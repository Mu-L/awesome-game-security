Project Path: arc_jtang613_GhidrAssist_4g8xxoqw

Source Tree:

```txt
arc_jtang613_GhidrAssist_4g8xxoqw
├── LICENSE
├── Module.manifest
├── README.md
├── build.gradle
├── data
│   └── README.txt
├── docs
│   ├── getting-started.md
│   ├── index.md
│   ├── screenshots
│   │   ├── actions-tab-interface.png
│   │   ├── add-provider-dialog.png
│   │   ├── explain-tab-interface.png
│   │   ├── main-interface.png
│   │   ├── query-tab-interface.png
│   │   ├── rag-tab-interface.png
│   │   ├── semantic-graph-tab-interface.png
│   │   ├── semantic-graph-visual-explore.png
│   │   └── settings-tab-full.png
│   ├── tabs
│   │   ├── actions-tab.md
│   │   ├── explain-tab.md
│   │   ├── query-tab.md
│   │   ├── rag-tab.md
│   │   ├── semantic-graph-tab.md
│   │   └── settings-tab.md
│   └── workflows
│       ├── explain-workflow.md
│       ├── query-workflow.md
│       └── semantic-graph-workflow.md
├── extension.properties
├── ghidra_scripts
│   └── README.txt
├── res
│   ├── screenshot1.png
│   └── screenshots_anim.gif
└── src
    └── main
        ├── help
        │   └── help
        │       ├── TOC_Source.xml
        │       └── topics
        │           └── ghidrassist
        │               └── help.html
        ├── java
        │   └── ghidrassist
        │       ├── AnalysisDB.java
        │       ├── GAUtils.java
        │       ├── GhidrAssistPlugin.java
        │       ├── GhidrAssistProvider.java
        │       ├── LlmApi.java
        │       ├── RLHFDatabase.java
        │       ├── agent
        │       │   └── react
        │       │       ├── ContextSummarizer.java
        │       │       ├── ConversationHistoryManager.java
        │       │       ├── FindingsCache.java
        │       │       ├── ReActOrchestrator.java
        │       │       ├── ReActProgressHandler.java
        │       │       ├── ReActPrompts.java
        │       │       ├── ReActResult.java
        │       │       └── TodoListManager.java
        │       ├── apiprovider
        │       │   ├── APIProvider.java
        │       │   ├── APIProviderConfig.java
        │       │   ├── APIProviderLogger.java
        │       │   ├── AnthropicClaudeCliProvider.java
        │       │   ├── AnthropicOAuthProvider.java
        │       │   ├── AnthropicPlatformApiProvider.java
        │       │   ├── AzureOpenAIProvider.java
        │       │   ├── ChatMessage.java
        │       │   ├── CodexInstructions.java
        │       │   ├── ErrorAction.java
        │       │   ├── ErrorMessageBuilder.java
        │       │   ├── GeminiOAuthProvider.java
        │       │   ├── GeminiPlatformApiProvider.java
        │       │   ├── LMStudioProvider.java
        │       │   ├── LiteLLMProvider.java
        │       │   ├── OllamaProvider.java
        │       │   ├── OpenAIOAuthProvider.java
        │       │   ├── OpenAIPlatformApiProvider.java
        │       │   ├── OpenWebUiProvider.java
        │       │   ├── ReasoningConfig.java
        │       │   ├── RetryHandler.java
        │       │   ├── XaiPlatformApiProvider.java
        │       │   ├── capabilities
        │       │   │   ├── ChatProvider.java
        │       │   │   ├── EmbeddingProvider.java
        │       │   │   ├── FunctionCallingProvider.java
        │       │   │   └── ModelListProvider.java
        │       │   ├── exceptions
        │       │   │   ├── APIProviderException.java
        │       │   │   ├── AuthenticationException.java
        │       │   │   ├── ModelException.java
        │       │   │   ├── NetworkException.java
        │       │   │   ├── RateLimitException.java
        │       │   │   ├── ResponseException.java
        │       │   │   └── StreamCancelledException.java
        │       │   ├── factory
        │       │   │   ├── APIProviderFactory.java
        │       │   │   ├── AnthropicClaudeCliProviderFactory.java
        │       │   │   ├── AnthropicOAuthProviderFactory.java
        │       │   │   ├── AnthropicPlatformApiProviderFactory.java
        │       │   │   ├── AzureOpenAIProviderFactory.java
        │       │   │   ├── GeminiOAuthProviderFactory.java
        │       │   │   ├── GeminiPlatformApiProviderFactory.java
        │       │   │   ├── LMStudioProviderFactory.java
        │       │   │   ├── LiteLLMProviderFactory.java
        │       │   │   ├── OllamaProviderFactory.java
        │       │   │   ├── OpenAIOAuthProviderFactory.java
        │       │   │   ├── OpenAIPlatformApiProviderFactory.java
        │       │   │   ├── OpenWebUiProviderFactory.java
        │       │   │   ├── ProviderRegistry.java
        │       │   │   ├── UnsupportedProviderException.java
        │       │   │   └── XaiPlatformApiProviderFactory.java
        │       │   └── oauth
        │       │       ├── GeminiOAuthTokenManager.java
        │       │       ├── OAuthCallbackServer.java
        │       │       ├── OAuthTokenManager.java
        │       │       ├── OpenAICodexOAuthTest.java
        │       │       └── OpenAIOAuthTokenManager.java
        │       ├── chat
        │       │   ├── ChangeType.java
        │       │   ├── ChatChange.java
        │       │   ├── ChatEditManager.java
        │       │   ├── PersistedChatMessage.java
        │       │   ├── message
        │       │   │   ├── MessageRepository.java
        │       │   │   ├── MessageStore.java
        │       │   │   └── ThreadSafeMessageStore.java
        │       │   ├── persistence
        │       │   │   ├── ChatHistoryDAO.java
        │       │   │   ├── SqliteTransactionManager.java
        │       │   │   └── TransactionManager.java
        │       │   ├── session
        │       │   │   ├── ChatSession.java
        │       │   │   ├── ChatSessionManager.java
        │       │   │   └── ChatSessionRepository.java
        │       │   └── util
        │       │       └── RoleNormalizer.java
        │       ├── context
        │       │   ├── CharacterBasedTokenCounter.java
        │       │   ├── ContextStatus.java
        │       │   ├── ContextWindowConfig.java
        │       │   ├── ContextWindowManager.java
        │       │   ├── ProviderTokenCounter.java
        │       │   ├── TokenCounter.java
        │       │   └── ToolPair.java
        │       ├── core
        │       │   ├── ActionConstants.java
        │       │   ├── ActionExecutor.java
        │       │   ├── ActionParser.java
        │       │   ├── CodeUtils.java
        │       │   ├── ConversationalToolHandler.java
        │       │   ├── LlmApiClient.java
        │       │   ├── LlmErrorHandler.java
        │       │   ├── LlmTaskExecutor.java
        │       │   ├── MarkdownHelper.java
        │       │   ├── OperationStateManager.java
        │       │   ├── QueryProcessor.java
        │       │   ├── RAGDocumentInfo.java
        │       │   ├── RAGEngine.java
        │       │   ├── ResponseProcessor.java
        │       │   ├── SearchResult.java
        │       │   ├── SemanticGraphController.java
        │       │   ├── StreamingResponseManager.java
        │       │   ├── SymGraphController.java
        │       │   ├── TabController.java
        │       │   ├── UIState.java
        │       │   ├── WorkerExecutor.java
        │       │   └── streaming
        │       │       ├── BlockBoundaryDetector.java
        │       │       ├── RenderUpdate.java
        │       │       ├── StreamingMarkdownRenderer.java
        │       │       └── StreamingScrollManager.java
        │       ├── db
        │       │   └── migration
        │       │       ├── SchemaMigration.java
        │       │       ├── SchemaMigrationRunner.java
        │       │       ├── SchemaVersionDetector.java
        │       │       ├── V1_BaseSchema.java
        │       │       ├── V2_GraphRAGCore.java
        │       │       ├── V3_SecurityColumns.java
        │       │       ├── V4_UserEditedColumn.java
        │       │       ├── V5_UniqueAddressIndex.java
        │       │       └── V6_LineExplanations.java
        │       ├── graphrag
        │       │   ├── BinaryKnowledgeGraph.java
        │       │   ├── GraphRAGEngine.java
        │       │   ├── GraphRAGService.java
        │       │   ├── analysis
        │       │   │   └── TaintAnalyzer.java
        │       │   ├── community
        │       │   │   ├── Community.java
        │       │   │   └── CommunityDetector.java
        │       │   ├── extraction
        │       │   │   ├── BackgroundIndexer.java
        │       │   │   ├── ExtractionPrompts.java
        │       │   │   ├── SecurityFeatureExtractor.java
        │       │   │   ├── SecurityFeatures.java
        │       │   │   ├── SemanticExtractor.java
        │       │   │   └── StructureExtractor.java
        │       │   ├── nodes
        │       │   │   ├── EdgeType.java
        │       │   │   ├── KnowledgeNode.java
        │       │   │   └── NodeType.java
        │       │   └── query
        │       │       ├── CallContext.java
        │       │       ├── GlobalQueryResult.java
        │       │       ├── ModuleSummary.java
        │       │       ├── SearchResult.java
        │       │       ├── SecurityAnalysis.java
        │       │       ├── SemanticAnalysis.java
        │       │       ├── SemanticQueryTools.java
        │       │       └── SimilarFunction.java
        │       ├── mcp2
        │       │   ├── prompts
        │       │   │   ├── MCPPrompt.java
        │       │   │   └── MCPPromptArgument.java
        │       │   ├── protocol
        │       │   │   └── MCPClientAdapter.java
        │       │   ├── resources
        │       │   │   └── MCPResource.java
        │       │   ├── server
        │       │   │   ├── MCPServerConfig.java
        │       │   │   └── MCPServerRegistry.java
        │       │   └── tools
        │       │       ├── BinaryContextInjector.java
        │       │       ├── MCPTool.java
        │       │       ├── MCPToolAdapter.java
        │       │       ├── MCPToolManager.java
        │       │       └── MCPToolResult.java
        │       ├── resources
        │       │   └── GhidrAssistIcons.java
        │       ├── services
        │       │   ├── ActionAnalysisService.java
        │       │   ├── AnalysisDataService.java
        │       │   ├── CodeAnalysisService.java
        │       │   ├── FeedbackService.java
        │       │   ├── QueryService.java
        │       │   ├── RAGManagementService.java
        │       │   └── symgraph
        │       │       ├── SymGraphModels.java
        │       │       ├── SymGraphService.java
        │       │       └── SymGraphUtils.java
        │       ├── tools
        │       │   ├── api
        │       │   │   ├── Tool.java
        │       │   │   ├── ToolExecutor.java
        │       │   │   ├── ToolProvider.java
        │       │   │   └── ToolResult.java
        │       │   ├── native_
        │       │   │   ├── ActionToolProvider.java
        │       │   │   ├── GhidraToolProvider.java
        │       │   │   ├── NativeTool.java
        │       │   │   ├── NativeToolManager.java
        │       │   │   └── SemanticToolProvider.java
        │       │   └── registry
        │       │       └── ToolRegistry.java
        │       ├── ui
        │       │   ├── EnhancedErrorDialog.java
        │       │   ├── GhidrAssistUI.java
        │       │   ├── common
        │       │   │   ├── PlaceholderTextField.java
        │       │   │   └── UIConstants.java
        │       │   └── tabs
        │       │       ├── ActionsTab.java
        │       │       ├── ExplainTab.java
        │       │       ├── MCPServerDialog.java
        │       │       ├── MCPServersTab.java
        │       │       ├── QueryTab.java
        │       │       ├── RAGManagementTab.java
        │       │       ├── SemanticGraphTab.java
        │       │       ├── SettingsTab.java
        │       │       ├── SymGraphTab.java
        │       │       └── semanticgraph
        │       │           ├── GraphViewPanel.java
        │       │           ├── ListViewPanel.java
        │       │           ├── ManualAnalysisPanel.java
        │       │           └── SearchViewPanel.java
        │       └── workers
        │           ├── AnalysisWorker.java
        │           ├── CommunityDetectionWorker.java
        │           ├── NetworkFlowAnalysisWorker.java
        │           ├── ProgressUpdate.java
        │           ├── RefreshNamesWorker.java
        │           ├── ReindexWorker.java
        │           ├── SecurityAnalysisWorker.java
        │           ├── SemanticAnalysisWorker.java
        │           ├── SwingWorkerTaskMonitor.java
        │           ├── SymGraphApplyWorker.java
        │           └── SymGraphPullWorker.java
        └── resources
            └── images
                ├── README.txt
                ├── robot.svg
                ├── robot16.png
                └── robot32.png

```

`LICENSE`:

```
Copyright (c) 2025 Jason Tang

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

`README.md`:

```md
# GhidrAssist
Author: **Jason Tang**

_An advanced LLM-powered plugin for interactive reverse engineering assistance in Ghidra._

## Description

GhidrAssist integrates Large Language Models (LLMs) into Ghidra to provide intelligent assistance for binary exploration and reverse engineering. It supports any OpenAI v1-compatible API, including local models (Ollama, LM-Studio, Open-WebUI) and cloud providers (OpenAI, Anthropic, Azure).

### Key Features

**Core Functionality:**
* **Code Explanation** - Explain functions and instructions in both disassembly and decompiled pseudo-C
  - Security analysis panel showing risk level, activity profile, and API usage
  - Editable summaries with user-edit protection from auto-overwrite
* **Interactive Chat** - Multi-turn conversational queries with persistent chat history
* **Custom Queries** - Direct LLM queries with optional context from current function/location

**Graph-RAG Knowledge System:**
* **Semantic Knowledge Graph** - Hierarchical representation of binary analysis
  - 5-level semantic hierarchy: Statement → Block → Function → Module → Binary
  - Pre-computed LLM summaries enable fast, LLM-free queries
  - SQLite persistence with JGraphT graph algorithms
  - Full-text search (FTS5) on summaries and security annotations
* **Community Detection** - Automatic module discovery via Leiden algorithm
  - Groups related functions into logical modules
  - Hierarchical community structure with summaries
  - Visual graph exploration with configurable depth
* **Security Feature Extraction** - Comprehensive security analysis
  - Network APIs: POSIX sockets, WinSock, DNS, SSL/TLS, WinHTTP, WinINet
  - File I/O APIs: POSIX, Windows, C library functions
  - Crypto APIs: OpenSSL, Windows crypto, platform-specific
  - String patterns: IP addresses, URLs, domains, file paths, registry keys
  - Risk level classification (LOW/MEDIUM/HIGH) and activity profiling
* **Semantic Graph Tab** - Visual knowledge graph interface
  - Graph view with N-hop depth exploration
  - List view of all indexed functions
  - Semantic search across summaries
  - One-click re-indexing and security analysis

**Advanced Capabilities:**
* **Extended Thinking/Reasoning Control** - Adjust LLM reasoning depth for quality vs. speed trade-offs
  - Support for OpenAI o1/o3/o4, Claude with extended thinking, and local reasoning models
  - Configurable effort levels: Low (fast), Medium (balanced), High (thorough)
  - Per-program persistence - different binaries can use different reasoning levels
  - Provider-agnostic implementation (Anthropic, OpenAI, Azure, LiteLLM, LMStudio, Ollama)
* **ReAct Agentic Mode** - Autonomous investigation using structured reasoning (Think-Act-Observe)
  - LLM proposes investigation steps based on your query
  - Systematic tool execution with progress tracking via todo lists
  - Iteration history preservation showing all investigation steps
  - Final synthesis with comprehensive answer and key findings
  - Accurate metrics (iterations, tool calls, duration)
* **MCP Integration** - Model Context Protocol client for tool-based analysis
  - Works with [GhidrAssistMCP](https://github.com/jtang613/GhidrAssistMCP) for Ghidra-specific tools
  - Conversational tool calling with automatic function execution
  - Support for SSE (Server-Sent Events) transport
* **Function Calling** - LLM can autonomously navigate binaries and modify analysis
  - Rename functions and variables
  - Navigate to addresses and cross-references
  - Execute Ghidra commands
* **Actions Tab** - Propose and apply bulk analysis improvements
  - Security vulnerability detection
  - Code quality analysis
  - Automated refactoring suggestions
* **RAG (Retrieval Augmented Generation)** - Enhance queries with contextual documents
  - Add custom documentation, exploit notes, architecture references
  - Lucene-based full-text search
  - Context injection into queries
* **RLHF Dataset Generation** - Collect feedback for model fine-tuning


### Architecture

The plugin uses a modular, service-oriented architecture:

**Core Services:**
- **Query Modes**: Regular queries, MCP-enhanced queries, or full agentic investigation
- **ReAct Orchestrator**: Manages autonomous investigation loops with todo tracking and findings accumulation
- **Conversational Tool Handler**: Manages multi-turn tool calling sessions
- **MCPToolManager**: Interfaces with external MCP servers for specialized tools

**Graph-RAG Backend:**
- **BinaryKnowledgeGraph**: Hybrid SQLite + JGraphT storage for semantic knowledge
- **GraphRAGEngine**: LLM-free query engine using pre-computed summaries
- **SemanticExtractor**: LLM-powered function summarization with batch processing
- **SecurityFeatureExtractor**: Static analysis for network, file I/O, and crypto APIs
- **CommunityDetector**: Leiden algorithm implementation for module discovery

**Data Layer:**
- **AnalysisDB**: SQLite database for chat history, RLHF feedback, and knowledge graphs
- **SchemaMigrationRunner**: Versioned database migrations for transparent upgrades
- **RAGEngine**: Lucene-powered document search for custom context injection

**UI Components:**
- Tab-based interface: Explain, Query, Actions, Semantic Graph, RAG Management, MCP Servers
- Service orchestration via TabController

Future Roadmap:
* Model fine-tuning using collected RLHF dataset
* Additional MCP tool integrations
* Enhanced agentic capabilities, multi-agent collaboration
* Embedding-based similarity search

## Screenshots

![Screenshot](https://github.com/user-attachments/assets/f5476e0d-5e30-4855-90a9-e0dbf39e16c7)


https://github.com/user-attachments/assets/bd79474a-c82f-4083-b432-96625fef1387


## Quickstart

* If necessary, copy the binary release ZIP archive to the Ghidra_Install/Extensions/Ghidra directory.
* Launch Ghidra -> File -> Install Extension -> Enable GhidrAssist.
* Load a binary and launch the CodeBrowser.
* CodeBrowser -> File -> Configure -> Miscellaneous -> Enable GhidrAssist.
* CodeBrowser -> Tools -> GhidraAssist Settings.
* Ensure the RLHF and RAG database paths are appropriate for your environment.
* Point the API host to your preferred API provider and set the API key.
* (Optional) In the Analysis Options tab, set the Reasoning Effort level (None/Low/Medium/High) for models that support extended thinking.
* Open GhidrAssist with the GhidrAssist option in the Windows menu and start exploring.

## LLM Setup

GhidrAssist works with any OpenAI v1-compatible API. Setup details are provider-specific - here are some helpful resources:

**Local LLM Providers:**
- [LM Studio](https://lmstudio.ai/docs/basics) - Easy local model hosting with GUI
- [Ollama](https://github.com/ollama/ollama#running-local-builds) - Command-line local model management
- Open-WebUI - Web interface for local models

**Cloud Providers:**
- [OpenAI API](https://help.openai.com/en/articles/4936850-where-do-i-find-my-openai-api-key)
- [Anthropic Claude](https://docs.anthropic.com/en/docs/initial-setup)
- Azure OpenAI

**LiteLLM Proxy (Multi-Provider Gateway):**
- [LiteLLM](https://docs.litellm.ai/) - Unified API for 100+ LLM providers
- Supports AWS Bedrock, Google Vertex AI, Azure, and many others
- Select "LiteLLM" as provider type in GhidrAssist settings
- Automatic model family detection for proper message formatting

### Recommended Models

**For Agentic Mode (requires strong reasoning and tool use):**
- **Cloud**: GPT-5.1, Claude Sonnet 4.5
- **Local**: GPT-OSS, Llama 3.3 70B, DeepSeek-R1 70B, Qwen2.5 72B

**Models with Extended Thinking/Reasoning Support:**
- **OpenAI**: o1-preview, o1-mini, o3-mini, o4-mini, gpt-5 (use `reasoning_effort` parameter)
- **Anthropic**: Claude Sonnet 4.5, Claude Opus 4.5, Claude Haiku 4.5, Claude Opus 4.1/4, Claude Sonnet 4 (use `thinking.budget_tokens` parameter)
- **Local**: openai/gpt-oss-20b via Ollama/LMStudio (supports effort levels)

**Reasoning Effort Guidelines:**
- **Low**: Quick analysis, minimal thinking tokens (~5-10s, lower cost)
- **Medium**: Balanced reasoning depth (~15-30s, moderate cost)
- **High**: Deep security analysis (~30-60s, 2x cost, recommended for vulnerability hunting)

**Note**: Agentic mode requires models with strong function calling and multi-step reasoning capabilities. Smaller models may struggle with complex investigations. Extended thinking is optional but can significantly improve analysis quality for complex reverse engineering tasks.

## Using GhidrAssistMCP for Tool-Based Analysis

[GhidrAssistMCP](https://github.com/jtang613/GhidrAssistMCP) provides MCP tools that allow the LLM to interact directly with Ghidra's analysis capabilities.

### Setup

1. **Start the MCP Server**

2. **Configure GhidrAssist:**
   - Open Tools → GhidrAssist Settings → MCP Servers tab
   - Add server: `http://127.0.0.1:8081` as `GhidrAssistMCP` with transport type `SSE`

3. **Enable MCP in queries:**
   - In the Custom Query tab, check "Use MCP"
   - Optionally enable "Agentic" for autonomous investigation mode

### Usage Modes

**Regular MCP Queries:**
- Enable "Use MCP" checkbox
- Ask questions like "What does the current function do?"
- LLM can call tools to get decompilation, cross-references, etc.

**Agentic Mode (Recommended):**
- Enable both "Use MCP" and "Agentic" checkboxes
- Ask complex questions like "Find vulnerabilities in this function" or "Analyze the call graph"
- The ReAct agent will:
  1. Propose investigation steps as a todo list
  2. Systematically execute tools to gather information
  3. Track progress and accumulate findings
  4. Synthesize a comprehensive answer with evidence

**Example Queries:**
- "What security vulnerabilities exist in this function?"
- "Trace the data flow from user input to this call"
- "Find all functions that modify global variable X"
- "Analyze the error handling in the current function"

## Using the Semantic Graph (Graph-RAG)

The Semantic Graph tab provides a knowledge graph interface for exploring binary analysis results without requiring LLM calls for every query.

### Getting Started

1. **Index the Binary:**
   - Open the Semantic Graph tab
   - Click "ReIndex Binary" to extract structural relationships
   - Click "Semantic Analysis" to generate LLM summaries (requires API)
   - Progress is shown in the status bar

2. **Explore the Graph:**
   - **List View**: Browse all indexed functions with summaries and security flags
   - **Graph View**: Visualize call relationships with configurable N-hop depth
   - **Search View**: Full-text search across summaries and security annotations

3. **Security Analysis:**
   - Click "Security Analysis" to scan for security-relevant features
   - Results include: network APIs, file I/O, crypto usage, string patterns
   - Risk levels (LOW/MEDIUM/HIGH) are assigned based on detected features

### Explain Tab Integration

When viewing a function in the Explain tab:
- If the function is indexed, the pre-computed summary is shown instantly
- Security panel displays: risk level, activity profile, APIs used
- Click "Edit" to modify summaries (protected from auto-overwrite)
- Use "Refresh" to re-generate the summary with the LLM

### Benefits

- **Fast Queries**: Pre-computed summaries eliminate LLM latency for repeat queries
- **Offline Analysis**: Browse indexed data without API connectivity
- **Security Focus**: Automatic detection of security-relevant code patterns
- **Module Discovery**: Community detection groups related functions automatically

## Homepage
https://github.com/jtang613/GhidrAssist


## Minimum Version

This plugin requires the following minimum version of Ghidra:

* 11.0

## License

This plugin is released under a MIT license.

```

`build.gradle`:

```gradle
/*
 *
 */
// Builds a Ghidra Extension for a given Ghidra installation.
//
// An absolute path to the Ghidra installation directory must be supplied either by setting the 
// GHIDRA_INSTALL_DIR environment variable or Gradle project property:
//
//     > export GHIDRA_INSTALL_DIR=<Absolute path to Ghidra> 
//     > gradle
//
//         or
//
//     > gradle -PGHIDRA_INSTALL_DIR=<Absolute path to Ghidra>
//
// Gradle should be invoked from the directory of the project to build.  Please see the
// application.gradle.version property in <GHIDRA_INSTALL_DIR>/Ghidra/application.properties
// for the correction version of Gradle to use for the Ghidra installation you specify.

plugins {
    id 'java'
    id 'eclipse'
}

//----------------------START "DO NOT MODIFY" SECTION------------------------------
def ghidraInstallDir

if (System.env.GHIDRA_INSTALL_DIR) {
	ghidraInstallDir = System.env.GHIDRA_INSTALL_DIR
}
else if (project.hasProperty("GHIDRA_INSTALL_DIR")) {
	ghidraInstallDir = project.getProperty("GHIDRA_INSTALL_DIR")
}

if (ghidraInstallDir) {
	apply from: new File(ghidraInstallDir).getCanonicalPath() + "/support/buildExtension.gradle"
}
else {
	throw new GradleException("GHIDRA_INSTALL_DIR is not defined!")
}
//----------------------END "DO NOT MODIFY" SECTION-------------------------------

repositories {
	// Declare dependency repositories here.  This is not needed if dependencies are manually
	// dropped into the lib/ directory.
	// See https://docs.gradle.org/current/userguide/declaring_repositories.html for more info.
	mavenCentral()
	maven { url 'https://jitpack.io' }
}

dependencies {
	// Any external dependencies added here will automatically be copied to the lib/ directory when
	// this extension is built.	

	implementation 'com.fasterxml.jackson.core:jackson-databind:2.15.0'
	implementation "io.reactivex.rxjava3:rxjava:3.1.9"
	implementation 'com.vladsch.flexmark:flexmark:0.64.0'
	implementation 'com.vladsch.flexmark:flexmark-html2md-converter:0.64.0'
	implementation 'com.vladsch.flexmark:flexmark-ext-tables:0.64.0'
	implementation 'org.xerial:sqlite-jdbc:3.46.1.0'
	implementation 'org.apache.lucene:lucene-core:9.11.1'
	implementation 'org.apache.lucene:lucene-analysis-common:9.11.1'
	implementation 'org.apache.lucene:lucene-queryparser:9.11.1'
	implementation 'com.squareup.okio:okio:3.10.2'
	implementation "com.squareup.okhttp3:okhttp:4.12.0"
	
	// MCP SDK core dependency
	implementation 'io.modelcontextprotocol.sdk:mcp:0.17.1'

	// Project Reactor dependency for async MCP client
	implementation 'io.projectreactor:reactor-core:3.6.0'

	// JGraphT - Graph algorithms for Graph-RAG (community detection, traversal)
	implementation 'org.jgrapht:jgrapht-core:1.5.2'

	// JGraphX - Visual graph rendering for Semantic Graph tab
	implementation 'com.github.vlsi.mxgraph:jgraphx:4.2.2'
}

// Exclude additional files from the built extension
// Ex: buildExtension.exclude '.idea/**'
buildExtension.exclude '**/*.db'
buildExtension.exclude '**/*.db-journal'
buildExtension.exclude '**/*.db-wal'
buildExtension.exclude '**/*.db-shm'

```

`data/README.txt`:

```txt
The "data" directory is intended to hold data files that will be used by this module and will
not end up in the .jar file, but will be present in the zip or tar file.  Typically, data
files are placed here rather than in the resources directory if the user may need to edit them.

An optional data/languages directory can exist for the purpose of containing various Sleigh language
specification files and importer opinion files.  

The data/buildLanguage.xml is used for building the contents of the data/languages directory.

The skel language definition has been commented-out within the skel.ldefs file so that the 
skeleton language does not show-up within Ghidra.

See the Sleigh language documentation (docs/languages/index.html) for details Sleigh language 
specification syntax.
 
```

`docs/getting-started.md`:

```md
# Getting Started with GhidrAssist

This guide helps you install GhidrAssist, configure an LLM provider, and run your first analysis in Ghidra.

## Prerequisites

Before installing GhidrAssist, ensure you have:

- **Ghidra**: Version 11.0 or higher
- **Internet connection**: For cloud providers or downloading local models
- **Python (optional)**: For some local tooling, depending on your MCP server setup

## Installation

GhidrAssist is installed as a Ghidra extension.

### Step 1: Install the Extension

**Option A: Extension Manager (Recommended)**

1. Download the GhidrAssist release ZIP
2. Open Ghidra
3. Go to **File → Install Extensions**
4. Click the **+** button and select the ZIP
5. Enable the extension and restart Ghidra

**Option B: Manual Install**

1. Copy the release ZIP into:
   - `Ghidra_Install/Extensions/Ghidra/`
2. Restart Ghidra
3. Enable the extension in **File → Install Extensions**

### Step 2: Enable the Plugin

1. Open or create a project
2. Launch **CodeBrowser**
3. Go to **File → Configure → Miscellaneous**
4. Check **Enable GhidrAssist**

### Step 3: Open GhidrAssist

1. In CodeBrowser, open **Window → GhidrAssist**
2. The GhidrAssist panel appears with the tab interface

![GhidrAssist Window](screenshots/ghidrassist-window.png)
<!-- SCREENSHOT: Ghidra CodeBrowser with GhidrAssist window open and docked -->

## Initial Configuration

You need to configure at least one LLM provider.

### Accessing Settings

1. In the GhidrAssist panel, click the **Settings** tab
2. The LLM Providers section appears at the top

![Settings Tab](screenshots/settings-tab-overview.png)
<!-- SCREENSHOT: Settings tab showing empty LLM providers table with Add button visible -->

## Setting Up an LLM Provider

GhidrAssist supports multiple providers. Choose the one that fits your needs:

### Option 1: Ollama (Local, Free, Private)

Ollama runs models locally on your machine.

**Step 1: Install Ollama**

```bash
# Linux/macOS
curl -fsSL https://ollama.ai/install.sh | sh

# Windows: Download from https://ollama.ai/download
```

**Step 2: Pull a Model**

```bash
# General purpose model
ollama pull llama3.1:8b

# Reasoning model (recommended for complex analysis)
ollama pull gpt-oss:20b

# Start the server
ollama serve
```

**Step 3: Configure in GhidrAssist**

1. In Settings, click **Add** in LLM Providers
2. Fill in:
   - **Name**: `Ollama Local`
   - **Type**: `Ollama`
   - **Model**: `gpt-oss:20b`
   - **URL**: `http://localhost:11434`
   - **API Key**: Leave empty
   - **Max Tokens**: `16384`
3. Click **Save**
4. Click **Test**

![Add Ollama Provider](screenshots/add-provider-ollama.png)
<!-- SCREENSHOT: Add Provider dialog filled out for Ollama with localhost URL -->

### Option 2: OpenAI Platform API

Use OpenAI models with a paid API key.

**Step 1: Get an API Key**

1. Go to [platform.openai.com](https://platform.openai.com/)
2. Create an API key from the dashboard

**Step 2: Configure in GhidrAssist**

1. Click **Add** in LLM Providers
2. Fill in:
   - **Name**: `OpenAI`
   - **Type**: `OpenAI Platform API`
   - **Model**: `gpt-5.2-codex`
   - **URL**: Leave empty (default)
   - **API Key**: Paste your API key
   - **Max Tokens**: `20000`
3. Click **Save**
4. Click **Test**

### Option 3: Anthropic Platform API

Use Claude models with a paid API key.

**Step 1: Get an API Key**

1. Go to [console.anthropic.com](https://console.anthropic.com/)
2. Create an API key

**Step 2: Configure in GhidrAssist**

1. Click **Add** in LLM Providers
2. Fill in:
   - **Name**: `Anthropic Claude`
   - **Type**: `Anthropic Platform API`
   - **Model**: `claude-sonnet-4-5`
   - **URL**: Leave empty (default)
   - **API Key**: Paste your API key
   - **Max Tokens**: `20000`
3. Click **Save**
4. Click **Test**

### Option 4: OAuth Providers (Claude Pro/Max or ChatGPT Pro/Plus)

If you have a Claude Pro/Max or ChatGPT Pro/Plus subscription, use OAuth instead of an API key.

**Claude Pro/Max:**

1. Click **Add** in LLM Providers
2. Select **Type**: `Anthropic OAuth`
3. Enter **Name** and **Model** (e.g., `claude-sonnet-4-5`)
4. Click **Authenticate**
5. A browser window opens for login
6. After authorization, credentials are saved automatically
7. Click **Save**

**ChatGPT Pro/Plus:**

1. Click **Add** in LLM Providers
2. Select **Type**: `OpenAI OAuth`
3. Enter **Name** and **Model** (e.g., `gpt-5.2-codex`)
4. Click **Authenticate**
5. A browser window opens for login
6. After authorization, credentials are saved automatically
7. Click **Save**

![OAuth Authentication](screenshots/oauth-authenticate.png)
<!-- SCREENSHOT: Add Provider dialog showing OAuth type selected with Authenticate button -->

### Setting the Active Provider

1. Use the **Active Provider** dropdown at the bottom of the LLM Providers section
2. Select the provider you want to use

## Your First Analysis

### Step 1: Load a Binary

1. Open a binary in Ghidra
2. Wait for auto-analysis to complete

### Step 2: Navigate to a Function

1. In the Functions window, click a function
2. Or press **G** and enter an address

### Step 3: Explain the Function

1. Open the GhidrAssist panel
2. Click the **Explain** tab
3. Click **Explain Function**
4. Wait for the explanation to stream in

![First Explanation](screenshots/first-explanation.png)
<!-- SCREENSHOT: Explain tab showing a function explanation with the response text visible -->

### Step 4: Ask a Question

1. Switch to the **Query** tab
2. Type a question, for example:
   - "What does this function do?"
   - "Are there any security concerns here?"
   - "What functions does this call?"
3. Click **Submit**
4. Watch the response stream in

## Next Steps

Explore these guides:

- [Explain Workflow](workflows/explain-workflow.md)
- [Query Workflow](workflows/query-workflow.md)
- [Semantic Graph Workflow](workflows/semantic-graph-workflow.md)
- [Settings Reference](tabs/settings-tab.md)

## Troubleshooting

### "Connection failed" when testing provider

- **Ollama**: Ensure `ollama serve` is running
- **Cloud providers**: Verify your API key is correct
- **Network issues**: Check firewall and proxy settings

### No response from LLM

- Check **Window → Console** in Ghidra for errors
- Verify the model name is correct
- Ensure you have sufficient API credits

### Plugin not appearing

- Restart Ghidra after installation
- Confirm the extension is enabled
- Ensure it is enabled in **File → Configure → Miscellaneous**

### Slow responses

- Local models: Use a smaller model or a GPU
- Cloud models: Reasoning models are slower by design
- Large functions: Analyze smaller functions first

```

`docs/index.md`:

```md
# GhidrAssist Documentation

**GhidrAssist** is a comprehensive LLM-powered plugin for Ghidra that enhances reverse engineering workflows through intelligent automation.

![GhidrAssist Main Interface](screenshots/main-interface.png)
<!-- SCREENSHOT: Ghidra CodeBrowser with the GhidrAssist sidebar visible, tab bar showing all seven tabs, Explain tab active -->

## What is GhidrAssist?

GhidrAssist integrates large language models directly into your Ghidra workflow. Instead of switching between tools or copying code snippets, you can ask questions, generate explanations, and receive intelligent suggestions without leaving CodeBrowser.

The plugin supports local LLMs (Ollama, LM Studio) and cloud providers (OpenAI, Anthropic), letting you choose between privacy, cost, and performance.

## Core Capabilities

GhidrAssist is organized into seven tabs, each focused on a specific aspect of LLM-assisted analysis:

| Tab | Purpose |
|-----|---------|
| **[Explain](tabs/explain-tab.md)** | Generate and store function explanations with security analysis |
| **[Query](tabs/query-tab.md)** | Interactive chat with context macros and autonomous ReAct agent |
| **[Actions](tabs/actions-tab.md)** | LLM-powered suggestions for renaming, retyping, and struct creation |
| **[Semantic Graph](tabs/semantic-graph-tab.md)** | Build a knowledge graph of function relationships and security properties |
| **[RAG](tabs/rag-tab.md)** | Manage external documentation for context-enhanced queries |
| **[Settings](tabs/settings-tab.md)** | Configure LLM providers, MCP servers, and plugin options |

## Key Features

### MCP Tool Integration

GhidrAssist supports the Model Context Protocol (MCP), allowing LLMs to interact with Ghidra through tool calls. When MCP is enabled, the LLM can:

- Navigate to functions and addresses
- Retrieve decompiled code and disassembly
- Query cross-references
- Access the semantic graph
- Use external MCP servers for specialized tooling

See the [Query Workflow](workflows/query-workflow.md) for details on using MCP tools.

### ReAct Autonomous Agent

For complex investigations, GhidrAssist includes a ReAct (Reasoning + Acting) agent that can autonomously:

1. Plan an investigation based on your question
2. Execute multiple tool calls to gather information
3. Reflect on findings and adapt its approach
4. Synthesize a comprehensive answer

This is useful for exploratory questions like "What does this binary do?" or "Trace the data flow from user input."

### Extended Thinking

For models that support it (Claude Sonnet 4+, OpenAI o1/o3, local reasoning models), GhidrAssist provides reasoning effort control:

| Level | Use Case |
|-------|----------|
| None | Quick queries, simple questions |
| Low | Light reasoning tasks |
| Medium | Moderate complexity analysis |
| High | Deep analysis, complex vulnerability research |

Higher reasoning effort allows the model more "thinking time" but increases latency and cost.

### Semantic Graph

Build a rich knowledge graph of your binary that captures:

- Function summaries and purposes
- Call relationships
- Security flags (network, file I/O, crypto, etc.)
- Taint flow paths for vulnerability detection
- Function communities and modules

The graph can be queried directly or used to enhance LLM responses.

### SymGraph Cloud Sharing

Share your analysis with the community through SymGraph:

- Push function names, types, and semantic graph data
- Pull existing analysis from other researchers
- Resolve conflicts between local and cloud symbols

## Supported LLM Providers

GhidrAssist supports a wide range of LLM providers:

| Provider Type | Description |
|---------------|-------------|
| **Ollama** | Local LLM inference (recommended for privacy) |
| **LM Studio** | Local models with GUI |
| **Open WebUI** | Self-hosted web interface |
| **OpenAI Platform API** | GPT-5+, GPT-4o, o1, o3, o4 with API key |
| **OpenAI OAuth** | ChatGPT Pro/Plus subscription |
| **Anthropic Platform API** | Claude models with API key |
| **Anthropic OAuth** | Claude Pro/Max subscription |
| **Anthropic CLI** | Claude Code CLI wrapper |
| **LiteLLM** | Proxy for 100+ providers (AWS Bedrock, Azure, etc.) |

### Recommended Models

- **Reasoning-intensive tasks**: Claude Sonnet 4+, OpenAI GPT-5.2, gpt-oss (extended thinking)
- **General analysis**: GPT-5.2-Codex, Claude Sonnet 3.5, DeepSeek, Llama-based models
- **Local/private analysis**: Ollama with gpt-oss, qwen2.5-coder, or codellama

## Architecture Overview

GhidrAssist uses a Model-View-Controller architecture:

- **Views**: Swing-based UI components for each tab
- **Controllers**: Business logic and LLM orchestration
- **Services**: Reusable services for settings, analysis storage, RAG, and more

All LLM operations run in background tasks so the UI stays responsive, with streaming for real-time output.

## Getting Started

Ready to start using GhidrAssist? See the [Getting Started Guide](getting-started.md) for installation and configuration instructions.

## Common Workflows

- [Building Context with the Explain Tab](workflows/explain-workflow.md)
- [Interactive Queries and the ReAct Agent](workflows/query-workflow.md)
- [Building a Semantic Graph](workflows/semantic-graph-workflow.md)

## Tab Reference

- [Explain Tab](tabs/explain-tab.md)
- [Query Tab](tabs/query-tab.md)
- [Actions Tab](tabs/actions-tab.md)
- [Semantic Graph Tab](tabs/semantic-graph-tab.md)
- [RAG Tab](tabs/rag-tab.md)
- [Settings Tab](tabs/settings-tab.md)

```

`docs/tabs/actions-tab.md`:

```md
# Actions Tab Reference

The Actions tab provides LLM-powered suggestions for improving analysis, such as renaming functions, variables, retyping, and struct creation.

![Actions Tab Interface](../screenshots/actions-tab-interface.png)
<!-- SCREENSHOT: Actions tab showing action checkboxes, Analyze Function button, and results table -->

## Purpose

The Actions tab automates common reverse engineering cleanup tasks:

- Suggest meaningful function names
- Propose descriptive variable names
- Recommend better data types
- Generate structure definitions from access patterns

Each suggestion includes structured arguments and can be applied directly.

## Action Types

### Rename Function

Suggests a semantic name for the current function based on behavior.

### Rename Variable

Suggests clearer variable names based on usage patterns.

### Retype Variable

Proposes more accurate data types based on usage.

### Auto Create Struct

Generates structure definitions from offset access patterns.

## UI Elements

### Action Selection

Checkboxes let you choose which action types to analyze. All are enabled by default.

### Buttons

| Button | Description |
|--------|-------------|
| **Analyze Function** | Generate suggestions for selected action types |
| **Clear** | Clear the results table |
| **Apply Actions** | Apply checked suggestions |

### Results Table

| Column | Description |
|--------|-------------|
| **Select** | Checkbox to apply action |
| **Action** | Action type |
| **Description** | Human-readable summary |
| **Status** | Pending / Success / Failed |
| **Arguments** | Structured parameters for the action |

### Select All Header

The Select column header includes a checkbox to toggle all rows.

## Workflow

1. Navigate to a function in Ghidra
2. Open Actions tab
3. Select action types
4. Click **Analyze Function**
5. Review suggestions
6. Check the ones to apply
7. Click **Apply Actions**

## Tips

- Review suggestions before applying
- Use Explain or Query tabs to understand functions first
- Apply changes incrementally

## Related Documentation

- [Explain Tab](explain-tab.md)
- [Query Tab](query-tab.md)
- [Settings Tab](settings-tab.md)

```

`docs/tabs/explain-tab.md`:

```md
# Explain Tab Reference

The Explain tab generates and stores LLM-powered explanations of functions, with integrated security analysis and editing support.

![Explain Tab Interface](../screenshots/explain-tab-interface.png)
<!-- SCREENSHOT: Explain tab showing a function explanation with the security panel visible below -->

## Purpose

The Explain tab helps you build a documented understanding of a binary by:

- Generating detailed function explanations
- Providing security assessments and risk indicators
- Storing explanations for later reference
- Allowing you to edit and refine the output

## UI Elements

### Analysis Buttons

| Button | Description |
|--------|-------------|
| **Explain Function** | Analyze the entire current function |
| **Explain Line** | Statement-level analysis (coming soon) |
| **Clear** | Clear stored analysis for the current function |

**Explain Line** is currently disabled and marked as coming soon in GhidrAssist.

### Enhancement Options

GhidrAssist uses the global settings from the Query tab and Settings tab:

- **RAG**: Enable document context (see [RAG Tab](rag-tab.md))
- **MCP**: Enable tool calling for enhanced analysis

### Display Area

The main display area renders the LLM response as markdown, including:

- Function purpose and behavior
- Parameter and return value analysis
- Notable implementation details

### Security Analysis Panel

![Security Panel](../screenshots/explain-security-panel.png)
<!-- SCREENSHOT: Expanded security analysis panel showing Risk Level, Activity Profile, Flags, Network APIs, File I/O APIs -->

| Field | Description |
|--------|-------------|
| **Risk Level** | Overall security assessment (Low, Medium, High) |
| **Activity Profile** | Behavior category (e.g., "Network Communication") |
| **Security Flags** | Detected patterns and risks |
| **Network APIs** | Network-related calls detected |
| **File I/O APIs** | File operations detected |

The panel is hidden until analysis data is available.

### Edit Mode

Use the **Edit** button to modify explanations:

1. Click **Edit** to switch to markdown mode
2. Modify the content
3. Click **Save** to store changes

Edits are persisted in the analysis database and protected from auto-overwrite.

### Feedback

Use the thumbs up/down buttons to provide feedback on explanation quality.

## Function Context

The Explain tab tracks the current function based on the Ghidra cursor. If no function is selected, analysis buttons are disabled.

## Stored Explanations

Explanations are stored by:
- Binary SHA256 hash
- Function address

This allows you to return to the same function later and see the saved explanation.

## Related Documentation

- [Explain Workflow](../workflows/explain-workflow.md)
- [Query Tab](query-tab.md)
- [Settings Tab](settings-tab.md)

```

`docs/tabs/query-tab.md`:

```md
# Query Tab Reference

The Query tab provides an interactive chat interface for questions about your binary, with context macros, MCP tools, and the ReAct agent.

![Query Tab Interface](../screenshots/query-tab-interface.png)
<!-- SCREENSHOT: Query tab showing chat history on the left, response panel, and input box with Submit button -->

## Purpose

The Query tab enables free-form conversation with the LLM about your binary. It supports:

- Follow-up questions and multi-turn chats
- Context macros for function and address data
- MCP tool calling for interactive analysis
- ReAct autonomous agent for complex investigations

## UI Elements

### Chat History

The left panel shows saved conversations:

- **New**: Start a new chat
- **Delete**: Remove selected chat
- Each row shows a description and timestamp

### Response Area

The main panel displays:

- Your prompts
- LLM responses rendered as markdown
- Tool call outputs when MCP is enabled

### Input Area

At the bottom:

- Text input field
- **Submit** button (or Ctrl+Enter)
- **Stop** button (visible while generating)

### Enhancement Options

| Option | Description |
|--------|-------------|
| **Use RAG** | Include document context from the RAG index |
| **Use MCP Tools** | Enable tool calling |
| **Agentic Mode (ReAct)** | Enable autonomous investigation |

## Context Macros

Macros are replaced with binary context before the query is sent:

| Macro | Description |
|-------|-------------|
| `#func` | Current function code (decompiler or disassembly) |
| `#addr` | Data at the current address |
| `#line` | Current line (decompiler or disassembly) |
| `#range(start, end)` | Data in an address range |

**Example**:
```
What vulnerabilities exist in #func?
```

## MCP Tool Calling

When **Use MCP Tools** is enabled, the LLM can call tools to gather information:

![MCP Tool Call](../screenshots/query-mcp-tool-call.png)
<!-- SCREENSHOT: Query response showing tool calls with tool name, parameters, and results -->

Typical tool usage:
- Decompile current function
- Get cross-references
- Navigate to addresses
- Query the semantic graph

## ReAct Agent (Agentic Mode)

The ReAct agent performs multi-step investigations:

1. **Plan**: Create investigation steps
2. **Investigate**: Call tools to gather information
3. **Reflect**: Adjust plan if needed
4. **Synthesize**: Provide final answer

![ReAct Progress](../screenshots/query-react-progress.png)
<!-- SCREENSHOT: Query tab showing ReAct plan with checkboxes, current step, and tool calls -->

**Use ReAct for**:
- Complex investigations
- Vulnerability hunting
- Call graph analysis
- Exploratory reverse engineering

## Edit Mode

The Query tab supports editing chat history:

- Click **Edit** to enter markdown mode
- Modify content and save
- Changes update the stored chat history

## Related Documentation

- [Query Workflow](../workflows/query-workflow.md)
- [Settings Tab](settings-tab.md)
- [Semantic Graph Tab](semantic-graph-tab.md)

```

`docs/tabs/rag-tab.md`:

```md
# RAG Tab Reference

The RAG (Retrieval-Augmented Generation) tab manages external documentation for context-enhanced analysis.

![RAG Tab Interface](../screenshots/rag-tab-interface.png)
<!-- SCREENSHOT: RAG tab showing document table, Add/Refresh/Delete buttons, search controls, and results panel -->

## Purpose

RAG lets you import documentation (protocols, APIs, notes) so the LLM can reference it during analysis.

## UI Elements

### Document Management

- **Add Documents**: Import files
- **Refresh**: Re-index selected document
- **Delete**: Remove selected document
- **Clear Index**: Remove all indexed documents

Document table columns:

| Column | Description |
|--------|-------------|
| **Name** | Document filename |
| **Size** | File size |
| **Chunks** | Indexed chunk count |

### Search Panel

Search the index to validate results:

- **Query** input
- **Search Type**: Hybrid / Semantic / Keyword
- Results list with relevance scores

## Supported Document Types

- `.txt` (plain text)
- `.md` (markdown)
- `.pdf` (PDF text extraction)

## Search Types

| Type | Description |
|------|-------------|
| **Hybrid** | Combines keyword and semantic search |
| **Semantic** | Vector similarity search |
| **Keyword** | Traditional full-text search |

## Using RAG in Analysis

1. Import documents in the RAG tab
2. Enable **Use RAG** in the Query tab
3. Ask your question or run analysis

## Related Documentation

- [Query Tab](query-tab.md)
- [Explain Tab](explain-tab.md)
- [Settings Tab](settings-tab.md)

```

`docs/tabs/semantic-graph-tab.md`:

```md
# Semantic Graph Tab Reference

The Semantic Graph tab builds and explores a knowledge graph of your binary, capturing relationships, summaries, and security properties.

![Semantic Graph Tab Interface](../screenshots/semantic-graph-tab-interface.png)
<!-- SCREENSHOT: Semantic Graph tab showing List View sub-tab with function table and status header -->

## Purpose

The Semantic Graph provides:

- A call-graph-backed knowledge base
- LLM summaries and security annotations
- Taint analysis results for vulnerability detection
- Function communities for modular understanding

## Sub-Tabs

### List View

Displays indexed functions in a table:

- Address, name, summary, security flags, community labels
- Click a row to navigate to that function
- Caller/callee information is shown for the selected node

![List View](../screenshots/semantic-graph-list-view.png)
<!-- SCREENSHOT: List View showing functions, summaries, and security flags -->

### Visual Graph

Interactive graph visualization:

- Nodes are functions
- Edges are call relationships
- N-hop depth controls exploration

![Visual Graph](../screenshots/semantic-graph-visual.png)
<!-- SCREENSHOT: Visual Graph view with nodes and edges, one node selected -->

### Search

Full-text search across summaries and annotations:

- Search by keywords or function names
- Results include relevant excerpt snippets

![Search](../screenshots/semantic-graph-search.png)
<!-- SCREENSHOT: Search tab showing results list with highlighted snippets -->

### Manual Analysis

Provides fine-grained controls for analysis workflows.

## Main Controls

At the bottom of the tab:

| Button | Description |
|--------|-------------|
| **Reset Graph** | Clear all graph data for the current binary |
| **ReIndex Binary** | Build structure + security + network flow pipeline |
| **Semantic Analysis** | Run LLM summarization on stale/unsummarized nodes |

## Manual Analysis Panel

Additional analysis operations:

| Button | Description |
|--------|-------------|
| **Security Analysis** | Taint analysis for source-to-sink flows |
| **Network Flow Analysis** | Track data flow through network APIs |
| **Community Detection** | Group related functions using Label Propagation |
| **Refresh Names** | Sync graph node names with Ghidra function names |

## Graph Statistics

The status line shows:

- Current index state
- Caller/callee counts
- Security flags count

## Related Documentation

- [Semantic Graph Workflow](../workflows/semantic-graph-workflow.md)
- [Query Tab](query-tab.md)
- [SymGraph Tab](symgraph-tab.md)

```

`docs/tabs/settings-tab.md`:

```md
# Settings Tab Reference

The Settings tab configures LLM providers, MCP servers, SymGraph, and analysis options for GhidrAssist.

![Settings Tab Overview](../screenshots/settings-tab-full.png)
<!-- SCREENSHOT: Full Settings tab showing LLM Providers, MCP Servers, SymGraph, System Prompt, Database Paths, Analysis Options -->

## LLM Providers Section

This section manages the LLM providers that power GhidrAssist.

### Provider Table

| Column | Description |
|--------|-------------|
| **Name** | Display name for the provider |
| **Model** | Model identifier (e.g., `gpt-4o`, `claude-sonnet-4-20250514`) |
| **Max Tokens** | Maximum tokens per request |
| **URL** | API endpoint URL (may be empty for defaults) |
| **Key** | API key (masked) |
| **Disable TLS** | Skip TLS verification (for local development) |

### Provider Management Buttons

- **Add**: Create a new provider configuration
- **Edit**: Modify the selected provider
- **Duplicate**: Duplicate the selected provider
- **Delete**: Remove the selected provider
- **Test**: Verify the selected provider

### Active Provider and Reasoning Effort

Below the table:

- **Active Provider** dropdown chooses which provider is used for all operations
- **Reasoning Effort** controls extended thinking depth (None / Low / Medium / High)

| Level | Description |
|-------|-------------|
| None | Standard response mode |
| Low | Light reasoning |
| Medium | Moderate reasoning |
| High | Deep analysis |

### Provider Types

| Type | Description | Auth |
|------|-------------|------|
| **Ollama** | Local Ollama server | None |
| **LM Studio** | Local LM Studio server | None |
| **Open WebUI** | Self-hosted Open WebUI | Optional key |
| **OpenAI Platform API** | OpenAI official API | API key |
| **OpenAI OAuth** | ChatGPT Pro/Plus subscription | OAuth |
| **Anthropic Platform API** | Anthropic official API | API key |
| **Anthropic OAuth** | Claude Pro/Max subscription | OAuth |
| **Anthropic CLI** | Claude Code CLI wrapper | CLI auth |
| **LiteLLM** | LiteLLM proxy server | API key |

### Add/Edit Provider Dialog

![Add Provider Dialog](../screenshots/add-provider-dialog.png)
<!-- SCREENSHOT: Add Provider dialog with fields for Name, Type, Model, URL, API Key, Max Tokens, Disable TLS -->

Common fields:
- **Name**: Display name
- **Type**: Provider type
- **Model**: Model identifier
- **Max Tokens**: Max tokens per request

Type-specific fields:
- **URL**: Required for Ollama/LM Studio/Open WebUI/LiteLLM
- **API Key**: Required for platform APIs
- **Authenticate**: OAuth providers

## MCP Servers Section

Configure Model Context Protocol (MCP) servers that provide tools.

### MCP Server Table

| Column | Description |
|--------|-------------|
| **Name** | Server name |
| **URL** | Server endpoint |
| **Enabled** | Whether the server is active |
| **Transport** | HTTP / SSE / Stdio |

### MCP Management Buttons

- **Add Server**: Configure a new MCP server
- **Edit**: Modify selected server
- **Duplicate**: Duplicate the selected server
- **Remove**: Delete selected server
- **Test Connection**: Verify connectivity

### Recommended MCP Server

[GhidrAssistMCP](https://github.com/jtang613/GhidrAssistMCP) provides Ghidra-specific tools:

- Function decompilation and disassembly
- Cross-references and navigation
- Symbol lookup
- Semantic graph queries

## SymGraph Section

Configure the SymGraph cloud service for symbol sharing.

![SymGraph Settings](../screenshots/settings-symgraph.png)
<!-- SCREENSHOT: SymGraph section showing API URL, API Key field, Show/Hide button, Test Connection button -->

Fields:
- **API URL**: Default `https://api.symgraph.com`
- **API Key**: Required for push/pull operations
- **Show/Hide**: Toggle visibility
- **Test Connection**: Verify credentials

SymGraph accounts are required for push/pull operations. See the [SymGraph Workflow](../workflows/symgraph-workflow.md).

## System Prompt Section

Customize the system prompt sent to the LLM.

![System Prompt](../screenshots/settings-system-prompt.png)
<!-- SCREENSHOT: System Prompt section showing text area and Reset/Save buttons -->

- **Save**: Persist prompt
- **Revert**: Reset to default

Use the system prompt to customize analysis style or domain context.

## Database Paths Section

Configure local storage paths:

| Database | Purpose | Default |
|----------|---------|---------|
| **Analysis DB** | Stores explanations, graph data | `ghidrassist_analysis.db` |
| **RLHF DB** | Stores feedback data | `ghidrassist_rlhf.db` |
| **RAG Index** | Lucene index directory | `ghidrassist_lucene` |

![Database Paths](../screenshots/settings-database-paths.png)
<!-- SCREENSHOT: Database Paths section showing Analysis DB, RLHF DB, RAG Index fields with Browse buttons -->

## Analysis Options Section

Additional analysis controls:

- **Max Tool Calls/Iteration**: Limits tool calls in ReAct loops
- **API Timeout (seconds)**: Request timeout for LLM APIs

![Analysis Options](../screenshots/settings-analysis-options.png)
<!-- SCREENSHOT: Analysis Options section showing max tool calls spinner and API timeout field -->

## Related Documentation

- [Getting Started](../getting-started.md)
- [Query Tab](query-tab.md) - MCP usage
- [SymGraph Tab](symgraph-tab.md) - SymGraph operations
- [RAG Tab](rag-tab.md) - Document management

```

`docs/workflows/explain-workflow.md`:

```md
# Workflow: Building Context with the Explain Tab

This guide shows how to use the Explain tab to document your understanding of a binary in Ghidra.

## Overview

The Explain tab generates LLM-powered explanations of functions and stores them for later use. It is best for building persistent context across a project.

## When to Use the Explain Tab

Use Explain when you want to:

- Understand a function at a high level
- Document findings for later reference
- Capture security-relevant information
- Build a knowledge base as you analyze

For ad-hoc questions, use the [Query tab](../tabs/query-tab.md).

## Step-by-Step Workflow

### Step 1: Select a Function

Navigate to a function in Ghidra:

1. Click a function in the Functions window
2. Or press **G** to jump to an address

The Explain tab shows the current function automatically.

![Function Selected](../screenshots/explain-function-selected.png)
<!-- SCREENSHOT: Explain tab header showing function name and address -->

### Step 2: Generate an Explanation

Click **Explain Function** to generate a summary.

The explanation includes:
- Purpose and behavior
- Parameters and return values
- Notable operations

![Explanation Streaming](../screenshots/explain-streaming.png)
<!-- SCREENSHOT: Explain tab showing explanation text streaming in -->

### Step 3: Review Security Analysis

Expand the security panel to view:

| Field | Description |
|-------|-------------|
| **Risk Level** | Low / Medium / High risk assessment |
| **Activity Profile** | Behavioral category |
| **Security Flags** | Detected patterns |
| **Network APIs** | Network calls detected |
| **File I/O APIs** | File operations detected |

![Security Panel](../screenshots/explain-security-expanded.png)
<!-- SCREENSHOT: Security panel expanded with populated data -->

### Step 4: Edit and Save

If needed:

1. Click **Edit**
2. Modify the markdown
3. Click **Save** to store updates

Edits are persisted and protected from auto-overwrite.

![Edit Mode](../screenshots/explain-edit-mode.png)
<!-- SCREENSHOT: Explain tab in edit mode with Save button visible -->

### Step 5: Clear Analysis (Optional)

Use **Clear** to remove stored analysis for the current function.

## Enhancing Explanations

### Using RAG

If you have documents indexed in the [RAG tab](../tabs/rag-tab.md):

1. Enable **Use RAG** in Query tab before analysis
2. Run Explain Function
3. The LLM uses relevant document context

### Using MCP

If MCP servers are configured:

1. Enable **Use MCP Tools** in Query tab
2. Run Explain Function
3. The LLM can call tools for extra context

## Explain Line

The **Explain Line** button is currently disabled and marked as "Coming Soon" in GhidrAssist.

## Building a Documentation Set

To systematically document a binary:

1. Start with entry points and exports
2. Follow call chains through key functions
3. Prioritize security-relevant functions
4. Update explanations as your understanding improves

Explanations are stored by binary hash and function address.

## Related Documentation

- [Explain Tab Reference](../tabs/explain-tab.md)
- [Query Workflow](query-workflow.md)
- [RAG Tab](../tabs/rag-tab.md)

```

`docs/workflows/query-workflow.md`:

```md
# Workflow: Interactive Queries and the ReAct Agent

This guide walks through using the Query tab for interactive analysis and autonomous investigation.

## Overview

The Query tab supports:

- Multi-turn chat
- Context macros
- MCP tool calling
- ReAct agentic investigations

## Basic Query Workflow

### Ask a Question

1. Open the Query tab
2. Type your question
3. Click **Submit**

![Basic Query](../screenshots/query-basic-question.png)
<!-- SCREENSHOT: Query tab showing a simple question and streaming response -->

### Use Context Macros

Macros insert context from Ghidra:

| Macro | Description |
|-------|-------------|
| `#func` | Current function code (decompiler or disassembly) |
| `#addr` | Data at current address |
| `#line` | Current line (decompiler or disassembly) |
| `#range(start, end)` | Data in address range |

Example:
```
What does #func do with user input?
```

![Context Macro](../screenshots/query-context-macro.png)
<!-- SCREENSHOT: Query showing #func macro and context-based response -->

### Manage Conversations

- **New**: Start a new conversation
- **Delete**: Remove selected chats
- Chats persist across sessions

## MCP Tool Integration

When **Use MCP Tools** is enabled, the LLM can call tools to gather data.

![MCP Tool Call](../screenshots/query-mcp-tools.png)
<!-- SCREENSHOT: Query conversation showing tool calls and results -->

Common tool usage:
- Decompile or disassemble
- Query cross-references
- Navigate to addresses
- Query the semantic graph

## ReAct Agent Workflow

### When to Use ReAct

Use agentic mode for:

- Complex investigations
- Vulnerability searches
- Call-graph exploration
- Data flow tracing

### Enabling ReAct

1. Enable **Use MCP Tools**
2. Enable **Agentic Mode (ReAct)**
3. Ask your question

### The Investigation Process

1. **Planning**: Create a todo list of investigation steps
2. **Investigation**: Call tools and gather evidence
3. **Reflection**: Update the plan if needed
4. **Synthesis**: Provide a final, evidence-based answer

![ReAct Planning](../screenshots/query-react-planning.png)
<!-- SCREENSHOT: ReAct planning checklist visible in Query tab -->

![ReAct Synthesis](../screenshots/query-react-synthesis.png)
<!-- SCREENSHOT: ReAct final response with findings and summary -->

### Stopping Early

Click **Stop** to cancel the investigation. GhidrAssist will save partial findings in the chat history.

## Extended Thinking

Configure reasoning depth in [Settings](../tabs/settings-tab.md):

| Level | Best For |
|-------|----------|
| None | Quick responses |
| Low | Light reasoning |
| Medium | Moderate complexity |
| High | Deep analysis |

Higher levels improve quality but increase latency and cost.

## Tips for Effective Queries

- Be specific about what you want analyzed
- Use macros to include relevant code
- Enable MCP for complex questions
- Use ReAct for multi-step investigations

## Related Documentation

- [Query Tab Reference](../tabs/query-tab.md)
- [Explain Workflow](explain-workflow.md)
- [Semantic Graph Workflow](semantic-graph-workflow.md)
- [Settings Tab](../tabs/settings-tab.md)

```

`docs/workflows/semantic-graph-workflow.md`:

```md
# Workflow: Building a Semantic Graph

This guide shows how to build and use GhidrAssist's semantic graph for structured analysis.

## Overview

The semantic graph captures:

- Function summaries and call relationships
- Security flags and activity profiles
- Taint and network flow paths
- Function communities

It can be used directly in the Semantic Graph tab or via MCP queries.

## Step-by-Step Workflow

### Step 1: Open the Semantic Graph Tab

Navigate to the Semantic Graph tab in GhidrAssist.

![Semantic Graph Empty](../screenshots/semantic-graph-empty.png)
<!-- SCREENSHOT: Semantic Graph tab before indexing, empty or baseline state -->

### Step 2: ReIndex the Binary

Click **ReIndex Binary** to build the initial graph.

This extracts:
- Functions and addresses
- Call relationships
- Imports/exports

![ReIndex](../screenshots/semantic-graph-reindex.png)
<!-- SCREENSHOT: ReIndex progress or completed status -->

### Step 3: Run Semantic Analysis

Click **Semantic Analysis** to generate LLM summaries and security metadata.

![Semantic Analysis](../screenshots/semantic-graph-semantic.png)
<!-- SCREENSHOT: List View populated with summaries and flags -->

### Step 4: Run Security Analysis

From the Manual Analysis panel, click **Security Analysis** to find source-to-sink paths.

![Security Analysis](../screenshots/semantic-graph-security.png)
<!-- SCREENSHOT: Security analysis results or highlighted functions -->

### Step 5: Run Network Flow Analysis

Click **Network Flow Analysis** to track data flow through network send/recv APIs.

### Step 6: Run Community Detection

Click **Community Detection** to group related functions using Label Propagation.

![Communities](../screenshots/semantic-graph-communities.png)
<!-- SCREENSHOT: Functions showing community labels -->

## Exploring the Graph

### List View

- Browse all functions and summaries
- Review security flags
- Navigate directly to code

### Visual Graph

- Explore relationships visually
- Adjust depth and focus on critical nodes

![Visual Graph](../screenshots/semantic-graph-visual-explore.png)
<!-- SCREENSHOT: Visual graph with nodes, edges, selected function -->

### Search

Search summaries and function names:

![Search Results](../screenshots/semantic-graph-search-results.png)
<!-- SCREENSHOT: Search tab showing results with snippets -->

## Using the Graph in Queries

With MCP enabled in Query tab, the LLM can:
- Search summaries
- Find related functions
- Trace call chains
- Identify risky code paths

## Sharing via SymGraph

If you want to contribute:

1. Open the SymGraph tab
2. Select **Graph**
3. Click **Push to SymGraph**

See [SymGraph Workflow](symgraph-workflow.md).

## Related Documentation

- [Semantic Graph Tab Reference](../tabs/semantic-graph-tab.md)
- [Query Workflow](query-workflow.md)
- [SymGraph Workflow](symgraph-workflow.md)

```

`extension.properties`:

```properties
name=@extname@
description=A plugin that provides LLM helpers to explain code and assist in RE.
author=Jason Tang
createdOn=
version=@extversion@

```

`ghidra_scripts/README.txt`:

```txt
Java source directory to hold module-specific Ghidra scripts.

```

`src/main/help/help/TOC_Source.xml`:

```xml
<?xml version='1.0' encoding='ISO-8859-1' ?>
<!-- 

	This is an XML file intended to be parsed by the Ghidra help system.  It is loosely based 
	upon the JavaHelp table of contents document format.  The Ghidra help system uses a 
	TOC_Source.xml file to allow a module with help to define how its contents appear in the 
	Ghidra help viewer's table of contents.  The main document (in the Base module) 
	defines a basic structure for the 
	Ghidra table of contents system.  Other TOC_Source.xml files may use this structure to insert
	their files directly into this structure (and optionally define a substructure).
	
	
	In this document, a tag can be either a <tocdef> or a <tocref>.  The former is a definition
	of an XML item that may have a link and may contain other <tocdef> and <tocref> children.  
	<tocdef> items may be referred to in other documents by using a <tocref> tag with the 
	appropriate id attribute value.  Using these two tags allows any module to define a place 
	in the table of contents system (<tocdef>), which also provides a place for 
	other TOC_Source.xml files to insert content (<tocref>).  
	
	During the help build time, all TOC_Source.xml files will be parsed and	validated to ensure
	that all <tocref> tags point to valid <tocdef> tags.  From these files will be generated
	<module name>_TOC.xml files, which are table of contents files written in the format 
	desired by the JavaHelp system.   Additionally, the genated files will be merged together
	as they are loaded by the JavaHelp system.  In the end, when displaying help in the Ghidra
	help GUI, there will be on table of contents that has been created from the definitions in 
	all of the modules' TOC_Source.xml files.

	
	Tags and Attributes
	
	<tocdef>
	-id          - the name of the definition (this must be unique across all TOC_Source.xml files)	
	-text        - the display text of the node, as seen in the help GUI
	-target**    - the file to display when the node is clicked in the GUI
	-sortgroup   - this is a string that defines where a given node should appear under a given
	               parent.  The string values will be sorted by the JavaHelp system using
	               a javax.text.RulesBasedCollator.  If this attribute is not specified, then
	               the text of attribute will be used.

	<tocref>
	-id			 - The id of the <tocdef> that this reference points to 
	
	**The URL for the target is relative and should start with 'help/topics'.  This text is 
	used by the Ghidra help system to provide a universal starting point for all links so that
	they can be resolved at runtime, across modules.
	
	
-->


<tocroot>
	<!-- Uncomment and adjust fields to add help topic to help system's Table of Contents
	<tocref id="Ghidra Functionality">
		<tocdef id="HelpAnchor" text="My Feature" target="help/topics/my_topic/help.html" />
	</tocref>
	-->
</tocroot>

```

`src/main/help/help/topics/ghidrassist/help.html`:

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>
  <HEAD>
    <META name="generator" content=
    "HTML Tidy for Java (vers. 2009-12-01), see jtidy.sourceforge.net">
    <META http-equiv="Content-Language" content="en-us">
    <META http-equiv="Content-Type" content="text/html; charset=windows-1252">
    <META name="GENERATOR" content="Microsoft FrontPage 4.0">
    <META name="ProgId" content="FrontPage.Editor.Document">

    <TITLE>Skeleton Help File for a Module</TITLE>
    <LINK rel="stylesheet" type="text/css" href="help/shared/DefaultStyle.css">
  </HEAD>

  <BODY>
    <H1><a name="HelpAnchor"></a>Skeleton Help File for a Module</H1>

    <P>This is a simple skeleton help topic. For a better description of what should and should not
    go in here, see the "sample" Ghidra extension in the Extensions/Ghidra directory, or see your 
    favorite help topic. In general, language modules do not have their own help topics.</P>
  </BODY>
</HTML>

```

`src/main/java/ghidrassist/AnalysisDB.java`:

```java
package ghidrassist;

import ghidra.framework.preferences.Preferences;
import ghidra.program.model.address.Address;
import ghidra.util.Msg;
import ghidrassist.chat.PersistedChatMessage;
import ghidrassist.db.migration.SchemaMigrationRunner;
import ghidrassist.graphrag.BinaryKnowledgeGraph;
import java.sql.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

public class AnalysisDB {
    private static final String DB_PATH_PROPERTY = "GhidrAssist.AnalysisDBPath";
    private static final String DEFAULT_DB_PATH = "ghidrassist_analysis.db";
    private Connection connection;

    // Cache of BinaryKnowledgeGraph instances per program hash
    private final Map<String, BinaryKnowledgeGraph> graphCache = new ConcurrentHashMap<>();

    public AnalysisDB() {
        String dbPath = Preferences.getProperty(DB_PATH_PROPERTY, DEFAULT_DB_PATH);
        initializeDatabase(dbPath);
    }

    private void initializeDatabase(String dbPath) {
        try {
            connection = DriverManager.getConnection("jdbc:sqlite:" + dbPath);
            createAnalysisTables();
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error", "Failed to initialize Analysis database: " + e.getMessage());
        }
    }

    private void createAnalysisTables() throws SQLException {
        // Use the versioned migration system
        SchemaMigrationRunner runner = new SchemaMigrationRunner(connection);
        runner.runMigrations();

        // Additional legacy compatibility checks
        migrateChatMessagesTable();

        // Validate Graph-RAG schema integrity
        ensureGraphRagSchema();
    }

    private void ensureGraphRagSchema() throws SQLException {
        List<String> nodeColumns = Arrays.asList(
                "id",
                "type",
                "address",
                "binary_id",
                "name",
                "raw_content",
                "llm_summary",
                "confidence",
                "embedding",
                "security_flags",
                "network_apis",
                "file_io_apis",
                "ip_addresses",
                "urls",
                "file_paths",
                "domains",
                "registry_keys",
                "risk_level",
                "activity_profile",
                "analysis_depth",
                "created_at",
                "updated_at",
                "is_stale",
                "user_edited"
        );
        List<String> edgeColumns = Arrays.asList(
                "id",
                "source_id",
                "target_id",
                "type",
                "weight",
                "metadata",
                "created_at"
        );
        List<String> communityColumns = Arrays.asList(
                "id",
                "level",
                "binary_id",
                "parent_community_id",
                "name",
                "summary",
                "member_count",
                "is_stale",
                "created_at",
                "updated_at"
        );
        List<String> memberColumns = Arrays.asList(
                "community_id",
                "node_id",
                "membership_score"
        );
        List<String> ftsColumns = Arrays.asList(
                "id",
                "name",
                "llm_summary",
                "security_flags"
        );

        dropGraphNodeTriggers();

        boolean nodesRenamed = ensureTableSchema("graph_nodes", nodeColumns);
        if (nodesRenamed) {
            renameTableWithCounter("graph_edges");
            renameTableWithCounter("graph_communities");
            renameTableWithCounter("community_members");
            renameTableWithCounter("node_fts");
            return;
        }

        ensureTableSchema("graph_edges", edgeColumns);
        ensureTableSchema("graph_communities", communityColumns);
        ensureTableSchema("community_members", memberColumns);
        ensureTableSchema("node_fts", ftsColumns);

        ensureFtsSync();
    }

    private void dropGraphNodeTriggers() throws SQLException {
        try (Statement stmt = connection.createStatement()) {
            stmt.execute("DROP TRIGGER IF EXISTS graph_nodes_ai");
            stmt.execute("DROP TRIGGER IF EXISTS graph_nodes_ad");
            stmt.execute("DROP TRIGGER IF EXISTS graph_nodes_au");
        }
    }

    private void ensureFtsSync() {
        try (Statement stmt = connection.createStatement()) {
            ResultSet nodeRs = stmt.executeQuery(
                "SELECT COUNT(*) FROM graph_nodes WHERE llm_summary IS NOT NULL AND TRIM(llm_summary) != ''");
            int nodeCount = nodeRs.next() ? nodeRs.getInt(1) : 0;
            nodeRs.close();
            if (nodeCount == 0) return;

            int ftsCount = 0;
            try {
                ResultSet ftsRs = stmt.executeQuery("SELECT COUNT(*) FROM node_fts");
                ftsCount = ftsRs.next() ? ftsRs.getInt(1) : 0;
                ftsRs.close();
            } catch (SQLException e) {
                ftsCount = 0;
            }

            if (ftsCount < nodeCount * 0.8) {
                Msg.info(this, String.format("FTS out of sync (FTS: %d, nodes with summaries: %d). Rebuilding...",
                    ftsCount, nodeCount));
                try {
                    stmt.execute("INSERT INTO node_fts(node_fts) VALUES('rebuild')");
                    Msg.info(this, "FTS rebuild completed.");
                } catch (SQLException rebuildEx) {
                    Msg.warn(this, "FTS rebuild failed (likely corrupt), attempting full repair: " + rebuildEx.getMessage());
                    repairFtsTable();
                }
            }
        } catch (SQLException e) {
            Msg.warn(this, "FTS sync check failed: " + e.getMessage());
        }
    }

    /**
     * Rebuild the FTS index from current graph_nodes data.
     * Call after batch operations (semantic analysis, reindex) to sync FTS.
     */
    public void rebuildFts() {
        try (Statement stmt = connection.createStatement()) {
            stmt.execute("INSERT INTO node_fts(node_fts) VALUES('rebuild')");
            Msg.info(this, "FTS index rebuilt successfully.");
        } catch (SQLException e) {
            Msg.warn(this, "FTS rebuild failed, attempting full repair: " + e.getMessage());
            repairFtsTable();
        }
    }

    private boolean ensureTableSchema(String tableName, List<String> expectedColumns) throws SQLException {
        if (!tableExists(tableName)) {
            return false;
        }
        List<String> existing = getTableColumns(tableName);
        if (!columnsMatch(existing, expectedColumns)) {
            renameTableWithCounter(tableName);
            return true;
        }
        return false;
    }

    private boolean columnsMatch(List<String> existing, List<String> expected) {
        Set<String> existingSet = new HashSet<>(existing);
        Set<String> expectedSet = new HashSet<>(expected);
        return existingSet.equals(expectedSet);
    }

    private boolean tableExists(String tableName) throws SQLException {
        try (PreparedStatement stmt = connection.prepareStatement(
                "SELECT name FROM sqlite_master WHERE type='table' AND name=?")) {
            stmt.setString(1, tableName);
            try (ResultSet rs = stmt.executeQuery()) {
                return rs.next();
            }
        }
    }

    private List<String> getTableColumns(String tableName) throws SQLException {
        List<String> columns = new ArrayList<>();
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery("PRAGMA table_info(" + tableName + ")")) {
            while (rs.next()) {
                columns.add(rs.getString("name"));
            }
        }
        return columns;
    }

    private String nextBackupName(String tableName) throws SQLException {
        int suffix = 1;
        while (tableExists(tableName + "_backup_" + suffix)) {
            suffix++;
        }
        return tableName + "_backup_" + suffix;
    }

    private void renameTableWithCounter(String tableName) throws SQLException {
        if (!tableExists(tableName)) {
            return;
        }
        String backupName = nextBackupName(tableName);
        try (Statement stmt = connection.createStatement()) {
            stmt.execute("ALTER TABLE " + tableName + " RENAME TO " + backupName);
        }
    }

    /**
     * Repair or recreate the FTS table when it's corrupt.
     * This properly handles severe corruption by:
     * 1. Dropping any leftover triggers (FTS is managed via explicit rebuild, not triggers)
     * 2. Removing FTS entries from sqlite_master if needed
     * 3. Running VACUUM to rebuild the database
     * 4. Recreating FTS table
     * 5. Rebuilding the index from existing data
     *
     * @return true if repair was successful
     */
    public boolean repairFtsTable() {
        Msg.info(this, "Attempting full FTS table repair...");
        try (Statement stmt = connection.createStatement()) {
            // Step 1: Drop any leftover triggers
            stmt.execute("DROP TRIGGER IF EXISTS graph_nodes_ai");
            stmt.execute("DROP TRIGGER IF EXISTS graph_nodes_ad");
            stmt.execute("DROP TRIGGER IF EXISTS graph_nodes_au");

            // Step 2: Try normal drop
            boolean normalDropWorked = false;
            try {
                stmt.execute("DROP TABLE IF EXISTS node_fts");
                normalDropWorked = true;
                Msg.info(this, "FTS table dropped normally");
            } catch (SQLException e) {
                Msg.warn(this, "Normal DROP failed: " + e.getMessage());
            }

            // Step 3: If normal drop failed, use writable_schema + VACUUM
            if (!normalDropWorked) {
                Msg.info(this, "Using writable_schema to remove corrupt FTS entries...");
                stmt.execute("PRAGMA writable_schema = ON");
                stmt.execute("DELETE FROM sqlite_master WHERE type = 'table' AND name = 'node_fts'");
                stmt.execute("DELETE FROM sqlite_master WHERE type = 'table' AND name LIKE 'node_fts_%'");
                stmt.execute("DELETE FROM sqlite_master WHERE type = 'trigger' AND name LIKE 'graph_nodes_%'");
                stmt.execute("PRAGMA writable_schema = OFF");

                Msg.info(this, "Running VACUUM to rebuild database...");
                stmt.execute("VACUUM");
                Msg.info(this, "VACUUM completed");
            }

            // Step 4: Recreate the FTS table
            Msg.info(this, "Creating fresh FTS table...");
            stmt.execute("CREATE VIRTUAL TABLE IF NOT EXISTS node_fts USING fts5("
                    + "id, "
                    + "name, "
                    + "llm_summary, "
                    + "security_flags, "
                    + "content='graph_nodes', "
                    + "content_rowid='rowid'"
                    + ")");

            // Step 5: Rebuild FTS index from existing graph_nodes data
            Msg.info(this, "Rebuilding FTS index from existing data...");
            stmt.execute("INSERT INTO node_fts(node_fts) VALUES('rebuild')");

            Msg.info(this, "FTS table repaired successfully!");
            return true;

        } catch (SQLException e) {
            Msg.error(this, "FTS repair failed: " + e.getMessage(), e);
            return false;
        }
    }

    /**
     * Check if FTS is healthy by running a simple test query.
     * @return true if FTS is working
     */
    public boolean isFtsHealthy() {
        try (Statement stmt = connection.createStatement()) {
            // Try a simple FTS query
            ResultSet rs = stmt.executeQuery("SELECT 1 FROM node_fts LIMIT 1");
            rs.close();
            return true;
        } catch (SQLException e) {
            return false;
        }
    }

    /**
     * Check if an SQLException indicates FTS table corruption.
     */
    public static boolean isFtsCorruptionError(SQLException e) {
        String message = e.getMessage();
        return message != null && (
                message.contains("SQLITE_CORRUPT_VTAB") ||
                message.contains("vtable constructor failed") ||
                message.contains("node_fts")
        );
    }

    /**
     * Migrate GHChatMessages table - add any missing columns.
     * Uses PRAGMA table_info to check what columns actually exist.
     */
    private void migrateChatMessagesTable() {
        // First check if table exists
        boolean tableExists = false;
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(
                 "SELECT name FROM sqlite_master WHERE type='table' AND name='GHChatMessages'")) {
            tableExists = rs.next();
        } catch (SQLException e) {
            Msg.error(this, "Failed to check if GHChatMessages table exists: " + e.getMessage());
            return;
        }

        if (!tableExists) {
            // Table doesn't exist - let CREATE TABLE IF NOT EXISTS handle it
            return;
        }

        // Table exists - get existing columns
        java.util.Set<String> existingColumns = new java.util.HashSet<>();
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery("PRAGMA table_info(GHChatMessages)")) {
            while (rs.next()) {
                existingColumns.add(rs.getString("name").toLowerCase());
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to get GHChatMessages columns: " + e.getMessage());
            return;
        }

        // Define columns to add with their definitions
        // Note: SQLite ALTER TABLE cannot use non-constant defaults like CURRENT_TIMESTAMP
        // So we add these columns without defaults and handle timestamps in INSERT/UPDATE
        String[][] columnsToAdd = {
            {"program_hash", "TEXT"},
            {"chat_id", "INTEGER"},
            {"session_id", "INTEGER"},  // For backward compatibility with old databases
            {"message_order", "INTEGER"},
            {"sequence_number", "INTEGER"},  // For backward compatibility with old databases
            {"provider_type", "TEXT"},
            {"native_message_data", "TEXT"},
            {"role", "TEXT"},
            {"content_text", "TEXT"},
            {"message_type", "TEXT DEFAULT 'standard'"},
            {"created_at", "TIMESTAMP"},
            {"updated_at", "TIMESTAMP"}
        };

        // Add only missing columns
        for (String[] colDef : columnsToAdd) {
            String colName = colDef[0];
            String colType = colDef[1];
            if (!existingColumns.contains(colName.toLowerCase())) {
                String alterSql = "ALTER TABLE GHChatMessages ADD COLUMN " + colName + " " + colType;
                try (Statement stmt = connection.createStatement()) {
                    stmt.execute(alterSql);
                    Msg.info(this, "Added missing column to GHChatMessages: " + colName);
                } catch (SQLException e) {
                    Msg.error(this, "Failed to add column " + colName + " to GHChatMessages: " + e.getMessage());
                }
            }
        }

        // Migrate data from old 'timestamp' column to 'created_at' if timestamp exists
        if (existingColumns.contains("timestamp")) {
            try (Statement stmt = connection.createStatement()) {
                // Copy timestamp values to created_at for rows where created_at is NULL
                String migrateSql = "UPDATE GHChatMessages SET created_at = timestamp WHERE created_at IS NULL";
                int updated = stmt.executeUpdate(migrateSql);
                if (updated > 0) {
                    Msg.info(this, "Migrated " + updated + " rows from timestamp to created_at in GHChatMessages");
                }
            } catch (SQLException e) {
                Msg.error(this, "Failed to migrate timestamp data: " + e.getMessage());
            }
        }
    }

    public void upsertAnalysis(String programHash, Address functionAddress, String query, String response) {
        String upsertSQL = "INSERT INTO GHAnalysis (program_hash, function_address, query, response) "
                + "VALUES (?, ?, ?, ?) "
                + "ON CONFLICT(program_hash, function_address) "
                + "DO UPDATE SET query = ?, response = ?, timestamp = CURRENT_TIMESTAMP";
        
        try (PreparedStatement pstmt = connection.prepareStatement(upsertSQL)) {
            pstmt.setString(1, programHash);
            pstmt.setString(2, functionAddress.toString());
            pstmt.setString(3, query);
            pstmt.setString(4, response);
            pstmt.setString(5, query);
            pstmt.setString(6, response);
            pstmt.executeUpdate();
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error", "Failed to store analysis: " + e.getMessage());
        }
    }

    /**
     * Deletes the analysis entry for the specified program and function
     * 
     * @param programHash The hash of the program
     * @param functionAddress The address of the function
     * @return true if an entry was deleted, false otherwise
     */
    public boolean deleteAnalysis(String programHash, Address functionAddress) {
        String deleteSQL = "DELETE FROM GHAnalysis WHERE program_hash = ? AND function_address = ?";
        
        if (programHash == null || functionAddress == null) {
            Msg.error(this, "Cannot delete analysis: programHash or functionAddress is null");
            return false;
        }
        
        Msg.info(this, "Attempting to delete analysis for " + programHash + " at " + functionAddress.toString());
        
        try (PreparedStatement pstmt = connection.prepareStatement(deleteSQL)) {
            pstmt.setString(1, programHash);
            pstmt.setString(2, functionAddress.toString());
            
            int rowsAffected = pstmt.executeUpdate();
            Msg.info(this, "Delete operation affected " + rowsAffected + " rows");
            return rowsAffected > 0;
        } catch (SQLException e) {
            Msg.error(this, "Failed to delete analysis: " + e.getMessage());
            return false;
        }
    }

    public Analysis getAnalysis(String programHash, Address functionAddress) {
        String selectSQL = "SELECT query, response, timestamp FROM GHAnalysis "
                + "WHERE program_hash = ? AND function_address = ?";
        
        try (PreparedStatement pstmt = connection.prepareStatement(selectSQL)) {
            pstmt.setString(1, programHash);
            pstmt.setString(2, functionAddress.toString());
            
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return new Analysis(
                    rs.getString("query"),
                    rs.getString("response"),
                    rs.getTimestamp("timestamp")
                );
            }
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error", "Failed to retrieve analysis: " + e.getMessage());
        }
        return null;
    }

    public void upsertContext(String programHash, String context) {
        if (context == null) {
            // If context is null, delete the entry to revert to default
            deleteContext(programHash);
            return;
        }
        
        String upsertSQL = "INSERT INTO GHContext (program_hash, system_context) "
                + "VALUES (?, ?) "
                + "ON CONFLICT(program_hash) "
                + "DO UPDATE SET system_context = ?, timestamp = CURRENT_TIMESTAMP";
        
        try (PreparedStatement pstmt = connection.prepareStatement(upsertSQL)) {
            pstmt.setString(1, programHash);
            pstmt.setString(2, context);
            pstmt.setString(3, context);
            pstmt.executeUpdate();
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error", "Failed to store context: " + e.getMessage());
        }
    }
    
    public void deleteContext(String programHash) {
        String deleteSQL = "DELETE FROM GHContext WHERE program_hash = ?";
        
        try (PreparedStatement pstmt = connection.prepareStatement(deleteSQL)) {
            pstmt.setString(1, programHash);
            pstmt.executeUpdate();
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error", "Failed to delete context: " + e.getMessage());
        }
    }

    public String getContext(String programHash) {
        String selectSQL = "SELECT system_context FROM GHContext WHERE program_hash = ?";

        try (PreparedStatement pstmt = connection.prepareStatement(selectSQL)) {
            pstmt.setString(1, programHash);

            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return rs.getString("system_context");
            }
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error", "Failed to retrieve context: " + e.getMessage());
        }
        return null;
    }

    public void upsertReasoningEffort(String programHash, String reasoningEffort) {
        if (reasoningEffort == null || reasoningEffort.equalsIgnoreCase("none")) {
            reasoningEffort = "none";
        }

        // Check if context entry exists
        String selectSQL = "SELECT program_hash FROM GHContext WHERE program_hash = ?";
        boolean exists = false;
        try (PreparedStatement pstmt = connection.prepareStatement(selectSQL)) {
            pstmt.setString(1, programHash);
            ResultSet rs = pstmt.executeQuery();
            exists = rs.next();
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error", "Failed to check context: " + e.getMessage());
            return;
        }

        if (!exists) {
            // Create entry with default context
            String insertSQL = "INSERT INTO GHContext (program_hash, system_context, reasoning_effort) VALUES (?, '', ?)";
            try (PreparedStatement pstmt = connection.prepareStatement(insertSQL)) {
                pstmt.setString(1, programHash);
                pstmt.setString(2, reasoningEffort);
                pstmt.executeUpdate();
            } catch (SQLException e) {
                Msg.showError(this, null, "Database Error", "Failed to insert reasoning effort: " + e.getMessage());
            }
        } else {
            // Update existing entry
            String updateSQL = "UPDATE GHContext SET reasoning_effort = ?, timestamp = CURRENT_TIMESTAMP WHERE program_hash = ?";
            try (PreparedStatement pstmt = connection.prepareStatement(updateSQL)) {
                pstmt.setString(1, reasoningEffort);
                pstmt.setString(2, programHash);
                pstmt.executeUpdate();
            } catch (SQLException e) {
                Msg.showError(this, null, "Database Error", "Failed to update reasoning effort: " + e.getMessage());
            }
        }
    }

    public String getReasoningEffort(String programHash) {
        String selectSQL = "SELECT reasoning_effort FROM GHContext WHERE program_hash = ?";

        try (PreparedStatement pstmt = connection.prepareStatement(selectSQL)) {
            pstmt.setString(1, programHash);

            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                String effort = rs.getString("reasoning_effort");
                return effort != null ? effort : "none";
            }
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error", "Failed to retrieve reasoning effort: " + e.getMessage());
        }
        return "none"; // Default to none if not found
    }

    public void upsertMaxToolCalls(String programHash, int maxToolCalls) {
        // Validate range (must be at least 1)
        if (maxToolCalls < 1) {
            maxToolCalls = 10; // Default value
        }

        // Check if context entry exists
        String selectSQL = "SELECT program_hash FROM GHContext WHERE program_hash = ?";
        boolean exists = false;
        try (PreparedStatement pstmt = connection.prepareStatement(selectSQL)) {
            pstmt.setString(1, programHash);
            ResultSet rs = pstmt.executeQuery();
            exists = rs.next();
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error", "Failed to check context: " + e.getMessage());
            return;
        }

        if (!exists) {
            // Create entry with default context
            String insertSQL = "INSERT INTO GHContext (program_hash, system_context, max_tool_calls) VALUES (?, '', ?)";
            try (PreparedStatement pstmt = connection.prepareStatement(insertSQL)) {
                pstmt.setString(1, programHash);
                pstmt.setInt(2, maxToolCalls);
                pstmt.executeUpdate();
            } catch (SQLException e) {
                Msg.showError(this, null, "Database Error", "Failed to insert max tool calls: " + e.getMessage());
            }
        } else {
            // Update existing entry
            String updateSQL = "UPDATE GHContext SET max_tool_calls = ?, timestamp = CURRENT_TIMESTAMP WHERE program_hash = ?";
            try (PreparedStatement pstmt = connection.prepareStatement(updateSQL)) {
                pstmt.setInt(1, maxToolCalls);
                pstmt.setString(2, programHash);
                pstmt.executeUpdate();
            } catch (SQLException e) {
                Msg.showError(this, null, "Database Error", "Failed to update max tool calls: " + e.getMessage());
            }
        }
    }

    public int getMaxToolCalls(String programHash) {
        String selectSQL = "SELECT max_tool_calls FROM GHContext WHERE program_hash = ?";

        try (PreparedStatement pstmt = connection.prepareStatement(selectSQL)) {
            pstmt.setString(1, programHash);

            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                int maxToolCalls = rs.getInt("max_tool_calls");
                // Return default if not set (0) or invalid
                return maxToolCalls > 0 ? maxToolCalls : 10;
            }
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error", "Failed to retrieve max tool calls: " + e.getMessage());
        }
        return 10; // Default to 10 if not found
    }

    // Chat History Methods
    
    public int createChatSession(String programHash, String description, String conversation) {
        String insertSQL = "INSERT INTO GHChatHistory (program_hash, description, conversation) VALUES (?, ?, ?)";
        
        try (PreparedStatement pstmt = connection.prepareStatement(insertSQL, Statement.RETURN_GENERATED_KEYS)) {
            pstmt.setString(1, programHash);
            pstmt.setString(2, description);
            pstmt.setString(3, conversation);
            pstmt.executeUpdate();
            
            ResultSet rs = pstmt.getGeneratedKeys();
            if (rs.next()) {
                return rs.getInt(1);
            }
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error", "Failed to create chat session: " + e.getMessage());
        }
        return -1;
    }
    
    public void updateChatSession(int sessionId, String conversation) {
        String updateSQL = "UPDATE GHChatHistory SET conversation = ?, last_update = CURRENT_TIMESTAMP WHERE id = ?";
        
        try (PreparedStatement pstmt = connection.prepareStatement(updateSQL)) {
            pstmt.setString(1, conversation);
            pstmt.setInt(2, sessionId);
            pstmt.executeUpdate();
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error", "Failed to update chat session: " + e.getMessage());
        }
    }
    
    public void updateChatDescription(int sessionId, String description) {
        String updateSQL = "UPDATE GHChatHistory SET description = ? WHERE id = ?";
        
        try (PreparedStatement pstmt = connection.prepareStatement(updateSQL)) {
            pstmt.setString(1, description);
            pstmt.setInt(2, sessionId);
            pstmt.executeUpdate();
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error", "Failed to update chat description: " + e.getMessage());
        }
    }
    
    public boolean deleteChatSession(int sessionId) {
        String deleteSQL = "DELETE FROM GHChatHistory WHERE id = ?";
        
        try (PreparedStatement pstmt = connection.prepareStatement(deleteSQL)) {
            pstmt.setInt(1, sessionId);
            int rowsAffected = pstmt.executeUpdate();
            return rowsAffected > 0;
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error", "Failed to delete chat session: " + e.getMessage());
            return false;
        }
    }
    
    public java.util.List<ChatSession> getChatSessions(String programHash) {
        java.util.List<ChatSession> sessions = new java.util.ArrayList<>();
        String selectSQL = "SELECT id, description, last_update FROM GHChatHistory WHERE program_hash = ? ORDER BY last_update DESC";
        
        try (PreparedStatement pstmt = connection.prepareStatement(selectSQL)) {
            pstmt.setString(1, programHash);
            
            ResultSet rs = pstmt.executeQuery();
            while (rs.next()) {
                sessions.add(new ChatSession(
                    rs.getInt("id"),
                    rs.getString("description"),
                    rs.getTimestamp("last_update")
                ));
            }
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error", "Failed to retrieve chat sessions: " + e.getMessage());
        }
        return sessions;
    }
    
    public String getChatConversation(int sessionId) {
        String selectSQL = "SELECT conversation FROM GHChatHistory WHERE id = ?";

        try (PreparedStatement pstmt = connection.prepareStatement(selectSQL)) {
            pstmt.setInt(1, sessionId);

            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return rs.getString("conversation");
            }
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error", "Failed to retrieve chat conversation: " + e.getMessage());
        }
        return null;
    }

    // Per-Message Storage Methods

    /**
     * Save a single chat message to the per-message storage.
     *
     * @param programHash Program hash
     * @param chatId Chat session ID
     * @param order Message order in conversation
     * @param providerType Provider type (anthropic/openai/ollama/edited)
     * @param nativeData JSON with essential tool info
     * @param role Message role
     * @param content Message content
     * @param messageType Message type (standard/tool_call/tool_response/edited)
     * @return Generated message ID, or -1 on failure
     */
    public int saveMessage(String programHash, int chatId, int order,
                           String providerType, String nativeData,
                           String role, String content, String messageType) {
        // Check if row exists
        String checkSql = "SELECT id FROM GHChatMessages WHERE program_hash = ? AND chat_id = ? AND message_order = ?";
        int existingId = -1;

        try (PreparedStatement checkStmt = connection.prepareStatement(checkSql)) {
            checkStmt.setString(1, programHash);
            checkStmt.setInt(2, chatId);
            checkStmt.setInt(3, order);
            ResultSet rs = checkStmt.executeQuery();
            if (rs.next()) {
                existingId = rs.getInt("id");
            }
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error", "Failed to check existing message: " + e.getMessage());
            return -1;
        }

        if (existingId > 0) {
            // NEVER UPDATE message_order=0 (the user query) - it must be preserved!
            if (order == 0 && "user".equals(role)) {
                Msg.warn(this, "Attempted to overwrite user query at order=0 - skipping update to preserve original");
                return existingId;
            }

            // Update existing row
            String updateSql = "UPDATE GHChatMessages SET provider_type = ?, native_message_data = ?, "
                    + "role = ?, content_text = ?, message_type = ?, updated_at = CURRENT_TIMESTAMP "
                    + "WHERE id = ?";
            try (PreparedStatement pstmt = connection.prepareStatement(updateSql)) {
                pstmt.setString(1, providerType);
                pstmt.setString(2, nativeData != null ? nativeData : "{}");
                pstmt.setString(3, role);
                pstmt.setString(4, content);
                pstmt.setString(5, messageType != null ? messageType : "standard");
                pstmt.setInt(6, existingId);
                pstmt.executeUpdate();
                return existingId;
            } catch (SQLException e) {
                Msg.showError(this, null, "Database Error", "Failed to update message: " + e.getMessage());
                return -1;
            }
        } else {
            // Insert new row
            // Note: session_id and sequence_number included for backward compatibility with old database schemas
            String insertSql = "INSERT INTO GHChatMessages "
                    + "(program_hash, chat_id, session_id, message_order, sequence_number, provider_type, native_message_data, "
                    + "role, content_text, message_type, created_at, updated_at) "
                    + "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)";
            try (PreparedStatement pstmt = connection.prepareStatement(insertSql, Statement.RETURN_GENERATED_KEYS)) {
                pstmt.setString(1, programHash);
                pstmt.setInt(2, chatId);
                pstmt.setInt(3, chatId);  // session_id = chat_id for compatibility
                pstmt.setInt(4, order);
                pstmt.setInt(5, order);   // sequence_number = message_order for compatibility
                pstmt.setString(6, providerType);
                pstmt.setString(7, nativeData != null ? nativeData : "{}");
                pstmt.setString(8, role);
                pstmt.setString(9, content);
                pstmt.setString(10, messageType != null ? messageType : "standard");
                pstmt.executeUpdate();

                ResultSet rs = pstmt.getGeneratedKeys();
                if (rs.next()) {
                    return rs.getInt(1);
                }
            } catch (SQLException e) {
                Msg.showError(this, null, "Database Error", "Failed to insert message: " + e.getMessage());
            }
        }
        return -1;
    }

    /**
     * Get all messages for a chat session.
     *
     * @param programHash Program hash
     * @param chatId Chat session ID
     * @return List of PersistedChatMessage objects, ordered by message_order
     */
    public List<PersistedChatMessage> getMessages(String programHash, int chatId) {
        List<PersistedChatMessage> messages = new ArrayList<>();
        String sql = "SELECT id, role, content_text, message_order, "
                + "created_at, "
                + "provider_type, native_message_data, message_type "
                + "FROM GHChatMessages WHERE program_hash = ? AND chat_id = ? "
                + "ORDER BY message_order ASC";

        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, programHash);
            pstmt.setInt(2, chatId);

            ResultSet rs = pstmt.executeQuery();
            while (rs.next()) {
                PersistedChatMessage msg = new PersistedChatMessage(
                        rs.getInt("id"),
                        rs.getString("role"),
                        rs.getString("content_text"),
                        rs.getTimestamp("created_at"),
                        rs.getInt("message_order")
                );
                msg.setProviderType(rs.getString("provider_type"));
                msg.setNativeMessageData(rs.getString("native_message_data"));
                msg.setMessageType(rs.getString("message_type"));
                messages.add(msg);
            }
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error",
                    "Failed to retrieve messages: " + e.getMessage());
        }
        return messages;
    }

    /**
     * Delete all messages for a chat session.
     *
     * @param programHash Program hash
     * @param chatId Chat session ID
     * @return Number of messages deleted
     */
    public int deleteMessages(String programHash, int chatId) {
        String sql = "DELETE FROM GHChatMessages WHERE program_hash = ? AND chat_id = ?";

        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, programHash);
            pstmt.setInt(2, chatId);
            return pstmt.executeUpdate();
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error",
                    "Failed to delete messages: " + e.getMessage());
        }
        return 0;
    }

    /**
     * Check if a chat session has per-message storage (has been migrated).
     *
     * @param programHash Program hash
     * @param chatId Chat session ID
     * @return true if the session has per-message storage
     */
    public boolean hasPerMessageStorage(String programHash, int chatId) {
        String sql = "SELECT COUNT(*) FROM GHChatMessages WHERE program_hash = ? AND chat_id = ?";

        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, programHash);
            pstmt.setInt(2, chatId);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return rs.getInt(1) > 0;
            }
        } catch (SQLException e) {
            // Table may not exist yet in older databases
            Msg.warn(this, "Error checking per-message storage: " + e.getMessage());
        }
        return false;
    }

    /**
     * Get the count of messages in a chat session.
     *
     * @param programHash Program hash
     * @param chatId Chat session ID
     * @return Number of messages
     */
    public int getMessageCount(String programHash, int chatId) {
        String sql = "SELECT COUNT(*) FROM GHChatMessages WHERE program_hash = ? AND chat_id = ?";

        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, programHash);
            pstmt.setInt(2, chatId);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return rs.getInt(1);
            }
        } catch (SQLException e) {
            Msg.warn(this, "Error getting message count: " + e.getMessage());
        }
        return 0;
    }

    /**
     * Get the database connection for use with new chat persistence components.
     * @return The database connection
     */
    public Connection getConnection() {
        return connection;
    }

    // ========================================
    // Graph-RAG Knowledge Graph Methods
    // ========================================

    /**
     * Get or create a BinaryKnowledgeGraph for a program.
     * The graph is cached per program hash for efficiency.
     *
     * @param programHash The program hash identifying the binary
     * @return BinaryKnowledgeGraph instance for the program
     */
    public BinaryKnowledgeGraph getKnowledgeGraph(String programHash) {
        return graphCache.computeIfAbsent(programHash,
                hash -> new BinaryKnowledgeGraph(connection, hash, this));
    }

    /**
     * Check if a knowledge graph exists for a program (has any nodes).
     *
     * @param programHash The program hash
     * @return true if the graph has been populated
     */
    public boolean hasKnowledgeGraph(String programHash) {
        String sql = "SELECT COUNT(*) FROM graph_nodes WHERE binary_id = ?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, programHash);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return rs.getInt(1) > 0;
            }
        } catch (SQLException e) {
            Msg.warn(this, "Error checking knowledge graph: " + e.getMessage());
        }
        return false;
    }

    /**
     * Get statistics about a program's knowledge graph.
     *
     * @param programHash The program hash
     * @return Map with "nodes" and "edges" counts
     */
    public Map<String, Integer> getKnowledgeGraphStats(String programHash) {
        Map<String, Integer> stats = new java.util.HashMap<>();
        stats.put("nodes", 0);
        stats.put("edges", 0);
        stats.put("stale_nodes", 0);

        String nodesSql = "SELECT COUNT(*) FROM graph_nodes WHERE binary_id = ?";
        // Count nodes that need summarization: stale OR missing summary
        String staleSql = "SELECT COUNT(*) FROM graph_nodes WHERE binary_id = ? " +
                "AND (is_stale = 1 OR llm_summary IS NULL OR llm_summary = '')";
        String edgesSql = "SELECT COUNT(*) FROM graph_edges e "
                + "INNER JOIN graph_nodes n ON e.source_id = n.id WHERE n.binary_id = ?";

        try (PreparedStatement nodesStmt = connection.prepareStatement(nodesSql);
             PreparedStatement staleStmt = connection.prepareStatement(staleSql);
             PreparedStatement edgesStmt = connection.prepareStatement(edgesSql)) {

            nodesStmt.setString(1, programHash);
            staleStmt.setString(1, programHash);
            edgesStmt.setString(1, programHash);

            ResultSet rs1 = nodesStmt.executeQuery();
            if (rs1.next()) {
                stats.put("nodes", rs1.getInt(1));
            }

            ResultSet rs2 = staleStmt.executeQuery();
            if (rs2.next()) {
                stats.put("stale_nodes", rs2.getInt(1));
            }

            ResultSet rs3 = edgesStmt.executeQuery();
            if (rs3.next()) {
                stats.put("edges", rs3.getInt(1));
            }
        } catch (SQLException e) {
            Msg.warn(this, "Error getting knowledge graph stats: " + e.getMessage());
        }
        return stats;
    }

    /**
     * Get the last updated timestamp (epoch ms) for a program's knowledge graph.
     *
     * @param programHash The program hash
     * @return Epoch milliseconds for most recent update, or null if unknown
     */
    public Long getKnowledgeGraphLastIndexed(String programHash) {
        String sql = "SELECT MAX(updated_at) FROM graph_nodes WHERE binary_id = ?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, programHash);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                long value = rs.getLong(1);
                if (!rs.wasNull() && value > 0) {
                    return value;
                }
            }
        } catch (SQLException e) {
            Msg.warn(this, "Error getting knowledge graph last indexed time: " + e.getMessage());
        }
        return null;
    }

    /**
     * Clear the cached BinaryKnowledgeGraph for a program.
     * Call this when switching programs or when the graph needs to be reloaded.
     *
     * @param programHash The program hash
     */
    public void invalidateKnowledgeGraphCache(String programHash) {
        graphCache.remove(programHash);
    }

    /**
     * Clear all cached BinaryKnowledgeGraph instances.
     */
    public void invalidateAllKnowledgeGraphCaches() {
        graphCache.clear();
    }

    public void close() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close();
            }
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error", "Failed to close Analysis database connection: " + e.getMessage());
        }
    }

    public static class Analysis {
        private final String query;
        private final String response;
        private final Timestamp timestamp;

        public Analysis(String query, String response, Timestamp timestamp) {
            this.query = query;
            this.response = response;
            this.timestamp = timestamp;
        }

        public String getQuery() { return query; }
        public String getResponse() { return response; }
        public Timestamp getTimestamp() { return timestamp; }
    }
    
    public static class ChatSession {
        private final int id;
        private final String description;
        private final Timestamp lastUpdate;

        public ChatSession(int id, String description, Timestamp lastUpdate) {
            this.id = id;
            this.description = description;
            this.lastUpdate = lastUpdate;
        }

        public int getId() { return id; }
        public String getDescription() { return description; }
        public Timestamp getLastUpdate() { return lastUpdate; }
    }

    /**
     * Data class for line explanations.
     */
    public static class LineExplanation {
        private final int id;
        private final String binaryId;
        private final long functionAddress;
        private final long lineAddress;
        private final String viewType;  // 'DECOMPILER' or 'DISASSEMBLY'
        private final String lineContent;
        private final String contextBefore;
        private final String contextAfter;
        private final String explanation;
        private final long createdAt;
        private final long updatedAt;

        public LineExplanation(int id, String binaryId, long functionAddress, long lineAddress,
                               String viewType, String lineContent, String contextBefore,
                               String contextAfter, String explanation, long createdAt, long updatedAt) {
            this.id = id;
            this.binaryId = binaryId;
            this.functionAddress = functionAddress;
            this.lineAddress = lineAddress;
            this.viewType = viewType;
            this.lineContent = lineContent;
            this.contextBefore = contextBefore;
            this.contextAfter = contextAfter;
            this.explanation = explanation;
            this.createdAt = createdAt;
            this.updatedAt = updatedAt;
        }

        public int getId() { return id; }
        public String getBinaryId() { return binaryId; }
        public long getFunctionAddress() { return functionAddress; }
        public long getLineAddress() { return lineAddress; }
        public String getViewType() { return viewType; }
        public String getLineContent() { return lineContent; }
        public String getContextBefore() { return contextBefore; }
        public String getContextAfter() { return contextAfter; }
        public String getExplanation() { return explanation; }
        public long getCreatedAt() { return createdAt; }
        public long getUpdatedAt() { return updatedAt; }
    }

    // ========================================
    // Line Explanation Methods
    // ========================================

    /**
     * Get a cached line explanation.
     *
     * @param binaryId The binary hash
     * @param lineAddress The address of the line
     * @param viewType 'DECOMPILER' or 'DISASSEMBLY'
     * @return LineExplanation if found, null otherwise
     */
    public LineExplanation getLineExplanation(String binaryId, long lineAddress, String viewType) {
        String sql = "SELECT id, binary_id, function_address, line_address, view_type, " +
                     "line_content, context_before, context_after, explanation, created_at, updated_at " +
                     "FROM line_explanations WHERE binary_id = ? AND line_address = ? AND view_type = ?";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, binaryId);
            stmt.setLong(2, lineAddress);
            stmt.setString(3, viewType);

            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return new LineExplanation(
                    rs.getInt("id"),
                    rs.getString("binary_id"),
                    rs.getLong("function_address"),
                    rs.getLong("line_address"),
                    rs.getString("view_type"),
                    rs.getString("line_content"),
                    rs.getString("context_before"),
                    rs.getString("context_after"),
                    rs.getString("explanation"),
                    rs.getLong("created_at"),
                    rs.getLong("updated_at")
                );
            }
        } catch (SQLException e) {
            Msg.warn(this, "Error getting line explanation: " + e.getMessage());
        }
        return null;
    }

    /**
     * Insert or update a line explanation.
     *
     * @param binaryId The binary hash
     * @param functionAddress The function containing this line
     * @param lineAddress The address of the line
     * @param viewType 'DECOMPILER' or 'DISASSEMBLY'
     * @param lineContent The actual code/instruction content
     * @param contextBefore Context lines before
     * @param contextAfter Context lines after
     * @param explanation The LLM-generated explanation
     */
    public void upsertLineExplanation(String binaryId, long functionAddress, long lineAddress,
                                       String viewType, String lineContent, String contextBefore,
                                       String contextAfter, String explanation) {
        String sql = "INSERT INTO line_explanations " +
                     "(binary_id, function_address, line_address, view_type, line_content, " +
                     "context_before, context_after, explanation, created_at, updated_at) " +
                     "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) " +
                     "ON CONFLICT(binary_id, line_address, view_type) DO UPDATE SET " +
                     "function_address = excluded.function_address, " +
                     "line_content = excluded.line_content, " +
                     "context_before = excluded.context_before, " +
                     "context_after = excluded.context_after, " +
                     "explanation = excluded.explanation, " +
                     "updated_at = excluded.updated_at";

        long now = System.currentTimeMillis();
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, binaryId);
            stmt.setLong(2, functionAddress);
            stmt.setLong(3, lineAddress);
            stmt.setString(4, viewType);
            stmt.setString(5, lineContent);
            stmt.setString(6, contextBefore);
            stmt.setString(7, contextAfter);
            stmt.setString(8, explanation);
            stmt.setLong(9, now);
            stmt.setLong(10, now);
            stmt.executeUpdate();
        } catch (SQLException e) {
            Msg.error(this, "Failed to upsert line explanation: " + e.getMessage(), e);
        }
    }

    /**
     * Clear all line explanations for a function.
     * Useful when function is re-analyzed or renamed.
     *
     * @param binaryId The binary hash
     * @param functionAddress The function address
     * @return Number of deleted rows
     */
    public int clearLineExplanationsForFunction(String binaryId, long functionAddress) {
        String sql = "DELETE FROM line_explanations WHERE binary_id = ? AND function_address = ?";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, binaryId);
            stmt.setLong(2, functionAddress);
            return stmt.executeUpdate();
        } catch (SQLException e) {
            Msg.error(this, "Failed to clear line explanations: " + e.getMessage(), e);
        }
        return 0;
    }

    /**
     * Clear a specific line explanation.
     *
     * @param binaryId The binary hash
     * @param lineAddress The line address
     * @param viewType 'DECOMPILER' or 'DISASSEMBLY'
     * @return true if deleted
     */
    public boolean clearLineExplanation(String binaryId, long lineAddress, String viewType) {
        String sql = "DELETE FROM line_explanations WHERE binary_id = ? AND line_address = ? AND view_type = ?";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, binaryId);
            stmt.setLong(2, lineAddress);
            stmt.setString(3, viewType);
            return stmt.executeUpdate() > 0;
        } catch (SQLException e) {
            Msg.error(this, "Failed to clear line explanation: " + e.getMessage(), e);
        }
        return false;
    }

    // ReAct Message Storage Methods

    /**
     * Save a ReAct message to GHReActMessages table.
     *
     * @param programHash Program hash
     * @param sessionId Chat session ID
     * @param messageOrder Message order in conversation
     * @param phase Current phase (planning/investigation/reflection/synthesis)
     * @param iterationNumber Iteration number (null for planning/synthesis)
     * @param message ChatMessage to save
     * @return Generated message ID, or -1 on failure
     */
    public int saveReActMessage(String programHash, int sessionId, int messageOrder,
                                String phase, Integer iterationNumber,
                                ghidrassist.apiprovider.ChatMessage message) {
        String sql = "INSERT OR REPLACE INTO GHReActMessages " +
                "(program_hash, session_id, message_order, phase, iteration_number, role, content_text, native_message_data) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?)";

        try (PreparedStatement pstmt = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            pstmt.setString(1, programHash);
            pstmt.setInt(2, sessionId);
            pstmt.setInt(3, messageOrder);
            pstmt.setString(4, phase);
            if (iterationNumber != null) {
                pstmt.setInt(5, iterationNumber);
            } else {
                pstmt.setNull(5, java.sql.Types.INTEGER);
            }
            pstmt.setString(6, message.getRole());
            pstmt.setString(7, message.getContent());

            // Store native message data as JSON (tool_calls, tool_call_id, etc.)
            String nativeData = serializeMessageMetadata(message);
            pstmt.setString(8, nativeData);

            pstmt.executeUpdate();

            ResultSet rs = pstmt.getGeneratedKeys();
            if (rs.next()) {
                return rs.getInt(1);
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to save ReAct message: " + e.getMessage(), e);
        }
        return -1;
    }

    /**
     * Save a ReAct iteration chunk to GHReActIterationChunks table.
     *
     * @param programHash Program hash
     * @param sessionId Chat session ID
     * @param iterationNumber Iteration number
     * @param summary Iteration summary from LLM
     * @param messageStartIndex Start index in message list
     * @param messageEndIndex End index in message list
     * @return Generated chunk ID, or -1 on failure
     */
    public int saveReActIterationChunk(String programHash, int sessionId, int iterationNumber,
                                       String summary, int messageStartIndex, int messageEndIndex) {
        String sql = "INSERT OR REPLACE INTO GHReActIterationChunks " +
                "(program_hash, session_id, iteration_number, iteration_summary, message_start_index, message_end_index) " +
                "VALUES (?, ?, ?, ?, ?, ?)";

        try (PreparedStatement pstmt = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            pstmt.setString(1, programHash);
            pstmt.setInt(2, sessionId);
            pstmt.setInt(3, iterationNumber);
            pstmt.setString(4, summary);
            pstmt.setInt(5, messageStartIndex);
            pstmt.setInt(6, messageEndIndex);

            pstmt.executeUpdate();

            ResultSet rs = pstmt.getGeneratedKeys();
            if (rs.next()) {
                return rs.getInt(1);
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to save ReAct iteration chunk: " + e.getMessage(), e);
        }
        return -1;
    }

    /**
     * Serialize ChatMessage metadata to JSON for storage.
     */
    private String serializeMessageMetadata(ghidrassist.apiprovider.ChatMessage message) {
        com.google.gson.JsonObject json = new com.google.gson.JsonObject();

        if (message.getToolCalls() != null) {
            json.add("tool_calls", message.getToolCalls());
        }
        if (message.getToolCallId() != null) {
            json.addProperty("tool_call_id", message.getToolCallId());
        }
        if (message.getThinkingContent() != null) {
            json.addProperty("thinking_content", message.getThinkingContent());
        }
        if (message.getThinkingSignature() != null) {
            json.addProperty("thinking_signature", message.getThinkingSignature());
        }

        return json.toString();
    }

    /**
     * Get ReAct messages for a session.
     *
     * @param programHash Program hash
     * @param sessionId Session ID
     * @return List of messages ordered by message_order
     */
    public List<ghidrassist.apiprovider.ChatMessage> getReActMessages(String programHash, int sessionId) {
        List<ghidrassist.apiprovider.ChatMessage> messages = new ArrayList<>();
        String sql = "SELECT role, content_text, native_message_data FROM GHReActMessages " +
                "WHERE program_hash = ? AND session_id = ? ORDER BY message_order ASC";

        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, programHash);
            pstmt.setInt(2, sessionId);

            ResultSet rs = pstmt.executeQuery();
            com.google.gson.Gson gson = new com.google.gson.Gson();

            while (rs.next()) {
                String role = rs.getString("role");
                String content = rs.getString("content_text");
                String nativeData = rs.getString("native_message_data");

                ghidrassist.apiprovider.ChatMessage message = new ghidrassist.apiprovider.ChatMessage(role, content);

                // Restore metadata from JSON
                if (nativeData != null && !nativeData.isEmpty()) {
                    try {
                        com.google.gson.JsonObject json = gson.fromJson(nativeData, com.google.gson.JsonObject.class);

                        if (json.has("tool_calls")) {
                            message.setToolCalls(json.get("tool_calls").getAsJsonArray());
                        }
                        if (json.has("tool_call_id")) {
                            message.setToolCallId(json.get("tool_call_id").getAsString());
                        }
                        if (json.has("thinking_content")) {
                            message.setThinkingContent(json.get("thinking_content").getAsString());
                        }
                        if (json.has("thinking_signature")) {
                            message.setThinkingSignature(json.get("thinking_signature").getAsString());
                        }
                    } catch (Exception e) {
                        Msg.warn(this, "Failed to parse message metadata: " + e.getMessage());
                    }
                }

                messages.add(message);
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to retrieve ReAct messages: " + e.getMessage(), e);
        }

        return messages;
    }

    /**
     * Get ReAct iteration chunks for a session.
     *
     * @param programHash Program hash
     * @param sessionId Session ID
     * @return List of iteration summaries ordered by iteration number
     */
    public List<String> getReActIterationSummaries(String programHash, int sessionId) {
        List<String> summaries = new ArrayList<>();
        String sql = "SELECT iteration_summary FROM GHReActIterationChunks " +
                "WHERE program_hash = ? AND session_id = ? ORDER BY iteration_number ASC";

        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, programHash);
            pstmt.setInt(2, sessionId);

            ResultSet rs = pstmt.executeQuery();
            while (rs.next()) {
                String summary = rs.getString("iteration_summary");
                if (summary != null) {
                    summaries.add(summary);
                }
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to retrieve ReAct iteration summaries: " + e.getMessage(), e);
        }

        return summaries;
    }

    /**
     * Check if a session has ReAct messages.
     *
     * @param sessionId Session ID
     * @return true if session has ReAct messages
     */
    public boolean isReActSession(int sessionId) {
        String sql = "SELECT COUNT(*) FROM GHReActMessages WHERE session_id = ?";

        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setInt(1, sessionId);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return rs.getInt(1) > 0;
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to check if ReAct session: " + e.getMessage(), e);
        }

        return false;
    }

    /**
     * Get the maximum iteration number for a ReAct session.
     * Used to continue iteration numbering across multiple ReAct runs in same session.
     *
     * @param programHash Program hash
     * @param sessionId Session ID
     * @return Maximum iteration number, or 0 if no iterations exist
     */
    public int getMaxReActIteration(String programHash, int sessionId) {
        String sql = "SELECT COALESCE(MAX(iteration_number), 0) FROM GHReActIterationChunks " +
                "WHERE program_hash = ? AND session_id = ?";

        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, programHash);
            pstmt.setInt(2, sessionId);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return rs.getInt(1);
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to get max ReAct iteration: " + e.getMessage(), e);
        }

        return 0;
    }
}

```

`src/main/java/ghidrassist/GAUtils.java`:

```java
package ghidrassist;

import java.io.File;

public class GAUtils {
	public enum OperatingSystem {
	    WINDOWS, MAC, LINUX, UNKNOWN;
	
	    public static OperatingSystem detect() {
	        String os = System.getProperty("os.name").toLowerCase();
	        if (os.contains("win")) {
	            return WINDOWS;
	        } else if (os.contains("mac")) {
	            return MAC;
	        } else if (os.contains("nix") || os.contains("nux") || os.contains("aix")) {
	            return LINUX;
	        } else {
	            return UNKNOWN;
	        }
	    }
	}
	
	public static String getDefaultLucenePath(OperatingSystem os) {
	    String basePath;
	    switch (os) {
	        case WINDOWS:
	            basePath = System.getenv("LOCALAPPDATA");
	            if (basePath == null) {
	                throw new RuntimeException("Unable to access LOCALAPPDATA environment variable.");
	            }
	            break;

	        case MAC:
	            basePath = System.getProperty("user.home") + "/Library/Application Support";
	            break;

	        case LINUX:
	            basePath = System.getProperty("user.home") + "/.config";
	            break;

	        default:
	            throw new UnsupportedOperationException("Unsupported operating system: " + os);
	    }
	    return basePath + File.separator + "GhidrAssist" + File.separator + "LuceneIndex";
	}

}
```

`src/main/java/ghidrassist/GhidrAssistPlugin.java`:

```java
package ghidrassist;

import java.lang.reflect.Type;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

import ghidra.app.decompiler.DecompilerLocation;
import ghidra.app.plugin.PluginCategoryNames;
import ghidra.app.plugin.ProgramPlugin;
import ghidra.framework.plugintool.*;
import ghidra.framework.plugintool.util.PluginStatus;
import ghidra.framework.preferences.Preferences;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.FunctionManager;
import ghidra.program.model.listing.Program;
import ghidra.program.util.ProgramLocation;
import ghidrassist.apiprovider.APIProviderConfig;

@PluginInfo(
    status = PluginStatus.STABLE,
    packageName = "GhidrAssist",
    category = PluginCategoryNames.COMMON,
    shortDescription = "GhidrAssist LLM Plugin",
    description = "A plugin that provides code assistance using a language model."
)
public class GhidrAssistPlugin extends ProgramPlugin {
    public enum CodeViewType {
        IS_DECOMPILER,
        IS_DISASSEMBLER,
        UNKNOWN
    }
    private GhidrAssistProvider provider;
    private String lastActiveProvider;

    public GhidrAssistPlugin(PluginTool tool) {
        super(tool);
        String pluginName = getName();
        provider = new GhidrAssistProvider(this, pluginName);
    }

    @Override
    protected void dispose() {
        if (provider != null) {
            tool.removeComponentProvider(provider);
            provider = null;
        }
        super.dispose();
    }

    @Override
    public void locationChanged(ProgramLocation loc) {
        if (provider != null) {
            provider.getUI().updateLocation(loc);
        }
    }

    public Program getCurrentProgram() {
        return currentProgram;
    }

    public Address getCurrentAddress() {
        if (currentLocation != null) {
            return currentLocation.getAddress();
        }
        return null;
    }

    public Function getCurrentFunction() {
        Program program = getCurrentProgram();
        Address address = getCurrentAddress();

        if (program != null && address != null) {
            FunctionManager functionManager = program.getFunctionManager();
            return functionManager.getFunctionContaining(address);
        }
        return null;
    }

    public String getLastActiveProvider() {
        return lastActiveProvider;
    }
    
    public CodeViewType checkLastActiveCodeView() {
        if (currentLocation instanceof DecompilerLocation) {
            return CodeViewType.IS_DECOMPILER;
        } else if (currentLocation != null) {
            return CodeViewType.IS_DISASSEMBLER;
        } else {
            return CodeViewType.UNKNOWN;
        }
    }

    public static APIProviderConfig getCurrentProviderConfig() {
        // Load the list of API providers from preferences
        String providersJson = Preferences.getProperty("GhidrAssist.APIProviders", "[]");
        Gson gson = new Gson();
        Type listType = new TypeToken<List<APIProviderConfig>>() {}.getType();
        List<APIProviderConfig> apiProviders = gson.fromJson(providersJson, listType);

        // Load the selected provider name
        String selectedProviderName = Preferences.getProperty("GhidrAssist.SelectedAPIProvider", "");
        
        // Load the global API timeout setting
        String apiTimeoutStr = Preferences.getProperty("GhidrAssist.APITimeout", "120");
        Integer apiTimeout = 120; // Default value
        try {
            apiTimeout = Integer.parseInt(apiTimeoutStr);
        } catch (NumberFormatException e) {
            // Use default if there's an error
        }

        for (APIProviderConfig provider : apiProviders) {
            if (provider.getName().equals(selectedProviderName)) {
                // If the provider doesn't have a timeout set, use the global setting
                if (provider.getTimeout() == null) {
                    provider.setTimeout(apiTimeout);
                }
                return provider;
            }
        }

        return null;
    }
    
    public static Integer getGlobalApiTimeout() {
        String apiTimeoutStr = Preferences.getProperty("GhidrAssist.APITimeout", "120");
        try {
            return Integer.parseInt(apiTimeoutStr);
        } catch (NumberFormatException e) {
            return 120; // Default value
        }
    }

	public GhidrAssistPlugin getInstance() {
		return this;
	}
}
```

`src/main/java/ghidrassist/GhidrAssistProvider.java`:

```java
package ghidrassist;

import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;

import javax.swing.*;

import docking.ActionContext;
import docking.ComponentProvider;
import docking.DefaultActionContext;
import docking.action.DockingAction;
import docking.action.ToolBarData;
import ghidra.util.Msg;
import ghidrassist.resources.GhidrAssistIcons;
import ghidrassist.ui.GhidrAssistUI;
import resources.Icons;

public class GhidrAssistProvider extends ComponentProvider {
    private GhidrAssistPlugin plugin;
    private GhidrAssistUI ui;
    private JComponent mainPanel;
    private List<DockingAction> actions;

    public GhidrAssistProvider(GhidrAssistPlugin plugin, String owner) {
        super(plugin.getTool(), owner, owner);
        this.plugin = plugin;
        this.actions = new ArrayList<>();

        buildPanel();
        createActions();
        setIcon(GhidrAssistIcons.ROBOT_ICON);
    }

    private void buildPanel() {
        ui = new GhidrAssistUI(plugin);
        mainPanel = ui.getComponent();
        setVisible(true);
    }

    private void createActions() {
        DockingAction refreshAction = new DockingAction("Refresh GhidrAssist", getName()) {
            @Override
            public void actionPerformed(ActionContext context) {
                refresh();
            }
        };
        refreshAction.setToolBarData(new ToolBarData(Icons.REFRESH_ICON, null));
        refreshAction.setEnabled(true);
        refreshAction.markHelpUnnecessary();
        actions.add(refreshAction);

        // Add actions to the tool
        for (DockingAction action : actions) {
            plugin.getTool().addLocalAction(this, action);
        }
    }

    public GhidrAssistUI getUI() {
        return ui;
    }
    
    @Override
    public JComponent getComponent() {
        return mainPanel;
    }

    @Override
    public ActionContext getActionContext(MouseEvent event) {
        return new DefaultActionContext(this, mainPanel);
    }

    public void refresh() {
        try {
            Msg.info(this, "GhidrAssist UI refreshed");
        }
        catch (Exception e) {
            Msg.error(this, "Error refreshing GhidrAssist UI", e);
        }
    }
}
```

`src/main/java/ghidrassist/LlmApi.java`:

```java
package ghidrassist;

import ghidrassist.apiprovider.APIProviderConfig;
import ghidrassist.apiprovider.ChatMessage;
import ghidrassist.apiprovider.ReasoningConfig;
import ghidrassist.core.ConversationalToolHandler;
import ghidrassist.core.LlmApiClient;
import ghidrassist.core.LlmErrorHandler;
import ghidrassist.core.LlmTaskExecutor;
import ghidrassist.core.ResponseProcessor;
import ghidrassist.tools.registry.ToolRegistry;

import java.util.List;
import java.util.Map;

/**
 * - LlmApiClient: Provider management and API calls
 * - ResponseProcessor: Text filtering and processing
 * - LlmTaskExecutor: Background task execution
 * - LlmErrorHandler: Error handling and user feedback
 */
public class LlmApi {
    
    private final LlmApiClient apiClient;
    private final ResponseProcessor responseProcessor;
    private final LlmTaskExecutor taskExecutor;
    private final LlmErrorHandler errorHandler;
    private volatile ConversationalToolHandler activeConversationalHandler;
    
    public LlmApi(APIProviderConfig config, GhidrAssistPlugin plugin) {
        this.apiClient = new LlmApiClient(config, plugin);
        this.responseProcessor = new ResponseProcessor();
        this.taskExecutor = new LlmTaskExecutor();
        this.errorHandler = new LlmErrorHandler(plugin, this);
    }

    /**
     * Get the system prompt for regular queries
     */
    public String getSystemPrompt() {
        return apiClient.getSystemPrompt();
    }

    /**
     * Send a streaming request with enhanced error handling
     */
    public void sendRequestAsync(String prompt, LlmResponseHandler responseHandler) {
        if (!apiClient.isProviderAvailable()) {
            errorHandler.handleError(
                new IllegalStateException("LLM provider is not initialized."), 
                "send request", 
                null
            );
            return;
        }

        // Create enhanced response handler that includes error handling
        LlmTaskExecutor.LlmResponseHandler enhancedHandler = new LlmTaskExecutor.LlmResponseHandler() {
            @Override
            public void onStart() {
                responseHandler.onStart();
            }

            @Override
            public void onUpdate(String partialResponse) {
                responseHandler.onUpdate(partialResponse);
            }

            @Override
            public void onComplete(String fullResponse) {
                responseHandler.onComplete(fullResponse);
            }

            @Override
            public void onError(Throwable error) {
                // Handle error with enhanced error handling
                Runnable retryAction = () -> sendRequestAsync(prompt, responseHandler);
                errorHandler.handleError(error, "stream chat completion", retryAction);
                responseHandler.onError(error);
            }

            @Override
            public boolean shouldContinue() {
                return responseHandler.shouldContinue();
            }
        };

        taskExecutor.executeStreamingRequest(apiClient, prompt, responseProcessor, enhancedHandler);
    }

    /**
     * Send a conversational tool calling request that handles multiple turns
     * Monitors finish_reason to determine when to execute tools vs. complete
     */
    public void sendConversationalToolRequest(String prompt, List<Map<String, Object>> functions,
            LlmResponseHandler responseHandler, int maxToolRounds, ToolRegistry toolRegistry) {
        if (!apiClient.isProviderAvailable()) {
            errorHandler.handleError(
                new IllegalStateException("LLM provider is not initialized."),
                "send conversational tool request",
                null
            );
            return;
        }

        // Create completion callback to clear reference
        Runnable onCompletion = () -> {
            activeConversationalHandler = null;
        };

        // Create enhanced response handler for conversational tool calling
        ConversationalToolHandler toolHandler = new ConversationalToolHandler(
            apiClient, functions, responseProcessor, responseHandler, errorHandler, onCompletion,
            maxToolRounds, toolRegistry);

        // Store reference for cancellation
        activeConversationalHandler = toolHandler;

        // Start the conversation
        toolHandler.startConversation(prompt);
    }

    /**
     * Send a conversational tool calling request with existing history.
     * This preserves thinking content, tool calls, and other metadata from previous turns.
     *
     * @param existingHistory List of ChatMessages from previous conversation
     * @param newPrompt The new user message to add
     * @param functions Available function definitions
     * @param responseHandler Handler for streaming responses
     * @param maxToolRounds Maximum number of tool calling rounds
     * @param toolRegistry Registry for tool execution
     */
    public void sendConversationalToolRequestWithHistory(
            List<ChatMessage> existingHistory,
            String newPrompt,
            List<Map<String, Object>> functions,
            LlmResponseHandler responseHandler,
            int maxToolRounds,
            ToolRegistry toolRegistry) {

        if (!apiClient.isProviderAvailable()) {
            errorHandler.handleError(
                new IllegalStateException("LLM provider is not initialized."),
                "send conversational tool request with history",
                null
            );
            return;
        }

        // Create completion callback to clear reference
        Runnable onCompletion = () -> {
            activeConversationalHandler = null;
        };

        // Create enhanced response handler for conversational tool calling
        ConversationalToolHandler toolHandler = new ConversationalToolHandler(
            apiClient, functions, responseProcessor, responseHandler, errorHandler, onCompletion,
            maxToolRounds, toolRegistry);

        // Store reference for cancellation
        activeConversationalHandler = toolHandler;

        // Start the conversation with existing history
        toolHandler.startConversationWithHistory(existingHistory, newPrompt);
    }

    /**
     * Send a function calling request with enhanced error handling (legacy method)
     */
    public void sendRequestAsyncWithFunctions(String prompt, List<Map<String, Object>> functions, LlmResponseHandler responseHandler) {
        if (!apiClient.isProviderAvailable()) {
            errorHandler.handleError(
                new IllegalStateException("LLM provider is not initialized."), 
                "send function request", 
                null
            );
            return;
        }

        // Create enhanced response handler that includes error handling
        LlmTaskExecutor.LlmResponseHandler enhancedHandler = new LlmTaskExecutor.LlmResponseHandler() {
            @Override
            public void onStart() {
                responseHandler.onStart();
            }

            @Override
            public void onUpdate(String partialResponse) {
                responseHandler.onUpdate(partialResponse);
            }

            @Override
            public void onComplete(String fullResponse) {
                responseHandler.onComplete(fullResponse);
            }

            @Override
            public void onError(Throwable error) {
                // Handle error with enhanced error handling
                Runnable retryAction = () -> sendRequestAsyncWithFunctions(prompt, functions, responseHandler);
                errorHandler.handleError(error, "chat completion with functions", retryAction);
                responseHandler.onError(error);
            }

            @Override
            public boolean shouldContinue() {
                return responseHandler.shouldContinue();
            }
        };

        taskExecutor.executeFunctionRequest(apiClient, prompt, functions, responseProcessor, enhancedHandler);
    }

    /**
     * Cancel the current request
     */
    public void cancelCurrentRequest() {
        // Cancel conversational tool handler if active
        if (activeConversationalHandler != null) {
            activeConversationalHandler.cancel();
            activeConversationalHandler = null;
        }
        
        // Cancel regular task executor
        taskExecutor.cancelCurrentRequest();
    }

    /**
     * Check if currently processing a request
     */
    public boolean isStreaming() {
        return taskExecutor.isStreaming();
    }
    
    /**
     * Get provider information for debugging/logging
     */
    public String getProviderInfo() {
        return String.format("Provider: %s, Model: %s",
            apiClient.getProviderName(),
            apiClient.getProviderModel());
    }

    /**
     * Set the reasoning configuration for this LLM instance.
     * This affects how the provider constructs requests with thinking/reasoning parameters.
     */
    public void setReasoningConfig(ReasoningConfig config) {
        ghidra.util.Msg.info(this, "DEBUG [LlmApi.setReasoningConfig]: Called with " +
            (config != null ? config.getEffort() + ", enabled=" + config.isEnabled() : "NULL"));
        ghidra.util.Msg.info(this, "DEBUG [LlmApi.setReasoningConfig]: apiClient=" +
            (apiClient != null ? "NOT NULL" : "NULL") + ", provider=" +
            (apiClient != null && apiClient.getProvider() != null ? "NOT NULL" : "NULL"));

        if (apiClient != null && apiClient.getProvider() != null) {
            apiClient.getProvider().setReasoningConfig(config);
        } else {
            ghidra.util.Msg.warn(this, "DEBUG [LlmApi.setReasoningConfig]: Cannot set - apiClient or provider is NULL!");
        }
    }

    /**
     * Get the current reasoning configuration.
     */
    public ReasoningConfig getReasoningConfig() {
        if (apiClient != null && apiClient.getProvider() != null) {
            return apiClient.getProvider().getReasoningConfig();
        }
        ghidra.util.Msg.warn(this, "DEBUG [LlmApi.getReasoningConfig]: Returning default - apiClient or provider is NULL!");
        return new ReasoningConfig();
    }

    /**
     * Interface for handling LLM responses - maintains compatibility with existing code
     */
    public interface LlmResponseHandler {
        void onStart();
        void onUpdate(String partialResponse);
        void onComplete(String fullResponse);
        void onError(Throwable error);
        default boolean shouldContinue() {
            return true;
        }
    }
}
```

`src/main/java/ghidrassist/RLHFDatabase.java`:

```java
package ghidrassist;

import ghidra.framework.preferences.Preferences;
import ghidra.util.Msg;

import java.sql.*;

public class RLHFDatabase {

    private static final String DB_PATH_PROPERTY = "GhidrAssist.RLHFDatabasePath";
    private static final String DEFAULT_DB_PATH = "ghidrassist_rlhf.db";
    private Connection connection;

    public RLHFDatabase() {
        String dbPath = Preferences.getProperty(DB_PATH_PROPERTY, DEFAULT_DB_PATH);
        initializeDatabase(dbPath);
    }

    private void initializeDatabase(String dbPath) {
        try {
            connection = DriverManager.getConnection("jdbc:sqlite:" + dbPath);
            createFeedbackTable();
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error", "Failed to initialize RLHF database: " + e.getMessage());
        }
    }

    private void createFeedbackTable() throws SQLException {
        String createTableSQL = "CREATE TABLE IF NOT EXISTS feedback ("
                + "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                + "model_name TEXT NOT NULL,"
                + "prompt_context TEXT NOT NULL,"
                + "system_context TEXT NOT NULL,"
                + "response TEXT NOT NULL,"
                + "feedback INTEGER NOT NULL" // 1 for thumbs up, 0 for thumbs down
                + ")";
        Statement stmt = connection.createStatement();
        stmt.execute(createTableSQL);
        stmt.close();
    }

    public void storeFeedback(String modelName, String promptContext, String systemContext, String response, int feedback) {
        String insertSQL = "INSERT INTO feedback (model_name, prompt_context, system_context, response, feedback) "
                + "VALUES (?, ?, ?, ?, ?)";
        try (PreparedStatement pstmt = connection.prepareStatement(insertSQL)) {
            pstmt.setString(1, modelName);
            pstmt.setString(2, promptContext);
            pstmt.setString(3, systemContext);
            pstmt.setString(4, response);
            pstmt.setInt(5, feedback);
            pstmt.executeUpdate();
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error", "Failed to store feedback: " + e.getMessage());
        }
    }

    public void close() {
        try {
            connection.close();
        } catch (SQLException e) {
            Msg.showError(this, null, "Database Error", "Failed to close RLHF database connection: " + e.getMessage());
        }
    }
}

```

`src/main/java/ghidrassist/agent/react/ContextSummarizer.java`:

```java
package ghidrassist.agent.react;

/**
 * Manages context summarization to stay within token limits.
 * Compresses conversation history while retaining key information.
 */
public class ContextSummarizer {

    private final int summaryThreshold;  // Trigger summarization after this many chars

    public ContextSummarizer() {
        this(8000);  // Default threshold
    }

    public ContextSummarizer(int summaryThreshold) {
        this.summaryThreshold = summaryThreshold;
    }

    /**
     * Check if summarization is needed based on context size.
     */
    public boolean needsSummarization(int currentSize) {
        return currentSize > summaryThreshold;
    }

    /**
     * Create a compact summary of current progress.
     */
    public String createSummary(
        String objective,
        TodoListManager todoManager,
        FindingsCache findings
    ) {
        StringBuilder sb = new StringBuilder();

        sb.append("## Investigation Summary\n\n");
        sb.append("**Objective**: ").append(objective).append("\n\n");

        // Progress
        sb.append("**Progress**: ").append(todoManager.toCompactString()).append("\n\n");

        // Completed todos with evidence
        String completed = todoManager.getCompletedSummary();
        if (!completed.isEmpty()) {
            sb.append("**Completed**:\n");
            sb.append(completed).append("\n\n");
        }

        // Pending todos
        String pending = todoManager.formatForPrompt();
        if (!pending.isEmpty() && !todoManager.allComplete()) {
            sb.append("**Still To Do**:\n");
            sb.append(pending).append("\n\n");
        }

        // Key findings
        sb.append("**Key Findings** (").append(findings.getCount()).append(" total):\n");
        sb.append(findings.formatForPrompt(15)).append("\n\n");

        return sb.toString();
    }

    /**
     * Create a continuation prompt after summarization.
     * This replaces the long conversation history.
     */
    public String createContinuationPrompt(String summary) {
        return String.format("""
            You are continuing a reverse engineering investigation.
            Here's what has been done so far:

            %s

            Continue the investigation based on the pending todos and what you've learned.
            Use tools to gather any additional information needed.
            """,
            summary
        );
    }

    /**
     * Estimate context size in characters (rough approximation).
     */
    public int estimateContextSize(
        String objective,
        TodoListManager todoManager,
        FindingsCache findings,
        int conversationSize
    ) {
        return objective.length() +
               todoManager.formatForPrompt().length() +
               findings.formatForPrompt().length() +
               conversationSize;
    }

    public int getSummaryThreshold() {
        return summaryThreshold;
    }
}

```

`src/main/java/ghidrassist/agent/react/ConversationHistoryManager.java`:

```java
package ghidrassist.agent.react;

import ghidrassist.AnalysisDB;
import ghidrassist.apiprovider.ChatMessage;
import ghidra.util.Msg;

import java.util.ArrayList;
import java.util.List;

/**
 * Manages unified conversation history for ReAct agent with chunked iteration storage.
 *
 * Maintains single conversation list throughout all ReAct phases (planning, investigation,
 * reflection, synthesis) with per-iteration chunk boundaries for efficient storage and
 * retrieval.
 *
 * Design:
 * - All messages stored in single list with metadata (phase, iteration)
 * - Iteration boundaries marked with summaries for context compression
 * - Database integration for persistence across sessions
 * - Supports BinAssist parity: unified history instead of separate planning/investigation lists
 */
public class ConversationHistoryManager {

    private final List<ChatMessage> conversationHistory;
    private final List<IterationChunk> iterationChunks;
    private final AnalysisDB database;
    private final String programHash;
    private final int sessionId;

    /**
     * Represents a chunk of conversation for one iteration.
     */
    public static class IterationChunk {
        private final int iterationNumber;
        private final int messageStartIndex;
        private int messageEndIndex;  // Mutable until chunk is finalized
        private String iterationSummary;

        public IterationChunk(int iterationNumber, int messageStartIndex) {
            this.iterationNumber = iterationNumber;
            this.messageStartIndex = messageStartIndex;
            this.messageEndIndex = messageStartIndex;
        }

        public void finalizeChunk(int endIndex, String summary) {
            this.messageEndIndex = endIndex;
            this.iterationSummary = summary;
        }

        public int getIterationNumber() { return iterationNumber; }
        public int getMessageStartIndex() { return messageStartIndex; }
        public int getMessageEndIndex() { return messageEndIndex; }
        public String getIterationSummary() { return iterationSummary; }
    }

    /**
     * Create history manager for current ReAct session.
     *
     * @param database Database for persistence
     * @param programHash Current program hash
     * @param sessionId Current session ID
     */
    public ConversationHistoryManager(AnalysisDB database, String programHash, int sessionId) {
        this.conversationHistory = new ArrayList<>();
        this.iterationChunks = new ArrayList<>();
        this.database = database;
        this.programHash = programHash;
        this.sessionId = sessionId;
    }

    /**
     * Add message to conversation history with metadata.
     *
     * @param message Chat message to add
     * @param phase Current phase ("planning", "investigation", "reflection", "synthesis")
     * @param iterationNumber Current iteration (0 for planning)
     */
    public void addMessage(ChatMessage message, String phase, int iterationNumber) {
        conversationHistory.add(message);

        // Log for debugging
        Msg.debug(this, String.format(
            "Added message to history: phase=%s, iteration=%d, role=%s, size=%d",
            phase, iterationNumber, message.getRole(), conversationHistory.size()
        ));
    }

    /**
     * Start a new iteration chunk (marks beginning of iteration).
     *
     * @param iterationNumber Iteration number
     */
    public void startIterationChunk(int iterationNumber) {
        int startIndex = conversationHistory.size();
        IterationChunk chunk = new IterationChunk(iterationNumber, startIndex);
        iterationChunks.add(chunk);

        Msg.debug(this, String.format(
            "Started iteration chunk %d at message index %d",
            iterationNumber, startIndex
        ));
    }

    /**
     * Store iteration summary and finalize current chunk (marks end of iteration).
     *
     * @param iterationNumber Iteration number
     * @param summary LLM's summary of what was discovered in this iteration
     */
    public void storeIterationSummary(int iterationNumber, String summary) {
        // Find the chunk for this iteration
        for (IterationChunk chunk : iterationChunks) {
            if (chunk.getIterationNumber() == iterationNumber) {
                int endIndex = conversationHistory.size() - 1;
                chunk.finalizeChunk(endIndex, summary);

                Msg.debug(this, String.format(
                    "Finalized iteration chunk %d: messages [%d-%d], summary length=%d",
                    iterationNumber, chunk.getMessageStartIndex(), endIndex,
                    summary != null ? summary.length() : 0
                ));

                // Persist to database if available
                if (database != null) {
                    persistIterationChunk(chunk);
                }

                return;
            }
        }

        Msg.warn(this, "No chunk found for iteration " + iterationNumber);
    }

    /**
     * Get current conversation history (full unified list).
     *
     * @return List of all messages in conversation
     */
    public List<ChatMessage> getConversation() {
        return new ArrayList<>(conversationHistory);
    }

    /**
     * Get messages for a specific iteration.
     *
     * @param iterationNumber Iteration to retrieve
     * @return Messages from that iteration, or empty list if not found
     */
    public List<ChatMessage> getIterationMessages(int iterationNumber) {
        for (IterationChunk chunk : iterationChunks) {
            if (chunk.getIterationNumber() == iterationNumber) {
                int start = chunk.getMessageStartIndex();
                int end = Math.min(chunk.getMessageEndIndex() + 1, conversationHistory.size());
                return new ArrayList<>(conversationHistory.subList(start, end));
            }
        }
        return new ArrayList<>();
    }

    /**
     * Get all iteration summaries.
     *
     * @return List of summaries in iteration order
     */
    public List<String> getIterationSummaries() {
        List<String> summaries = new ArrayList<>();
        for (IterationChunk chunk : iterationChunks) {
            if (chunk.getIterationSummary() != null) {
                summaries.add(chunk.getIterationSummary());
            }
        }
        return summaries;
    }

    /**
     * Get formatted iteration summaries for prompt.
     *
     * @return Formatted string with iteration summaries
     */
    public String formatIterationSummaries() {
        if (iterationChunks.isEmpty()) {
            return "No iteration summaries available.";
        }

        StringBuilder sb = new StringBuilder();
        for (IterationChunk chunk : iterationChunks) {
            if (chunk.getIterationSummary() != null) {
                sb.append("### Iteration ").append(chunk.getIterationNumber()).append("\n");
                sb.append(chunk.getIterationSummary()).append("\n\n");
            }
        }
        return sb.toString();
    }

    /**
     * Restore conversation history from database.
     *
     * @param programHash Program hash to restore
     * @param sessionId Session ID to restore
     * @return Restored conversation history
     */
    public static List<ChatMessage> restoreConversation(
        AnalysisDB database,
        String programHash,
        int sessionId
    ) {
        if (database == null) {
            return new ArrayList<>();
        }

        // TODO: Implement database retrieval
        // This will query GHReActMessages table ordered by message_order
        // and reconstruct ChatMessage objects

        Msg.warn(ConversationHistoryManager.class,
            "Conversation restoration not yet implemented - database schema pending");

        return new ArrayList<>();
    }

    /**
     * Persist iteration chunk to database.
     */
    private void persistIterationChunk(IterationChunk chunk) {
        if (database == null) {
            return;
        }

        try {
            // Save iteration chunk metadata
            database.saveReActIterationChunk(
                programHash,
                sessionId,
                chunk.getIterationNumber(),
                chunk.getIterationSummary(),
                chunk.getMessageStartIndex(),
                chunk.getMessageEndIndex()
            );

            // Save all messages in this chunk
            for (int i = chunk.getMessageStartIndex(); i <= chunk.getMessageEndIndex() && i < conversationHistory.size(); i++) {
                ChatMessage message = conversationHistory.get(i);
                database.saveReActMessage(
                    programHash,
                    sessionId,
                    i,
                    "investigation",  // phase - determined by iteration context
                    chunk.getIterationNumber(),
                    message
                );
            }

            Msg.debug(this, String.format(
                "Persisted iteration chunk %d with %d messages to database",
                chunk.getIterationNumber(),
                chunk.getMessageEndIndex() - chunk.getMessageStartIndex() + 1
            ));

        } catch (Exception e) {
            Msg.error(this, "Failed to persist iteration chunk: " + e.getMessage(), e);
        }
    }

    /**
     * Clear all conversation history (for reset).
     */
    public void clear() {
        conversationHistory.clear();
        iterationChunks.clear();
        Msg.debug(this, "Cleared conversation history");
    }

    /**
     * Get conversation size (total message count).
     */
    public int size() {
        return conversationHistory.size();
    }

    /**
     * Get iteration chunk count.
     */
    public int getIterationCount() {
        return iterationChunks.size();
    }

    /**
     * Get summary statistics for logging/debugging.
     */
    public String getStats() {
        return String.format(
            "ConversationHistory: %d messages, %d iterations",
            conversationHistory.size(), iterationChunks.size()
        );
    }
}

```

`src/main/java/ghidrassist/agent/react/FindingsCache.java`:

```java
package ghidrassist.agent.react;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Accumulates findings/evidence during analysis.
 * Tracks what tools discovered and maintains relevance scoring.
 * Enhanced with BinAssist keyword-based scoring for automatic relevance detection.
 */
public class FindingsCache {

    // BinAssist keyword scoring constants
    public static final int RELEVANCE_HIGH = 9;
    public static final int RELEVANCE_MEDIUM = 6;
    public static final int RELEVANCE_LOW = 3;

    // High-relevance keywords (security, vulnerabilities, critical findings)
    private static final Set<String> HIGH_KEYWORDS = new HashSet<>(Arrays.asList(
        "vulnerability", "exploit", "buffer overflow", "unsafe", "injection",
        "backdoor", "malware", "shellcode", "rop chain", "heap spray",
        "use after free", "double free", "stack overflow", "format string",
        "integer overflow", "null pointer", "race condition", "privilege",
        "escalation", "arbitrary code", "remote code execution"
    ));

    // Medium-relevance keywords (structural, functional analysis)
    private static final Set<String> MEDIUM_KEYWORDS = new HashSet<>(Arrays.asList(
        "function", "address", "reference", "import", "export",
        "symbol", "call", "jump", "branch", "loop", "condition",
        "parameter", "return", "register", "stack", "heap",
        "pointer", "structure", "class", "method", "variable",
        "string", "constant", "offset", "section", "segment"
    ));

    // Default relevance for findings without keyword matches
    private static final int DEFAULT_RELEVANCE = RELEVANCE_LOW;

    public static class Finding {
        private final String fact;
        private final String evidence;
        private final String toolUsed;
        private final long timestamp;
        private int relevance;  // Mutable - can be updated

        public Finding(String fact, String evidence, String toolUsed, int relevance) {
            this.fact = fact;
            this.evidence = evidence;
            this.toolUsed = toolUsed;
            this.relevance = relevance;
            this.timestamp = System.currentTimeMillis();
        }

        public String getFact() { return fact; }
        public String getEvidence() { return evidence; }
        public String getToolUsed() { return toolUsed; }
        public int getRelevance() { return relevance; }
        public long getTimestamp() { return timestamp; }

        public void setRelevance(int relevance) { this.relevance = relevance; }
    }

    private final List<Finding> findings;
    private final List<String> iterationSummaries;
    private final int maxFindings;

    public FindingsCache() {
        this(100);  // Keep up to 100 findings
    }

    public FindingsCache(int maxFindings) {
        this.findings = new ArrayList<>();
        this.iterationSummaries = new ArrayList<>();
        this.maxFindings = maxFindings;
    }

    /**
     * Add a finding from tool observation.
     */
    public void addFinding(String fact, String evidence, String toolUsed, int relevance) {
        findings.add(new Finding(fact, evidence, toolUsed, relevance));

        // Prune old low-relevance findings if we exceed max
        if (findings.size() > maxFindings) {
            pruneFindings();
        }
    }

    /**
     * Add a simple finding with default relevance.
     */
    public void addFinding(String fact, String toolUsed) {
        addFinding(fact, null, toolUsed, 5);  // Default medium relevance
    }

    /**
     * Extract key findings from tool output using keyword-based scoring.
     * Enhanced with BinAssist keyword matching for automatic relevance.
     */
    public void extractFromToolOutput(String toolName, String output) {
        if (output == null || output.isEmpty()) {
            return;
        }

        // Simple heuristics for extracting important information
        String[] lines = output.split("\n");
        for (String line : lines) {
            line = line.trim();

            // Skip empty or very short lines
            if (line.length() < 10) {
                continue;
            }

            // Skip lines that are too long (likely raw data)
            if (line.length() > 500) {
                continue;
            }

            // Calculate relevance based on keywords
            int relevance = calculateRelevance(line);

            // Only add findings with reasonable length and some relevance
            if (line.length() >= 20 && line.length() <= 300) {
                addFinding(line, output, toolName, relevance);
            }
        }
    }

    /**
     * Calculate relevance score based on keyword matching.
     * Returns highest matching keyword category score.
     */
    private int calculateRelevance(String text) {
        String lowerText = text.toLowerCase();

        // Check for high-relevance keywords first
        for (String keyword : HIGH_KEYWORDS) {
            if (lowerText.contains(keyword)) {
                return RELEVANCE_HIGH;
            }
        }

        // Check for medium-relevance keywords
        for (String keyword : MEDIUM_KEYWORDS) {
            if (lowerText.contains(keyword)) {
                return RELEVANCE_MEDIUM;
            }
        }

        // Default to low relevance
        return RELEVANCE_LOW;
    }

    /**
     * Remove low-relevance findings to stay within max limit.
     */
    private void pruneFindings() {
        if (findings.size() <= maxFindings) {
            return;
        }

        // Sort by relevance (descending) and keep top findings
        findings.sort(Comparator.comparingInt(Finding::getRelevance).reversed());

        // Remove lowest relevance findings
        while (findings.size() > maxFindings) {
            findings.remove(findings.size() - 1);
        }
    }

    /**
     * Format findings for LLM prompt - show most relevant.
     * Default: top 10 findings, no character limit.
     */
    public String formatForPrompt() {
        return formatForPrompt(10, 0);
    }

    /**
     * Format top N findings for prompt (no character limiting).
     */
    public String formatForPrompt(int maxShow) {
        return formatForPrompt(maxShow, 0);
    }

    /**
     * Format top N findings for prompt with optional character limiting.
     * Enhanced version supporting BinAssist parity (top 50 for iterations).
     *
     * @param maxShow Maximum number of findings to show
     * @param maxCharsPerFinding Maximum characters per finding (0 = no limit)
     * @return Formatted findings string
     */
    public String formatForPrompt(int maxShow, int maxCharsPerFinding) {
        if (findings.isEmpty()) {
            return "No significant findings yet.";
        }

        return findings.stream()
            .sorted(Comparator.comparingInt(Finding::getRelevance).reversed())
            .limit(maxShow)
            .map(f -> {
                String fact = f.getFact();
                // Apply character limit if specified
                if (maxCharsPerFinding > 0 && fact.length() > maxCharsPerFinding) {
                    fact = fact.substring(0, maxCharsPerFinding - 3) + "...";
                }
                return "• " + fact;
            })
            .collect(Collectors.joining("\n"));
    }

    /**
     * Get detailed findings with evidence.
     * Enhanced for synthesis with top 100 findings + iteration summaries (BinAssist parity).
     */
    public String formatDetailed() {
        return formatDetailed(100, true);
    }

    /**
     * Get detailed findings with custom limits.
     *
     * @param maxFindings Maximum number of findings to include
     * @param includeIterationSummaries Whether to include iteration summaries
     * @return Formatted detailed findings
     */
    public String formatDetailed(int maxFindings, boolean includeIterationSummaries) {
        StringBuilder sb = new StringBuilder();

        // Add iteration summaries first (provides context)
        if (includeIterationSummaries && !iterationSummaries.isEmpty()) {
            sb.append("## Investigation History\n\n");
            sb.append(formatIterationSummaries()).append("\n");
        }

        // Add findings
        if (findings.isEmpty()) {
            sb.append("## Findings\n\nNo findings accumulated.\n");
            return sb.toString();
        }

        sb.append("## Key Findings\n\n");
        findings.stream()
            .sorted(Comparator.comparingInt(Finding::getRelevance).reversed())
            .limit(maxFindings)
            .forEach(f -> {
                sb.append("**").append(f.getFact()).append("**");
                if (f.getToolUsed() != null) {
                    sb.append(" (from ").append(f.getToolUsed()).append(")");
                }
                sb.append("\n");
                if (f.getEvidence() != null && !f.getEvidence().isEmpty()) {
                    String truncated = f.getEvidence().length() > 200
                        ? f.getEvidence().substring(0, 200) + "..."
                        : f.getEvidence();
                    sb.append("Evidence: ").append(truncated).append("\n");
                }
                sb.append("\n");
            });

        return sb.toString();
    }

    /**
     * Summarize findings into compact form.
     * Used when context needs to be compressed.
     */
    public String summarize() {
        if (findings.isEmpty()) {
            return "No findings to summarize.";
        }

        // Get top findings by relevance
        List<Finding> topFindings = findings.stream()
            .sorted(Comparator.comparingInt(Finding::getRelevance).reversed())
            .limit(15)
            .collect(Collectors.toList());

        StringBuilder sb = new StringBuilder();
        sb.append("Key Findings Summary:\n");
        for (Finding f : topFindings) {
            sb.append("- ").append(f.getFact()).append("\n");
        }

        return sb.toString();
    }

    /**
     * Get count of findings.
     */
    public int getCount() {
        return findings.size();
    }

    /**
     * Get all findings.
     */
    public List<Finding> getAllFindings() {
        return new ArrayList<>(findings);
    }

    /**
     * Clear all findings (for context reset).
     */
    public void clear() {
        findings.clear();
        iterationSummaries.clear();
    }

    /**
     * Get compact representation for progress tracking.
     */
    public String toCompactString() {
        return String.format("%d findings accumulated", findings.size());
    }

    /**
     * Add a summary from an iteration.
     * This captures the LLM's analytical summary after each iteration.
     */
    public void addIterationSummary(String summary) {
        if (summary != null && !summary.trim().isEmpty()) {
            iterationSummaries.add(summary.trim());
        }
    }

    /**
     * Format iteration summaries for synthesis prompt.
     * Shows last 10 iterations by default.
     */
    public String formatIterationSummaries() {
        return formatIterationSummaries(10);
    }

    /**
     * Format iteration summaries with custom limit.
     */
    public String formatIterationSummaries(int maxIterations) {
        if (iterationSummaries.isEmpty()) {
            return "No iteration summaries available.";
        }

        // Get last N iterations (most recent)
        int startIdx = Math.max(0, iterationSummaries.size() - maxIterations);
        List<String> recent = iterationSummaries.subList(startIdx, iterationSummaries.size());

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < recent.size(); i++) {
            sb.append("### Iteration ").append(startIdx + i + 1).append("\n");
            sb.append(recent.get(i)).append("\n\n");
        }
        return sb.toString();
    }

    /**
     * Get all iteration summaries.
     * @return Copy of iteration summaries list
     */
    public List<String> getIterationSummaries() {
        return new ArrayList<>(iterationSummaries);
    }
}

```

`src/main/java/ghidrassist/agent/react/ReActOrchestrator.java`:

```java
package ghidrassist.agent.react;

import ghidrassist.AnalysisDB;
import ghidrassist.GhidrAssistPlugin;
import ghidrassist.LlmApi;
import ghidrassist.apiprovider.APIProviderConfig;
import ghidrassist.mcp2.tools.MCPTool;
import ghidrassist.mcp2.tools.MCPToolManager;
import ghidrassist.tools.api.Tool;
import ghidrassist.tools.native_.NativeToolManager;
import ghidrassist.tools.registry.ToolRegistry;

import ghidra.util.Msg;

import java.time.Duration;
import java.time.Instant;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * ReAct orchestrator that adds Think-Act-Observe structure on top of
 * the existing ConversationalToolHandler.
 *
 * Key features:
 * - Todo list management for tracking investigation progress
 * - Findings accumulation with relevance scoring
 * - Context window management with token-based thresholds
 * - Unified conversation history with chunked iterations
 * - Structured prompts with todos and findings
 * - Reflection-based plan adaptation
 * - Dynamic iteration budget extension
 *
 * Enhanced for BinAssist feature parity.
 */
public class ReActOrchestrator {

    // Configuration
    private int maxIterations;  // Now mutable for dynamic extension
    private final int baseMaxIterations;  // Original limit for tracking
    private final int contextSummaryThreshold;
    private final int maxToolRounds;  // Maximum tool calls per iteration

    // Dependencies
    private final LlmApi llmApi;
    private final MCPToolManager mcpToolManager;
    private final ToolRegistry toolRegistry;
    private final GhidrAssistPlugin plugin;

    // Conversation history manager (optional - for persistence)
    private ConversationHistoryManager historyManager;

    // Cancellation support
    private final AtomicBoolean cancelled = new AtomicBoolean(false);

    public ReActOrchestrator(APIProviderConfig providerConfig, GhidrAssistPlugin plugin) {
        this(providerConfig, plugin, 18, 8000, 10);
    }

    public ReActOrchestrator(
        APIProviderConfig providerConfig,
        GhidrAssistPlugin plugin,
        int maxIterations,
        int contextSummaryThreshold
    ) {
        this(providerConfig, plugin, maxIterations, contextSummaryThreshold, 10);
    }

    public ReActOrchestrator(
        APIProviderConfig providerConfig,
        GhidrAssistPlugin plugin,
        int maxIterations,
        int contextSummaryThreshold,
        int maxToolRounds
    ) {
        this.plugin = plugin;
        this.maxIterations = maxIterations;
        this.baseMaxIterations = maxIterations;  // Store original limit
        this.contextSummaryThreshold = contextSummaryThreshold;
        this.maxToolRounds = maxToolRounds > 0 ? maxToolRounds : 10;  // Default to 10 if invalid
        this.llmApi = new LlmApi(providerConfig, plugin);
        this.mcpToolManager = MCPToolManager.getInstance();

        // Apply saved reasoning config
        ghidra.program.model.listing.Program currentProgram = plugin.getCurrentProgram();
        if (currentProgram != null) {
            try {
                AnalysisDB analysisDB = new AnalysisDB();
                String programHash = currentProgram.getExecutableSHA256();
                String savedEffort = analysisDB.getReasoningEffort(programHash);
                if (savedEffort != null && !savedEffort.equalsIgnoreCase("none")) {
                    ghidrassist.apiprovider.ReasoningConfig reasoningConfig =
                            ghidrassist.apiprovider.ReasoningConfig.fromString(savedEffort);
                    llmApi.setReasoningConfig(reasoningConfig);
                }
            } catch (Exception e) {
                // Continue without reasoning config if loading fails
            }
        }

        // Initialize unified ToolRegistry with both native and MCP tools
        this.toolRegistry = initializeToolRegistry();
    }

    /**
     * Initialize the unified ToolRegistry with all tool providers.
     */
    private ToolRegistry initializeToolRegistry() {
        ToolRegistry registry = new ToolRegistry();

        try {
            // Register native tools (semantic, actions)
            AnalysisDB analysisDB = new AnalysisDB();
            NativeToolManager nativeManager = new NativeToolManager(analysisDB);
            registry.registerProvider(nativeManager);

            // Register MCP tools
            registry.registerProvider(mcpToolManager);

            // Set program context for tools that need it
            ghidra.program.model.listing.Program currentProgram = plugin.getCurrentProgram();
            if (currentProgram != null) {
                registry.setContext(currentProgram);
            }

            Msg.info(this, registry.getSummary());

        } catch (Exception e) {
            Msg.error(this, "Failed to initialize ToolRegistry: " + e.getMessage(), e);
        }

        return registry;
    }

    /**
     * Update program context for all tools when program changes.
     */
    public void updateProgramContext(ghidra.program.model.listing.Program program) {
        if (toolRegistry != null) {
            toolRegistry.setContext(program);
        }
    }

    /**
     * Get all tools from ToolRegistry in LLM function calling format.
     */
    private List<Map<String, Object>> getToolsAsFunction() {
        if (toolRegistry == null) {
            return List.of();
        }

        return toolRegistry.getAllTools().stream()
                .map(this::toolToFunctionSchema)
                .collect(Collectors.toList());
    }

    /**
     * Convert a Tool to OpenAI function calling schema format.
     */
    private Map<String, Object> toolToFunctionSchema(Tool tool) {
        Map<String, Object> function = new HashMap<>();
        function.put("type", "function");

        Map<String, Object> functionDef = new HashMap<>();
        functionDef.put("name", tool.getName());
        functionDef.put("description", tool.getDescription());

        if (tool.getInputSchema() != null) {
            // Convert JsonObject to Map for compatibility
            functionDef.put("parameters", jsonObjectToMap(tool.getInputSchema()));
        } else {
            // Empty parameters schema
            Map<String, Object> emptyParams = new HashMap<>();
            emptyParams.put("type", "object");
            emptyParams.put("properties", new HashMap<>());
            functionDef.put("parameters", emptyParams);
        }

        function.put("function", functionDef);
        return function;
    }

    /**
     * Convert JsonObject to Map for function schema compatibility.
     */
    private Map<String, Object> jsonObjectToMap(com.google.gson.JsonObject jsonObject) {
        Map<String, Object> map = new HashMap<>();
        for (String key : jsonObject.keySet()) {
            Object value = jsonElementToObject(jsonObject.get(key));
            map.put(key, value);
        }
        return map;
    }

    /**
     * Convert JsonElement to Java object.
     */
    private Object jsonElementToObject(com.google.gson.JsonElement element) {
        if (element.isJsonPrimitive()) {
            if (element.getAsJsonPrimitive().isString()) {
                return element.getAsString();
            } else if (element.getAsJsonPrimitive().isNumber()) {
                return element.getAsNumber();
            } else if (element.getAsJsonPrimitive().isBoolean()) {
                return element.getAsBoolean();
            }
        } else if (element.isJsonObject()) {
            return jsonObjectToMap(element.getAsJsonObject());
        } else if (element.isJsonArray()) {
            com.google.gson.JsonArray array = element.getAsJsonArray();
            java.util.ArrayList<Object> list = new java.util.ArrayList<>();
            for (int i = 0; i < array.size(); i++) {
                list.add(jsonElementToObject(array.get(i)));
            }
            return list;
        }
        return null;
    }

    /**
     * Analyze a query using ReAct pattern with conversational tool calling.
     */
    public CompletableFuture<ReActResult> analyze(
        String query,
        String initialContext,
        String sessionId,
        ReActProgressHandler handler
    ) {
        CompletableFuture<ReActResult> resultFuture = new CompletableFuture<>();

        // Run asynchronously
        CompletableFuture.runAsync(() -> {
            Instant startTime = Instant.now();
            cancelled.set(false);

            try {
                // Initialize components
                TodoListManager todoManager = new TodoListManager(query);
                FindingsCache findings = new FindingsCache();
                ContextSummarizer summarizer = new ContextSummarizer(contextSummaryThreshold);

                handler.onStart(query);

                // First, ask LLM to propose investigation steps
                Msg.info(this, "Asking LLM to plan investigation steps...");
                String planningPrompt = ReActPrompts.getPlanningPrompt(query, initialContext);

                // Get todo plan from LLM (synchronous for simplicity)
                CompletableFuture<String> planningFuture = new CompletableFuture<>();
                llmApi.sendRequestAsync(planningPrompt, new LlmApi.LlmResponseHandler() {
                    private final StringBuilder planResponse = new StringBuilder();

                    @Override
                    public void onStart() {
                        planResponse.setLength(0);
                    }

                    @Override
                    public void onUpdate(String partialResponse) {
                        planResponse.append(partialResponse);
                    }

                    @Override
                    public void onComplete(String fullResponse) {
                        planningFuture.complete(fullResponse);
                    }

                    @Override
                    public void onError(Throwable error) {
                        planningFuture.completeExceptionally(error);
                    }

                    @Override
                    public boolean shouldContinue() {
                        return !cancelled.get() && handler.shouldContinue();
                    }
                });

                // Wait for planning to complete (generous timeout to accommodate rate limiting and token refresh)
                String todoList = planningFuture.get(180, java.util.concurrent.TimeUnit.SECONDS);
                todoManager.initializeFromLLMResponse(todoList);
                Msg.info(this, "Investigation plan created with " + todoManager.getAllTodos().size() + " steps");

                handler.onTodosUpdated(todoManager.formatForPrompt());

                // Get available tools from all providers via ToolRegistry
                List<Map<String, Object>> tools = getToolsAsFunction();
                if (tools.isEmpty()) {
                    Msg.warn(this, "No tools available - analysis may be limited");
                } else {
                    Msg.info(this, "Loaded " + tools.size() + " tools from ToolRegistry");
                }

                // Track iteration count
                AtomicInteger iteration = new AtomicInteger(0);
                AtomicInteger toolCallCount = new AtomicInteger(0);

                // Main ReAct loop
                runReActIteration(
                    query,
                    initialContext,
                    todoManager,
                    findings,
                    summarizer,
                    tools,
                    iteration,
                    toolCallCount,
                    handler,
                    startTime,
                    resultFuture
                );

            } catch (Exception e) {
                Msg.error(this, "ReAct analysis error: " + e.getMessage(), e);
                Duration duration = Duration.between(startTime, Instant.now());
                FindingsCache emptyFindings = new FindingsCache();
                ReActResult result = ReActResult.error(e, emptyFindings, duration);
                handler.onError(e);
                handler.onComplete(result);
                resultFuture.complete(result);
            }
        });

        return resultFuture;
    }

    /**
     * Run one iteration of the ReAct loop.
     */
    private void runReActIteration(
        String objective,
        String initialContext,
        TodoListManager todoManager,
        FindingsCache findings,
        ContextSummarizer summarizer,
        List<Map<String, Object>> tools,
        AtomicInteger iteration,
        AtomicInteger toolCallCount,
        ReActProgressHandler handler,
        Instant startTime,
        CompletableFuture<ReActResult> resultFuture
    ) {
        // Check termination conditions
        if (cancelled.get() || !handler.shouldContinue()) {
            Duration duration = Duration.between(startTime, Instant.now());
            resultFuture.complete(ReActResult.cancelled(findings, duration));
            return;
        }

        int currentIteration = iteration.incrementAndGet();

        if (currentIteration > maxIterations) {
            // Max iterations reached - synthesize answer
            synthesizeFinalAnswer(objective, todoManager, findings, tools, handler, startTime, resultFuture, currentIteration, toolCallCount.get(), ReActResult.Status.MAX_ITERATIONS);
            return;
        }

        if (todoManager.allComplete()) {
            // All todos done - synthesize answer
            synthesizeFinalAnswer(objective, todoManager, findings, tools, handler, startTime, resultFuture, currentIteration, toolCallCount.get(), ReActResult.Status.SUCCESS);
            return;
        }

        Msg.info(this, String.format("ReAct iteration %d/%d", currentIteration, maxIterations));

        // Mark next pending todo as in progress
        TodoListManager.Todo nextTodo = todoManager.getNextPending();
        if (nextTodo != null) {
            todoManager.setInProgress(nextTodo.getTask());
            handler.onTodosUpdated(todoManager.formatForPrompt());
        }

        // Build investigation prompt
        // Use enhanced findings format: top 50 findings, 500 chars each (BinAssist parity)
        String prompt = ReActPrompts.buildInvestigationPrompt(
            objective,
            currentIteration == 1 ? initialContext : null,  // Only include context on first iteration
            todoManager.formatForPrompt(),
            findings.formatForPrompt(50, 500),  // Top 50, max 500 chars per finding
            currentIteration
        );

        // Add warning if approaching limit
        if (maxIterations - currentIteration <= 3) {
            prompt += ReActPrompts.getIterationLimitWarning(maxIterations - currentIteration);
            handler.onIterationWarning(maxIterations - currentIteration);
        }

        // Create response handler for this iteration
        LlmApi.LlmResponseHandler iterationHandler = new LlmApi.LlmResponseHandler() {
            private final StringBuilder responseBuffer = new StringBuilder();
            private final StringBuilder displayBuffer = new StringBuilder();
            private boolean hasCalledTools = false;

            @Override
            public void onStart() {
                responseBuffer.setLength(0);
                displayBuffer.setLength(0);
            }

            @Override
            public void onUpdate(String partialResponse) {
                // Forward ALL conversational updates to the UI immediately
                if (partialResponse != null && !partialResponse.isEmpty()) {
                    responseBuffer.append(partialResponse);
                    displayBuffer.append(partialResponse);

                    // Pass through to progress handler for real-time display
                    // This shows tool execution, assistant thinking, etc.
                    handler.onThought(displayBuffer.toString(), currentIteration);
                }

                // Detect tool calls for tracking purposes
                if (partialResponse.contains("🔧") || partialResponse.contains("Executing tools")) {
                    hasCalledTools = true;
                    toolCallCount.incrementAndGet();
                }
            }

            @Override
            public void onComplete(String fullResponse) {
                // Extract findings from the response (keyword-based, for backwards compatibility)
                findings.extractFromToolOutput("llm_response", fullResponse);

                // Store the iteration summary (LLM's final analysis) for synthesis
                findings.addIterationSummary(fullResponse);

                // Update todos based on progress
                updateTodosFromResponse(todoManager, fullResponse);
                handler.onTodosUpdated(todoManager.formatForPrompt());

                // Check if we should continue or finish
                if (todoManager.allComplete() || !hasCalledTools) {
                    // Either done or no more tools to call - synthesize
                    synthesizeFinalAnswer(objective, todoManager, findings, tools, handler, startTime, resultFuture, currentIteration, toolCallCount.get(), ReActResult.Status.SUCCESS);
                } else {
                    // Perform self-reflection to determine if we should continue
                    performSelfReflection(
                        objective,
                        initialContext,
                        todoManager,
                        findings,
                        summarizer,
                        tools,
                        iteration,
                        toolCallCount,
                        handler,
                        startTime,
                        resultFuture,
                        currentIteration
                    );
                }
            }

            @Override
            public void onError(Throwable error) {
                Duration duration = Duration.between(startTime, Instant.now());
                ReActResult result = ReActResult.error(error, null, duration);
                handler.onError(error);
                handler.onComplete(result);
                resultFuture.complete(result);
            }

            @Override
            public boolean shouldContinue() {
                return handler.shouldContinue() && !cancelled.get();
            }
        };

        // Call the conversational tool handler
        llmApi.sendConversationalToolRequest(prompt, tools, iterationHandler, maxToolRounds, toolRegistry);
    }

    /**
     * Synthesize final answer from accumulated findings.
     */
    private void synthesizeFinalAnswer(
        String objective,
        TodoListManager todoManager,
        FindingsCache findings,
        List<Map<String, Object>> tools,
        ReActProgressHandler handler,
        Instant startTime,
        CompletableFuture<ReActResult> resultFuture,
        int iterationCount,
        int toolCallCount,
        ReActResult.Status completionStatus
    ) {
        String synthesisPrompt = ReActPrompts.getSynthesisPrompt(
            objective,
            findings.formatDetailed(),
            todoManager.getCompletedSummary(),
            findings.formatIterationSummaries()
        );

        // Get final answer without tool calling
        llmApi.sendRequestAsync(synthesisPrompt, new LlmApi.LlmResponseHandler() {
            private final StringBuilder answer = new StringBuilder();

            @Override
            public void onStart() {
                answer.setLength(0);
            }

            @Override
            public void onUpdate(String partialResponse) {
                answer.append(partialResponse);
                // Stream synthesis to UI
                handler.onSynthesisChunk(partialResponse);
            }

            @Override
            public void onComplete(String fullResponse) {
                Duration duration = Duration.between(startTime, Instant.now());

                // Build result with the provided completion status
                ReActResult result = new ReActResult.Builder()
                    .status(completionStatus)
                    .answer(fullResponse)
                    .findings(findings.getAllFindings().stream()
                        .map(f -> f.getFact())
                        .toList())
                    .iterationSummaries(findings.getIterationSummaries())
                    .iterationCount(iterationCount)
                    .toolCallCount(toolCallCount)
                    .duration(duration)
                    .build();

                handler.onComplete(result);
                resultFuture.complete(result);
            }

            @Override
            public void onError(Throwable error) {
                Duration duration = Duration.between(startTime, Instant.now());
                ReActResult result = ReActResult.error(error, null, duration);
                handler.onError(error);
                handler.onComplete(result);
                resultFuture.complete(result);
            }

            @Override
            public boolean shouldContinue() {
                return true;
            }
        });
    }

    /**
     * Perform self-reflection to determine if investigation should continue.
     */
    private void performSelfReflection(
        String objective,
        String initialContext,
        TodoListManager todoManager,
        FindingsCache findings,
        ContextSummarizer summarizer,
        List<Map<String, Object>> tools,
        AtomicInteger iteration,
        AtomicInteger toolCallCount,
        ReActProgressHandler handler,
        Instant startTime,
        CompletableFuture<ReActResult> resultFuture,
        int currentIteration
    ) {
        String reflectionPrompt = ReActPrompts.getReflectionPrompt(
            objective,
            findings.formatForPrompt(),
            todoManager.formatForPrompt()
        );

        // Ask the LLM to reflect
        CompletableFuture<String> reflectionFuture = new CompletableFuture<>();
        llmApi.sendRequestAsync(reflectionPrompt, new LlmApi.LlmResponseHandler() {
            private final StringBuilder reflection = new StringBuilder();

            @Override
            public void onStart() {
                reflection.setLength(0);
            }

            @Override
            public void onUpdate(String partialResponse) {
                reflection.append(partialResponse);
            }

            @Override
            public void onComplete(String fullResponse) {
                reflectionFuture.complete(fullResponse);
            }

            @Override
            public void onError(Throwable error) {
                // On error, default to continuing
                Msg.warn(ReActOrchestrator.this, "Reflection failed, continuing investigation: " + error.getMessage());
                reflectionFuture.complete("CONTINUE: Reflection error, continuing investigation");
            }

            @Override
            public boolean shouldContinue() {
                return !cancelled.get() && handler.shouldContinue();
            }
        });

        // Wait for reflection and decide next action
        reflectionFuture.thenAccept(reflectionResponse -> {
            String trimmedResponse = reflectionResponse.trim();

            // Parse structured reflection response for plan updates
            ReflectionParsed parsed = parseReflectionResponse(trimmedResponse);

            // Apply plan updates if present (ADD/REMOVE tasks)
            boolean planChanged = false;
            if (!parsed.tasksToAdd.isEmpty() || !parsed.tasksToRemove.isEmpty()) {
                planChanged = todoManager.updateFromReflection(parsed.tasksToAdd, parsed.tasksToRemove);

                if (planChanged) {
                    Msg.info(this, String.format(
                        "Reflection updated plan: +%d tasks, -%d tasks",
                        parsed.tasksToAdd.size(), parsed.tasksToRemove.size()
                    ));
                    handler.onTodosUpdated(todoManager.formatForPrompt());

                    // Dynamic iteration budget extension (BinAssist parity)
                    if (!parsed.tasksToAdd.isEmpty()) {
                        int extensionAmount = parsed.tasksToAdd.size();
                        maxIterations += extensionAmount;
                        Msg.info(this, String.format(
                            "Extended iteration budget by %d (new limit: %d)",
                            extensionAmount, maxIterations
                        ));
                        handler.onFinding(String.format(
                            "⚡ Extended investigation budget: +%d iterations (new limit: %d)",
                            extensionAmount, maxIterations
                        ));
                    }
                }
            }

            // Determine if ready to synthesize
            boolean shouldSynthesize = "READY".equals(parsed.decision);

            if (shouldSynthesize) {
                // Log reflection and decision
                handler.onFinding("Self-Reflection: " + parsed.assessment);
                handler.onFinding("Decision: READY - Sufficient information gathered, synthesizing final answer");
                synthesizeFinalAnswer(objective, todoManager, findings, tools, handler, startTime, resultFuture, currentIteration, toolCallCount.get(), ReActResult.Status.SUCCESS);
            } else {
                // Log reflection and decision
                handler.onFinding("Self-Reflection: " + parsed.assessment);
                handler.onFinding("Decision: CONTINUE - " + parsed.reason);
                // Continue to next iteration
                runReActIteration(
                    objective,
                    initialContext,
                    todoManager,
                    findings,
                    summarizer,
                    tools,
                    iteration,
                    toolCallCount,
                    handler,
                    startTime,
                    resultFuture
                );
            }
        }).exceptionally(error -> {
            Msg.error(this, "Reflection handling failed: " + error.getMessage(), error);
            handler.onThought("⚠️ **Error in reflection**: " + error.getMessage() + ". Continuing investigation...\n\n", currentIteration);
            // On error, continue investigation
            runReActIteration(
                objective,
                initialContext,
                todoManager,
                findings,
                summarizer,
                tools,
                iteration,
                toolCallCount,
                handler,
                startTime,
                resultFuture
            );
            return null;
        });
    }

    /**
     * Extract tool name from conversational handler update.
     */
    private String extractToolName(String message) {
        // ConversationalToolHandler formats as "🔧 Calling tool: <name>"
        if (message.contains("Calling tool:")) {
            int start = message.indexOf("Calling tool:") + 13;
            int end = message.indexOf("\n", start);
            if (end == -1) end = message.length();
            return message.substring(start, end).trim();
        }
        return null;
    }

    /**
     * Update todos based on iteration completion.
     * Marks the current in-progress todo as complete after an iteration.
     */
    private void updateTodosFromResponse(TodoListManager todoManager, String response) {
        // After each iteration with tool calls, mark the current in-progress todo as complete
        // The iteration has gathered information, so we consider the step done
        for (TodoListManager.Todo todo : todoManager.getAllTodos()) {
            if (todo.getStatus() == TodoListManager.TodoStatus.IN_PROGRESS) {
                // Mark complete - the investigation step has been executed
                todoManager.completeTodo(todo.getTask(), "Investigation step completed");
                Msg.info(this, "Completed todo: " + todo.getTask());
                break;  // Only one should be in progress at a time
            }
        }
    }

    /**
     * Parse structured reflection response.
     * Expected format:
     * **Assessment:** ...
     * **Plan Updates:**
     * - ADD: task (or "None")
     * - REMOVE: task (or "None")
     * **Decision:** READY or CONTINUE
     * **Reason:** ...
     */
    private ReflectionParsed parseReflectionResponse(String response) {
        ReflectionParsed parsed = new ReflectionParsed();

        String[] lines = response.split("\n");
        boolean inPlanUpdates = false;

        for (String line : lines) {
            line = line.trim();

            // Parse Assessment
            if (line.startsWith("**Assessment:**")) {
                parsed.assessment = line.substring("**Assessment:**".length()).trim();
            }
            // Parse Plan Updates section
            else if (line.startsWith("**Plan Updates:**")) {
                inPlanUpdates = true;
            }
            // Parse Decision
            else if (line.startsWith("**Decision:**")) {
                inPlanUpdates = false;
                String decision = line.substring("**Decision:**".length()).trim().toUpperCase();
                // Extract READY or CONTINUE
                if (decision.contains("READY") && !decision.contains("NOT READY")) {
                    parsed.decision = "READY";
                } else {
                    parsed.decision = "CONTINUE";
                }
            }
            // Parse Reason
            else if (line.startsWith("**Reason:**")) {
                parsed.reason = line.substring("**Reason:**".length()).trim();
            }
            // Parse ADD/REMOVE within Plan Updates
            else if (inPlanUpdates) {
                if (line.startsWith("- ADD:") || line.startsWith("-ADD:")) {
                    String task = line.replaceFirst("^-\\s*ADD:\\s*", "").trim();
                    if (!task.equalsIgnoreCase("None") && !task.isEmpty()) {
                        parsed.tasksToAdd.add(task);
                    }
                } else if (line.startsWith("- REMOVE:") || line.startsWith("-REMOVE:")) {
                    String task = line.replaceFirst("^-\\s*REMOVE:\\s*", "").trim();
                    if (!task.equalsIgnoreCase("None") && !task.isEmpty()) {
                        parsed.tasksToRemove.add(task);
                    }
                }
            }
        }

        // Fallback parsing if structured format not found
        if (parsed.decision == null) {
            String upperResponse = response.toUpperCase();
            if (upperResponse.contains("READY:") || upperResponse.startsWith("READY")) {
                parsed.decision = "READY";
                parsed.assessment = "Ready to synthesize (legacy format)";
            } else {
                parsed.decision = "CONTINUE";
                parsed.assessment = "Continue investigation (legacy format)";
            }
        }

        return parsed;
    }

    /**
     * Helper class for parsed reflection response.
     */
    private static class ReflectionParsed {
        String assessment = "";
        List<String> tasksToAdd = new java.util.ArrayList<>();
        List<String> tasksToRemove = new java.util.ArrayList<>();
        String decision = null;  // "READY" or "CONTINUE"
        String reason = "";
    }

    /**
     * Cancel the current analysis.
     */
    public void cancel() {
        cancelled.set(true);
        llmApi.cancelCurrentRequest();
    }
}

```

`src/main/java/ghidrassist/agent/react/ReActProgressHandler.java`:

```java
package ghidrassist.agent.react;

import com.google.gson.JsonObject;

/**
 * Callback interface for tracking ReAct agent progress.
 * Much simpler than AgentProgressHandler - no hypothesis/reflection callbacks.
 */
public interface ReActProgressHandler {

    /**
     * Called when analysis starts.
     * @param objective The user's query/question
     */
    void onStart(String objective);

    /**
     * Called when the agent generates a thought.
     * @param thought The agent's reasoning about what to do next
     * @param iteration Current iteration number (1-based)
     */
    void onThought(String thought, int iteration);

    /**
     * Called when the agent decides to execute a tool.
     * @param toolName Name of the tool being called
     * @param args Arguments for the tool call
     */
    void onAction(String toolName, JsonObject args);

    /**
     * Called when a tool execution completes.
     * @param toolName Name of the tool that was called
     * @param result Result from the tool execution
     */
    void onObservation(String toolName, String result);

    /**
     * Called when the agent adds a key finding.
     * @param finding A significant discovery worth highlighting
     */
    void onFinding(String finding);

    /**
     * Called when analysis completes (successfully or otherwise).
     * @param result The final analysis result
     */
    void onComplete(ReActResult result);

    /**
     * Called when an error occurs during analysis.
     * @param error The error that occurred
     */
    void onError(Throwable error);

    /**
     * Called periodically to check if analysis should continue.
     * @return true to continue, false to cancel
     */
    boolean shouldContinue();

    /**
     * Called when approaching iteration limit.
     * @param remaining Number of iterations remaining
     */
    default void onIterationWarning(int remaining) {
        // Default implementation does nothing - can be overridden
    }

    /**
     * Called when approaching tool call limit.
     * @param remaining Number of tool calls remaining
     */
    default void onToolCallWarning(int remaining) {
        // Default implementation does nothing - can be overridden
    }

    /**
     * Called when todos are updated.
     * @param todosFormatted Current todo list formatted for display
     */
    default void onTodosUpdated(String todosFormatted) {
        // Default implementation does nothing - can be overridden
    }

    /**
     * Called when context is being summarized.
     * @param summary The summary being created
     */
    default void onSummarizing(String summary) {
        // Default implementation does nothing - can be overridden
    }

    /**
     * Called when synthesis response is streaming.
     * @param chunk Chunk of the synthesis response
     */
    default void onSynthesisChunk(String chunk) {
        // Default implementation does nothing - can be overridden
    }
}

```

`src/main/java/ghidrassist/agent/react/ReActPrompts.java`:

```java
package ghidrassist.agent.react;

/**
 * Prompt templates for ReAct-style agent using function calling API.
 * Focus on structured thinking with todos and findings.
 */
public class ReActPrompts {

    /**
     * System prompt that sets up the ReAct mindset.
     * This goes in the initial system message.
     */
    public static String getSystemPrompt() {
        return """
            You are a reverse engineering assistant helping analyze binary code in Ghidra.

            You have access to powerful analysis tools. Work systematically:

            1. **Review the todo list** - what needs investigation
            2. **Check findings** - what you've already learned
            3. **Think** - what's the next most important thing to investigate
            4. **Use tools** - call the appropriate tool to get information
            5. **Reflect** - update your understanding based on observations
            6. **Track progress** - note what you've learned and what's still unknown

            ## Tool Selection Priority

            Tool names are prefixed with their provider:
            - Native GhidrAssist tools use `ga_` prefix (e.g., `ga_get_semantic_analysis`)
            - MCP server tools use `servername_` prefix (e.g., `ghidrassistmcp_decompile_function`)

            For understanding function behavior, PREFER these LLM-free semantic query tools:
            - `ga_get_semantic_analysis(address)` - Returns pre-computed summary, security flags, and relationships
            - `ga_get_similar_functions(address)` - Find structurally similar functions
            - `ga_get_call_context(address)` - Get callers/callees with their summaries
            - `ga_get_security_analysis(address)` - Get vulnerability flags and taint paths
            - `ga_search_semantic(query)` - Search functions by semantic keywords
            - `ga_get_module_summary(address)` - Get the module/subsystem a function belongs to
            - `ga_get_activity_analysis(address)` - Get network/file activity, APIs, and risk level

            These tools return pre-indexed semantic analysis and are MUCH faster than raw decompilation.
            Only use `decompile_function` when you need the actual source code (e.g., for specific
            line-by-line analysis) or when semantic analysis is not yet available.

            When you've gathered enough information to answer the user's question,
            provide a clear, comprehensive answer.

            Be systematic and thorough. Use the tools to gather facts, then synthesize
            your findings into actionable insights.
            """;
    }

    /**
     * Prompt for planning investigation steps.
     * Asks the LLM to propose a todo list.
     */
    public static String getPlanningPrompt(String objective, String initialContext) {
        StringBuilder sb = new StringBuilder();

        sb.append("## Investigation Planning\n\n");
        sb.append("**User's Question**: ").append(objective).append("\n\n");

        if (initialContext != null && !initialContext.isEmpty()) {
            sb.append("**Available Context**:\n```\n");
            String truncated = initialContext.length() > 1000
                ? initialContext.substring(0, 1000) + "\n... [truncated]"
                : initialContext;
            sb.append(truncated);
            sb.append("\n```\n\n");
        }

        sb.append("Before we start investigating, let's plan the investigation steps.\n\n");
        sb.append("**Task**: Based on the user's question");
        if (initialContext != null && !initialContext.isEmpty()) {
            sb.append(" and the available context");
        }
        sb.append(", propose a list of 3-5 investigation steps to answer this question.\n\n");
        sb.append("Format your response as a markdown checklist, for example:\n");
        sb.append("- [ ] First investigation step\n");
        sb.append("- [ ] Second investigation step\n");
        sb.append("- [ ] Third investigation step\n\n");
        sb.append("Focus on specific, actionable steps that use the available tools.\n");

        return sb.toString();
    }

    /**
     * Build the investigation prompt with current state.
     * Enhanced with BinAssist parity: iteration context, current task focus marker.
     */
    public static String buildInvestigationPrompt(
        String objective,
        String initialContext,
        String todos,
        String findings,
        int iteration
    ) {
        StringBuilder sb = new StringBuilder();

        sb.append("## Investigation Iteration ").append(iteration).append("\n\n");

        sb.append("**Your Goal**: ").append(objective).append("\n\n");

        if (initialContext != null && !initialContext.isEmpty() && iteration == 1) {
            // Only show initial context on first iteration
            sb.append("**Initial Context**:\n```\n");
            // Truncate if too long
            String truncated = initialContext.length() > 2000
                ? initialContext.substring(0, 2000) + "\n... [truncated]"
                : initialContext;
            sb.append(truncated);
            sb.append("\n```\n\n");
        }

        sb.append("**Investigation Progress**:\n");
        sb.append(todos).append("\n\n");

        if (findings != null && !findings.equals("No significant findings yet.")) {
            sb.append("**What You've Discovered**:\n");
            sb.append(findings).append("\n\n");
        }

        sb.append("**Current Task**: Focus on the task marked with [->] in the progress list above.\n\n");

        sb.append("**Instructions**:\n");
        sb.append("1. Think about what information you still need for the current task\n");
        sb.append("2. Call the appropriate tool(s) to gather that information:\n");
        sb.append("   - PREFER `ga_get_semantic_analysis`, `ga_get_call_context`, `ga_search_semantic` for understanding function behavior\n");
        sb.append("   - Use `decompile_function` (with appropriate server prefix) only when you need actual source code\n");
        sb.append("3. After receiving results, briefly summarize what you learned\n\n");

        sb.append("If you believe the current task is complete based on previous findings,\n");
        sb.append("you may proceed without additional tool calls.\n");

        return sb.toString();
    }

    /**
     * Build investigation prompt with iteration warning when approaching limit.
     */
    public static String buildInvestigationPromptWithWarning(
        String objective,
        String initialContext,
        String todos,
        String findings,
        int iteration,
        int remaining
    ) {
        String basePrompt = buildInvestigationPrompt(objective, initialContext, todos, findings, iteration);

        if (remaining <= 3) {
            return basePrompt + "\n" + getIterationLimitWarning(remaining);
        }

        return basePrompt;
    }

    /**
     * Prompt for when approaching iteration limit.
     */
    public static String getIterationLimitWarning(int remaining) {
        return String.format(
            "\n⚠️ **Note**: %d iteration%s remaining. If you have enough information, " +
            "consider synthesizing your answer soon.\n",
            remaining,
            remaining == 1 ? "" : "s"
        );
    }

    /**
     * Prompt to encourage final synthesis when todos are complete.
     */
    public static String getSynthesisPrompt(String objective, String findings, String todos, String iterationSummaries) {
        StringBuilder sb = new StringBuilder();
        sb.append("## Time to Synthesize\n\n");
        sb.append("**Goal**: ").append(objective).append("\n\n");

        sb.append("**Completed Investigation**:\n");
        sb.append(todos).append("\n\n");

        // Include iteration summaries for full context
        if (iterationSummaries != null && !iterationSummaries.trim().isEmpty() &&
            !iterationSummaries.equals("No iteration summaries available.")) {
            sb.append("**Investigation History** (what you discovered in each iteration):\n");
            sb.append(iterationSummaries).append("\n");
        }

        sb.append("**Key Findings**:\n");
        sb.append(findings).append("\n\n");

        sb.append("You've completed your investigation todos. Based on all the information\n");
        sb.append("you've gathered (shown in the investigation history above), provide a\n");
        sb.append("comprehensive answer to the user's question.\n\n");
        sb.append("Synthesize your findings into a clear, actionable response.\n");

        return sb.toString();
    }

    /**
     * Prompt for when max iterations reached without completion.
     */
    public static String getMaxIterationsPrompt(String objective, String findings, String todos) {
        return String.format("""
            ## Investigation Limit Reached

            **Goal**: %s

            **Progress**:
            %s

            **Findings**:
            %s

            You've reached the maximum number of investigation iterations.
            Based on what you've learned, provide the best answer you can.
            Note any limitations or areas that need further investigation.
            """,
            objective,
            todos,
            findings
        );
    }

    /**
     * Build a refresher prompt after context summarization.
     */
    public static String buildRefresherPrompt(String summary) {
        return String.format("""
            ## Investigation Context Refreshed

            Your previous investigation has been summarized to manage context:

            %s

            Continue from where you left off. Review the pending todos and use
            tools to gather any additional information needed.
            """,
            summary
        );
    }

    /**
     * Prompt for self-reflection after an iteration.
     * Asks the agent to assess progress, update plan, and decide readiness.
     * Uses strict formatting for reliable parsing (BinAssist parity).
     */
    public static String getReflectionPrompt(String objective, String findings, String todos) {
        return String.format("""
            ## Self-Reflection & Plan Adaptation

            **Original Question**: %s

            **Current Investigation Plan**:
            %s

            **Findings Accumulated**:
            %s

            **Reflection Tasks**:
            1. **Progress Assessment**: Review what you've learned and how it relates to the objective
            2. **Plan Adaptation**: Based on new findings, should the investigation plan change?
            3. **Readiness Check**: Can you now answer the user's question comprehensively?

            **Required Response Format** (use plain text, keep label and content on same line):

            **Assessment:** [Your assessment here on same line]

            **Plan Updates:**
            - ADD: [task] (or "None")
            - REMOVE: [task] (or "None")

            **Decision:** READY or CONTINUE

            **Reason:** [Your reason here on same line - do NOT put a newline after "Reason:"]

            **Guidelines**:
            - Keep each label and its content on the SAME LINE
            - **ADD** new tasks if findings reveal unexpected complexity or new investigation paths
            - **REMOVE** pending tasks that are no longer relevant based on what you've learned
            - Say **CONTINUE** if there are pending tasks that would provide valuable information
            - Say **READY** only if ALL planned tasks are complete OR remaining tasks would not
              meaningfully improve the answer
            - Completing investigation tasks thoroughly leads to better answers
            - Do NOT use code blocks, backticks, or extra newlines after labels
            """,
            objective,
            todos,
            findings
        );
    }
}

```

`src/main/java/ghidrassist/agent/react/ReActResult.java`:

```java
package ghidrassist.agent.react;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.time.Duration;
import java.util.ArrayList;
import java.util.List;

/**
 * Result of a ReAct agent analysis.
 * Much simpler than LATS AnalysisResult - no hypothesis trees or reflection data.
 */
public class ReActResult {

    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    /**
     * Analysis completion status.
     */
    public enum Status {
        SUCCESS,           // Agent provided an answer
        MAX_ITERATIONS,    // Reached max think-act-observe cycles
        MAX_TOOLS,         // Exhausted tool call budget
        ERROR,             // Unexpected error occurred
        CANCELLED          // User cancelled the analysis
    }

    // Core result data
    private final Status status;
    private final String answer;
    private final List<String> findings;
    private final List<String> iterationSummaries;

    // Metrics
    private final int iterationCount;
    private final int toolCallCount;
    private final Duration duration;

    // Error information (if applicable)
    private final String errorMessage;
    private final Throwable error;

    private ReActResult(Builder builder) {
        this.status = builder.status;
        this.answer = builder.answer;
        this.findings = new ArrayList<>(builder.findings);
        this.iterationSummaries = new ArrayList<>(builder.iterationSummaries);
        this.iterationCount = builder.iterationCount;
        this.toolCallCount = builder.toolCallCount;
        this.duration = builder.duration;
        this.errorMessage = builder.errorMessage;
        this.error = builder.error;
    }

    /**
     * Format result as markdown for display.
     */
    public String toMarkdown() {
        StringBuilder sb = new StringBuilder();

        // Status header
        sb.append("# ReAct Analysis Result\n\n");
        sb.append("**Status**: ").append(formatStatus()).append("\n");
        sb.append("**Iterations**: ").append(iterationCount).append("\n");
        sb.append("**Tool Calls**: ").append(toolCallCount).append("\n");
        sb.append("**Duration**: ").append(formatDuration()).append("\n\n");

        // Error message if applicable
        if (status == Status.ERROR && errorMessage != null) {
            sb.append("## Error\n\n");
            sb.append("```\n").append(errorMessage).append("\n```\n\n");
        }

        // Answer
        if (answer != null && !answer.isEmpty()) {
            sb.append("## Answer\n\n");
            sb.append(answer).append("\n\n");
        }

        // Key findings
        if (!findings.isEmpty()) {
            sb.append("## Key Findings\n\n");
            for (String finding : findings) {
                sb.append("- ").append(finding).append("\n");
            }
            sb.append("\n");
        }

        return sb.toString();
    }

    /**
     * Format result as compact summary for logging.
     */
    public String toSummary() {
        return String.format(
            "ReActResult[status=%s, iterations=%d, tools=%d, duration=%s]",
            status, iterationCount, toolCallCount, formatDuration()
        );
    }

    private String formatStatus() {
        switch (status) {
            case SUCCESS: return "✓ Success";
            case MAX_ITERATIONS: return "⚠ Max Iterations Reached";
            case MAX_TOOLS: return "⚠ Max Tool Calls Reached";
            case ERROR: return "✗ Error";
            case CANCELLED: return "⚠ Cancelled";
            default: return status.toString();
        }
    }

    private String formatDuration() {
        if (duration == null) {
            return "N/A";
        }
        long seconds = duration.getSeconds();
        if (seconds < 60) {
            return String.format("%ds", seconds);
        } else {
            long minutes = seconds / 60;
            long remainingSeconds = seconds % 60;
            return String.format("%dm %ds", minutes, remainingSeconds);
        }
    }

    // Getters
    public Status getStatus() { return status; }
    public String getAnswer() { return answer; }
    public List<String> getFindings() { return new ArrayList<>(findings); }
    public List<String> getIterationSummaries() { return new ArrayList<>(iterationSummaries); }
    public int getIterationCount() { return iterationCount; }
    public int getToolCallCount() { return toolCallCount; }
    public Duration getDuration() { return duration; }
    public String getErrorMessage() { return errorMessage; }
    public Throwable getError() { return error; }

    public boolean isSuccess() {
        return status == Status.SUCCESS;
    }

    /**
     * Serialize to JSON.
     */
    public String toJson() {
        return GSON.toJson(this);
    }

    /**
     * Builder for creating ReActResult instances.
     */
    public static class Builder {
        private Status status;
        private String answer = "";
        private List<String> findings = new ArrayList<>();
        private List<String> iterationSummaries = new ArrayList<>();
        private int iterationCount = 0;
        private int toolCallCount = 0;
        private Duration duration = Duration.ZERO;
        private String errorMessage = null;
        private Throwable error = null;

        public Builder status(Status status) {
            this.status = status;
            return this;
        }

        public Builder answer(String answer) {
            this.answer = answer;
            return this;
        }

        public Builder findings(List<String> findings) {
            this.findings = new ArrayList<>(findings);
            return this;
        }

        public Builder iterationSummaries(List<String> summaries) {
            this.iterationSummaries = new ArrayList<>(summaries);
            return this;
        }

        public Builder iterationCount(int count) {
            this.iterationCount = count;
            return this;
        }

        public Builder toolCallCount(int count) {
            this.toolCallCount = count;
            return this;
        }

        public Builder duration(Duration duration) {
            this.duration = duration;
            return this;
        }

        public Builder errorMessage(String message) {
            this.errorMessage = message;
            return this;
        }

        public Builder error(Throwable error) {
            this.error = error;
            if (error != null && this.errorMessage == null) {
                this.errorMessage = error.getMessage();
            }
            return this;
        }

        public ReActResult build() {
            if (status == null) {
                throw new IllegalStateException("Status must be set");
            }
            return new ReActResult(this);
        }
    }

    /**
     * Create an error result.
     */
    public static ReActResult error(Throwable error, FindingsCache findings, Duration duration) {
        return new Builder()
            .status(Status.ERROR)
            .error(error)
            .findings(findings != null ? findings.getAllFindings().stream().map(f -> f.getFact()).toList() : new ArrayList<>())
            .duration(duration)
            .build();
    }

    /**
     * Create a cancelled result.
     */
    public static ReActResult cancelled(FindingsCache findings, Duration duration) {
        return new Builder()
            .status(Status.CANCELLED)
            .findings(findings != null ? findings.getAllFindings().stream().map(f -> f.getFact()).toList() : new ArrayList<>())
            .duration(duration)
            .build();
    }
}

```

`src/main/java/ghidrassist/agent/react/TodoListManager.java`:

```java
package ghidrassist.agent.react;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Manages a dynamic todo list for tracking investigation progress.
 * Todos evolve as the agent learns more about the problem.
 */
public class TodoListManager {

    public enum TodoStatus {
        PENDING,
        IN_PROGRESS,
        COMPLETE
    }

    public static class Todo {
        private String task;
        private TodoStatus status;
        private String evidence;  // What we learned when completing this
        private int priority;     // Higher = more important

        public Todo(String task, int priority) {
            this.task = task;
            this.status = TodoStatus.PENDING;
            this.priority = priority;
        }

        public String getTask() { return task; }
        public TodoStatus getStatus() { return status; }
        public String getEvidence() { return evidence; }
        public int getPriority() { return priority; }

        public void setStatus(TodoStatus status) { this.status = status; }
        public void setEvidence(String evidence) { this.evidence = evidence; }
        public void setPriority(int priority) { this.priority = priority; }
    }

    private final List<Todo> todos;
    private final String objective;

    public TodoListManager(String objective) {
        this.objective = objective;
        this.todos = new ArrayList<>();
    }

    /**
     * Initialize todo list from LLM response.
     * Parses a markdown checklist or numbered list.
     */
    public void initializeFromLLMResponse(String llmResponse) {
        // Clear any existing todos
        todos.clear();

        if (llmResponse == null || llmResponse.trim().isEmpty()) {
            // Fallback: add generic investigation step
            todos.add(new Todo("Investigate the query using available tools", 10));
            return;
        }

        // Parse the LLM response for todo items
        // Expected format: markdown checklist or numbered list
        String[] lines = llmResponse.split("\n");
        int priority = 10;

        for (String line : lines) {
            line = line.trim();

            // Skip empty lines and headers
            if (line.isEmpty() || line.startsWith("#")) {
                continue;
            }

            // Parse markdown checkbox format: - [ ] Task or - [x] Task
            if (line.matches("^-\\s*\\[[ xX]\\]\\s+.+")) {
                String task = line.replaceFirst("^-\\s*\\[[ xX]\\]\\s+", "").trim();
                if (!task.isEmpty()) {
                    todos.add(new Todo(task, priority));
                    priority = Math.max(1, priority - 1);
                }
            }
            // Parse numbered list format: 1. Task
            else if (line.matches("^\\d+\\.\\s+.+")) {
                String task = line.replaceFirst("^\\d+\\.\\s+", "").trim();
                if (!task.isEmpty()) {
                    todos.add(new Todo(task, priority));
                    priority = Math.max(1, priority - 1);
                }
            }
            // Parse bullet list format: - Task or * Task
            else if (line.matches("^[\\-\\*]\\s+.+")) {
                String task = line.replaceFirst("^[\\-\\*]\\s+", "").trim();
                if (!task.isEmpty()) {
                    todos.add(new Todo(task, priority));
                    priority = Math.max(1, priority - 1);
                }
            }
        }

        // If we didn't find any todos, add a fallback
        if (todos.isEmpty()) {
            todos.add(new Todo("Investigate the query using available tools", 10));
        }
    }

    /**
     * Add a new todo dynamically based on discoveries.
     */
    public void addTodo(String task, int priority) {
        todos.add(new Todo(task, priority));
    }

    /**
     * Update todo list based on reflection feedback.
     * Adds new tasks if they're not duplicates, removes obsolete pending tasks.
     * Returns true if any changes were made (triggers iteration budget extension).
     *
     * @param newTasks Tasks to add (from reflection ADD)
     * @param removeTasks Tasks to remove (from reflection REMOVE)
     * @return true if todo list was modified
     */
    public boolean updateFromReflection(List<String> newTasks, List<String> removeTasks) {
        boolean changed = false;

        // Add new tasks if not duplicates
        if (newTasks != null && !newTasks.isEmpty()) {
            for (String newTask : newTasks) {
                // Skip "None" markers
                if (newTask == null || newTask.trim().isEmpty() ||
                    newTask.trim().equalsIgnoreCase("None")) {
                    continue;
                }

                // Check for duplicates using similarity
                boolean isDuplicate = false;
                for (Todo existing : todos) {
                    if (tasksSimilar(existing.getTask(), newTask)) {
                        isDuplicate = true;
                        break;
                    }
                }

                if (!isDuplicate) {
                    // Add with medium priority (5)
                    todos.add(new Todo(newTask.trim(), 5));
                    changed = true;
                }
            }
        }

        // Remove obsolete pending tasks
        if (removeTasks != null && !removeTasks.isEmpty()) {
            for (String removeTask : removeTasks) {
                // Skip "None" markers
                if (removeTask == null || removeTask.trim().isEmpty() ||
                    removeTask.trim().equalsIgnoreCase("None")) {
                    continue;
                }

                // Find and remove matching PENDING tasks only
                boolean removed = todos.removeIf(todo ->
                    todo.getStatus() == TodoStatus.PENDING &&
                    tasksSimilar(todo.getTask(), removeTask)
                );

                if (removed) {
                    changed = true;
                }
            }
        }

        return changed;
    }

    /**
     * Check if two tasks are similar (for duplicate detection).
     * Uses simple heuristics: lowercase comparison, contains relationship.
     *
     * @param task1 First task
     * @param task2 Second task
     * @return true if tasks are similar
     */
    private boolean tasksSimilar(String task1, String task2) {
        if (task1 == null || task2 == null) {
            return false;
        }

        // Normalize: lowercase, remove punctuation
        String normalized1 = task1.toLowerCase().replaceAll("[^a-z0-9\\s]", "").trim();
        String normalized2 = task2.toLowerCase().replaceAll("[^a-z0-9\\s]", "").trim();

        // Exact match after normalization
        if (normalized1.equals(normalized2)) {
            return true;
        }

        // Contains relationship (one is substring of other)
        if (normalized1.contains(normalized2) || normalized2.contains(normalized1)) {
            return true;
        }

        // Check word overlap (at least 70% common words)
        String[] words1 = normalized1.split("\\s+");
        String[] words2 = normalized2.split("\\s+");

        int commonWords = 0;
        for (String word1 : words1) {
            for (String word2 : words2) {
                if (word1.equals(word2) && word1.length() > 2) { // Skip short words
                    commonWords++;
                    break;
                }
            }
        }

        int maxWords = Math.max(words1.length, words2.length);
        double overlap = maxWords > 0 ? (double) commonWords / maxWords : 0;

        return overlap >= 0.7;
    }

    /**
     * Mark a todo as complete with evidence.
     */
    public void completeTodo(String task, String evidence) {
        for (Todo todo : todos) {
            if (todo.getTask().equals(task) || todo.getTask().contains(task)) {
                todo.setStatus(TodoStatus.COMPLETE);
                todo.setEvidence(evidence);
                break;
            }
        }
    }

    /**
     * Mark a todo as in progress.
     */
    public void setInProgress(String task) {
        for (Todo todo : todos) {
            if (todo.getTask().equals(task) || todo.getTask().contains(task)) {
                todo.setStatus(TodoStatus.IN_PROGRESS);
                break;
            }
        }
    }

    /**
     * Get the next pending todo by priority.
     */
    public Todo getNextPending() {
        return todos.stream()
            .filter(t -> t.getStatus() == TodoStatus.PENDING)
            .sorted((a, b) -> Integer.compare(b.getPriority(), a.getPriority()))
            .findFirst()
            .orElse(null);
    }

    /**
     * Check if all todos are complete.
     */
    public boolean allComplete() {
        return todos.stream().allMatch(t -> t.getStatus() == TodoStatus.COMPLETE);
    }

    /**
     * Get count of pending todos.
     */
    public int getPendingCount() {
        return (int) todos.stream().filter(t -> t.getStatus() == TodoStatus.PENDING).count();
    }

    /**
     * Format todos for LLM prompt (markdown checklist).
     */
    public String formatForPrompt() {
        if (todos.isEmpty()) {
            return "No specific investigation steps defined yet.";
        }

        StringBuilder sb = new StringBuilder();
        for (Todo todo : todos) {
            String checkbox = switch (todo.getStatus()) {
                case COMPLETE -> "[x]";
                case IN_PROGRESS -> "[->]";
                case PENDING -> "[ ]";
            };

            sb.append(checkbox).append(" ").append(todo.getTask());

            if (todo.getStatus() == TodoStatus.COMPLETE && todo.getEvidence() != null) {
                sb.append(" ✓");
            }
            sb.append("\n");
        }
        return sb.toString();
    }

    /**
     * Get summary of completed todos with evidence.
     */
    public String getCompletedSummary() {
        return todos.stream()
            .filter(t -> t.getStatus() == TodoStatus.COMPLETE)
            .map(t -> "✓ " + t.getTask() + (t.getEvidence() != null ? ": " + t.getEvidence() : ""))
            .collect(Collectors.joining("\n"));
    }

    /**
     * Compact representation for summarization.
     */
    public String toCompactString() {
        long completed = todos.stream().filter(t -> t.getStatus() == TodoStatus.COMPLETE).count();
        return String.format("%d/%d tasks complete", completed, todos.size());
    }

    public List<Todo> getAllTodos() {
        return new ArrayList<>(todos);
    }

    public String getObjective() {
        return objective;
    }
}

```

`src/main/java/ghidrassist/apiprovider/APIProvider.java`:

```java
package ghidrassist.apiprovider;

import java.io.IOException;
import java.net.ConnectException;
import java.net.SocketTimeoutException;
import java.net.UnknownHostException;
import java.time.Duration;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import javax.net.ssl.SSLException;

import ghidrassist.LlmApi;
import ghidrassist.apiprovider.capabilities.ChatProvider;
import ghidrassist.apiprovider.exceptions.*;
import okhttp3.OkHttpClient;
import okhttp3.Response;

public abstract class APIProvider implements ChatProvider {
    public enum ProviderType {
        ANTHROPIC_CLAUDE_CLI,
        ANTHROPIC_OAUTH,
        ANTHROPIC_PLATFORM_API,
        AZURE_OPENAI,
        GEMINI_OAUTH,
        GEMINI_PLATFORM_API,
        LITELLM,
        LMSTUDIO,
        OLLAMA,
        OPENAI_OAUTH,
        OPENAI_PLATFORM_API,
        OPENWEBUI,
        XAI_PLATFORM_API
    }

    protected String name;
    protected String model;
    protected Integer maxTokens;
    protected String url;
    protected String key;
    protected boolean disableTlsVerification;
    protected ProviderType type;
    protected OkHttpClient client;
    protected Duration timeout;
    protected RetryHandler retryHandler;
    protected ReasoningConfig reasoningConfig;

    public APIProvider(String name, ProviderType type, String model, Integer maxTokens,
                      String url, String key, boolean disableTlsVerification, Integer timeout2) {
        this.name = name;
        this.type = type;
        this.model = model;
        this.maxTokens = maxTokens;
        this.url = url.endsWith("/") ? url : url + "/";
        this.key = key;
        this.disableTlsVerification = disableTlsVerification;
        this.timeout = Duration.ofSeconds(timeout2);
        this.retryHandler = new RetryHandler(50, this);
        this.reasoningConfig = new ReasoningConfig(); // Default to NONE
        this.client = buildClient();
    }

    // Getters
    public String getName() { return name; }
    public ProviderType getType() { return type; }
    public String getModel() { return model; }
    public Integer getMaxTokens() { return maxTokens; }
    public String getUrl() { return url; }
    public String getKey() { return key; }
    public boolean isDisableTlsVerification() { return disableTlsVerification; }

    // Reasoning configuration
    public ReasoningConfig getReasoningConfig() {
        ReasoningConfig result = reasoningConfig != null ? reasoningConfig : new ReasoningConfig();
        ghidra.util.Msg.info(this, "DEBUG [APIProvider.getReasoningConfig]: Returning " +
            result.getEffort() + ", enabled=" + result.isEnabled() +
            " (field is " + (reasoningConfig != null ? "NOT NULL" : "NULL") + ")");
        return result;
    }

    public void setReasoningConfig(ReasoningConfig config) {
        this.reasoningConfig = config != null ? config : new ReasoningConfig();
        ghidra.util.Msg.info(this, "DEBUG [APIProvider.setReasoningConfig]: Set to " +
            this.reasoningConfig.getEffort() + ", enabled=" + this.reasoningConfig.isEnabled() +
            " (input was " + (config != null ? config.getEffort().toString() : "NULL") + ")");
    }

    protected abstract OkHttpClient buildClient();
    public abstract String createChatCompletion(List<ChatMessage> messages) throws APIProviderException;
    public abstract void streamChatCompletion(List<ChatMessage> messages, LlmApi.LlmResponseHandler handler) throws APIProviderException;
    public abstract String createChatCompletionWithFunctions(List<ChatMessage> messages, List<Map<String, Object>> functions) throws APIProviderException;
    public abstract String createChatCompletionWithFunctionsFullResponse(List<ChatMessage> messages, List<Map<String, Object>> functions) throws APIProviderException;
    public abstract List<String> getAvailableModels() throws APIProviderException;
    public abstract void getEmbeddingsAsync(String text, EmbeddingCallback callback);
	public void setTimeout(Integer timeout2) { this.timeout = Duration.ofSeconds(timeout2); }
	public Integer getTimeout() { return this.timeout.toSecondsPart(); }

    
    public double[] getEmbeddings(String text) throws APIProviderException {
        CompletableFuture<double[]> future = new CompletableFuture<>();
        
        getEmbeddingsAsync(text, new EmbeddingCallback() {
            @Override
            public void onSuccess(double[] embedding) {
                future.complete(embedding);
            }
            
            @Override
            public void onError(Throwable error) {
                future.completeExceptionally(error);
            }
        });
        
        try {
            return future.get(30, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new StreamCancelledException(name, "get_embeddings", 
                StreamCancelledException.CancellationReason.USER_REQUESTED, e);
        } catch (ExecutionException e) {
            Throwable cause = e.getCause();
            if (cause instanceof APIProviderException) {
                throw (APIProviderException) cause;
            }
            throw new APIProviderException(APIProviderException.ErrorCategory.SERVICE_ERROR, 
                name, "get_embeddings", "Failed to get embeddings: " + e.getMessage());
        } catch (TimeoutException e) {
            throw new APIProviderException(APIProviderException.ErrorCategory.TIMEOUT, 
                name, "get_embeddings", "Embedding request timed out");
        }
    }

    public interface EmbeddingCallback {
        void onSuccess(double[] embedding);
        void onError(Throwable error);
    }
    
    /**
     * Handle network-related exceptions and convert to appropriate APIProviderException
     */
    protected APIProviderException handleNetworkError(Exception e, String operation) {
        if (e instanceof SocketTimeoutException) {
            return new NetworkException(name, operation, NetworkException.NetworkErrorType.TIMEOUT, e);
        } else if (e instanceof SSLException) {
            return new NetworkException(name, operation, NetworkException.NetworkErrorType.SSL_ERROR, e);
        } else if (e instanceof ConnectException) {
            return new NetworkException(name, operation, NetworkException.NetworkErrorType.CONNECTION_FAILED, e);
        } else if (e instanceof UnknownHostException) {
            return new NetworkException(name, operation, NetworkException.NetworkErrorType.DNS_ERROR, e);
        } else if (e instanceof IOException && e.getMessage() != null && 
                   e.getMessage().toLowerCase().contains("connection")) {
            return new NetworkException(name, operation, NetworkException.NetworkErrorType.CONNECTION_LOST, e);
        }
        
        // Default network error
        return new NetworkException(name, operation, "Network error: " + e.getMessage());
    }
    
    /**
     * Handle HTTP response errors and convert to appropriate APIProviderException
     */
    protected APIProviderException handleHttpError(Response response, String operation) {
        String responseBody = null;
        
        try {
            if (response.body() != null) {
                responseBody = response.body().string();
            }
        } catch (IOException e) {
            // Ignore errors reading response body
        }
        
        return handleHttpError(response, responseBody, operation);
    }
    
    /**
     * Handle HTTP response errors with preread response body
     */
    protected APIProviderException handleHttpError(Response response, String responseBody, String operation) {
        int statusCode = response.code();
        String apiErrorCode = extractApiErrorCode(responseBody);
        String errorMessage = extractErrorMessage(responseBody, statusCode);
        
        switch (statusCode) {
            case 401:
                return new AuthenticationException(name, operation, statusCode, apiErrorCode, 
                    errorMessage != null ? errorMessage : "Invalid or missing API key");
                    
            case 403:
                return new AuthenticationException(name, operation, statusCode, apiErrorCode, 
                    errorMessage != null ? errorMessage : "API key does not have sufficient permissions");
                    
            case 429:
                Integer retryAfter = extractRetryAfter(response, responseBody);
                return new RateLimitException(name, operation, statusCode, apiErrorCode, 
                    errorMessage != null ? errorMessage : "Rate limit exceeded", retryAfter);
                    
            case 400:
                // Be more specific about model errors - look for definitive phrases, not just "model"
                String lowerErrorMessage = errorMessage != null ? errorMessage.toLowerCase() : "";
                if (lowerErrorMessage.contains("model not found") ||
                    lowerErrorMessage.contains("model_not_found") ||
                    lowerErrorMessage.contains("unknown model") ||
                    lowerErrorMessage.contains("invalid model")) {
                    // Preserve the actual error message instead of using a generic one
                    return new ModelException(name, operation, ModelException.ModelErrorType.MODEL_NOT_FOUND,
                        statusCode, apiErrorCode, errorMessage);
                } else if (lowerErrorMessage.contains("context length") ||
                           lowerErrorMessage.contains("context_length") ||
                           lowerErrorMessage.contains("maximum context")) {
                    return new ModelException(name, operation, ModelException.ModelErrorType.CONTEXT_LENGTH_EXCEEDED,
                        statusCode, apiErrorCode, errorMessage);
                } else if (lowerErrorMessage.contains("token limit") ||
                           lowerErrorMessage.contains("max_tokens") ||
                           lowerErrorMessage.contains("maximum.*token")) {
                    return new ModelException(name, operation, ModelException.ModelErrorType.TOKEN_LIMIT_EXCEEDED,
                        statusCode, apiErrorCode, errorMessage);
                }
                return new APIProviderException(APIProviderException.ErrorCategory.CONFIGURATION,
                    name, operation, statusCode, apiErrorCode,
                    errorMessage != null ? errorMessage : "Bad request");
                    
            case 404:
                if (operation.contains("model")) {
                    return new ModelException(name, operation, ModelException.ModelErrorType.MODEL_NOT_FOUND, 
                        statusCode, apiErrorCode);
                }
                return new APIProviderException(APIProviderException.ErrorCategory.CONFIGURATION, 
                    name, operation, statusCode, apiErrorCode, 
                    errorMessage != null ? errorMessage : "Resource not found");
                    
            case 500:
            case 502:
            case 503:
            case 504:
                return new APIProviderException(APIProviderException.ErrorCategory.SERVICE_ERROR, 
                    name, operation, statusCode, apiErrorCode, 
                    errorMessage != null ? errorMessage : "Service error", true, null, null);
                    
            default:
                return new APIProviderException(APIProviderException.ErrorCategory.SERVICE_ERROR, 
                    name, operation, statusCode, apiErrorCode, 
                    errorMessage != null ? errorMessage : "HTTP error " + statusCode);
        }
    }
    
    /**
     * Extract API error code from response body (provider-specific)
     */
    protected String extractApiErrorCode(String responseBody) {
        // Default implementation - subclasses should override for provider-specific logic
        return null;
    }
    
    /**
     * Extract error message from response body (provider-specific)
     */
    protected String extractErrorMessage(String responseBody, int statusCode) {
        // Default implementation - subclasses should override for provider-specific logic
        if (responseBody != null && !responseBody.isEmpty()) {
            // Try to extract a simple error message
            if (responseBody.contains("\"message\"")) {
                try {
                    int start = responseBody.indexOf("\"message\"") + 10;
                    int end = responseBody.indexOf("\"", start + 1);
                    if (end > start) {
                        return responseBody.substring(start + 1, end);
                    }
                } catch (Exception e) {
                    // Ignore parsing errors
                }
            }
            
            // Fallback: return truncated response body
            return responseBody.length() > 200 ? responseBody.substring(0, 200) + "..." : responseBody;
        }
        
        return null;
    }
    
    /**
     * Extract retry-after value from response
     */
    protected Integer extractRetryAfter(Response response, String responseBody) {
        // Check Retry-After header
        String retryAfterHeader = response.header("Retry-After");
        if (retryAfterHeader != null) {
            try {
                return Integer.parseInt(retryAfterHeader);
            } catch (NumberFormatException e) {
                // Ignore parsing errors
            }
        }
        
        // Check for retry-after in response body (provider-specific)
        if (responseBody != null && responseBody.contains("retry")) {
            // Basic parsing - subclasses should override for provider-specific logic
            try {
                java.util.regex.Pattern pattern = java.util.regex.Pattern.compile("\"retry.*?(\\d+)");
                java.util.regex.Matcher matcher = pattern.matcher(responseBody);
                if (matcher.find()) {
                    return Integer.parseInt(matcher.group(1));
                }
            } catch (Exception e) {
                // Ignore parsing errors
            }
        }
        
        return null; // No retry-after information found
    }
    
    /**
     * Execute an HTTP request with retry logic for handling rate limits and transient errors
     */
    protected Response executeWithRetry(okhttp3.Request request, String operationName) throws APIProviderException {
        return retryHandler.executeWithRetryCallable(() -> {
            Response response = client.newCall(request).execute();
            if (!response.isSuccessful()) {
                throw handleHttpError(response, operationName);
            }
            return response;
        }, operationName);
    }

    // ========== Token Counting Methods (for Context Management) ==========

    /**
     * Count tokens in a list of chat messages.
     * Default implementation returns -1 (unsupported).
     * Providers with native token counting APIs should override this method.
     *
     * @param messages List of chat messages
     * @return Token count, or -1 if provider doesn't support token counting
     * @throws APIProviderException if token counting fails
     */
    public int countTokens(List<ChatMessage> messages) throws APIProviderException {
        return -1; // Not supported by default
    }

    /**
     * Count tokens in a text string.
     * Default implementation returns -1 (unsupported).
     * Providers with native token counting APIs should override this method.
     *
     * @param text Text to count tokens for
     * @return Token count, or -1 if provider doesn't support token counting
     * @throws APIProviderException if token counting fails
     */
    public int countTokens(String text) throws APIProviderException {
        return -1; // Not supported by default
    }

    /**
     * Estimate tokens required for tool definitions.
     * Default implementation returns -1 (unsupported).
     * Providers can override with more accurate estimates.
     *
     * @param tools List of tool definitions in OpenAI function format
     * @return Token estimate, or -1 if provider doesn't support estimation
     * @throws APIProviderException if estimation fails
     */
    public int estimateTokensForTools(List<Map<String, Object>> tools) throws APIProviderException {
        return -1; // Not supported by default
    }

}
```

`src/main/java/ghidrassist/apiprovider/APIProviderConfig.java`:

```java
package ghidrassist.apiprovider;

import ghidrassist.GhidrAssistPlugin;
import ghidrassist.apiprovider.factory.ProviderRegistry;
import ghidrassist.apiprovider.factory.UnsupportedProviderException;

public class APIProviderConfig {
    private String name;
    private String model;
    private Integer maxTokens;
    private String url;
    private String key;
    private boolean disableTlsVerification;
    private APIProvider.ProviderType type;
    private Integer timeout;

    public APIProviderConfig(
            String name,
            APIProvider.ProviderType type,
            String model,
            Integer maxTokens,
            String url,
            String key,
            boolean disableTlsVerification) {
        this(name, type, model, maxTokens, url, key, disableTlsVerification, 120); // Default timeout of 120 seconds
    }

    public APIProviderConfig(
            String name,
            APIProvider.ProviderType type,
            String model,
            Integer maxTokens,
            String url,
            String key,
            boolean disableTlsVerification,
            Integer timeout) {
        this.name = name;
        this.type = type;
        this.model = model;
        this.maxTokens = maxTokens;
        this.url = url;
        this.key = key;
        this.disableTlsVerification = disableTlsVerification;
        this.timeout = timeout;
    }

    // Getters
    public String getName() { return name; }
    public APIProvider.ProviderType getType() { return type; }
    public String getModel() { return model; }
    public Integer getMaxTokens() { return maxTokens; }
    public String getUrl() { return url; }
    public String getKey() { return key; }
    public boolean isDisableTlsVerification() { return disableTlsVerification; }
    public Integer getTimeout() { return timeout; }

    // Setters
    public void setName(String name) { this.name = name; }
    public void setType(APIProvider.ProviderType type) { this.type = type; }
    public void setModel(String model) { this.model = model; }
    public void setMaxTokens(Integer maxTokens) { this.maxTokens = maxTokens; }
    public void setUrl(String url) { this.url = url; }
    public void setKey(String key) { this.key = key; }
    public void setDisableTlsVerification(boolean disableTlsVerification) { this.disableTlsVerification = disableTlsVerification; }
    public void setTimeout(Integer timeout) { this.timeout = timeout; }

    /**
     * Create a provider using the factory pattern
     * @return Configured API provider instance
     * @throws RuntimeException if provider creation fails
     */
    public APIProvider createProvider() {
        this.timeout = GhidrAssistPlugin.getGlobalApiTimeout();
        
        try {
            return ProviderRegistry.getInstance().createProvider(this);
        } catch (UnsupportedProviderException e) {
            throw new IllegalArgumentException("Failed to create provider: " + e.getMessage(), e);
        }
    }

    /**
     * Create a copy of this provider
     * @return new provider instance with identical configuration
     */
    public APIProviderConfig copy() {
        return new APIProviderConfig(name, type, model, maxTokens, url, key, disableTlsVerification, timeout);
    }
    
    /**
     * Check if this provider type is supported
     * @return true if the provider type is supported
     */
    public boolean isSupported() {
        return ProviderRegistry.getInstance().isSupported(type);
    }
}
```

`src/main/java/ghidrassist/apiprovider/APIProviderLogger.java`:

```java
package ghidrassist.apiprovider;

import ghidrassist.apiprovider.exceptions.APIProviderException;
import ghidra.util.Msg;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Structured logging and analytics for API provider errors
 */
public class APIProviderLogger {
    private static final ConcurrentHashMap<String, ErrorStats> errorStats = new ConcurrentHashMap<>();
    
    /**
     * Log an API provider error with structured information
     */
    public static void logError(Object source, APIProviderException e) {
        // Log the structured error message
        String logMessage = formatErrorMessage(e);
        Msg.error(source, logMessage, e);
        
        // Update error statistics
        updateErrorStats(e);
        
        // Log additional context if available
        if (e.getCause() != null) {
            Msg.debug(source, "Underlying cause: " + e.getCause().getClass().getSimpleName() + 
                              " - " + e.getCause().getMessage());
        }
    }
    
    /**
     * Log a warning for retry attempts
     */
    public static void logRetry(Object source, APIProviderException e, int attempt, int maxAttempts) {
        String message = String.format(
            "[%s] Retry %d/%d for %s: %s",
            e.getProviderName(),
            attempt,
            maxAttempts,
            e.getOperation(),
            e.getCategory().getDisplayName()
        );
        Msg.warn(source, message);
        
        // Update retry statistics
        updateRetryStats(e);
    }
    
    /**
     * Log successful recovery after retries
     */
    public static void logRecovery(Object source, String providerName, String operation, int attempts) {
        String message = String.format(
            "[%s] Operation %s succeeded after %d attempts",
            providerName,
            operation,
            attempts
        );
        Msg.info(source, message);
    }
    
    /**
     * Log provider status changes
     */
    public static void logProviderStatus(Object source, String providerName, String status, String details) {
        String message = String.format("[%s] Status: %s - %s", providerName, status, details);
        Msg.info(source, message);
    }
    
    /**
     * Get error statistics for diagnostics
     */
    public static ErrorStats getErrorStats(String providerName) {
        return errorStats.get(providerName);
    }
    
    /**
     * Get all error statistics
     */
    public static ConcurrentHashMap<String, ErrorStats> getAllErrorStats() {
        return new ConcurrentHashMap<>(errorStats);
    }
    
    /**
     * Clear error statistics
     */
    public static void clearStats() {
        errorStats.clear();
    }
    
    /**
     * Generate a diagnostics report
     */
    public static String generateDiagnosticsReport() {
        StringBuilder report = new StringBuilder();
        report.append("=== API Provider Error Statistics ===\n\n");
        
        if (errorStats.isEmpty()) {
            report.append("No errors recorded.\n");
            return report.toString();
        }
        
        for (String providerName : errorStats.keySet()) {
            ErrorStats stats = errorStats.get(providerName);
            report.append(String.format("Provider: %s\n", providerName));
            report.append(String.format("  Total Errors: %d\n", stats.getTotalErrors()));
            report.append(String.format("  Total Retries: %d\n", stats.getTotalRetries()));
            report.append(String.format("  Last Error: %s\n", 
                stats.getLastErrorTime() > 0 ? new java.util.Date(stats.getLastErrorTime()).toString() : "None"));
            
            report.append("  Errors by Category:\n");
            for (APIProviderException.ErrorCategory category : APIProviderException.ErrorCategory.values()) {
                int count = stats.getCategoryCount(category);
                if (count > 0) {
                    report.append(String.format("    %s: %d\n", category.getDisplayName(), count));
                }
            }
            
            // Reliability calculation
            double reliability = stats.calculateReliability();
            report.append(String.format("  Estimated Reliability: %.1f%%\n", reliability * 100));
            
            report.append("\n");
        }
        
        return report.toString();
    }
    
    private static String formatErrorMessage(APIProviderException e) {
        StringBuilder message = new StringBuilder();
        
        message.append(String.format("[%s] %s failed", 
            e.getProviderName(), e.getOperation()));
        
        message.append(String.format(" - %s", e.getCategory().getDisplayName()));
        
        if (e.getHttpStatusCode() > 0) {
            message.append(String.format(" (HTTP %d)", e.getHttpStatusCode()));
        }
        
        if (e.getApiErrorCode() != null && !e.getApiErrorCode().isEmpty()) {
            message.append(String.format(" [%s]", e.getApiErrorCode()));
        }
        
        if (e.getMessage() != null) {
            message.append(": ").append(e.getMessage());
        }
        
        return message.toString();
    }
    
    private static void updateErrorStats(APIProviderException e) {
        errorStats.computeIfAbsent(e.getProviderName(), k -> new ErrorStats())
                  .recordError(e.getCategory());
    }
    
    private static void updateRetryStats(APIProviderException e) {
        errorStats.computeIfAbsent(e.getProviderName(), k -> new ErrorStats())
                  .recordRetry();
    }
    
    /**
     * Statistics tracking for API provider errors
     */
    public static class ErrorStats {
        private final AtomicInteger totalErrors = new AtomicInteger(0);
        private final AtomicInteger totalRetries = new AtomicInteger(0);
        private final AtomicLong lastErrorTime = new AtomicLong(0);
        private final ConcurrentHashMap<APIProviderException.ErrorCategory, AtomicInteger> categoryStats = 
            new ConcurrentHashMap<>();
        
        public void recordError(APIProviderException.ErrorCategory category) {
            totalErrors.incrementAndGet();
            lastErrorTime.set(System.currentTimeMillis());
            categoryStats.computeIfAbsent(category, k -> new AtomicInteger(0)).incrementAndGet();
        }
        
        public void recordRetry() {
            totalRetries.incrementAndGet();
        }
        
        public int getTotalErrors() {
            return totalErrors.get();
        }
        
        public int getTotalRetries() {
            return totalRetries.get();
        }
        
        public long getLastErrorTime() {
            return lastErrorTime.get();
        }
        
        public int getCategoryCount(APIProviderException.ErrorCategory category) {
            AtomicInteger count = categoryStats.get(category);
            return count != null ? count.get() : 0;
        }
        
        /**
         * Calculate estimated reliability based on error patterns
         * This is a simple heuristic that can be improved with more sophisticated metrics
         */
        public double calculateReliability() {
            int totalErrors = getTotalErrors();
            if (totalErrors == 0) {
                return 1.0; // 100% reliability if no errors
            }
            
            // Simple calculation: assume some baseline number of successful operations
            // This is a rough estimate and could be improved with actual success tracking
            int estimatedTotalOperations = Math.max(totalErrors * 10, 100); // Assume 10:1 success ratio minimum
            return Math.max(0.0, 1.0 - (double) totalErrors / estimatedTotalOperations);
        }
        
        /**
         * Check if provider is experiencing frequent errors (more than 10 in last hour)
         */
        public boolean isFrequentErrorsDetected() {
            long oneHourAgo = System.currentTimeMillis() - (60 * 60 * 1000);
            return lastErrorTime.get() > oneHourAgo && totalErrors.get() > 10;
        }
    }
}
```

`src/main/java/ghidrassist/apiprovider/AnthropicClaudeCliProvider.java`:

```java
package ghidrassist.apiprovider;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;

import ghidra.util.Msg;
import ghidrassist.LlmApi.LlmResponseHandler;
import ghidrassist.apiprovider.capabilities.FunctionCallingProvider;
import ghidrassist.apiprovider.exceptions.*;
import ghidrassist.mcp2.server.MCPServerConfig;
import ghidrassist.mcp2.server.MCPServerRegistry;
import okhttp3.OkHttpClient;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

/**
 * Anthropic Claude CLI Provider - proxies API requests through the claude CLI.
 *
 * Benefits:
 * - No API key required (uses CLI's OAuth authentication)
 * - MCP integration via --mcp-config
 * - Development/testing without direct API costs
 *
 * Limitations:
 * - No true streaming (simulated by chunking complete response)
 * - Requires claude CLI installed and authenticated
 */
public class AnthropicClaudeCliProvider extends APIProvider implements FunctionCallingProvider {
    private static final Gson gson = new Gson();

    // CLI streaming simulation settings
    private int streamChunkSize = 50;
    private int streamChunkDelay = 10; // milliseconds

    // Cached CLI path
    private String cachedCliPath = null;

    public AnthropicClaudeCliProvider(String name, String model, Integer maxTokens,
                              String url, String key, boolean disableTlsVerification,
                              Integer timeout) {
        super(name, ProviderType.ANTHROPIC_CLAUDE_CLI, model, maxTokens,
              url != null ? url : "", key != null ? key : "",
              disableTlsVerification, timeout != null ? timeout : 300);

        // Default model to "sonnet" if not specified
        if (this.model == null || this.model.isEmpty()) {
            this.model = "sonnet";
        }
    }

    @Override
    protected OkHttpClient buildClient() {
        // CLI-based provider doesn't use HTTP client, but we need to return something
        // for the base class. Build a minimal client.
        return new OkHttpClient.Builder()
            .connectTimeout(Duration.ofSeconds(10))
            .readTimeout(super.timeout)
            .writeTimeout(super.timeout)
            .build();
    }

    /**
     * Find the claude CLI executable (cross-platform).
     * Searches common installation paths based on the operating system.
     */
    private String findClaudeCli() {
        if (cachedCliPath != null) {
            // Verify cached path still exists
            File cached = new File(cachedCliPath);
            if (cached.exists() && cached.canExecute()) {
                return cachedCliPath;
            }
            cachedCliPath = null;
        }

        String osName = System.getProperty("os.name").toLowerCase();
        String userHome = System.getProperty("user.home");
        List<String> commonPaths = new ArrayList<>();

        if (osName.contains("win")) {
            // Windows paths
            String appData = System.getenv("APPDATA");
            String localAppData = System.getenv("LOCALAPPDATA");
            String userProfile = System.getenv("USERPROFILE");

            if (appData != null) {
                commonPaths.add(appData + "\\npm\\claude.cmd");
                commonPaths.add(appData + "\\npm\\claude");
            }
            if (localAppData != null) {
                commonPaths.add(localAppData + "\\npm\\claude.cmd");
                commonPaths.add(localAppData + "\\npm\\claude");
            }
            if (userProfile != null) {
                // Scoop install location
                commonPaths.add(userProfile + "\\scoop\\shims\\claude.cmd");
                commonPaths.add(userProfile + "\\scoop\\shims\\claude");
            }
        } else if (osName.contains("mac") || osName.contains("darwin")) {
            // macOS paths
            commonPaths.add("/usr/local/bin/claude");           // Intel Macs
            commonPaths.add("/opt/homebrew/bin/claude");        // Apple Silicon (M1/M2/M3)
            commonPaths.add(userHome + "/.npm-global/bin/claude");
            commonPaths.add(userHome + "/Library/npm/bin/claude");
            commonPaths.add(userHome + "/.local/bin/claude");
        } else {
            // Linux paths
            commonPaths.add("/usr/local/bin/claude");
            commonPaths.add("/usr/bin/claude");
            commonPaths.add(userHome + "/.local/bin/claude");
            commonPaths.add(userHome + "/.npm-global/bin/claude");
            commonPaths.add("/snap/bin/claude");                // Snap install
        }

        // Check explicit paths first
        for (String path : commonPaths) {
            if (path == null) continue;
            File file = new File(path);
            if (file.exists() && file.canExecute()) {
                cachedCliPath = path;
                Msg.debug(this, "Found Claude CLI at: " + cachedCliPath);
                return cachedCliPath;
            }
        }

        // Try platform-specific PATH lookup command
        if (osName.contains("win")) {
            // Try 'where' command on Windows
            cachedCliPath = findCliUsingCommand("where", "claude");
        } else {
            // Try 'which' command on Unix-like systems
            cachedCliPath = findCliUsingCommand("which", "claude");
        }

        if (cachedCliPath != null) {
            Msg.debug(this, "Found Claude CLI via PATH lookup: " + cachedCliPath);
            return cachedCliPath;
        }

        Msg.warn(this, "Claude CLI not found. Searched paths: " + commonPaths);
        return null;
    }

    /**
     * Use a command (which/where) to find the CLI in PATH.
     */
    private String findCliUsingCommand(String... command) {
        try {
            ProcessBuilder pb = new ProcessBuilder(command);
            pb.redirectErrorStream(true);
            Process process = pb.start();

            try (BufferedReader reader = new BufferedReader(
                    new InputStreamReader(process.getInputStream()))) {
                String line = reader.readLine();
                if (line != null && !line.isEmpty()) {
                    File found = new File(line.trim());
                    if (found.exists()) {
                        return found.getAbsolutePath();
                    }
                }
            }
            process.waitFor(5, TimeUnit.SECONDS);
        } catch (Exception e) {
            // Ignore - path lookup failed
        }
        return null;
    }

    /**
     * Get platform-specific error message when CLI is not found.
     */
    private String getCliNotFoundMessage() {
        String osName = System.getProperty("os.name").toLowerCase();
        StringBuilder msg = new StringBuilder();
        msg.append("Claude CLI not found.\n\n");
        msg.append("Install with: npm install -g @anthropic-ai/claude-code\n\n");

        if (osName.contains("win")) {
            msg.append("On Windows, ensure npm global bin is in your PATH:\n");
            msg.append("  %APPDATA%\\npm\n");
        } else if (osName.contains("mac") || osName.contains("darwin")) {
            msg.append("On macOS, the CLI is typically installed at:\n");
            msg.append("  /usr/local/bin/claude (Intel) or\n");
            msg.append("  /opt/homebrew/bin/claude (Apple Silicon)\n");
        } else {
            msg.append("On Linux, the CLI is typically installed at:\n");
            msg.append("  ~/.local/bin/claude or /usr/local/bin/claude\n");
        }

        msg.append("\nAfter installation, run 'claude' once to authenticate.");
        return msg.toString();
    }

    /**
     * Format chat messages into a single prompt string for the CLI.
     */
    private String formatMessagesForCli(List<ChatMessage> messages) {
        StringBuilder sb = new StringBuilder();

        for (ChatMessage msg : messages) {
            String role = msg.getRole();
            String content = msg.getContent() != null ? msg.getContent() : "";

            if (content.isEmpty()) continue;

            switch (role) {
                case ChatMessage.ChatMessageRole.SYSTEM:
                    sb.append("System: ").append(content).append("\n\n");
                    break;
                case ChatMessage.ChatMessageRole.USER:
                    sb.append("User: ").append(content).append("\n\n");
                    break;
                case ChatMessage.ChatMessageRole.ASSISTANT:
                    sb.append("Assistant: ").append(content).append("\n\n");
                    break;
                case ChatMessage.ChatMessageRole.TOOL:
                case ChatMessage.ChatMessageRole.FUNCTION:
                    sb.append("Tool Result: ").append(content).append("\n\n");
                    break;
                default:
                    sb.append(content).append("\n\n");
                    break;
            }
        }

        return sb.toString().trim();
    }

    /**
     * Create MCP config file for the Claude CLI.
     * Returns path to temporary config file, or null if no MCP servers configured.
     */
    private File createMcpConfigFile() throws IOException {
        MCPServerRegistry registry = MCPServerRegistry.getInstance();
        List<MCPServerConfig> enabledServers = registry.getEnabledServers();

        if (enabledServers.isEmpty()) {
            return null;
        }

        JsonObject config = new JsonObject();
        JsonObject mcpServers = new JsonObject();

        for (MCPServerConfig server : enabledServers) {
            String serverUrl = server.getUrl();
            if (serverUrl == null || serverUrl.isEmpty()) {
                continue;
            }

            JsonObject serverConfig = new JsonObject();
            String transport = server.getTransport().name().toLowerCase();
            // Map transport types to Claude CLI config types
            String cliType;
            if ("sse".equals(transport)) {
                cliType = "sse";
            } else if ("streamable_http".equals(transport)) {
                cliType = "streamable-http";
            } else {
                cliType = "sse"; // Default fallback
            }
            serverConfig.addProperty("type", cliType);
            serverConfig.addProperty("url", server.getBaseUrl());

            mcpServers.add(server.getName(), serverConfig);
        }

        if (mcpServers.size() == 0) {
            return null;
        }

        config.add("mcpServers", mcpServers);

        // Create temp file
        File tempFile = File.createTempFile("ghidrassist_mcp_", ".json");
        tempFile.deleteOnExit();

        try (FileWriter writer = new FileWriter(tempFile)) {
            gson.toJson(config, writer);
        }

        Msg.debug(this, "Created MCP config file: " + tempFile.getAbsolutePath() +
                  " with " + mcpServers.size() + " server(s)");

        return tempFile;
    }

    /**
     * Handle CLI error based on stderr output and exit code.
     */
    private void handleCliError(String stderr, int exitCode) throws APIProviderException {
        String errorLower = stderr.toLowerCase();

        if (errorLower.contains("rate limit") || errorLower.contains("429")) {
            throw new RateLimitException(
                "Claude rate limit exceeded: " + stderr,
                getName(), "runClaudeCli", 60
            );
        }

        if (errorLower.contains("auth") || errorLower.contains("login") ||
            errorLower.contains("unauthorized") || errorLower.contains("401")) {
            throw new AuthenticationException(
                "Claude CLI authentication failed. Please run 'claude' interactively to authenticate.",
                getName(), "runClaudeCli"
            );
        }

        if (errorLower.contains("not found") || errorLower.contains("no such")) {
            throw new APIProviderException(
                APIProviderException.ErrorCategory.CONFIGURATION,
                "Claude CLI error: " + stderr,
                getName(), "runClaudeCli"
            );
        }

        throw new APIProviderException(
            APIProviderException.ErrorCategory.SERVICE_ERROR,
            "Claude CLI exited with code " + exitCode + ": " +
            (stderr.isEmpty() ? "No error message" : stderr),
            getName(), "runClaudeCli"
        );
    }

    /**
     * Execute the claude CLI with the given prompt.
     *
     * @param prompt The formatted prompt string
     * @param useMcp Whether to enable MCP servers
     * @return The CLI output (Claude's response)
     */
    private String runClaudeCli(String prompt, boolean useMcp) throws APIProviderException {
        String cliPath = findClaudeCli();
        if (cliPath == null) {
            throw new APIProviderException(
                APIProviderException.ErrorCategory.CONFIGURATION,
                getCliNotFoundMessage(),
                getName(), "runClaudeCli"
            );
        }

        if (prompt == null || prompt.trim().isEmpty()) {
            throw new APIProviderException(
                APIProviderException.ErrorCategory.CONFIGURATION,
                "Cannot send empty prompt to Claude CLI",
                getName(), "runClaudeCli"
            );
        }

        List<String> command = new ArrayList<>();
        command.add(cliPath);
        command.add("--print");
        command.add("--model");
        command.add(this.model);

        File mcpConfigFile = null;
        if (useMcp) {
            try {
                mcpConfigFile = createMcpConfigFile();
                if (mcpConfigFile != null) {
                    command.add("--mcp-config");
                    command.add(mcpConfigFile.getAbsolutePath());
                    command.add("--dangerously-skip-permissions");
                }
            } catch (IOException e) {
                Msg.warn(this, "Failed to create MCP config: " + e.getMessage());
            }
        }

        Msg.debug(this, "Executing Claude CLI: " + String.join(" ", command));

        try {
            ProcessBuilder pb = new ProcessBuilder(command);
            pb.redirectErrorStream(false);

            Process process = pb.start();

            // Write prompt to stdin
            try (OutputStream stdin = process.getOutputStream()) {
                stdin.write(prompt.getBytes(StandardCharsets.UTF_8));
                stdin.flush();
            }

            // Read stdout in a separate thread to avoid deadlock
            StringBuilder stdoutBuilder = new StringBuilder();
            StringBuilder stderrBuilder = new StringBuilder();

            Thread stdoutThread = new Thread(() -> {
                try (BufferedReader reader = new BufferedReader(
                        new InputStreamReader(process.getInputStream(), StandardCharsets.UTF_8))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        if (stdoutBuilder.length() > 0) {
                            stdoutBuilder.append("\n");
                        }
                        stdoutBuilder.append(line);
                    }
                } catch (IOException e) {
                    Msg.error(this, "Error reading stdout: " + e.getMessage());
                }
            });

            Thread stderrThread = new Thread(() -> {
                try (BufferedReader reader = new BufferedReader(
                        new InputStreamReader(process.getErrorStream(), StandardCharsets.UTF_8))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        if (stderrBuilder.length() > 0) {
                            stderrBuilder.append("\n");
                        }
                        stderrBuilder.append(line);
                    }
                } catch (IOException e) {
                    Msg.error(this, "Error reading stderr: " + e.getMessage());
                }
            });

            stdoutThread.start();
            stderrThread.start();

            // Wait for process with timeout
            long timeoutSeconds = super.timeout.getSeconds();
            boolean completed = process.waitFor(timeoutSeconds, TimeUnit.SECONDS);

            if (!completed) {
                process.destroyForcibly();
                stdoutThread.interrupt();
                stderrThread.interrupt();
                throw new APIProviderException(
                    APIProviderException.ErrorCategory.TIMEOUT,
                    "Claude CLI timed out after " + timeoutSeconds + " seconds",
                    getName(), "runClaudeCli"
                );
            }

            // Wait for reader threads to complete
            stdoutThread.join(5000);
            stderrThread.join(5000);

            int exitCode = process.exitValue();
            String stdout = stdoutBuilder.toString().trim();
            String stderr = stderrBuilder.toString().trim();

            if (exitCode != 0) {
                handleCliError(stderr, exitCode);
            }

            if (stdout.isEmpty()) {
                Msg.warn(this, "Claude CLI returned empty response");
            }

            return stdout;

        } catch (IOException e) {
            throw new NetworkException(
                getName(), "runClaudeCli",
                NetworkException.NetworkErrorType.CONNECTION_FAILED, e
            );
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new APIProviderException(
                APIProviderException.ErrorCategory.CANCELLED,
                "CLI execution interrupted",
                getName(), "runClaudeCli"
            );
        } finally {
            // Cleanup temp file
            if (mcpConfigFile != null) {
                try {
                    mcpConfigFile.delete();
                } catch (Exception e) {
                    // Ignore cleanup errors
                }
            }
        }
    }

    @Override
    public String createChatCompletion(List<ChatMessage> messages) throws APIProviderException {
        String prompt = formatMessagesForCli(messages);
        return runClaudeCli(prompt, false);
    }

    @Override
    public String createChatCompletionWithFunctions(List<ChatMessage> messages,
            List<Map<String, Object>> functions) throws APIProviderException {
        String prompt = formatMessagesForCli(messages);
        // Enable MCP when functions are provided (indicates MCP checkbox is enabled)
        boolean useMcp = functions != null && !functions.isEmpty();
        return runClaudeCli(prompt, useMcp);
    }

    @Override
    public String createChatCompletionWithFunctionsFullResponse(List<ChatMessage> messages,
            List<Map<String, Object>> functions) throws APIProviderException {
        // Get the plain text response from CLI
        String responseText = createChatCompletionWithFunctions(messages, functions);

        // Wrap in OpenAI-compatible JSON format for ConversationalToolHandler
        // Claude CLI executes MCP tools internally, so we always return finish_reason="stop"
        // (there are no tool_calls for the host to execute)
        return wrapResponseAsOpenAIFormat(responseText);
    }

    /**
     * Wrap plain text response in OpenAI-compatible JSON format.
     * This is required for ConversationalToolHandler which expects JSON with
     * choices array, finish_reason, and message object.
     *
     * Note: Claude CLI handles MCP tool execution internally, so finish_reason
     * is always "stop" - there are no tool_calls for the host application to execute.
     */
    private String wrapResponseAsOpenAIFormat(String responseText) {
        JsonObject response = new JsonObject();
        JsonArray choices = new JsonArray();
        JsonObject choice = new JsonObject();
        JsonObject message = new JsonObject();

        message.addProperty("role", "assistant");
        message.addProperty("content", responseText != null ? responseText : "");

        choice.add("message", message);
        choice.addProperty("finish_reason", "stop");
        choice.addProperty("index", 0);

        choices.add(choice);
        response.add("choices", choices);
        response.addProperty("model", this.model);
        response.addProperty("object", "chat.completion");

        return gson.toJson(response);
    }

    @Override
    public void streamChatCompletion(List<ChatMessage> messages, LlmResponseHandler handler)
            throws APIProviderException {
        handler.onStart();

        try {
            String prompt = formatMessagesForCli(messages);
            String fullResponse = runClaudeCli(prompt, false);

            if (fullResponse.isEmpty()) {
                handler.onComplete("");
                return;
            }

            // Simulate streaming by chunking the response
            StringBuilder accumulated = new StringBuilder();
            for (int i = 0; i < fullResponse.length(); i += streamChunkSize) {
                if (!handler.shouldContinue()) {
                    break;
                }

                String chunk = fullResponse.substring(i,
                    Math.min(i + streamChunkSize, fullResponse.length()));
                accumulated.append(chunk);
                handler.onUpdate(chunk);

                // Small delay for visual effect
                if (streamChunkDelay > 0 && i + streamChunkSize < fullResponse.length()) {
                    Thread.sleep(streamChunkDelay);
                }
            }

            handler.onComplete(accumulated.toString());

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            handler.onError(e);
        } catch (APIProviderException e) {
            handler.onError(e);
        } catch (Exception e) {
            handler.onError(new APIProviderException(
                APIProviderException.ErrorCategory.SERVICE_ERROR,
                e.getMessage(), getName(), "streamChatCompletion"
            ));
        }
    }

    @Override
    public List<String> getAvailableModels() throws APIProviderException {
        // Claude Code CLI supports these model shortcuts
        List<String> models = new ArrayList<>();
        models.add("sonnet");
        models.add("opus");
        models.add("haiku");
        return models;
    }

    @Override
    public void getEmbeddingsAsync(String text, EmbeddingCallback callback) {
        // Claude CLI doesn't support embeddings
        callback.onError(new APIProviderException(
            APIProviderException.ErrorCategory.CONFIGURATION,
            "Embeddings not supported by Claude Code CLI provider",
            getName(), "getEmbeddingsAsync"
        ));
    }

    /**
     * Test connection by checking if CLI is available and authenticated.
     */
    public boolean testConnection() {
        String cliPath = findClaudeCli();
        if (cliPath == null) {
            Msg.warn(this, "Claude CLI not found");
            return false;
        }

        try {
            ProcessBuilder pb = new ProcessBuilder(cliPath, "--version");
            pb.redirectErrorStream(true);
            Process process = pb.start();

            boolean completed = process.waitFor(10, TimeUnit.SECONDS);

            if (completed && process.exitValue() == 0) {
                try (BufferedReader reader = new BufferedReader(
                        new InputStreamReader(process.getInputStream()))) {
                    String version = reader.readLine();
                    Msg.info(this, "Claude CLI version: " + version);
                }
                return true;
            } else {
                Msg.warn(this, "Claude CLI version check failed with exit code: " +
                        process.exitValue());
            }
        } catch (Exception e) {
            Msg.error(this, "Claude CLI test failed: " + e.getMessage());
        }

        return false;
    }

    /**
     * Get the path to the Claude CLI if found.
     */
    public String getCliPath() {
        return findClaudeCli();
    }

    // Token counting - CLI doesn't provide token counts, so we estimate
    @Override
    public int countTokens(List<ChatMessage> messages) {
        // Rough estimate: ~4 characters per token
        String formatted = formatMessagesForCli(messages);
        return formatted.length() / 4;
    }

    @Override
    public int countTokens(String text) {
        if (text == null) return 0;
        return text.length() / 4;
    }
}

```

`src/main/java/ghidrassist/apiprovider/AnthropicOAuthProvider.java`:

```java
package ghidrassist.apiprovider;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import ghidra.util.Msg;
import ghidrassist.LlmApi.LlmResponseHandler;
import ghidrassist.apiprovider.capabilities.FunctionCallingProvider;
import ghidrassist.apiprovider.capabilities.ModelListProvider;
import ghidrassist.apiprovider.exceptions.*;
import ghidrassist.apiprovider.oauth.OAuthTokenManager;
import okhttp3.*;
import okio.BufferedSource;

import javax.net.ssl.*;
import java.io.IOException;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Anthropic OAuth Provider - Uses OAuth authentication for Claude Pro/Max subscriptions.
 * 
 * This provider uses OAuth PKCE authentication to access the Anthropic API using
 * Claude Pro/Max subscriptions, replicating the authentication flow used by Claude Code.
 * 
 * Key Features:
 * - OAuth PKCE authentication (no API key required)
 * - Automatic token refresh
 * - Two-step warmup sequence (required by API)
 * - Claude Code-style request formatting
 * - Tool name prefixing (mcp_)
 * 
 * Based on the BinAssist Anthropic Experimental Provider implementation.
 */
public class AnthropicOAuthProvider extends APIProvider implements FunctionCallingProvider, ModelListProvider {
    
    private static final Gson gson = new Gson();
    private static final MediaType JSON = MediaType.get("application/json; charset=utf-8");
    
    // Anthropic API
    private static final String ANTHROPIC_API_URL = "https://api.anthropic.com";
    private static final String MESSAGES_ENDPOINT = "/v1/messages";
    
    // Required system prompt prefix for Claude Code OAuth requests
    private static final String CLAUDE_CODE_SYSTEM_PREFIX = 
        "You are a Claude agent, built on Anthropic's Claude Agent SDK.";
    
    // Tool name prefix required by OAuth API
    private static final String TOOL_PREFIX = "mcp_";
    
    // Beta headers
    private static final String BETA_HEADERS_WARMUP = "oauth-2025-04-20,interleaved-thinking-2025-05-14";
    private static final String BETA_HEADERS_FULL = "claude-code-20250219,oauth-2025-04-20,interleaved-thinking-2025-05-14";
    
    // Retry settings
    private static final int MAX_STREAMING_RETRIES = 10;
    private static final int MIN_RETRY_BACKOFF_MS = 10000;
    private static final int MAX_RETRY_BACKOFF_MS = 30000;
    
    // Minimal stub tools required for OAuth API requests
    private static final JsonArray MINIMAL_STUB_TOOLS;
    static {
        MINIMAL_STUB_TOOLS = new JsonArray();
        
        JsonObject taskTool = new JsonObject();
        taskTool.addProperty("name", "mcp_Task");
        taskTool.addProperty("description", "Launch a task to perform work");
        JsonObject taskSchema = new JsonObject();
        taskSchema.addProperty("type", "object");
        JsonObject taskProps = new JsonObject();
        JsonObject promptProp = new JsonObject();
        promptProp.addProperty("type", "string");
        promptProp.addProperty("description", "The task prompt");
        taskProps.add("prompt", promptProp);
        taskSchema.add("properties", taskProps);
        JsonArray required = new JsonArray();
        required.add("prompt");
        taskSchema.add("required", required);
        taskTool.add("input_schema", taskSchema);
        MINIMAL_STUB_TOOLS.add(taskTool);
        
        JsonObject bashTool = new JsonObject();
        bashTool.addProperty("name", "mcp_Bash");
        bashTool.addProperty("description", "Execute bash commands");
        JsonObject bashSchema = new JsonObject();
        bashSchema.addProperty("type", "object");
        JsonObject bashProps = new JsonObject();
        JsonObject cmdProp = new JsonObject();
        cmdProp.addProperty("type", "string");
        cmdProp.addProperty("description", "The command to run");
        bashProps.add("command", cmdProp);
        bashSchema.add("properties", bashProps);
        JsonArray bashRequired = new JsonArray();
        bashRequired.add("command");
        bashSchema.add("required", bashRequired);
        bashTool.add("input_schema", bashSchema);
        MINIMAL_STUB_TOOLS.add(bashTool);
        
        JsonObject readTool = new JsonObject();
        readTool.addProperty("name", "mcp_Read");
        readTool.addProperty("description", "Read file contents");
        JsonObject readSchema = new JsonObject();
        readSchema.addProperty("type", "object");
        JsonObject readProps = new JsonObject();
        JsonObject pathProp = new JsonObject();
        pathProp.addProperty("type", "string");
        pathProp.addProperty("description", "File path to read");
        readProps.add("path", pathProp);
        readSchema.add("properties", readProps);
        JsonArray readRequired = new JsonArray();
        readRequired.add("path");
        readSchema.add("required", readRequired);
        readTool.add("input_schema", readSchema);
        MINIMAL_STUB_TOOLS.add(readTool);
    }
    
    private final OAuthTokenManager tokenManager;
    private volatile boolean warmedUp = false;
    private volatile boolean isCancelled = false;
    
    /**
     * Creates a new Anthropic OAuth provider.
     * 
     * @param name Provider name
     * @param model Model to use
     * @param maxTokens Maximum tokens
     * @param url Ignored (uses Anthropic API URL)
     * @param key OAuth credentials as JSON, or empty for unauthenticated
     * @param disableTlsVerification TLS verification setting
     * @param timeout Timeout in seconds
     */
    public AnthropicOAuthProvider(String name, String model, Integer maxTokens, String url, 
                               String key, boolean disableTlsVerification, Integer timeout) {
        super(name, ProviderType.ANTHROPIC_OAUTH, model, maxTokens, 
              ANTHROPIC_API_URL, key, disableTlsVerification, timeout);
        
        // Initialize token manager with credentials from key field
        this.tokenManager = new OAuthTokenManager(key);
        
        Msg.info(this, "Anthropic OAuth provider initialized with model: " + model);
    }
    
    /**
     * Gets the OAuth token manager for authentication operations.
     */
    public OAuthTokenManager getTokenManager() {
        return tokenManager;
    }
    
    /**
     * Checks if the provider is authenticated.
     */
    public boolean isAuthenticated() {
        return tokenManager.isAuthenticated();
    }
    
    /**
     * Gets updated credentials JSON for storage.
     */
    public String getCredentialsJson() {
        return tokenManager.toJson();
    }
    
    @Override
    protected OkHttpClient buildClient() {
        try {
            OkHttpClient.Builder builder = new OkHttpClient.Builder()
                .connectTimeout(super.timeout)
                .readTimeout(super.timeout)
                .writeTimeout(super.timeout)
                .retryOnConnectionFailure(true);
            
            if (disableTlsVerification) {
                TrustManager[] trustAllCerts = new TrustManager[]{
                    new X509TrustManager() {
                        @Override
                        public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) {}
                        @Override
                        public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) {}
                        @Override
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return new java.security.cert.X509Certificate[]{};
                        }
                    }
                };
                
                SSLContext sslContext = SSLContext.getInstance("TLS");
                sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
                builder.sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustAllCerts[0])
                       .hostnameVerifier((hostname, session) -> true);
            }
            
            return builder.build();
        } catch (Exception e) {
            throw new RuntimeException("Failed to build HTTP client", e);
        }
    }
    
    // =========================================================================
    // Warmup Sequence
    // =========================================================================
    
    /**
     * Ensures the warmup sequence has been performed.
     */
    private void ensureWarmedUp() throws APIProviderException {
        if (!warmedUp) {
            performWarmup();
        }
    }
    
    /**
     * Performs the two-step warmup sequence required for OAuth API calls.
     */
    private synchronized void performWarmup() throws APIProviderException {
        if (warmedUp) return;
        
        if (!isAuthenticated()) {
            throw new AuthenticationException(name, "warmup", 401, null,
                "Not authenticated. Please authenticate via Settings > Edit Provider > Authenticate.");
        }
        
        Msg.info(this, "Performing OAuth warmup sequence...");
        
        try {
            // Step 1: Quota check (no claude-code beta)
            Msg.debug(this, "Warmup step 1/2: quota check...");
            warmupQuotaCheck();
            
            // Step 2: Token counting with tools (includes claude-code beta)
            Msg.debug(this, "Warmup step 2/2: token count with tools...");
            warmupTokenCount();
            
            warmedUp = true;
            Msg.info(this, "OAuth warmup completed successfully");
            
        } catch (Exception e) {
            Msg.error(this, "OAuth warmup failed: " + e.getMessage());
            throw new APIProviderException(APIProviderException.ErrorCategory.SERVICE_ERROR,
                name, "warmup", "OAuth warmup failed: " + e.getMessage());
        }
    }
    
    /**
     * Step 1: Simple quota check request (no claude-code beta).
     */
    private void warmupQuotaCheck() throws IOException, APIProviderException {
        String accessToken = tokenManager.getValidAccessToken();
        
        JsonObject payload = new JsonObject();
        payload.addProperty("model", "claude-haiku-4-5-20251001");
        payload.addProperty("max_tokens", 1);
        JsonArray messages = new JsonArray();
        JsonObject msg = new JsonObject();
        msg.addProperty("role", "user");
        msg.addProperty("content", "quota");
        messages.add(msg);
        payload.add("messages", messages);
        
        JsonObject metadata = new JsonObject();
        metadata.addProperty("user_id", generateUserId());
        payload.add("metadata", metadata);
        
        Request request = new Request.Builder()
            .url(ANTHROPIC_API_URL + MESSAGES_ENDPOINT + "?beta=true")
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .header("Authorization", "Bearer " + accessToken)
            .header("anthropic-version", "2023-06-01")
            .header("anthropic-beta", BETA_HEADERS_WARMUP)
            .header("anthropic-dangerous-direct-browser-access", "true")
            .header("Content-Type", "application/json")
            .header("user-agent", "claude-cli/2.1.6 (external, sdk-cli)")
            .header("x-app", "cli")
            .build();
        
        try (Response response = client.newCall(request).execute()) {
            if (!response.isSuccessful()) {
                String body = response.body() != null ? response.body().string() : "";
                throw new IOException("Warmup quota check failed: " + response.code() + " - " + body);
            }
            Msg.debug(this, "Warmup step 1 succeeded");
        }
    }
    
    /**
     * Step 2: Token counting request with tools (includes claude-code beta).
     */
    private void warmupTokenCount() throws IOException, APIProviderException {
        String accessToken = tokenManager.getValidAccessToken();
        
        // Tools without mcp_ prefix for token counting
        JsonArray tools = new JsonArray();
        JsonObject tool = new JsonObject();
        tool.addProperty("name", "Task");
        tool.addProperty("description", "Launch a task");
        JsonObject schema = new JsonObject();
        schema.addProperty("type", "object");
        JsonObject props = new JsonObject();
        JsonObject promptProp = new JsonObject();
        promptProp.addProperty("type", "string");
        props.add("prompt", promptProp);
        schema.add("properties", props);
        JsonArray required = new JsonArray();
        required.add("prompt");
        schema.add("required", required);
        tool.add("input_schema", schema);
        tools.add(tool);
        
        JsonObject payload = new JsonObject();
        payload.addProperty("model", "claude-opus-4-5-20251101");
        JsonArray messages = new JsonArray();
        JsonObject msg = new JsonObject();
        msg.addProperty("role", "user");
        msg.addProperty("content", "foo");
        messages.add(msg);
        payload.add("messages", messages);
        payload.add("tools", tools);
        
        Request request = new Request.Builder()
            .url(ANTHROPIC_API_URL + "/v1/messages/count_tokens?beta=true")
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .header("Authorization", "Bearer " + accessToken)
            .header("anthropic-version", "2023-06-01")
            .header("anthropic-beta", BETA_HEADERS_FULL + ",token-counting-2024-11-01")
            .header("anthropic-dangerous-direct-browser-access", "true")
            .header("Content-Type", "application/json")
            .header("user-agent", "claude-cli/2.1.6 (external, sdk-cli)")
            .header("x-app", "cli")
            .build();
        
        try (Response response = client.newCall(request).execute()) {
            if (!response.isSuccessful()) {
                String body = response.body() != null ? response.body().string() : "";
                throw new IOException("Warmup token count failed: " + response.code() + " - " + body);
            }
            Msg.debug(this, "Warmup step 2 succeeded");
        }
    }
    
    /**
     * Generates a user ID in Claude Code format.
     */
    private String generateUserId() {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest("ghidrassist_oauth".getBytes());
            StringBuilder hex = new StringBuilder();
            for (byte b : hash) {
                hex.append(String.format("%02x", b));
            }
            return "user_" + hex + "_account_00000000-0000-0000-0000-000000000000_session_00000000-0000-0000-0000-000000000000";
        } catch (Exception e) {
            return "user_ghidrassist";
        }
    }
    
    // =========================================================================
    // Request Helpers
    // =========================================================================
    
    /**
     * Gets headers for OAuth API requests.
     */
    private Headers.Builder getOAuthHeaders() throws IOException {
        String accessToken = tokenManager.getValidAccessToken();
        
        return new Headers.Builder()
            .add("Authorization", "Bearer " + accessToken)
            .add("anthropic-version", "2023-06-01")
            .add("anthropic-beta", BETA_HEADERS_FULL)
            .add("anthropic-dangerous-direct-browser-access", "true")
            .add("Content-Type", "application/json")
            .add("Accept", "application/json")
            .add("user-agent", "claude-cli/2.1.6 (external, sdk-cli)")
            .add("x-app", "cli");
    }
    
    /**
     * Prepares the system prompt with required Claude Code prefix.
     * Currently ignores custom system prompts due to OAuth restrictions.
     */
    private String prepareSystemPrompt(String originalSystem) {
        // WORKAROUND: Only use Claude Code prefix, ignore custom system prompt
        // The full system prompt causes OAuth rejection
        return CLAUDE_CODE_SYSTEM_PREFIX;
    }
    
    /**
     * Prepares tools array with mcp_ prefix.
     */
    private JsonArray prepareTools(List<Map<String, Object>> requestTools) {
        if (requestTools != null && !requestTools.isEmpty()) {
            JsonArray tools = new JsonArray();
            for (Map<String, Object> tool : requestTools) {
                @SuppressWarnings("unchecked")
                Map<String, Object> function = (Map<String, Object>) tool.get("function");
                
                JsonObject anthropicTool = new JsonObject();
                String name = (String) function.get("name");
                if (!name.startsWith(TOOL_PREFIX)) {
                    name = TOOL_PREFIX + name;
                }
                anthropicTool.addProperty("name", name);
                anthropicTool.addProperty("description", (String) function.get("description"));
                
                @SuppressWarnings("unchecked")
                Map<String, Object> parameters = (Map<String, Object>) function.get("parameters");
                if (parameters != null) {
                    anthropicTool.add("input_schema", gson.toJsonTree(parameters));
                }
                
                tools.add(anthropicTool);
            }
            return tools;
        }
        return MINIMAL_STUB_TOOLS.deepCopy();
    }
    
    /**
     * Removes mcp_ prefix from tool names in response.
     */
    private String removeToolPrefix(String name) {
        if (name != null && name.startsWith(TOOL_PREFIX)) {
            return name.substring(TOOL_PREFIX.length());
        }
        return name;
    }
    
    // =========================================================================
    // Chat Completion
    // =========================================================================
    
    @Override
    public String createChatCompletion(List<ChatMessage> messages) throws APIProviderException {
        if (!isAuthenticated()) {
            throw new AuthenticationException(name, "createChatCompletion", 401, null,
                "Not authenticated. Please authenticate via Settings > Edit Provider > Authenticate.");
        }
        
        ensureWarmedUp();
        
        try {
            JsonObject payload = buildMessagesPayload(messages, false);
            
            Request request = new Request.Builder()
                .url(ANTHROPIC_API_URL + MESSAGES_ENDPOINT + "?beta=true")
                .post(RequestBody.create(gson.toJson(payload), JSON))
                .headers(getOAuthHeaders().build())
                .build();
            
            try (Response response = executeWithRetry(request, "createChatCompletion")) {
                JsonObject responseObj = gson.fromJson(response.body().string(), JsonObject.class);
                
                StringBuilder textContent = new StringBuilder();
                if (responseObj.has("content")) {
                    JsonArray contentArray = responseObj.getAsJsonArray("content");
                    for (JsonElement contentElement : contentArray) {
                        JsonObject contentBlock = contentElement.getAsJsonObject();
                        String type = contentBlock.get("type").getAsString();
                        if ("text".equals(type) && contentBlock.has("text")) {
                            textContent.append(contentBlock.get("text").getAsString());
                        }
                    }
                }
                return textContent.toString();
            }
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletion");
        }
    }
    
    @Override
    public void streamChatCompletion(List<ChatMessage> messages, LlmResponseHandler handler) 
            throws APIProviderException {
        if (!isAuthenticated()) {
            throw new AuthenticationException(name, "streamChatCompletion", 401, null,
                "Not authenticated. Please authenticate via Settings > Edit Provider > Authenticate.");
        }
        
        ensureWarmedUp();
        
        JsonObject payload = buildMessagesPayload(messages, true);
        executeStreamingWithRetry(payload, handler, "streamChatCompletion", 0);
    }
    
    /**
     * Execute streaming request with retry logic.
     */
    private void executeStreamingWithRetry(JsonObject payload, LlmResponseHandler handler,
                                           String operation, int attemptNumber) {
        if (isCancelled) {
            handler.onError(new APIProviderException(APIProviderException.ErrorCategory.CANCELLED,
                name, operation, "Request cancelled"));
            return;
        }
        
        try {
            Request request = new Request.Builder()
                .url(ANTHROPIC_API_URL + MESSAGES_ENDPOINT + "?beta=true")
                .post(RequestBody.create(gson.toJson(payload), JSON))
                .headers(getOAuthHeaders().add("Accept", "text/event-stream").build())
                .build();
            
            client.newCall(request).enqueue(new Callback() {
                private boolean isFirst = true;
                private StringBuilder contentBuilder = new StringBuilder();
                
                @Override
                public void onFailure(Call call, IOException e) {
                    APIProviderException error = handleNetworkError(e, operation);
                    if (shouldRetryStreaming(error, attemptNumber)) {
                        retryStreamingAfterDelay(payload, handler, operation, attemptNumber, error);
                    } else {
                        handler.onError(error);
                    }
                }
                
                @Override
                public void onResponse(Call call, Response response) throws IOException {
                    try (ResponseBody responseBody = response.body()) {
                        if (!response.isSuccessful()) {
                            String errorBody = responseBody != null ? responseBody.string() : null;
                            APIProviderException error = handleHttpError(response, errorBody, operation);
                            
                            if (shouldRetryStreaming(error, attemptNumber)) {
                                retryStreamingAfterDelay(payload, handler, operation, attemptNumber, error);
                            } else {
                                handler.onError(error);
                            }
                            return;
                        }
                        
                        BufferedSource source = responseBody.source();
                        while (!source.exhausted() && !isCancelled && handler.shouldContinue()) {
                            String line = source.readUtf8Line();
                            if (line == null || line.isEmpty()) continue;
                            
                            if (line.equals("event: ping")) {
                                source.readUtf8Line();
                                continue;
                            }
                            
                            if (line.startsWith("data: ")) {
                                String data = line.substring(6).trim();
                                if (data.equals("[DONE]")) {
                                    handler.onComplete(contentBuilder.toString());
                                    return;
                                }
                                
                                JsonObject event = gson.fromJson(data, JsonObject.class);
                                
                                if (event.has("type") && event.get("type").getAsString().equals("error")) {
                                    handler.onError(new APIProviderException(
                                        APIProviderException.ErrorCategory.SERVICE_ERROR,
                                        name, operation, event.get("error").getAsString()));
                                    return;
                                }
                                
                                if (event.has("type") && 
                                    event.get("type").getAsString().equals("content_block_delta")) {
                                    JsonObject delta = event.getAsJsonObject("delta");
                                    
                                    if (delta.has("text")) {
                                        String text = delta.get("text").getAsString();
                                        if (isFirst) {
                                            handler.onStart();
                                            isFirst = false;
                                        }
                                        contentBuilder.append(text);
                                        handler.onUpdate(text);
                                    }
                                }
                            }
                        }
                        
                        if (isCancelled) {
                            handler.onError(new APIProviderException(
                                APIProviderException.ErrorCategory.CANCELLED,
                                name, operation, "Request cancelled"));
                        } else {
                            handler.onComplete(contentBuilder.toString());
                        }
                    }
                }
            });
        } catch (IOException e) {
            handler.onError(handleNetworkError(e, operation));
        }
    }
    
    private boolean shouldRetryStreaming(APIProviderException error, int attemptNumber) {
        if (attemptNumber >= MAX_STREAMING_RETRIES) return false;
        
        switch (error.getCategory()) {
            case RATE_LIMIT:
            case NETWORK:
            case TIMEOUT:
            case SERVICE_ERROR:
                return true;
            default:
                return false;
        }
    }
    
    private void retryStreamingAfterDelay(JsonObject payload, LlmResponseHandler handler,
                                          String operation, int attemptNumber, 
                                          APIProviderException error) {
        int nextAttempt = attemptNumber + 1;
        int waitTimeMs = calculateStreamingRetryWait(error);
        
        Msg.warn(this, String.format("Streaming retry %d/%d for %s: %s. Waiting %d seconds...",
            nextAttempt, MAX_STREAMING_RETRIES, operation,
            error.getCategory().getDisplayName(), waitTimeMs / 1000));
        
        new Thread(() -> {
            try {
                Thread.sleep(waitTimeMs);
                if (!isCancelled) {
                    executeStreamingWithRetry(payload, handler, operation, nextAttempt);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                handler.onError(new APIProviderException(APIProviderException.ErrorCategory.CANCELLED,
                    name, operation, "Retry interrupted"));
            }
        }, "AnthropicOAuthProvider-StreamRetry").start();
    }
    
    private int calculateStreamingRetryWait(APIProviderException error) {
        if (error.getCategory() == APIProviderException.ErrorCategory.RATE_LIMIT) {
            Integer retryAfter = error.getRetryAfterSeconds();
            if (retryAfter != null && retryAfter > 0) {
                return retryAfter * 1000;
            }
        }
        return MIN_RETRY_BACKOFF_MS + (int) (Math.random() * (MAX_RETRY_BACKOFF_MS - MIN_RETRY_BACKOFF_MS));
    }
    
    // =========================================================================
    // Function Calling
    // =========================================================================
    
    @Override
    public String createChatCompletionWithFunctions(List<ChatMessage> messages, 
                                                    List<Map<String, Object>> functions) 
            throws APIProviderException {
        if (!isAuthenticated()) {
            throw new AuthenticationException(name, "createChatCompletionWithFunctions", 401, null,
                "Not authenticated. Please authenticate via Settings > Edit Provider > Authenticate.");
        }
        
        ensureWarmedUp();
        
        try {
            JsonObject payload = buildMessagesPayload(messages, false);
            payload.add("tools", prepareTools(functions));
            
            JsonObject toolChoice = new JsonObject();
            toolChoice.addProperty("type", "any");
            payload.add("tool_choice", toolChoice);
            
            Request request = new Request.Builder()
                .url(ANTHROPIC_API_URL + MESSAGES_ENDPOINT + "?beta=true")
                .post(RequestBody.create(gson.toJson(payload), JSON))
                .headers(getOAuthHeaders().build())
                .build();
            
            try (Response response = executeWithRetry(request, "createChatCompletionWithFunctions")) {
                JsonObject responseObj = gson.fromJson(response.body().string(), JsonObject.class);
                
                JsonArray toolCallsArray = new JsonArray();
                
                if (responseObj.has("content")) {
                    JsonArray contentArray = responseObj.getAsJsonArray("content");
                    
                    for (JsonElement contentElement : contentArray) {
                        JsonObject contentBlock = contentElement.getAsJsonObject();
                        String type = contentBlock.get("type").getAsString();
                        
                        if ("tool_use".equals(type)) {
                            JsonObject toolCall = new JsonObject();
                            toolCall.addProperty("id", contentBlock.get("id").getAsString());
                            toolCall.addProperty("type", "function");
                            
                            JsonObject function = new JsonObject();
                            function.addProperty("name", 
                                removeToolPrefix(contentBlock.get("name").getAsString()));
                            function.addProperty("arguments", 
                                gson.toJson(contentBlock.get("input")));
                            toolCall.add("function", function);
                            
                            toolCallsArray.add(toolCall);
                        }
                    }
                }
                
                JsonObject result = new JsonObject();
                result.add("tool_calls", toolCallsArray);
                return gson.toJson(result);
            }
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletionWithFunctions");
        }
    }
    
    @Override
    public String createChatCompletionWithFunctionsFullResponse(List<ChatMessage> messages,
                                                                List<Map<String, Object>> functions)
            throws APIProviderException {
        if (!isAuthenticated()) {
            throw new AuthenticationException(name, "createChatCompletionWithFunctionsFullResponse", 401, null,
                "Not authenticated. Please authenticate via Settings > Edit Provider > Authenticate.");
        }
        
        ensureWarmedUp();
        
        try {
            JsonObject payload = buildMessagesPayload(messages, false);
            payload.add("tools", prepareTools(functions));
            
            Request request = new Request.Builder()
                .url(ANTHROPIC_API_URL + MESSAGES_ENDPOINT + "?beta=true")
                .post(RequestBody.create(gson.toJson(payload), JSON))
                .headers(getOAuthHeaders().build())
                .build();
            
            try (Response response = executeWithRetry(request, "createChatCompletionWithFunctionsFullResponse")) {
                JsonObject responseObj = gson.fromJson(response.body().string(), JsonObject.class);
                
                // Convert to OpenAI format
                JsonObject fullResponse = new JsonObject();
                JsonArray choices = new JsonArray();
                JsonObject choice = new JsonObject();
                JsonObject message = new JsonObject();
                
                message.addProperty("role", "assistant");
                
                String finishReason = "stop";
                JsonArray toolCalls = null;
                StringBuilder textContent = new StringBuilder();
                
                if (responseObj.has("content")) {
                    JsonArray contentArray = responseObj.getAsJsonArray("content");
                    
                    for (JsonElement contentElement : contentArray) {
                        JsonObject contentBlock = contentElement.getAsJsonObject();
                        String type = contentBlock.get("type").getAsString();
                        
                        if ("tool_use".equals(type)) {
                            if (toolCalls == null) {
                                toolCalls = new JsonArray();
                                finishReason = "tool_calls";
                            }
                            
                            JsonObject toolCall = new JsonObject();
                            toolCall.addProperty("id", contentBlock.get("id").getAsString());
                            toolCall.addProperty("type", "function");
                            
                            JsonObject function = new JsonObject();
                            function.addProperty("name",
                                removeToolPrefix(contentBlock.get("name").getAsString()));
                            function.addProperty("arguments",
                                gson.toJson(contentBlock.get("input")));
                            toolCall.add("function", function);
                            
                            toolCalls.add(toolCall);
                            
                        } else if ("text".equals(type)) {
                            if (contentBlock.has("text")) {
                                textContent.append(contentBlock.get("text").getAsString());
                            }
                        }
                    }
                }
                
                if (toolCalls != null) {
                    message.add("tool_calls", toolCalls);
                    if (textContent.length() > 0) {
                        message.addProperty("content", textContent.toString());
                    }
                } else {
                    message.addProperty("content", textContent.toString());
                }
                
                if (responseObj.has("stop_reason")) {
                    String anthropicStopReason = responseObj.get("stop_reason").getAsString();
                    if ("tool_use".equals(anthropicStopReason)) {
                        finishReason = "tool_calls";
                    } else {
                        finishReason = "stop";
                    }
                }
                
                choice.add("message", message);
                choice.addProperty("finish_reason", finishReason);
                choice.addProperty("index", 0);
                choices.add(choice);
                
                fullResponse.add("choices", choices);
                fullResponse.addProperty("id", "chatcmpl-oauth-" + System.currentTimeMillis());
                fullResponse.addProperty("object", "chat.completion");
                fullResponse.addProperty("created", System.currentTimeMillis() / 1000);
                fullResponse.addProperty("model", this.model);
                
                return gson.toJson(fullResponse);
            }
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletionWithFunctionsFullResponse");
        }
    }
    
    // =========================================================================
    // Message Building
    // =========================================================================
    
    private JsonObject buildMessagesPayload(List<ChatMessage> messages, boolean stream) {
        JsonObject payload = new JsonObject();
        payload.addProperty("model", super.getModel());
        payload.addProperty("max_tokens", super.getMaxTokens());
        payload.addProperty("stream", stream);
        
        // Add system prompt with Claude Code prefix
        String systemPrompt = prepareSystemPrompt(null);
        payload.addProperty("system", systemPrompt);
        
        // Add tools
        payload.add("tools", MINIMAL_STUB_TOOLS.deepCopy());
        
        // Add metadata
        JsonObject metadata = new JsonObject();
        metadata.addProperty("user_id", generateUserId());
        payload.add("metadata", metadata);
        
        // Convert messages
        JsonArray messagesArray = new JsonArray();
        for (ChatMessage message : messages) {
            if (message.getRole().equals(ChatMessage.ChatMessageRole.SYSTEM)) {
                // System messages handled separately
                continue;
            }
            
            JsonObject messageObj = new JsonObject();
            messageObj.addProperty("role", convertRole(message.getRole()));
            
            if (message.getRole().equals(ChatMessage.ChatMessageRole.TOOL)) {
                JsonArray contentArray = new JsonArray();
                JsonObject toolResultBlock = new JsonObject();
                toolResultBlock.addProperty("type", "tool_result");
                toolResultBlock.addProperty("tool_use_id", message.getToolCallId());
                toolResultBlock.addProperty("content", message.getContent());
                contentArray.add(toolResultBlock);
                messageObj.add("content", contentArray);
                
            } else if (message.getToolCalls() != null) {
                JsonArray contentArray = new JsonArray();
                
                if (message.getContent() != null && !message.getContent().isEmpty()) {
                    JsonObject textBlock = new JsonObject();
                    textBlock.addProperty("type", "text");
                    textBlock.addProperty("text", message.getContent());
                    contentArray.add(textBlock);
                }
                
                JsonArray toolCalls = message.getToolCalls();
                for (JsonElement toolCallElement : toolCalls) {
                    JsonObject toolCall = toolCallElement.getAsJsonObject();
                    JsonObject function = toolCall.getAsJsonObject("function");
                    
                    JsonObject toolUseBlock = new JsonObject();
                    toolUseBlock.addProperty("type", "tool_use");
                    toolUseBlock.addProperty("id", toolCall.get("id").getAsString());
                    
                    String toolName = function.get("name").getAsString();
                    if (!toolName.startsWith(TOOL_PREFIX)) {
                        toolName = TOOL_PREFIX + toolName;
                    }
                    toolUseBlock.addProperty("name", toolName);
                    
                    try {
                        JsonElement argumentsElement = function.get("arguments");
                        if (argumentsElement != null && !argumentsElement.isJsonNull()) {
                            String argumentsStr = argumentsElement.getAsString();
                            if (argumentsStr != null && !argumentsStr.trim().isEmpty()) {
                                JsonElement arguments = gson.fromJson(argumentsStr, JsonElement.class);
                                toolUseBlock.add("input", arguments);
                            } else {
                                toolUseBlock.add("input", new JsonObject());
                            }
                        } else {
                            toolUseBlock.add("input", new JsonObject());
                        }
                    } catch (Exception e) {
                        toolUseBlock.add("input", new JsonObject());
                    }
                    
                    contentArray.add(toolUseBlock);
                }
                
                messageObj.add("content", contentArray);
                
            } else {
                String content = message.getContent();
                if (content == null || content.trim().isEmpty()) {
                    continue;
                }
                messageObj.addProperty("content", content);
            }
            
            messagesArray.add(messageObj);
        }
        
        payload.add("messages", messagesArray);
        return payload;
    }
    
    private String convertRole(String role) {
        switch (role) {
            case ChatMessage.ChatMessageRole.USER:
                return "user";
            case ChatMessage.ChatMessageRole.ASSISTANT:
                return "assistant";
            case ChatMessage.ChatMessageRole.FUNCTION:
                return "assistant";
            case ChatMessage.ChatMessageRole.TOOL:
                return "user";
            default:
                return role;
        }
    }
    
    // =========================================================================
    // Other Required Methods
    // =========================================================================
    
    @Override
    public List<String> getAvailableModels() throws APIProviderException {
        List<String> models = new ArrayList<>();
        models.add("claude-sonnet-4-20250514");
        models.add("claude-haiku-4-5-20251001");
        models.add("claude-opus-4-5-20251101");
        return models;
    }
    
    @Override
    public void getEmbeddingsAsync(String text, EmbeddingCallback callback) {
        callback.onError(new UnsupportedOperationException(
            "Embeddings are not supported by the Anthropic OAuth API"));
    }
    
    public void cancelRequest() {
        isCancelled = true;
    }
    
    /**
     * Resets the warmup state (for re-authentication).
     */
    public void resetWarmup() {
        warmedUp = false;
    }
}

```

`src/main/java/ghidrassist/apiprovider/AnthropicPlatformApiProvider.java`:

```java
package ghidrassist.apiprovider;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import ghidra.util.Msg;
import ghidrassist.LlmApi.LlmResponseHandler;
import ghidrassist.apiprovider.exceptions.APIProviderException;
import ghidrassist.apiprovider.capabilities.FunctionCallingProvider;
import ghidrassist.apiprovider.capabilities.ModelListProvider;
import okhttp3.*;
import okio.BufferedSource;

import javax.net.ssl.*;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class AnthropicPlatformApiProvider extends APIProvider implements FunctionCallingProvider, ModelListProvider {
    private static final Gson gson = new Gson();
    private static final MediaType JSON = MediaType.get("application/json; charset=utf-8");
    private static final String ANTHROPIC_MESSAGES_ENDPOINT = "v1/messages";
    private static final String ANTHROPIC_MODELS_ENDPOINT = "v1/models";

    // Retry settings for streaming calls (matching RetryHandler defaults)
    private static final int MAX_STREAMING_RETRIES = 10;
    private static final int MIN_RETRY_BACKOFF_MS = 10000;  // 10 seconds
    private static final int MAX_RETRY_BACKOFF_MS = 30000;  // 30 seconds

    private volatile boolean isCancelled = false;

    public AnthropicPlatformApiProvider(String name, String model, Integer maxTokens, String url, String key, boolean disableTlsVerification, Integer timeout) {
        super(name, ProviderType.ANTHROPIC_PLATFORM_API, model, maxTokens, url, key, disableTlsVerification, timeout);
    }

    @Override
    protected OkHttpClient buildClient() {
        try {
            OkHttpClient.Builder builder = new OkHttpClient.Builder()
                .connectTimeout(super.timeout)
                .readTimeout(super.timeout)
                .writeTimeout(super.timeout)
                .retryOnConnectionFailure(true)
                .addInterceptor(chain -> {
                    Request originalRequest = chain.request();
                    Request.Builder requestBuilder = originalRequest.newBuilder()
                        .header("x-api-key", key)
                        .header("anthropic-version", "2023-06-01")
                        .header("Content-Type", "application/json");
                    
                    return chain.proceed(requestBuilder.build());
                });

            if (disableTlsVerification) {
                TrustManager[] trustAllCerts = new TrustManager[]{
                    new X509TrustManager() {
                        @Override
                        public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) {}
                        @Override
                        public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) {}
                        @Override
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return new java.security.cert.X509Certificate[]{};
                        }
                    }
                };

                SSLContext sslContext = SSLContext.getInstance("TLS");
                sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
                builder.sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustAllCerts[0])
                       .hostnameVerifier((hostname, session) -> true);
            }

            return builder.build();
        } catch (Exception e) {
            throw new RuntimeException("Failed to build HTTP client", e);
        }
    }

    @Override
    public String createChatCompletion(List<ChatMessage> messages) throws APIProviderException {
        JsonObject payload = buildMessagesPayload(messages, false);

        Request request = new Request.Builder()
            .url(url + ANTHROPIC_MESSAGES_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        try (Response response = executeWithRetry(request, "createChatCompletion")) {
            JsonObject responseObj = gson.fromJson(response.body().string(), JsonObject.class);

            // Anthropic returns content as an array of content blocks
            // Extract text from all text blocks
            StringBuilder textContent = new StringBuilder();
            if (responseObj.has("content")) {
                JsonArray contentArray = responseObj.getAsJsonArray("content");
                for (JsonElement contentElement : contentArray) {
                    JsonObject contentBlock = contentElement.getAsJsonObject();
                    String type = contentBlock.get("type").getAsString();
                    if ("text".equals(type) && contentBlock.has("text")) {
                        textContent.append(contentBlock.get("text").getAsString());
                    }
                }
            }
            return textContent.toString();
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletion");
        }
    }

    @Override
    public void streamChatCompletion(List<ChatMessage> messages, LlmResponseHandler handler) throws APIProviderException {
        JsonObject payload = buildMessagesPayload(messages, true);
        executeStreamingWithRetry(payload, handler, "streamChatCompletion", 0);
    }

    /**
     * Execute streaming request with retry logic for rate limits and transient errors.
     */
    private void executeStreamingWithRetry(JsonObject payload, LlmResponseHandler handler,
                                           String operation, int attemptNumber) {
        if (isCancelled) {
            handler.onError(new APIProviderException(APIProviderException.ErrorCategory.CANCELLED,
                name, operation, "Request cancelled"));
            return;
        }

        Request request = new Request.Builder()
            .url(url + ANTHROPIC_MESSAGES_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        client.newCall(request).enqueue(new Callback() {
            private boolean isFirst = true;
            private StringBuilder contentBuilder = new StringBuilder();

            @Override
            public void onFailure(Call call, IOException e) {
                APIProviderException error = handleNetworkError(e, operation);
                if (shouldRetryStreaming(error, attemptNumber)) {
                    retryStreamingAfterDelay(payload, handler, operation, attemptNumber, error);
                } else {
                    handler.onError(error);
                }
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (!response.isSuccessful()) {
                        String errorBody = responseBody != null ? responseBody.string() : null;
                        APIProviderException error = handleHttpError(response, errorBody, operation);

                        if (shouldRetryStreaming(error, attemptNumber)) {
                            retryStreamingAfterDelay(payload, handler, operation, attemptNumber, error);
                        } else {
                            handler.onError(error);
                        }
                        return;
                    }

                    BufferedSource source = responseBody.source();
                    while (!source.exhausted() && !isCancelled && handler.shouldContinue()) {
                        String line = source.readUtf8Line();
                        if (line == null || line.isEmpty()) continue;

                        // Skip ping events
                        if (line.equals("event: ping")) {
                            source.readUtf8Line(); // Skip data line
                            continue;
                        }

                        if (line.startsWith("data: ")) {
                            String data = line.substring(6).trim();
                            if (data.equals("[DONE]")) {
                                handler.onComplete(contentBuilder.toString());
                                return;
                            }

                            JsonObject event = gson.fromJson(data, JsonObject.class);

                            // Check for error events
                            if (event.has("type") && event.get("type").getAsString().equals("error")) {
                                String errorMessage;
                                JsonElement errorElement = event.get("error");
                                if (errorElement == null || errorElement.isJsonNull()) {
                                    errorMessage = "Unknown error";
                                } else if (errorElement.isJsonPrimitive()) {
                                    errorMessage = errorElement.getAsString();
                                } else {
                                    errorMessage = gson.toJson(errorElement);
                                }
                                handler.onError(new APIProviderException(APIProviderException.ErrorCategory.SERVICE_ERROR,
                                    name, operation, errorMessage));
                                return;
                            }

                            // Extract content from delta
                            if (event.has("type") && event.get("type").getAsString().equals("content_block_delta")) {
                                JsonObject delta = event.getAsJsonObject("delta");

                                // Check if this is a text delta (skip thinking deltas)
                                if (delta.has("text")) {
                                    String text = delta.get("text").getAsString();

                                    if (isFirst) {
                                        handler.onStart();
                                        isFirst = false;
                                    }
                                    contentBuilder.append(text);
                                    handler.onUpdate(text);
                                }
                                // Thinking deltas are silently ignored (not displayed)
                            }
                        }
                    }

                    if (isCancelled) {
                        handler.onError(new APIProviderException(APIProviderException.ErrorCategory.CANCELLED,
                            name, operation, "Request cancelled"));
                    } else {
                        handler.onComplete(contentBuilder.toString());
                    }
                }
            }
        });
    }

    /**
     * Check if a streaming error should be retried.
     */
    private boolean shouldRetryStreaming(APIProviderException error, int attemptNumber) {
        if (attemptNumber >= MAX_STREAMING_RETRIES) {
            return false;
        }

        switch (error.getCategory()) {
            case RATE_LIMIT:
            case NETWORK:
            case TIMEOUT:
            case SERVICE_ERROR:
                return true;
            default:
                return false;
        }
    }

    /**
     * Retry streaming request after appropriate delay.
     */
    private void retryStreamingAfterDelay(JsonObject payload, LlmResponseHandler handler,
                                          String operation, int attemptNumber, APIProviderException error) {
        int nextAttempt = attemptNumber + 1;
        int waitTimeMs = calculateStreamingRetryWait(error);

        Msg.warn(this, String.format("Streaming retry %d/%d for %s: %s. Waiting %d seconds...",
            nextAttempt, MAX_STREAMING_RETRIES, operation,
            error.getCategory().getDisplayName(), waitTimeMs / 1000));

        // Schedule retry on a background thread
        new Thread(() -> {
            try {
                Thread.sleep(waitTimeMs);
                if (!isCancelled) {
                    executeStreamingWithRetry(payload, handler, operation, nextAttempt);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                handler.onError(new APIProviderException(APIProviderException.ErrorCategory.CANCELLED,
                    name, operation, "Retry interrupted"));
            }
        }, "AnthropicPlatformApiProvider-StreamRetry").start();
    }

    /**
     * Calculate wait time for streaming retry with jitter.
     */
    private int calculateStreamingRetryWait(APIProviderException error) {
        // For rate limits, use retry-after if available
        if (error.getCategory() == APIProviderException.ErrorCategory.RATE_LIMIT) {
            Integer retryAfter = error.getRetryAfterSeconds();
            if (retryAfter != null && retryAfter > 0) {
                return retryAfter * 1000;
            }
        }
        // Random backoff between MIN and MAX
        return MIN_RETRY_BACKOFF_MS + (int) (Math.random() * (MAX_RETRY_BACKOFF_MS - MIN_RETRY_BACKOFF_MS));
    }

    /**
     * Retry streaming function call request after appropriate delay.
     */
    private void retryStreamingFunctionsAfterDelay(JsonObject payload, StreamingFunctionHandler handler,
                                                   String operation, int attemptNumber, APIProviderException error) {
        int nextAttempt = attemptNumber + 1;
        int waitTimeMs = calculateStreamingRetryWait(error);

        Msg.warn(this, String.format("Streaming functions retry %d/%d for %s: %s. Waiting %d seconds...",
            nextAttempt, MAX_STREAMING_RETRIES, operation,
            error.getCategory().getDisplayName(), waitTimeMs / 1000));

        // Schedule retry on a background thread
        new Thread(() -> {
            try {
                Thread.sleep(waitTimeMs);
                if (!isCancelled) {
                    executeStreamingFunctionsWithRetry(payload, handler, operation, nextAttempt);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                handler.onError(new APIProviderException(APIProviderException.ErrorCategory.CANCELLED,
                    name, operation, "Retry interrupted"));
            }
        }, "AnthropicPlatformApiProvider-StreamFunctionsRetry").start();
    }

    @Override
    @SuppressWarnings("unchecked")  // Intentional cast from known OpenAI function format
    public String createChatCompletionWithFunctionsFullResponse(List<ChatMessage> messages, List<Map<String, Object>> functions) throws APIProviderException {
        // Build payload with native Anthropic tools support
        JsonObject payload = buildMessagesPayload(messages, false);
        
        // Convert OpenAI function format to Anthropic tools format
        JsonArray anthropicTools = new JsonArray();
        for (Map<String, Object> tool : functions) {
            Map<String, Object> function = (Map<String, Object>) tool.get("function");
            
            JsonObject anthropicTool = new JsonObject();
            anthropicTool.addProperty("name", (String) function.get("name"));
            anthropicTool.addProperty("description", (String) function.get("description"));
            
            // Convert parameters schema to input_schema
            Map<String, Object> parameters = (Map<String, Object>) function.get("parameters");
            if (parameters != null) {
                anthropicTool.add("input_schema", gson.toJsonTree(parameters));
            }
            
            anthropicTools.add(anthropicTool);
        }
        
        payload.add("tools", anthropicTools);

        Request request = new Request.Builder()
            .url(url + ANTHROPIC_MESSAGES_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        try (Response response = executeWithRetry(request, "createChatCompletionWithFunctionsFullResponse")) {
            JsonObject responseObj = gson.fromJson(response.body().string(), JsonObject.class);
            
            // Convert Anthropic response to OpenAI format
            JsonObject fullResponse = new JsonObject();
            JsonArray choices = new JsonArray();
            JsonObject choice = new JsonObject();
            JsonObject message = new JsonObject();
            
            message.addProperty("role", "assistant");
            
            // Parse Anthropic's content array for tool_use blocks
            String finishReason = "stop";
            JsonArray toolCalls = null;
            StringBuilder textContent = new StringBuilder();
            
            if (responseObj.has("content")) {
                JsonArray contentArray = responseObj.getAsJsonArray("content");
                
                for (JsonElement contentElement : contentArray) {
                    JsonObject contentBlock = contentElement.getAsJsonObject();
                    String type = contentBlock.get("type").getAsString();
                    
                    if ("tool_use".equals(type)) {
                        // Convert Anthropic tool_use to OpenAI tool_calls format
                        if (toolCalls == null) {
                            toolCalls = new JsonArray();
                            finishReason = "tool_calls";
                        }
                        
                        JsonObject toolCall = new JsonObject();
                        toolCall.addProperty("id", contentBlock.get("id").getAsString());
                        toolCall.addProperty("type", "function");
                        
                        JsonObject function = new JsonObject();
                        function.addProperty("name", contentBlock.get("name").getAsString());
                        function.addProperty("arguments", gson.toJson(contentBlock.get("input")));
                        toolCall.add("function", function);
                        
                        toolCalls.add(toolCall);
                        
                    } else if ("text".equals(type)) {
                        // Collect text content
                        if (contentBlock.has("text")) {
                            textContent.append(contentBlock.get("text").getAsString());
                        }
                    }
                }
            }
            
            // Set message content based on what we found
            if (toolCalls != null) {
                message.add("tool_calls", toolCalls);
                // Include any text content alongside tool calls
                if (textContent.length() > 0) {
                    message.addProperty("content", textContent.toString());
                }
            } else {
                message.addProperty("content", textContent.toString());
            }
            
            // Check stop_reason from Anthropic response
            if (responseObj.has("stop_reason")) {
                String anthropicStopReason = responseObj.get("stop_reason").getAsString();
                if ("tool_use".equals(anthropicStopReason)) {
                    finishReason = "tool_calls";
                } else {
                    finishReason = "stop";
                }
            }
            
            choice.add("message", message);
            choice.addProperty("finish_reason", finishReason);
            choice.addProperty("index", 0);
            choices.add(choice);
            
            fullResponse.add("choices", choices);
            fullResponse.addProperty("id", "chatcmpl-anthropic-" + System.currentTimeMillis());
            fullResponse.addProperty("object", "chat.completion");
            fullResponse.addProperty("created", System.currentTimeMillis() / 1000);
            fullResponse.addProperty("model", this.model);
            
            return gson.toJson(fullResponse);
            
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletionWithFunctionsFullResponse");
        }
    }
    

    @Override
    public String createChatCompletionWithFunctions(List<ChatMessage> messages, List<Map<String, Object>> functions) throws APIProviderException {
        // Build payload with native Anthropic tools support
        JsonObject payload = buildMessagesPayload(messages, false);
        
        // Convert OpenAI function format to Anthropic tools format
        JsonArray anthropicTools = new JsonArray();
        for (Map<String, Object> tool : functions) {
            @SuppressWarnings("unchecked")
            Map<String, Object> function = (Map<String, Object>) tool.get("function");
            
            JsonObject anthropicTool = new JsonObject();
            anthropicTool.addProperty("name", (String) function.get("name"));
            anthropicTool.addProperty("description", (String) function.get("description"));
            
            // Convert parameters schema to input_schema
            @SuppressWarnings("unchecked")
            Map<String, Object> parameters = (Map<String, Object>) function.get("parameters");
            if (parameters != null) {
                anthropicTool.add("input_schema", gson.toJsonTree(parameters));
            }
            
            anthropicTools.add(anthropicTool);
        }
        
        payload.add("tools", anthropicTools);

        // Force tool use - "any" means model must use at least one tool
        JsonObject toolChoice = new JsonObject();
        toolChoice.addProperty("type", "any");
        payload.add("tool_choice", toolChoice);

        Request request = new Request.Builder()
            .url(url + ANTHROPIC_MESSAGES_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        try (Response response = executeWithRetry(request, "createChatCompletionWithFunctions")) {
            JsonObject responseObj = gson.fromJson(response.body().string(), JsonObject.class);
            
            // Extract content from Anthropic's response format
            JsonArray toolCallsArray = new JsonArray();
            StringBuilder textContent = new StringBuilder();
            
            if (responseObj.has("content")) {
                JsonArray contentArray = responseObj.getAsJsonArray("content");
                
                for (JsonElement contentElement : contentArray) {
                    JsonObject contentBlock = contentElement.getAsJsonObject();
                    String type = contentBlock.get("type").getAsString();
                    
                    if ("tool_use".equals(type)) {
                        // Convert tool_use to legacy OpenAI-style tool call format
                        JsonObject toolCall = new JsonObject();
                        toolCall.addProperty("id", contentBlock.get("id").getAsString());
                        toolCall.addProperty("type", "function");
                        
                        JsonObject function = new JsonObject();
                        function.addProperty("name", contentBlock.get("name").getAsString());
                        function.addProperty("arguments", gson.toJson(contentBlock.get("input")));
                        toolCall.add("function", function);
                        
                        toolCallsArray.add(toolCall);
                        
                    } else if ("text".equals(type)) {
                        // Append text content
                        if (contentBlock.has("text")) {
                            textContent.append(contentBlock.get("text").getAsString());
                        }
                    }
                }
            }
            
            // Return format expected by ActionParser
            JsonObject result = new JsonObject();
            result.add("tool_calls", toolCallsArray);
            return gson.toJson(result);
            
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletionWithFunctions");
        }
    }

    /**
     * Stream chat completion with function calling support.
     * Text blocks stream immediately; tool_use blocks are buffered until complete.
     */
    public void streamChatCompletionWithFunctions(
        List<ChatMessage> messages,
        List<Map<String, Object>> functions,
        StreamingFunctionHandler handler
    ) throws APIProviderException {
        // Build payload with native Anthropic tools support
        JsonObject payload = buildMessagesPayload(messages, true); // true for streaming

        // Convert OpenAI function format to Anthropic tools format
        JsonArray anthropicTools = new JsonArray();
        for (Map<String, Object> tool : functions) {
            @SuppressWarnings("unchecked")
            Map<String, Object> function = (Map<String, Object>) tool.get("function");

            JsonObject anthropicTool = new JsonObject();
            anthropicTool.addProperty("name", (String) function.get("name"));
            anthropicTool.addProperty("description", (String) function.get("description"));

            // Convert parameters schema to input_schema
            @SuppressWarnings("unchecked")
            Map<String, Object> parameters = (Map<String, Object>) function.get("parameters");
            if (parameters != null) {
                anthropicTool.add("input_schema", gson.toJsonTree(parameters));
            }

            anthropicTools.add(anthropicTool);
        }

        payload.add("tools", anthropicTools);

        executeStreamingFunctionsWithRetry(payload, handler, "streamChatCompletionWithFunctions", 0);
    }

    /**
     * Execute streaming function call request with retry logic.
     */
    private void executeStreamingFunctionsWithRetry(JsonObject payload, StreamingFunctionHandler handler,
                                                    String operation, int attemptNumber) {
        if (isCancelled) {
            handler.onError(new APIProviderException(APIProviderException.ErrorCategory.CANCELLED,
                name, operation, "Request cancelled"));
            return;
        }

        Request request = new Request.Builder()
            .url(url + ANTHROPIC_MESSAGES_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        client.newCall(request).enqueue(new Callback() {
            private final java.util.Map<Integer, ContentBlock> contentBlocks = new java.util.HashMap<>();
            private String stopReason = null;

            @Override
            public void onFailure(Call call, IOException e) {
                APIProviderException error = handleNetworkError(e, operation);
                if (shouldRetryStreaming(error, attemptNumber)) {
                    retryStreamingFunctionsAfterDelay(payload, handler, operation, attemptNumber, error);
                } else {
                    handler.onError(error);
                }
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (!response.isSuccessful()) {
                        String errorBody = responseBody != null ? responseBody.string() : null;
                        APIProviderException error = handleHttpError(response, errorBody, operation);

                        if (shouldRetryStreaming(error, attemptNumber)) {
                            retryStreamingFunctionsAfterDelay(payload, handler, operation, attemptNumber, error);
                        } else {
                            handler.onError(error);
                        }
                        return;
                    }

                    BufferedSource source = responseBody.source();
                    while (!source.exhausted() && !isCancelled && handler.shouldContinue()) {
                        String line = source.readUtf8Line();
                        if (line == null || line.isEmpty()) continue;

                        // Skip ping events
                        if (line.equals("event: ping")) {
                            source.readUtf8Line(); // Skip data line
                            continue;
                        }

                        if (line.startsWith("data: ")) {
                            String data = line.substring(6).trim();
                            if (data.equals("[DONE]")) {
                                processStreamComplete();
                                return;
                            }

                            try {
                                JsonObject event = gson.fromJson(data, JsonObject.class);

                                // Check for error events
                                if (event.has("type") && event.get("type").getAsString().equals("error")) {
                                    String errorMsg = event.has("error") ?
                                        event.getAsJsonObject("error").get("message").getAsString() :
                                        "Unknown streaming error";
                                    handler.onError(new APIProviderException(
                                        APIProviderException.ErrorCategory.SERVICE_ERROR,
                                        name, "streamChatCompletionWithFunctions", errorMsg));
                                    return;
                                }

                                processEvent(event);

                            } catch (Exception e) {
                                handler.onError(new APIProviderException(
                                    APIProviderException.ErrorCategory.RESPONSE_ERROR,
                                    name, "streamChatCompletionWithFunctions",
                                    "Failed to parse streaming event: " + e.getMessage()));
                                return;
                            }
                        }
                    }

                    if (isCancelled) {
                        handler.onError(new APIProviderException(
                            APIProviderException.ErrorCategory.CANCELLED,
                            name, "streamChatCompletionWithFunctions", "Request cancelled"));
                    } else {
                        processStreamComplete();
                    }
                }
            }

            private void processEvent(JsonObject event) {
                String eventType = event.get("type").getAsString();

                switch (eventType) {
                    case "content_block_start":
                        handleContentBlockStart(event);
                        break;
                    case "content_block_delta":
                        handleContentBlockDelta(event);
                        break;
                    case "message_delta":
                        handleMessageDelta(event);
                        break;
                    case "message_stop":
                        // Final event - will be handled after loop exits
                        break;
                }
            }

            private void handleContentBlockStart(JsonObject event) {
                int index = event.get("index").getAsInt();
                JsonObject contentBlock = event.getAsJsonObject("content_block");
                String type = contentBlock.get("type").getAsString();

                ContentBlock block = new ContentBlock(index, type);

                // If tool_use, extract id and name
                if ("tool_use".equals(type)) {
                    block.toolId = contentBlock.get("id").getAsString();
                    block.toolName = contentBlock.get("name").getAsString();
                }

                contentBlocks.put(index, block);
            }

            private void handleContentBlockDelta(JsonObject event) {
                int index = event.get("index").getAsInt();
                ContentBlock block = contentBlocks.get(index);
                if (block == null) return;

                JsonObject delta = event.getAsJsonObject("delta");

                if ("text".equals(block.type) && delta.has("text")) {
                    // Stream text immediately
                    String textDelta = delta.get("text").getAsString();
                    block.textBuffer.append(textDelta);
                    handler.onTextUpdate(textDelta);

                } else if ("tool_use".equals(block.type) && delta.has("partial_json")) {
                    // Buffer tool input deltas
                    String inputDelta = delta.get("partial_json").getAsString();
                    block.inputBuffer.append(inputDelta);

                } else if ("thinking".equals(block.type) && delta.has("thinking")) {
                    // Buffer thinking content (don't stream to UI)
                    // Store for potential future "Show Thinking" feature
                    String thinkingDelta = delta.get("thinking").getAsString();
                    block.textBuffer.append(thinkingDelta);
                    // Note: We intentionally don't call handler.onTextUpdate() for thinking blocks

                } else if ("thinking".equals(block.type) && delta.has("signature")) {
                    // Buffer signature for thinking blocks
                    String signatureDelta = delta.get("signature").getAsString();
                    block.signatureBuffer.append(signatureDelta);
                }
            }

            private void handleMessageDelta(JsonObject event) {
                JsonObject delta = event.getAsJsonObject("delta");
                if (delta.has("stop_reason")) {
                    stopReason = delta.get("stop_reason").getAsString();
                }
            }

            private void processStreamComplete() {
                // Extract full text from text blocks
                String fullText = contentBlocks.values().stream()
                    .filter(b -> "text".equals(b.type))
                    .sorted((a, b) -> Integer.compare(a.index, b.index))
                    .map(b -> b.textBuffer.toString())
                    .collect(java.util.stream.Collectors.joining());

                // Extract thinking content and signature from thinking blocks
                String thinkingContent = contentBlocks.values().stream()
                    .filter(b -> "thinking".equals(b.type))
                    .sorted((a, b) -> Integer.compare(a.index, b.index))
                    .map(b -> b.textBuffer.toString())
                    .collect(java.util.stream.Collectors.joining());

                String thinkingSignature = contentBlocks.values().stream()
                    .filter(b -> "thinking".equals(b.type))
                    .sorted((a, b) -> Integer.compare(a.index, b.index))
                    .map(b -> b.signatureBuffer.toString())
                    .collect(java.util.stream.Collectors.joining());

                // Parse tool calls from tool_use blocks
                List<ToolCall> toolCalls = new ArrayList<>();
                for (ContentBlock block : contentBlocks.values()) {
                    if ("tool_use".equals(block.type)) {
                        String arguments = block.inputBuffer.toString().trim();

                        // Ensure we have valid arguments (not empty)
                        // If empty, use empty object as default
                        if (arguments.isEmpty()) {
                            arguments = "{}";
                        }

                        toolCalls.add(new ToolCall(
                            block.toolId,
                            block.toolName,
                            arguments
                        ));
                    }
                }

                // Sort tool calls by index
                toolCalls.sort((a, b) -> {
                    int indexA = contentBlocks.values().stream()
                        .filter(cb -> cb.toolId != null && cb.toolId.equals(a.id))
                        .findFirst()
                        .map(cb -> cb.index)
                        .orElse(0);
                    int indexB = contentBlocks.values().stream()
                        .filter(cb -> cb.toolId != null && cb.toolId.equals(b.id))
                        .findFirst()
                        .map(cb -> cb.index)
                        .orElse(0);
                    return Integer.compare(indexA, indexB);
                });

                // Callback with complete data including thinking content and signature
                handler.onStreamComplete(
                    stopReason != null ? stopReason : "end_turn",
                    fullText,
                    thinkingContent.isEmpty() ? null : thinkingContent,
                    thinkingSignature.isEmpty() ? null : thinkingSignature,
                    toolCalls
                );
            }
        });
    }

    @Override
    public List<String> getAvailableModels() throws APIProviderException {
        Request request = new Request.Builder()
            .url(url + ANTHROPIC_MODELS_ENDPOINT)
            .build();

        try (Response response = executeWithRetry(request, "getAvailableModels")) {
            JsonObject responseObj = gson.fromJson(response.body().string(), JsonObject.class);
            List<String> modelIds = new ArrayList<>();
            JsonArray models = responseObj.getAsJsonArray("models");
            
            for (JsonElement model : models) {
                modelIds.add(model.getAsJsonObject().get("id").getAsString());
            }
            
            return modelIds;
        } catch (IOException e) {
            throw handleNetworkError(e, "getAvailableModels");
        }
    }

    @Override
    public void getEmbeddingsAsync(String text, EmbeddingCallback callback) {
        // Anthropic does not currently provide a public embeddings endpoint
        callback.onError(new UnsupportedOperationException("Embeddings are not supported by the Anthropic API"));
    }

    private JsonObject buildMessagesPayload(List<ChatMessage> messages, boolean stream) {
        JsonObject payload = new JsonObject();
        payload.addProperty("model", super.getModel());
        payload.addProperty("max_tokens", super.getMaxTokens());
        //payload.addProperty("max_tokens", 64000);
        payload.addProperty("stream", stream);

        // Check if thinking can be enabled - all assistant messages must have valid thinking data
        // Anthropic requires that when thinking is enabled, ALL assistant messages MUST start with
        // a thinking block. If any assistant message lacks thinking data (e.g., old conversations
        // before thinking persistence was implemented), we must disable thinking for this request.
        ReasoningConfig reasoning = getReasoningConfig();
        boolean canEnableThinking = reasoning != null && reasoning.isEnabled();

        if (canEnableThinking) {
            // Scan messages to check if all assistant messages have valid thinking data
            for (ChatMessage message : messages) {
                if (message.getRole().equals(ChatMessage.ChatMessageRole.ASSISTANT)) {
                    String thinkingContent = message.getThinkingContent();
                    String thinkingSignature = message.getThinkingSignature();

                    // If ANY assistant message lacks valid thinking data, we cannot use thinking
                    if (thinkingContent == null || thinkingContent.isEmpty() ||
                        thinkingSignature == null || thinkingSignature.isEmpty()) {
                        Msg.debug(this, "Disabling thinking for this request - an assistant message " +
                            "lacks valid thinking content/signature (may be from older conversation)");
                        canEnableThinking = false;
                        break;
                    }
                }
            }
        }

        if (canEnableThinking) {
            int budget = reasoning.getAnthropicBudget();
            // Ensure budget_tokens is less than max_tokens
            Integer maxTokens = super.getMaxTokens();
            if (maxTokens != null && budget >= maxTokens) {
                budget = Math.max(1024, maxTokens - 1000);
            }
            JsonObject thinking = new JsonObject();
            thinking.addProperty("type", "enabled");
            thinking.addProperty("budget_tokens", budget);
            payload.add("thinking", thinking);
        }

        // Convert the messages to Anthropic's format
        JsonArray messagesArray = new JsonArray();
        for (ChatMessage message : messages) {
            if (message.getRole().equals(ChatMessage.ChatMessageRole.SYSTEM)) {
                payload.addProperty("system", message.getContent());
            } else {
                JsonObject messageObj = new JsonObject();
                messageObj.addProperty("role", convertRole(message.getRole()));
                
                // Handle different message types for Anthropic format
                if (message.getRole().equals(ChatMessage.ChatMessageRole.TOOL)) {
                    // Tool result message - use tool_result content block
                    JsonArray contentArray = new JsonArray();
                    JsonObject toolResultBlock = new JsonObject();
                    toolResultBlock.addProperty("type", "tool_result");
                    toolResultBlock.addProperty("tool_use_id", message.getToolCallId());
                    toolResultBlock.addProperty("content", message.getContent());
                    
                    contentArray.add(toolResultBlock);
                    messageObj.add("content", contentArray);
                } else if (message.getToolCalls() != null) {
                    // Assistant message with tool calls - need to convert to content blocks
                    JsonArray contentArray = new JsonArray();

                    // When thinking is enabled AND valid for all messages (canEnableThinking),
                    // include thinking blocks from the original API response.
                    if (canEnableThinking) {
                        String thinkingContent = message.getThinkingContent();
                        String thinkingSignature = message.getThinkingSignature();

                        // We already verified all messages have valid thinking data in the pre-check,
                        // so we can safely add the thinking block here
                        if (thinkingContent != null && !thinkingContent.isEmpty() &&
                            thinkingSignature != null && !thinkingSignature.isEmpty()) {
                            JsonObject thinkingBlock = new JsonObject();
                            thinkingBlock.addProperty("type", "thinking");
                            thinkingBlock.addProperty("thinking", thinkingContent);
                            thinkingBlock.addProperty("signature", thinkingSignature);
                            contentArray.add(thinkingBlock);
                        }
                    }

                    // Add text content if present
                    if (message.getContent() != null && !message.getContent().isEmpty()) {
                        JsonObject textBlock = new JsonObject();
                        textBlock.addProperty("type", "text");
                        textBlock.addProperty("text", message.getContent());
                        contentArray.add(textBlock);
                    }
                    
                    // Convert tool_calls to tool_use blocks
                    JsonArray toolCalls = message.getToolCalls();
                    for (JsonElement toolCallElement : toolCalls) {
                        JsonObject toolCall = toolCallElement.getAsJsonObject();
                        JsonObject function = toolCall.getAsJsonObject("function");
                        
                        JsonObject toolUseBlock = new JsonObject();
                        toolUseBlock.addProperty("type", "tool_use");
                        toolUseBlock.addProperty("id", toolCall.get("id").getAsString());
                        toolUseBlock.addProperty("name", function.get("name").getAsString());

                        // Parse arguments JSON string back to object
                        try {
                            JsonElement argumentsElement = function.get("arguments");
                            if (argumentsElement != null && !argumentsElement.isJsonNull()) {
                                String argumentsStr = argumentsElement.getAsString();
                                if (argumentsStr != null && !argumentsStr.trim().isEmpty()) {
                                    JsonElement arguments = gson.fromJson(argumentsStr, JsonElement.class);
                                    toolUseBlock.add("input", arguments);
                                } else {
                                    // Empty arguments string, use empty object
                                    toolUseBlock.add("input", new JsonObject());
                                }
                            } else {
                                // No arguments field, use empty object
                                toolUseBlock.add("input", new JsonObject());
                            }
                        } catch (Exception e) {
                            // If parsing fails, use empty object
                            System.err.println("AnthropicPlatformApiProvider: Failed to parse tool arguments: " + e.getMessage());
                            toolUseBlock.add("input", new JsonObject());
                        }
                        
                        contentArray.add(toolUseBlock);
                    }
                    
                    messageObj.add("content", contentArray);
                } else {
                    // Regular text message - ensure content is not null or empty
                    String content = message.getContent();
                    if (content == null || content.trim().isEmpty()) {
                        // Skip messages with empty content (Anthropic rejects them)
                        // This can happen on first load or with malformed conversation history
                        Msg.debug(this, "Skipping message with empty content, role=" + message.getRole());
                        continue;
                    }
                    messageObj.addProperty("content", content);
                }

                messagesArray.add(messageObj);
            }
        }
        payload.add("messages", messagesArray);

        return payload;
    }

    private String convertRole(String role) {
        switch (role) {
            case ChatMessage.ChatMessageRole.USER:
                return "user";
            case ChatMessage.ChatMessageRole.ASSISTANT:
                return "assistant";
            case ChatMessage.ChatMessageRole.FUNCTION:
                return "assistant"; // Anthropic doesn't have function messages, treat as assistant
            case ChatMessage.ChatMessageRole.TOOL:
                return "user"; // Tool results are sent as user messages in Anthropic
            default:
                return role;
        }
    }

    /**
     * Callback interface for streaming function calling responses.
     * Allows text content to stream immediately while buffering tool calls.
     */
    public interface StreamingFunctionHandler {
        /**
         * Called when a text delta arrives during streaming.
         * @param textDelta The incremental text content
         */
        void onTextUpdate(String textDelta);

        /**
         * Called when streaming completes with all content blocks processed.
         * @param stopReason The reason streaming stopped ("end_turn" or "tool_use")
         * @param fullText Complete text content from all text blocks
         * @param thinkingContent Complete thinking/reasoning content (may be null)
         * @param thinkingSignature Thinking signature for verification (may be null)
         * @param toolCalls List of tool calls to execute (may be empty)
         */
        void onStreamComplete(String stopReason, String fullText, String thinkingContent, String thinkingSignature, List<ToolCall> toolCalls);

        /**
         * Called if an error occurs during streaming.
         * @param error The error that occurred
         */
        void onError(Throwable error);

        /**
         * Check if streaming should continue.
         * @return true if streaming should continue, false to cancel
         */
        boolean shouldContinue();
    }

    /**
     * Represents a tool call extracted from streaming response.
     */
    public static class ToolCall {
        public final String id;
        public final String name;
        public final String arguments;

        public ToolCall(String id, String name, String arguments) {
            this.id = id;
            this.name = name;
            this.arguments = arguments;
        }
    }

    /**
     * Helper class to track content blocks during streaming.
     */
    private static class ContentBlock {
        final int index;
        final String type;
        final StringBuilder textBuffer = new StringBuilder();
        final StringBuilder signatureBuffer = new StringBuilder();  // For thinking signatures

        // For tool_use blocks
        String toolId;
        String toolName;
        final StringBuilder inputBuffer = new StringBuilder();

        ContentBlock(int index, String type) {
            this.index = index;
            this.type = type;
        }
    }

    public void cancelRequest() {
        isCancelled = true;
    }
}
```

`src/main/java/ghidrassist/apiprovider/AzureOpenAIProvider.java`:

```java
package ghidrassist.apiprovider;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.JsonSyntaxException;

import ghidrassist.LlmApi;
import ghidrassist.apiprovider.exceptions.*;
import ghidrassist.apiprovider.capabilities.FunctionCallingProvider;
import ghidrassist.apiprovider.capabilities.ModelListProvider;
import ghidrassist.apiprovider.capabilities.EmbeddingProvider;
import okhttp3.*;
import okio.BufferedSource;
import javax.net.ssl.*;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class AzureOpenAIProvider extends APIProvider
        implements FunctionCallingProvider, ModelListProvider, EmbeddingProvider {
    private static final Gson gson = new Gson();
    private static final MediaType JSON = MediaType.get("application/json; charset=utf-8");
    private static final String AZURE_API_VERSION = "2025-01-01-preview";
    private static final String AZURE_EMBEDDING_MODEL = "text-embedding-ada-002";

    // Retry settings for streaming calls
    private static final int MAX_STREAMING_RETRIES = 10;
    private static final int MIN_RETRY_BACKOFF_MS = 10000;  // 10 seconds
    private static final int MAX_RETRY_BACKOFF_MS = 30000;  // 30 seconds

    private volatile boolean isCancelled = false;

    // Azure OpenAI requires a deployment name
    private String deploymentName;

    public AzureOpenAIProvider(String name, String model, Integer maxTokens, String url, String key,
            boolean disableTlsVerification, Integer timeout) {
        super(name, ProviderType.AZURE_OPENAI, model, maxTokens, url, key, disableTlsVerification, timeout);

        // Extract deployment name from model if it contains a deployment name
        // Format: deploymentName or deploymentName:modelName
        if (model != null && model.contains(":")) {
            String[] parts = model.split(":", 2);
            this.deploymentName = parts[0];
            this.model = parts[1]; // Use the actual model name
        } else {
            this.deploymentName = model; // Use model as deployment name
        }
    }

    public static AzureOpenAIProvider fromConfig(APIProviderConfig config) {
        return new AzureOpenAIProvider(
                config.getName(),
                config.getModel(),
                config.getMaxTokens(),
                config.getUrl(),
                config.getKey(),
                config.isDisableTlsVerification(),
                config.getTimeout());
    }

    @Override
    protected OkHttpClient buildClient() {
        try {
            OkHttpClient.Builder builder = new OkHttpClient.Builder()
                    .connectTimeout(super.timeout)
                    .readTimeout(super.timeout)
                    .writeTimeout(super.timeout)
                    .retryOnConnectionFailure(true)
                    .addInterceptor(chain -> {
                        Request originalRequest = chain.request();

                        // Add Azure OpenAI specific headers
                        Request.Builder requestBuilder = originalRequest.newBuilder()
                                .header("api-key", super.key)
                                .header("Content-Type", "application/json");

                        return chain.proceed(requestBuilder.build());
                    });

            if (disableTlsVerification) {
                // Create a trust manager that does not validate certificate chains
                final TrustManager[] trustAllCerts = new TrustManager[] {
                        new X509TrustManager() {
                            @Override
                            public void checkClientTrusted(java.security.cert.X509Certificate[] chain,
                                    String authType) {
                            }

                            @Override
                            public void checkServerTrusted(java.security.cert.X509Certificate[] chain,
                                    String authType) {
                            }

                            @Override
                            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                                return new java.security.cert.X509Certificate[] {};
                            }
                        }
                };

                // Install the all-trusting trust manager
                final SSLContext sslContext = SSLContext.getInstance("SSL");
                sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
                final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();

                builder.sslSocketFactory(sslSocketFactory, (X509TrustManager) trustAllCerts[0]);
                builder.hostnameVerifier((hostname, session) -> true);
            }

            return builder.build();
        } catch (Exception e) {
            throw new RuntimeException("Failed to build Azure OpenAI HTTP client: " + e.getMessage(), e);
        }
    }

    @Override
    public String createChatCompletion(List<ChatMessage> messages) throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, false);

        String endpoint = buildChatCompletionUrl();
        Request request = new Request.Builder()
                .url(endpoint)
                .post(RequestBody.create(gson.toJson(payload), JSON))
                .build();

        try (Response response = executeWithRetry(request, "createChatCompletion")) {
            String responseBody = response.body().string();
            try {
                JsonObject responseObj = gson.fromJson(responseBody, JsonObject.class);
                return extractContentFromResponse(responseObj);
            } catch (JsonSyntaxException e) {
                throw new ResponseException(name, "createChatCompletion",
                        ResponseException.ResponseErrorType.MALFORMED_JSON, e);
            }
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletion");
        }
    }

    @Override
    public void streamChatCompletion(List<ChatMessage> messages, LlmApi.LlmResponseHandler handler)
            throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, true);
        executeStreamingWithRetry(payload, handler, "stream_chat_completion", 0);
    }

    /**
     * Execute streaming request with retry logic for rate limits and transient errors.
     */
    private void executeStreamingWithRetry(JsonObject payload, LlmApi.LlmResponseHandler handler,
                                           String operation, int attemptNumber) {
        if (isCancelled) {
            handler.onError(new StreamCancelledException(name, operation,
                StreamCancelledException.CancellationReason.USER_REQUESTED));
            return;
        }

        String endpoint = buildChatCompletionUrl();
        Request request = new Request.Builder()
                .url(endpoint)
                .post(RequestBody.create(gson.toJson(payload), JSON))
                .build();

        client.newCall(request).enqueue(new Callback() {
            private boolean isFirst = true;

            @Override
            public void onFailure(Call call, IOException e) {
                if (call.isCanceled()) {
                    handler.onError(new StreamCancelledException(name, operation,
                        StreamCancelledException.CancellationReason.USER_REQUESTED, e));
                    return;
                }

                APIProviderException error = handleNetworkError(e, operation);
                if (shouldRetryStreaming(error, attemptNumber)) {
                    retryStreamingAfterDelay(payload, handler, operation, attemptNumber, error);
                } else {
                    handler.onError(error);
                }
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                if (!response.isSuccessful()) {
                    APIProviderException error = handleHttpError(response, operation);
                    if (shouldRetryStreaming(error, attemptNumber)) {
                        retryStreamingAfterDelay(payload, handler, operation, attemptNumber, error);
                    } else {
                        handler.onError(error);
                    }
                    return;
                }

                try (BufferedSource source = response.body().source()) {
                    StringBuilder contentBuilder = new StringBuilder();

                    while (!source.exhausted() && !isCancelled && handler.shouldContinue()) {
                        String line = source.readUtf8Line();
                        if (line == null || line.isEmpty())
                            continue;

                        if (line.startsWith("data: ")) {
                            String data = line.substring(6).trim();
                            if (data.equals("[DONE]")) {
                                handler.onComplete(contentBuilder.toString());
                                return;
                            }

                            try {
                                JsonObject chunk = gson.fromJson(data, JsonObject.class);
                                String content = extractDeltaContent(chunk);
                                if (content != null) {
                                    if (isFirst) {
                                        handler.onStart();
                                        isFirst = false;
                                    }
                                    contentBuilder.append(content);
                                    handler.onUpdate(content);
                                }
                            } catch (JsonSyntaxException e) {
                                handler.onError(new ResponseException(name, operation,
                                        ResponseException.ResponseErrorType.MALFORMED_JSON, e));
                                return;
                            }
                        }
                    }

                    if (isCancelled) {
                        handler.onError(new StreamCancelledException(name, operation,
                                StreamCancelledException.CancellationReason.USER_REQUESTED));
                    } else if (!handler.shouldContinue()) {
                        handler.onError(new StreamCancelledException(name, operation,
                                StreamCancelledException.CancellationReason.USER_REQUESTED));
                    } else {
                        handler.onComplete(contentBuilder.toString());
                    }
                } catch (IOException e) {
                    if (!isCancelled) {
                        handler.onError(handleNetworkError(e, operation));
                    }
                }
            }
        });
    }

    /**
     * Check if a streaming error should be retried.
     */
    private boolean shouldRetryStreaming(APIProviderException error, int attemptNumber) {
        if (attemptNumber >= MAX_STREAMING_RETRIES) {
            return false;
        }
        switch (error.getCategory()) {
            case RATE_LIMIT:
            case NETWORK:
            case TIMEOUT:
            case SERVICE_ERROR:
                return true;
            default:
                return false;
        }
    }

    /**
     * Retry streaming request after appropriate delay.
     */
    private void retryStreamingAfterDelay(JsonObject payload, LlmApi.LlmResponseHandler handler,
                                          String operation, int attemptNumber, APIProviderException error) {
        int nextAttempt = attemptNumber + 1;
        int waitTimeMs = calculateStreamingRetryWait(error);

        ghidra.util.Msg.warn(this, String.format("Streaming retry %d/%d for %s: %s. Waiting %d seconds...",
            nextAttempt, MAX_STREAMING_RETRIES, operation,
            error.getCategory().getDisplayName(), waitTimeMs / 1000));

        new Thread(() -> {
            try {
                Thread.sleep(waitTimeMs);
                if (!isCancelled) {
                    executeStreamingWithRetry(payload, handler, operation, nextAttempt);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                handler.onError(new StreamCancelledException(name, operation,
                    StreamCancelledException.CancellationReason.USER_REQUESTED));
            }
        }, "AzureOpenAIProvider-StreamRetry").start();
    }

    /**
     * Calculate wait time for streaming retry with jitter.
     */
    private int calculateStreamingRetryWait(APIProviderException error) {
        if (error.getCategory() == APIProviderException.ErrorCategory.RATE_LIMIT) {
            Integer retryAfter = error.getRetryAfterSeconds();
            if (retryAfter != null && retryAfter > 0) {
                return retryAfter * 1000;
            }
        }
        return MIN_RETRY_BACKOFF_MS + (int) (Math.random() * (MAX_RETRY_BACKOFF_MS - MIN_RETRY_BACKOFF_MS));
    }

    @Override
    public String createChatCompletionWithFunctionsFullResponse(List<ChatMessage> messages,
            List<Map<String, Object>> functions) throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, false);

        // Add tools (functions) to the payload
        payload.add("tools", gson.toJsonTree(functions));

        String endpoint = buildChatCompletionUrl();
        Request request = new Request.Builder()
                .url(endpoint)
                .post(RequestBody.create(gson.toJson(payload), JSON))
                .build();

        try (Response response = executeWithRetry(request, "createChatCompletionWithFunctionsFullResponse")) {
            String responseBody = response.body().string();

            // Return the full response body as-is, including finish_reason
            return responseBody;

        } catch (IOException e) {
            throw new NetworkException(name, "createChatCompletionWithFunctionsFullResponse",
                    NetworkException.NetworkErrorType.CONNECTION_FAILED);
        }
    }

    @Override
    public String createChatCompletionWithFunctions(List<ChatMessage> messages, List<Map<String, Object>> functions)
            throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, false);

        // Add tools (functions) to the payload
        payload.add("tools", gson.toJsonTree(functions));

        // Force tool use - "required" means model must use at least one tool
        payload.addProperty("tool_choice", "required");

        String endpoint = buildChatCompletionUrl();
        Request request = new Request.Builder()
                .url(endpoint)
                .post(RequestBody.create(gson.toJson(payload), JSON))
                .build();

        try (Response response = executeWithRetry(request, "createChatCompletionWithFunctions")) {
            String responseBody = response.body().string();

            try {
                JsonObject responseObj = gson.fromJson(responseBody, JsonObject.class);

                // Extract message from response (Azure OpenAI follows standard format)
                JsonObject message = responseObj.getAsJsonArray("choices")
                        .get(0).getAsJsonObject()
                        .getAsJsonObject("message");

                // Check if tool_calls exists directly
                if (message.has("tool_calls") && !message.get("tool_calls").isJsonNull()) {
                    return "{\"tool_calls\":" + message.get("tool_calls").toString() + "}";
                }

                // If no tool_calls, check if content contains a JSON object (fallback for edge
                // cases)
                if (message.has("content") && !message.get("content").isJsonNull()) {
                    String content = message.get("content").getAsString().trim();

                    // Try to parse content as JSON if it looks like JSON
                    if (content.startsWith("{") || content.startsWith("[")) {
                        try {
                            JsonElement contentJson = JsonParser.parseString(content);

                            // Case 1: Content is already a tool_calls object
                            if (contentJson.isJsonObject() && contentJson.getAsJsonObject().has("tool_calls")) {
                                return content;
                            }

                            // Case 2: Content is a single function call
                            if (contentJson.isJsonObject()) {
                                JsonObject funcObj = contentJson.getAsJsonObject();
                                if (funcObj.has("name") && funcObj.has("arguments")) {
                                    JsonArray toolCalls = new JsonArray();
                                    JsonObject toolCall = new JsonObject();
                                    toolCall.addProperty("id", "call_" + System.currentTimeMillis());
                                    toolCall.addProperty("type", "function");

                                    JsonObject function = new JsonObject();
                                    function.add("name", funcObj.get("name"));
                                    function.add("arguments", funcObj.get("arguments"));
                                    toolCall.add("function", function);
                                    toolCalls.add(toolCall);

                                    return "{\"tool_calls\":" + toolCalls.toString() + "}";
                                }
                            }
                        } catch (JsonSyntaxException e) {
                            // Content is not valid JSON, fall through
                        }
                    }
                }

                // No valid tool calls found
                return "{\"tool_calls\":[]}";

            } catch (JsonSyntaxException e) {
                throw new ResponseException(name, "createChatCompletionWithFunctions",
                        ResponseException.ResponseErrorType.MALFORMED_JSON, e);
            }
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletionWithFunctions");
        }
    }

    @Override
    public List<String> getAvailableModels() throws APIProviderException {
        String endpoint = buildModelsUrl();
        Request request = new Request.Builder()
                .url(endpoint)
                .build();

        try (Response response = executeWithRetry(request, "getAvailableModels")) {
            String responseBody = response.body().string();
            try {
                JsonObject responseObj = gson.fromJson(responseBody, JsonObject.class);
                JsonArray modelsArray = responseObj.getAsJsonArray("data");

                List<String> models = new ArrayList<>();
                for (JsonElement element : modelsArray) {
                    JsonObject modelObj = element.getAsJsonObject();
                    models.add(modelObj.get("id").getAsString());
                }
                return models;
            } catch (JsonSyntaxException e) {
                throw new ResponseException(name, "getAvailableModels",
                        ResponseException.ResponseErrorType.MALFORMED_JSON, e);
            }
        } catch (IOException e) {
            throw handleNetworkError(e, "getAvailableModels");
        }
    }

    @Override
    public void getEmbeddingsAsync(String text, EmbeddingCallback callback) {
        JsonObject payload = new JsonObject();
        payload.addProperty("input", text);
        executeEmbeddingsWithRetry(payload, callback, "get_embeddings", 0);
    }

    /**
     * Execute embeddings request with retry logic for rate limits and transient errors.
     */
    private void executeEmbeddingsWithRetry(JsonObject payload, EmbeddingCallback callback,
                                            String operation, int attemptNumber) {
        if (isCancelled) {
            callback.onError(new StreamCancelledException(name, operation,
                StreamCancelledException.CancellationReason.USER_REQUESTED));
            return;
        }

        String endpoint = buildEmbeddingsUrl();
        Request request = new Request.Builder()
                .url(endpoint)
                .post(RequestBody.create(gson.toJson(payload), JSON))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                if (call.isCanceled()) {
                    callback.onError(new StreamCancelledException(name, operation,
                        StreamCancelledException.CancellationReason.USER_REQUESTED, e));
                    return;
                }

                APIProviderException error = handleNetworkError(e, operation);
                if (shouldRetryStreaming(error, attemptNumber)) {
                    retryEmbeddingsAfterDelay(payload, callback, operation, attemptNumber, error);
                } else {
                    callback.onError(error);
                }
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                if (!response.isSuccessful()) {
                    APIProviderException error = handleHttpError(response, operation);
                    if (shouldRetryStreaming(error, attemptNumber)) {
                        retryEmbeddingsAfterDelay(payload, callback, operation, attemptNumber, error);
                    } else {
                        callback.onError(error);
                    }
                    return;
                }

                try {
                    String responseBody = response.body().string();
                    JsonObject responseObj = gson.fromJson(responseBody, JsonObject.class);
                    JsonArray dataArray = responseObj.getAsJsonArray("data");

                    if (dataArray.size() > 0) {
                        JsonArray embeddingArray = dataArray.get(0).getAsJsonObject().getAsJsonArray("embedding");
                        double[] embedding = new double[embeddingArray.size()];

                        for (int i = 0; i < embeddingArray.size(); i++) {
                            embedding[i] = embeddingArray.get(i).getAsDouble();
                        }

                        callback.onSuccess(embedding);
                    } else {
                        callback.onError(new ResponseException(name, operation,
                                ResponseException.ResponseErrorType.EMPTY_RESPONSE));
                    }
                } catch (JsonSyntaxException e) {
                    callback.onError(new ResponseException(name, operation,
                            ResponseException.ResponseErrorType.MALFORMED_JSON, e));
                }
            }
        });
    }

    /**
     * Retry embeddings request after appropriate delay.
     */
    private void retryEmbeddingsAfterDelay(JsonObject payload, EmbeddingCallback callback,
                                           String operation, int attemptNumber, APIProviderException error) {
        int nextAttempt = attemptNumber + 1;
        int waitTimeMs = calculateStreamingRetryWait(error);

        ghidra.util.Msg.warn(this, String.format("Embeddings retry %d/%d for %s: %s. Waiting %d seconds...",
            nextAttempt, MAX_STREAMING_RETRIES, operation,
            error.getCategory().getDisplayName(), waitTimeMs / 1000));

        new Thread(() -> {
            try {
                Thread.sleep(waitTimeMs);
                if (!isCancelled) {
                    executeEmbeddingsWithRetry(payload, callback, operation, nextAttempt);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                callback.onError(new StreamCancelledException(name, operation,
                    StreamCancelledException.CancellationReason.USER_REQUESTED));
            }
        }, "AzureOpenAIProvider-EmbeddingsRetry").start();
    }

    private String buildChatCompletionUrl() {
        return String.format("%sopenai/deployments/%s/chat/completions?api-version=%s",
                url, deploymentName, AZURE_API_VERSION);
    }

    private String buildModelsUrl() {
        return String.format("%sopenai/models?api-version=%s", url, AZURE_API_VERSION);
    }

    private String buildEmbeddingsUrl() {
        return String.format("%sopenai/deployments/%s/embeddings?api-version=%s",
                url, AZURE_EMBEDDING_MODEL, AZURE_API_VERSION);
    }

    private JsonObject buildChatCompletionPayload(List<ChatMessage> messages, boolean stream) {
        JsonObject payload = new JsonObject();

        // Handle different token field names based on model
        String modelName = super.getModel();
        if (modelName != null
                && (modelName.startsWith("o1-") || modelName.startsWith("o3-") || modelName.startsWith("o4-") || modelName.startsWith("gpt-5"))) {
            payload.addProperty("max_completion_tokens", super.getMaxTokens());
        } else {
            payload.addProperty("max_tokens", super.getMaxTokens());
        }

        payload.addProperty("stream", stream);

        // Add reasoning_effort if configured
        ReasoningConfig reasoning = getReasoningConfig();
        if (reasoning != null && reasoning.isEnabled()) {
            payload.addProperty("reasoning_effort", reasoning.getEffortString());
        }

        JsonArray messagesArray = new JsonArray();
        for (ChatMessage message : messages) {
            JsonObject messageObj = new JsonObject();
            messageObj.addProperty("role", message.getRole());

            // Handle content (can be null for tool calling assistant messages)
            if (message.getContent() != null) {
                messageObj.addProperty("content", message.getContent());
            }

            // Handle tool calls for assistant messages
            if (message.getToolCalls() != null) {
                messageObj.add("tool_calls", gson.toJsonTree(message.getToolCalls()));
            }

            // Handle tool call ID for tool response messages
            if (message.getToolCallId() != null) {
                messageObj.addProperty("tool_call_id", message.getToolCallId());
            }

            messagesArray.add(messageObj);
        }
        payload.add("messages", messagesArray);

        return payload;
    }

    private String extractContentFromResponse(JsonObject responseObj) {
        JsonObject message = responseObj.getAsJsonArray("choices")
                .get(0).getAsJsonObject()
                .getAsJsonObject("message");

        // Check if content exists and is not null
        if (message.has("content") && !message.get("content").isJsonNull()) {
            return message.get("content").getAsString();
        }

        // If no content, this might be a tool call response
        // Return empty string or handle tool calls appropriately
        return "";
    }

    private String extractDeltaContent(JsonObject chunk) {
        try {
            JsonObject delta = chunk.getAsJsonArray("choices")
                    .get(0).getAsJsonObject()
                    .getAsJsonObject("delta");

            if (delta.has("content") && !delta.get("content").isJsonNull()) {
                return delta.get("content").getAsString();
            }
        } catch (Exception e) {
            // Handle any JSON parsing errors silently and return null
        }
        return null;
    }

    public void cancelRequest() {
        isCancelled = true;
    }

    @Override
    protected String extractApiErrorCode(String responseBody) {
        if (responseBody == null || responseBody.isEmpty()) {
            return null;
        }

        try {
            JsonObject errorObj = gson.fromJson(responseBody, JsonObject.class);
            if (errorObj.has("error")) {
                JsonObject error = errorObj.getAsJsonObject("error");
                if (error.has("code")) {
                    JsonElement codeElement = error.get("code");
                    if (codeElement != null && !codeElement.isJsonNull()) {
                        return codeElement.getAsString();
                    }
                }
            }
        } catch (JsonSyntaxException e) {
            // Ignore parsing errors
        }

        return null;
    }

    @Override
    protected String extractErrorMessage(String responseBody, int statusCode) {
        if (responseBody == null || responseBody.isEmpty()) {
            return null;
        }

        try {
            JsonObject errorObj = gson.fromJson(responseBody, JsonObject.class);
            if (errorObj.has("error")) {
                JsonObject error = errorObj.getAsJsonObject("error");
                if (error.has("message")) {
                    JsonElement messageElement = error.get("message");
                    if (messageElement != null && !messageElement.isJsonNull()) {
                        return messageElement.getAsString();
                    }
                }
            }
        } catch (JsonSyntaxException e) {
            // Ignore parsing errors and fall back to parent implementation
        }

        // Fallback to parent implementation
        return super.extractErrorMessage(responseBody, statusCode);
    }

    @Override
    protected Integer extractRetryAfter(Response response, String responseBody) {
        // First check the parent implementation for standard headers
        Integer retryAfter = super.extractRetryAfter(response, responseBody);
        if (retryAfter != null) {
            return retryAfter;
        }

        // Check Azure OpenAI-specific retry information in response body
        if (responseBody != null) {
            try {
                JsonObject errorObj = gson.fromJson(responseBody, JsonObject.class);
                if (errorObj.has("error")) {
                    JsonObject error = errorObj.getAsJsonObject("error");
                    if (error.has("retry_after")) {
                        return error.get("retry_after").getAsInt();
                    }
                }
            } catch (Exception e) {
                // Ignore parsing errors
            }
        }

        return null;
    }
}

```

`src/main/java/ghidrassist/apiprovider/ChatMessage.java`:

```java
package ghidrassist.apiprovider;

import com.fasterxml.jackson.databind.JsonNode;
import com.google.gson.JsonArray;

public class ChatMessage {
    private String role;
    private String content;
    private FunctionCall functionCall;
    private JsonArray toolCalls;  // For assistant messages with tool calls
    private String toolCallId;   // For tool response messages
    private String thinkingContent;  // For storing thinking/reasoning content
    private String thinkingSignature;  // For storing thinking signature

    public ChatMessage(String role, String content) {
        this.role = role;
        this.content = content;
    }

    public String getRole() {
        return role;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public FunctionCall getFunctionCall() {
        return functionCall;
    }

    public void setFunctionCall(FunctionCall functionCall) {
        this.functionCall = functionCall;
    }

    public JsonArray getToolCalls() {
        return toolCalls;
    }

    public void setToolCalls(JsonArray toolCalls) {
        this.toolCalls = toolCalls;
    }

    public String getToolCallId() {
        return toolCallId;
    }

    public void setToolCallId(String toolCallId) {
        this.toolCallId = toolCallId;
    }

    public String getThinkingContent() {
        return thinkingContent;
    }

    public void setThinkingContent(String thinkingContent) {
        this.thinkingContent = thinkingContent;
    }

    public String getThinkingSignature() {
        return thinkingSignature;
    }

    public void setThinkingSignature(String thinkingSignature) {
        this.thinkingSignature = thinkingSignature;
    }

    public static class FunctionCall {
        private String name;
        private JsonNode arguments;

        public String getName() {
            return name;
        }

        public JsonNode getArguments() {
            return arguments;
        }
    }

    public static class ChatMessageRole {
        public static final String SYSTEM = "system";
        public static final String USER = "user";
        public static final String ASSISTANT = "assistant";
        public static final String FUNCTION = "function";
        public static final String TOOL = "tool";
    }
}
```

`src/main/java/ghidrassist/apiprovider/CodexInstructions.java`:

```java
package ghidrassist.apiprovider;

/**
 * Official Codex CLI instructions from openai/codex rust-v0.80.0.
 * 
 * CRITICAL: The Codex API validates that instructions match the official prompt.
 * Custom instructions will be rejected with "Instructions are not valid".
 * This prompt must be used verbatim.
 */
public final class CodexInstructions {
    
    private CodexInstructions() {
        // Utility class - prevent instantiation
    }
    
    /**
     * The official Codex CLI system instructions.
     * Source: https://github.com/openai/codex (rust-v0.80.0)
     */
    public static final String INSTRUCTIONS = """
You are Codex, based on GPT-5. You are running as a coding agent in the Codex CLI on a user's computer.

## General

- When searching for text or files, prefer using `rg` or `rg --files` respectively because `rg` is much faster than alternatives like `grep`. (If the `rg` command is not found, then use alternatives.)

## Editing constraints

- Default to ASCII when editing or creating files. Only introduce non-ASCII or other Unicode characters when there is a clear justification and the file already uses them.
- Add succinct code comments that explain what is going on if code is not self-explanatory. You should not add comments like "Assigns the value to the variable", but a brief comment might be useful ahead of a complex code block that the user would otherwise have to spend time parsing out. Usage of these comments should be rare.
- Try to use apply_patch for single file edits, but it is fine to explore other options to make the edit if it does not work well. Do not use apply_patch for changes that are auto-generated (i.e. generating package.json or running a lint or format command like gofmt) or when scripting is more efficient (such as search and replacing a string across a codebase).
- You may be in a dirty git worktree.
    * NEVER revert existing changes you did not make unless explicitly requested, since these changes were made by the user.
    * If asked to make a commit or code edits and there are unrelated changes to your work or changes that you didn't make in those files, don't revert those changes.
    * If the changes are in files you've touched recently, you should read carefully and understand how you can work with the changes rather than reverting them.
    * If the changes are in unrelated files, just ignore them and don't revert them.
- Do not amend a commit unless explicitly requested to do so.
- While you are working, you might notice unexpected changes that you didn't make. If this happens, STOP IMMEDIATELY and ask the user how they would like to proceed.
- **NEVER** use destructive commands like `git reset --hard` or `git checkout --` unless specifically requested or approved by the user.

## Plan tool

When using the planning tool:
- Skip using the planning tool for straightforward tasks (roughly the easiest 25%).
- Do not make single-step plans.
- When you made a plan, update it after having performed one of the sub-tasks that you shared on the plan.

## Codex CLI harness, sandboxing, and approvals

The Codex CLI harness supports several different configurations for sandboxing and escalation approvals that the user can choose from.

Filesystem sandboxing defines which files can be read or written. The options for `sandbox_mode` are:
- **read-only**: The sandbox only permits reading files.
- **workspace-write**: The sandbox permits reading files, and editing files in `cwd` and `writable_roots`. Editing files in other directories requires approval.
- **danger-full-access**: No filesystem sandboxing - all commands are permitted.

Network sandboxing defines whether network can be accessed without approval. Options for `network_access` are:
- **restricted**: Requires approval
- **enabled**: No approval needed

Approvals are your mechanism to get user consent to run shell commands without the sandbox. Possible configuration options for `approval_policy` are
- **untrusted**: The harness will escalate most commands for user approval, apart from a limited allowlist of safe "read" commands.
- **on-failure**: The harness will allow all commands to run in the sandbox (if enabled), and failures will be escalated to the user for approval to run again without the sandbox.
- **on-request**: Commands will be run in the sandbox by default, and you can specify in your tool call if you want to escalate a command to run without sandboxing. (Note that this mode is not always available. If it is, you'll see parameters for it in the `shell` command description.)
- **never**: This is a non-interactive mode where you may NEVER ask the user for approval to run commands. Instead, you must always persist and work around constraints to solve the task for the user. You MUST do your utmost best to finish the task and validate your work before yielding. If this mode is paired with `danger-full-access`, take advantage of it to deliver the best outcome for the user. Further, in this mode, your default testing philosophy is overridden: Even if you don't see local patterns for testing, you may add tests and scripts to validate your work. Just remove them before yielding.

When you are running with `approval_policy == on-request`, and sandboxing enabled, here are scenarios where you'll need to request approval:
- You need to run a command that writes to a directory that requires it (e.g. running tests that write to /var)
- You need to run a GUI app (e.g., open/xdg-open/osascript) to open browsers or files.
- You are running sandboxed and need to run a command that requires network access (e.g. installing packages)
- If you run a command that is important to solving the user's query, but it fails because of sandboxing, rerun the command with approval. ALWAYS proceed to use the `sandbox_permissions` and `justification` parameters - do not message the user before requesting approval for the command.
- You are about to take a potentially destructive action such as an `rm` or `git reset` that the user did not explicitly ask for
- (for all of these, you should weigh alternative paths that do not require approval)

When `sandbox_mode` is set to read-only, you'll need to request approval for any command that isn't a read.

You will be told what filesystem sandboxing, network sandboxing, and approval mode are active in a developer or user message. If you are not told about this, assume that you are running with workspace-write, network sandboxing enabled, and approval on-failure.

Although they introduce friction to the user because your work is paused until the user responds, you should leverage them when necessary to accomplish important work. If the completing the task requires escalated permissions, Do not let these settings or the sandbox deter you from attempting to accomplish the user's task unless it is set to "never", in which case never ask for approvals.

When requesting approval to execute a command that will require escalated privileges:
  - Provide the `sandbox_permissions` parameter with the value `"require_escalated"`
  - Include a short, 1 sentence explanation for why you need escalated permissions in the justification parameter

## Special user requests

- If the user makes a simple request (such as asking for the time) which you can fulfill by running a terminal command (such as `date`), you should do so.
- If the user asks for a "review", default to a code review mindset: prioritise identifying bugs, risks, behavioural regressions, and missing tests. Findings must be the primary focus of the response - keep summaries or overviews brief and only after enumerating the issues. Present findings first (ordered by severity with file/line references), follow with open questions or assumptions, and offer a change-summary only as a secondary detail. If no findings are discovered, state that explicitly and mention any residual risks or testing gaps.

## Presenting your work and final message

You are producing plain text that will later be styled by the CLI. Follow these rules exactly. Formatting should make results easy to scan, but not feel mechanical. Use judgment to decide how much structure adds value.

- Default: be very concise; friendly coding teammate tone.
- Ask only when needed; suggest ideas; mirror the user's style.
- For substantial work, summarize clearly; follow final-answer formatting.
- Skip heavy formatting for simple confirmations.
- Don't dump large files you've written; reference paths only.
- No "save/copy this file" - User is on the same machine.
- Offer logical next steps (tests, commits, build) briefly; add verify steps if you couldn't do something.
- For code changes:
  * Lead with a quick explanation of the change, and then give more details on the context covering where and why a change was made. Do not start this explanation with "summary", just jump right in.
  * If there are natural next steps the user may want to take, suggest them at the end of your response. Do not make suggestions if there are no natural next steps.
  * When suggesting multiple options, use numeric lists for the suggestions so the user can quickly respond with a single number.
- The user does not command execution outputs. When asked to show the output of a command (e.g. `git show`), relay the important details in your answer or summarize the key lines so the user understands the result.

### Final answer structure and style guidelines

- Plain text; CLI handles styling. Use structure only when it helps scanability.
- Headers: optional; short Title Case (1-3 words) wrapped in **...**; no blank line before the first bullet; add only if they truly help.
- Bullets: use - ; merge related points; keep to one line when possible; 4-6 per list ordered by importance; keep phrasing consistent.
- Monospace: backticks for commands/paths/env vars/code ids and inline examples; use for literal keyword bullets; never combine with **.
- Code samples or multi-line snippets should be wrapped in fenced code blocks; include an info string as often as possible.
- Structure: group related bullets; order sections general -> specific -> supporting; for subsections, start with a bolded keyword bullet, then items; match complexity to the task.
- Tone: collaborative, concise, factual; present tense, active voice; self-contained; no "above/below"; parallel wording.
- Don'ts: no nested bullets/hierarchies; no ANSI codes; don't cram unrelated keywords; keep keyword lists short-wrap/reformat if long; avoid naming formatting styles in answers.
- Adaptation: code explanations -> precise, structured with code refs; simple tasks -> lead with outcome; big changes -> logical walkthrough + rationale + next actions; casual one-offs -> plain sentences, no headers/bullets.
- File References: When referencing files in your response, make sure to include the relevant start line and always follow the below rules:
  * Use inline code to make file paths clickable.
  * Each reference should have a stand alone path. Even if it's the same file.
  * Accepted: absolute, workspace-relative, a/ or b/ diff prefixes, or bare filename/suffix.
  * Line/column (1-based, optional): :line[:column] or #Lline[Ccolumn] (column defaults to 1).
  * Do not use URIs like file://, vscode://, or https://.
  * Do not provide range of lines
  * Examples: src/app.ts, src/app.ts:42, b/server/index.js#L10, C:\\repo\\project\\main.rs:12:5
""";
}

```

`src/main/java/ghidrassist/apiprovider/ErrorAction.java`:

```java
package ghidrassist.apiprovider;

import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

/**
 * Represents an action that can be taken in response to an error
 */
public class ErrorAction {
    private final String actionText;
    private final String description;
    private final Runnable action;
    private final boolean isPrimary;
    
    public ErrorAction(String actionText, String description, Runnable action, boolean isPrimary) {
        this.actionText = actionText;
        this.description = description;
        this.action = action;
        this.isPrimary = isPrimary;
    }
    
    public ErrorAction(String actionText, Runnable action) {
        this(actionText, null, action, false);
    }
    
    // Getters
    public String getActionText() { return actionText; }
    public String getDescription() { return description; }
    public Runnable getAction() { return action; }
    public boolean isPrimary() { return isPrimary; }
    
    /**
     * Create a button for this action
     */
    public JButton createButton() {
        JButton button = new JButton(actionText);
        if (description != null) {
            button.setToolTipText(description);
        }
        button.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                if (action != null) {
                    try {
                        action.run();
                    } catch (Exception ex) {
                        // Log error but don't propagate to avoid cascading errors
                        System.err.println("Error executing action: " + ex.getMessage());
                    }
                }
            }
        });
        return button;
    }
    
    // Common action factory methods
    public static ErrorAction createSettingsAction(Runnable openSettingsAction) {
        return new ErrorAction(
            "Open Settings", 
            "Open the settings dialog to configure API providers",
            openSettingsAction, 
            true
        );
    }
    
    public static ErrorAction createRetryAction(Runnable retryAction) {
        return new ErrorAction(
            "Retry", 
            "Try the operation again",
            retryAction, 
            true
        );
    }
    
    public static ErrorAction createCopyErrorAction(String errorDetails) {
        return new ErrorAction(
            "Copy Details", 
            "Copy error details to clipboard",
            () -> copyToClipboard(errorDetails), 
            false
        );
    }
    
    public static ErrorAction createSwitchProviderAction(Runnable switchAction) {
        return new ErrorAction(
            "Switch Provider", 
            "Try using a different API provider",
            switchAction, 
            false
        );
    }
    
    public static ErrorAction createDismissAction() {
        return new ErrorAction(
            "Dismiss", 
            "Close this error dialog",
            () -> {}, // No-op, dialog will handle dismissal
            false
        );
    }
    
    private static void copyToClipboard(String text) {
        try {
            java.awt.datatransfer.StringSelection stringSelection = 
                new java.awt.datatransfer.StringSelection(text);
            java.awt.datatransfer.Clipboard clipboard = 
                java.awt.Toolkit.getDefaultToolkit().getSystemClipboard();
            clipboard.setContents(stringSelection, null);
        } catch (Exception e) {
            // Silently fail if clipboard is not available
        }
    }
}
```

`src/main/java/ghidrassist/apiprovider/ErrorMessageBuilder.java`:

```java
package ghidrassist.apiprovider;

import ghidrassist.apiprovider.exceptions.*;

/**
 * Builds user-friendly error messages from API provider exceptions
 */
public class ErrorMessageBuilder {
    
    /**
     * Build a user-friendly error message from an API provider exception
     */
    public static String buildUserMessage(APIProviderException e) {
        String baseMessage = buildBaseMessage(e);
        String suggestion = buildSuggestion(e);
        
        if (suggestion != null && !suggestion.isEmpty()) {
            return baseMessage + "\n\n" + suggestion;
        }
        
        return baseMessage;
    }
    
    /**
     * Build a short error message for status displays
     */
    public static String buildShortMessage(APIProviderException e) {
        return String.format("[%s] %s", e.getProviderName(), e.getCategory().getDisplayName());
    }
    
    private static String buildBaseMessage(APIProviderException e) {
        switch (e.getCategory()) {
            case AUTHENTICATION:
                return String.format("Authentication failed with %s. %s", 
                    e.getProviderName(), getAuthenticationDetails(e));
                    
            case NETWORK:
                return String.format("Connection failed to %s. %s", 
                    e.getProviderName(), getNetworkDetails(e));
                    
            case RATE_LIMIT:
                return String.format("Rate limit exceeded for %s. %s", 
                    e.getProviderName(), getRateLimitDetails(e));
                    
            case MODEL_ERROR:
                return String.format("Model error with %s. %s", 
                    e.getProviderName(), getModelDetails(e));
                    
            case CONFIGURATION:
                return String.format("Configuration error for %s. %s", 
                    e.getProviderName(), e.getMessage());
                    
            case RESPONSE_ERROR:
                return String.format("Invalid response from %s. %s", 
                    e.getProviderName(), getResponseDetails(e));
                    
            case SERVICE_ERROR:
                return String.format("Service error from %s. %s", 
                    e.getProviderName(), getServiceDetails(e));
                    
            case TIMEOUT:
                return String.format("Request to %s timed out. The operation took too long to complete.", 
                    e.getProviderName());
                    
            case CANCELLED:
                return String.format("Request to %s was cancelled. %s", 
                    e.getProviderName(), getCancellationDetails(e));
                    
            default:
                return String.format("Error with %s: %s", e.getProviderName(), e.getMessage());
        }
    }
    
    private static String buildSuggestion(APIProviderException e) {
        switch (e.getCategory()) {
            case AUTHENTICATION:
                return "Please check your API key in Settings. Verify the key is valid and has the necessary permissions.";
                
            case NETWORK:
                if (e instanceof NetworkException) {
                    NetworkException ne = (NetworkException) e;
                    if (ne.getNetworkErrorType() == NetworkException.NetworkErrorType.SSL_ERROR) {
                        return "Try enabling 'Disable TLS Verification' in Settings if using a local server.";
                    }
                }
                return "Check your internet connection and verify the API URL is correct.";
                
            case RATE_LIMIT:
                if (e.getRetryAfterSeconds() != null) {
                    return String.format("Please wait %d seconds before trying again, or consider switching to a different provider.", 
                        e.getRetryAfterSeconds());
                }
                return "Please wait a moment before trying again, or consider switching to a different provider.";
                
            case MODEL_ERROR:
                if (e instanceof ModelException) {
                    ModelException me = (ModelException) e;
                    if (me.getModelErrorType() == ModelException.ModelErrorType.MODEL_NOT_FOUND) {
                        return "Check that the model name is correct in Settings, or try a different model.";
                    } else if (me.getModelErrorType() == ModelException.ModelErrorType.CONTEXT_LENGTH_EXCEEDED) {
                        return "Try reducing the query length or use a model with a larger context window.";
                    }
                }
                return "Check your model settings and try a different model if available.";
                
            case CONFIGURATION:
                return "Please check your provider settings in the Settings dialog.";
                
            case RESPONSE_ERROR:
                return "This may be a temporary issue with the API. Try again in a moment.";
                
            case SERVICE_ERROR:
                return "The API service may be experiencing issues. Try again later or switch to a different provider.";
                
            case TIMEOUT:
                return "Try increasing the timeout value in Settings or check your connection speed.";
                
            case CANCELLED:
                return ""; // No suggestion needed for cancellations
                
            default:
                return "Please check your settings and try again.";
        }
    }
    
    private static String getAuthenticationDetails(APIProviderException e) {
        if (e.getHttpStatusCode() == 401) {
            return "Invalid or missing API key.";
        } else if (e.getHttpStatusCode() == 403) {
            return "API key does not have sufficient permissions.";
        }
        return e.getMessage() != null ? e.getMessage() : "Authentication failed.";
    }
    
    private static String getNetworkDetails(APIProviderException e) {
        if (e instanceof NetworkException) {
            NetworkException ne = (NetworkException) e;
            if (ne.getNetworkErrorType() != null) {
                return ne.getNetworkErrorType().getDescription();
            }
        }
        return e.getMessage() != null ? e.getMessage() : "Network connection failed.";
    }
    
    private static String getRateLimitDetails(APIProviderException e) {
        if (e.getRetryAfterSeconds() != null) {
            return String.format("Too many requests. Retry after %d seconds.", e.getRetryAfterSeconds());
        }
        return "Too many requests. Please wait before retrying.";
    }
    
    private static String getModelDetails(APIProviderException e) {
        if (e instanceof ModelException) {
            ModelException me = (ModelException) e;
            if (me.getModelErrorType() != null) {
                return me.getModelErrorType().getDescription();
            }
        }
        return e.getMessage() != null ? e.getMessage() : "Model error occurred.";
    }
    
    private static String getResponseDetails(APIProviderException e) {
        if (e instanceof ResponseException) {
            ResponseException re = (ResponseException) e;
            if (re.getResponseErrorType() != null) {
                return re.getResponseErrorType().getDescription();
            }
        }
        return e.getMessage() != null ? e.getMessage() : "Invalid response received.";
    }
    
    private static String getServiceDetails(APIProviderException e) {
        if (e.getHttpStatusCode() >= 500) {
            return "The API service is experiencing internal issues.";
        } else if (e.getHttpStatusCode() == 503) {
            return "The API service is temporarily unavailable.";
        }
        return e.getMessage() != null ? e.getMessage() : "Service error occurred.";
    }
    
    private static String getCancellationDetails(APIProviderException e) {
        if (e instanceof StreamCancelledException) {
            StreamCancelledException sce = (StreamCancelledException) e;
            return sce.getCancellationReason().getDescription();
        }
        return e.getMessage() != null ? e.getMessage() : "Request was cancelled.";
    }
}
```

`src/main/java/ghidrassist/apiprovider/GeminiOAuthProvider.java`:

```java
package ghidrassist.apiprovider;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import ghidra.util.Msg;
import ghidrassist.LlmApi.LlmResponseHandler;
import ghidrassist.apiprovider.capabilities.FunctionCallingProvider;
import ghidrassist.apiprovider.capabilities.ModelListProvider;
import ghidrassist.apiprovider.exceptions.*;
import ghidrassist.apiprovider.oauth.GeminiOAuthTokenManager;
import okhttp3.*;
import okio.BufferedSource;

import javax.net.ssl.*;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.UUID;

/**
 * Google Gemini OAuth Provider - Routes requests through the Code Assist proxy.
 *
 * This provider uses OAuth authentication for Google Gemini CLI subscriptions.
 * All API requests go through cloudcode-pa.googleapis.com/v1internal:{action}.
 * Requests are wrapped in a Code Assist envelope and responses are unwrapped.
 * Uses native Gemini API format (contents/parts), NOT OpenAI-compatible.
 *
 * Key Features:
 * - OAuth authentication (no API key required)
 * - Automatic token refresh
 * - Native Gemini API format (contents[{role, parts[{text}]}])
 * - Code Assist proxy wrapping/unwrapping
 * - Streaming via ?alt=sse
 * - Function/tool calling support (Gemini format)
 */
public class GeminiOAuthProvider extends APIProvider implements FunctionCallingProvider, ModelListProvider {

    private static final Gson gson = new Gson();
    private static final MediaType JSON_MEDIA_TYPE = MediaType.get("application/json");

    // Code Assist proxy endpoint
    private static final String CODE_ASSIST_ENDPOINT = "https://cloudcode-pa.googleapis.com";
    private static final String CODE_ASSIST_API_VERSION = "v1internal";
    private static final String GEMINI_CLI_VERSION = "1.0.0";

    // Default model
    private static final String DEFAULT_MODEL = "gemini-2.5-flash";

    // Synthetic thought signature used when the original is unavailable.
    // Matches the Gemini CLI's skip_thought_signature_validator behavior.
    private static final String SYNTHETIC_THOUGHT_SIGNATURE = "skip_thought_signature_validator";

    // Rate limiting: minimum interval between API requests (milliseconds)
    private static final long MIN_REQUEST_INTERVAL_MS = 2000;
    // Maximum backoff for 429 retries (milliseconds)
    private static final long MAX_RATE_LIMIT_BACKOFF_MS = 60_000;
    // Initial backoff for 429 retries (milliseconds)
    private static final long INITIAL_RATE_LIMIT_BACKOFF_MS = 5_000;

    private final GeminiOAuthTokenManager tokenManager;
    private final String sessionId;
    private volatile boolean isCancelled = false;
    private volatile long lastRequestTimeMs = 0;

    public GeminiOAuthProvider(String name, String model, Integer maxTokens, String url,
                               String key, boolean disableTlsVerification, Integer timeout) {
        super(name, ProviderType.GEMINI_OAUTH,
              model != null && !model.isEmpty() ? model : DEFAULT_MODEL,
              maxTokens, CODE_ASSIST_ENDPOINT, key, disableTlsVerification, timeout);

        this.tokenManager = new GeminiOAuthTokenManager(key);
        this.sessionId = generateSessionId();

        Msg.info(this, "Gemini OAuth provider initialized with model: " + this.model);
    }

    public GeminiOAuthTokenManager getTokenManager() {
        return tokenManager;
    }

    public boolean isAuthenticated() {
        return tokenManager.isAuthenticated();
    }

    public String getCredentialsJson() {
        return tokenManager.toJson();
    }

    @Override
    protected OkHttpClient buildClient() {
        try {
            OkHttpClient.Builder builder = new OkHttpClient.Builder()
                .connectTimeout(super.timeout)
                .readTimeout(super.timeout)
                .writeTimeout(super.timeout)
                .retryOnConnectionFailure(true);

            if (disableTlsVerification) {
                TrustManager[] trustAllCerts = new TrustManager[]{
                    new X509TrustManager() {
                        @Override
                        public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) {}
                        @Override
                        public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) {}
                        @Override
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return new java.security.cert.X509Certificate[]{};
                        }
                    }
                };

                SSLContext sslContext = SSLContext.getInstance("TLS");
                sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
                builder.sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustAllCerts[0])
                       .hostnameVerifier((hostname, session) -> true);
            }

            return builder.build();
        } catch (Exception e) {
            throw new RuntimeException("Failed to build HTTP client", e);
        }
    }

    // =========================================================================
    // Request Headers
    // =========================================================================

    private Headers.Builder getGeminiHeaders() throws IOException {
        String accessToken = tokenManager.getValidAccessToken();

        return new Headers.Builder()
            .add("Authorization", "Bearer " + accessToken)
            .add("Content-Type", "application/json")
            .add("User-Agent", buildUserAgent());
    }

    private String buildUserAgent() {
        String os = System.getProperty("os.name", "").toLowerCase();
        String platform;
        if (os.contains("linux")) platform = "linux";
        else if (os.contains("mac") || os.contains("darwin")) platform = "darwin";
        else if (os.contains("win")) platform = "win32";
        else platform = os;

        String arch = System.getProperty("os.arch", "");
        if ("amd64".equals(arch) || "x86_64".equals(arch)) arch = "x86_64";
        else if ("aarch64".equals(arch) || "arm64".equals(arch)) arch = "arm64";

        return "GeminiCLI/" + GEMINI_CLI_VERSION + "/" + this.model + " (" + platform + "; " + arch + ")";
    }

    // =========================================================================
    // Rate Limiting
    // =========================================================================

    /**
     * Enforces minimum interval between API requests.
     * Blocks until at least MIN_REQUEST_INTERVAL_MS has elapsed since the last request.
     */
    private synchronized void enforceRateLimit() {
        long now = System.currentTimeMillis();
        long elapsed = now - lastRequestTimeMs;
        if (elapsed < MIN_REQUEST_INTERVAL_MS && lastRequestTimeMs > 0) {
            long sleepMs = MIN_REQUEST_INTERVAL_MS - elapsed;
            Msg.debug(this, "Rate limiting: waiting " + sleepMs + "ms before next request");
            try {
                Thread.sleep(sleepMs);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        lastRequestTimeMs = System.currentTimeMillis();
    }

    /**
     * Executes an HTTP request with automatic retry on 429 rate limit responses.
     * Retries indefinitely with backoff capped at MAX_RATE_LIMIT_BACKOFF_MS.
     * Returns the successful Response (caller is responsible for closing it).
     */
    private Response executeWithRateLimitRetry(Request request, String operation) throws IOException, APIProviderException {
        long backoffMs = INITIAL_RATE_LIMIT_BACKOFF_MS;
        int attempt = 0;

        while (true) {
            if (isCancelled) {
                throw new APIProviderException(APIProviderException.ErrorCategory.CANCELLED,
                    name, operation, "Request cancelled");
            }

            enforceRateLimit();
            Response response = client.newCall(request).execute();

            if (response.code() != 429) {
                return response;
            }

            // 429 - rate limited. Close this response and retry.
            response.close();
            attempt++;

            // Check for Retry-After header
            String retryAfter = response.header("Retry-After");
            long waitMs = backoffMs;
            if (retryAfter != null) {
                try {
                    waitMs = Long.parseLong(retryAfter) * 1000;
                } catch (NumberFormatException e) {
                    // ignore, use computed backoff
                }
            }
            waitMs = Math.min(waitMs, MAX_RATE_LIMIT_BACKOFF_MS);

            Msg.info(this, String.format("Rate limited (429) on %s, attempt %d. Waiting %dms...",
                operation, attempt, waitMs));

            try {
                Thread.sleep(waitMs);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new IOException("Interrupted during rate limit backoff", e);
            }

            // Increase backoff for next time, capped
            backoffMs = Math.min(backoffMs * 2, MAX_RATE_LIMIT_BACKOFF_MS);
        }
    }

    /**
     * Enqueues a streaming HTTP request with automatic retry on 429 rate limit responses.
     * Retries indefinitely with backoff capped at MAX_RATE_LIMIT_BACKOFF_MS.
     */
    private void enqueueStreamingWithRetry(Request request, LlmResponseHandler handler) {
        enforceRateLimit();
        client.newCall(request).enqueue(new Callback() {
            private boolean isFirst = true;
            private StringBuilder contentBuilder = new StringBuilder();
            private long backoffMs = INITIAL_RATE_LIMIT_BACKOFF_MS;
            private int rateLimitAttempt = 0;

            @Override
            public void onFailure(Call call, IOException e) {
                handler.onError(handleNetworkError(e, "streamChatCompletion"));
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.code() == 401) {
                        handler.onError(new AuthenticationException(name, "streamChatCompletion",
                            401, null, "Authentication failed. Please re-authenticate."));
                        return;
                    }
                    if (response.code() == 429) {
                        // Rate limited - retry with backoff, never give up
                        rateLimitAttempt++;
                        String retryAfter = response.header("Retry-After");
                        long waitMs = backoffMs;
                        if (retryAfter != null) {
                            try {
                                waitMs = Long.parseLong(retryAfter) * 1000;
                            } catch (NumberFormatException e) {
                                // ignore, use computed backoff
                            }
                        }
                        waitMs = Math.min(waitMs, MAX_RATE_LIMIT_BACKOFF_MS);

                        Msg.info(GeminiOAuthProvider.this, String.format(
                            "Rate limited (429) on streaming, attempt %d. Waiting %dms...",
                            rateLimitAttempt, waitMs));

                        try {
                            Thread.sleep(waitMs);
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                            handler.onError(handleNetworkError(
                                new IOException("Interrupted during rate limit backoff", e),
                                "streamChatCompletion"));
                            return;
                        }

                        backoffMs = Math.min(backoffMs * 2, MAX_RATE_LIMIT_BACKOFF_MS);

                        // Re-enqueue the request
                        if (!isCancelled) {
                            enforceRateLimit();
                            client.newCall(request).enqueue(this);
                        }
                        return;
                    }
                    if (!response.isSuccessful()) {
                        String errorBody = responseBody != null ? responseBody.string() : "";
                        handler.onError(new APIProviderException(APIProviderException.ErrorCategory.SERVICE_ERROR,
                            name, "streamChatCompletion",
                            "API error " + response.code() + ": " + errorBody));
                        return;
                    }

                    // Parse SSE: multi-line data blocks separated by empty lines
                    BufferedSource source = responseBody.source();
                    List<String> bufferedLines = new ArrayList<>();

                    while (!source.exhausted() && !isCancelled && handler.shouldContinue()) {
                        String line = source.readUtf8Line();
                        if (line == null) break;

                        if (line.startsWith("data: ")) {
                            bufferedLines.add(line.substring(6).trim());
                        } else if (line.isEmpty() && !bufferedLines.isEmpty()) {
                            // Empty line = end of SSE block, parse buffered data
                            try {
                                String jsonStr = String.join("\n", bufferedLines);
                                JsonObject event = gson.fromJson(jsonStr, JsonObject.class);
                                JsonObject unwrapped = unwrapResponse(event);

                                // Extract text from candidates
                                JsonArray candidates = unwrapped.has("candidates")
                                    ? unwrapped.getAsJsonArray("candidates") : null;

                                if (candidates != null && candidates.size() > 0) {
                                    JsonObject firstCandidate = candidates.get(0).getAsJsonObject();
                                    if (firstCandidate.has("content") && firstCandidate.get("content").isJsonObject()) {
                                        JsonArray parts = firstCandidate.getAsJsonObject("content")
                                            .has("parts") ? firstCandidate.getAsJsonObject("content").getAsJsonArray("parts") : null;

                                        if (parts != null) {
                                            for (JsonElement partEl : parts) {
                                                JsonObject part = partEl.getAsJsonObject();
                                                if (part.has("text")) {
                                                    String text = part.get("text").getAsString();
                                                    if (!text.isEmpty()) {
                                                        if (isFirst) {
                                                            handler.onStart();
                                                            isFirst = false;
                                                        }
                                                        contentBuilder.append(text);
                                                        handler.onUpdate(text);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } catch (Exception e) {
                                Msg.debug(GeminiOAuthProvider.this, "Skipping malformed SSE event: " + e.getMessage());
                            }
                            bufferedLines.clear();
                        }
                    }

                    if (isCancelled) {
                        handler.onError(new APIProviderException(APIProviderException.ErrorCategory.CANCELLED,
                            name, "streamChatCompletion", "Request cancelled"));
                    } else {
                        handler.onComplete(contentBuilder.toString());
                    }
                }
            }
        });
    }

    // =========================================================================
    // Message Translation - Gemini Native Format
    // =========================================================================

    /**
     * Translates ChatMessage list to Gemini native format.
     * Returns a JsonObject with 'contents' and optionally 'systemInstruction'.
     */
    private JsonObject translateMessages(List<ChatMessage> messages) {
        JsonObject result = new JsonObject();
        JsonArray contents = new JsonArray();

        if (messages == null) {
            result.add("contents", contents);
            return result;
        }

        for (int i = 0; i < messages.size(); i++) {
            ChatMessage message = messages.get(i);
            if (message == null || message.getRole() == null) continue;

            String role = message.getRole();
            String content = message.getContent();

            if (ChatMessage.ChatMessageRole.SYSTEM.equals(role)) {
                // System message -> systemInstruction
                if (content != null && !content.isEmpty()) {
                    JsonObject sysInstruction = new JsonObject();
                    JsonArray parts = new JsonArray();
                    JsonObject textPart = new JsonObject();
                    textPart.addProperty("text", content);
                    parts.add(textPart);
                    sysInstruction.add("parts", parts);
                    result.add("systemInstruction", sysInstruction);
                }
                continue;
            }

            if (ChatMessage.ChatMessageRole.USER.equals(role)) {
                if (content != null && !content.isEmpty()) {
                    JsonObject entry = new JsonObject();
                    entry.addProperty("role", "user");
                    JsonArray parts = new JsonArray();
                    JsonObject textPart = new JsonObject();
                    textPart.addProperty("text", content);
                    parts.add(textPart);
                    entry.add("parts", parts);
                    contents.add(entry);
                }
                continue;
            }

            if (ChatMessage.ChatMessageRole.ASSISTANT.equals(role)) {
                // Check for tool calls first
                com.google.gson.JsonArray toolCalls = message.getToolCalls();
                if (toolCalls != null && toolCalls.size() > 0) {
                    JsonObject entry = new JsonObject();
                    entry.addProperty("role", "model");
                    JsonArray parts = new JsonArray();

                    for (JsonElement toolCallElement : toolCalls) {
                        if (!toolCallElement.isJsonObject()) continue;
                        JsonObject toolCall = toolCallElement.getAsJsonObject();

                        JsonObject function = toolCall.has("function") && toolCall.get("function").isJsonObject()
                            ? toolCall.getAsJsonObject("function") : null;

                        String funcName = null;
                        if (function != null && function.has("name")) {
                            funcName = function.get("name").getAsString();
                        } else if (toolCall.has("name")) {
                            funcName = toolCall.get("name").getAsString();
                        }

                        JsonElement argsElement = null;
                        if (function != null && function.has("arguments")) {
                            argsElement = function.get("arguments");
                        } else if (toolCall.has("arguments")) {
                            argsElement = toolCall.get("arguments");
                        }

                        JsonObject args = new JsonObject();
                        if (argsElement != null && !argsElement.isJsonNull()) {
                            if (argsElement.isJsonObject()) {
                                args = argsElement.getAsJsonObject();
                            } else if (argsElement.isJsonPrimitive()) {
                                try {
                                    args = gson.fromJson(argsElement.getAsString(), JsonObject.class);
                                } catch (Exception e) {
                                    args.addProperty("input", argsElement.getAsString());
                                }
                            }
                        }

                        JsonObject functionCall = new JsonObject();
                        functionCall.addProperty("name", funcName != null ? funcName : "");
                        functionCall.add("args", args);

                        JsonObject fcPart = new JsonObject();
                        // Gemini API requires thoughtSignature on function call parts.
                        // Use synthetic signature when original is unavailable.
                        fcPart.addProperty("thoughtSignature", SYNTHETIC_THOUGHT_SIGNATURE);
                        fcPart.add("functionCall", functionCall);
                        parts.add(fcPart);
                    }

                    // Also add text content if present
                    if (content != null && !content.isEmpty()) {
                        JsonObject textPart = new JsonObject();
                        textPart.addProperty("text", content);
                        parts.add(textPart);
                    }

                    entry.add("parts", parts);
                    contents.add(entry);
                } else if (content != null && !content.isEmpty()) {
                    JsonObject entry = new JsonObject();
                    entry.addProperty("role", "model");
                    JsonArray parts = new JsonArray();
                    JsonObject textPart = new JsonObject();
                    textPart.addProperty("text", content);
                    parts.add(textPart);
                    entry.add("parts", parts);
                    contents.add(entry);
                }
                continue;
            }

            if (ChatMessage.ChatMessageRole.TOOL.equals(role) || ChatMessage.ChatMessageRole.FUNCTION.equals(role)) {
                // Batch all consecutive TOOL messages into a single user content block.
                // Gemini requires the number of functionResponse parts to match the
                // number of functionCall parts from the preceding model turn.
                JsonObject entry = new JsonObject();
                entry.addProperty("role", "user");
                JsonArray parts = new JsonArray();

                // Process this TOOL message and all consecutive ones
                for (; i < messages.size(); i++) {
                    ChatMessage toolMsg = messages.get(i);
                    if (toolMsg == null || toolMsg.getRole() == null) continue;
                    String toolRole = toolMsg.getRole();
                    if (!ChatMessage.ChatMessageRole.TOOL.equals(toolRole) &&
                        !ChatMessage.ChatMessageRole.FUNCTION.equals(toolRole)) {
                        // Not a TOOL message - back up so outer loop processes it
                        i--;
                        break;
                    }

                    // Always create a functionResponse part for every TOOL message.
                    // Gemini requires exactly one functionResponse for each functionCall.
                    // Skipping empty results would cause a count mismatch error.
                    String toolContent = toolMsg.getContent();
                    JsonObject funcResponse = new JsonObject();
                    String toolCallId = toolMsg.getToolCallId();
                    String funcName = lookupFunctionName(messages, toolCallId);
                    funcResponse.addProperty("name", funcName);
                    if (toolCallId != null) {
                        funcResponse.addProperty("id", toolCallId);
                    }

                    JsonObject responseContent = new JsonObject();
                    responseContent.addProperty("output",
                        (toolContent != null && !toolContent.isEmpty()) ? toolContent : "(no output)");
                    funcResponse.add("response", responseContent);

                    JsonObject frPart = new JsonObject();
                    frPart.add("functionResponse", funcResponse);
                    parts.add(frPart);
                }

                if (parts.size() > 0) {
                    entry.add("parts", parts);
                    contents.add(entry);
                }
            }
        }

        result.add("contents", contents);
        return result;
    }

    /**
     * Looks up the actual function name for a tool call ID by searching
     * prior assistant messages' tool_calls arrays.
     */
    private String lookupFunctionName(List<ChatMessage> messages, String toolCallId) {
        if (toolCallId == null || messages == null) return "function";

        for (ChatMessage msg : messages) {
            if (!ChatMessage.ChatMessageRole.ASSISTANT.equals(msg.getRole())) continue;
            JsonArray toolCalls = msg.getToolCalls();
            if (toolCalls == null) continue;

            for (JsonElement tcElement : toolCalls) {
                if (!tcElement.isJsonObject()) continue;
                JsonObject tc = tcElement.getAsJsonObject();

                // Check if this tool call matches the ID
                String id = tc.has("id") ? tc.get("id").getAsString() : null;
                if (!toolCallId.equals(id)) continue;

                // Extract function name from nested "function" object or direct "name"
                if (tc.has("function") && tc.get("function").isJsonObject()) {
                    JsonObject func = tc.getAsJsonObject("function");
                    if (func.has("name")) {
                        return func.get("name").getAsString();
                    }
                }
                if (tc.has("name")) {
                    return tc.get("name").getAsString();
                }
            }
        }
        return "function";
    }

    /**
     * Translates tool definitions to Gemini tools format.
     */
    private JsonArray translateToolsToGeminiFormat(List<Map<String, Object>> tools) {
        JsonArray geminiTools = new JsonArray();

        if (tools == null || tools.isEmpty()) return geminiTools;

        JsonArray functionDeclarations = new JsonArray();
        for (Map<String, Object> tool : tools) {
            if (!"function".equals(tool.get("type"))) continue;

            @SuppressWarnings("unchecked")
            Map<String, Object> function = (Map<String, Object>) tool.get("function");
            if (function == null) continue;

            JsonObject decl = new JsonObject();
            decl.addProperty("name", (String) function.get("name"));
            decl.addProperty("description", (String) function.get("description"));

            @SuppressWarnings("unchecked")
            Map<String, Object> parameters = (Map<String, Object>) function.get("parameters");
            if (parameters != null) {
                // Use parametersJsonSchema (standard JSON Schema with lowercase types)
                // instead of parameters (Gemini Schema with uppercase types like "OBJECT", "STRING")
                decl.add("parametersJsonSchema", gson.toJsonTree(parameters));
            }

            functionDeclarations.add(decl);
        }

        if (functionDeclarations.size() > 0) {
            JsonObject toolObj = new JsonObject();
            toolObj.add("functionDeclarations", functionDeclarations);
            geminiTools.add(toolObj);
        }

        return geminiTools;
    }

    // =========================================================================
    // Request Wrapping / Response Unwrapping
    // =========================================================================

    /**
     * Wraps a Gemini API request in the Code Assist envelope.
     */
    private JsonObject wrapRequest(JsonObject requestPayload) {
        requestPayload.addProperty("session_id", sessionId);

        String projectId = tokenManager.getProjectId();

        JsonObject envelope = new JsonObject();
        envelope.addProperty("model", this.model);
        envelope.addProperty("project", projectId != null ? projectId : "");
        envelope.addProperty("user_prompt_id", UUID.randomUUID().toString());
        envelope.add("request", requestPayload);

        return envelope;
    }

    /**
     * Unwraps a Code Assist response envelope.
     * The proxy returns {response: {...actual data...}, traceId: "..."}.
     */
    private JsonObject unwrapResponse(JsonObject data) {
        if (data.has("response") && data.get("response").isJsonObject()) {
            return data.getAsJsonObject("response");
        }
        return data;
    }

    // =========================================================================
    // Response Parsing
    // =========================================================================

    private ParsedResponse parseGeminiResponse(JsonObject responseData) {
        StringBuilder textContent = new StringBuilder();
        JsonArray toolCalls = new JsonArray();
        String finishReason = "stop";

        JsonArray candidates = responseData.has("candidates")
            ? responseData.getAsJsonArray("candidates") : new JsonArray();

        if (candidates.size() > 0) {
            JsonObject firstCandidate = candidates.get(0).getAsJsonObject();

            if (firstCandidate.has("content") && firstCandidate.get("content").isJsonObject()) {
                JsonObject content = firstCandidate.getAsJsonObject("content");
                JsonArray parts = content.has("parts") ? content.getAsJsonArray("parts") : new JsonArray();

                for (JsonElement partElement : parts) {
                    JsonObject part = partElement.getAsJsonObject();

                    // Text content
                    if (part.has("text")) {
                        textContent.append(part.get("text").getAsString());
                    }

                    // Function call
                    if (part.has("functionCall") && part.get("functionCall").isJsonObject()) {
                        JsonObject funcCall = part.getAsJsonObject("functionCall");

                        // Convert to OpenAI format for compatibility with ActionParser
                        JsonObject toolCall = new JsonObject();
                        toolCall.addProperty("id", "call_" + UUID.randomUUID().toString().replace("-", "").substring(0, 24));
                        toolCall.addProperty("type", "function");

                        JsonObject function = new JsonObject();
                        function.addProperty("name", funcCall.has("name") ? funcCall.get("name").getAsString() : "");
                        function.addProperty("arguments", funcCall.has("args")
                            ? gson.toJson(funcCall.get("args")) : "{}");
                        toolCall.add("function", function);

                        toolCalls.add(toolCall);
                        finishReason = "tool_calls";
                    }
                }
            }

            // Check finish reason - but don't overwrite "tool_calls" if we detected function calls,
            // because Gemini returns finishReason="STOP" even when making function calls
            if (toolCalls.isEmpty() && firstCandidate.has("finishReason")) {
                String reason = firstCandidate.get("finishReason").getAsString();
                if ("MAX_TOKENS".equals(reason)) finishReason = "length";
                else if ("STOP".equals(reason)) finishReason = "stop";
            }
        }

        return new ParsedResponse(textContent.toString(), toolCalls, finishReason);
    }

    private record ParsedResponse(String textContent, JsonArray toolCalls, String finishReason) {}

    // =========================================================================
    // Chat Completion
    // =========================================================================

    @Override
    public String createChatCompletion(List<ChatMessage> messages) throws APIProviderException {
        if (!isAuthenticated()) {
            throw new AuthenticationException(name, "createChatCompletion", 401, null,
                "Not authenticated. Please authenticate via Settings > Edit Provider > Authenticate.");
        }

        try {
            JsonObject requestPayload = buildRequestPayload(messages, null);
            JsonObject wrapped = wrapRequest(requestPayload);
            Headers headers = getGeminiHeaders().build();

            String requestUrl = CODE_ASSIST_ENDPOINT + "/" + CODE_ASSIST_API_VERSION + ":generateContent";

            Request request = new Request.Builder()
                .url(requestUrl)
                .post(RequestBody.create(gson.toJson(wrapped).getBytes(StandardCharsets.UTF_8), JSON_MEDIA_TYPE))
                .headers(headers)
                .build();

            try (Response response = executeWithRateLimitRetry(request, "createChatCompletion")) {
                if (response.code() == 401) {
                    throw new AuthenticationException(name, "createChatCompletion", 401,
                        response.body() != null ? response.body().string() : null,
                        "Authentication failed. Please re-authenticate.");
                }
                if (!response.isSuccessful()) {
                    String errorBody = response.body() != null ? response.body().string() : "";
                    throw new APIProviderException(APIProviderException.ErrorCategory.SERVICE_ERROR,
                        name, "createChatCompletion",
                        "API error " + response.code() + ": " + errorBody);
                }

                String responseBody = response.body() != null ? response.body().string() : "{}";
                JsonObject responseData = gson.fromJson(responseBody, JsonObject.class);
                responseData = unwrapResponse(responseData);

                ParsedResponse parsed = parseGeminiResponse(responseData);
                return parsed.textContent();
            }
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletion");
        }
    }

    @Override
    public void streamChatCompletion(List<ChatMessage> messages, LlmResponseHandler handler)
            throws APIProviderException {
        if (!isAuthenticated()) {
            throw new AuthenticationException(name, "streamChatCompletion", 401, null,
                "Not authenticated. Please authenticate via Settings > Edit Provider > Authenticate.");
        }

        isCancelled = false;

        try {
            JsonObject requestPayload = buildRequestPayload(messages, null);
            JsonObject wrapped = wrapRequest(requestPayload);
            Headers headers = getGeminiHeaders().build();

            // Streaming via ?alt=sse
            String requestUrl = CODE_ASSIST_ENDPOINT + "/" + CODE_ASSIST_API_VERSION + ":streamGenerateContent?alt=sse";

            Request request = new Request.Builder()
                .url(requestUrl)
                .post(RequestBody.create(gson.toJson(wrapped).getBytes(StandardCharsets.UTF_8), JSON_MEDIA_TYPE))
                .headers(headers)
                .build();

            enqueueStreamingWithRetry(request, handler);
        } catch (IOException e) {
            handler.onError(handleNetworkError(e, "streamChatCompletion"));
        }
    }

    // =========================================================================
    // Function Calling
    // =========================================================================

    @Override
    public String createChatCompletionWithFunctions(List<ChatMessage> messages,
                                                    List<Map<String, Object>> functions)
            throws APIProviderException {
        if (!isAuthenticated()) {
            throw new AuthenticationException(name, "createChatCompletionWithFunctions", 401, null,
                "Not authenticated. Please authenticate via Settings > Edit Provider > Authenticate.");
        }

        try {
            JsonObject requestPayload = buildRequestPayload(messages, functions);
            JsonObject wrapped = wrapRequest(requestPayload);
            Headers headers = getGeminiHeaders().build();

            String requestUrl = CODE_ASSIST_ENDPOINT + "/" + CODE_ASSIST_API_VERSION + ":generateContent";

            Request request = new Request.Builder()
                .url(requestUrl)
                .post(RequestBody.create(gson.toJson(wrapped).getBytes(StandardCharsets.UTF_8), JSON_MEDIA_TYPE))
                .headers(headers)
                .build();

            try (Response response = executeWithRateLimitRetry(request, "createChatCompletionWithFunctions")) {
                if (response.code() == 401) {
                    throw new AuthenticationException(name, "createChatCompletionWithFunctions", 401,
                        response.body() != null ? response.body().string() : null,
                        "Authentication failed. Please re-authenticate.");
                }
                if (!response.isSuccessful()) {
                    String errorBody = response.body() != null ? response.body().string() : "";
                    throw new APIProviderException(APIProviderException.ErrorCategory.SERVICE_ERROR,
                        name, "createChatCompletionWithFunctions",
                        "API error " + response.code() + ": " + errorBody);
                }

                String responseBody = response.body() != null ? response.body().string() : "{}";
                JsonObject responseData = gson.fromJson(responseBody, JsonObject.class);
                responseData = unwrapResponse(responseData);

                ParsedResponse parsed = parseGeminiResponse(responseData);

                // Return tool calls in OpenAI format for ActionParser compatibility
                JsonObject result = new JsonObject();
                result.add("tool_calls", parsed.toolCalls());
                return gson.toJson(result);
            }
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletionWithFunctions");
        }
    }

    @Override
    public String createChatCompletionWithFunctionsFullResponse(List<ChatMessage> messages,
                                                                List<Map<String, Object>> functions)
            throws APIProviderException {
        if (!isAuthenticated()) {
            throw new AuthenticationException(name, "createChatCompletionWithFunctionsFullResponse", 401, null,
                "Not authenticated. Please authenticate via Settings > Edit Provider > Authenticate.");
        }

        try {
            JsonObject requestPayload = buildRequestPayload(messages, functions);
            JsonObject wrapped = wrapRequest(requestPayload);
            Headers headers = getGeminiHeaders().build();

            String requestUrl = CODE_ASSIST_ENDPOINT + "/" + CODE_ASSIST_API_VERSION + ":generateContent";

            String requestJson = gson.toJson(wrapped);
            // Debug: Log tool count and first tool name
            if (requestPayload.has("tools")) {
                JsonArray tools = requestPayload.getAsJsonArray("tools");
                int declCount = 0;
                String firstToolName = "none";
                for (JsonElement t : tools) {
                    if (t.isJsonObject() && t.getAsJsonObject().has("functionDeclarations")) {
                        JsonArray decls = t.getAsJsonObject().getAsJsonArray("functionDeclarations");
                        declCount += decls.size();
                        if (decls.size() > 0 && decls.get(0).getAsJsonObject().has("name")) {
                            firstToolName = decls.get(0).getAsJsonObject().get("name").getAsString();
                        }
                    }
                }
                Msg.info(this, "Gemini FunctionCall request: " + declCount + " tools declared, first=" + firstToolName
                    + ", hasToolConfig=" + requestPayload.has("toolConfig"));
            }

            Request request = new Request.Builder()
                .url(requestUrl)
                .post(RequestBody.create(requestJson.getBytes(StandardCharsets.UTF_8), JSON_MEDIA_TYPE))
                .headers(headers)
                .build();

            try (Response response = executeWithRateLimitRetry(request, "createChatCompletionWithFunctionsFullResponse")) {
                if (response.code() == 401) {
                    throw new AuthenticationException(name, "createChatCompletionWithFunctionsFullResponse", 401,
                        response.body() != null ? response.body().string() : null,
                        "Authentication failed. Please re-authenticate.");
                }
                if (!response.isSuccessful()) {
                    String errorBody = response.body() != null ? response.body().string() : "";
                    throw new APIProviderException(APIProviderException.ErrorCategory.SERVICE_ERROR,
                        name, "createChatCompletionWithFunctionsFullResponse",
                        "API error " + response.code() + ": " + errorBody);
                }

                String responseBody = response.body() != null ? response.body().string() : "{}";
                Msg.info(this, "Gemini raw response (first 1000 chars): " +
                    responseBody.substring(0, Math.min(1000, responseBody.length())));

                JsonObject responseData = gson.fromJson(responseBody, JsonObject.class);
                responseData = unwrapResponse(responseData);

                ParsedResponse parsed = parseGeminiResponse(responseData);
                Msg.info(this, "Gemini parsed: text=" + parsed.textContent().length() + " chars, toolCalls="
                    + parsed.toolCalls().size() + ", finishReason=" + parsed.finishReason());

                // Convert to OpenAI Chat Completions format for ActionParser compatibility
                JsonObject fullResponse = new JsonObject();
                JsonArray choices = new JsonArray();
                JsonObject choice = new JsonObject();
                JsonObject message = new JsonObject();

                message.addProperty("role", "assistant");

                if (!parsed.toolCalls().isEmpty()) {
                    message.add("tool_calls", parsed.toolCalls());
                    if (!parsed.textContent().isEmpty()) {
                        message.addProperty("content", parsed.textContent());
                    }
                } else {
                    message.addProperty("content", parsed.textContent());
                }

                choice.add("message", message);
                choice.addProperty("finish_reason", parsed.finishReason());
                choice.addProperty("index", 0);
                choices.add(choice);

                fullResponse.add("choices", choices);
                fullResponse.addProperty("id", "chatcmpl-gemini-" + System.currentTimeMillis());
                fullResponse.addProperty("object", "chat.completion");
                fullResponse.addProperty("created", System.currentTimeMillis() / 1000);
                fullResponse.addProperty("model", this.model);

                return gson.toJson(fullResponse);
            }
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletionWithFunctionsFullResponse");
        }
    }

    // =========================================================================
    // Request Building
    // =========================================================================

    /**
     * Builds request payload in Gemini native format.
     */
    private JsonObject buildRequestPayload(List<ChatMessage> messages, List<Map<String, Object>> tools) {
        JsonObject translated = translateMessages(messages);
        JsonObject payload = new JsonObject();

        // Add contents
        payload.add("contents", translated.getAsJsonArray("contents"));

        // Add systemInstruction if present
        if (translated.has("systemInstruction")) {
            payload.add("systemInstruction", translated.getAsJsonObject("systemInstruction"));
        }

        // Add tools if present
        if (tools != null && !tools.isEmpty()) {
            JsonArray geminiTools = translateToolsToGeminiFormat(tools);
            if (geminiTools.size() > 0) {
                payload.add("tools", geminiTools);

                // Explicitly set toolConfig to AUTO mode for function calling
                JsonObject toolConfig = new JsonObject();
                JsonObject functionCallingConfig = new JsonObject();
                functionCallingConfig.addProperty("mode", "AUTO");
                toolConfig.add("functionCallingConfig", functionCallingConfig);
                payload.add("toolConfig", toolConfig);
            }
        }

        // Add generation config
        if (maxTokens != null && maxTokens > 0) {
            JsonObject generationConfig = new JsonObject();
            generationConfig.addProperty("maxOutputTokens", maxTokens);
            payload.add("generationConfig", generationConfig);
        }

        return payload;
    }

    // =========================================================================
    // Other Required Methods
    // =========================================================================

    @Override
    public List<String> getAvailableModels() throws APIProviderException {
        // Return commonly available Gemini models
        List<String> models = new ArrayList<>();
        models.add("gemini-2.5-flash");
        models.add("gemini-2.5-pro");
        models.add("gemini-2.0-flash");
        models.add("gemini-2.0-flash-lite");
        return models;
    }

    @Override
    public void getEmbeddingsAsync(String text, EmbeddingCallback callback) {
        callback.onError(new UnsupportedOperationException(
            "Embeddings are not supported by the Gemini OAuth API"));
    }

    public void cancelRequest() {
        isCancelled = true;
    }

    // =========================================================================
    // Utility
    // =========================================================================

    /**
     * Generate a session ID matching Gemini CLI format: random long int with leading dash.
     */
    private static String generateSessionId() {
        Random random = new Random();
        long id = 1_000_000_000_000_000L + (long)(random.nextDouble() * 9_000_000_000_000_000L);
        return "-" + id;
    }
}

```

`src/main/java/ghidrassist/apiprovider/GeminiPlatformApiProvider.java`:

```java
package ghidrassist.apiprovider;

import ghidrassist.apiprovider.exceptions.APIProviderException;

/**
 * Google Gemini Provider - OpenAI-compatible API at
 * https://generativelanguage.googleapis.com/v1beta/openai/.
 * Inherits all chat, streaming, function calling, and model listing from OpenAIPlatformApiProvider.
 * Gemini's OpenAI-compatible endpoint does not support embeddings.
 */
public class GeminiPlatformApiProvider extends OpenAIPlatformApiProvider {

    public GeminiPlatformApiProvider(String name, String model, Integer maxTokens, String url,
                                      String key, boolean disableTlsVerification, Integer timeout) {
        super(name, model, maxTokens, url, key, disableTlsVerification, timeout);

        // Override the type to GEMINI_PLATFORM_API
        this.type = ProviderType.GEMINI_PLATFORM_API;
    }

    public static GeminiPlatformApiProvider fromConfig(APIProviderConfig config) {
        return new GeminiPlatformApiProvider(
            config.getName(),
            config.getModel(),
            config.getMaxTokens(),
            config.getUrl(),
            config.getKey(),
            config.isDisableTlsVerification(),
            config.getTimeout()
        );
    }

    @Override
    public void getEmbeddingsAsync(String text, EmbeddingCallback callback) {
        callback.onError(new APIProviderException(
            APIProviderException.ErrorCategory.CONFIGURATION,
            name, "get_embeddings",
            "Gemini OpenAI-compatible endpoint does not support embeddings"));
    }
}

```

`src/main/java/ghidrassist/apiprovider/LMStudioProvider.java`:

```java
package ghidrassist.apiprovider;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import ghidrassist.LlmApi.LlmResponseHandler;
import ghidrassist.apiprovider.exceptions.APIProviderException;
import ghidrassist.apiprovider.capabilities.FunctionCallingProvider;
import ghidrassist.apiprovider.capabilities.ModelListProvider;
import ghidrassist.apiprovider.capabilities.EmbeddingProvider;
import okhttp3.*;
import okio.BufferedSource;

import javax.net.ssl.*;
import java.io.IOException;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class LMStudioProvider extends APIProvider implements FunctionCallingProvider, ModelListProvider, EmbeddingProvider {
    private static final Gson gson = new Gson();
    private static final MediaType JSON = MediaType.get("application/json; charset=utf-8");
    private static final String LMSTUDIO_CHAT_ENDPOINT = "v1/chat/completions";
    private static final String LMSTUDIO_MODELS_ENDPOINT = "v1/models";
    private static final String LMSTUDIO_EMBEDDINGS_ENDPOINT = "v1/embeddings";
    private volatile boolean isCancelled = false;

    public LMStudioProvider(String name, String model, Integer maxTokens, String url, String key, boolean disableTlsVerification, Integer timeout) {
        super(name, ProviderType.LMSTUDIO, model, maxTokens, url, key, disableTlsVerification, timeout);
    }

    @Override
    protected OkHttpClient buildClient() {
        try {
            OkHttpClient.Builder builder = new OkHttpClient.Builder()
                .connectTimeout(super.timeout)
                .readTimeout(super.timeout)
                .writeTimeout(super.timeout)
                .retryOnConnectionFailure(true)
                .addInterceptor(chain -> {
                    Request originalRequest = chain.request();
                    Request.Builder requestBuilder = originalRequest.newBuilder()
                        .header("Content-Type", "application/json");

                    String apiKey = key != null ? key.trim() : "";
                    if (!apiKey.isEmpty()) {
                        // Support API-key-protected OpenAI-compatible local endpoints.
                        // LM Studio itself may not require this, but remote/proxied servers often do.
                        requestBuilder.header("Authorization", "Bearer " + apiKey);
                    }

                    return chain.proceed(requestBuilder.build());
                });

            if (disableTlsVerification) {
                TrustManager[] trustAllCerts = new TrustManager[]{
                    new X509TrustManager() {
                        @Override
                        public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) {}
                        @Override
                        public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) {}
                        @Override
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return new java.security.cert.X509Certificate[]{};
                        }
                    }
                };

                SSLContext sslContext = SSLContext.getInstance("TLS");
                sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
                builder.sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustAllCerts[0])
                       .hostnameVerifier((hostname, session) -> true);
            }

            return builder.build();
        } catch (Exception e) {
            throw new RuntimeException("Failed to build HTTP client", e);
        }
    }

    @Override
    public String createChatCompletion(List<ChatMessage> messages) throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, false);
        
        Request request = new Request.Builder()
            .url(super.getUrl() + LMSTUDIO_CHAT_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        try (Response response = executeWithRetry(request, "createChatCompletion")) {
            JsonObject responseObj = gson.fromJson(response.body().string(), JsonObject.class);
            return extractContentFromResponse(responseObj);
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletion");
        }
    }

    @Override
    public void streamChatCompletion(List<ChatMessage> messages, LlmResponseHandler handler) throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, true);

        Request request = new Request.Builder()
            .url(super.getUrl() + LMSTUDIO_CHAT_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        client.newCall(request).enqueue(new Callback() {
            private boolean isFirst = true;
            private StringBuilder contentBuilder = new StringBuilder();

            @Override
            public void onFailure(Call call, IOException e) {
                handler.onError(handleNetworkError(e, "streamChatCompletion"));
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (!response.isSuccessful()) {
                        String errorBody = responseBody != null ? responseBody.string() : null;
                        handler.onError(handleHttpError(response, errorBody, "streamChatCompletion"));
                        return;
                    }

                    BufferedSource source = responseBody.source();
                    while (!source.exhausted() && !isCancelled && handler.shouldContinue()) {
                        String line = source.readUtf8Line();
                        if (line == null || line.isEmpty()) continue;
                        if (line.startsWith("data: ")) {
                            String data = line.substring(6).trim();
                            if (data.equals("[DONE]")) {
                                handler.onComplete(contentBuilder.toString());
                                return;
                            }

                            JsonObject chunk = gson.fromJson(data, JsonObject.class);
                            String content = extractDeltaContent(chunk);
                            
                            if (content != null) {
                                if (isFirst) {
                                    handler.onStart();
                                    isFirst = false;
                                }
                                contentBuilder.append(content);
                                handler.onUpdate(content);
                            }
                        }
                    }

                    if (isCancelled) {
                        handler.onError(new APIProviderException(APIProviderException.ErrorCategory.CANCELLED,
                            name, "streamChatCompletion", "Request cancelled"));
                    }
                }
            }
        });
    }

    @Override
    public String createChatCompletionWithFunctionsFullResponse(List<ChatMessage> messages, List<Map<String, Object>> functions) throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, true); // Enable streaming

        // LMStudio uses the modern 'tools' format, not 'functions'
        payload.add("tools", gson.toJsonTree(functions));

        Request request = new Request.Builder()
            .url(super.getUrl() + LMSTUDIO_CHAT_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        try (Response response = executeWithRetry(request, "createChatCompletionWithFunctionsFullResponse")) {
            // Handle streaming response - accumulate all chunks
            StringBuilder contentBuilder = new StringBuilder();
            java.util.Map<Integer, JsonObject> toolCallsMap = new java.util.HashMap<>();
            String finishReason = "stop";
            String responseId = null;

            try (ResponseBody responseBody = response.body()) {
                BufferedSource source = responseBody.source();
                while (!source.exhausted()) {
                    String line = source.readUtf8Line();
                    if (line == null || line.isEmpty()) continue;

                    if (line.startsWith("data: ")) {
                        String data = line.substring(6).trim();
                        if (data.equals("[DONE]")) {
                            break;
                        }

                        JsonObject chunk = gson.fromJson(data, JsonObject.class);

                        // Capture response ID from first chunk
                        if (responseId == null && chunk.has("id")) {
                            responseId = chunk.get("id").getAsString();
                        }

                        // Accumulate content and tool_calls from deltas
                        if (chunk.has("choices")) {
                            JsonArray choices = chunk.getAsJsonArray("choices");
                            if (choices.size() > 0) {
                                JsonObject choice = choices.get(0).getAsJsonObject();

                                // Handle delta content
                                if (choice.has("delta")) {
                                    JsonObject delta = choice.getAsJsonObject("delta");

                                    // Accumulate text content
                                    if (delta.has("content") && !delta.get("content").isJsonNull()) {
                                        contentBuilder.append(delta.get("content").getAsString());
                                    }

                                    // Accumulate tool_calls - they come as deltas that need to be merged
                                    if (delta.has("tool_calls")) {
                                        JsonArray toolCallDeltas = delta.getAsJsonArray("tool_calls");
                                        for (JsonElement tcElement : toolCallDeltas) {
                                            JsonObject toolCallDelta = tcElement.getAsJsonObject();

                                            // Each delta has an index to identify which tool call it belongs to
                                            int index = toolCallDelta.has("index") ? toolCallDelta.get("index").getAsInt() : 0;

                                            // Get or create the accumulated tool call for this index
                                            JsonObject accumulatedToolCall = toolCallsMap.computeIfAbsent(index, k -> new JsonObject());

                                            // Merge fields from delta into accumulated tool call
                                            if (toolCallDelta.has("id")) {
                                                accumulatedToolCall.addProperty("id", toolCallDelta.get("id").getAsString());
                                            }
                                            if (toolCallDelta.has("type")) {
                                                accumulatedToolCall.addProperty("type", toolCallDelta.get("type").getAsString());
                                            }
                                            if (toolCallDelta.has("index")) {
                                                accumulatedToolCall.addProperty("index", index);
                                            }

                                            // Merge function object
                                            if (toolCallDelta.has("function")) {
                                                JsonObject functionDelta = toolCallDelta.getAsJsonObject("function");
                                                JsonObject accumulatedFunction = accumulatedToolCall.has("function")
                                                    ? accumulatedToolCall.getAsJsonObject("function")
                                                    : new JsonObject();

                                                // Accumulate function name
                                                if (functionDelta.has("name")) {
                                                    accumulatedFunction.addProperty("name", functionDelta.get("name").getAsString());
                                                }

                                                // Accumulate function arguments (they come in chunks)
                                                if (functionDelta.has("arguments")) {
                                                    String existingArgs = accumulatedFunction.has("arguments")
                                                        ? accumulatedFunction.get("arguments").getAsString()
                                                        : "";
                                                    String newArgs = functionDelta.get("arguments").getAsString();
                                                    accumulatedFunction.addProperty("arguments", existingArgs + newArgs);
                                                }

                                                accumulatedToolCall.add("function", accumulatedFunction);
                                            }
                                        }
                                    }
                                }

                                // Capture finish_reason from final chunk
                                if (choice.has("finish_reason") && !choice.get("finish_reason").isJsonNull()) {
                                    finishReason = choice.get("finish_reason").getAsString();
                                }
                            }
                        }
                    }
                }
            }

            // Build a complete OpenAI-format response from accumulated data
            JsonObject responseObj = new JsonObject();
            responseObj.addProperty("id", responseId != null ? responseId : "chatcmpl-lmstudio-" + System.currentTimeMillis());
            responseObj.addProperty("object", "chat.completion");
            responseObj.addProperty("created", System.currentTimeMillis() / 1000);
            responseObj.addProperty("model", this.model);

            JsonArray choices = new JsonArray();
            JsonObject choice = new JsonObject();
            choice.addProperty("index", 0);

            // Build the message object from accumulated content
            JsonObject message = new JsonObject();
            message.addProperty("role", "assistant");
            message.addProperty("content", contentBuilder.toString());

            // Convert accumulated tool_calls map to array
            if (!toolCallsMap.isEmpty()) {
                JsonArray toolCallsArray = new JsonArray();
                // Sort by index to maintain order
                toolCallsMap.entrySet().stream()
                    .sorted(java.util.Map.Entry.comparingByKey())
                    .forEach(entry -> toolCallsArray.add(entry.getValue()));

                message.add("tool_calls", toolCallsArray);
                finishReason = "tool_calls";
            }

            choice.add("message", message);
            choice.addProperty("finish_reason", finishReason);
            choices.add(choice);
            responseObj.add("choices", choices);

            return gson.toJson(responseObj);
            
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletionWithFunctionsFullResponse");
        }
    }

    @Override
    public String createChatCompletionWithFunctions(List<ChatMessage> messages, List<Map<String, Object>> functions) throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, false);

        // LMStudio uses the modern 'tools' format, not 'functions'
        payload.add("tools", gson.toJsonTree(functions));

        // Use tool_choice instead of function_call for modern tools API
        payload.addProperty("tool_choice", "auto");

        Request request = new Request.Builder()
            .url(super.getUrl() + LMSTUDIO_CHAT_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        try (Response response = executeWithRetry(request, "createChatCompletionWithFunctions")) {
            JsonObject responseObj = gson.fromJson(response.body().string(), JsonObject.class);
            JsonObject message = responseObj.getAsJsonArray("choices")
                .get(0).getAsJsonObject()
                .getAsJsonObject("message");

            // Check if tool_calls already exists (modern format)
            if (message.has("tool_calls")) {
                JsonArray toolCalls = message.getAsJsonArray("tool_calls");
                return "{\"tool_calls\":" + toolCalls.toString() + "}";
            }

            // Check for legacy function_call format
            if (message.has("function_call")) {
                JsonObject functionCall = message.getAsJsonObject("function_call");
                // Convert to tool_calls format for ActionParser compatibility
                JsonArray toolCalls = new JsonArray();
                JsonObject toolCall = new JsonObject();
                toolCall.addProperty("id", "call_" + System.currentTimeMillis());
                toolCall.addProperty("type", "function");

                JsonObject function = new JsonObject();
                function.addProperty("name", functionCall.get("name").getAsString());
                function.add("arguments", functionCall.get("arguments"));
                toolCall.add("function", function);

                toolCalls.add(toolCall);
                return "{\"tool_calls\":" + toolCalls.toString() + "}";
            }

            // No function call - return empty tool_calls array
            return "{\"tool_calls\":[]}";
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletionWithFunctions");
        }
    }

    @Override
    public List<String> getAvailableModels() throws APIProviderException {
        Request request = new Request.Builder()
            .url(super.getUrl() + LMSTUDIO_MODELS_ENDPOINT)
            .build();

        try (Response response = executeWithRetry(request, "getAvailableModels")) {
            JsonObject responseObj = gson.fromJson(response.body().string(), JsonObject.class);
            List<String> modelIds = new ArrayList<>();
            JsonArray models = responseObj.getAsJsonArray("data");
            
            for (JsonElement model : models) {
                modelIds.add(model.getAsJsonObject().get("id").getAsString());
            }
            
            return modelIds;
        } catch (IOException e) {
            throw handleNetworkError(e, "getAvailableModels");
        }
    }

    @Override
    public void getEmbeddingsAsync(String text, EmbeddingCallback callback) {
        JsonObject payload = new JsonObject();
        payload.addProperty("model", "text-embedding-nomic-embed-text-v1.5");
        payload.addProperty("input", text);

        Request request = new Request.Builder()
            .url(super.getUrl() + LMSTUDIO_EMBEDDINGS_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callback.onError(e);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (!response.isSuccessful()) {
                        callback.onError(new IOException("Failed to get embeddings: " + 
                            response.code() + " " + response.message()));
                        return;
                    }

                    JsonObject responseObj = gson.fromJson(responseBody.string(), JsonObject.class);
                    JsonArray embedding = responseObj.getAsJsonArray("data")
                        .get(0).getAsJsonObject()
                        .getAsJsonArray("embedding");

                    double[] embeddingArray = new double[embedding.size()];
                    for (int i = 0; i < embedding.size(); i++) {
                        embeddingArray[i] = embedding.get(i).getAsDouble();
                    }
                    
                    callback.onSuccess(embeddingArray);
                } catch (Exception e) {
                    callback.onError(e);
                }
            }
        });
    }

    private JsonObject buildChatCompletionPayload(List<ChatMessage> messages, boolean stream) {
        JsonObject payload = new JsonObject();
        payload.addProperty("model", super.getModel());
        payload.addProperty("max_tokens", super.getMaxTokens());
        payload.addProperty("stream", stream);

        // Add reasoning object if configured (LMStudio Chat Completions API)
        // Format: { reasoning: { effort: "low" | "medium" | "high" } }
        ReasoningConfig reasoning = getReasoningConfig();
        if (reasoning != null && reasoning.isEnabled()) {
            JsonObject reasoningObj = new JsonObject();
            reasoningObj.addProperty("effort", reasoning.getEffortString());
            payload.add("reasoning", reasoningObj);
        }

        JsonArray messagesArray = new JsonArray();
        for (ChatMessage message : messages) {
            JsonObject messageObj = new JsonObject();
            messageObj.addProperty("role", message.getRole());
            messageObj.addProperty("content", message.getContent());
            messagesArray.add(messageObj);
        }
        payload.add("messages", messagesArray);

        return payload;
    }

    private String extractContentFromResponse(JsonObject responseObj) {
        return responseObj.getAsJsonArray("choices")
            .get(0).getAsJsonObject()
            .getAsJsonObject("message")
            .get("content").getAsString();
    }

    private String extractDeltaContent(JsonObject chunk) {
        try {
            JsonObject delta = chunk.getAsJsonArray("choices")
                .get(0).getAsJsonObject()
                .getAsJsonObject("delta");
            
            if (delta.has("content")) {
                return delta.get("content").getAsString();
            }
        } catch (Exception e) {
            // Handle any JSON parsing errors silently and return null
        }
        return null;
    }

    /**
     * Interface for handling streaming responses with function calling support.
     */
    public interface StreamingFunctionHandler {
        /**
         * Called when a text delta is received.
         * @param textDelta The incremental text content
         */
        void onTextUpdate(String textDelta);

        /**
         * Called when streaming is complete and all data is available.
         * @param stopReason The reason streaming stopped (e.g., "stop", "tool_calls")
         * @param fullText The complete text content
         * @param toolCalls List of tool calls (empty if none)
         */
        void onStreamComplete(String stopReason, String fullText, List<ToolCall> toolCalls);

        /**
         * Called when an error occurs during streaming.
         * @param error The error that occurred
         */
        void onError(Throwable error);

        /**
         * Called to check if streaming should continue.
         * @return true if streaming should continue, false to cancel
         */
        boolean shouldContinue();
    }

    /**
     * Represents a tool call from the LLM.
     */
    public static class ToolCall {
        public final String id;
        public final String name;
        public final String arguments;

        public ToolCall(String id, String name, String arguments) {
            this.id = id;
            this.name = name;
            this.arguments = arguments;
        }
    }

    /**
     * Stream chat completion with function calling support.
     * This method streams text content in real-time while buffering tool calls.
     */
    public void streamChatCompletionWithFunctions(
        List<ChatMessage> messages,
        List<Map<String, Object>> functions,
        StreamingFunctionHandler handler
    ) throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, true);
        payload.add("tools", gson.toJsonTree(functions));

        Request request = new Request.Builder()
            .url(super.getUrl() + LMSTUDIO_CHAT_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                handler.onError(handleNetworkError(e, "streamChatCompletionWithFunctions"));
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (!response.isSuccessful()) {
                        String errorBody = responseBody != null ? responseBody.string() : null;
                        handler.onError(handleHttpError(response, errorBody, "streamChatCompletionWithFunctions"));
                        return;
                    }

                    if (responseBody == null) {
                        handler.onError(new APIProviderException(APIProviderException.ErrorCategory.RESPONSE_ERROR,
                            name, "streamChatCompletionWithFunctions", "Empty response body"));
                        return;
                    }

                    BufferedSource source = responseBody.source();
                    StringBuilder textBuilder = new StringBuilder();
                    java.util.Map<Integer, JsonObject> toolCallsMap = new java.util.HashMap<>();
                    String finishReason = "stop";

                    try {
                        while (!source.exhausted() && !isCancelled && handler.shouldContinue()) {
                            String line = source.readUtf8Line();
                            if (line == null || line.isEmpty()) continue;

                            if (line.startsWith("data: ")) {
                                String data = line.substring(6).trim();
                                if (data.equals("[DONE]")) {
                                    // Process complete - convert accumulated tool calls
                                    List<ToolCall> toolCalls = new java.util.ArrayList<>();
                                    toolCallsMap.entrySet().stream()
                                        .sorted(java.util.Map.Entry.comparingByKey())
                                        .forEach(entry -> {
                                            JsonObject toolCallObj = entry.getValue();
                                            String id = toolCallObj.has("id") ? toolCallObj.get("id").getAsString() : "call_" + entry.getKey();
                                            String name = "";
                                            String arguments = "{}";

                                            if (toolCallObj.has("function")) {
                                                JsonObject function = toolCallObj.getAsJsonObject("function");
                                                if (function.has("name")) {
                                                    name = function.get("name").getAsString();
                                                }
                                                if (function.has("arguments")) {
                                                    String args = function.get("arguments").getAsString().trim();
                                                    arguments = args.isEmpty() ? "{}" : args;
                                                }
                                            }

                                            toolCalls.add(new ToolCall(id, name, arguments));
                                        });

                                    handler.onStreamComplete(finishReason, textBuilder.toString(), toolCalls);
                                    return;
                                }

                                try {
                                    JsonObject chunk = gson.fromJson(data, JsonObject.class);

                                    if (chunk.has("choices")) {
                                        JsonArray choices = chunk.getAsJsonArray("choices");
                                        if (choices.size() > 0) {
                                            JsonObject choice = choices.get(0).getAsJsonObject();

                                            if (choice.has("delta")) {
                                                JsonObject delta = choice.getAsJsonObject("delta");

                                                // Stream text content immediately
                                                if (delta.has("content") && !delta.get("content").isJsonNull()) {
                                                    String content = delta.get("content").getAsString();
                                                    textBuilder.append(content);
                                                    handler.onTextUpdate(content);
                                                }

                                                // Buffer tool calls - accumulate deltas
                                                if (delta.has("tool_calls")) {
                                                    JsonArray toolCallDeltas = delta.getAsJsonArray("tool_calls");
                                                    for (JsonElement tcElement : toolCallDeltas) {
                                                        JsonObject toolCallDelta = tcElement.getAsJsonObject();
                                                        int index = toolCallDelta.has("index") ? toolCallDelta.get("index").getAsInt() : 0;

                                                        JsonObject accumulatedToolCall = toolCallsMap.computeIfAbsent(index, k -> new JsonObject());

                                                        // Merge fields from delta
                                                        if (toolCallDelta.has("id")) {
                                                            accumulatedToolCall.addProperty("id", toolCallDelta.get("id").getAsString());
                                                        }
                                                        if (toolCallDelta.has("type")) {
                                                            accumulatedToolCall.addProperty("type", toolCallDelta.get("type").getAsString());
                                                        }

                                                        // Merge function object
                                                        if (toolCallDelta.has("function")) {
                                                            JsonObject functionDelta = toolCallDelta.getAsJsonObject("function");
                                                            JsonObject accumulatedFunction = accumulatedToolCall.has("function")
                                                                ? accumulatedToolCall.getAsJsonObject("function")
                                                                : new JsonObject();

                                                            if (functionDelta.has("name")) {
                                                                accumulatedFunction.addProperty("name", functionDelta.get("name").getAsString());
                                                            }

                                                            if (functionDelta.has("arguments")) {
                                                                String existingArgs = accumulatedFunction.has("arguments")
                                                                    ? accumulatedFunction.get("arguments").getAsString()
                                                                    : "";
                                                                String newArgs = functionDelta.get("arguments").getAsString();
                                                                accumulatedFunction.addProperty("arguments", existingArgs + newArgs);
                                                            }

                                                            accumulatedToolCall.add("function", accumulatedFunction);
                                                        }
                                                    }
                                                }
                                            }

                                            // Capture finish_reason
                                            if (choice.has("finish_reason") && !choice.get("finish_reason").isJsonNull()) {
                                                finishReason = choice.get("finish_reason").getAsString();
                                            }
                                        }
                                    }
                                } catch (Exception e) {
                                    handler.onError(new APIProviderException(APIProviderException.ErrorCategory.RESPONSE_ERROR,
                                        name, "streamChatCompletionWithFunctions", "Failed to parse streaming chunk: " + e.getMessage()));
                                    return;
                                }
                            }
                        }

                        if (isCancelled) {
                            handler.onError(new APIProviderException(APIProviderException.ErrorCategory.CANCELLED,
                                name, "streamChatCompletionWithFunctions", "Request cancelled"));
                        } else if (!handler.shouldContinue()) {
                            handler.onError(new APIProviderException(APIProviderException.ErrorCategory.CANCELLED,
                                name, "streamChatCompletionWithFunctions", "Request cancelled"));
                        }
                    } catch (IOException e) {
                        handler.onError(new APIProviderException(APIProviderException.ErrorCategory.RESPONSE_ERROR,
                            name, "streamChatCompletionWithFunctions", "Stream interrupted: " + e.getMessage()));
                    }
                }
            }
        });
    }

    public void cancelRequest() {
        isCancelled = true;
    }
}

```

`src/main/java/ghidrassist/apiprovider/LiteLLMProvider.java`:

```java
package ghidrassist.apiprovider;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;

import ghidra.util.Msg;
import ghidrassist.LlmApi;
import ghidrassist.apiprovider.exceptions.*;
import okhttp3.*;
import okio.BufferedSource;

import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * LiteLLM Provider - Implementation for LiteLLM proxy API.
 * Handles AWS Bedrock and other providers via LiteLLM proxy.
 *
 * LiteLLM provides an OpenAI-compatible API but does NOT perform payload
 * translation for provider-specific features like Anthropic's extended thinking.
 * This applies regardless of whether the backend is direct Anthropic or Bedrock.
 *
 * Known quirks handled:
 * 1. Anthropic models with extended thinking require specific message formats
 *    that LiteLLM doesn't translate - thinking blocks must be preserved
 * 2. Model family and Bedrock detection from model name AND URL patterns
 * 3. LiteLLM model aliases (e.g., "claude-sonnet-4-5") that route to Bedrock
 * 4. Message format translation for thinking blocks
 */
public class LiteLLMProvider extends OpenAIPlatformApiProvider {

    private static final Gson gson = new Gson();
    private static final MediaType JSON = MediaType.get("application/json; charset=utf-8");

    // Retry settings for streaming calls
    private static final int MAX_STREAMING_RETRIES = 10;
    private static final int MIN_RETRY_BACKOFF_MS = 10000;  // 10 seconds
    private static final int MAX_RETRY_BACKOFF_MS = 30000;  // 30 seconds

    private final String modelFamily;
    private final boolean isBedrock;
    private final boolean isAnthropicCompatible;
    private boolean warnedAboutThinking = false;
    private volatile boolean isCancelled = false;

    public LiteLLMProvider(String name, String model, Integer maxTokens, String url,
                           String key, boolean disableTlsVerification, Integer timeout) {
        super(name, model, maxTokens, url, key, disableTlsVerification, timeout);

        // Override the type to LITELLM
        this.type = ProviderType.LITELLM;

        // Detect model characteristics from both model name AND URL
        this.isBedrock = detectIsBedrock(model, url);
        this.modelFamily = detectModelFamily(model);
        this.isAnthropicCompatible = "anthropic".equals(modelFamily);

        Msg.info(this, String.format(
                "LiteLLM provider initialized - Model: %s, Family: %s, Bedrock: %s, AnthropicCompatible: %s",
                model, modelFamily, isBedrock, isAnthropicCompatible));

        if (isAnthropicCompatible) {
            Msg.info(this, "LiteLLM: Anthropic-compatible model detected. " +
                    "Extended thinking will use proper message format translation.");
        }
    }

    public static LiteLLMProvider fromConfig(APIProviderConfig config) {
        return new LiteLLMProvider(
            config.getName(),
            config.getModel(),
            config.getMaxTokens(),
            config.getUrl(),
            config.getKey(),
            config.isDisableTlsVerification(),
            config.getTimeout()
        );
    }

    /**
     * Detect if this is a Bedrock model.
     * Checks both model name patterns AND URL patterns.
     *
     * Detection sources:
     * 1. Model name prefix "bedrock/" (LiteLLM standard format)
     * 2. Model name prefix "bedrock-" (alternative format like "bedrock-claude-opus-4-5")
     * 3. Model name contains "bedrock" anywhere
     * 4. URL contains AWS/Bedrock patterns (amazonaws.com, bedrock, etc.)
     * 5. Common Bedrock model aliases (claude-sonnet-4-5, claude-opus-4, etc.)
     */
    private boolean detectIsBedrock(String model, String url) {
        if (model == null) return false;
        String lowerModel = model.toLowerCase();
        String lowerUrl = url != null ? url.toLowerCase() : "";

        // Direct model name detection - both slash and hyphen prefixes
        if (lowerModel.startsWith("bedrock/") || lowerModel.startsWith("bedrock-") ||
            lowerModel.contains("bedrock")) {
            Msg.info(this, "LiteLLM: Detected Bedrock model from name: " + model);
            return true;
        }

        // URL-based detection for AWS/Bedrock
        if (lowerUrl.contains("amazonaws.com") ||
            lowerUrl.contains("bedrock") ||
            lowerUrl.contains(".aws.") ||
            lowerUrl.contains("aws-")) {
            Msg.info(this, "LiteLLM: Detected Bedrock from URL pattern: " + url);
            return true;
        }

        // Common LiteLLM model aliases that typically route to Bedrock
        // These are Anthropic model aliases that LiteLLM maps to Bedrock
        if (lowerModel.matches("claude-(sonnet|opus|haiku)-\\d.*") ||
            lowerModel.matches("anthropic[./].*") ||
            lowerModel.matches("claude-\\d.*-sonnet.*") ||
            lowerModel.matches("claude-\\d.*-opus.*") ||
            lowerModel.matches("claude-\\d.*-haiku.*")) {

            // These could be either direct Anthropic or Bedrock
            // Check if URL suggests direct Anthropic API
            if (lowerUrl.contains("anthropic.com") || lowerUrl.contains("api.anthropic")) {
                return false; // Direct Anthropic, not Bedrock
            }

            // If it's a Claude model alias and not direct Anthropic API,
            // it's likely Bedrock (common LiteLLM setup)
            Msg.info(this, "LiteLLM: Claude model alias '" + model +
                    "' detected - assuming Bedrock routing (use native Anthropic provider for direct API)");
            return true;
        }

        return false;
    }

    /**
     * Detect the underlying model family from the model name.
     *
     * Examples:
     * - bedrock/anthropic.claude-3-5-sonnet-20241022-v2:0 -> anthropic
     * - bedrock-claude-opus-4-5 -> anthropic (hyphen prefix format)
     * - bedrock/amazon.nova-pro-v1:0 -> amazon
     * - bedrock/meta.llama3-70b-instruct-v1:0 -> meta
     * - claude-sonnet-4-5 -> anthropic (alias)
     * - claude-3-5-sonnet -> anthropic (non-Bedrock)
     * - gpt-4o -> openai (non-Bedrock)
     */
    private String detectModelFamily(String model) {
        if (model == null) return "unknown";
        String lowerModel = model.toLowerCase();

        // Bedrock models with slash format: bedrock/<provider>.<model-name>
        if (lowerModel.startsWith("bedrock/")) {
            if (lowerModel.contains("anthropic") || lowerModel.contains("claude")) {
                return "anthropic";
            } else if (lowerModel.contains("amazon") || lowerModel.contains("nova") || lowerModel.contains("titan")) {
                return "amazon";
            } else if (lowerModel.contains("meta") || lowerModel.contains("llama")) {
                return "meta";
            } else if (lowerModel.contains("cohere")) {
                return "cohere";
            } else if (lowerModel.contains("ai21")) {
                return "ai21";
            } else if (lowerModel.contains("mistral")) {
                return "mistral";
            }
        }

        // Bedrock models with hyphen format: bedrock-<model-name>
        if (lowerModel.startsWith("bedrock-")) {
            String modelPart = lowerModel.substring(8); // Remove "bedrock-" prefix
            if (modelPart.contains("claude") || modelPart.contains("anthropic")) {
                return "anthropic";
            } else if (modelPart.contains("nova") || modelPart.contains("titan") || modelPart.contains("amazon")) {
                return "amazon";
            } else if (modelPart.contains("llama") || modelPart.contains("meta")) {
                return "meta";
            } else if (modelPart.contains("mistral")) {
                return "mistral";
            }
        }

        // Non-Bedrock or alias models
        if (lowerModel.contains("claude") || lowerModel.contains("anthropic")) {
            return "anthropic";
        } else if (lowerModel.contains("gpt") || lowerModel.contains("openai") || lowerModel.startsWith("o1") || lowerModel.startsWith("o3")) {
            return "openai";
        } else if (lowerModel.contains("gemini") || lowerModel.contains("google")) {
            return "google";
        } else if (lowerModel.contains("llama") || lowerModel.contains("meta")) {
            return "meta";
        } else if (lowerModel.contains("mistral")) {
            return "mistral";
        }

        return "unknown";
    }

    /**
     * Build chat completion payload with LiteLLM/Bedrock quirks handled.
     *
     * LiteLLM Quirks (apply to ALL models):
     * 1. Skip reasoning_effort parameter (not supported via LiteLLM proxy)
     * 2. Always include tools array (even empty) for Bedrock compatibility
     *
     * Anthropic-specific quirks:
     * 3. Format messages with proper thinking block structure
     * 4. Temperature must be 1 when thinking is enabled
     */
    private JsonObject buildLiteLLMPayload(List<ChatMessage> messages, boolean stream,
                                            List<Map<String, Object>> functions) {
        JsonObject payload = new JsonObject();
        payload.addProperty("model", super.getModel());
        payload.addProperty("max_tokens", super.getMaxTokens());
        payload.addProperty("stream", stream);

        ReasoningConfig reasoning = super.getReasoningConfig();
        boolean thinkingEnabled = reasoning != null && reasoning.isEnabled();

        // LITELLM QUIRK #1: Skip reasoning_effort parameter for ALL LiteLLM providers
        // LiteLLM/Bedrock doesn't support this OpenAI-style parameter
        if (thinkingEnabled && !warnedAboutThinking) {
            Msg.warn(this, "LiteLLM: reasoning_effort parameter skipped (not supported via LiteLLM proxy). " +
                    "Extended thinking may still work if enabled in model/server config.");
            warnedAboutThinking = true;
        }

        // LITELLM QUIRK #2: Temperature must be 1 when thinking is enabled for Anthropic
        if (thinkingEnabled && isAnthropicCompatible) {
            payload.addProperty("temperature", 1);
        }

        // Build messages array - only use thinking block format for Anthropic models
        JsonArray messagesArray = new JsonArray();
        for (ChatMessage message : messages) {
            JsonObject messageObj = buildMessageObject(message, thinkingEnabled && isAnthropicCompatible);
            messagesArray.add(messageObj);
        }
        payload.add("messages", messagesArray);

        // LITELLM/BEDROCK QUIRK #3: Always include tools array for compatibility
        // Bedrock requires tools=[] even when not using tools
        if (functions != null && !functions.isEmpty()) {
            payload.add("tools", gson.toJsonTree(functions));
        } else {
            // Add empty tools array for Bedrock compatibility
            payload.add("tools", new JsonArray());
            Msg.debug(this, "LiteLLM: Added empty tools array for Bedrock compatibility");
        }

        return payload;
    }

    /**
     * Build a message object with proper format for the target model.
     *
     * @param message The chat message to format
     * @param useAnthropicThinkingFormat If true, format thinking blocks for Anthropic models.
     *                                    If false, use standard OpenAI format.
     */
    private JsonObject buildMessageObject(ChatMessage message, boolean useAnthropicThinkingFormat) {
        JsonObject messageObj = new JsonObject();
        messageObj.addProperty("role", message.getRole());

        // Check if this message has thinking data
        boolean hasThinking = message.getThinkingContent() != null ||
                              message.getThinkingSignature() != null;

        // For Anthropic models with thinking enabled AND assistant messages,
        // we MUST include thinking blocks (either real or redacted)
        if (useAnthropicThinkingFormat && "assistant".equals(message.getRole())) {
            JsonArray contentBlocks = new JsonArray();

            if (hasThinking && message.getThinkingContent() != null) {
                // Add actual thinking block first (Anthropic requirement)
                JsonObject thinkingBlock = new JsonObject();
                thinkingBlock.addProperty("type", "thinking");
                thinkingBlock.addProperty("thinking", message.getThinkingContent());
                if (message.getThinkingSignature() != null) {
                    thinkingBlock.addProperty("signature", message.getThinkingSignature());
                }
                contentBlocks.add(thinkingBlock);
            } else {
                // No thinking content stored - add redacted_thinking block
                // This is required by Bedrock when thinking is enabled globally
                // "When thinking is enabled, a final assistant message must start with a thinking block"
                JsonObject redactedBlock = new JsonObject();
                redactedBlock.addProperty("type", "redacted_thinking");
                redactedBlock.addProperty("data", ""); // Empty redacted block
                contentBlocks.add(redactedBlock);
                Msg.debug(this, "LiteLLM: Added redacted_thinking block for historical assistant message");
            }

            // Add text content block
            if (message.getContent() != null && !message.getContent().isEmpty()) {
                JsonObject textBlock = new JsonObject();
                textBlock.addProperty("type", "text");
                textBlock.addProperty("text", message.getContent());
                contentBlocks.add(textBlock);
            }

            messageObj.add("content", contentBlocks);
        } else {
            // Standard OpenAI format - simple string content
            // This is used for ALL non-Anthropic models and user/system messages
            if (message.getContent() != null) {
                messageObj.addProperty("content", message.getContent());
            }
        }

        // Handle tool calls for assistant messages
        if (message.getToolCalls() != null) {
            messageObj.add("tool_calls", message.getToolCalls());
        }

        // Handle tool call ID for tool response messages
        if (message.getToolCallId() != null) {
            messageObj.addProperty("tool_call_id", message.getToolCallId());
        }

        return messageObj;
    }

    /**
     * Override streaming with functions to use LiteLLM-specific payload building.
     */
    @Override
    public void streamChatCompletionWithFunctions(
            List<ChatMessage> messages,
            List<Map<String, Object>> functions,
            StreamingFunctionHandler handler
    ) throws APIProviderException {
        JsonObject payload = buildLiteLLMPayload(messages, true, functions);
        Msg.debug(this, "LiteLLM request payload: " + payload.toString());
        executeStreamingFunctionsWithRetry(payload, handler, "stream_chat_completion_with_functions", 0);
    }

    /**
     * Execute streaming with functions request with retry logic for rate limits and transient errors.
     */
    private void executeStreamingFunctionsWithRetry(JsonObject payload, StreamingFunctionHandler handler,
                                                    String operation, int attemptNumber) {
        if (isCancelled) {
            handler.onError(new StreamCancelledException(name, operation,
                StreamCancelledException.CancellationReason.USER_REQUESTED));
            return;
        }

        Request request = new Request.Builder()
                .url(url + "chat/completions")
                .post(RequestBody.create(gson.toJson(payload), JSON))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                if (call.isCanceled()) {
                    handler.onError(new StreamCancelledException(name, operation,
                            StreamCancelledException.CancellationReason.USER_REQUESTED, e));
                    return;
                }

                APIProviderException error = handleNetworkError(e, operation);
                if (shouldRetryStreaming(error, attemptNumber)) {
                    retryStreamingFunctionsAfterDelay(payload, handler, operation, attemptNumber, error);
                } else {
                    handler.onError(error);
                }
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (!response.isSuccessful()) {
                        APIProviderException error = handleHttpError(response, operation);
                        if (shouldRetryStreaming(error, attemptNumber)) {
                            retryStreamingFunctionsAfterDelay(payload, handler, operation, attemptNumber, error);
                        } else {
                            handler.onError(error);
                        }
                        return;
                    }

                    if (responseBody == null) {
                        handler.onError(new ResponseException(name, operation,
                                ResponseException.ResponseErrorType.EMPTY_RESPONSE));
                        return;
                    }

                    BufferedSource source = responseBody.source();
                    StringBuilder textBuilder = new StringBuilder();
                    java.util.Map<Integer, ToolCallAccumulator> toolCallsMap = new java.util.HashMap<>();
                    String finishReason = "stop";

                    try {
                        while (!source.exhausted() && !isCancelled && handler.shouldContinue()) {
                            String line = source.readUtf8Line();
                            if (line == null || line.isEmpty()) continue;

                            if (line.startsWith("data: ")) {
                                String data = line.substring(6).trim();
                                if (data.equals("[DONE]")) {
                                    // Process complete - convert accumulated tool calls
                                    java.util.List<ToolCall> toolCalls = new java.util.ArrayList<>();
                                    toolCallsMap.entrySet().stream()
                                            .sorted(java.util.Map.Entry.comparingByKey())
                                            .forEach(entry -> {
                                                ToolCallAccumulator acc = entry.getValue();
                                                String args = acc.argumentsBuffer.toString().trim();
                                                if (args.isEmpty()) {
                                                    args = "{}";
                                                }
                                                toolCalls.add(new ToolCall(acc.id, acc.name, args));
                                            });

                                    handler.onStreamComplete(finishReason, textBuilder.toString(), toolCalls);
                                    return;
                                }

                                try {
                                    JsonObject chunk = gson.fromJson(data, JsonObject.class);

                                    if (chunk.has("choices")) {
                                        com.google.gson.JsonArray choices = chunk.getAsJsonArray("choices");
                                        if (choices.size() > 0) {
                                            JsonObject choice = choices.get(0).getAsJsonObject();

                                            if (choice.has("delta")) {
                                                JsonObject delta = choice.getAsJsonObject("delta");

                                                // Stream text content immediately
                                                if (delta.has("content") && !delta.get("content").isJsonNull()) {
                                                    String content = delta.get("content").getAsString();
                                                    textBuilder.append(content);
                                                    handler.onTextUpdate(content);
                                                }

                                                // Buffer tool calls
                                                if (delta.has("tool_calls")) {
                                                    com.google.gson.JsonArray toolCallDeltas = delta.getAsJsonArray("tool_calls");
                                                    for (com.google.gson.JsonElement tcElement : toolCallDeltas) {
                                                        JsonObject toolCallDelta = tcElement.getAsJsonObject();
                                                        int index = toolCallDelta.has("index") ? toolCallDelta.get("index").getAsInt() : 0;

                                                        ToolCallAccumulator acc = toolCallsMap.computeIfAbsent(index, k -> new ToolCallAccumulator());

                                                        if (toolCallDelta.has("id")) {
                                                            acc.id = toolCallDelta.get("id").getAsString();
                                                        }

                                                        if (toolCallDelta.has("function")) {
                                                            JsonObject functionDelta = toolCallDelta.getAsJsonObject("function");
                                                            if (functionDelta.has("name")) {
                                                                acc.name = functionDelta.get("name").getAsString();
                                                            }
                                                            if (functionDelta.has("arguments")) {
                                                                acc.argumentsBuffer.append(functionDelta.get("arguments").getAsString());
                                                            }
                                                        }
                                                    }
                                                }
                                            }

                                            if (choice.has("finish_reason") && !choice.get("finish_reason").isJsonNull()) {
                                                finishReason = choice.get("finish_reason").getAsString();
                                            }
                                        }
                                    }
                                } catch (com.google.gson.JsonSyntaxException e) {
                                    handler.onError(new ResponseException(name, operation,
                                            ResponseException.ResponseErrorType.MALFORMED_JSON, e));
                                    return;
                                }
                            }
                        }

                        if (isCancelled) {
                            handler.onError(new StreamCancelledException(name, operation,
                                    StreamCancelledException.CancellationReason.USER_REQUESTED));
                        } else if (!handler.shouldContinue()) {
                            handler.onError(new StreamCancelledException(name, operation,
                                    StreamCancelledException.CancellationReason.USER_REQUESTED));
                        }
                    } catch (IOException e) {
                        handler.onError(new ResponseException(name, operation,
                                ResponseException.ResponseErrorType.STREAM_INTERRUPTED, e));
                    }
                }
            }
        });
    }

    /**
     * Retry streaming with functions request after appropriate delay.
     */
    private void retryStreamingFunctionsAfterDelay(JsonObject payload, StreamingFunctionHandler handler,
                                                   String operation, int attemptNumber, APIProviderException error) {
        int nextAttempt = attemptNumber + 1;
        int waitTimeMs = calculateStreamingRetryWait(error);

        Msg.warn(this, String.format("LiteLLM streaming functions retry %d/%d for %s: %s. Waiting %d seconds...",
            nextAttempt, MAX_STREAMING_RETRIES, operation,
            error.getCategory().getDisplayName(), waitTimeMs / 1000));

        new Thread(() -> {
            try {
                Thread.sleep(waitTimeMs);
                if (!isCancelled) {
                    executeStreamingFunctionsWithRetry(payload, handler, operation, nextAttempt);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                handler.onError(new StreamCancelledException(name, operation,
                    StreamCancelledException.CancellationReason.USER_REQUESTED));
            }
        }, "LiteLLMProvider-StreamFunctionsRetry").start();
    }

    /**
     * Override standard streaming to use LiteLLM-specific payload building.
     */
    @Override
    public void streamChatCompletion(List<ChatMessage> messages, LlmApi.LlmResponseHandler handler)
            throws APIProviderException {
        JsonObject payload = buildLiteLLMPayload(messages, true, null);
        executeStreamingWithRetry(payload, handler, "stream_chat_completion", 0);
    }

    /**
     * Execute streaming request with retry logic for rate limits and transient errors.
     */
    private void executeStreamingWithRetry(JsonObject payload, LlmApi.LlmResponseHandler handler,
                                           String operation, int attemptNumber) {
        if (isCancelled) {
            handler.onError(new StreamCancelledException(name, operation,
                StreamCancelledException.CancellationReason.USER_REQUESTED));
            return;
        }

        Request request = new Request.Builder()
                .url(url + "chat/completions")
                .post(RequestBody.create(gson.toJson(payload), JSON))
                .build();

        client.newCall(request).enqueue(new Callback() {
            private boolean isFirst = true;

            @Override
            public void onFailure(Call call, IOException e) {
                if (call.isCanceled()) {
                    handler.onError(new StreamCancelledException(name, operation,
                            StreamCancelledException.CancellationReason.USER_REQUESTED, e));
                    return;
                }

                APIProviderException error = handleNetworkError(e, operation);
                if (shouldRetryStreaming(error, attemptNumber)) {
                    retryStreamingAfterDelay(payload, handler, operation, attemptNumber, error);
                } else {
                    handler.onError(error);
                }
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (!response.isSuccessful()) {
                        APIProviderException error = handleHttpError(response, operation);
                        if (shouldRetryStreaming(error, attemptNumber)) {
                            retryStreamingAfterDelay(payload, handler, operation, attemptNumber, error);
                        } else {
                            handler.onError(error);
                        }
                        return;
                    }

                    if (responseBody == null) {
                        handler.onError(new ResponseException(name, operation,
                                ResponseException.ResponseErrorType.EMPTY_RESPONSE));
                        return;
                    }

                    BufferedSource source = responseBody.source();
                    StringBuilder contentBuilder = new StringBuilder();

                    try {
                        while (!source.exhausted() && !isCancelled && handler.shouldContinue()) {
                            String line = source.readUtf8Line();
                            if (line == null || line.isEmpty()) continue;

                            if (line.startsWith("data: ")) {
                                String data = line.substring(6).trim();
                                if (data.equals("[DONE]")) {
                                    handler.onComplete(contentBuilder.toString());
                                    return;
                                }

                                try {
                                    JsonObject chunk = gson.fromJson(data, JsonObject.class);
                                    String content = extractDeltaContent(chunk);

                                    if (content != null) {
                                        if (isFirst) {
                                            handler.onStart();
                                            isFirst = false;
                                        }
                                        contentBuilder.append(content);
                                        handler.onUpdate(content);
                                    }
                                } catch (com.google.gson.JsonSyntaxException e) {
                                    handler.onError(new ResponseException(name, operation,
                                            ResponseException.ResponseErrorType.MALFORMED_JSON, e));
                                    return;
                                }
                            }
                        }

                        if (isCancelled) {
                            handler.onError(new StreamCancelledException(name, operation,
                                    StreamCancelledException.CancellationReason.USER_REQUESTED));
                        } else if (!handler.shouldContinue()) {
                            handler.onError(new StreamCancelledException(name, operation,
                                    StreamCancelledException.CancellationReason.USER_REQUESTED));
                        }
                    } catch (IOException e) {
                        handler.onError(new ResponseException(name, operation,
                                ResponseException.ResponseErrorType.STREAM_INTERRUPTED, e));
                    }
                }
            }
        });
    }

    /**
     * Retry streaming request after appropriate delay.
     */
    private void retryStreamingAfterDelay(JsonObject payload, LlmApi.LlmResponseHandler handler,
                                          String operation, int attemptNumber, APIProviderException error) {
        int nextAttempt = attemptNumber + 1;
        int waitTimeMs = calculateStreamingRetryWait(error);

        Msg.warn(this, String.format("LiteLLM streaming retry %d/%d for %s: %s. Waiting %d seconds...",
            nextAttempt, MAX_STREAMING_RETRIES, operation,
            error.getCategory().getDisplayName(), waitTimeMs / 1000));

        new Thread(() -> {
            try {
                Thread.sleep(waitTimeMs);
                if (!isCancelled) {
                    executeStreamingWithRetry(payload, handler, operation, nextAttempt);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                handler.onError(new StreamCancelledException(name, operation,
                    StreamCancelledException.CancellationReason.USER_REQUESTED));
            }
        }, "LiteLLMProvider-StreamRetry").start();
    }

    /**
     * Check if a streaming error should be retried.
     */
    private boolean shouldRetryStreaming(APIProviderException error, int attemptNumber) {
        if (attemptNumber >= MAX_STREAMING_RETRIES) {
            return false;
        }
        switch (error.getCategory()) {
            case RATE_LIMIT:
            case NETWORK:
            case TIMEOUT:
            case SERVICE_ERROR:
                return true;
            default:
                return false;
        }
    }

    /**
     * Calculate wait time for streaming retry with jitter.
     */
    private int calculateStreamingRetryWait(APIProviderException error) {
        if (error.getCategory() == APIProviderException.ErrorCategory.RATE_LIMIT) {
            Integer retryAfter = error.getRetryAfterSeconds();
            if (retryAfter != null && retryAfter > 0) {
                return retryAfter * 1000;
            }
        }
        return MIN_RETRY_BACKOFF_MS + (int) (Math.random() * (MAX_RETRY_BACKOFF_MS - MIN_RETRY_BACKOFF_MS));
    }

    /**
     * Cancel any ongoing requests.
     */
    @Override
    public void cancelRequest() {
        isCancelled = true;
        super.cancelRequest();
    }

    /**
     * Extract delta content from a streaming chunk.
     */
    private String extractDeltaContent(JsonObject chunk) {
        try {
            JsonObject delta = chunk.getAsJsonArray("choices")
                    .get(0).getAsJsonObject()
                    .getAsJsonObject("delta");

            if (delta.has("content")) {
                return delta.get("content").getAsString();
            }
        } catch (Exception e) {
            // Handle any JSON parsing errors silently and return null
        }
        return null;
    }

    /**
     * Helper class to accumulate tool call deltas during streaming.
     */
    private static class ToolCallAccumulator {
        String id;
        String name;
        final StringBuilder argumentsBuffer = new StringBuilder();
    }

    /**
     * Override non-streaming function call to handle Bedrock quirk:
     * "Thinking may not be enabled when tool_choice forces tool use."
     *
     * When tool_choice is "required", we must NOT include any thinking/reasoning
     * configuration for Anthropic models on Bedrock.
     */
    @Override
    public String createChatCompletionWithFunctions(List<ChatMessage> messages,
                                                     List<Map<String, Object>> functions) throws APIProviderException {
        // Build payload WITHOUT thinking enabled (tool_choice will be "required")
        JsonObject payload = buildToolCallPayload(messages, functions, true);

        Request request = new Request.Builder()
                .url(url + "chat/completions")
                .post(RequestBody.create(gson.toJson(payload), JSON))
                .build();

        try (Response response = executeWithRetry(request, "createChatCompletionWithFunctions")) {
            String responseBody = response.body().string();
            return parseToolCallResponse(responseBody);
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletionWithFunctions");
        }
    }

    /**
     * Override non-streaming full response function call.
     */
    @Override
    public String createChatCompletionWithFunctionsFullResponse(List<ChatMessage> messages,
                                                                  List<Map<String, Object>> functions) throws APIProviderException {
        // Build payload WITHOUT thinking enabled
        JsonObject payload = buildToolCallPayload(messages, functions, false);

        Request request = new Request.Builder()
                .url(url + "chat/completions")
                .post(RequestBody.create(gson.toJson(payload), JSON))
                .build();

        try (Response response = executeWithRetry(request, "createChatCompletionWithFunctionsFullResponse")) {
            return response.body().string();
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletionWithFunctionsFullResponse");
        }
    }

    /**
     * Build payload for tool/function calls.
     * CRITICAL: Thinking must be DISABLED when tool_choice forces tool use.
     *
     * @param messages Chat messages
     * @param functions Tool/function definitions
     * @param forceToolUse If true, set tool_choice to "required"
     */
    private JsonObject buildToolCallPayload(List<ChatMessage> messages,
                                             List<Map<String, Object>> functions,
                                             boolean forceToolUse) {
        JsonObject payload = new JsonObject();
        payload.addProperty("model", super.getModel());
        payload.addProperty("max_tokens", super.getMaxTokens());
        payload.addProperty("stream", false);

        // CRITICAL: Do NOT include reasoning/thinking when using tool_choice
        // Bedrock error: "Thinking may not be enabled when tool_choice forces tool use."
        // So we intentionally skip all thinking-related configuration here

        // Build messages array - use standard format (no thinking blocks)
        JsonArray messagesArray = new JsonArray();
        for (ChatMessage message : messages) {
            // Always use standard format for tool calls - no thinking block translation
            JsonObject messageObj = buildMessageObject(message, false);
            messagesArray.add(messageObj);
        }
        payload.add("messages", messagesArray);

        // Add tools
        if (functions != null && !functions.isEmpty()) {
            payload.add("tools", gson.toJsonTree(functions));
        } else {
            payload.add("tools", new JsonArray());
        }

        // Set tool_choice if forcing tool use
        if (forceToolUse) {
            payload.addProperty("tool_choice", "required");
        }

        Msg.debug(this, "LiteLLM tool call payload (thinking disabled): " + payload.toString());
        return payload;
    }

    /**
     * Parse tool call response and return in standard {"tool_calls":[...]} format.
     * Handles both OpenAI format and Anthropic/Bedrock format.
     *
     * OpenAI format:
     *   choices[0].message.tool_calls[0].function.arguments
     *
     * Anthropic/Bedrock format (via LiteLLM):
     *   choices[0].message.content[] with type="tool_use", input={...}
     *   OR direct content array with tool_use blocks
     *
     * Returns: {"tool_calls":[{"function":{"name":"...", "arguments":{...}}}]}
     */
    private String parseToolCallResponse(String responseBody) throws APIProviderException {
        try {
            Msg.debug(this, "LiteLLM parsing response: " + responseBody);
            JsonObject jsonResponse = gson.fromJson(responseBody, JsonObject.class);

            if (jsonResponse.has("choices")) {
                JsonArray choices = jsonResponse.getAsJsonArray("choices");
                if (choices.size() > 0) {
                    JsonObject choice = choices.get(0).getAsJsonObject();
                    if (choice.has("message")) {
                        JsonObject message = choice.getAsJsonObject("message");

                        // Format 1: OpenAI style - tool_calls array
                        if (message.has("tool_calls")) {
                            JsonArray toolCalls = message.getAsJsonArray("tool_calls");
                            String result = "{\"tool_calls\":" + toolCalls.toString() + "}";
                            Msg.debug(this, "LiteLLM parsed OpenAI tool_calls format: " + result);
                            return result;
                        }

                        // Format 2: Anthropic/Bedrock style - content array with tool_use blocks
                        if (message.has("content")) {
                            com.google.gson.JsonElement contentElement = message.get("content");

                            // Content could be an array (Anthropic format)
                            if (contentElement.isJsonArray()) {
                                JsonArray contentArray = contentElement.getAsJsonArray();
                                JsonArray convertedToolCalls = convertToolUseToToolCalls(contentArray);
                                if (convertedToolCalls.size() > 0) {
                                    String result = "{\"tool_calls\":" + convertedToolCalls.toString() + "}";
                                    Msg.debug(this, "LiteLLM parsed Anthropic tool_use format: " + result);
                                    return result;
                                }
                            }
                        }
                    }
                }
            }

            // Format 3: Direct Anthropic API response (content at top level)
            if (jsonResponse.has("content")) {
                com.google.gson.JsonElement contentElement = jsonResponse.get("content");
                if (contentElement.isJsonArray()) {
                    JsonArray contentArray = contentElement.getAsJsonArray();
                    JsonArray convertedToolCalls = convertToolUseToToolCalls(contentArray);
                    if (convertedToolCalls.size() > 0) {
                        String result = "{\"tool_calls\":" + convertedToolCalls.toString() + "}";
                        Msg.debug(this, "LiteLLM parsed direct Anthropic format: " + result);
                        return result;
                    }
                }
            }

            Msg.warn(this, "LiteLLM: Could not find tool call in response: " + responseBody);
            // Return empty tool_calls if nothing found
            return "{\"tool_calls\":[]}";
        } catch (Exception e) {
            throw new ResponseException(name, "createChatCompletionWithFunctions",
                    ResponseException.ResponseErrorType.MALFORMED_JSON, e);
        }
    }

    /**
     * Convert Anthropic tool_use content blocks to OpenAI-style tool_calls array.
     *
     * Anthropic format:
     *   { "type": "tool_use", "id": "...", "name": "func_name", "input": {...} }
     *
     * OpenAI format:
     *   { "function": { "name": "func_name", "arguments": {...} }, "id": "..." }
     */
    private JsonArray convertToolUseToToolCalls(JsonArray contentArray) {
        JsonArray toolCalls = new JsonArray();

        for (com.google.gson.JsonElement item : contentArray) {
            if (!item.isJsonObject()) continue;

            JsonObject contentBlock = item.getAsJsonObject();
            if (!contentBlock.has("type")) continue;

            String type = contentBlock.get("type").getAsString();
            if ("tool_use".equals(type)) {
                JsonObject toolCall = new JsonObject();
                JsonObject function = new JsonObject();

                // Get function name
                if (contentBlock.has("name")) {
                    function.addProperty("name", contentBlock.get("name").getAsString());
                }

                // Get arguments (called "input" in Anthropic format)
                if (contentBlock.has("input")) {
                    // Keep as object, not string
                    function.add("arguments", contentBlock.get("input"));
                }

                toolCall.add("function", function);

                // Preserve ID if present
                if (contentBlock.has("id")) {
                    toolCall.addProperty("id", contentBlock.get("id").getAsString());
                }

                toolCalls.add(toolCall);
            }
        }

        return toolCalls;
    }

    /**
     * Get the detected model family.
     */
    public String getModelFamily() {
        return modelFamily;
    }

    /**
     * Check if this is a Bedrock model.
     */
    public boolean isBedrock() {
        return isBedrock;
    }

    /**
     * Check if this model uses Anthropic-compatible API.
     */
    public boolean isAnthropicCompatible() {
        return isAnthropicCompatible;
    }
}

```

`src/main/java/ghidrassist/apiprovider/OllamaProvider.java`:

```java
package ghidrassist.apiprovider;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.JsonSyntaxException;
import com.google.gson.stream.JsonReader;

import ghidrassist.LlmApi.LlmResponseHandler;
import ghidrassist.apiprovider.exceptions.APIProviderException;
import ghidrassist.apiprovider.capabilities.FunctionCallingProvider;
import ghidrassist.apiprovider.capabilities.ModelListProvider;
import ghidrassist.apiprovider.capabilities.EmbeddingProvider;
import okhttp3.*;
import okio.BufferedSource;

import javax.net.ssl.*;
import java.io.IOException;
import java.io.StringReader;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class OllamaProvider extends APIProvider implements FunctionCallingProvider, ModelListProvider, EmbeddingProvider {
    private static final Gson gson = new Gson();
    private static final MediaType JSON = MediaType.get("application/json; charset=utf-8");
    private static final String OLLAMA_CHAT_ENDPOINT = "api/chat";
    private static final String OLLAMA_EMBEDDINGS_ENDPOINT = "api/embed";
    private static final String OLLAMA_MODELS_ENDPOINT = "api/tags";
    private volatile boolean isCancelled = false;

    public OllamaProvider(String name, String model, Integer maxTokens, String url, String key, boolean disableTlsVerification, Integer timeout) {
        super(name, ProviderType.OLLAMA, model, maxTokens, url, key, disableTlsVerification, timeout);
    }

    @Override
    protected OkHttpClient buildClient() {
        try {
            OkHttpClient.Builder builder = new OkHttpClient.Builder()
                .connectTimeout(super.timeout)
                .readTimeout(super.timeout)
                .writeTimeout(super.timeout)
                .retryOnConnectionFailure(true)
                .addInterceptor(chain -> {
                    Request originalRequest = chain.request();
                    Request.Builder requestBuilder = originalRequest.newBuilder()
                        .header("Authorization", "Bearer " + key)
                        .header("Content-Type", "application/json");
                    
                    if (!originalRequest.method().equals("GET")) {
                        requestBuilder.header("Accept", "application/json");
                    }
                    
                    return chain.proceed(requestBuilder.build());
                });

            if (disableTlsVerification) {
                TrustManager[] trustAllCerts = new TrustManager[]{
                    new X509TrustManager() {
                        @Override
                        public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) {}
                        @Override
                        public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) {}
                        @Override
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return new java.security.cert.X509Certificate[]{};
                        }
                    }
                };

                SSLContext sslContext = SSLContext.getInstance("TLS");
                sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
                builder.sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustAllCerts[0])
                       .hostnameVerifier((hostname, session) -> true);
            }

            return builder.build();
        } catch (Exception e) {
            throw new RuntimeException("Failed to build HTTP client", e);
        }
    }

    @Override
    public String createChatCompletion(List<ChatMessage> messages) throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, false);
        
        Request request = new Request.Builder()
            .url(super.getUrl() + OLLAMA_CHAT_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        try (Response response = executeWithRetry(request, "createChatCompletion")) {
            JsonObject responseObj = gson.fromJson(response.body().string(), JsonObject.class);
            return extractContentFromResponse(responseObj);
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletion");
        }
    }

    @Override
    public void streamChatCompletion(List<ChatMessage> messages, LlmResponseHandler handler) throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, true);

        Request request = new Request.Builder()
            .url(super.getUrl() + OLLAMA_CHAT_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        client.newCall(request).enqueue(new Callback() {
            private boolean isFirst = true;
            private StringBuilder contentBuilder = new StringBuilder();

            @Override
            public void onFailure(Call call, IOException e) {
                handler.onError(handleNetworkError(e, "streamChatCompletion"));
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (!response.isSuccessful()) {
                        handler.onError(handleHttpError(response, "streamChatCompletion"));
                        return;
                    }

                    BufferedSource source = responseBody.source();
                    while (!source.exhausted() && !isCancelled && handler.shouldContinue()) {
                        String line = source.readUtf8Line();
                        if (line == null || line.isEmpty()) continue;

                        JsonObject chunk = gson.fromJson(line, JsonObject.class);
                        String content = extractStreamContent(chunk);
                        
                        if (content != null) {
                            if (isFirst) {
                                handler.onStart();
                                isFirst = false;
                            }
                            contentBuilder.append(content);
                            handler.onUpdate(content);
                        }

                        if (chunk.has("done") && chunk.get("done").getAsBoolean()) {
                            handler.onComplete(contentBuilder.toString());
                            return;
                        }
                    }

                    if (isCancelled) {
                        handler.onError(new APIProviderException(APIProviderException.ErrorCategory.CANCELLED,
                            name, "streamChatCompletion", "Request cancelled"));
                    }
                }
            }
        });
    }

    @Override
    public String createChatCompletionWithFunctionsFullResponse(List<ChatMessage> messages, List<Map<String, Object>> functions) throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, false);
        
        // Add tools (functions) to the payload
        payload.add("tools", gson.toJsonTree(functions));

        // Specify json output
        payload.addProperty("format", "json");

        Request request = new Request.Builder()
            .url(super.getUrl() + OLLAMA_CHAT_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        try (Response response = executeWithRetry(request, "createChatCompletionWithFunctionsFullResponse")) {
            JsonObject responseObj = gson.fromJson(response.body().string(), JsonObject.class);
            
            // Parse the response to create OpenAI-compatible format
            JsonObject fullResponse = new JsonObject();
            JsonArray choices = new JsonArray();
            JsonObject choice = new JsonObject();
            JsonObject message = new JsonObject();
            
            message.addProperty("role", "assistant");
            
            String finishReason = "stop";
            JsonArray toolCalls = null;
            String content = "";
            
            // Extract message from response
            if (responseObj.has("message")) {
                JsonObject responseMessage = responseObj.getAsJsonObject("message");
                
                // Check for native tool_calls first
                if (responseMessage.has("tool_calls")) {
                    JsonArray nativeToolCalls = responseMessage.getAsJsonArray("tool_calls");
                    toolCalls = convertNativeToolCallsToOpenAI(nativeToolCalls);
                    finishReason = "tool_calls";
                }
                
                // Extract content
                if (responseMessage.has("content")) {
                    content = responseMessage.get("content").getAsString();
                }
                
                // If no native tool calls, try parsing from content
                if (toolCalls == null || toolCalls.size() == 0) {
                    toolCalls = parseToolCallsFromContent(content);
                    if (toolCalls != null && toolCalls.size() > 0) {
                        finishReason = "tool_calls";
                    }
                }
            }
            
            // Set message content based on what we found
            if (toolCalls != null && toolCalls.size() > 0) {
                message.add("tool_calls", toolCalls);
                // Include content if present
                if (content != null && !content.trim().isEmpty()) {
                    message.addProperty("content", content);
                }
            } else {
                message.addProperty("content", content);
            }
            
            choice.add("message", message);
            choice.addProperty("finish_reason", finishReason);
            choice.addProperty("index", 0);
            choices.add(choice);
            
            fullResponse.add("choices", choices);
            fullResponse.addProperty("id", "chatcmpl-ollama-" + System.currentTimeMillis());
            fullResponse.addProperty("object", "chat.completion");
            fullResponse.addProperty("created", System.currentTimeMillis() / 1000);
            fullResponse.addProperty("model", this.model);
            
            return gson.toJson(fullResponse);
            
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletionWithFunctionsFullResponse");
        }
    }

    @Override
    public String createChatCompletionWithFunctions(List<ChatMessage> messages, List<Map<String, Object>> functions) throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, false);
        
        // Add tools (functions) to the payload
        payload.add("tools", gson.toJsonTree(functions));

        // Force tool use - "required" means model must use at least one tool
        payload.addProperty("tool_choice", "required");

        // Specify json output
        payload.add("format", gson.toJsonTree("json"));

        Request request = new Request.Builder()
            .url(super.getUrl() + OLLAMA_CHAT_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        try (Response response = executeWithRetry(request, "createChatCompletionWithFunctions")) {
            // Create a lenient JsonReader
            JsonReader jsonReader = new JsonReader(new StringReader(response.body().string()));
            jsonReader.setLenient(true);

            // Parse with lenient reader
            JsonObject responseObj = JsonParser.parseReader(jsonReader).getAsJsonObject();
            JsonObject message = responseObj.getAsJsonObject("message");

            // Check if tool_calls exists directly
            if (message.has("tool_calls")) {
                return "{\"tool_calls\":" + message.get("tool_calls").toString() + "}";
            }

            // If no tool_calls, check if content contains a JSON object
            if (message.has("content")) {
                String content = message.get("content").getAsString().trim();
                
                // Try to parse content as JSON if it looks like JSON
                if (content.startsWith("{") || content.startsWith("[")) {
                    try {
                        JsonElement contentJson = JsonParser.parseString(content);
                        
                        // Case 1: Content is a single function call
                        if (contentJson.isJsonObject()) {
                            JsonObject funcObj = contentJson.getAsJsonObject();
                            if (funcObj.has("name") && funcObj.has("arguments")) {
                                // Convert to tool_calls format
                                JsonArray toolCalls = new JsonArray();
                                JsonObject toolCall = new JsonObject();
                                JsonObject function = new JsonObject();
                                function.add("name", funcObj.get("name"));
                                function.add("arguments", funcObj.get("arguments"));
                                toolCall.add("function", function);
                                toolCalls.add(toolCall);
                                return "{\"tool_calls\":" + toolCalls.toString() + "}";
                            }
                        }
                        
                        // Case 2: Content is already a tool_calls array
                        if (contentJson.isJsonObject() && contentJson.getAsJsonObject().has("tool_calls")) {
                            return content;
                        }
                        
                        // Case 3: Content is an array of function calls
                        if (contentJson.isJsonArray()) {
                            JsonArray array = contentJson.getAsJsonArray();
                            JsonArray toolCalls = new JsonArray();
                            for (JsonElement elem : array) {
                                if (elem.isJsonObject()) {
                                    JsonObject funcObj = elem.getAsJsonObject();
                                    if (funcObj.has("name") && funcObj.has("arguments")) {
                                        JsonObject toolCall = new JsonObject();
                                        JsonObject function = new JsonObject();
                                        function.add("name", funcObj.get("name"));
                                        function.add("arguments", funcObj.get("arguments"));
                                        toolCall.add("function", function);
                                        toolCalls.add(toolCall);
                                    }
                                }
                            }
                            if (toolCalls.size() > 0) {
                                return "{\"tool_calls\":" + toolCalls.toString() + "}";
                            }
                        }
                    } catch (JsonSyntaxException e) {
                        // Content is not valid JSON, fall through to return original content
                    }
                }
                
                // If we couldn't parse as tool calls, return the original content
                return "{\"tool_calls\":[]}";
            }

            // No valid tool calls found
            return "{\"tool_calls\":[]}";
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletionWithFunctions");
        }
    }

    @Override
    public List<String> getAvailableModels() throws APIProviderException {
        Request request = new Request.Builder()
            .url(super.getUrl() + OLLAMA_MODELS_ENDPOINT)
            .build();

        try (Response response = executeWithRetry(request, "getAvailableModels")) {
            JsonObject responseObj = gson.fromJson(response.body().string(), JsonObject.class);
            List<String> modelIds = new ArrayList<>();
            JsonArray models = responseObj.getAsJsonArray("models");
            
            for (JsonElement model : models) {
                JsonObject modelObj = model.getAsJsonObject();
                String name = modelObj.get("name").getAsString();
                // Don't include model tags/versions in the name
                if (name.contains(":")) {
                    name = name.substring(0, name.indexOf(":"));
                }
                if (!modelIds.contains(name)) {
                    modelIds.add(name);
                }
            }
            
            return modelIds;
        } catch (IOException e) {
            throw handleNetworkError(e, "getAvailableModels");
        }
    }

    @Override
    public void getEmbeddingsAsync(String text, EmbeddingCallback callback) {
        JsonObject payload = new JsonObject();
        payload.addProperty("model", super.getModel());
        payload.addProperty("input", text);

        Request request = new Request.Builder()
            .url(super.getUrl() + OLLAMA_EMBEDDINGS_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callback.onError(handleNetworkError(e, "getEmbeddingsAsync"));
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (!response.isSuccessful()) {
                        callback.onError(handleHttpError(response, "getEmbeddingsAsync"));
                        return;
                    }

                    JsonObject responseObj = gson.fromJson(responseBody.string(), JsonObject.class);
                    JsonArray embeddingsArray = responseObj.getAsJsonArray("embeddings");


                    JsonArray embeddings = (JsonArray) embeddingsArray.get(0);
                    double[] embeddingArray = new double[embeddings.size()];
                    for (int i = 0; i < embeddings.size(); i++) {
                        embeddingArray[i] = embeddings.get(i).getAsDouble();
                    }
                    
                    callback.onSuccess(embeddingArray);
                } catch (Exception e) {
                    callback.onError(e);
                }
            }
        });
    }

    private JsonObject buildChatCompletionPayload(List<ChatMessage> messages, boolean stream) {
        JsonObject payload = new JsonObject();
        payload.addProperty("model", super.getModel());
        payload.addProperty("stream", stream);

        // Add think parameter if reasoning is configured
        ReasoningConfig reasoning = getReasoningConfig();
        if (reasoning != null && reasoning.isEnabled()) {
            // Use effort level string - works for gpt-oss and most thinking models
            payload.addProperty("think", reasoning.getEffortString());
        }

        JsonArray messagesArray = new JsonArray();
        for (ChatMessage message : messages) {
            JsonObject messageObj = new JsonObject();
            messageObj.addProperty("role", message.getRole());
            messageObj.addProperty("content", message.getContent());
            messagesArray.add(messageObj);
        }
        payload.add("messages", messagesArray);

        return payload;
    }



    private String extractContentFromResponse(JsonObject responseObj) {
        return responseObj.get("message")
            .getAsJsonObject()
            .get("content")
            .getAsString();
    }

    private String extractStreamContent(JsonObject chunk) {
        try {
            if (chunk.has("message")) {
                JsonObject message = chunk.getAsJsonObject("message");
                if (message.has("content")) {
                    return message.get("content").getAsString();
                }
            }
        } catch (Exception e) {
            // Handle any JSON parsing errors silently and return null
        }
        return null;
    }

    public void cancelRequest() {
        isCancelled = true;
    }
    
    /**
     * Parse tool calls from content and return in OpenAI format
     */
    private JsonArray parseToolCallsFromContent(String content) {
        if (content == null || content.trim().isEmpty()) {
            return null;
        }
        
        content = content.trim();
        
        // Try to parse content as JSON if it looks like JSON
        if (content.startsWith("{") || content.startsWith("[")) {
            try {
                JsonElement contentJson = JsonParser.parseString(content);
                
                // Case 1: Content is a single function call
                if (contentJson.isJsonObject()) {
                    JsonObject funcObj = contentJson.getAsJsonObject();
                    if (funcObj.has("name") && funcObj.has("arguments")) {
                        // Convert to tool_calls format
                        JsonArray toolCalls = new JsonArray();
                        JsonObject toolCall = new JsonObject();
                        toolCall.addProperty("id", "call_" + System.currentTimeMillis());
                        toolCall.addProperty("type", "function");
                        
                        JsonObject function = new JsonObject();
                        function.addProperty("name", funcObj.get("name").getAsString());
                        function.addProperty("arguments", gson.toJson(funcObj.get("arguments")));
                        toolCall.add("function", function);
                        
                        toolCalls.add(toolCall);
                        return toolCalls;
                    }
                }
                
                // Case 2: Content is array of function calls
                if (contentJson.isJsonArray()) {
                    JsonArray funcArray = contentJson.getAsJsonArray();
                    JsonArray toolCalls = new JsonArray();
                    
                    for (JsonElement funcElement : funcArray) {
                        if (funcElement.isJsonObject()) {
                            JsonObject funcObj = funcElement.getAsJsonObject();
                            if (funcObj.has("name") && funcObj.has("arguments")) {
                                JsonObject toolCall = new JsonObject();
                                toolCall.addProperty("id", "call_" + System.currentTimeMillis() + "_" + toolCalls.size());
                                toolCall.addProperty("type", "function");
                                
                                JsonObject function = new JsonObject();
                                function.addProperty("name", funcObj.get("name").getAsString());
                                function.addProperty("arguments", gson.toJson(funcObj.get("arguments")));
                                toolCall.add("function", function);
                                
                                toolCalls.add(toolCall);
                            }
                        }
                    }
                    
                    return toolCalls.size() > 0 ? toolCalls : null;
                }
                
                // Case 3: Content has tool_calls property
                if (contentJson.isJsonObject()) {
                    JsonObject obj = contentJson.getAsJsonObject();
                    if (obj.has("tool_calls")) {
                        JsonArray existingToolCalls = obj.getAsJsonArray("tool_calls");
                        // Convert to OpenAI format if needed
                        JsonArray toolCalls = new JsonArray();
                        for (JsonElement tcElement : existingToolCalls) {
                            if (tcElement.isJsonObject()) {
                                JsonObject tc = tcElement.getAsJsonObject();
                                if (!tc.has("id")) {
                                    tc.addProperty("id", "call_" + System.currentTimeMillis() + "_" + toolCalls.size());
                                }
                                if (!tc.has("type")) {
                                    tc.addProperty("type", "function");
                                }
                                toolCalls.add(tc);
                            }
                        }
                        return toolCalls.size() > 0 ? toolCalls : null;
                    }
                }
                
            } catch (Exception e) {
                // If parsing fails, return null
                return null;
            }
        }
        
        return null;
    }
    
    /**
     * Convert native Ollama tool calls to OpenAI format
     */
    private JsonArray convertNativeToolCallsToOpenAI(JsonArray nativeToolCalls) {
        JsonArray toolCalls = new JsonArray();
        
        for (JsonElement tcElement : nativeToolCalls) {
            if (tcElement.isJsonObject()) {
                JsonObject nativeToolCall = tcElement.getAsJsonObject();
                
                JsonObject toolCall = new JsonObject();
                toolCall.addProperty("id", "call_" + System.currentTimeMillis() + "_" + toolCalls.size());
                toolCall.addProperty("type", "function");
                
                // Extract function information
                if (nativeToolCall.has("function")) {
                    JsonObject nativeFunction = nativeToolCall.getAsJsonObject("function");
                    
                    JsonObject function = new JsonObject();
                    if (nativeFunction.has("name")) {
                        function.addProperty("name", nativeFunction.get("name").getAsString());
                    }
                    if (nativeFunction.has("arguments")) {
                        function.addProperty("arguments", gson.toJson(nativeFunction.get("arguments")));
                    }
                    
                    toolCall.add("function", function);
                    toolCalls.add(toolCall);
                }
            }
        }
        
        return toolCalls;
    }
}
```

`src/main/java/ghidrassist/apiprovider/OpenAIOAuthProvider.java`:

```java
package ghidrassist.apiprovider;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import ghidra.util.Msg;
import ghidrassist.LlmApi.LlmResponseHandler;
import ghidrassist.apiprovider.capabilities.FunctionCallingProvider;
import ghidrassist.apiprovider.capabilities.ModelListProvider;
import ghidrassist.apiprovider.exceptions.*;
import ghidrassist.apiprovider.oauth.OpenAIOAuthTokenManager;
import okhttp3.*;
import okio.BufferedSource;

import javax.net.ssl.*;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * OpenAI OAuth Provider - Uses OAuth authentication for ChatGPT Pro/Plus subscriptions.
 * 
 * This provider uses the Codex Responses API endpoint, implementing the same protocol
 * as the official Codex CLI (codex-cli-rs). Routes requests through the ChatGPT backend.
 * 
 * Key Features:
 * - OAuth PKCE authentication (no API key required)
 * - Automatic token refresh
 * - OpenAI Responses API format translation
 * - Streaming (required by Codex API)
 * - Function/tool calling support
 * 
 * CRITICAL Implementation Details:
 * - originator header MUST be "codex_cli_rs" (not "opencode")
 * - OpenAI-Beta header MUST include "responses=experimental"
 * - chatgpt-account-id header must be lowercase
 * - instructions MUST match the official Codex CLI prompt
 * - stream MUST be true (API requires streaming)
 * - store MUST be false
 */
public class OpenAIOAuthProvider extends APIProvider implements FunctionCallingProvider, ModelListProvider {
    
    private static final Gson gson = new Gson();
    private static final MediaType JSON = MediaType.get("application/json");
    
    // Codex API endpoint
    private static final String CODEX_API_ENDPOINT = "https://chatgpt.com/backend-api/codex/responses";
    
    // Default model
    private static final String DEFAULT_MODEL = "gpt-5.1-codex";
    
    private final OpenAIOAuthTokenManager tokenManager;
    private volatile boolean isCancelled = false;
    
    /**
     * Creates a new OpenAI OAuth provider.
     * 
     * @param name Provider name
     * @param model Model to use (user-specified, API will validate)
     * @param maxTokens Maximum tokens
     * @param url Ignored (uses fixed Codex endpoint)
     * @param key OAuth credentials as JSON, or empty for unauthenticated
     * @param disableTlsVerification TLS verification setting
     * @param timeout Timeout in seconds
     */
    public OpenAIOAuthProvider(String name, String model, Integer maxTokens, String url,
                               String key, boolean disableTlsVerification, Integer timeout) {
        super(name, ProviderType.OPENAI_OAUTH, 
              model != null && !model.isEmpty() ? model : DEFAULT_MODEL,
              maxTokens, CODEX_API_ENDPOINT, key, disableTlsVerification, timeout);
        
        // Initialize token manager with credentials from key field
        this.tokenManager = new OpenAIOAuthTokenManager(key);
        
        Msg.info(this, "OpenAI OAuth provider initialized with model: " + this.model);
    }
    
    /**
     * Gets the OAuth token manager for authentication operations.
     */
    public OpenAIOAuthTokenManager getTokenManager() {
        return tokenManager;
    }
    
    /**
     * Checks if the provider is authenticated.
     */
    public boolean isAuthenticated() {
        return tokenManager.isAuthenticated();
    }
    
    /**
     * Gets updated credentials JSON for storage.
     */
    public String getCredentialsJson() {
        return tokenManager.toJson();
    }
    
    @Override
    protected OkHttpClient buildClient() {
        try {
            OkHttpClient.Builder builder = new OkHttpClient.Builder()
                .connectTimeout(super.timeout)
                .readTimeout(super.timeout)
                .writeTimeout(super.timeout)
                .retryOnConnectionFailure(true);
            
            if (disableTlsVerification) {
                TrustManager[] trustAllCerts = new TrustManager[]{
                    new X509TrustManager() {
                        @Override
                        public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) {}
                        @Override
                        public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) {}
                        @Override
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return new java.security.cert.X509Certificate[]{};
                        }
                    }
                };
                
                SSLContext sslContext = SSLContext.getInstance("TLS");
                sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
                builder.sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustAllCerts[0])
                       .hostnameVerifier((hostname, session) -> true);
            }
            
            return builder.build();
        } catch (Exception e) {
            throw new RuntimeException("Failed to build HTTP client", e);
        }
    }
    
    // =========================================================================
    // Request Headers
    // =========================================================================
    
    /**
     * Gets headers for Codex API requests.
     * CRITICAL: These headers must match what the official Codex CLI sends.
     */
    private Headers.Builder getCodexHeaders() throws IOException {
        String accessToken = tokenManager.getValidAccessToken();
        
        // Match Python client header names exactly (lowercase)
        Headers.Builder headers = new Headers.Builder()
            .add("Content-Type", "application/json")
            .add("Authorization", "Bearer " + accessToken)
            .add("originator", "codex_cli_rs")
            .add("OpenAI-Beta", "responses=experimental")
            .add("accept", "text/event-stream");  // lowercase to match Python
        
        // Add account ID header (lowercase)
        String accountId = tokenManager.getAccountId();
        if (accountId != null && !accountId.isEmpty()) {
            headers.add("chatgpt-account-id", accountId);
        }
        
        return headers;
    }
    
    // =========================================================================
    // Message Translation - OpenAI Responses API Format
    // =========================================================================
    
    /**
     * Translates ChatMessage list to OpenAI Responses API input format.
     * Matches the BinAssist Codex provider payload shape exactly.
     */
    private JsonArray translateMessagesToInput(List<ChatMessage> messages) {
        JsonArray inputItems = new JsonArray();

        if (messages == null) {
            return inputItems;
        }

        for (ChatMessage message : messages) {
            if (message == null || message.getRole() == null) {
                continue;
            }

            String role = message.getRole();
            String content = message.getContent();

            if (ChatMessage.ChatMessageRole.SYSTEM.equals(role)) {
                if (content == null || content.isEmpty()) {
                    continue;
                }
                JsonObject item = new JsonObject();
                item.addProperty("role", "developer");
                JsonArray contentArray = new JsonArray();
                JsonObject textContent = new JsonObject();
                textContent.addProperty("type", "input_text");
                textContent.addProperty("text", content);
                contentArray.add(textContent);
                item.add("content", contentArray);
                inputItems.add(item);
                continue;
            }

            if (ChatMessage.ChatMessageRole.USER.equals(role)) {
                if (content == null || content.isEmpty()) {
                    continue;
                }
                JsonObject item = new JsonObject();
                item.addProperty("role", "user");
                JsonArray contentArray = new JsonArray();
                JsonObject textContent = new JsonObject();
                textContent.addProperty("type", "input_text");
                textContent.addProperty("text", content);
                contentArray.add(textContent);
                item.add("content", contentArray);
                inputItems.add(item);
                continue;
            }

            if (ChatMessage.ChatMessageRole.ASSISTANT.equals(role)) {
                JsonArray toolCalls = message.getToolCalls();
                if (toolCalls != null && toolCalls.size() > 0) {
                    for (JsonElement toolCallElement : toolCalls) {
                        if (!toolCallElement.isJsonObject()) {
                            continue;
                        }
                        JsonObject toolCall = toolCallElement.getAsJsonObject();
                        JsonObject function = toolCall.has("function") && toolCall.get("function").isJsonObject()
                            ? toolCall.getAsJsonObject("function")
                            : null;

                        String callId = null;
                        if (toolCall.has("id")) {
                            callId = toolCall.get("id").getAsString();
                        } else if (toolCall.has("call_id")) {
                            callId = toolCall.get("call_id").getAsString();
                        }

                        String name = null;
                        if (function != null && function.has("name")) {
                            name = function.get("name").getAsString();
                        } else if (toolCall.has("name")) {
                            name = toolCall.get("name").getAsString();
                        }

                        String arguments = null;
                        JsonElement argumentsElement = null;
                        if (function != null && function.has("arguments")) {
                            argumentsElement = function.get("arguments");
                        } else if (toolCall.has("arguments")) {
                            argumentsElement = toolCall.get("arguments");
                        }
                        if (argumentsElement != null && !argumentsElement.isJsonNull()) {
                            if (argumentsElement.isJsonPrimitive()) {
                                arguments = argumentsElement.getAsString();
                            } else {
                                arguments = gson.toJson(argumentsElement);
                            }
                        }

                        JsonObject item = new JsonObject();
                        item.addProperty("type", "function_call");
                        if (callId != null && !callId.isEmpty()) {
                            item.addProperty("call_id", callId);
                        }
                        if (name != null && !name.isEmpty()) {
                            item.addProperty("name", name);
                        }
                        if (arguments != null && !arguments.isEmpty()) {
                            item.addProperty("arguments", arguments);
                        }
                        inputItems.add(item);
                    }
                }

                if (content != null && !content.isEmpty()) {
                    JsonObject item = new JsonObject();
                    item.addProperty("role", "assistant");
                    JsonArray contentArray = new JsonArray();
                    JsonObject textContent = new JsonObject();
                    textContent.addProperty("type", "output_text");
                    textContent.addProperty("text", content);
                    contentArray.add(textContent);
                    item.add("content", contentArray);
                    inputItems.add(item);
                }
                continue;
            }

            if (ChatMessage.ChatMessageRole.TOOL.equals(role) || ChatMessage.ChatMessageRole.FUNCTION.equals(role)) {
                if (content == null || content.isEmpty()) {
                    continue;
                }
                JsonObject item = new JsonObject();
                item.addProperty("type", "function_call_output");
                if (message.getToolCallId() != null && !message.getToolCallId().isEmpty()) {
                    item.addProperty("call_id", message.getToolCallId());
                }
                item.addProperty("output", content);
                inputItems.add(item);
            }
        }

        return inputItems;
    }
    
    /**
     * Translates tool definitions to Responses API format.
     */
    private JsonArray translateToolsToFormat(List<Map<String, Object>> tools) {
        JsonArray responsesTools = new JsonArray();
        
        if (tools == null || tools.isEmpty()) {
            return responsesTools;
        }
        
        for (Map<String, Object> tool : tools) {
            if (!"function".equals(tool.get("type"))) {
                continue;
            }
            
            @SuppressWarnings("unchecked")
            Map<String, Object> function = (Map<String, Object>) tool.get("function");
            if (function == null) continue;
            
            JsonObject responsesTool = new JsonObject();
            responsesTool.addProperty("type", "function");
            responsesTool.addProperty("name", (String) function.get("name"));
            responsesTool.addProperty("description", (String) function.get("description"));
            
            @SuppressWarnings("unchecked")
            Map<String, Object> parameters = (Map<String, Object>) function.get("parameters");
            if (parameters != null) {
                responsesTool.add("parameters", gson.toJsonTree(parameters));
            }
            
            if (function.containsKey("strict")) {
                responsesTool.addProperty("strict", (Boolean) function.get("strict"));
            }
            
            responsesTools.add(responsesTool);
        }
        
        return responsesTools;
    }
    
    // =========================================================================
    // Response Parsing
    // =========================================================================
    
    /**
     * Parses response content from Responses API format.
     * Returns a ParsedResponse containing text, tool calls, and finish reason.
     */
    private ParsedResponse parseResponseContent(JsonObject responseData) {
        StringBuilder textContent = new StringBuilder();
        JsonArray toolCalls = new JsonArray();
        String finishReason = "stop";
        
        JsonArray output = responseData.has("output") ? responseData.getAsJsonArray("output") : new JsonArray();
        
        for (JsonElement itemElement : output) {
            JsonObject item = itemElement.getAsJsonObject();
            String itemType = item.has("type") ? item.get("type").getAsString() : "";
            
            if ("message".equals(itemType)) {
                // Extract text content from message
                JsonArray content = item.has("content") ? item.getAsJsonArray("content") : new JsonArray();
                for (JsonElement partElement : content) {
                    JsonObject part = partElement.getAsJsonObject();
                    if ("output_text".equals(part.has("type") ? part.get("type").getAsString() : "")) {
                        if (part.has("text")) {
                            textContent.append(part.get("text").getAsString());
                        }
                    }
                }
            } else if ("function_call".equals(itemType)) {
                // Parse function call into OpenAI format
                JsonObject toolCall = new JsonObject();
                toolCall.addProperty("id", item.has("call_id") ? item.get("call_id").getAsString() 
                                                               : item.get("id").getAsString());
                toolCall.addProperty("type", "function");
                
                JsonObject function = new JsonObject();
                function.addProperty("name", item.get("name").getAsString());
                function.addProperty("arguments", item.get("arguments").getAsString());
                toolCall.add("function", function);
                
                toolCalls.add(toolCall);
                finishReason = "tool_calls";
            }
        }
        
        // Check status for finish reason
        if (responseData.has("status")) {
            String status = responseData.get("status").getAsString();
            if ("incomplete".equals(status)) {
                if (responseData.has("incomplete_details")) {
                    JsonObject details = responseData.getAsJsonObject("incomplete_details");
                    if (details.has("reason")) {
                        finishReason = details.get("reason").getAsString();
                    }
                } else {
                    finishReason = "length";
                }
            }
        }
        
        return new ParsedResponse(textContent.toString(), toolCalls, finishReason);
    }
    
    private record ParsedResponse(String textContent, JsonArray toolCalls, String finishReason) {}
    
    // =========================================================================
    // Chat Completion - Streaming Required
    // =========================================================================
    
    @Override
    public String createChatCompletion(List<ChatMessage> messages) throws APIProviderException {
        if (!isAuthenticated()) {
            throw new AuthenticationException(name, "createChatCompletion", 401, null,
                "Not authenticated. Please authenticate via Settings > Edit Provider > Authenticate.");
        }
        
        try {
            // Build payload - Codex requires stream=true, we collect the response
            JsonObject payload = buildRequestPayload(messages, null);
            Headers headers = getCodexHeaders().build();
            
            Request request = new Request.Builder()
                .url(CODEX_API_ENDPOINT)
                .post(buildJsonRequestBody(payload))
                .headers(headers)
                .build();
            
            try (Response response = client.newCall(request).execute()) {
                if (response.code() == 401) {
                    throw new AuthenticationException(name, "createChatCompletion", 401, 
                        response.body() != null ? response.body().string() : null,
                        "Authentication failed. Please re-authenticate.");
                }
                if (response.code() == 429) {
                    throw new RateLimitException(name, "createChatCompletion", null, null);
                }
                if (!response.isSuccessful()) {
                    String errorBody = response.body() != null ? response.body().string() : "";
                    throw new APIProviderException(APIProviderException.ErrorCategory.SERVICE_ERROR,
                        name, "createChatCompletion", 
                        "API error " + response.code() + ": " + errorBody);
                }
                
                // Collect streaming response (API requires stream=true)
                JsonObject responseData = collectStreamingResponse(response);
                ParsedResponse parsed = parseResponseContent(responseData);
                
                return parsed.textContent();
            }
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletion");
        }
    }
    
    @Override
    public void streamChatCompletion(List<ChatMessage> messages, LlmResponseHandler handler) 
            throws APIProviderException {
        if (!isAuthenticated()) {
            throw new AuthenticationException(name, "streamChatCompletion", 401, null,
                "Not authenticated. Please authenticate via Settings > Edit Provider > Authenticate.");
        }
        
        isCancelled = false;
        
        try {
            JsonObject payload = buildRequestPayload(messages, null);
            Headers headers = getCodexHeaders().build();
            
            Request request = new Request.Builder()
                .url(CODEX_API_ENDPOINT)
                .post(buildJsonRequestBody(payload))
                .headers(headers)
                .build();
            
            client.newCall(request).enqueue(new Callback() {
                private boolean isFirst = true;
                private StringBuilder contentBuilder = new StringBuilder();
                
                @Override
                public void onFailure(Call call, IOException e) {
                    handler.onError(handleNetworkError(e, "streamChatCompletion"));
                }
                
                @Override
                public void onResponse(Call call, Response response) throws IOException {
                    try (ResponseBody responseBody = response.body()) {
                        if (response.code() == 401) {
                            handler.onError(new AuthenticationException(name, "streamChatCompletion", 
                                401, null, "Authentication failed. Please re-authenticate."));
                            return;
                        }
                        if (response.code() == 429) {
                            handler.onError(new RateLimitException(name, "streamChatCompletion", null, null));
                            return;
                        }
                        if (!response.isSuccessful()) {
                            String errorBody = responseBody != null ? responseBody.string() : "";
                            handler.onError(new APIProviderException(APIProviderException.ErrorCategory.SERVICE_ERROR,
                                name, "streamChatCompletion", 
                                "API error " + response.code() + ": " + errorBody));
                            return;
                        }
                        
                        BufferedSource source = responseBody.source();
                        while (!source.exhausted() && !isCancelled && handler.shouldContinue()) {
                            String line = source.readUtf8Line();
                            if (line == null || line.isEmpty()) continue;
                            
                            if (line.startsWith("data: ")) {
                                String data = line.substring(6).trim();
                                
                                if ("[DONE]".equals(data)) {
                                    handler.onComplete(contentBuilder.toString());
                                    return;
                                }
                                
                                try {
                                    JsonObject event = gson.fromJson(data, JsonObject.class);
                                    String eventType = event.has("type") ? event.get("type").getAsString() : "";
                                    
                                    // Handle text delta
                                    if ("response.output_text.delta".equals(eventType)) {
                                        String deltaText = event.has("delta") ? event.get("delta").getAsString() : "";
                                        if (!deltaText.isEmpty()) {
                                            if (isFirst) {
                                                handler.onStart();
                                                isFirst = false;
                                            }
                                            contentBuilder.append(deltaText);
                                            handler.onUpdate(deltaText);
                                        }
                                    }
                                    // Handle completed response
                                    else if ("response.completed".equals(eventType) || "response.done".equals(eventType)) {
                                        handler.onComplete(contentBuilder.toString());
                                        return;
                                    }
                                } catch (Exception e) {
                                    // Skip malformed events
                                    Msg.debug(OpenAIOAuthProvider.this, "Skipping malformed SSE event: " + e.getMessage());
                                }
                            }
                        }
                        
                        if (isCancelled) {
                            handler.onError(new APIProviderException(APIProviderException.ErrorCategory.CANCELLED,
                                name, "streamChatCompletion", "Request cancelled"));
                        } else {
                            handler.onComplete(contentBuilder.toString());
                        }
                    }
                }
            });
        } catch (IOException e) {
            handler.onError(handleNetworkError(e, "streamChatCompletion"));
        }
    }
    
    /**
     * Collects a streaming SSE response into a complete response object.
     * The Codex API requires stream=true, so we must parse SSE events.
     */
    private JsonObject collectStreamingResponse(Response response) throws IOException {
        JsonObject finalResponse = new JsonObject();
        
        try (ResponseBody body = response.body()) {
            if (body == null) return finalResponse;
            
            BufferedSource source = body.source();
            while (!source.exhausted()) {
                String line = source.readUtf8Line();
                if (line == null || line.isEmpty()) continue;
                
                if (line.startsWith("data: ")) {
                    String data = line.substring(6).trim();
                    
                    if ("[DONE]".equals(data)) {
                        break;
                    }
                    
                    try {
                        JsonObject event = gson.fromJson(data, JsonObject.class);
                        String eventType = event.has("type") ? event.get("type").getAsString() : "";
                        
                        // Capture the final response
                        if ("response.completed".equals(eventType) || "response.done".equals(eventType)) {
                            if (event.has("response")) {
                                finalResponse = event.getAsJsonObject("response");
                            }
                        }
                    } catch (Exception e) {
                        // Skip malformed events
                    }
                }
            }
        }
        
        return finalResponse;
    }
    
    // =========================================================================
    // Function Calling
    // =========================================================================
    
    @Override
    public String createChatCompletionWithFunctions(List<ChatMessage> messages,
                                                    List<Map<String, Object>> functions) 
            throws APIProviderException {
        if (!isAuthenticated()) {
            throw new AuthenticationException(name, "createChatCompletionWithFunctions", 401, null,
                "Not authenticated. Please authenticate via Settings > Edit Provider > Authenticate.");
        }
        
        try {
            JsonObject payload = buildRequestPayload(messages, functions);
            Headers headers = getCodexHeaders().build();
            
            Request request = new Request.Builder()
                .url(CODEX_API_ENDPOINT)
                .post(buildJsonRequestBody(payload))
                .headers(headers)
                .build();
            
            try (Response response = client.newCall(request).execute()) {
                if (response.code() == 401) {
                    throw new AuthenticationException(name, "createChatCompletionWithFunctions", 401, 
                        response.body() != null ? response.body().string() : null,
                        "Authentication failed. Please re-authenticate.");
                }
                if (!response.isSuccessful()) {
                    String errorBody = response.body() != null ? response.body().string() : "";
                    throw new APIProviderException(APIProviderException.ErrorCategory.SERVICE_ERROR,
                        name, "createChatCompletionWithFunctions", 
                        "API error " + response.code() + ": " + errorBody);
                }
                
                JsonObject responseData = collectStreamingResponse(response);
                ParsedResponse parsed = parseResponseContent(responseData);
                
                // Return tool calls in OpenAI format
                JsonObject result = new JsonObject();
                result.add("tool_calls", parsed.toolCalls());
                return gson.toJson(result);
            }
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletionWithFunctions");
        }
    }
    
    @Override
    public String createChatCompletionWithFunctionsFullResponse(List<ChatMessage> messages,
                                                                List<Map<String, Object>> functions)
            throws APIProviderException {
        if (!isAuthenticated()) {
            throw new AuthenticationException(name, "createChatCompletionWithFunctionsFullResponse", 401, null,
                "Not authenticated. Please authenticate via Settings > Edit Provider > Authenticate.");
        }
        
        try {
            JsonObject payload = buildRequestPayload(messages, functions);
            Headers headers = getCodexHeaders().build();
            
            Request request = new Request.Builder()
                .url(CODEX_API_ENDPOINT)
                .post(buildJsonRequestBody(payload))
                .headers(headers)
                .build();
            
            try (Response response = client.newCall(request).execute()) {
                if (response.code() == 401) {
                    throw new AuthenticationException(name, "createChatCompletionWithFunctionsFullResponse", 401, 
                        response.body() != null ? response.body().string() : null,
                        "Authentication failed. Please re-authenticate.");
                }
                if (!response.isSuccessful()) {
                    String errorBody = response.body() != null ? response.body().string() : "";
                    throw new APIProviderException(APIProviderException.ErrorCategory.SERVICE_ERROR,
                        name, "createChatCompletionWithFunctionsFullResponse", 
                        "API error " + response.code() + ": " + errorBody);
                }
                
                JsonObject responseData = collectStreamingResponse(response);
                ParsedResponse parsed = parseResponseContent(responseData);
                
                // Convert to OpenAI Chat Completions format
                JsonObject fullResponse = new JsonObject();
                JsonArray choices = new JsonArray();
                JsonObject choice = new JsonObject();
                JsonObject message = new JsonObject();
                
                message.addProperty("role", "assistant");
                
                if (!parsed.toolCalls().isEmpty()) {
                    message.add("tool_calls", parsed.toolCalls());
                    if (!parsed.textContent().isEmpty()) {
                        message.addProperty("content", parsed.textContent());
                    }
                } else {
                    message.addProperty("content", parsed.textContent());
                }
                
                choice.add("message", message);
                choice.addProperty("finish_reason", parsed.finishReason());
                choice.addProperty("index", 0);
                choices.add(choice);
                
                fullResponse.add("choices", choices);
                fullResponse.addProperty("id", "chatcmpl-codex-" + System.currentTimeMillis());
                fullResponse.addProperty("object", "chat.completion");
                fullResponse.addProperty("created", System.currentTimeMillis() / 1000);
                fullResponse.addProperty("model", this.model);
                
                return gson.toJson(fullResponse);
            }
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletionWithFunctionsFullResponse");
        }
    }
    
    // =========================================================================
    // Request Building
    // =========================================================================
    
    /**
     * Builds request payload in OpenAI Responses API format.
     * CRITICAL: Codex API requires store=false AND stream=true.
     */
    private JsonObject buildRequestPayload(List<ChatMessage> messages, List<Map<String, Object>> tools) {
        JsonObject payload = new JsonObject();
        payload.addProperty("model", this.model);
        payload.add("input", translateMessagesToInput(messages));
        payload.addProperty("instructions", CodexInstructions.INSTRUCTIONS);
        payload.addProperty("store", false);
        payload.addProperty("stream", true);  // REQUIRED by Codex API
        
        // Add tools if present
        if (tools != null && !tools.isEmpty()) {
            payload.add("tools", translateToolsToFormat(tools));
        }
        
        return payload;
    }

    private RequestBody buildJsonRequestBody(JsonObject payload) {
        return RequestBody.create(gson.toJson(payload).getBytes(StandardCharsets.UTF_8), JSON);
    }
    
    
    // =========================================================================
    // Other Required Methods
    // =========================================================================
    
    @Override
    public List<String> getAvailableModels() throws APIProviderException {
        // Return commonly available Codex models
        // The API will reject invalid models for the user's subscription
        List<String> models = new ArrayList<>();
        models.add("gpt-5.1-codex");
        models.add("gpt-4.1-codex");
        models.add("o3");
        models.add("o4-mini");
        return models;
    }
    
    @Override
    public void getEmbeddingsAsync(String text, EmbeddingCallback callback) {
        callback.onError(new UnsupportedOperationException(
            "Embeddings are not supported by the OpenAI Codex OAuth API"));
    }
    
    public void cancelRequest() {
        isCancelled = true;
    }
}

```

`src/main/java/ghidrassist/apiprovider/OpenAIPlatformApiProvider.java`:

```java
package ghidrassist.apiprovider;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.JsonSyntaxException;
import com.google.gson.stream.JsonReader;

import ghidrassist.LlmApi;
import ghidrassist.apiprovider.exceptions.*;
import ghidrassist.apiprovider.capabilities.FunctionCallingProvider;
import ghidrassist.apiprovider.capabilities.ModelListProvider;
import ghidrassist.apiprovider.capabilities.EmbeddingProvider;
import okhttp3.*;
import okio.BufferedSource;
import javax.net.ssl.*;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class OpenAIPlatformApiProvider extends APIProvider implements FunctionCallingProvider, ModelListProvider, EmbeddingProvider {
    private static final Gson gson = new Gson();
    private static final MediaType JSON = MediaType.get("application/json; charset=utf-8");
    private static final String OPENAI_CHAT_ENDPOINT = "chat/completions";
    private static final String OPENAI_MODELS_ENDPOINT = "models";
    private static final String OPENAI_EMBEDDINGS_ENDPOINT = "embeddings";
    private static final String OPENAI_EMBEDDING_MODEL = "text-embedding-ada-002";

    // Retry settings for streaming calls
    private static final int MAX_STREAMING_RETRIES = 10;
    private static final int MIN_RETRY_BACKOFF_MS = 10000;  // 10 seconds
    private static final int MAX_RETRY_BACKOFF_MS = 30000;  // 30 seconds

    private volatile boolean isCancelled = false;

    public OpenAIPlatformApiProvider(String name, String model, Integer maxTokens, String url, String key, boolean disableTlsVerification, Integer timeout) {
        super(name, ProviderType.OPENAI_PLATFORM_API, model, maxTokens, url, key, disableTlsVerification, timeout);
    }

    public static OpenAIPlatformApiProvider fromConfig(APIProviderConfig config) {
        return new OpenAIPlatformApiProvider(
            config.getName(),
            config.getModel(),
            config.getMaxTokens(),
            config.getUrl(),
            config.getKey(),
            config.isDisableTlsVerification(),
            config.getTimeout()
        );
    }

    @Override
    protected OkHttpClient buildClient() {
        try {
            OkHttpClient.Builder builder = new OkHttpClient.Builder()
                .connectTimeout(super.timeout)
                .readTimeout(super.timeout)
                .writeTimeout(super.timeout)
                .retryOnConnectionFailure(true)
                .addInterceptor(chain -> {
                    Request originalRequest = chain.request();
                    Request.Builder requestBuilder = originalRequest.newBuilder()
                        .header("Authorization", "Bearer " + key)
                        .header("Content-Type", "application/json");
                    
                    if (!originalRequest.method().equals("GET")) {
                        requestBuilder.header("Accept", "application/json");
                    }
                    
                    return chain.proceed(requestBuilder.build());
                });

            if (disableTlsVerification) {
                TrustManager[] trustAllCerts = new TrustManager[]{
                    new X509TrustManager() {
                        @Override
                        public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) {}
                        @Override
                        public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) {}
                        @Override
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return new java.security.cert.X509Certificate[]{};
                        }
                    }
                };

                SSLContext sslContext = SSLContext.getInstance("TLS");
                sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
                builder.sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustAllCerts[0])
                       .hostnameVerifier((hostname, session) -> true);
            }

            return builder.build();
        } catch (Exception e) {
            throw new RuntimeException("Failed to build OpenAI HTTP client: " + e.getMessage(), e);
        }
    }

    @Override
    public String createChatCompletion(List<ChatMessage> messages) throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, false);
        
        Request request = new Request.Builder()
            .url(url + OPENAI_CHAT_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        try (Response response = executeWithRetry(request, "createChatCompletion")) {
            String responseBody = response.body().string();
            try {
                JsonObject responseObj = gson.fromJson(responseBody, JsonObject.class);
                return extractContentFromResponse(responseObj);
            } catch (JsonSyntaxException e) {
                throw new ResponseException(name, "createChatCompletion", 
                    ResponseException.ResponseErrorType.MALFORMED_JSON, e);
            }
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletion");
        }
    }

    @Override
    public void streamChatCompletion(List<ChatMessage> messages, LlmApi.LlmResponseHandler handler) throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, true);
        executeStreamingWithRetry(payload, handler, "stream_chat_completion", 0);
    }

    /**
     * Execute streaming request with retry logic for rate limits and transient errors.
     */
    private void executeStreamingWithRetry(JsonObject payload, LlmApi.LlmResponseHandler handler,
                                           String operation, int attemptNumber) {
        if (isCancelled) {
            handler.onError(new StreamCancelledException(name, operation,
                StreamCancelledException.CancellationReason.USER_REQUESTED));
            return;
        }

        Request request = new Request.Builder()
            .url(url + OPENAI_CHAT_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        client.newCall(request).enqueue(new Callback() {
            private boolean isFirst = true;

            @Override
            public void onFailure(Call call, IOException e) {
                if (call.isCanceled()) {
                    handler.onError(new StreamCancelledException(name, operation,
                        StreamCancelledException.CancellationReason.USER_REQUESTED, e));
                    return;
                }

                APIProviderException error = handleNetworkError(e, operation);
                if (shouldRetryStreaming(error, attemptNumber)) {
                    retryStreamingAfterDelay(payload, handler, operation, attemptNumber, error);
                } else {
                    handler.onError(error);
                }
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (!response.isSuccessful()) {
                        APIProviderException error = handleHttpError(response, operation);
                        if (shouldRetryStreaming(error, attemptNumber)) {
                            retryStreamingAfterDelay(payload, handler, operation, attemptNumber, error);
                        } else {
                            handler.onError(error);
                        }
                        return;
                    }

                    if (responseBody == null) {
                        handler.onError(new ResponseException(name, operation,
                            ResponseException.ResponseErrorType.EMPTY_RESPONSE));
                        return;
                    }

                    BufferedSource source = responseBody.source();
                    StringBuilder contentBuilder = new StringBuilder();

                    try {
                        while (!source.exhausted() && !isCancelled && handler.shouldContinue()) {
                            String line = source.readUtf8Line();
                            if (line == null || line.isEmpty()) continue;

                            if (line.startsWith("data: ")) {
                                String data = line.substring(6).trim();
                                if (data.equals("[DONE]")) {
                                    handler.onComplete(contentBuilder.toString());
                                    return;
                                }

                                try {
                                    JsonObject chunk = gson.fromJson(data, JsonObject.class);
                                    String content = extractDeltaContent(chunk);

                                    if (content != null) {
                                        if (isFirst) {
                                            handler.onStart();
                                            isFirst = false;
                                        }
                                        contentBuilder.append(content);
                                        handler.onUpdate(content);
                                    }
                                } catch (JsonSyntaxException e) {
                                    handler.onError(new ResponseException(name, operation,
                                        ResponseException.ResponseErrorType.MALFORMED_JSON, e));
                                    return;
                                }
                            }
                        }

                        if (isCancelled) {
                            handler.onError(new StreamCancelledException(name, operation,
                                StreamCancelledException.CancellationReason.USER_REQUESTED));
                        } else if (!handler.shouldContinue()) {
                            handler.onError(new StreamCancelledException(name, operation,
                                StreamCancelledException.CancellationReason.USER_REQUESTED));
                        }
                    } catch (IOException e) {
                        handler.onError(new ResponseException(name, operation,
                            ResponseException.ResponseErrorType.STREAM_INTERRUPTED, e));
                    }
                }
            }
        });
    }

    /**
     * Check if a streaming error should be retried.
     */
    private boolean shouldRetryStreaming(APIProviderException error, int attemptNumber) {
        if (attemptNumber >= MAX_STREAMING_RETRIES) {
            return false;
        }
        switch (error.getCategory()) {
            case RATE_LIMIT:
            case NETWORK:
            case TIMEOUT:
            case SERVICE_ERROR:
                return true;
            default:
                return false;
        }
    }

    /**
     * Retry streaming request after appropriate delay.
     */
    private void retryStreamingAfterDelay(JsonObject payload, LlmApi.LlmResponseHandler handler,
                                          String operation, int attemptNumber, APIProviderException error) {
        int nextAttempt = attemptNumber + 1;
        int waitTimeMs = calculateStreamingRetryWait(error);

        ghidra.util.Msg.warn(this, String.format("Streaming retry %d/%d for %s: %s. Waiting %d seconds...",
            nextAttempt, MAX_STREAMING_RETRIES, operation,
            error.getCategory().getDisplayName(), waitTimeMs / 1000));

        new Thread(() -> {
            try {
                Thread.sleep(waitTimeMs);
                if (!isCancelled) {
                    executeStreamingWithRetry(payload, handler, operation, nextAttempt);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                handler.onError(new StreamCancelledException(name, operation,
                    StreamCancelledException.CancellationReason.USER_REQUESTED));
            }
        }, "OpenAIPlatformApiProvider-StreamRetry").start();
    }

    /**
     * Calculate wait time for streaming retry with jitter.
     */
    private int calculateStreamingRetryWait(APIProviderException error) {
        if (error.getCategory() == APIProviderException.ErrorCategory.RATE_LIMIT) {
            Integer retryAfter = error.getRetryAfterSeconds();
            if (retryAfter != null && retryAfter > 0) {
                return retryAfter * 1000;
            }
        }
        return MIN_RETRY_BACKOFF_MS + (int) (Math.random() * (MAX_RETRY_BACKOFF_MS - MIN_RETRY_BACKOFF_MS));
    }

    @Override
    public String createChatCompletionWithFunctionsFullResponse(List<ChatMessage> messages, List<Map<String, Object>> functions) throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, false);
        
        // Add tools (functions) to the payload
        payload.add("tools", gson.toJsonTree(functions));
        
        Request request = new Request.Builder()
            .url(url + OPENAI_CHAT_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        try (Response response = executeWithRetry(request, "createChatCompletionWithFunctionsFullResponse")) {
            String responseBody = response.body().string();
            
            // Return the full response body as-is, including finish_reason
            return responseBody;
            
        } catch (IOException e) {
            throw new NetworkException(name, "createChatCompletionWithFunctionsFullResponse", NetworkException.NetworkErrorType.CONNECTION_FAILED);
        }
    }

    @Override
    public String createChatCompletionWithFunctions(List<ChatMessage> messages, List<Map<String, Object>> functions) throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, false);
        
        // Add tools (functions) to the payload
        payload.add("tools", gson.toJsonTree(functions));

        // Force tool use - "required" means model must use at least one tool
        payload.addProperty("tool_choice", "required");

        Request request = new Request.Builder()
            .url(url + OPENAI_CHAT_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        try (Response response = executeWithRetry(request, "createChatCompletionWithFunctions")) {
            String responseBody = response.body().string();
            StringReader responseStr = new StringReader(responseBody.replaceFirst("```json", "").replaceAll("```", ""));
            
            try {
                // Create a lenient JsonReader
                JsonReader jsonReader = new JsonReader(responseStr);
                jsonReader.setLenient(true);

                // Parse with lenient reader
                JsonObject responseObj = JsonParser.parseReader(jsonReader).getAsJsonObject();
            JsonObject message = new JsonObject();
            if ( responseObj.has("message") ) {
            	message = responseObj.getAsJsonObject("message");
            } else if ( responseObj.has("choices") ) {
            	JsonArray choices = responseObj.getAsJsonArray("choices");
            	message = choices.get(0).getAsJsonObject().getAsJsonObject("message");
            }

            // Check if tool_calls exists directly
            if (message.has("tool_calls")) {
                return "{\"tool_calls\":" + message.get("tool_calls").toString() + "}";
            }

            // If no tool_calls, check if content contains a JSON object
            if (message.has("content")) {
                String content = message.get("content").getAsString().trim();
                
                // Try to parse content as JSON if it looks like JSON
                if (content.startsWith("{") || content.startsWith("[")) {
                    try {
                        JsonElement contentJson = JsonParser.parseString(content);
                        
                        // Case 1: Content is a single function call
                        if (contentJson.isJsonObject()) {
                            JsonObject funcObj = contentJson.getAsJsonObject();
                            if (funcObj.has("name") && funcObj.has("arguments")) {
                                // Convert to tool_calls format
                                JsonArray toolCalls = new JsonArray();
                                JsonObject toolCall = new JsonObject();
                                JsonObject function = new JsonObject();
                                function.add("name", funcObj.get("name"));
                                function.add("arguments", funcObj.get("arguments"));
                                toolCall.add("function", function);
                                toolCalls.add(toolCall);
                                return "{\"tool_calls\":" + toolCalls.toString() + "}";
                            }
                        }
                        
                        // Case 2: Content is already a tool_calls array
                        if (contentJson.isJsonObject() && contentJson.getAsJsonObject().has("tool_calls")) {
                            return content;
                        }
                        
                        // Case 3: Content is an array of function calls
                        if (contentJson.isJsonArray()) {
                            JsonArray array = contentJson.getAsJsonArray();
                            JsonArray toolCalls = new JsonArray();
                            for (JsonElement elem : array) {
                                if (elem.isJsonObject()) {
                                    JsonObject funcObj = elem.getAsJsonObject();
                                    if (funcObj.has("name") && funcObj.has("arguments")) {
                                        JsonObject toolCall = new JsonObject();
                                        JsonObject function = new JsonObject();
                                        function.add("name", funcObj.get("name"));
                                        function.add("arguments", funcObj.get("arguments"));
                                        toolCall.add("function", function);
                                        toolCalls.add(toolCall);
                                    }
                                }
                            }
                            if (toolCalls.size() > 0) {
                                return "{\"tool_calls\":" + toolCalls.toString() + "}";
                            }
                        }
                    } catch (JsonSyntaxException e) {
                        // Content is not valid JSON, fall through to return original content
                    }
                }
                
                // If we couldn't parse as tool calls, return the original content
                return "{\"tool_calls\":[]}";
            }

            // No valid tool calls found
            return "{\"tool_calls\":[]}";
            
            } catch (JsonSyntaxException e) {
                throw new ResponseException(name, "createChatCompletionWithFunctions", 
                    ResponseException.ResponseErrorType.MALFORMED_JSON, e);
            }
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletionWithFunctions");
        }
    }


    @Override
    public List<String> getAvailableModels() throws APIProviderException {
        Request request = new Request.Builder()
            .url(url + OPENAI_MODELS_ENDPOINT)
            .build();

        try (Response response = executeWithRetry(request, "getAvailableModels")) {
            String responseBody = response.body().string();
            try {
                JsonObject responseObj = gson.fromJson(responseBody, JsonObject.class);
                List<String> modelIds = new ArrayList<>();
                
                if (!responseObj.has("data")) {
                    throw new ResponseException(name, "get_models", 
                        ResponseException.ResponseErrorType.MISSING_REQUIRED_FIELD);
                }
                
                JsonArray models = responseObj.getAsJsonArray("data");
                for (JsonElement model : models) {
                    if (model.isJsonObject() && model.getAsJsonObject().has("id")) {
                        modelIds.add(model.getAsJsonObject().get("id").getAsString());
                    }
                }
                
                return modelIds;
            } catch (JsonSyntaxException e) {
                throw new ResponseException(name, "getAvailableModels", 
                    ResponseException.ResponseErrorType.MALFORMED_JSON, e);
            }
        } catch (IOException e) {
            throw handleNetworkError(e, "getAvailableModels");
        }
    }

    @Override
    public void getEmbeddingsAsync(String text, EmbeddingCallback callback) {
        JsonObject payload = new JsonObject();
        payload.addProperty("model", OPENAI_EMBEDDING_MODEL);
        payload.addProperty("input", text);
        executeEmbeddingsWithRetry(payload, callback, "get_embeddings", 0);
    }

    /**
     * Execute embeddings request with retry logic for rate limits and transient errors.
     */
    private void executeEmbeddingsWithRetry(JsonObject payload, EmbeddingCallback callback,
                                            String operation, int attemptNumber) {
        if (isCancelled) {
            callback.onError(new StreamCancelledException(name, operation,
                StreamCancelledException.CancellationReason.USER_REQUESTED));
            return;
        }

        Request request = new Request.Builder()
            .url(super.getUrl() + OPENAI_EMBEDDINGS_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                if (call.isCanceled()) {
                    callback.onError(new StreamCancelledException(name, operation,
                        StreamCancelledException.CancellationReason.USER_REQUESTED, e));
                    return;
                }

                APIProviderException error = handleNetworkError(e, operation);
                if (shouldRetryStreaming(error, attemptNumber)) {
                    retryEmbeddingsAfterDelay(payload, callback, operation, attemptNumber, error);
                } else {
                    callback.onError(error);
                }
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (!response.isSuccessful()) {
                        APIProviderException error = handleHttpError(response, operation);
                        if (shouldRetryStreaming(error, attemptNumber)) {
                            retryEmbeddingsAfterDelay(payload, callback, operation, attemptNumber, error);
                        } else {
                            callback.onError(error);
                        }
                        return;
                    }

                    if (responseBody == null) {
                        callback.onError(new ResponseException(name, operation,
                            ResponseException.ResponseErrorType.EMPTY_RESPONSE));
                        return;
                    }

                    try {
                        String responseBodyStr = responseBody.string();
                        JsonObject responseObj = gson.fromJson(responseBodyStr, JsonObject.class);

                        if (!responseObj.has("data")) {
                            callback.onError(new ResponseException(name, operation,
                                ResponseException.ResponseErrorType.MISSING_REQUIRED_FIELD));
                            return;
                        }

                        JsonArray dataArray = responseObj.getAsJsonArray("data");
                        if (dataArray.size() == 0) {
                            callback.onError(new ResponseException(name, operation,
                                "No embedding data in response"));
                            return;
                        }

                        JsonObject firstElement = dataArray.get(0).getAsJsonObject();
                        if (!firstElement.has("embedding")) {
                            callback.onError(new ResponseException(name, operation,
                                ResponseException.ResponseErrorType.MISSING_REQUIRED_FIELD));
                            return;
                        }

                        JsonArray embedding = firstElement.getAsJsonArray("embedding");

                        double[] embeddingArray = new double[embedding.size()];
                        for (int i = 0; i < embedding.size(); i++) {
                            embeddingArray[i] = embedding.get(i).getAsDouble();
                        }

                        callback.onSuccess(embeddingArray);
                    } catch (JsonSyntaxException e) {
                        callback.onError(new ResponseException(name, operation,
                            ResponseException.ResponseErrorType.MALFORMED_JSON, e));
                    } catch (NumberFormatException e) {
                        callback.onError(new ResponseException(name, operation,
                            "Invalid embedding format: " + e.getMessage()));
                    }
                } catch (IOException e) {
                    callback.onError(new ResponseException(name, operation,
                        ResponseException.ResponseErrorType.STREAM_INTERRUPTED, e));
                }
            }
        });
    }

    /**
     * Retry embeddings request after appropriate delay.
     */
    private void retryEmbeddingsAfterDelay(JsonObject payload, EmbeddingCallback callback,
                                           String operation, int attemptNumber, APIProviderException error) {
        int nextAttempt = attemptNumber + 1;
        int waitTimeMs = calculateStreamingRetryWait(error);

        ghidra.util.Msg.warn(this, String.format("Embeddings retry %d/%d for %s: %s. Waiting %d seconds...",
            nextAttempt, MAX_STREAMING_RETRIES, operation,
            error.getCategory().getDisplayName(), waitTimeMs / 1000));

        new Thread(() -> {
            try {
                Thread.sleep(waitTimeMs);
                if (!isCancelled) {
                    executeEmbeddingsWithRetry(payload, callback, operation, nextAttempt);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                callback.onError(new StreamCancelledException(name, operation,
                    StreamCancelledException.CancellationReason.USER_REQUESTED));
            }
        }, "OpenAIPlatformApiProvider-EmbeddingsRetry").start();
    }

    private JsonObject buildChatCompletionPayload(List<ChatMessage> messages, boolean stream) {
        JsonObject payload = new JsonObject();
        payload.addProperty("model", super.getModel());

        // Handle different token field names based on model
        String modelName = super.getModel();
        if (modelName != null && (modelName.startsWith("o1-") || modelName.startsWith("o3-") || modelName.startsWith("o4-") || modelName.startsWith("gpt-5"))) {
            payload.addProperty("max_completion_tokens", super.getMaxTokens());
        } else {
            payload.addProperty("max_tokens", super.getMaxTokens());
        }
        
        payload.addProperty("stream", stream);

        // Add reasoning_effort if configured
        ReasoningConfig reasoning = getReasoningConfig();
        if (reasoning != null && reasoning.isEnabled()) {
            payload.addProperty("reasoning_effort", reasoning.getEffortString());
        }

        JsonArray messagesArray = new JsonArray();
        for (ChatMessage message : messages) {
            JsonObject messageObj = new JsonObject();
            messageObj.addProperty("role", message.getRole());
            
            // Handle content (can be null for tool calling assistant messages)
            if (message.getContent() != null) {
                messageObj.addProperty("content", message.getContent());
            }
            
            // Handle tool calls for assistant messages
            if (message.getToolCalls() != null) {
                messageObj.add("tool_calls", message.getToolCalls());
            }
            
            // Handle tool call ID for tool response messages
            if (message.getToolCallId() != null) {
                messageObj.addProperty("tool_call_id", message.getToolCallId());
            }
            
            messagesArray.add(messageObj);
        }
        payload.add("messages", messagesArray);

        return payload;
    }

    private String extractContentFromResponse(JsonObject responseObj) {
        return responseObj.getAsJsonArray("choices")
            .get(0).getAsJsonObject()
            .getAsJsonObject("message")
            .get("content").getAsString();
    }

    private String extractDeltaContent(JsonObject chunk) {
        try {
            JsonObject delta = chunk.getAsJsonArray("choices")
                .get(0).getAsJsonObject()
                .getAsJsonObject("delta");
            
            if (delta.has("content")) {
                return delta.get("content").getAsString();
            }
        } catch (Exception e) {
            // Handle any JSON parsing errors silently and return null
        }
        return null;
    }

    /**
     * Interface for handling streaming responses with function calling support.
     */
    public interface StreamingFunctionHandler {
        /**
         * Called when a text delta is received.
         * @param textDelta The incremental text content
         */
        void onTextUpdate(String textDelta);

        /**
         * Called when streaming is complete and all data is available.
         * @param stopReason The reason streaming stopped (e.g., "stop", "tool_calls")
         * @param fullText The complete text content
         * @param toolCalls List of tool calls (empty if none)
         */
        void onStreamComplete(String stopReason, String fullText, List<ToolCall> toolCalls);

        /**
         * Called when an error occurs during streaming.
         * @param error The error that occurred
         */
        void onError(Throwable error);

        /**
         * Called to check if streaming should continue.
         * @return true if streaming should continue, false to cancel
         */
        boolean shouldContinue();
    }

    /**
     * Represents a tool call from the LLM.
     */
    public static class ToolCall {
        public final String id;
        public final String name;
        public final String arguments;

        public ToolCall(String id, String name, String arguments) {
            this.id = id;
            this.name = name;
            this.arguments = arguments;
        }
    }

    /**
     * Stream chat completion with function calling support.
     * This method streams text content in real-time while buffering tool calls.
     */
    public void streamChatCompletionWithFunctions(
        List<ChatMessage> messages,
        List<Map<String, Object>> functions,
        StreamingFunctionHandler handler
    ) throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, true);
        payload.add("tools", gson.toJsonTree(functions));
        executeStreamingFunctionsWithRetry(payload, handler, "stream_chat_completion_with_functions", 0);
    }

    /**
     * Execute streaming with functions request with retry logic for rate limits and transient errors.
     */
    private void executeStreamingFunctionsWithRetry(JsonObject payload, StreamingFunctionHandler handler,
                                                    String operation, int attemptNumber) {
        if (isCancelled) {
            handler.onError(new StreamCancelledException(name, operation,
                StreamCancelledException.CancellationReason.USER_REQUESTED));
            return;
        }

        Request request = new Request.Builder()
            .url(url + OPENAI_CHAT_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                if (call.isCanceled()) {
                    handler.onError(new StreamCancelledException(name, operation,
                        StreamCancelledException.CancellationReason.USER_REQUESTED, e));
                    return;
                }

                APIProviderException error = handleNetworkError(e, operation);
                if (shouldRetryStreaming(error, attemptNumber)) {
                    retryStreamingFunctionsAfterDelay(payload, handler, operation, attemptNumber, error);
                } else {
                    handler.onError(error);
                }
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (!response.isSuccessful()) {
                        APIProviderException error = handleHttpError(response, operation);
                        if (shouldRetryStreaming(error, attemptNumber)) {
                            retryStreamingFunctionsAfterDelay(payload, handler, operation, attemptNumber, error);
                        } else {
                            handler.onError(error);
                        }
                        return;
                    }

                    if (responseBody == null) {
                        handler.onError(new ResponseException(name, operation,
                            ResponseException.ResponseErrorType.EMPTY_RESPONSE));
                        return;
                    }

                    BufferedSource source = responseBody.source();
                    StringBuilder textBuilder = new StringBuilder();
                    java.util.Map<Integer, ToolCallAccumulator> toolCallsMap = new java.util.HashMap<>();
                    String finishReason = "stop";

                    try {
                        while (!source.exhausted() && !isCancelled && handler.shouldContinue()) {
                            String line = source.readUtf8Line();
                            if (line == null || line.isEmpty()) continue;

                            if (line.startsWith("data: ")) {
                                String data = line.substring(6).trim();
                                if (data.equals("[DONE]")) {
                                    // Process complete - convert accumulated tool calls
                                    List<ToolCall> toolCalls = new java.util.ArrayList<>();
                                    toolCallsMap.entrySet().stream()
                                        .sorted(java.util.Map.Entry.comparingByKey())
                                        .forEach(entry -> {
                                            ToolCallAccumulator acc = entry.getValue();
                                            // Validate arguments - default to {} if empty
                                            String args = acc.argumentsBuffer.toString().trim();
                                            if (args.isEmpty()) {
                                                args = "{}";
                                            }
                                            toolCalls.add(new ToolCall(acc.id, acc.name, args));
                                        });

                                    handler.onStreamComplete(finishReason, textBuilder.toString(), toolCalls);
                                    return;
                                }

                                try {
                                    JsonObject chunk = gson.fromJson(data, JsonObject.class);

                                    if (chunk.has("choices")) {
                                        JsonArray choices = chunk.getAsJsonArray("choices");
                                        if (choices.size() > 0) {
                                            JsonObject choice = choices.get(0).getAsJsonObject();

                                            // Handle delta
                                            if (choice.has("delta")) {
                                                JsonObject delta = choice.getAsJsonObject("delta");

                                                // Stream text content immediately
                                                if (delta.has("content") && !delta.get("content").isJsonNull()) {
                                                    String content = delta.get("content").getAsString();
                                                    textBuilder.append(content);
                                                    handler.onTextUpdate(content);
                                                }

                                                // Buffer tool calls
                                                if (delta.has("tool_calls")) {
                                                    JsonArray toolCallDeltas = delta.getAsJsonArray("tool_calls");
                                                    for (JsonElement tcElement : toolCallDeltas) {
                                                        JsonObject toolCallDelta = tcElement.getAsJsonObject();
                                                        int index = toolCallDelta.has("index") ? toolCallDelta.get("index").getAsInt() : 0;

                                                        ToolCallAccumulator acc = toolCallsMap.computeIfAbsent(index, k -> new ToolCallAccumulator());

                                                        if (toolCallDelta.has("id") && !toolCallDelta.get("id").isJsonNull()) {
                                                            acc.id = toolCallDelta.get("id").getAsString();
                                                        }

                                                        if (toolCallDelta.has("function")) {
                                                            JsonObject functionDelta = toolCallDelta.getAsJsonObject("function");
                                                            if (functionDelta.has("name") && !functionDelta.get("name").isJsonNull()) {
                                                                acc.name = functionDelta.get("name").getAsString();
                                                            }
                                                            if (functionDelta.has("arguments") && !functionDelta.get("arguments").isJsonNull()) {
                                                                acc.argumentsBuffer.append(functionDelta.get("arguments").getAsString());
                                                            }
                                                        }
                                                    }
                                                }
                                            }

                                            // Capture finish_reason
                                            if (choice.has("finish_reason") && !choice.get("finish_reason").isJsonNull()) {
                                                finishReason = choice.get("finish_reason").getAsString();
                                            }
                                        }
                                    }
                                } catch (JsonSyntaxException e) {
                                    handler.onError(new ResponseException(name, operation,
                                        ResponseException.ResponseErrorType.MALFORMED_JSON, e));
                                    return;
                                }
                            }
                        }

                        if (isCancelled) {
                            handler.onError(new StreamCancelledException(name, operation,
                                StreamCancelledException.CancellationReason.USER_REQUESTED));
                        } else if (!handler.shouldContinue()) {
                            handler.onError(new StreamCancelledException(name, operation,
                                StreamCancelledException.CancellationReason.USER_REQUESTED));
                        }
                    } catch (IOException e) {
                        handler.onError(new ResponseException(name, operation,
                            ResponseException.ResponseErrorType.STREAM_INTERRUPTED, e));
                    }
                }
            }
        });
    }

    /**
     * Retry streaming with functions request after appropriate delay.
     */
    private void retryStreamingFunctionsAfterDelay(JsonObject payload, StreamingFunctionHandler handler,
                                                   String operation, int attemptNumber, APIProviderException error) {
        int nextAttempt = attemptNumber + 1;
        int waitTimeMs = calculateStreamingRetryWait(error);

        ghidra.util.Msg.warn(this, String.format("Streaming functions retry %d/%d for %s: %s. Waiting %d seconds...",
            nextAttempt, MAX_STREAMING_RETRIES, operation,
            error.getCategory().getDisplayName(), waitTimeMs / 1000));

        new Thread(() -> {
            try {
                Thread.sleep(waitTimeMs);
                if (!isCancelled) {
                    executeStreamingFunctionsWithRetry(payload, handler, operation, nextAttempt);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                handler.onError(new StreamCancelledException(name, operation,
                    StreamCancelledException.CancellationReason.USER_REQUESTED));
            }
        }, "OpenAIPlatformApiProvider-StreamFunctionsRetry").start();
    }

    /**
     * Helper class to accumulate tool call deltas during streaming.
     */
    private static class ToolCallAccumulator {
        String id;
        String name;
        final StringBuilder argumentsBuffer = new StringBuilder();
    }

    public void cancelRequest() {
        isCancelled = true;
    }

    @Override
    protected String extractApiErrorCode(String responseBody) {
        if (responseBody == null || responseBody.isEmpty()) {
            return null;
        }
        
        try {
            JsonObject errorObj = gson.fromJson(responseBody, JsonObject.class);
            if (errorObj.has("error")) {
                JsonElement errorElement = errorObj.get("error");
                if (errorElement.isJsonObject()) {
                    JsonObject error = errorElement.getAsJsonObject();
                    if (error.has("type")) {
                        JsonElement typeElement = error.get("type");
                        if (typeElement != null && !typeElement.isJsonNull()) {
                            return typeElement.getAsString();
                        }
                    } else if (error.has("code")) {
                        JsonElement codeElement = error.get("code");
                        if (codeElement != null && !codeElement.isJsonNull()) {
                            return codeElement.getAsString();
                        }
                    }
                }
            }
        } catch (JsonSyntaxException e) {
            // Ignore parsing errors
        }

        return null;
    }

    @Override
    protected String extractErrorMessage(String responseBody, int statusCode) {
        if (responseBody == null || responseBody.isEmpty()) {
            return null;
        }

        try {
            JsonObject errorObj = gson.fromJson(responseBody, JsonObject.class);
            if (errorObj.has("error")) {
                JsonElement errorElement = errorObj.get("error");
                if (errorElement.isJsonPrimitive()) {
                    return errorElement.getAsString();
                }
                if (errorElement.isJsonObject()) {
                    JsonObject error = errorElement.getAsJsonObject();
                    if (error.has("message")) {
                        JsonElement messageElement = error.get("message");
                        if (messageElement != null && !messageElement.isJsonNull()) {
                            return messageElement.getAsString();
                        }
                    }
                }
            }
        } catch (JsonSyntaxException e) {
            // Ignore parsing errors and fall back to parent implementation
        }
        
        // Fallback to parent implementation
        return super.extractErrorMessage(responseBody, statusCode);
    }
    
    @Override
    protected Integer extractRetryAfter(Response response, String responseBody) {
        // First check the parent implementation for standard headers
        Integer retryAfter = super.extractRetryAfter(response, responseBody);
        if (retryAfter != null) {
            return retryAfter;
        }
        
        // Check OpenAI-specific retry information in response body
        if (responseBody != null) {
            try {
                JsonObject errorObj = gson.fromJson(responseBody, JsonObject.class);
                if (errorObj.has("error")) {
                    JsonObject error = errorObj.getAsJsonObject("error");
                    if (error.has("retry_after")) {
                        return error.get("retry_after").getAsInt();
                    }
                }
            } catch (Exception e) {
                // Ignore parsing errors
            }
        }
        
        return null;
    }
}
```

`src/main/java/ghidrassist/apiprovider/OpenWebUiProvider.java`:

```java
package ghidrassist.apiprovider;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.JsonSyntaxException;
import com.google.gson.stream.JsonReader;

import ghidrassist.LlmApi.LlmResponseHandler;
import ghidrassist.apiprovider.exceptions.APIProviderException;
import ghidrassist.apiprovider.capabilities.FunctionCallingProvider;
import ghidrassist.apiprovider.capabilities.ModelListProvider;
import ghidrassist.apiprovider.capabilities.EmbeddingProvider;
import okhttp3.*;
import okio.BufferedSource;

import javax.net.ssl.*;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class OpenWebUiProvider extends APIProvider implements FunctionCallingProvider, ModelListProvider, EmbeddingProvider {
    private static final Gson gson = new Gson();
    private static final MediaType JSON = MediaType.get("application/json; charset=utf-8");
    private static final String OPENWEBUI_CHAT_ENDPOINT = "ollama/api/chat";
    private static final String OPENWEBUI_EMBEDDINGS_ENDPOINT = "ollama/api/embed";
    private static final String OPENWEBUI_MODELS_ENDPOINT = "ollama/api/tags";
    private volatile boolean isCancelled = false;

    public OpenWebUiProvider(String name, String model, Integer maxTokens, String url, String key, boolean disableTlsVerification, Integer timeout) {
        super(name, ProviderType.OPENWEBUI, model, maxTokens, url, key, disableTlsVerification, timeout);
    }

    @Override
    protected OkHttpClient buildClient() {
        try {
            OkHttpClient.Builder builder = new OkHttpClient.Builder()
                .connectTimeout(super.timeout)
                .readTimeout(super.timeout)
                .writeTimeout(super.timeout)
                .retryOnConnectionFailure(true)
                .addInterceptor(chain -> {
                    Request originalRequest = chain.request();
                    Request.Builder requestBuilder = originalRequest.newBuilder()
                        .header("Authorization", "Bearer " + key)
                        .header("Content-Type", "application/json");
                    
                    if (!originalRequest.method().equals("GET")) {
                        requestBuilder.header("Accept", "application/json");
                    }
                    
                    return chain.proceed(requestBuilder.build());
                });

            if (disableTlsVerification) {
                TrustManager[] trustAllCerts = new TrustManager[]{
                    new X509TrustManager() {
                        @Override
                        public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) {}
                        @Override
                        public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) {}
                        @Override
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return new java.security.cert.X509Certificate[]{};
                        }
                    }
                };

                SSLContext sslContext = SSLContext.getInstance("TLS");
                sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
                builder.sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustAllCerts[0])
                       .hostnameVerifier((hostname, session) -> true);
            }

            return builder.build();
        } catch (Exception e) {
            throw new RuntimeException("Failed to build HTTP client", e);
        }
    }

    @Override
    public String createChatCompletion(List<ChatMessage> messages) throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, false);
        
        Request request = new Request.Builder()
            .url(super.getUrl() + OPENWEBUI_CHAT_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        try (Response response = executeWithRetry(request, "createChatCompletion")) {
            JsonObject responseObj = gson.fromJson(response.body().string(), JsonObject.class);
            return extractContentFromResponse(responseObj);
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletion");
        }
    }

    @Override
    public void streamChatCompletion(List<ChatMessage> messages, LlmResponseHandler handler) throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, true);

        Request request = new Request.Builder()
            .url(super.getUrl() + OPENWEBUI_CHAT_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        client.newCall(request).enqueue(new Callback() {
            private boolean isFirst = true;
            private StringBuilder contentBuilder = new StringBuilder();

            @Override
            public void onFailure(Call call, IOException e) {
                handler.onError(handleNetworkError(e, "streamChatCompletion"));
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (!response.isSuccessful()) {
                        String errorBody = responseBody != null ? responseBody.string() : null;
                        handler.onError(handleHttpError(response, errorBody, "streamChatCompletion"));
                        return;
                    }

                    BufferedSource source = responseBody.source();
                    while (!source.exhausted() && !isCancelled && handler.shouldContinue()) {
                        String line = source.readUtf8Line();
                        if (line == null || line.isEmpty()) continue;

                        JsonObject chunk = gson.fromJson(line, JsonObject.class);
                        String content = extractStreamContent(chunk);
                        
                        if (content != null) {
                            if (isFirst) {
                                handler.onStart();
                                isFirst = false;
                            }
                            contentBuilder.append(content);
                            handler.onUpdate(content);
                        }

                        if (chunk.has("done") && chunk.get("done").getAsBoolean()) {
                            handler.onComplete(contentBuilder.toString());
                            return;
                        }
                    }

                    if (isCancelled) {
                        handler.onError(new APIProviderException(APIProviderException.ErrorCategory.CANCELLED,
                            name, "streamChatCompletion", "Request cancelled"));
                    }
                }
            }
        });
    }

    @Override
    public String createChatCompletionWithFunctionsFullResponse(List<ChatMessage> messages, List<Map<String, Object>> functions) throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, false);
        
        // Add tools (functions) to the payload
        payload.add("tools", gson.toJsonTree(functions));

        // Specify json output
        payload.addProperty("format", "json");

        Request request = new Request.Builder()
            .url(super.getUrl() + OPENWEBUI_CHAT_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        try (Response response = executeWithRetry(request, "createChatCompletionWithFunctionsFullResponse")) {
            JsonObject responseObj = gson.fromJson(response.body().string(), JsonObject.class);
            
            // Parse the response to create OpenAI-compatible format
            JsonObject fullResponse = new JsonObject();
            JsonArray choices = new JsonArray();
            JsonObject choice = new JsonObject();
            JsonObject message = new JsonObject();
            
            message.addProperty("role", "assistant");
            
            String finishReason = "stop";
            JsonArray toolCalls = null;
            String content = "";
            
            // Extract message from response
            if (responseObj.has("message")) {
                JsonObject responseMessage = responseObj.getAsJsonObject("message");
                
                // Check for native tool_calls first
                if (responseMessage.has("tool_calls")) {
                    JsonArray nativeToolCalls = responseMessage.getAsJsonArray("tool_calls");
                    toolCalls = convertNativeToolCallsToOpenAI(nativeToolCalls);
                    finishReason = "tool_calls";
                }
                
                // Extract content
                if (responseMessage.has("content")) {
                    content = responseMessage.get("content").getAsString();
                }
                
                // If no native tool calls, try parsing from content
                if (toolCalls == null || toolCalls.size() == 0) {
                    toolCalls = parseToolCallsFromContent(content);
                    if (toolCalls != null && toolCalls.size() > 0) {
                        finishReason = "tool_calls";
                    }
                }
            }
            
            // Set message content based on what we found
            if (toolCalls != null && toolCalls.size() > 0) {
                message.add("tool_calls", toolCalls);
                // Include content if present
                if (content != null && !content.trim().isEmpty()) {
                    message.addProperty("content", content);
                }
            } else {
                message.addProperty("content", content);
            }
            
            choice.add("message", message);
            choice.addProperty("finish_reason", finishReason);
            choice.addProperty("index", 0);
            choices.add(choice);
            
            fullResponse.add("choices", choices);
            fullResponse.addProperty("id", "chatcmpl-openwebui-" + System.currentTimeMillis());
            fullResponse.addProperty("object", "chat.completion");
            fullResponse.addProperty("created", System.currentTimeMillis() / 1000);
            fullResponse.addProperty("model", this.model);
            
            return gson.toJson(fullResponse);
            
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletionWithFunctionsFullResponse");
        }
    }

    @Override
    public String createChatCompletionWithFunctions(List<ChatMessage> messages, List<Map<String, Object>> functions) throws APIProviderException {
        JsonObject payload = buildChatCompletionPayload(messages, false);
        
        // Add tools (functions) to the payload
        payload.add("tools", gson.toJsonTree(functions));

        // Force tool use - "required" means model must use at least one tool
        payload.addProperty("tool_choice", "required");

        Request request = new Request.Builder()
            .url(super.getUrl() + OPENWEBUI_CHAT_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        try (Response response = executeWithRetry(request, "createChatCompletionWithFunctions")) {

            // Create a lenient JsonReader
            JsonReader jsonReader = new JsonReader(new StringReader(response.body().string()));
            jsonReader.setLenient(true);

            // Parse with lenient reader
            JsonObject responseObj = JsonParser.parseReader(jsonReader).getAsJsonObject();
            JsonObject message = responseObj.getAsJsonObject("message");

            // Check if tool_calls exists directly
            if (message.has("tool_calls")) {
                return "{\"tool_calls\":" + message.get("tool_calls").toString() + "}";
            }

            // If no tool_calls, check if content contains a JSON object
            if (message.has("content")) {
                String content = message.get("content").getAsString().trim();
                
                // Try to parse content as JSON if it looks like JSON
                if (content.startsWith("{") || content.startsWith("[")) {
                    try {
                        JsonElement contentJson = JsonParser.parseString(content);
                        
                        // Case 1: Content is a single function call
                        if (contentJson.isJsonObject()) {
                            JsonObject funcObj = contentJson.getAsJsonObject();
                            if (funcObj.has("name") && funcObj.has("arguments")) {
                                // Convert to tool_calls format
                                JsonArray toolCalls = new JsonArray();
                                JsonObject toolCall = new JsonObject();
                                JsonObject function = new JsonObject();
                                function.add("name", funcObj.get("name"));
                                function.add("arguments", funcObj.get("arguments"));
                                toolCall.add("function", function);
                                toolCalls.add(toolCall);
                                return "{\"tool_calls\":" + toolCalls.toString() + "}";
                            }
                        }
                        
                        // Case 2: Content is already a tool_calls array
                        if (contentJson.isJsonObject() && contentJson.getAsJsonObject().has("tool_calls")) {
                            return content;
                        }
                        
                        // Case 3: Content is an array of function calls
                        if (contentJson.isJsonArray()) {
                            JsonArray array = contentJson.getAsJsonArray();
                            JsonArray toolCalls = new JsonArray();
                            for (JsonElement elem : array) {
                                if (elem.isJsonObject()) {
                                    JsonObject funcObj = elem.getAsJsonObject();
                                    if (funcObj.has("name") && funcObj.has("arguments")) {
                                        JsonObject toolCall = new JsonObject();
                                        JsonObject function = new JsonObject();
                                        function.add("name", funcObj.get("name"));
                                        function.add("arguments", funcObj.get("arguments"));
                                        toolCall.add("function", function);
                                        toolCalls.add(toolCall);
                                    }
                                }
                            }
                            if (toolCalls.size() > 0) {
                                return "{\"tool_calls\":" + toolCalls.toString() + "}";
                            }
                        }
                    } catch (JsonSyntaxException e) {
                        // Content is not valid JSON, fall through to return original content
                    }
                }
                
                // If we couldn't parse as tool calls, return the original content
                return "{\"tool_calls\":[]}";
            }

            // No valid tool calls found
            return "{\"tool_calls\":[]}";
        } catch (IOException e) {
            throw handleNetworkError(e, "createChatCompletionWithFunctions");
        }
    }


    @Override
    public List<String> getAvailableModels() throws APIProviderException {
        Request request = new Request.Builder()
            .url(super.getUrl() + OPENWEBUI_MODELS_ENDPOINT)
            .build();

        try (Response response = executeWithRetry(request, "getAvailableModels")) {
            JsonObject responseObj = gson.fromJson(response.body().string(), JsonObject.class);
            List<String> modelIds = new ArrayList<>();
            JsonArray models = responseObj.getAsJsonArray("models");
            
            for (JsonElement model : models) {
                JsonObject modelObj = model.getAsJsonObject();
                String name = modelObj.get("name").getAsString();
                // Don't include model tags/versions in the name
                if (name.contains(":")) {
                    name = name.substring(0, name.indexOf(":"));
                }
                if (!modelIds.contains(name)) {
                    modelIds.add(name);
                }
            }
            
            return modelIds;
        } catch (IOException e) {
            throw handleNetworkError(e, "getAvailableModels");
        }
    }

    @Override
    public void getEmbeddingsAsync(String text, EmbeddingCallback callback) {
        JsonObject payload = new JsonObject();
        payload.addProperty("model", super.getModel());
        payload.addProperty("input", text);

        Request request = new Request.Builder()
            .url(super.getUrl() + OPENWEBUI_EMBEDDINGS_ENDPOINT)
            .post(RequestBody.create(gson.toJson(payload), JSON))
            .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callback.onError(e);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (!response.isSuccessful()) {
                        callback.onError(new IOException("Failed to get embeddings: " + 
                            response.code() + " " + response.message()));
                        return;
                    }

                    JsonObject responseObj = gson.fromJson(responseBody.string(), JsonObject.class);
                    JsonArray embeddingsArray = responseObj.getAsJsonArray("embeddings");


                    JsonArray embeddings = (JsonArray) embeddingsArray.get(0);
                    double[] embeddingArray = new double[embeddings.size()];
                    for (int i = 0; i < embeddings.size(); i++) {
                        embeddingArray[i] = embeddings.get(i).getAsDouble();
                    }
                    
                    callback.onSuccess(embeddingArray);
                } catch (Exception e) {
                    callback.onError(e);
                }
            }
        });
    }

    private JsonObject buildChatCompletionPayload(List<ChatMessage> messages, boolean stream) {
        JsonObject payload = new JsonObject();
        payload.addProperty("model", super.getModel());
        payload.addProperty("stream", stream);

        // Add think parameter if reasoning is configured
        ReasoningConfig reasoning = getReasoningConfig();
        if (reasoning != null && reasoning.isEnabled()) {
            // Use effort level string - works for gpt-oss and most thinking models
            payload.addProperty("think", reasoning.getEffortString());
        }

        JsonArray messagesArray = new JsonArray();
        for (ChatMessage message : messages) {
            JsonObject messageObj = new JsonObject();
            messageObj.addProperty("role", message.getRole());
            messageObj.addProperty("content", message.getContent());
            messagesArray.add(messageObj);
        }
        payload.add("messages", messagesArray);

        return payload;
    }



    private String extractContentFromResponse(JsonObject responseObj) {
        return responseObj.get("message")
            .getAsJsonObject()
            .get("content")
            .getAsString();
    }

    private String extractStreamContent(JsonObject chunk) {
        try {
            if (chunk.has("message")) {
                JsonObject message = chunk.getAsJsonObject("message");
                if (message.has("content")) {
                    return message.get("content").getAsString();
                }
            }
        } catch (Exception e) {
            // Handle any JSON parsing errors silently and return null
        }
        return null;
    }

    public void cancelRequest() {
        isCancelled = true;
    }
    
    /**
     * Parse tool calls from content and return in OpenAI format (same as OllamaProvider)
     */
    private JsonArray parseToolCallsFromContent(String content) {
        if (content == null || content.trim().isEmpty()) {
            return null;
        }
        
        content = content.trim();
        
        // Try to parse content as JSON if it looks like JSON
        if (content.startsWith("{") || content.startsWith("[")) {
            try {
                JsonElement contentJson = JsonParser.parseString(content);
                
                // Case 1: Content is a single function call
                if (contentJson.isJsonObject()) {
                    JsonObject funcObj = contentJson.getAsJsonObject();
                    if (funcObj.has("name") && funcObj.has("arguments")) {
                        // Convert to tool_calls format
                        JsonArray toolCalls = new JsonArray();
                        JsonObject toolCall = new JsonObject();
                        toolCall.addProperty("id", "call_" + System.currentTimeMillis());
                        toolCall.addProperty("type", "function");
                        
                        JsonObject function = new JsonObject();
                        function.addProperty("name", funcObj.get("name").getAsString());
                        function.addProperty("arguments", gson.toJson(funcObj.get("arguments")));
                        toolCall.add("function", function);
                        
                        toolCalls.add(toolCall);
                        return toolCalls;
                    }
                }
                
                // Case 2: Content is array of function calls
                if (contentJson.isJsonArray()) {
                    JsonArray funcArray = contentJson.getAsJsonArray();
                    JsonArray toolCalls = new JsonArray();
                    
                    for (JsonElement funcElement : funcArray) {
                        if (funcElement.isJsonObject()) {
                            JsonObject funcObj = funcElement.getAsJsonObject();
                            if (funcObj.has("name") && funcObj.has("arguments")) {
                                JsonObject toolCall = new JsonObject();
                                toolCall.addProperty("id", "call_" + System.currentTimeMillis() + "_" + toolCalls.size());
                                toolCall.addProperty("type", "function");
                                
                                JsonObject function = new JsonObject();
                                function.addProperty("name", funcObj.get("name").getAsString());
                                function.addProperty("arguments", gson.toJson(funcObj.get("arguments")));
                                toolCall.add("function", function);
                                
                                toolCalls.add(toolCall);
                            }
                        }
                    }
                    
                    return toolCalls.size() > 0 ? toolCalls : null;
                }
                
                // Case 3: Content has tool_calls property
                if (contentJson.isJsonObject()) {
                    JsonObject obj = contentJson.getAsJsonObject();
                    if (obj.has("tool_calls")) {
                        JsonArray existingToolCalls = obj.getAsJsonArray("tool_calls");
                        // Convert to OpenAI format if needed
                        JsonArray toolCalls = new JsonArray();
                        for (JsonElement tcElement : existingToolCalls) {
                            if (tcElement.isJsonObject()) {
                                JsonObject tc = tcElement.getAsJsonObject();
                                if (!tc.has("id")) {
                                    tc.addProperty("id", "call_" + System.currentTimeMillis() + "_" + toolCalls.size());
                                }
                                if (!tc.has("type")) {
                                    tc.addProperty("type", "function");
                                }
                                toolCalls.add(tc);
                            }
                        }
                        return toolCalls.size() > 0 ? toolCalls : null;
                    }
                }
                
            } catch (Exception e) {
                // If parsing fails, return null
                return null;
            }
        }
        
        return null;
    }
    
    /**
     * Convert native OpenWebUI tool calls to OpenAI format
     */
    private JsonArray convertNativeToolCallsToOpenAI(JsonArray nativeToolCalls) {
        JsonArray toolCalls = new JsonArray();
        
        for (JsonElement tcElement : nativeToolCalls) {
            if (tcElement.isJsonObject()) {
                JsonObject nativeToolCall = tcElement.getAsJsonObject();
                
                JsonObject toolCall = new JsonObject();
                toolCall.addProperty("id", "call_" + System.currentTimeMillis() + "_" + toolCalls.size());
                toolCall.addProperty("type", "function");
                
                // Extract function information
                if (nativeToolCall.has("function")) {
                    JsonObject nativeFunction = nativeToolCall.getAsJsonObject("function");
                    
                    JsonObject function = new JsonObject();
                    if (nativeFunction.has("name")) {
                        function.addProperty("name", nativeFunction.get("name").getAsString());
                    }
                    if (nativeFunction.has("arguments")) {
                        function.addProperty("arguments", gson.toJson(nativeFunction.get("arguments")));
                    }
                    
                    toolCall.add("function", function);
                    toolCalls.add(toolCall);
                }
            }
        }
        
        return toolCalls;
    }
}
```

`src/main/java/ghidrassist/apiprovider/ReasoningConfig.java`:

```java
package ghidrassist.apiprovider;

/**
 * Configuration for LLM reasoning/thinking effort.
 * Different providers use different parameter formats:
 * - Anthropic: thinking.budget_tokens object
 * - OpenAI/Azure: reasoning_effort string
 * - Ollama/OpenWebUI: think boolean/string
 * - LMStudio: reasoning.effort object
 */
public class ReasoningConfig {

    public enum EffortLevel {
        NONE,    // Don't send any reasoning parameters
        LOW,     // Minimal reasoning
        MEDIUM,  // Balanced reasoning
        HIGH     // Maximum reasoning depth
    }

    private EffortLevel effort;

    public ReasoningConfig() {
        this.effort = EffortLevel.NONE;
    }

    public ReasoningConfig(EffortLevel effort) {
        this.effort = effort != null ? effort : EffortLevel.NONE;
    }

    public EffortLevel getEffort() {
        return effort;
    }

    public void setEffort(EffortLevel effort) {
        this.effort = effort != null ? effort : EffortLevel.NONE;
    }

    /**
     * Check if reasoning is enabled (not NONE).
     */
    public boolean isEnabled() {
        return effort != EffortLevel.NONE;
    }

    /**
     * Get the effort level as a lowercase string for API parameters.
     * Returns null if effort is NONE.
     */
    public String getEffortString() {
        if (effort == EffortLevel.NONE) {
            return null;
        }
        return effort.name().toLowerCase();
    }

    /**
     * Get the Anthropic thinking budget tokens based on effort level.
     * Returns 0 if effort is NONE.
     */
    public int getAnthropicBudget() {
        switch (effort) {
            case LOW:
                return 2000;
            case MEDIUM:
                return 10000;
            case HIGH:
                return 25000;
            default:
                return 0;
        }
    }

    /**
     * Get the Ollama/OpenWebUI think parameter value.
     * For gpt-oss models, returns effort string.
     * For other models, returns boolean equivalent.
     * Returns null if effort is NONE.
     */
    public Object getOllamaThinkValue() {
        if (effort == EffortLevel.NONE) {
            return null;
        }
        // Return the effort level string - works for gpt-oss and
        // Ollama will convert to boolean for other models
        return effort.name().toLowerCase();
    }

    /**
     * Parse an effort level from a string (case-insensitive).
     */
    public static EffortLevel parseEffort(String value) {
        if (value == null || value.trim().isEmpty() || value.equalsIgnoreCase("none")) {
            return EffortLevel.NONE;
        }
        try {
            return EffortLevel.valueOf(value.toUpperCase());
        } catch (IllegalArgumentException e) {
            return EffortLevel.NONE;
        }
    }

    /**
     * Create a ReasoningConfig from a string effort level.
     */
    public static ReasoningConfig fromString(String value) {
        return new ReasoningConfig(parseEffort(value));
    }

    @Override
    public String toString() {
        return "ReasoningConfig{effort=" + effort + "}";
    }
}

```

`src/main/java/ghidrassist/apiprovider/RetryHandler.java`:

```java
package ghidrassist.apiprovider;

import ghidrassist.apiprovider.exceptions.*;
import ghidra.util.Msg;

import java.util.concurrent.Callable;
import java.util.function.Supplier;

/**
 * Handles retry logic for API provider operations
 */
public class RetryHandler {
    private static final int DEFAULT_MAX_RETRIES = 50;
    private static final int MIN_BACKOFF_MS = 10000; // 10 seconds
    private static final int MAX_BACKOFF_MS = 30000; // 30 seconds
    
    private final int maxRetries;
    private final Object source; // For logging
    
    public RetryHandler() {
        this(DEFAULT_MAX_RETRIES, null);
    }
    
    public RetryHandler(int maxRetries, Object source) {
        this.maxRetries = maxRetries;
        this.source = source;
    }
    
    /**
     * Execute an operation with retry logic
     */
    public <T> T executeWithRetry(Supplier<T> operation, String operationName) throws APIProviderException {
        return executeWithRetryCallable(() -> operation.get(), operationName);
    }
    
    /**
     * Execute a callable operation with retry logic
     */
    public <T> T executeWithRetryCallable(Callable<T> operation, String operationName) throws APIProviderException {
        APIProviderException lastException = null;
        
        for (int attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return operation.call();
            } catch (APIProviderException e) {
                lastException = e;
                
                if (!shouldRetry(e, attempt)) {
                    throw e;
                }
                
                logRetryAttempt(operationName, attempt, e);
                
                if (attempt < maxRetries) {
                    waitForRetry(e, attempt);
                }
            } catch (Exception e) {
                // Convert non-API exceptions to APIProviderException
                throw new APIProviderException(
                    APIProviderException.ErrorCategory.SERVICE_ERROR,
                    "Unknown", 
                    operationName,
                    "Unexpected error: " + e.getMessage()
                );
            }
        }
        
        // If we get here, all retries failed
        throw lastException;
    }
    
    /**
     * Execute an operation with retry logic that doesn't return a value
     */
    public void executeWithRetryRunnable(Runnable operation, String operationName) throws APIProviderException {
        executeWithRetryCallable(() -> {
            operation.run();
            return null;
        }, operationName);
    }
    
    private boolean shouldRetry(APIProviderException e, int attempt) {
        // Don't retry if we've exceeded max attempts
        if (attempt >= maxRetries) {
            return false;
        }
        
        // Check if the error is retryable based on category
        switch (e.getCategory()) {
            case RATE_LIMIT:
            case NETWORK:
            case TIMEOUT:
            case SERVICE_ERROR:
                return true;
                
            case AUTHENTICATION:
            case MODEL_ERROR:
            case CONFIGURATION:
            case RESPONSE_ERROR:
            case CANCELLED:
                return false;
                
            default:
                // For unknown errors, check the isRetryable flag
                return e.isRetryable();
        }
    }
    
    private void waitForRetry(APIProviderException e, int attempt) {
        int waitTimeMs = calculateWaitTime(e, attempt);
        
        if (source != null) {
            Msg.info(source, String.format("Waiting %d seconds before retry...", waitTimeMs / 1000 ));
        }
        
        try {
            Thread.sleep(waitTimeMs);
        } catch (InterruptedException ie) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Retry interrupted", ie);
        }
    }
    
    private int calculateWaitTime(APIProviderException e, int attempt) {
        // For rate limit errors, use the provided retry-after if available
        // Otherwise, use random backoff between 15-45 seconds
        if (e.getCategory() == APIProviderException.ErrorCategory.RATE_LIMIT) {
            if (e.getRetryAfterSeconds() != null) {
                return e.getRetryAfterSeconds() * 1000;
            }
            // Random backoff between MIN_BACKOFF_MS and MAX_BACKOFF_MS
            return MIN_BACKOFF_MS + (int) (Math.random() * (MAX_BACKOFF_MS - MIN_BACKOFF_MS));
        }

        // For other errors, also use random backoff between 15-45 seconds
        return MIN_BACKOFF_MS + (int) (Math.random() * (MAX_BACKOFF_MS - MIN_BACKOFF_MS));
    }
    
    private void logRetryAttempt(String operationName, int attempt, APIProviderException e) {
        if (source != null) {
            String message = String.format(
                "Retry attempt %d/%d for %s: %s (%s)",
                attempt, maxRetries, operationName, 
                e.getCategory().getDisplayName(), e.getProviderName()
            );
            Msg.warn(source, message);
        }
    }
    
    /**
     * Check if an exception indicates a transient error that might succeed on retry
     */
    public static boolean isTransientError(Throwable error) {
        if (error instanceof APIProviderException) {
            APIProviderException ape = (APIProviderException) error;
            return ape.isRetryable() || isTransientCategory(ape.getCategory());
        }
        
        // Check for common transient error indicators in message
        String message = error.getMessage();
        if (message != null) {
            message = message.toLowerCase();
            return message.contains("timeout") || 
                   message.contains("connection reset") ||
                   message.contains("temporary") ||
                   message.contains("service unavailable");
        }
        
        return false;
    }
    
    private static boolean isTransientCategory(APIProviderException.ErrorCategory category) {
        switch (category) {
            case RATE_LIMIT:
            case NETWORK:
            case TIMEOUT:
            case SERVICE_ERROR:
                return true;
            default:
                return false;
        }
    }
}
```

`src/main/java/ghidrassist/apiprovider/XaiPlatformApiProvider.java`:

```java
package ghidrassist.apiprovider;

import ghidrassist.apiprovider.exceptions.APIProviderException;

/**
 * xAI (Grok) Provider - OpenAI-compatible API at https://api.x.ai/v1.
 * Inherits all chat, streaming, function calling, and model listing from OpenAIPlatformApiProvider.
 * xAI does not offer an embeddings endpoint.
 */
public class XaiPlatformApiProvider extends OpenAIPlatformApiProvider {

    public XaiPlatformApiProvider(String name, String model, Integer maxTokens, String url,
                                   String key, boolean disableTlsVerification, Integer timeout) {
        super(name, model, maxTokens, url, key, disableTlsVerification, timeout);

        // Override the type to XAI_PLATFORM_API
        this.type = ProviderType.XAI_PLATFORM_API;
    }

    public static XaiPlatformApiProvider fromConfig(APIProviderConfig config) {
        return new XaiPlatformApiProvider(
            config.getName(),
            config.getModel(),
            config.getMaxTokens(),
            config.getUrl(),
            config.getKey(),
            config.isDisableTlsVerification(),
            config.getTimeout()
        );
    }

    @Override
    public void getEmbeddingsAsync(String text, EmbeddingCallback callback) {
        callback.onError(new APIProviderException(
            APIProviderException.ErrorCategory.CONFIGURATION,
            name, "get_embeddings",
            "xAI does not support embeddings"));
    }
}

```

`src/main/java/ghidrassist/apiprovider/capabilities/ChatProvider.java`:

```java
package ghidrassist.apiprovider.capabilities;

import ghidrassist.LlmApi;
import ghidrassist.apiprovider.ChatMessage;
import ghidrassist.apiprovider.exceptions.APIProviderException;

import java.util.List;

/**
 * Interface for providers that support basic chat completion.
 * This is the core capability that all LLM providers should support.
 */
public interface ChatProvider {
    
    /**
     * Create a chat completion (blocking/synchronous)
     * @param messages The conversation messages
     * @return The completion response
     * @throws APIProviderException if the request fails
     */
    String createChatCompletion(List<ChatMessage> messages) throws APIProviderException;
    
    /**
     * Stream a chat completion (non-blocking/asynchronous)
     * @param messages The conversation messages
     * @param handler Handler for streaming response chunks
     * @throws APIProviderException if the request fails
     */
    void streamChatCompletion(List<ChatMessage> messages, LlmApi.LlmResponseHandler handler) throws APIProviderException;
}
```

`src/main/java/ghidrassist/apiprovider/capabilities/EmbeddingProvider.java`:

```java
package ghidrassist.apiprovider.capabilities;

import ghidrassist.apiprovider.APIProvider;

/**
 * Interface for providers that support text embeddings.
 * Not all providers support this capability.
 */
public interface EmbeddingProvider {
    
    /**
     * Generate embeddings for text asynchronously
     * @param text The text to embed
     * @param callback Callback to handle the embedding result
     */
    void getEmbeddingsAsync(String text, APIProvider.EmbeddingCallback callback);
    
    /**
     * Check if this provider supports embeddings
     * @return true if embeddings are supported
     */
    default boolean supportsEmbeddings() {
        return true;
    }
}
```

`src/main/java/ghidrassist/apiprovider/capabilities/FunctionCallingProvider.java`:

```java
package ghidrassist.apiprovider.capabilities;

import ghidrassist.apiprovider.ChatMessage;
import ghidrassist.apiprovider.exceptions.APIProviderException;

import java.util.List;
import java.util.Map;

/**
 * Interface for providers that support function calling / tool calling.
 * Not all providers support this capability.
 */
public interface FunctionCallingProvider {
    
    /**
     * Create a chat completion with function calling support
     * @param messages The conversation messages
     * @param functions Available functions/tools that the model can call
     * @return The completion response, potentially containing function calls
     * @throws APIProviderException if the request fails
     */
    String createChatCompletionWithFunctions(List<ChatMessage> messages, List<Map<String, Object>> functions) throws APIProviderException;
    
    /**
     * Check if this provider supports function calling
     * @return true if function calling is supported
     */
    default boolean supportsFunctionCalling() {
        return true;
    }
}
```

`src/main/java/ghidrassist/apiprovider/capabilities/ModelListProvider.java`:

```java
package ghidrassist.apiprovider.capabilities;

import ghidrassist.apiprovider.exceptions.APIProviderException;

import java.util.List;

/**
 * Interface for providers that can list available models.
 * Not all providers support this capability.
 */
public interface ModelListProvider {
    
    /**
     * Get list of available models from this provider
     * @return List of model identifiers
     * @throws APIProviderException if the request fails
     */
    List<String> getAvailableModels() throws APIProviderException;
    
    /**
     * Check if this provider supports model listing
     * @return true if model listing is supported
     */
    default boolean supportsModelListing() {
        return true;
    }
}
```

`src/main/java/ghidrassist/apiprovider/exceptions/APIProviderException.java`:

```java
package ghidrassist.apiprovider.exceptions;

/**
 * Base exception for all API provider errors with structured error information
 */
public class APIProviderException extends Exception {
    private final ErrorCategory category;
    private final String providerName;
    private final String operation;
    private final int httpStatusCode;
    private final String apiErrorCode;
    private final boolean isRetryable;
    private final Integer retryAfterSeconds;
    
    public enum ErrorCategory {
        AUTHENTICATION("Authentication Error", "Check your API key and credentials"),
        NETWORK("Network Error", "Check your internet connection and API URL"),
        RATE_LIMIT("Rate Limit Exceeded", "Too many requests - please wait before retrying"),
        MODEL_ERROR("Model Error", "Issue with the specified model or unsupported feature"),
        CONFIGURATION("Configuration Error", "Invalid settings or configuration"),
        RESPONSE_ERROR("Response Error", "Invalid or unexpected response from API"),
        SERVICE_ERROR("Service Error", "API service is experiencing issues"),
        TIMEOUT("Timeout Error", "Request took too long to complete"),
        CANCELLED("Request Cancelled", "Operation was cancelled");
        
        private final String displayName;
        private final String description;
        
        ErrorCategory(String displayName, String description) {
            this.displayName = displayName;
            this.description = description;
        }
        
        public String getDisplayName() { return displayName; }
        public String getDescription() { return description; }
    }
    
    public APIProviderException(ErrorCategory category, String providerName, String operation, 
                              String message) {
        this(category, providerName, operation, -1, null, message, false, null, null);
    }
    
    public APIProviderException(ErrorCategory category, String providerName, String operation,
                              int httpStatusCode, String apiErrorCode, String message) {
        this(category, providerName, operation, httpStatusCode, apiErrorCode, message, false, null, null);
    }
    
    public APIProviderException(ErrorCategory category, String providerName, String operation,
                              int httpStatusCode, String apiErrorCode, String message, 
                              boolean isRetryable, Integer retryAfterSeconds, Throwable cause) {
        super(message, cause);
        this.category = category;
        this.providerName = providerName;
        this.operation = operation;
        this.httpStatusCode = httpStatusCode;
        this.apiErrorCode = apiErrorCode;
        this.isRetryable = isRetryable;
        this.retryAfterSeconds = retryAfterSeconds;
    }
    
    // Getters
    public ErrorCategory getCategory() { return category; }
    public String getProviderName() { return providerName; }
    public String getOperation() { return operation; }
    public int getHttpStatusCode() { return httpStatusCode; }
    public String getApiErrorCode() { return apiErrorCode; }
    public boolean isRetryable() { return isRetryable; }
    public Integer getRetryAfterSeconds() { return retryAfterSeconds; }
    
    /**
     * Get technical details for debugging
     */
    public String getTechnicalDetails() {
        StringBuilder details = new StringBuilder();
        details.append("Provider: ").append(providerName).append("\n");
        details.append("Operation: ").append(operation).append("\n");
        details.append("Category: ").append(category.getDisplayName()).append("\n");
        
        if (httpStatusCode > 0) {
            details.append("HTTP Status: ").append(httpStatusCode).append("\n");
        }
        
        if (apiErrorCode != null && !apiErrorCode.isEmpty()) {
            details.append("API Error Code: ").append(apiErrorCode).append("\n");
        }
        
        if (getMessage() != null) {
            details.append("Message: ").append(getMessage()).append("\n");
        }
        
        if (getCause() != null) {
            details.append("Cause: ").append(getCause().getClass().getSimpleName()).append("\n");
        }
        
        return details.toString();
    }
}
```

`src/main/java/ghidrassist/apiprovider/exceptions/AuthenticationException.java`:

```java
package ghidrassist.apiprovider.exceptions;

/**
 * Exception for authentication and authorization failures
 */
public class AuthenticationException extends APIProviderException {
    
    public AuthenticationException(String providerName, String operation, String message) {
        super(ErrorCategory.AUTHENTICATION, providerName, operation, message);
    }
    
    public AuthenticationException(String providerName, String operation, int httpStatusCode, 
                                 String apiErrorCode, String message) {
        super(ErrorCategory.AUTHENTICATION, providerName, operation, httpStatusCode, apiErrorCode, 
              message, false, null, null);
    }
    
    public AuthenticationException(String providerName, String operation, String message, Throwable cause) {
        super(ErrorCategory.AUTHENTICATION, providerName, operation, -1, null, message, false, null, cause);
    }
}
```

`src/main/java/ghidrassist/apiprovider/exceptions/ModelException.java`:

```java
package ghidrassist.apiprovider.exceptions;

/**
 * Exception for model-related errors
 */
public class ModelException extends APIProviderException {
    
    public enum ModelErrorType {
        MODEL_NOT_FOUND("The specified model was not found or is not available"),
        UNSUPPORTED_FEATURE("The model does not support this feature"),
        CONTEXT_LENGTH_EXCEEDED("Input exceeds the model's maximum context length"),
        TOKEN_LIMIT_EXCEEDED("Response would exceed the maximum token limit"),
        MODEL_OVERLOADED("The model is currently overloaded");
        
        private final String description;
        
        ModelErrorType(String description) {
            this.description = description;
        }
        
        public String getDescription() { return description; }
    }
    
    private final ModelErrorType modelErrorType;
    
    public ModelException(String providerName, String operation, ModelErrorType errorType) {
        super(ErrorCategory.MODEL_ERROR, providerName, operation, errorType.getDescription());
        this.modelErrorType = errorType;
    }
    
    public ModelException(String providerName, String operation, ModelErrorType errorType,
                        int httpStatusCode, String apiErrorCode) {
        super(ErrorCategory.MODEL_ERROR, providerName, operation, httpStatusCode, apiErrorCode,
              errorType.getDescription(), false, null, null);
        this.modelErrorType = errorType;
    }

    /**
     * Constructor that allows specifying a custom error message from the API
     * instead of using the generic ModelErrorType description.
     */
    public ModelException(String providerName, String operation, ModelErrorType errorType,
                        int httpStatusCode, String apiErrorCode, String customMessage) {
        super(ErrorCategory.MODEL_ERROR, providerName, operation, httpStatusCode, apiErrorCode,
              customMessage != null ? customMessage : errorType.getDescription(), false, null, null);
        this.modelErrorType = errorType;
    }

    public ModelException(String providerName, String operation, String message) {
        super(ErrorCategory.MODEL_ERROR, providerName, operation, message);
        this.modelErrorType = null;
    }
    
    public ModelErrorType getModelErrorType() {
        return modelErrorType;
    }
}
```

`src/main/java/ghidrassist/apiprovider/exceptions/NetworkException.java`:

```java
package ghidrassist.apiprovider.exceptions;

/**
 * Exception for network-related failures
 */
public class NetworkException extends APIProviderException {
    
    public enum NetworkErrorType {
        CONNECTION_FAILED("Cannot connect to server"),
        TIMEOUT("Request timed out"),
        SSL_ERROR("SSL/TLS connection failed"),
        DNS_ERROR("Cannot resolve hostname"),
        CONNECTION_LOST("Connection was lost during request");
        
        private final String description;
        
        NetworkErrorType(String description) {
            this.description = description;
        }
        
        public String getDescription() { return description; }
    }
    
    private final NetworkErrorType networkErrorType;
    
    public NetworkException(String providerName, String operation, NetworkErrorType errorType) {
        super(ErrorCategory.NETWORK, providerName, operation, errorType.getDescription());
        this.networkErrorType = errorType;
    }
    
    public NetworkException(String providerName, String operation, NetworkErrorType errorType, 
                          Throwable cause) {
        super(ErrorCategory.NETWORK, providerName, operation, -1, null, errorType.getDescription(), 
              true, null, cause);
        this.networkErrorType = errorType;
    }
    
    public NetworkException(String providerName, String operation, String message) {
        super(ErrorCategory.NETWORK, providerName, operation, message);
        this.networkErrorType = null;
    }
    
    public NetworkErrorType getNetworkErrorType() {
        return networkErrorType;
    }
}
```

`src/main/java/ghidrassist/apiprovider/exceptions/RateLimitException.java`:

```java
package ghidrassist.apiprovider.exceptions;

/**
 * Exception for rate limiting errors
 */
public class RateLimitException extends APIProviderException {
    
    public RateLimitException(String providerName, String operation, Integer retryAfterSeconds) {
        super(ErrorCategory.RATE_LIMIT, providerName, operation, 429, "rate_limit_exceeded",
              "Rate limit exceeded. Please wait before retrying.", true, retryAfterSeconds, null);
    }
    
    public RateLimitException(String providerName, String operation, String message, 
                            Integer retryAfterSeconds) {
        super(ErrorCategory.RATE_LIMIT, providerName, operation, 429, "rate_limit_exceeded",
              message, true, retryAfterSeconds, null);
    }
    
    public RateLimitException(String providerName, String operation, int httpStatusCode,
                            String apiErrorCode, String message, Integer retryAfterSeconds) {
        super(ErrorCategory.RATE_LIMIT, providerName, operation, httpStatusCode, apiErrorCode,
              message, true, retryAfterSeconds, null);
    }
}
```

`src/main/java/ghidrassist/apiprovider/exceptions/ResponseException.java`:

```java
package ghidrassist.apiprovider.exceptions;

/**
 * Exception for response parsing and format errors
 */
public class ResponseException extends APIProviderException {
    
    public enum ResponseErrorType {
        MALFORMED_JSON("Response contains invalid JSON"),
        MISSING_REQUIRED_FIELD("Required field missing from response"),
        UNEXPECTED_FORMAT("Response format is not as expected"),
        EMPTY_RESPONSE("Received empty response"),
        STREAM_INTERRUPTED("Response stream was interrupted");
        
        private final String description;
        
        ResponseErrorType(String description) {
            this.description = description;
        }
        
        public String getDescription() { return description; }
    }
    
    private final ResponseErrorType responseErrorType;
    
    public ResponseException(String providerName, String operation, ResponseErrorType errorType) {
        super(ErrorCategory.RESPONSE_ERROR, providerName, operation, errorType.getDescription());
        this.responseErrorType = errorType;
    }
    
    public ResponseException(String providerName, String operation, ResponseErrorType errorType,
                           Throwable cause) {
        super(ErrorCategory.RESPONSE_ERROR, providerName, operation, -1, null, 
              errorType.getDescription(), false, null, cause);
        this.responseErrorType = errorType;
    }
    
    public ResponseException(String providerName, String operation, String message) {
        super(ErrorCategory.RESPONSE_ERROR, providerName, operation, message);
        this.responseErrorType = null;
    }
    
    public ResponseErrorType getResponseErrorType() {
        return responseErrorType;
    }
}
```

`src/main/java/ghidrassist/apiprovider/exceptions/StreamCancelledException.java`:

```java
package ghidrassist.apiprovider.exceptions;

/**
 * Exception for stream cancellation scenarios
 */
public class StreamCancelledException extends APIProviderException {
    
    public enum CancellationReason {
        USER_REQUESTED("User cancelled the request"),
        TIMEOUT("Request timed out"),
        CONNECTION_LOST("Network connection was lost"),
        PROVIDER_ERROR("API provider terminated the stream"),
        SHUTDOWN("Application is shutting down");
        
        private final String description;
        
        CancellationReason(String description) {
            this.description = description;
        }
        
        public String getDescription() { return description; }
    }
    
    private final CancellationReason cancellationReason;
    
    public StreamCancelledException(String providerName, String operation, CancellationReason reason) {
        super(ErrorCategory.CANCELLED, providerName, operation, reason.getDescription());
        this.cancellationReason = reason;
    }
    
    public StreamCancelledException(String providerName, String operation, CancellationReason reason,
                                  Throwable cause) {
        super(ErrorCategory.CANCELLED, providerName, operation, -1, null, reason.getDescription(),
              false, null, cause);
        this.cancellationReason = reason;
    }
    
    public CancellationReason getCancellationReason() {
        return cancellationReason;
    }
}
```

`src/main/java/ghidrassist/apiprovider/factory/APIProviderFactory.java`:

```java
package ghidrassist.apiprovider.factory;

import ghidrassist.apiprovider.APIProvider;
import ghidrassist.apiprovider.APIProviderConfig;

/**
 * Factory interface for creating API providers.
 * Follows the Factory Method pattern to allow extensibility.
 */
public interface APIProviderFactory {
    
    /**
     * Create an API provider instance from configuration
     * @param config The provider configuration
     * @return A configured API provider instance
     * @throws UnsupportedProviderException if this factory cannot create the requested provider type
     */
    APIProvider createProvider(APIProviderConfig config) throws UnsupportedProviderException;
    
    /**
     * Check if this factory supports creating the given provider type
     * @param type The provider type to check
     * @return true if this factory can create providers of the given type
     */
    boolean supports(APIProvider.ProviderType type);
    
    /**
     * Get the provider type this factory creates
     * @return The provider type
     */
    APIProvider.ProviderType getProviderType();
    
    /**
     * Get a human-readable name for this factory
     * @return Factory name
     */
    String getFactoryName();
}
```

`src/main/java/ghidrassist/apiprovider/factory/AnthropicClaudeCliProviderFactory.java`:

```java
package ghidrassist.apiprovider.factory;

import ghidrassist.apiprovider.APIProvider;
import ghidrassist.apiprovider.APIProviderConfig;
import ghidrassist.apiprovider.AnthropicClaudeCliProvider;

/**
 * Factory for creating Claude Code CLI providers.
 *
 * The Claude Code provider proxies API requests through the claude CLI,
 * enabling use of Claude models without requiring an API key.
 */
public class AnthropicClaudeCliProviderFactory implements APIProviderFactory {

    @Override
    public APIProvider createProvider(APIProviderConfig config) throws UnsupportedProviderException {
        if (!supports(config.getType())) {
            throw new UnsupportedProviderException(config.getType(), getFactoryName());
        }

        return new AnthropicClaudeCliProvider(
            config.getName(),
            config.getModel(),
            config.getMaxTokens(),
            config.getUrl(),      // Not used but kept for API consistency
            config.getKey(),      // Not used but kept for API consistency
            config.isDisableTlsVerification(),
            config.getTimeout()
        );
    }

    @Override
    public boolean supports(APIProvider.ProviderType type) {
        return type == APIProvider.ProviderType.ANTHROPIC_CLAUDE_CLI;
    }

    @Override
    public APIProvider.ProviderType getProviderType() {
        return APIProvider.ProviderType.ANTHROPIC_CLAUDE_CLI;
    }

    @Override
    public String getFactoryName() {
        return "AnthropicClaudeCliProviderFactory";
    }
}

```

`src/main/java/ghidrassist/apiprovider/factory/AnthropicOAuthProviderFactory.java`:

```java
package ghidrassist.apiprovider.factory;

import ghidrassist.apiprovider.APIProvider;
import ghidrassist.apiprovider.APIProviderConfig;
import ghidrassist.apiprovider.AnthropicOAuthProvider;

/**
 * Factory for creating Claude OAuth API providers.
 * 
 * This provider uses OAuth authentication for Claude Pro/Max subscriptions.
 */
public class AnthropicOAuthProviderFactory implements APIProviderFactory {
    
    @Override
    public APIProvider createProvider(APIProviderConfig config) throws UnsupportedProviderException {
        if (!supports(config.getType())) {
            throw new UnsupportedProviderException(config.getType(), getFactoryName());
        }
        
        return new AnthropicOAuthProvider(
            config.getName(),
            config.getModel(),
            config.getMaxTokens(),
            config.getUrl(),
            config.getKey(),  // Contains OAuth credentials as JSON
            config.isDisableTlsVerification(),
            config.getTimeout()
        );
    }
    
    @Override
    public boolean supports(APIProvider.ProviderType type) {
        return type == APIProvider.ProviderType.ANTHROPIC_OAUTH;
    }
    
    @Override
    public APIProvider.ProviderType getProviderType() {
        return APIProvider.ProviderType.ANTHROPIC_OAUTH;
    }
    
    @Override
    public String getFactoryName() {
        return "AnthropicOAuthProviderFactory";
    }
}

```

`src/main/java/ghidrassist/apiprovider/factory/AnthropicPlatformApiProviderFactory.java`:

```java
package ghidrassist.apiprovider.factory;

import ghidrassist.apiprovider.APIProvider;
import ghidrassist.apiprovider.APIProviderConfig;
import ghidrassist.apiprovider.AnthropicPlatformApiProvider;

/**
 * Factory for creating Anthropic API providers.
 */
public class AnthropicPlatformApiProviderFactory implements APIProviderFactory {
    
    @Override
    public APIProvider createProvider(APIProviderConfig config) throws UnsupportedProviderException {
        if (!supports(config.getType())) {
            throw new UnsupportedProviderException(config.getType(), getFactoryName());
        }
        
        return new AnthropicPlatformApiProvider(
            config.getName(),
            config.getModel(),
            config.getMaxTokens(),
            config.getUrl(),
            config.getKey(),
            config.isDisableTlsVerification(),
            config.getTimeout()
        );
    }
    
    @Override
    public boolean supports(APIProvider.ProviderType type) {
        return type == APIProvider.ProviderType.ANTHROPIC_PLATFORM_API;
    }
    
    @Override
    public APIProvider.ProviderType getProviderType() {
        return APIProvider.ProviderType.ANTHROPIC_PLATFORM_API;
    }
    
    @Override
    public String getFactoryName() {
        return "AnthropicPlatformApiProviderFactory";
    }
}
```

`src/main/java/ghidrassist/apiprovider/factory/AzureOpenAIProviderFactory.java`:

```java
package ghidrassist.apiprovider.factory;

import ghidrassist.apiprovider.APIProvider;
import ghidrassist.apiprovider.APIProviderConfig;
import ghidrassist.apiprovider.AzureOpenAIProvider;

/**
 * Factory for creating Azure OpenAI API providers.
 */
public class AzureOpenAIProviderFactory implements APIProviderFactory {

    @Override
    public APIProvider createProvider(APIProviderConfig config) throws UnsupportedProviderException {
        if (!supports(config.getType())) {
            throw new UnsupportedProviderException(config.getType(), getFactoryName());
        }

        return new AzureOpenAIProvider(
                config.getName(),
                config.getModel(),
                config.getMaxTokens(),
                config.getUrl(),
                config.getKey(),
                config.isDisableTlsVerification(),
                config.getTimeout());
    }

    @Override
    public boolean supports(APIProvider.ProviderType type) {
        return type == APIProvider.ProviderType.AZURE_OPENAI;
    }

    @Override
    public APIProvider.ProviderType getProviderType() {
        return APIProvider.ProviderType.AZURE_OPENAI;
    }

    @Override
    public String getFactoryName() {
        return "AzureOpenAIProviderFactory";
    }
}

```

`src/main/java/ghidrassist/apiprovider/factory/GeminiOAuthProviderFactory.java`:

```java
package ghidrassist.apiprovider.factory;

import ghidrassist.apiprovider.APIProvider;
import ghidrassist.apiprovider.APIProviderConfig;
import ghidrassist.apiprovider.GeminiOAuthProvider;

/**
 * Factory for creating Google Gemini OAuth API providers.
 *
 * This provider uses OAuth authentication for Google Gemini CLI subscriptions,
 * routing requests through the Code Assist proxy endpoint.
 */
public class GeminiOAuthProviderFactory implements APIProviderFactory {

    @Override
    public APIProvider createProvider(APIProviderConfig config) throws UnsupportedProviderException {
        if (!supports(config.getType())) {
            throw new UnsupportedProviderException(config.getType(), getFactoryName());
        }

        return new GeminiOAuthProvider(
            config.getName(),
            config.getModel(),
            config.getMaxTokens(),
            config.getUrl(),
            config.getKey(),  // Contains OAuth credentials as JSON
            config.isDisableTlsVerification(),
            config.getTimeout()
        );
    }

    @Override
    public boolean supports(APIProvider.ProviderType type) {
        return type == APIProvider.ProviderType.GEMINI_OAUTH;
    }

    @Override
    public APIProvider.ProviderType getProviderType() {
        return APIProvider.ProviderType.GEMINI_OAUTH;
    }

    @Override
    public String getFactoryName() {
        return "GeminiOAuthProviderFactory";
    }
}

```

`src/main/java/ghidrassist/apiprovider/factory/GeminiPlatformApiProviderFactory.java`:

```java
package ghidrassist.apiprovider.factory;

import ghidrassist.apiprovider.APIProvider;
import ghidrassist.apiprovider.APIProviderConfig;
import ghidrassist.apiprovider.GeminiPlatformApiProvider;

/**
 * Factory for creating Google Gemini API providers.
 */
public class GeminiPlatformApiProviderFactory implements APIProviderFactory {

    @Override
    public APIProvider createProvider(APIProviderConfig config) throws UnsupportedProviderException {
        if (!supports(config.getType())) {
            throw new UnsupportedProviderException(config.getType(), getFactoryName());
        }

        return new GeminiPlatformApiProvider(
            config.getName(),
            config.getModel(),
            config.getMaxTokens(),
            config.getUrl(),
            config.getKey(),
            config.isDisableTlsVerification(),
            config.getTimeout()
        );
    }

    @Override
    public boolean supports(APIProvider.ProviderType type) {
        return type == APIProvider.ProviderType.GEMINI_PLATFORM_API;
    }

    @Override
    public APIProvider.ProviderType getProviderType() {
        return APIProvider.ProviderType.GEMINI_PLATFORM_API;
    }

    @Override
    public String getFactoryName() {
        return "GeminiPlatformApiProviderFactory";
    }
}

```

`src/main/java/ghidrassist/apiprovider/factory/LMStudioProviderFactory.java`:

```java
package ghidrassist.apiprovider.factory;

import ghidrassist.apiprovider.APIProvider;
import ghidrassist.apiprovider.APIProviderConfig;
import ghidrassist.apiprovider.LMStudioProvider;

/**
 * Factory for creating LM Studio API providers.
 */
public class LMStudioProviderFactory implements APIProviderFactory {
    
    @Override
    public APIProvider createProvider(APIProviderConfig config) throws UnsupportedProviderException {
        if (!supports(config.getType())) {
            throw new UnsupportedProviderException(config.getType(), getFactoryName());
        }
        
        return new LMStudioProvider(
            config.getName(),
            config.getModel(),
            config.getMaxTokens(),
            config.getUrl(),
            config.getKey(),
            config.isDisableTlsVerification(),
            config.getTimeout()
        );
    }
    
    @Override
    public boolean supports(APIProvider.ProviderType type) {
        return type == APIProvider.ProviderType.LMSTUDIO;
    }
    
    @Override
    public APIProvider.ProviderType getProviderType() {
        return APIProvider.ProviderType.LMSTUDIO;
    }
    
    @Override
    public String getFactoryName() {
        return "LMStudioProviderFactory";
    }
}
```

`src/main/java/ghidrassist/apiprovider/factory/LiteLLMProviderFactory.java`:

```java
package ghidrassist.apiprovider.factory;

import ghidrassist.apiprovider.APIProvider;
import ghidrassist.apiprovider.APIProviderConfig;
import ghidrassist.apiprovider.LiteLLMProvider;

/**
 * Factory for creating LiteLLM API providers.
 * LiteLLM is a proxy that provides an OpenAI-compatible API to various backends
 * including AWS Bedrock, Azure, Google, and more.
 */
public class LiteLLMProviderFactory implements APIProviderFactory {

    @Override
    public APIProvider createProvider(APIProviderConfig config) throws UnsupportedProviderException {
        if (!supports(config.getType())) {
            throw new UnsupportedProviderException(config.getType(), getFactoryName());
        }

        return new LiteLLMProvider(
            config.getName(),
            config.getModel(),
            config.getMaxTokens(),
            config.getUrl(),
            config.getKey(),
            config.isDisableTlsVerification(),
            config.getTimeout()
        );
    }

    @Override
    public boolean supports(APIProvider.ProviderType type) {
        return type == APIProvider.ProviderType.LITELLM;
    }

    @Override
    public APIProvider.ProviderType getProviderType() {
        return APIProvider.ProviderType.LITELLM;
    }

    @Override
    public String getFactoryName() {
        return "LiteLLMProviderFactory";
    }
}

```

`src/main/java/ghidrassist/apiprovider/factory/OllamaProviderFactory.java`:

```java
package ghidrassist.apiprovider.factory;

import ghidrassist.apiprovider.APIProvider;
import ghidrassist.apiprovider.APIProviderConfig;
import ghidrassist.apiprovider.OllamaProvider;

/**
 * Factory for creating Ollama API providers.
 */
public class OllamaProviderFactory implements APIProviderFactory {
    
    @Override
    public APIProvider createProvider(APIProviderConfig config) throws UnsupportedProviderException {
        if (!supports(config.getType())) {
            throw new UnsupportedProviderException(config.getType(), getFactoryName());
        }
        
        return new OllamaProvider(
            config.getName(),
            config.getModel(),
            config.getMaxTokens(),
            config.getUrl(),
            config.getKey(),
            config.isDisableTlsVerification(),
            config.getTimeout()
        );
    }
    
    @Override
    public boolean supports(APIProvider.ProviderType type) {
        return type == APIProvider.ProviderType.OLLAMA;
    }
    
    @Override
    public APIProvider.ProviderType getProviderType() {
        return APIProvider.ProviderType.OLLAMA;
    }
    
    @Override
    public String getFactoryName() {
        return "OllamaProviderFactory";
    }
}
```

`src/main/java/ghidrassist/apiprovider/factory/OpenAIOAuthProviderFactory.java`:

```java
package ghidrassist.apiprovider.factory;

import ghidrassist.apiprovider.APIProvider;
import ghidrassist.apiprovider.APIProviderConfig;
import ghidrassist.apiprovider.OpenAIOAuthProvider;

/**
 * Factory for creating OpenAI OAuth API providers.
 * 
 * This provider uses OAuth authentication for ChatGPT Pro/Plus subscriptions,
 * routing requests through the Codex Responses API endpoint.
 */
public class OpenAIOAuthProviderFactory implements APIProviderFactory {
    
    @Override
    public APIProvider createProvider(APIProviderConfig config) throws UnsupportedProviderException {
        if (!supports(config.getType())) {
            throw new UnsupportedProviderException(config.getType(), getFactoryName());
        }
        
        return new OpenAIOAuthProvider(
            config.getName(),
            config.getModel(),
            config.getMaxTokens(),
            config.getUrl(),
            config.getKey(),  // Contains OAuth credentials as JSON
            config.isDisableTlsVerification(),
            config.getTimeout()
        );
    }
    
    @Override
    public boolean supports(APIProvider.ProviderType type) {
        return type == APIProvider.ProviderType.OPENAI_OAUTH;
    }
    
    @Override
    public APIProvider.ProviderType getProviderType() {
        return APIProvider.ProviderType.OPENAI_OAUTH;
    }
    
    @Override
    public String getFactoryName() {
        return "OpenAIOAuthProviderFactory";
    }
}

```

`src/main/java/ghidrassist/apiprovider/factory/OpenAIPlatformApiProviderFactory.java`:

```java
package ghidrassist.apiprovider.factory;

import ghidrassist.apiprovider.APIProvider;
import ghidrassist.apiprovider.APIProviderConfig;
import ghidrassist.apiprovider.OpenAIPlatformApiProvider;

/**
 * Factory for creating OpenAI API providers.
 */
public class OpenAIPlatformApiProviderFactory implements APIProviderFactory {
    
    @Override
    public APIProvider createProvider(APIProviderConfig config) throws UnsupportedProviderException {
        if (!supports(config.getType())) {
            throw new UnsupportedProviderException(config.getType(), getFactoryName());
        }
        
        return new OpenAIPlatformApiProvider(
            config.getName(),
            config.getModel(),
            config.getMaxTokens(),
            config.getUrl(),
            config.getKey(),
            config.isDisableTlsVerification(),
            config.getTimeout()
        );
    }
    
    @Override
    public boolean supports(APIProvider.ProviderType type) {
        return type == APIProvider.ProviderType.OPENAI_PLATFORM_API;
    }
    
    @Override
    public APIProvider.ProviderType getProviderType() {
        return APIProvider.ProviderType.OPENAI_PLATFORM_API;
    }
    
    @Override
    public String getFactoryName() {
        return "OpenAIPlatformApiProviderFactory";
    }
}
```

`src/main/java/ghidrassist/apiprovider/factory/OpenWebUiProviderFactory.java`:

```java
package ghidrassist.apiprovider.factory;

import ghidrassist.apiprovider.APIProvider;
import ghidrassist.apiprovider.APIProviderConfig;
import ghidrassist.apiprovider.OpenWebUiProvider;

/**
 * Factory for creating OpenWebUI API providers.
 */
public class OpenWebUiProviderFactory implements APIProviderFactory {
    
    @Override
    public APIProvider createProvider(APIProviderConfig config) throws UnsupportedProviderException {
        if (!supports(config.getType())) {
            throw new UnsupportedProviderException(config.getType(), getFactoryName());
        }
        
        return new OpenWebUiProvider(
            config.getName(),
            config.getModel(),
            config.getMaxTokens(),
            config.getUrl(),
            config.getKey(),
            config.isDisableTlsVerification(),
            config.getTimeout()
        );
    }
    
    @Override
    public boolean supports(APIProvider.ProviderType type) {
        return type == APIProvider.ProviderType.OPENWEBUI;
    }
    
    @Override
    public APIProvider.ProviderType getProviderType() {
        return APIProvider.ProviderType.OPENWEBUI;
    }
    
    @Override
    public String getFactoryName() {
        return "OpenWebUiProviderFactory";
    }
}
```

`src/main/java/ghidrassist/apiprovider/factory/ProviderRegistry.java`:

```java
package ghidrassist.apiprovider.factory;

import ghidrassist.apiprovider.APIProvider;
import ghidrassist.apiprovider.APIProviderConfig;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Registry for API provider factories.
 * Manages the creation of providers through registered factories.
 * Thread-safe and follows the Registry pattern.
 */
public class ProviderRegistry {
    
    private final Map<APIProvider.ProviderType, APIProviderFactory> factories = new ConcurrentHashMap<>();
    private static final ProviderRegistry INSTANCE = new ProviderRegistry();
    
    /**
     * Get the singleton instance of the provider registry
     */
    public static ProviderRegistry getInstance() {
        return INSTANCE;
    }
    
    /**
     * Private constructor for singleton
     */
    private ProviderRegistry() {
        // Register default factories
        registerDefaultFactories();
    }
    
    /**
     * Register a factory for a specific provider type
     * @param factory The factory to register
     */
    public void registerFactory(APIProviderFactory factory) {
        if (factory == null) {
            throw new IllegalArgumentException("Factory cannot be null");
        }
        
        APIProvider.ProviderType type = factory.getProviderType();
        if (type == null) {
            throw new IllegalArgumentException("Factory must specify a provider type");
        }
        
        factories.put(type, factory);
    }
    
    /**
     * Unregister a factory for a specific provider type
     * @param type The provider type to unregister
     * @return The previously registered factory, or null if none was registered
     */
    public APIProviderFactory unregisterFactory(APIProvider.ProviderType type) {
        return factories.remove(type);
    }
    
    /**
     * Create a provider using the appropriate factory
     * @param config The provider configuration
     * @return A configured provider instance
     * @throws UnsupportedProviderException if no factory is registered for the provider type
     */
    public APIProvider createProvider(APIProviderConfig config) throws UnsupportedProviderException {
        if (config == null) {
            throw new IllegalArgumentException("Provider config cannot be null");
        }
        
        APIProvider.ProviderType type = config.getType();
        APIProviderFactory factory = factories.get(type);
        
        if (factory == null) {
            throw new UnsupportedProviderException(type, "ProviderRegistry", 
                "No factory registered for provider type: " + type);
        }
        
        return factory.createProvider(config);
    }
    
    /**
     * Check if a provider type is supported
     * @param type The provider type to check
     * @return true if a factory is registered for this type
     */
    public boolean isSupported(APIProvider.ProviderType type) {
        return factories.containsKey(type);
    }
    
    /**
     * Get all supported provider types
     * @return Set of supported provider types
     */
    public Set<APIProvider.ProviderType> getSupportedTypes() {
        return new HashSet<>(factories.keySet());
    }
    
    /**
     * Get all registered factories
     * @return Map of provider types to their factories
     */
    public Map<APIProvider.ProviderType, APIProviderFactory> getRegisteredFactories() {
        return new HashMap<>(factories);
    }
    
    /**
     * Get the factory for a specific provider type
     * @param type The provider type
     * @return The factory, or null if none is registered
     */
    public APIProviderFactory getFactory(APIProvider.ProviderType type) {
        return factories.get(type);
    }
    
    /**
     * Clear all registered factories (mainly for testing)
     */
    public void clearFactories() {
        factories.clear();
    }
    
    /**
     * Register the default built-in factories
     */
    private void registerDefaultFactories() {
        registerFactory(new AnthropicClaudeCliProviderFactory());
        registerFactory(new AnthropicOAuthProviderFactory());
        registerFactory(new AnthropicPlatformApiProviderFactory());
        registerFactory(new AzureOpenAIProviderFactory());
        registerFactory(new GeminiOAuthProviderFactory());
        registerFactory(new GeminiPlatformApiProviderFactory());
        registerFactory(new LiteLLMProviderFactory());
        registerFactory(new LMStudioProviderFactory());
        registerFactory(new OllamaProviderFactory());
        registerFactory(new OpenAIOAuthProviderFactory());
        registerFactory(new OpenAIPlatformApiProviderFactory());
        registerFactory(new OpenWebUiProviderFactory());
        registerFactory(new XaiPlatformApiProviderFactory());
    }
    
    /**
     * Get information about all registered factories
     * @return Human-readable string describing registered factories
     */
    public String getRegistryInfo() {
        StringBuilder sb = new StringBuilder();
        sb.append("Registered Provider Factories:\n");
        
        for (Map.Entry<APIProvider.ProviderType, APIProviderFactory> entry : factories.entrySet()) {
            sb.append(String.format("  %s -> %s\n", 
                entry.getKey(), 
                entry.getValue().getFactoryName()));
        }
        
        return sb.toString();
    }
}
```

`src/main/java/ghidrassist/apiprovider/factory/UnsupportedProviderException.java`:

```java
package ghidrassist.apiprovider.factory;

import ghidrassist.apiprovider.APIProvider;

/**
 * Exception thrown when a factory cannot create a requested provider type.
 */
public class UnsupportedProviderException extends Exception {
    
    private final APIProvider.ProviderType requestedType;
    private final String factoryName;
    
    public UnsupportedProviderException(APIProvider.ProviderType requestedType, String factoryName) {
        super(String.format("Factory '%s' does not support provider type '%s'", factoryName, requestedType));
        this.requestedType = requestedType;
        this.factoryName = factoryName;
    }
    
    public UnsupportedProviderException(APIProvider.ProviderType requestedType, String factoryName, String message) {
        super(message);
        this.requestedType = requestedType;
        this.factoryName = factoryName;
    }
    
    public UnsupportedProviderException(APIProvider.ProviderType requestedType, String factoryName, String message, Throwable cause) {
        super(message, cause);
        this.requestedType = requestedType;
        this.factoryName = factoryName;
    }
    
    public APIProvider.ProviderType getRequestedType() {
        return requestedType;
    }
    
    public String getFactoryName() {
        return factoryName;
    }
}
```

`src/main/java/ghidrassist/apiprovider/factory/XaiPlatformApiProviderFactory.java`:

```java
package ghidrassist.apiprovider.factory;

import ghidrassist.apiprovider.APIProvider;
import ghidrassist.apiprovider.APIProviderConfig;
import ghidrassist.apiprovider.XaiPlatformApiProvider;

/**
 * Factory for creating xAI (Grok) API providers.
 */
public class XaiPlatformApiProviderFactory implements APIProviderFactory {

    @Override
    public APIProvider createProvider(APIProviderConfig config) throws UnsupportedProviderException {
        if (!supports(config.getType())) {
            throw new UnsupportedProviderException(config.getType(), getFactoryName());
        }

        return new XaiPlatformApiProvider(
            config.getName(),
            config.getModel(),
            config.getMaxTokens(),
            config.getUrl(),
            config.getKey(),
            config.isDisableTlsVerification(),
            config.getTimeout()
        );
    }

    @Override
    public boolean supports(APIProvider.ProviderType type) {
        return type == APIProvider.ProviderType.XAI_PLATFORM_API;
    }

    @Override
    public APIProvider.ProviderType getProviderType() {
        return APIProvider.ProviderType.XAI_PLATFORM_API;
    }

    @Override
    public String getFactoryName() {
        return "XaiPlatformApiProviderFactory";
    }
}

```

`src/main/java/ghidrassist/apiprovider/oauth/GeminiOAuthTokenManager.java`:

```java
package ghidrassist.apiprovider.oauth;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import ghidra.util.Msg;
import okhttp3.*;

import java.awt.Desktop;
import java.io.IOException;
import java.net.URI;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Base64;
import java.util.concurrent.TimeUnit;

/**
 * Manages OAuth 2.0 authentication with Google Gemini CLI.
 *
 * This class handles the complete OAuth flow including:
 * - Browser-based authorization (NO PKCE, state-only CSRF protection)
 * - Headless/manual authorization (WITH PKCE S256)
 * - Token exchange (form-encoded with client_secret)
 * - Token refresh
 * - User info fetching (email)
 * - Project discovery via loadCodeAssist + onboardUser
 * - Token storage (as JSON in the provider's key field)
 *
 * Based on the official Gemini CLI authentication implementation.
 */
public class GeminiOAuthTokenManager {

    // OAuth Configuration - Official Gemini CLI Client ID (installed app - safe to embed)
    private static final String CLIENT_ID = "681255809395-oo8ft2oprdrnp9e3aqf6av3hmdib135j.apps.googleusercontent.com";
    private static final String CLIENT_SECRET = "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";
    private static final String AUTH_ENDPOINT = "https://accounts.google.com/o/oauth2/v2/auth";
    private static final String TOKEN_ENDPOINT = "https://oauth2.googleapis.com/token";
    private static final String HEADLESS_REDIRECT_URI = "https://codeassist.google.com/authcode";
    private static final String SCOPES = "https://www.googleapis.com/auth/cloud-platform https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile";
    private static final String USER_INFO_URL = "https://www.googleapis.com/oauth2/v2/userinfo";
    private static final String CODE_ASSIST_ENDPOINT = "https://cloudcode-pa.googleapis.com";
    private static final String CODE_ASSIST_API_VERSION = "v1internal";

    // Token expiry buffer (5 minutes before actual expiry)
    private static final long EXPIRY_BUFFER_MS = 5 * 60 * 1000;

    private final OkHttpClient httpClient;
    private final Gson gson;

    // Token storage
    private String accessToken;
    private String refreshToken;
    private long expiresAt; // Unix timestamp in milliseconds
    private String email;
    private String projectId;
    private String tier;
    private String tierName;

    // Auth flow state
    private String pendingCodeVerifier; // Only used in headless mode
    private String pendingState;
    private String pendingRedirectUri;
    private OAuthCallbackServer callbackServer;

    public GeminiOAuthTokenManager() {
        this.httpClient = new OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build();
        this.gson = new Gson();
    }

    public GeminiOAuthTokenManager(String credentialsJson) {
        this();
        if (credentialsJson != null && !credentialsJson.isEmpty()) {
            loadFromJson(credentialsJson);
        }
    }

    public boolean isAuthenticated() {
        return accessToken != null && !accessToken.isEmpty();
    }

    public boolean isTokenExpired() {
        return System.currentTimeMillis() >= (expiresAt - EXPIRY_BUFFER_MS);
    }

    public String getEmail() { return email; }
    public String getProjectId() { return projectId; }
    public String getTier() { return tier; }
    public String getTierName() { return tierName; }
    public String getAccessToken() { return accessToken; }
    public String getRefreshToken() { return refreshToken; }
    public long getExpiresAt() { return expiresAt; }

    // =========================================================================
    // Browser Auth Flow (NO PKCE, state-only CSRF) - matches authWithWeb
    // =========================================================================

    /**
     * Starts the OAuth authorization flow with automatic callback capture.
     * Opens a local HTTP server on a dynamic port to capture the callback.
     * Browser mode: NO PKCE, just state param + access_type=offline.
     *
     * @return The OAuthCallbackServer that will receive the callback
     * @throws IOException If the callback server cannot be started
     */
    public OAuthCallbackServer startAuthorizationFlowWithCallback() throws IOException {
        pendingState = generateState();

        // Create and start callback server on dynamic port
        callbackServer = OAuthCallbackServer.forGemini(pendingState);
        callbackServer.start();

        pendingRedirectUri = callbackServer.getRedirectUri();

        // Browser mode: NO PKCE, just state + access_type=offline
        String authUrl = buildBrowserAuthUrl(pendingState, pendingRedirectUri);

        Msg.info(this, "Opening browser for Google Gemini OAuth authentication with automatic callback...");
        Msg.info(this, "Callback server listening on: " + pendingRedirectUri);

        openBrowser(authUrl);

        return callbackServer;
    }

    /**
     * Completes authentication using the callback server.
     */
    public void completeAuthorizationWithCallback(OAuthCallbackServer server, int timeoutMinutes) throws Exception {
        try {
            String code = server.waitForCode(timeoutMinutes);
            // Browser mode: no PKCE verifier
            completeAuthorization(code, pendingRedirectUri, null);
        } finally {
            server.stop();
            callbackServer = null;
        }
    }

    // =========================================================================
    // Headless Auth Flow (WITH PKCE S256) - matches authWithUserCode
    // =========================================================================

    /**
     * Starts the OAuth authorization flow for headless/manual mode.
     * Uses PKCE S256 with codeassist.google.com/authcode redirect.
     */
    public void startAuthorizationFlow() {
        pendingCodeVerifier = generateCodeVerifier();
        String codeChallenge = generateCodeChallenge(pendingCodeVerifier);
        pendingState = generateState();
        pendingRedirectUri = HEADLESS_REDIRECT_URI;

        String authUrl = buildHeadlessAuthUrl(codeChallenge, pendingState);

        Msg.info(this, "Opening browser for Google Gemini OAuth authentication (headless mode)...");
        openBrowser(authUrl);
    }

    /**
     * Performs authentication with a manually entered authorization code.
     */
    public void authenticateWithCode(String input) throws Exception {
        if (pendingCodeVerifier == null) {
            throw new IllegalStateException("Call startAuthorizationFlow() first to open the browser");
        }

        String code = extractCodeFromInput(input.trim());
        Msg.info(this, "Extracted authorization code: " + code.substring(0, Math.min(20, code.length())) + "...");

        // Headless mode: WITH PKCE verifier
        completeAuthorization(code, HEADLESS_REDIRECT_URI, pendingCodeVerifier);
    }

    // =========================================================================
    // Common Auth Completion
    // =========================================================================

    /**
     * Completes authorization by exchanging code for tokens, fetching user info,
     * and setting up the user via Code Assist.
     */
    private void completeAuthorization(String code, String redirectUri, String codeVerifier) throws IOException {
        // Exchange code for tokens
        JsonObject tokens = exchangeCodeForTokens(code, redirectUri, codeVerifier);

        this.accessToken = tokens.get("access_token").getAsString();
        this.refreshToken = tokens.has("refresh_token") && !tokens.get("refresh_token").isJsonNull()
            ? tokens.get("refresh_token").getAsString() : null;
        this.expiresAt = System.currentTimeMillis() +
            (tokens.has("expires_in") ? tokens.get("expires_in").getAsLong() * 1000L : 3600000L);

        if (this.refreshToken == null || this.refreshToken.isEmpty()) {
            throw new IOException("Missing refresh token in response");
        }

        // Fetch user info (email)
        fetchUserInfo(this.accessToken);

        // Setup user via Code Assist (project discovery)
        setupUser(this.accessToken);

        Msg.info(this, "Google Gemini OAuth authentication successful!" +
            (email != null ? " Email: " + email : "") +
            (projectId != null ? " Project: " + projectId : ""));

        // Clean up
        pendingCodeVerifier = null;
        pendingState = null;
        pendingRedirectUri = null;
    }

    // =========================================================================
    // Token Management
    // =========================================================================

    public String getValidAccessToken() throws IOException {
        if (!isAuthenticated()) {
            throw new IllegalStateException("Not authenticated. Call authenticate() first.");
        }

        if (isTokenExpired()) {
            refreshAccessToken();
        }

        return accessToken;
    }

    public void refreshAccessToken() throws IOException {
        if (refreshToken == null || refreshToken.isEmpty()) {
            throw new IllegalStateException("No refresh token available. Re-authentication required.");
        }

        Msg.info(this, "Refreshing Google Gemini access token...");

        // Form-encoded with client_secret
        FormBody formBody = new FormBody.Builder()
            .add("grant_type", "refresh_token")
            .add("refresh_token", refreshToken)
            .add("client_id", CLIENT_ID)
            .add("client_secret", CLIENT_SECRET)
            .build();

        Request request = new Request.Builder()
            .url(TOKEN_ENDPOINT)
            .post(formBody)
            .header("Content-Type", "application/x-www-form-urlencoded")
            .build();

        try (Response response = httpClient.newCall(request).execute()) {
            String body = response.body() != null ? response.body().string() : "";

            if (!response.isSuccessful()) {
                Msg.error(this, "Token refresh failed: " + response.code() + " - " + body);
                throw new IOException("Token refresh failed: " + response.code() + " - " + body);
            }

            JsonObject json = gson.fromJson(body, JsonObject.class);

            this.accessToken = json.get("access_token").getAsString();
            // Google refresh response may omit refresh_token - preserve original
            if (json.has("refresh_token") && !json.get("refresh_token").isJsonNull()) {
                this.refreshToken = json.get("refresh_token").getAsString();
            }
            this.expiresAt = System.currentTimeMillis() +
                (json.has("expires_in") ? json.get("expires_in").getAsLong() * 1000L : 3600000L);

            Msg.info(this, "Google Gemini access token refreshed successfully");
        }
    }

    public void cancelAuthentication() {
        if (callbackServer != null) {
            callbackServer.stop();
            callbackServer = null;
        }
        pendingCodeVerifier = null;
        pendingState = null;
        pendingRedirectUri = null;
    }

    public OAuthCallbackServer getCallbackServer() {
        return callbackServer;
    }

    public void logout() {
        accessToken = null;
        refreshToken = null;
        expiresAt = 0;
        email = null;
        projectId = null;
        tier = null;
        tierName = null;
        Msg.info(this, "Google Gemini OAuth credentials cleared");
    }

    // =========================================================================
    // Serialization
    // =========================================================================

    public String toJson() {
        JsonObject json = new JsonObject();
        json.addProperty("access_token", accessToken != null ? accessToken : "");
        json.addProperty("refresh_token", refreshToken != null ? refreshToken : "");
        json.addProperty("expires_at", expiresAt);
        json.addProperty("email", email != null ? email : "");
        json.addProperty("project_id", projectId != null ? projectId : "");
        json.addProperty("tier", tier != null ? tier : "");
        json.addProperty("tier_name", tierName != null ? tierName : "");
        return gson.toJson(json);
    }

    public void loadFromJson(String json) {
        try {
            JsonObject obj = gson.fromJson(json, JsonObject.class);

            if (obj.has("access_token") && !obj.get("access_token").isJsonNull()) {
                this.accessToken = obj.get("access_token").getAsString();
            }
            if (obj.has("refresh_token") && !obj.get("refresh_token").isJsonNull()) {
                this.refreshToken = obj.get("refresh_token").getAsString();
            }
            if (obj.has("expires_at")) {
                this.expiresAt = obj.get("expires_at").getAsLong();
            }
            if (obj.has("email") && !obj.get("email").isJsonNull()) {
                this.email = obj.get("email").getAsString();
                if (this.email.isEmpty()) this.email = null;
            }
            if (obj.has("project_id") && !obj.get("project_id").isJsonNull()) {
                this.projectId = obj.get("project_id").getAsString();
                if (this.projectId.isEmpty()) this.projectId = null;
            }
            if (obj.has("tier") && !obj.get("tier").isJsonNull()) {
                this.tier = obj.get("tier").getAsString();
                if (this.tier.isEmpty()) this.tier = null;
            }
            if (obj.has("tier_name") && !obj.get("tier_name").isJsonNull()) {
                this.tierName = obj.get("tier_name").getAsString();
                if (this.tierName.isEmpty()) this.tierName = null;
            }

            Msg.debug(this, "Loaded Google Gemini OAuth credentials from JSON");
        } catch (Exception e) {
            Msg.warn(this, "Failed to parse Google Gemini OAuth credentials: " + e.getMessage());
        }
    }

    // =========================================================================
    // Token Exchange
    // =========================================================================

    /**
     * Exchanges the authorization code for tokens.
     * Form-encoded with client_secret (unlike OpenAI/Anthropic which are public clients).
     */
    private JsonObject exchangeCodeForTokens(String code, String redirectUri, String codeVerifier) throws IOException {
        FormBody.Builder formBuilder = new FormBody.Builder()
            .add("client_id", CLIENT_ID)
            .add("client_secret", CLIENT_SECRET)
            .add("code", code)
            .add("grant_type", "authorization_code")
            .add("redirect_uri", redirectUri);

        if (codeVerifier != null) {
            formBuilder.add("code_verifier", codeVerifier);
        }

        Request request = new Request.Builder()
            .url(TOKEN_ENDPOINT)
            .post(formBuilder.build())
            .header("Content-Type", "application/x-www-form-urlencoded")
            .build();

        try (Response response = httpClient.newCall(request).execute()) {
            String body = response.body() != null ? response.body().string() : "";

            if (!response.isSuccessful()) {
                throw new IOException("Token exchange failed: " + response.code() + " - " + body);
            }

            JsonObject json = gson.fromJson(body, JsonObject.class);
            if (json.has("error")) {
                String errorDesc = json.has("error_description")
                    ? json.get("error_description").getAsString()
                    : json.get("error").getAsString();
                throw new IOException("Token exchange failed: " + errorDesc);
            }

            return json;
        }
    }

    // =========================================================================
    // User Info
    // =========================================================================

    /**
     * Fetches user info (email) from Google's userinfo v2 endpoint.
     */
    private void fetchUserInfo(String accessToken) {
        try {
            Request request = new Request.Builder()
                .url(USER_INFO_URL)
                .get()
                .header("Authorization", "Bearer " + accessToken)
                .build();

            try (Response response = httpClient.newCall(request).execute()) {
                if (response.isSuccessful() && response.body() != null) {
                    JsonObject userInfo = gson.fromJson(response.body().string(), JsonObject.class);
                    if (userInfo.has("email") && !userInfo.get("email").isJsonNull()) {
                        this.email = userInfo.get("email").getAsString();
                        Msg.info(this, "Authenticated as: " + this.email);
                    }
                }
            }
        } catch (Exception e) {
            Msg.warn(this, "Could not fetch user info: " + e.getMessage());
        }
    }

    // =========================================================================
    // Code Assist Setup (loadCodeAssist + onboardUser)
    // =========================================================================

    /**
     * Full user setup flow matching Gemini CLI setup.ts setupUser():
     * 1. loadCodeAssist to discover project and tier
     * 2. onboardUser if needed (for free tier)
     */
    private void setupUser(String accessToken) {
        try {
            Msg.info(this, "Setting up user via Code Assist...");

            // Check environment for project ID
            String envProject = System.getenv("GOOGLE_CLOUD_PROJECT");
            if (envProject == null || envProject.isEmpty()) {
                envProject = System.getenv("GOOGLE_CLOUD_PROJECT_ID");
            }

            JsonObject loadResult = loadCodeAssist(accessToken, envProject);
            if (loadResult == null || loadResult.size() == 0) {
                this.projectId = envProject;
                return;
            }

            // If user already has a current tier
            if (loadResult.has("currentTier") && !loadResult.get("currentTier").isJsonNull()) {
                JsonObject currentTier = loadResult.getAsJsonObject("currentTier");
                this.projectId = loadResult.has("cloudaicompanionProject")
                    ? loadResult.get("cloudaicompanionProject").getAsString()
                    : (envProject != null ? envProject : "");

                JsonObject effectiveTier = loadResult.has("paidTier") && !loadResult.get("paidTier").isJsonNull()
                    ? loadResult.getAsJsonObject("paidTier")
                    : currentTier;

                this.tier = effectiveTier.has("id") ? effectiveTier.get("id").getAsString() : "";
                this.tierName = effectiveTier.has("name") ? effectiveTier.get("name").getAsString() : "";

                Msg.info(this, "Code Assist project: " + this.projectId + ", tier: " + this.tier + " (" + this.tierName + ")");
                return;
            }

            // Need to onboard - find default tier from allowedTiers
            String onboardTierId = "LEGACY";
            String onboardTierName = "";

            if (loadResult.has("allowedTiers") && loadResult.get("allowedTiers").isJsonArray()) {
                JsonArray allowedTiers = loadResult.getAsJsonArray("allowedTiers");
                for (JsonElement tierElement : allowedTiers) {
                    if (tierElement.isJsonObject()) {
                        JsonObject t = tierElement.getAsJsonObject();
                        if (t.has("isDefault") && t.get("isDefault").getAsBoolean()) {
                            onboardTierId = t.has("id") ? t.get("id").getAsString() : "LEGACY";
                            onboardTierName = t.has("name") ? t.get("name").getAsString() : "";
                            break;
                        }
                    }
                }
            }

            Msg.info(this, "Onboarding user for tier: " + onboardTierId + " (" + onboardTierName + ")");
            JsonObject onboardResult = onboardUser(accessToken, onboardTierId, envProject);

            // Extract project from onboard response
            String project = "";
            if (onboardResult != null) {
                if (onboardResult.has("response") && onboardResult.get("response").isJsonObject()) {
                    JsonObject respData = onboardResult.getAsJsonObject("response");
                    if (respData.has("cloudaicompanionProject")) {
                        JsonElement cap = respData.get("cloudaicompanionProject");
                        if (cap.isJsonObject()) {
                            project = cap.getAsJsonObject().has("id")
                                ? cap.getAsJsonObject().get("id").getAsString() : "";
                        } else if (cap.isJsonPrimitive()) {
                            project = cap.getAsString();
                        }
                    }
                }
            }

            if (project.isEmpty() && envProject != null) {
                project = envProject;
            }

            this.projectId = project;
            this.tier = onboardTierId;
            this.tierName = onboardTierName;

            Msg.info(this, "Code Assist setup complete. Project: " + this.projectId + ", tier: " + this.tier);

        } catch (Exception e) {
            Msg.warn(this, "Code Assist setup failed (non-fatal): " + e.getMessage());
        }
    }

    /**
     * Load Code Assist configuration (matches loadCodeAssist from setup.ts).
     */
    private JsonObject loadCodeAssist(String accessToken, String projectId) {
        try {
            JsonObject metadata = new JsonObject();
            metadata.addProperty("ideType", "IDE_UNSPECIFIED");
            metadata.addProperty("platform", "PLATFORM_UNSPECIFIED");
            metadata.addProperty("pluginType", "GEMINI");
            if (projectId != null && !projectId.isEmpty()) {
                metadata.addProperty("duetProject", projectId);
            }

            JsonObject body = new JsonObject();
            if (projectId != null && !projectId.isEmpty()) {
                body.addProperty("cloudaicompanionProject", projectId);
            }
            body.add("metadata", metadata);

            String url = CODE_ASSIST_ENDPOINT + "/" + CODE_ASSIST_API_VERSION + ":loadCodeAssist";

            Request request = new Request.Builder()
                .url(url)
                .post(RequestBody.create(gson.toJson(body).getBytes(StandardCharsets.UTF_8),
                    MediaType.get("application/json")))
                .header("Authorization", "Bearer " + accessToken)
                .header("Content-Type", "application/json")
                .header("User-Agent", "GeminiCLI/1.0.0/gemini-2.5-flash (" + getOsPlatform() + "; " + getOsArch() + ")")
                .build();

            try (Response response = httpClient.newCall(request).execute()) {
                if (response.isSuccessful() && response.body() != null) {
                    return gson.fromJson(response.body().string(), JsonObject.class);
                }
                Msg.debug(this, "loadCodeAssist failed: " + response.code());
                return null;
            }
        } catch (Exception e) {
            Msg.debug(this, "loadCodeAssist error: " + e.getMessage());
            return null;
        }
    }

    /**
     * Onboard a user for Code Assist (matches onboardUser from setup.ts).
     */
    private JsonObject onboardUser(String accessToken, String tierId, String projectId) {
        try {
            JsonObject metadata = new JsonObject();
            metadata.addProperty("ideType", "IDE_UNSPECIFIED");
            metadata.addProperty("platform", "PLATFORM_UNSPECIFIED");
            metadata.addProperty("pluginType", "GEMINI");

            JsonObject body = new JsonObject();
            body.addProperty("tierId", tierId);

            if (!"FREE".equals(tierId) && projectId != null && !projectId.isEmpty()) {
                body.addProperty("cloudaicompanionProject", projectId);
                metadata.addProperty("duetProject", projectId);
            }
            body.add("metadata", metadata);

            String url = CODE_ASSIST_ENDPOINT + "/" + CODE_ASSIST_API_VERSION + ":onboardUser";

            Request request = new Request.Builder()
                .url(url)
                .post(RequestBody.create(gson.toJson(body).getBytes(StandardCharsets.UTF_8),
                    MediaType.get("application/json")))
                .header("Authorization", "Bearer " + accessToken)
                .header("Content-Type", "application/json")
                .header("User-Agent", "GeminiCLI/1.0.0/gemini-2.5-flash (" + getOsPlatform() + "; " + getOsArch() + ")")
                .build();

            try (Response response = httpClient.newCall(request).execute()) {
                if (response.isSuccessful() && response.body() != null) {
                    return gson.fromJson(response.body().string(), JsonObject.class);
                }
                Msg.debug(this, "onboardUser failed: " + response.code());
                return null;
            }
        } catch (Exception e) {
            Msg.debug(this, "onboardUser error: " + e.getMessage());
            return null;
        }
    }

    // =========================================================================
    // Authorization URL Builders
    // =========================================================================

    /**
     * Browser mode auth URL: NO PKCE, just state + access_type=offline.
     */
    private String buildBrowserAuthUrl(String state, String redirectUri) {
        StringBuilder url = new StringBuilder(AUTH_ENDPOINT);
        url.append("?client_id=").append(urlEncode(CLIENT_ID));
        url.append("&response_type=code");
        url.append("&redirect_uri=").append(urlEncode(redirectUri));
        url.append("&scope=").append(urlEncode(SCOPES));
        url.append("&state=").append(urlEncode(state));
        url.append("&access_type=offline");
        return url.toString();
    }

    /**
     * Headless mode auth URL: WITH PKCE S256 + access_type=offline.
     */
    private String buildHeadlessAuthUrl(String codeChallenge, String state) {
        StringBuilder url = new StringBuilder(AUTH_ENDPOINT);
        url.append("?client_id=").append(urlEncode(CLIENT_ID));
        url.append("&response_type=code");
        url.append("&redirect_uri=").append(urlEncode(HEADLESS_REDIRECT_URI));
        url.append("&scope=").append(urlEncode(SCOPES));
        url.append("&code_challenge=").append(urlEncode(codeChallenge));
        url.append("&code_challenge_method=S256");
        url.append("&state=").append(urlEncode(state));
        url.append("&access_type=offline");
        return url.toString();
    }

    // =========================================================================
    // PKCE Methods (for headless mode only)
    // =========================================================================

    private String generateCodeVerifier() {
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[32];
        random.nextBytes(bytes);
        return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes);
    }

    private String generateCodeChallenge(String codeVerifier) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(codeVerifier.getBytes(StandardCharsets.US_ASCII));
            return Base64.getUrlEncoder().withoutPadding().encodeToString(hash);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("SHA-256 not available", e);
        }
    }

    private String generateState() {
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[32];
        random.nextBytes(bytes);
        // Match crypto.randomBytes(32).toString('hex') from Gemini CLI
        StringBuilder hex = new StringBuilder();
        for (byte b : bytes) {
            hex.append(String.format("%02x", b));
        }
        return hex.toString();
    }

    // =========================================================================
    // Utility Methods
    // =========================================================================

    private String urlEncode(String value) {
        return URLEncoder.encode(value, StandardCharsets.UTF_8);
    }

    private void openBrowser(String url) {
        try {
            if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {
                Desktop.getDesktop().browse(new URI(url));
            } else {
                String os = System.getProperty("os.name").toLowerCase();
                Runtime rt = Runtime.getRuntime();
                if (os.contains("mac")) {
                    rt.exec(new String[]{"open", url});
                } else if (os.contains("win")) {
                    rt.exec(new String[]{"rundll32", "url.dll,FileProtocolHandler", url});
                } else {
                    rt.exec(new String[]{"xdg-open", url});
                }
            }
        } catch (Exception e) {
            Msg.error(this, "Could not open browser: " + e.getMessage());
            Msg.info(this, "Please open this URL manually: " + url);
        }
    }

    private String extractCodeFromInput(String input) {
        // Try to parse as URL
        if (input.startsWith("http")) {
            try {
                java.net.URL url = java.net.URI.create(input).toURL();
                String query = url.getQuery();
                if (query != null) {
                    for (String param : query.split("&")) {
                        String[] pair = param.split("=", 2);
                        if (pair.length == 2 && "code".equals(pair[0])) {
                            return java.net.URLDecoder.decode(pair[1], StandardCharsets.UTF_8);
                        }
                    }
                }
            } catch (Exception e) {
                Msg.debug(this, "Failed to parse as URL, using input as-is: " + e.getMessage());
            }
        }
        return input;
    }

    private String getOsPlatform() {
        String os = System.getProperty("os.name", "").toLowerCase();
        if (os.contains("linux")) return "linux";
        if (os.contains("mac") || os.contains("darwin")) return "darwin";
        if (os.contains("win")) return "win32";
        return os;
    }

    private String getOsArch() {
        String arch = System.getProperty("os.arch", "");
        if ("amd64".equals(arch) || "x86_64".equals(arch)) return "x86_64";
        if ("aarch64".equals(arch) || "arm64".equals(arch)) return "arm64";
        return arch;
    }
}

```

`src/main/java/ghidrassist/apiprovider/oauth/OAuthCallbackServer.java`:

```java
package ghidrassist.apiprovider.oauth;

import com.sun.net.httpserver.HttpServer;
import com.sun.net.httpserver.HttpExchange;
import ghidra.util.Msg;

import java.io.IOException;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

/**
 * Local HTTP server for receiving OAuth callbacks from OAuth authorization flows.
 * 
 * This server listens on a configured port (with fallback) and waits for the OAuth 
 * redirect with the authorization code. It validates the state parameter to prevent 
 * CSRF attacks.
 * 
 * Supports both Anthropic (port 1456, /callback) and OpenAI (port 1455, /auth/callback).
 */
public class OAuthCallbackServer {
    
    // Default ports for OAuth providers
    public static final int OPENAI_DEFAULT_PORT = 1455;
    public static final int ANTHROPIC_DEFAULT_PORT = 1456;
    private static final int PORT_FALLBACK_RANGE = 5;
    
    private static final String SUCCESS_HTML = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>Authentication Successful - GhidrAssist</title>
            <meta charset="utf-8">
            <style>
                * {
                    margin: 0;
                    padding: 0;
                    box-sizing: border-box;
                }
                body {
                    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
                    background: linear-gradient(135deg, #667eea 0%%, #764ba2 100%%);
                    min-height: 100vh;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    padding: 20px;
                }
                .container {
                    background: white;
                    padding: 50px 40px;
                    border-radius: 16px;
                    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                    text-align: center;
                    max-width: 450px;
                    width: 100%%;
                }
                .checkmark {
                    width: 80px;
                    height: 80px;
                    background: linear-gradient(135deg, #4CAF50 0%%, #45a049 100%%);
                    border-radius: 50%%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    margin: 0 auto 25px;
                    box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
                }
                .checkmark svg {
                    width: 40px;
                    height: 40px;
                    fill: white;
                }
                h1 {
                    color: #1a1a2e;
                    font-size: 24px;
                    font-weight: 600;
                    margin-bottom: 12px;
                }
                .provider {
                    color: #667eea;
                    font-weight: 600;
                }
                p {
                    color: #666;
                    font-size: 16px;
                    line-height: 1.6;
                    margin-bottom: 8px;
                }
                .hint {
                    color: #999;
                    font-size: 14px;
                    margin-top: 20px;
                    padding-top: 20px;
                    border-top: 1px solid #eee;
                }
                .app-name {
                    color: #764ba2;
                    font-weight: 600;
                }
            </style>
        </head>
        <body>
            <div class="container">
                <div class="checkmark">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
                    </svg>
                </div>
                <h1>Authentication Successful</h1>
                <p>You have successfully authenticated.</p>
                <p class="hint">You can close this tab and return to <span class="app-name">Ghidra</span>.</p>
            </div>
        </body>
        </html>
        """;
    
    private static final String ERROR_HTML = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>Authentication Failed - GhidrAssist</title>
            <meta charset="utf-8">
            <style>
                * {
                    margin: 0;
                    padding: 0;
                    box-sizing: border-box;
                }
                body {
                    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
                    background: linear-gradient(135deg, #e74c3c 0%%, #c0392b 100%%);
                    min-height: 100vh;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    padding: 20px;
                }
                .container {
                    background: white;
                    padding: 50px 40px;
                    border-radius: 16px;
                    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                    text-align: center;
                    max-width: 450px;
                    width: 100%%;
                }
                .error-icon {
                    width: 80px;
                    height: 80px;
                    background: linear-gradient(135deg, #e74c3c 0%%, #c0392b 100%%);
                    border-radius: 50%%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    margin: 0 auto 25px;
                    box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
                }
                .error-icon svg {
                    width: 40px;
                    height: 40px;
                    fill: white;
                }
                h1 {
                    color: #1a1a2e;
                    font-size: 24px;
                    font-weight: 600;
                    margin-bottom: 12px;
                }
                p {
                    color: #666;
                    font-size: 16px;
                    line-height: 1.6;
                    margin-bottom: 8px;
                }
                .error-details {
                    background: #fff5f5;
                    border: 1px solid #feb2b2;
                    border-radius: 8px;
                    padding: 15px;
                    margin: 20px 0;
                    color: #c53030;
                    font-size: 14px;
                    word-break: break-word;
                }
                .hint {
                    color: #999;
                    font-size: 14px;
                    margin-top: 20px;
                    padding-top: 20px;
                    border-top: 1px solid #eee;
                }
            </style>
        </head>
        <body>
            <div class="container">
                <div class="error-icon">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                    </svg>
                </div>
                <h1>Authentication Failed</h1>
                <p>An error occurred during authentication.</p>
                <div class="error-details">%s</div>
                <p class="hint">Please close this tab and try again in Ghidra.</p>
            </div>
        </body>
        </html>
        """;
    
    private HttpServer server;
    private int port;
    private final CompletableFuture<String> authCodeFuture;
    private final String expectedState;
    private final String callbackPath;
    private final int preferredPort;
    private final boolean validateState;
    
    /**
     * Creates a new OAuth callback server with default settings.
     * Uses dynamic port allocation and /callback path.
     * 
     * @param expectedState The state parameter to validate against CSRF attacks
     */
    public OAuthCallbackServer(String expectedState) {
        this(expectedState, "/callback", 0, true);
    }
    
    /**
     * Creates a new OAuth callback server with custom configuration.
     * 
     * @param expectedState The state parameter to validate against CSRF attacks
     * @param callbackPath The path for the callback endpoint (e.g., "/callback" or "/auth/callback")
     * @param preferredPort The preferred port to use (0 for dynamic allocation)
     * @param validateState Whether to validate the state parameter
     */
    public OAuthCallbackServer(String expectedState, String callbackPath, int preferredPort, boolean validateState) {
        this.expectedState = expectedState;
        this.callbackPath = callbackPath;
        this.preferredPort = preferredPort;
        this.validateState = validateState;
        this.authCodeFuture = new CompletableFuture<>();
    }
    
    /**
     * Creates an OAuth callback server configured for OpenAI OAuth.
     * Uses port 1455 with /auth/callback path.
     * 
     * @param expectedState The state parameter to validate against CSRF attacks
     * @return A configured OAuthCallbackServer for OpenAI
     */
    public static OAuthCallbackServer forOpenAI(String expectedState) {
        return new OAuthCallbackServer(expectedState, "/auth/callback", OPENAI_DEFAULT_PORT, true);
    }
    
    /**
     * Creates an OAuth callback server configured for Anthropic OAuth.
     * Uses port 1456 with /callback path.
     * 
     * @param expectedState The state parameter to validate against CSRF attacks
     * @return A configured OAuthCallbackServer for Anthropic
     */
    public static OAuthCallbackServer forAnthropic(String expectedState) {
        return new OAuthCallbackServer(expectedState, "/callback", ANTHROPIC_DEFAULT_PORT, true);
    }
    
    /**
     * Creates an OAuth callback server configured for Google Gemini OAuth.
     * Uses dynamic port (port 0) with /oauth2callback path, matching the Gemini CLI.
     *
     * @param expectedState The state parameter to validate against CSRF attacks
     * @return A configured OAuthCallbackServer for Gemini
     */
    public static OAuthCallbackServer forGemini(String expectedState) {
        return new OAuthCallbackServer(expectedState, "/oauth2callback", 0, true);
    }

    /**
     * Starts the callback server on the preferred port (with fallback).
     * 
     * @return The port number the server is listening on
     * @throws IOException If the server cannot be started on any port
     */
    public int start() throws IOException {
        if (preferredPort > 0) {
            // Try preferred port first, then fallback ports
            port = findAvailablePortWithFallback(preferredPort);
        } else {
            // Dynamic port allocation
            port = findAvailablePort();
        }
        
        // Create and configure the server
        server = HttpServer.create(new InetSocketAddress("localhost", port), 0);
        server.createContext(callbackPath, this::handleCallback);
        server.setExecutor(null); // Use default executor
        server.start();
        
        Msg.info(this, "OAuth callback server started on port " + port + " with path " + callbackPath);
        return port;
    }
    
    /**
     * Waits for the authorization code with a timeout.
     * 
     * @param timeoutMinutes Timeout in minutes
     * @return The authorization code
     * @throws Exception If the wait times out or an error occurs
     */
    public String waitForCode(int timeoutMinutes) throws Exception {
        try {
            return authCodeFuture.get(timeoutMinutes, TimeUnit.MINUTES);
        } finally {
            // Delay stop to allow the success HTML page to be fully sent to browser
            stopDelayed(1);
        }
    }
    
    /**
     * Gets the future that will be completed with the authorization code.
     * 
     * @return The CompletableFuture for the authorization code
     */
    public CompletableFuture<String> getAuthCodeFuture() {
        return authCodeFuture;
    }
    
    /**
     * Stops the callback server immediately.
     */
    public void stop() {
        stopDelayed(0);
    }
    
    /**
     * Stops the callback server with a delay to allow pending responses to complete.
     * 
     * @param delaySeconds Seconds to wait for pending exchanges to finish
     */
    public void stopDelayed(int delaySeconds) {
        if (server != null) {
            server.stop(delaySeconds);
            server = null;
            Msg.info(this, "OAuth callback server stopped");
        }
    }
    
    /**
     * Gets the port the server is listening on.
     * 
     * @return The port number
     */
    public int getPort() {
        return port;
    }
    
    /**
     * Gets the redirect URI for this server.
     * 
     * @return The redirect URI (e.g., "http://localhost:12345/callback")
     */
    public String getRedirectUri() {
        return "http://localhost:" + port + callbackPath;
    }
    
    /**
     * Finds a dynamic available port for the callback server.
     */
    private int findAvailablePort() throws IOException {
        try (ServerSocket socket = new ServerSocket(0)) {
            socket.setReuseAddress(true);
            return socket.getLocalPort();
        }
    }
    
    /**
     * Tries to find an available port starting from the preferred port.
     * Falls back to subsequent ports if the preferred port is unavailable.
     * 
     * @param preferred The preferred port to start with
     * @return An available port
     * @throws IOException If no port in the range is available
     */
    private int findAvailablePortWithFallback(int preferred) throws IOException {
        for (int i = 0; i <= PORT_FALLBACK_RANGE; i++) {
            int testPort = preferred + i;
            if (isPortAvailable(testPort)) {
                if (i > 0) {
                    Msg.info(this, "Preferred port " + preferred + " unavailable, using port " + testPort);
                }
                return testPort;
            }
        }
        // Fall back to dynamic allocation if all preferred ports are taken
        Msg.warn(this, "All preferred ports (" + preferred + "-" + (preferred + PORT_FALLBACK_RANGE) + 
                      ") unavailable, using dynamic port");
        return findAvailablePort();
    }
    
    /**
     * Checks if a specific port is available.
     */
    private boolean isPortAvailable(int testPort) {
        try (ServerSocket socket = new ServerSocket(testPort)) {
            socket.setReuseAddress(true);
            return true;
        } catch (IOException e) {
            return false;
        }
    }
    
    /**
     * Handles the OAuth callback request.
     */
    private void handleCallback(HttpExchange exchange) throws IOException {
        String query = exchange.getRequestURI().getQuery();
        String response;
        int statusCode;
        
        try {
            // Parse query parameters
            String code = null;
            String state = null;
            String error = null;
            String errorDescription = null;
            
            if (query != null) {
                for (String param : query.split("&")) {
                    String[] pair = param.split("=", 2);
                    if (pair.length == 2) {
                        String key = URLDecoder.decode(pair[0], StandardCharsets.UTF_8);
                        String value = URLDecoder.decode(pair[1], StandardCharsets.UTF_8);
                        switch (key) {
                            case "code" -> code = value;
                            case "state" -> state = value;
                            case "error" -> error = value;
                            case "error_description" -> errorDescription = value;
                        }
                    }
                }
            }
            
            // Check for OAuth error
            if (error != null) {
                String errorMsg = errorDescription != null ? errorDescription : error;
                throw new OAuthException("OAuth error: " + errorMsg);
            }
            
            // Validate code is present
            if (code == null || code.isEmpty()) {
                throw new OAuthException("No authorization code received");
            }
            
            // Validate state parameter to prevent CSRF (if enabled)
            if (validateState && (state == null || !state.equals(expectedState))) {
                throw new OAuthException("State mismatch - possible CSRF attack");
            }
            
            // Success - complete the future with the authorization code
            authCodeFuture.complete(code);
            response = SUCCESS_HTML;
            statusCode = 200;
            
            Msg.info(this, "OAuth callback received authorization code");
            
        } catch (OAuthException e) {
            // Error - complete the future exceptionally
            authCodeFuture.completeExceptionally(e);
            response = String.format(ERROR_HTML, escapeHtml(e.getMessage()));
            statusCode = 400;
            
            Msg.error(this, "OAuth callback error: " + e.getMessage());
        }
        
        // Send response
        exchange.getResponseHeaders().add("Content-Type", "text/html; charset=utf-8");
        byte[] responseBytes = response.getBytes(StandardCharsets.UTF_8);
        exchange.sendResponseHeaders(statusCode, responseBytes.length);
        try (OutputStream os = exchange.getResponseBody()) {
            os.write(responseBytes);
        }
    }
    
    /**
     * Escapes HTML special characters.
     */
    private String escapeHtml(String text) {
        if (text == null) return "";
        return text.replace("&", "&amp;")
                   .replace("<", "&lt;")
                   .replace(">", "&gt;")
                   .replace("\"", "&quot;")
                   .replace("'", "&#39;");
    }
    
    /**
     * Exception for OAuth-related errors.
     */
    public static class OAuthException extends Exception {
        private static final long serialVersionUID = 1L;

        public OAuthException(String message) {
            super(message);
        }
        
        public OAuthException(String message, Throwable cause) {
            super(message, cause);
        }
    }
}

```

`src/main/java/ghidrassist/apiprovider/oauth/OAuthTokenManager.java`:

```java
package ghidrassist.apiprovider.oauth;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import ghidra.util.Msg;
import okhttp3.*;

import java.awt.Desktop;
import java.io.IOException;
import java.net.URI;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Base64;
import java.util.concurrent.TimeUnit;

/**
 * Manages OAuth 2.0 authentication with Anthropic's Claude Pro/Max API.
 * 
 * This class handles the complete OAuth flow including:
 * - PKCE (Proof Key for Code Exchange) generation
 * - Browser-based authorization
 * - Token exchange
 * - Token refresh
 * - Token storage (as JSON in the provider's key field)
 */
public class OAuthTokenManager {
    
    // OAuth Configuration - Official Anthropic OAuth Client ID
    private static final String CLIENT_ID = "9d1c250a-e61b-44d9-88ed-5944d1962f5e";
    private static final String AUTH_ENDPOINT = "https://claude.ai/oauth/authorize";
    private static final String TOKEN_ENDPOINT = "https://console.anthropic.com/v1/oauth/token";
    // Default redirect URI - Anthropic's hosted callback page (for manual code entry)
    private static final String DEFAULT_REDIRECT_URI = "https://console.anthropic.com/oauth/code/callback";
    private static final String SCOPES = "user:profile user:inference user:sessions:claude_code";
    
    // Token expiry buffer (5 minutes before actual expiry)
    private static final long EXPIRY_BUFFER_MS = 5 * 60 * 1000;
    
    private final OkHttpClient httpClient;
    private final Gson gson;
    
    // Token storage
    private String accessToken;
    private String refreshToken;
    private long expiresAt; // Unix timestamp in milliseconds
    
    // PKCE state for current auth flow
    private String pendingCodeVerifier;
    private String pendingState;
    private String pendingRedirectUri;
    private OAuthCallbackServer callbackServer;
    
    /**
     * Creates a new OAuthTokenManager.
     */
    public OAuthTokenManager() {
        this.httpClient = new OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build();
        this.gson = new Gson();
    }
    
    /**
     * Creates a new OAuthTokenManager with existing credentials.
     * 
     * @param credentialsJson JSON string containing access_token, refresh_token, and expires_at
     */
    public OAuthTokenManager(String credentialsJson) {
        this();
        if (credentialsJson != null && !credentialsJson.isEmpty()) {
            loadFromJson(credentialsJson);
        }
    }
    
    /**
     * Checks if valid OAuth credentials exist.
     * 
     * @return true if there is a valid access token
     */
    public boolean isAuthenticated() {
        return accessToken != null && !accessToken.isEmpty();
    }
    
    /**
     * Checks if the current token is expired or about to expire.
     * 
     * @return true if the token needs to be refreshed
     */
    public boolean isTokenExpired() {
        return System.currentTimeMillis() >= (expiresAt - EXPIRY_BUFFER_MS);
    }
    
    /**
     * Starts the OAuth authorization flow by opening the browser.
     * Returns the code verifier needed for token exchange.
     * Uses Anthropic's hosted callback page (for manual code entry).
     * 
     * @return The code verifier to use when calling completeAuthorization
     */
    public String startAuthorizationFlow() {
        return startAuthorizationFlow(DEFAULT_REDIRECT_URI);
    }
    
    /**
     * Starts the OAuth authorization flow by opening the browser with a custom redirect URI.
     * 
     * @param redirectUri The redirect URI to use
     * @return The code verifier to use when calling completeAuthorization
     */
    public String startAuthorizationFlow(String redirectUri) {
        // Generate PKCE parameters
        pendingCodeVerifier = generateCodeVerifier();
        String codeChallenge = generateCodeChallenge(pendingCodeVerifier);
        pendingRedirectUri = redirectUri;
        
        // Generate separate state for CSRF protection
        pendingState = generateState();
        
        // Build authorization URL with separate state parameter
        String authUrl = buildAuthorizationUrl(codeChallenge, pendingState, redirectUri);
        
        // Open browser
        Msg.info(this, "Opening browser for OAuth authorization...");
        openBrowser(authUrl);
        
        return pendingCodeVerifier;
    }
    
    /**
     * Starts the OAuth authorization flow with automatic callback capture.
     * Opens a local HTTP server to capture the OAuth callback automatically.
     * 
     * Note: Anthropic may not support localhost redirects, so this may fail.
     * Use startAuthorizationFlow() for manual code entry as a fallback.
     * 
     * @return The OAuthCallbackServer that will receive the callback
     * @throws IOException If the callback server cannot be started
     */
    public OAuthCallbackServer startAuthorizationFlowWithCallback() throws IOException {
        // Generate PKCE parameters
        pendingCodeVerifier = generateCodeVerifier();
        String codeChallenge = generateCodeChallenge(pendingCodeVerifier);
        
        // Generate separate state for CSRF protection
        pendingState = generateState();
        
        // Create and start callback server with state for validation
        callbackServer = OAuthCallbackServer.forAnthropic(pendingState);
        callbackServer.start();
        
        // Use the callback server's redirect URI
        pendingRedirectUri = callbackServer.getRedirectUri();
        
        // Build authorization URL with callback server's redirect URI and state
        String authUrl = buildAuthorizationUrl(codeChallenge, pendingState, pendingRedirectUri);
        
        Msg.info(this, "Opening browser for Anthropic OAuth authentication with automatic callback...");
        Msg.info(this, "Callback server listening on: " + pendingRedirectUri);
        
        openBrowser(authUrl);
        
        return callbackServer;
    }
    
    /**
     * Completes authentication using the callback server.
     * Waits for the authorization code from the callback server.
     * 
     * @param server The callback server from startAuthorizationFlowWithCallback
     * @param timeoutMinutes Timeout in minutes
     * @throws Exception If authentication fails or times out
     */
    public void completeAuthorizationWithCallback(OAuthCallbackServer server, int timeoutMinutes) throws Exception {
        try {
            String code = server.waitForCode(timeoutMinutes);
            // Exchange code for tokens with separate state parameter
            TokenResponse tokens = exchangeCodeForTokens(code, pendingState, pendingCodeVerifier);
            
            this.accessToken = tokens.accessToken;
            this.refreshToken = tokens.refreshToken;
            this.expiresAt = System.currentTimeMillis() + (tokens.expiresIn * 1000L);
            
            Msg.info(this, "OAuth authentication successful!");
        } finally {
            server.stop();
            callbackServer = null;
            pendingCodeVerifier = null;
            pendingState = null;
        }
    }
    
    /**
     * Cancels the current authentication flow and stops the callback server.
     */
    public void cancelAuthentication() {
        if (callbackServer != null) {
            callbackServer.stop();
            callbackServer = null;
        }
        pendingCodeVerifier = null;
        pendingState = null;
        pendingRedirectUri = null;
    }
    
    /**
     * Gets the current callback server (if any).
     * 
     * @return The callback server, or null if not using automatic callback
     */
    public OAuthCallbackServer getCallbackServer() {
        return callbackServer;
    }
    
    /**
     * Completes the OAuth authorization by exchanging the code for tokens.
     * Used for manual flow where user copies code from Anthropic's hosted callback page.
     * 
     * @param authorizationCode The authorization code from the browser (format: "code#state" or just "code")
     * @param codeVerifier The code verifier from startAuthorizationFlow
     * @throws IOException If the token exchange fails
     */
    public void completeAuthorization(String authorizationCode, String codeVerifier) throws IOException {
        // Parse code#state format (from Anthropic's hosted callback page)
        String[] parts = authorizationCode.split("#");
        String code = parts[0];
        // For manual flow, use pendingState if available, otherwise try to extract from code#state format
        String state = pendingState != null ? pendingState : (parts.length > 1 ? parts[1] : "");
        
        TokenResponse tokens = exchangeCodeForTokens(code, state, codeVerifier);
        
        this.accessToken = tokens.accessToken;
        this.refreshToken = tokens.refreshToken;
        this.expiresAt = System.currentTimeMillis() + (tokens.expiresIn * 1000L);
        
        Msg.info(this, "OAuth authentication successful!");
        
        // Clean up
        pendingCodeVerifier = null;
        pendingState = null;
    }
    
    /**
     * Performs the complete authentication flow with user interaction.
     * Opens browser and prompts user to paste the authorization code.
     * 
     * @param timeoutMinutes Timeout (not used in manual flow, kept for API compatibility)
     * @throws Exception If authentication fails
     */
    @SuppressWarnings("unused")  // verifier preserved for future interactive auth flow
    public void authenticate(int timeoutMinutes) throws Exception {
        // Start the flow and get verifier
        String verifier = startAuthorizationFlow();

        // Prompt user for the code (this will be handled by SettingsTab UI)
        // For now, throw an exception indicating manual code entry is needed
        throw new UnsupportedOperationException(
            "Use authenticateWithCode(String code) after user provides the authorization code from browser"
        );
    }
    
    /**
     * Performs authentication with a manually entered authorization code.
     * 
     * @param authorizationCode The code copied from the browser (format: "code#state" or just "code")
     * @throws Exception If authentication fails
     */
    public void authenticateWithCode(String authorizationCode) throws Exception {
        if (pendingCodeVerifier == null) {
            throw new IllegalStateException("Call startAuthorizationFlow() first to open the browser");
        }
        
        completeAuthorization(authorizationCode, pendingCodeVerifier);
    }
    
    /**
     * Gets a valid access token, refreshing if necessary.
     * 
     * @return A valid access token
     * @throws IOException If token refresh fails
     */
    public String getValidAccessToken() throws IOException {
        if (!isAuthenticated()) {
            throw new IllegalStateException("Not authenticated. Call authenticate() first.");
        }
        
        if (isTokenExpired()) {
            refreshAccessToken();
        }
        
        return accessToken;
    }
    
    /**
     * Refreshes the access token using the refresh token.
     * 
     * @throws IOException If refresh fails
     */
    public void refreshAccessToken() throws IOException {
        if (refreshToken == null || refreshToken.isEmpty()) {
            throw new IllegalStateException("No refresh token available. Re-authentication required.");
        }
        
        Msg.info(this, "Refreshing OAuth access token...");
        
        // Build JSON request body (Anthropic requires JSON, not form-encoded)
        JsonObject requestJson = new JsonObject();
        requestJson.addProperty("grant_type", "refresh_token");
        requestJson.addProperty("refresh_token", refreshToken);
        requestJson.addProperty("client_id", CLIENT_ID);
        
        RequestBody jsonBody = RequestBody.create(
            gson.toJson(requestJson),
            MediaType.parse("application/json")
        );
        
        Request request = new Request.Builder()
            .url(TOKEN_ENDPOINT)
            .post(jsonBody)
            .header("Content-Type", "application/json")
            .build();
        
        try (Response response = httpClient.newCall(request).execute()) {
            String body = response.body() != null ? response.body().string() : "";
            
            if (!response.isSuccessful()) {
                Msg.error(this, "Token refresh failed: " + response.code() + " - " + body);
                throw new IOException("Token refresh failed: " + response.code() + " - " + body);
            }
            
            JsonObject json = gson.fromJson(body, JsonObject.class);
            
            this.accessToken = json.get("access_token").getAsString();
            if (json.has("refresh_token")) {
                this.refreshToken = json.get("refresh_token").getAsString();
            }
            this.expiresAt = System.currentTimeMillis() + (json.get("expires_in").getAsInt() * 1000L);
            
            Msg.info(this, "OAuth access token refreshed successfully");
        }
    }
    
    /**
     * Clears all stored credentials.
     */
    public void logout() {
        accessToken = null;
        refreshToken = null;
        expiresAt = 0;
        Msg.info(this, "OAuth credentials cleared");
    }
    
    /**
     * Exports credentials to JSON for storage in the provider's key field.
     * 
     * @return JSON string containing credentials
     */
    public String toJson() {
        JsonObject json = new JsonObject();
        json.addProperty("access_token", accessToken != null ? accessToken : "");
        json.addProperty("refresh_token", refreshToken != null ? refreshToken : "");
        json.addProperty("expires_at", expiresAt);
        return gson.toJson(json);
    }
    
    /**
     * Loads credentials from JSON.
     * 
     * @param json JSON string containing credentials
     */
    public void loadFromJson(String json) {
        try {
            JsonObject obj = gson.fromJson(json, JsonObject.class);
            
            if (obj.has("access_token") && !obj.get("access_token").isJsonNull()) {
                this.accessToken = obj.get("access_token").getAsString();
            }
            if (obj.has("refresh_token") && !obj.get("refresh_token").isJsonNull()) {
                this.refreshToken = obj.get("refresh_token").getAsString();
            }
            if (obj.has("expires_at")) {
                this.expiresAt = obj.get("expires_at").getAsLong();
            }
            
            Msg.debug(this, "Loaded OAuth credentials from JSON");
            
        } catch (Exception e) {
            Msg.warn(this, "Failed to parse OAuth credentials: " + e.getMessage());
        }
    }
    
    // =========================================================================
    // PKCE Methods
    // =========================================================================
    
    /**
     * Generates a cryptographically random code verifier for PKCE.
     */
    private String generateCodeVerifier() {
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[32];
        random.nextBytes(bytes);
        return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes);
    }
    
    /**
     * Generates the code challenge from the verifier using SHA-256.
     */
    private String generateCodeChallenge(String codeVerifier) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(codeVerifier.getBytes(StandardCharsets.US_ASCII));
            return Base64.getUrlEncoder().withoutPadding().encodeToString(hash);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("SHA-256 not available", e);
        }
    }
    
    /**
     * Generates a cryptographically random state parameter for CSRF protection.
     * This is separate from the PKCE code verifier.
     */
    private String generateState() {
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[32];
        random.nextBytes(bytes);
        return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes);
    }
    
    // =========================================================================
    // Authorization URL
    // =========================================================================
    
    /**
     * Builds the OAuth authorization URL with all required parameters.
     * 
     * @param codeChallenge PKCE code challenge
     * @param state Random state parameter for CSRF protection (separate from verifier)
     */
    private String buildAuthorizationUrl(String codeChallenge, String state) {
        return buildAuthorizationUrl(codeChallenge, state, DEFAULT_REDIRECT_URI);
    }
    
    /**
     * Builds the OAuth authorization URL with all required parameters and custom redirect URI.
     * 
     * @param codeChallenge PKCE code challenge
     * @param state Random state parameter for CSRF protection (separate from verifier)
     * @param redirectUri The redirect URI to use
     */
    private String buildAuthorizationUrl(String codeChallenge, String state, String redirectUri) {
        try {
            // State is a separate random token for CSRF protection (not the PKCE verifier)
            return AUTH_ENDPOINT + "?" +
                "code=true" +  // Request code display in browser
                "&client_id=" + URLEncoder.encode(CLIENT_ID, StandardCharsets.UTF_8) +
                "&response_type=code" +
                "&redirect_uri=" + URLEncoder.encode(redirectUri, StandardCharsets.UTF_8) +
                "&scope=" + URLEncoder.encode(SCOPES, StandardCharsets.UTF_8) +
                "&code_challenge=" + URLEncoder.encode(codeChallenge, StandardCharsets.UTF_8) +
                "&code_challenge_method=S256" +
                "&state=" + URLEncoder.encode(state, StandardCharsets.UTF_8);
        } catch (Exception e) {
            throw new RuntimeException("Failed to build authorization URL", e);
        }
    }
    
    /**
     * Opens the system default browser to the specified URL.
     */
    private void openBrowser(String url) {
        try {
            if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {
                Desktop.getDesktop().browse(new URI(url));
            } else {
                // Fallback for headless environments
                String os = System.getProperty("os.name").toLowerCase();
                Runtime rt = Runtime.getRuntime();
                if (os.contains("mac")) {
                    rt.exec(new String[]{"open", url});
                } else if (os.contains("win")) {
                    rt.exec(new String[]{"rundll32", "url.dll,FileProtocolHandler", url});
                } else {
                    rt.exec(new String[]{"xdg-open", url});
                }
            }
        } catch (Exception e) {
            Msg.error(this, "Could not open browser: " + e.getMessage());
            Msg.info(this, "Please open this URL manually: " + url);
        }
    }
    
    // =========================================================================
    // Token Exchange
    // =========================================================================
    
    /**
     * Exchanges the authorization code for access and refresh tokens.
     */
    private TokenResponse exchangeCodeForTokens(String code, String state, String codeVerifier) 
            throws IOException {
        
        // Use the redirect URI from the auth flow, or default
        String redirectUri = pendingRedirectUri != null ? pendingRedirectUri : DEFAULT_REDIRECT_URI;
        
        // Build JSON request body (Anthropic requires JSON, not form-encoded)
        JsonObject requestJson = new JsonObject();
        requestJson.addProperty("code", code);
        requestJson.addProperty("state", state);
        requestJson.addProperty("grant_type", "authorization_code");
        requestJson.addProperty("client_id", CLIENT_ID);
        requestJson.addProperty("redirect_uri", redirectUri);
        requestJson.addProperty("code_verifier", codeVerifier);
        
        RequestBody jsonBody = RequestBody.create(
            gson.toJson(requestJson),
            MediaType.parse("application/json")
        );
        
        Request request = new Request.Builder()
            .url(TOKEN_ENDPOINT)
            .post(jsonBody)
            .header("Content-Type", "application/json")
            .build();
        
        try (Response response = httpClient.newCall(request).execute()) {
            String body = response.body() != null ? response.body().string() : "";
            
            if (!response.isSuccessful()) {
                throw new IOException("Token exchange failed: " + response.code() + " - " + body);
            }
            
            JsonObject json = gson.fromJson(body, JsonObject.class);
            
            return new TokenResponse(
                json.get("access_token").getAsString(),
                json.has("refresh_token") ? json.get("refresh_token").getAsString() : null,
                json.get("expires_in").getAsInt()
            );
        }
    }
    
    /**
     * Token response from the OAuth server.
     */
    private record TokenResponse(String accessToken, String refreshToken, int expiresIn) {}
    
    // =========================================================================
    // Getters for testing/debugging
    // =========================================================================
    
    public String getAccessToken() {
        return accessToken;
    }
    
    public String getRefreshToken() {
        return refreshToken;
    }
    
    public long getExpiresAt() {
        return expiresAt;
    }
}

```

`src/main/java/ghidrassist/apiprovider/oauth/OpenAICodexOAuthTest.java`:

```java
package ghidrassist.apiprovider.oauth;

import com.google.gson.Gson;
import com.google.gson.JsonObject;

import java.io.*;
import java.net.*;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Base64;
import java.util.Scanner;

/**
 * Standalone test client for OpenAI Codex OAuth authentication.
 * 
 * This is a direct translation of the working Python client at:
 * /home/jtang613/ml/symgraph/openai_codex_oauth_client.py
 * 
 * Run this to test OAuth flow independently before integrating with GhidrAssist.
 * 
 * Usage: java OpenAICodexOAuthTest
 */
public class OpenAICodexOAuthTest {
    
    // OAuth Configuration - From Codex CLI (codex-cli-rs)
    private static final String CLIENT_ID = "app_EMoamEEZ73f0CkXaXp7hrann";
    private static final String AUTH_URL = "https://auth.openai.com/oauth/authorize";
    private static final String TOKEN_URL = "https://auth.openai.com/oauth/token";
    private static final String REDIRECT_URI = "http://localhost:1455/auth/callback";
    private static final String OAUTH_SCOPES = "openid profile email offline_access";
    
    private static final Gson gson = new Gson();
    
    public static void main(String[] args) throws Exception {
        System.out.println("OpenAI Codex OAuth Test Client");
        System.out.println("=".repeat(50));
        
        // If arguments provided, use them for token exchange
        if (args.length >= 2) {
            String code = args[0];
            String verifier = args[1];
            System.out.println("\nUsing provided code and verifier for token exchange...");
            System.out.println("Code: " + code.substring(0, Math.min(20, code.length())) + "...");
            System.out.println("Verifier: " + verifier.substring(0, 20) + "...");
            
            JsonObject tokens = exchangeCodeForTokens(code, verifier);
            if (tokens.has("error")) {
                System.out.println("ERROR: " + tokens.get("error").getAsString());
                if (tokens.has("error_description")) {
                    System.out.println("Description: " + tokens.get("error_description").getAsString());
                }
            } else {
                System.out.println("\nSUCCESS! Tokens received:");
                System.out.println("  Access token: " + tokens.get("access_token").getAsString().substring(0, 30) + "...");
                if (tokens.has("refresh_token")) {
                    System.out.println("  Refresh token: " + tokens.get("refresh_token").getAsString().substring(0, 30) + "...");
                }
            }
            return;
        }
        
        // Generate PKCE
        String verifier = generateCodeVerifier();
        String challenge = generateCodeChallenge(verifier);
        String state = generateState();
        
        System.out.println("\nGenerated PKCE:");
        System.out.println("  Verifier: " + verifier.substring(0, 20) + "...");
        System.out.println("  Challenge: " + challenge.substring(0, 20) + "...");
        System.out.println("  State: " + state.substring(0, 20) + "...");
        
        // Build authorization URL
        String authUrl = buildAuthorizeUrl(challenge, state);
        
        System.out.println("\nAuthorization URL:");
        System.out.println(authUrl);
        System.out.println();
        
        // Open browser
        System.out.println("Opening browser for authorization...");
        openBrowser(authUrl);
        
        System.out.println("\nAfter authorizing, the browser will redirect to a page that won't load.");
        System.out.println("This is expected! Look at the URL bar - it will look like:");
        System.out.println("  http://localhost:1455/auth/callback?code=XXXX&state=YYYY");
        System.out.println();
        System.out.println("You can paste either:");
        System.out.println("  - The full URL from the browser");
        System.out.println("  - Just the 'code' value (the part after 'code=' and before '&')");
        System.out.println();
        
        // Check if we have interactive input
        String userInput = null;
        if (System.console() != null) {
            userInput = System.console().readLine("Paste the code or full URL here: ");
        } else {
            // Try Scanner, but handle non-interactive mode
            // Note: Intentionally not closing Scanner(System.in) as it would close System.in
            @SuppressWarnings("resource")
            Scanner scanner = new Scanner(System.in);
            System.out.print("Paste the code or full URL here: ");
            if (scanner.hasNextLine()) {
                userInput = scanner.nextLine();
            }
        }
        
        if (userInput == null || userInput.trim().isEmpty()) {
            System.out.println("\nNo input provided. To complete authentication:");
            System.out.println("1. Open the URL above in your browser");
            System.out.println("2. Log in and authorize");
            System.out.println("3. Copy the 'code' from the redirect URL");
            System.out.println("4. Run this test again with the code as an argument:");
            System.out.println("   java ... OpenAICodexOAuthTest <code> <verifier>");
            System.out.println("\nVerifier to use: " + verifier);
            return;
        }
        userInput = userInput.trim();
        
        // Extract code from URL if needed
        String code = extractCode(userInput);
        System.out.println("Using code: " + code.substring(0, Math.min(20, code.length())) + "...");
        
        // Exchange code for tokens
        System.out.println("\nExchanging code for tokens...");
        JsonObject tokens = exchangeCodeForTokens(code, verifier);
        
        if (tokens.has("error")) {
            System.out.println("ERROR: " + tokens.get("error").getAsString());
            if (tokens.has("error_description")) {
                System.out.println("Description: " + tokens.get("error_description").getAsString());
            }
            return;
        }
        
        System.out.println("\nSUCCESS! Tokens received:");
        System.out.println("  Access token: " + tokens.get("access_token").getAsString().substring(0, 30) + "...");
        if (tokens.has("refresh_token")) {
            System.out.println("  Refresh token: " + tokens.get("refresh_token").getAsString().substring(0, 30) + "...");
        }
        if (tokens.has("expires_in")) {
            System.out.println("  Expires in: " + tokens.get("expires_in").getAsInt() + " seconds");
        }
        
        // Extract account ID
        String accountId = extractAccountId(tokens);
        if (accountId != null) {
            System.out.println("  Account ID: " + accountId);
        }
        
        System.out.println("\nOAuth flow completed successfully!");
        System.out.println("You can now use these credentials in GhidrAssist.");
        
        // Output credentials JSON for GhidrAssist
        JsonObject credentials = new JsonObject();
        credentials.addProperty("access_token", tokens.get("access_token").getAsString());
        credentials.addProperty("refresh_token", tokens.has("refresh_token") ? tokens.get("refresh_token").getAsString() : "");
        credentials.addProperty("expires_at", System.currentTimeMillis() + (tokens.get("expires_in").getAsInt() * 1000L));
        if (accountId != null) {
            credentials.addProperty("account_id", accountId);
        }
        
        System.out.println("\nCredentials JSON (for GhidrAssist):");
        System.out.println(gson.toJson(credentials));
    }
    
    /**
     * Generate PKCE code verifier (43 chars, base64url encoded).
     */
    private static String generateCodeVerifier() {
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[32];
        random.nextBytes(bytes);
        return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes);
    }
    
    /**
     * Generate PKCE code challenge from verifier using SHA-256.
     */
    private static String generateCodeChallenge(String verifier) throws Exception {
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] hash = digest.digest(verifier.getBytes(StandardCharsets.US_ASCII));
        return Base64.getUrlEncoder().withoutPadding().encodeToString(hash);
    }
    
    /**
     * Generate random state parameter for CSRF protection.
     */
    private static String generateState() {
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[32];
        random.nextBytes(bytes);
        return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes);
    }
    
    /**
     * Build OAuth authorization URL with all required parameters.
     * Must match the Python implementation exactly.
     */
    private static String buildAuthorizeUrl(String challenge, String state) throws Exception {
        // Use StringBuilder with URLEncoder - matches Python's urlencode behavior
        StringBuilder params = new StringBuilder();
        params.append("response_type=code");
        params.append("&client_id=").append(URLEncoder.encode(CLIENT_ID, "UTF-8"));
        params.append("&redirect_uri=").append(URLEncoder.encode(REDIRECT_URI, "UTF-8"));
        params.append("&scope=").append(URLEncoder.encode(OAUTH_SCOPES, "UTF-8"));
        params.append("&code_challenge=").append(URLEncoder.encode(challenge, "UTF-8"));
        params.append("&code_challenge_method=S256");
        params.append("&state=").append(URLEncoder.encode(state, "UTF-8"));
        // Codex-specific parameters (from codex-cli-rs)
        params.append("&id_token_add_organizations=true");
        params.append("&codex_cli_simplified_flow=true");
        params.append("&originator=codex_cli_rs");
        
        return AUTH_URL + "?" + params.toString();
    }
    
    /**
     * Extract authorization code from user input.
     * Handles full URL, code#state format, or just the code.
     */
    private static String extractCode(String input) {
        // Try to parse as URL
        if (input.startsWith("http")) {
            try {
                URL url = URI.create(input).toURL();
                String query = url.getQuery();
                if (query != null) {
                    for (String param : query.split("&")) {
                        String[] pair = param.split("=", 2);
                        if (pair.length == 2 && "code".equals(pair[0])) {
                            System.out.println("Extracted code from URL");
                            return URLDecoder.decode(pair[1], "UTF-8");
                        }
                    }
                }
            } catch (Exception e) {
                System.out.println("Failed to parse URL, using input as-is: " + e.getMessage());
            }
        }
        
        // Try code#state format
        if (input.contains("#")) {
            return input.split("#")[0];
        }
        
        // Return as-is
        return input;
    }
    
    /**
     * Exchange authorization code for tokens.
     * Uses form-encoded body (not JSON) as required by OpenAI.
     */
    private static JsonObject exchangeCodeForTokens(String code, String verifier) throws Exception {
        URL url = URI.create(TOKEN_URL).toURL();
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setRequestMethod("POST");
        conn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
        conn.setDoOutput(true);
        
        // Form-encoded body
        String body = "grant_type=authorization_code" +
                      "&code=" + URLEncoder.encode(code, "UTF-8") +
                      "&redirect_uri=" + URLEncoder.encode(REDIRECT_URI, "UTF-8") +
                      "&client_id=" + URLEncoder.encode(CLIENT_ID, "UTF-8") +
                      "&code_verifier=" + URLEncoder.encode(verifier, "UTF-8");
        
        try (OutputStream os = conn.getOutputStream()) {
            os.write(body.getBytes(StandardCharsets.UTF_8));
        }
        
        int responseCode = conn.getResponseCode();
        InputStream is = responseCode >= 400 ? conn.getErrorStream() : conn.getInputStream();
        
        String response;
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {
            StringBuilder sb = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                sb.append(line);
            }
            response = sb.toString();
        }
        
        if (responseCode >= 400) {
            System.out.println("Token exchange failed: " + responseCode);
            System.out.println("Response: " + response);
        }
        
        return gson.fromJson(response, JsonObject.class);
    }
    
    /**
     * Extract ChatGPT account ID from tokens.
     */
    private static String extractAccountId(JsonObject tokens) {
        // Try id_token first
        if (tokens.has("id_token")) {
            String accountId = extractAccountIdFromJwt(tokens.get("id_token").getAsString());
            if (accountId != null) return accountId;
        }
        
        // Fall back to access_token
        if (tokens.has("access_token")) {
            return extractAccountIdFromJwt(tokens.get("access_token").getAsString());
        }
        
        return null;
    }
    
    /**
     * Extract account ID from JWT claims.
     */
    private static String extractAccountIdFromJwt(String jwt) {
        try {
            String[] parts = jwt.split("\\.");
            if (parts.length != 3) return null;
            
            String payload = parts[1];
            // Add padding if needed
            int padding = 4 - payload.length() % 4;
            if (padding != 4) {
                payload += "=".repeat(padding);
            }
            
            byte[] decoded = Base64.getUrlDecoder().decode(payload);
            JsonObject claims = gson.fromJson(new String(decoded, StandardCharsets.UTF_8), JsonObject.class);
            
            // Direct claim
            if (claims.has("chatgpt_account_id")) {
                return claims.get("chatgpt_account_id").getAsString();
            }
            
            // Nested in auth namespace
            if (claims.has("https://api.openai.com/auth")) {
                JsonObject authNs = claims.getAsJsonObject("https://api.openai.com/auth");
                if (authNs.has("chatgpt_account_id")) {
                    return authNs.get("chatgpt_account_id").getAsString();
                }
            }
            
            // From organizations array
            if (claims.has("organizations") && claims.get("organizations").isJsonArray()) {
                var orgs = claims.getAsJsonArray("organizations");
                if (!orgs.isEmpty() && orgs.get(0).isJsonObject()) {
                    JsonObject firstOrg = orgs.get(0).getAsJsonObject();
                    if (firstOrg.has("id")) {
                        return firstOrg.get("id").getAsString();
                    }
                }
            }
        } catch (Exception e) {
            System.out.println("Failed to extract account ID: " + e.getMessage());
        }
        
        return null;
    }
    
    /**
     * Open URL in default browser.
     */
    private static void openBrowser(String url) {
        try {
            String os = System.getProperty("os.name").toLowerCase();
            Runtime rt = Runtime.getRuntime();
            
            if (os.contains("mac")) {
                rt.exec(new String[]{"open", url});
            } else if (os.contains("win")) {
                rt.exec(new String[]{"rundll32", "url.dll,FileProtocolHandler", url});
            } else {
                rt.exec(new String[]{"xdg-open", url});
            }
        } catch (Exception e) {
            System.out.println("Could not open browser: " + e.getMessage());
            System.out.println("Please open the URL manually.");
        }
    }
}

```

`src/main/java/ghidrassist/apiprovider/oauth/OpenAIOAuthTokenManager.java`:

```java
package ghidrassist.apiprovider.oauth;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import ghidra.util.Msg;
import okhttp3.*;

import java.awt.Desktop;
import java.io.IOException;
import java.net.URI;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Base64;
import java.util.concurrent.TimeUnit;

/**
 * Manages OAuth 2.0 authentication with OpenAI's Codex API (ChatGPT Pro/Plus).
 * 
 * This class handles the complete OAuth flow including:
 * - PKCE (Proof Key for Code Exchange) generation
 * - Browser-based authorization
 * - Token exchange (form-encoded, not JSON)
 * - Token refresh
 * - Account ID extraction from JWT
 * - Token storage (as JSON in the provider's key field)
 * 
 * Based on the official Codex CLI (codex-cli-rs) authentication implementation.
 */
public class OpenAIOAuthTokenManager {
    
    // OAuth Configuration - Official OpenAI/Codex CLI Client ID
    private static final String CLIENT_ID = "app_EMoamEEZ73f0CkXaXp7hrann";
    private static final String AUTH_ENDPOINT = "https://auth.openai.com/oauth/authorize";
    private static final String TOKEN_ENDPOINT = "https://auth.openai.com/oauth/token";
    // Default redirect URI - can be overridden when using callback server
    private static final String DEFAULT_REDIRECT_URI = "http://localhost:1455/auth/callback";
    private static final String SCOPES = "openid profile email offline_access";
    
    // Token expiry buffer (5 minutes before actual expiry)
    private static final long EXPIRY_BUFFER_MS = 5 * 60 * 1000;
    
    private final OkHttpClient httpClient;
    private final Gson gson;
    
    // Token storage
    private String accessToken;
    private String refreshToken;
    private long expiresAt; // Unix timestamp in milliseconds
    private String accountId; // ChatGPT account ID for org subscriptions
    
    // PKCE state for current auth flow
    private String pendingCodeVerifier;
    private String pendingState;
    private String pendingRedirectUri;
    private OAuthCallbackServer callbackServer;
    
    /**
     * Creates a new OpenAIOAuthTokenManager.
     */
    public OpenAIOAuthTokenManager() {
        this.httpClient = new OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build();
        this.gson = new Gson();
    }
    
    /**
     * Creates a new OpenAIOAuthTokenManager with existing credentials.
     * 
     * @param credentialsJson JSON string containing access_token, refresh_token, expires_at, account_id
     */
    public OpenAIOAuthTokenManager(String credentialsJson) {
        this();
        if (credentialsJson != null && !credentialsJson.isEmpty()) {
            loadFromJson(credentialsJson);
        }
    }
    
    /**
     * Checks if valid OAuth credentials exist.
     * 
     * @return true if there is a valid access token
     */
    public boolean isAuthenticated() {
        return accessToken != null && !accessToken.isEmpty();
    }
    
    /**
     * Checks if the current token is expired or about to expire.
     * 
     * @return true if the token needs to be refreshed
     */
    public boolean isTokenExpired() {
        return System.currentTimeMillis() >= (expiresAt - EXPIRY_BUFFER_MS);
    }
    
    /**
     * Gets the ChatGPT account ID (for organization subscriptions).
     * 
     * @return The account ID, or null if not available
     */
    public String getAccountId() {
        return accountId;
    }
    
    /**
     * Starts the OAuth authorization flow by opening the browser.
     * Returns the code verifier needed for token exchange.
     * Uses the default redirect URI (manual code entry).
     * 
     * @return The code verifier to use when calling completeAuthorization
     */
    public String startAuthorizationFlow() {
        return startAuthorizationFlow(DEFAULT_REDIRECT_URI);
    }
    
    /**
     * Starts the OAuth authorization flow by opening the browser with a custom redirect URI.
     * 
     * @param redirectUri The redirect URI to use (for callback server)
     * @return The code verifier to use when calling completeAuthorization
     */
    public String startAuthorizationFlow(String redirectUri) {
        // Generate PKCE parameters
        pendingCodeVerifier = generateCodeVerifier();
        String codeChallenge = generateCodeChallenge(pendingCodeVerifier);
        pendingState = generateState();
        pendingRedirectUri = redirectUri;
        
        // Build authorization URL
        String authUrl = buildAuthorizationUrl(codeChallenge, pendingState, redirectUri);
        
        // Debug: Log the auth URL (redact sensitive parts)
        Msg.info(this, "Opening browser for OpenAI Codex OAuth authentication...");
        Msg.debug(this, "Auth URL (code_challenge redacted): " + 
            authUrl.replaceAll("code_challenge=[^&]+", "code_challenge=REDACTED"));
        
        openBrowser(authUrl);
        
        return pendingCodeVerifier;
    }
    
    /**
     * Starts the OAuth authorization flow with automatic callback capture.
     * Opens a local HTTP server to capture the OAuth callback automatically.
     * 
     * @return The OAuthCallbackServer that will receive the callback
     * @throws IOException If the callback server cannot be started
     */
    public OAuthCallbackServer startAuthorizationFlowWithCallback() throws IOException {
        // Generate PKCE parameters
        pendingCodeVerifier = generateCodeVerifier();
        String codeChallenge = generateCodeChallenge(pendingCodeVerifier);
        pendingState = generateState();
        
        // Create and start callback server
        callbackServer = OAuthCallbackServer.forOpenAI(pendingState);
        callbackServer.start();
        
        // Use the callback server's redirect URI
        pendingRedirectUri = callbackServer.getRedirectUri();
        
        // Build authorization URL with callback server's redirect URI
        String authUrl = buildAuthorizationUrl(codeChallenge, pendingState, pendingRedirectUri);
        
        Msg.info(this, "Opening browser for OpenAI Codex OAuth authentication with automatic callback...");
        Msg.info(this, "Callback server listening on: " + pendingRedirectUri);
        
        openBrowser(authUrl);
        
        return callbackServer;
    }
    
    /**
     * Completes authentication using the callback server.
     * Waits for the authorization code from the callback server.
     * 
     * @param server The callback server from startAuthorizationFlowWithCallback
     * @param timeoutMinutes Timeout in minutes
     * @throws Exception If authentication fails or times out
     */
    public void completeAuthorizationWithCallback(OAuthCallbackServer server, int timeoutMinutes) throws Exception {
        try {
            String code = server.waitForCode(timeoutMinutes);
            completeAuthorization(code, pendingCodeVerifier);
        } finally {
            server.stop();
            callbackServer = null;
        }
    }
    
    /**
     * Cancels the current authentication flow and stops the callback server.
     */
    public void cancelAuthentication() {
        if (callbackServer != null) {
            callbackServer.stop();
            callbackServer = null;
        }
        pendingCodeVerifier = null;
        pendingState = null;
        pendingRedirectUri = null;
    }
    
    /**
     * Gets the current callback server (if any).
     * 
     * @return The callback server, or null if not using automatic callback
     */
    public OAuthCallbackServer getCallbackServer() {
        return callbackServer;
    }
    
    /**
     * Completes the OAuth authorization by exchanging the code for tokens.
     * 
     * @param authorizationCode The authorization code from the browser URL
     * @param codeVerifier The code verifier from startAuthorizationFlow
     * @throws IOException If the token exchange fails
     */
    public void completeAuthorization(String authorizationCode, String codeVerifier) throws IOException {
        TokenResponse tokens = exchangeCodeForTokens(authorizationCode, codeVerifier);
        
        this.accessToken = tokens.accessToken;
        this.refreshToken = tokens.refreshToken;
        this.expiresAt = System.currentTimeMillis() + (tokens.expiresIn * 1000L);
        
        // Extract account ID from tokens
        this.accountId = extractAccountId(tokens.idToken, tokens.accessToken);
        
        Msg.info(this, "OpenAI Codex OAuth authentication successful!" + 
            (accountId != null ? " Account ID: " + accountId : ""));
        
        // Clean up
        pendingCodeVerifier = null;
        pendingState = null;
    }
    
    /**
     * Performs authentication with a manually entered authorization code or URL.
     * Accepts either:
     * - The full redirect URL (http://localhost:1455/auth/callback?code=XXX&state=YYY)
     * - Just the code value
     * 
     * @param input The code or URL copied from the browser
     * @throws Exception If authentication fails
     */
    public void authenticateWithCode(String input) throws Exception {
        if (pendingCodeVerifier == null) {
            throw new IllegalStateException("Call startAuthorizationFlow() first to open the browser");
        }
        
        String code = extractCodeFromInput(input.trim());
        Msg.info(this, "Extracted authorization code: " + code.substring(0, Math.min(20, code.length())) + "...");
        
        completeAuthorization(code, pendingCodeVerifier);
    }
    
    /**
     * Extracts the authorization code from user input.
     * Handles full URL, code#state format, or just the code.
     */
    private String extractCodeFromInput(String input) {
        // Try to parse as URL
        if (input.startsWith("http")) {
            try {
                java.net.URL url = java.net.URI.create(input).toURL();
                String query = url.getQuery();
                if (query != null) {
                    for (String param : query.split("&")) {
                        String[] pair = param.split("=", 2);
                        if (pair.length == 2 && "code".equals(pair[0])) {
                            Msg.info(this, "Extracted code from URL");
                            return java.net.URLDecoder.decode(pair[1], StandardCharsets.UTF_8);
                        }
                    }
                }
            } catch (Exception e) {
                Msg.debug(this, "Failed to parse as URL, using input as-is: " + e.getMessage());
            }
        }
        
        // Try code#state format
        if (input.contains("#")) {
            return input.split("#")[0];
        }
        
        // Return as-is
        return input;
    }
    
    /**
     * Gets a valid access token, refreshing if necessary.
     * 
     * @return A valid access token
     * @throws IOException If token refresh fails
     */
    public String getValidAccessToken() throws IOException {
        if (!isAuthenticated()) {
            throw new IllegalStateException("Not authenticated. Call authenticate() first.");
        }
        
        if (isTokenExpired()) {
            refreshAccessToken();
        }
        
        return accessToken;
    }
    
    /**
     * Refreshes the access token using the refresh token.
     * 
     * @throws IOException If refresh fails
     */
    public void refreshAccessToken() throws IOException {
        if (refreshToken == null || refreshToken.isEmpty()) {
            throw new IllegalStateException("No refresh token available. Re-authentication required.");
        }
        
        Msg.info(this, "Refreshing OpenAI Codex access token...");
        
        // OpenAI uses form-encoded body for token refresh
        FormBody formBody = new FormBody.Builder()
            .add("grant_type", "refresh_token")
            .add("refresh_token", refreshToken)
            .add("client_id", CLIENT_ID)
            .build();
        
        Request request = new Request.Builder()
            .url(TOKEN_ENDPOINT)
            .post(formBody)
            .header("Content-Type", "application/x-www-form-urlencoded")
            .build();
        
        try (Response response = httpClient.newCall(request).execute()) {
            String body = response.body() != null ? response.body().string() : "";
            
            if (!response.isSuccessful()) {
                Msg.error(this, "Token refresh failed: " + response.code() + " - " + body);
                throw new IOException("Token refresh failed: " + response.code() + " - " + body);
            }
            
            JsonObject json = gson.fromJson(body, JsonObject.class);
            
            this.accessToken = json.get("access_token").getAsString();
            if (json.has("refresh_token") && !json.get("refresh_token").isJsonNull()) {
                this.refreshToken = json.get("refresh_token").getAsString();
            }
            this.expiresAt = System.currentTimeMillis() + (json.get("expires_in").getAsInt() * 1000L);
            
            // Update account ID if present in new tokens
            if (json.has("id_token") && !json.get("id_token").isJsonNull()) {
                String newAccountId = extractAccountIdFromToken(json.get("id_token").getAsString());
                if (newAccountId != null) {
                    this.accountId = newAccountId;
                }
            }
            
            Msg.info(this, "OpenAI Codex access token refreshed successfully");
        }
    }
    
    /**
     * Clears all stored credentials.
     */
    public void logout() {
        accessToken = null;
        refreshToken = null;
        expiresAt = 0;
        accountId = null;
        Msg.info(this, "OpenAI OAuth credentials cleared");
    }
    
    /**
     * Exports credentials to JSON for storage in the provider's key field.
     * 
     * @return JSON string containing credentials
     */
    public String toJson() {
        JsonObject json = new JsonObject();
        json.addProperty("access_token", accessToken != null ? accessToken : "");
        json.addProperty("refresh_token", refreshToken != null ? refreshToken : "");
        json.addProperty("expires_at", expiresAt);
        json.addProperty("account_id", accountId != null ? accountId : "");
        return gson.toJson(json);
    }
    
    /**
     * Loads credentials from JSON.
     * 
     * @param json JSON string containing credentials
     */
    public void loadFromJson(String json) {
        try {
            JsonObject obj = gson.fromJson(json, JsonObject.class);
            
            if (obj.has("access_token") && !obj.get("access_token").isJsonNull()) {
                this.accessToken = obj.get("access_token").getAsString();
            }
            if (obj.has("refresh_token") && !obj.get("refresh_token").isJsonNull()) {
                this.refreshToken = obj.get("refresh_token").getAsString();
            }
            if (obj.has("expires_at")) {
                this.expiresAt = obj.get("expires_at").getAsLong();
            }
            if (obj.has("account_id") && !obj.get("account_id").isJsonNull()) {
                this.accountId = obj.get("account_id").getAsString();
                if (this.accountId.isEmpty()) {
                    this.accountId = null;
                }
            }
            
            Msg.debug(this, "Loaded OpenAI OAuth credentials from JSON");
            
        } catch (Exception e) {
            Msg.warn(this, "Failed to parse OpenAI OAuth credentials: " + e.getMessage());
        }
    }
    
    // =========================================================================
    // PKCE Methods
    // =========================================================================
    
    /**
     * Generates a cryptographically random code verifier for PKCE.
     */
    private String generateCodeVerifier() {
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[32];
        random.nextBytes(bytes);
        return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes);
    }
    
    /**
     * Generates the code challenge from the verifier using SHA-256.
     */
    private String generateCodeChallenge(String codeVerifier) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(codeVerifier.getBytes(StandardCharsets.US_ASCII));
            return Base64.getUrlEncoder().withoutPadding().encodeToString(hash);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("SHA-256 not available", e);
        }
    }
    
    /**
     * Generates a random state parameter for CSRF protection.
     */
    private String generateState() {
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[32];
        random.nextBytes(bytes);
        return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes);
    }
    
    // =========================================================================
    // Authorization URL
    // =========================================================================
    
    /**
     * Builds the OAuth authorization URL with all required parameters.
     * Includes Codex-specific parameters required by the API.
     * 
     * Based on codex-cli-rs OAuth implementation.
     */
    private String buildAuthorizationUrl(String codeChallenge, String state) {
        return buildAuthorizationUrl(codeChallenge, state, DEFAULT_REDIRECT_URI);
    }
    
    /**
     * Builds the OAuth authorization URL with all required parameters and custom redirect URI.
     * Includes Codex-specific parameters required by the API.
     * 
     * Based on codex-cli-rs OAuth implementation.
     */
    private String buildAuthorizationUrl(String codeChallenge, String state, String redirectUri) {
        try {
            // Build URL with all required parameters matching codex-cli-rs exactly
            StringBuilder url = new StringBuilder(AUTH_ENDPOINT);
            url.append("?response_type=code");
            url.append("&client_id=").append(urlEncode(CLIENT_ID));
            url.append("&redirect_uri=").append(urlEncode(redirectUri));
            url.append("&scope=").append(urlEncode(SCOPES));
            url.append("&code_challenge=").append(urlEncode(codeChallenge));
            url.append("&code_challenge_method=S256");
            url.append("&state=").append(urlEncode(state));
            // Codex-specific parameters (from codex-cli-rs)
            url.append("&id_token_add_organizations=true");
            url.append("&codex_cli_simplified_flow=true");
            url.append("&originator=codex_cli_rs");
            
            String finalUrl = url.toString();
            Msg.info(this, "Generated OAuth URL: " + finalUrl);
            return finalUrl;
        } catch (Exception e) {
            throw new RuntimeException("Failed to build authorization URL", e);
        }
    }
    
    /**
     * URL-encodes a string using application/x-www-form-urlencoded format.
     */
    private String urlEncode(String value) {
        return URLEncoder.encode(value, StandardCharsets.UTF_8);
    }
    
    /**
     * Opens the system default browser to the specified URL.
     */
    private void openBrowser(String url) {
        try {
            if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {
                Desktop.getDesktop().browse(new URI(url));
            } else {
                // Fallback for headless environments
                String os = System.getProperty("os.name").toLowerCase();
                Runtime rt = Runtime.getRuntime();
                if (os.contains("mac")) {
                    rt.exec(new String[]{"open", url});
                } else if (os.contains("win")) {
                    rt.exec(new String[]{"rundll32", "url.dll,FileProtocolHandler", url});
                } else {
                    rt.exec(new String[]{"xdg-open", url});
                }
            }
        } catch (Exception e) {
            Msg.error(this, "Could not open browser: " + e.getMessage());
            Msg.info(this, "Please open this URL manually: " + url);
        }
    }
    
    // =========================================================================
    // Token Exchange
    // =========================================================================
    
    /**
     * Exchanges the authorization code for access and refresh tokens.
     * OpenAI uses form-encoded body (not JSON like Anthropic).
     */
    private TokenResponse exchangeCodeForTokens(String code, String codeVerifier) throws IOException {
        // Use the redirect URI from the auth flow, or default
        String redirectUri = pendingRedirectUri != null ? pendingRedirectUri : DEFAULT_REDIRECT_URI;
        
        // OpenAI uses form-encoded body
        FormBody formBody = new FormBody.Builder()
            .add("grant_type", "authorization_code")
            .add("code", code)
            .add("redirect_uri", redirectUri)
            .add("client_id", CLIENT_ID)
            .add("code_verifier", codeVerifier)
            .build();
        
        Request request = new Request.Builder()
            .url(TOKEN_ENDPOINT)
            .post(formBody)
            .header("Content-Type", "application/x-www-form-urlencoded")
            .build();
        
        try (Response response = httpClient.newCall(request).execute()) {
            String body = response.body() != null ? response.body().string() : "";
            
            if (!response.isSuccessful()) {
                throw new IOException("Token exchange failed: " + response.code() + " - " + body);
            }
            
            JsonObject json = gson.fromJson(body, JsonObject.class);
            
            return new TokenResponse(
                json.get("access_token").getAsString(),
                json.has("refresh_token") && !json.get("refresh_token").isJsonNull() 
                    ? json.get("refresh_token").getAsString() : null,
                json.get("expires_in").getAsInt(),
                json.has("id_token") && !json.get("id_token").isJsonNull()
                    ? json.get("id_token").getAsString() : null
            );
        }
    }
    
    /**
     * Token response from the OAuth server.
     */
    private record TokenResponse(String accessToken, String refreshToken, int expiresIn, String idToken) {}
    
    // =========================================================================
    // Account ID Extraction
    // =========================================================================
    
    /**
     * Extracts the ChatGPT account ID from OAuth tokens.
     * The account ID is needed for organization subscriptions and is
     * sent in the chatgpt-account-id header.
     */
    private String extractAccountId(String idToken, String accessToken) {
        // Try id_token first
        if (idToken != null) {
            String accountId = extractAccountIdFromToken(idToken);
            if (accountId != null) {
                return accountId;
            }
        }
        
        // Fall back to access_token
        if (accessToken != null) {
            return extractAccountIdFromToken(accessToken);
        }
        
        return null;
    }
    
    /**
     * Extracts account ID from a JWT token.
     */
    private String extractAccountIdFromToken(String token) {
        try {
            JsonObject claims = parseJwtClaims(token);
            if (claims == null) {
                return null;
            }
            
            // Direct claim
            if (claims.has("chatgpt_account_id") && !claims.get("chatgpt_account_id").isJsonNull()) {
                return claims.get("chatgpt_account_id").getAsString();
            }
            
            // Nested in auth namespace
            if (claims.has("https://api.openai.com/auth")) {
                JsonElement authElement = claims.get("https://api.openai.com/auth");
                if (authElement.isJsonObject()) {
                    JsonObject authNamespace = authElement.getAsJsonObject();
                    if (authNamespace.has("chatgpt_account_id") && !authNamespace.get("chatgpt_account_id").isJsonNull()) {
                        return authNamespace.get("chatgpt_account_id").getAsString();
                    }
                }
            }
            
            // From organizations array
            if (claims.has("organizations")) {
                JsonElement orgsElement = claims.get("organizations");
                if (orgsElement.isJsonArray()) {
                    JsonArray orgs = orgsElement.getAsJsonArray();
                    if (!orgs.isEmpty()) {
                        JsonElement firstOrg = orgs.get(0);
                        if (firstOrg.isJsonObject()) {
                            JsonObject org = firstOrg.getAsJsonObject();
                            if (org.has("id") && !org.get("id").isJsonNull()) {
                                return org.get("id").getAsString();
                            }
                        }
                    }
                }
            }
            
        } catch (Exception e) {
            Msg.debug(this, "Failed to extract account ID from token: " + e.getMessage());
        }
        
        return null;
    }
    
    /**
     * Parses claims from a JWT token (without verification).
     */
    private JsonObject parseJwtClaims(String token) {
        String[] parts = token.split("\\.");
        if (parts.length != 3) {
            return null;
        }
        
        try {
            // Add padding if needed
            String payload = parts[1];
            int padding = 4 - payload.length() % 4;
            if (padding != 4) {
                payload += "=".repeat(padding);
            }
            
            byte[] decoded = Base64.getUrlDecoder().decode(payload);
            return gson.fromJson(new String(decoded, StandardCharsets.UTF_8), JsonObject.class);
        } catch (Exception e) {
            return null;
        }
    }
    
    // =========================================================================
    // Getters for testing/debugging
    // =========================================================================
    
    public String getAccessToken() {
        return accessToken;
    }
    
    public String getRefreshToken() {
        return refreshToken;
    }
    
    public long getExpiresAt() {
        return expiresAt;
    }
}

```

`src/main/java/ghidrassist/chat/ChangeType.java`:

```java
package ghidrassist.chat;

/**
 * Enumeration of possible change types when editing chat content.
 */
public enum ChangeType {
    /** Content was modified */
    MODIFIED("modified"),

    /** Message was deleted */
    DELETED("deleted"),

    /** New message was added */
    ADDED("added"),

    /** Message order changed (reserved for future use) */
    MOVED("moved");

    private final String value;

    ChangeType(String value) {
        this.value = value;
    }

    public String getValue() {
        return value;
    }

    @Override
    public String toString() {
        return value;
    }
}

```

`src/main/java/ghidrassist/chat/ChatChange.java`:

```java
package ghidrassist.chat;

/**
 * Represents a detected change in chat content during editing.
 * Used to track modifications, deletions, and additions when
 * parsing edited content.
 */
public class ChatChange {
    private ChangeType changeType;
    private String chunkId;
    private String oldContent;
    private String newContent;
    private Integer dbId;
    private Integer newOrder;
    private String role;
    private String timestamp;

    /**
     * Private constructor - use factory methods instead.
     */
    private ChatChange(ChangeType changeType, String chunkId, String oldContent,
                       String newContent, Integer dbId, Integer newOrder,
                       String role, String timestamp) {
        this.changeType = changeType;
        this.chunkId = chunkId;
        this.oldContent = oldContent;
        this.newContent = newContent;
        this.dbId = dbId;
        this.newOrder = newOrder;
        this.role = role;
        this.timestamp = timestamp;
    }

    // Factory methods for common change types

    /**
     * Create a change representing a modified message.
     */
    public static ChatChange modified(String chunkId, Integer dbId,
                                      String oldContent, String newContent,
                                      String role, String timestamp) {
        return new ChatChange(ChangeType.MODIFIED, chunkId, oldContent,
                              newContent, dbId, null, role, timestamp);
    }

    /**
     * Create a change representing a deleted message.
     */
    public static ChatChange deleted(String chunkId, Integer dbId, String oldContent) {
        return new ChatChange(ChangeType.DELETED, chunkId, oldContent,
                              null, dbId, null, null, null);
    }

    /**
     * Create a change representing a new message.
     */
    public static ChatChange added(String newContent, String role,
                                   String timestamp, Integer order) {
        return new ChatChange(ChangeType.ADDED, null, null,
                              newContent, null, order, role, timestamp);
    }

    /**
     * Create a change representing a title modification.
     */
    public static ChatChange titleModified(String oldTitle, String newTitle) {
        return new ChatChange(ChangeType.MODIFIED, "title", oldTitle,
                              newTitle, null, null, "title", null);
    }

    // Getters

    public ChangeType getChangeType() {
        return changeType;
    }

    public String getChunkId() {
        return chunkId;
    }

    public String getOldContent() {
        return oldContent;
    }

    public String getNewContent() {
        return newContent;
    }

    public Integer getDbId() {
        return dbId;
    }

    public Integer getNewOrder() {
        return newOrder;
    }

    public String getRole() {
        return role;
    }

    public String getTimestamp() {
        return timestamp;
    }

    /**
     * Check if this is a title change.
     */
    public boolean isTitleChange() {
        return "title".equals(role) && "title".equals(chunkId);
    }

    @Override
    public String toString() {
        return String.format("ChatChange{type=%s, chunkId='%s', role='%s'}",
            changeType, chunkId, role);
    }
}

```

`src/main/java/ghidrassist/chat/ChatEditManager.java`:

```java
package ghidrassist.chat;

import ghidrassist.chat.util.RoleNormalizer;

import java.util.*;
import java.util.regex.*;

/**
 * Manages chunk-based edit tracking for chat conversations.
 * Generates editable markdown with embedded chunk markers and
 * detects changes when content is saved.
 */
public class ChatEditManager {

    private Map<String, PersistedChatMessage> messageMap;
    private Map<String, String> originalChunks;
    private String chatTitle;
    private int conversationPairCount;

    private static final Pattern CHUNK_PATTERN =
            Pattern.compile("<!-- CHUNK:([^>]+) -->\\s*\\n(.*?)(?=<!-- CHUNK:|$)", Pattern.DOTALL);
    private static final Pattern TITLE_PATTERN =
            Pattern.compile("^#\\s+(.+?)\\s*$", Pattern.MULTILINE);
    private static final Pattern HEADER_PATTERN =
            Pattern.compile("^\\s*##?#?\\s*(\\w+)", Pattern.MULTILINE);

    public ChatEditManager() {
        this.messageMap = new HashMap<>();
        this.originalChunks = new HashMap<>();
        this.chatTitle = "";
        this.conversationPairCount = 0;
    }

    /**
     * Convert chat messages to editable markdown with embedded chunk tracking.
     *
     * @param chatName The chat session name
     * @param messages List of persisted chat messages
     * @return Markdown string with chunk markers
     */
    public String generateEditableContent(String chatName, List<PersistedChatMessage> messages) {
        messageMap.clear();
        originalChunks.clear();
        chatTitle = chatName != null ? chatName : "Untitled";
        conversationPairCount = 0;

        StringBuilder content = new StringBuilder();
        content.append("# ").append(chatTitle).append("\n\n");

        for (int i = 0; i < messages.size(); i++) {
            PersistedChatMessage msg = messages.get(i);

            // Add separator between conversation pairs
            if ("user".equalsIgnoreCase(msg.getRole()) && conversationPairCount > 0) {
                content.append("---\n\n");
            }

            String chunkMarkdown = msg.toMarkdownChunk();

            // Store for change detection
            messageMap.put(msg.getChunkId(), msg);
            originalChunks.put(msg.getChunkId(), chunkMarkdown);

            content.append(chunkMarkdown);

            if ("user".equalsIgnoreCase(msg.getRole())) {
                conversationPairCount++;
            }
        }

        return content.toString();
    }

    /**
     * Detect changes between original and edited content.
     *
     * @param editedContent The edited markdown content
     * @return List of detected changes
     */
    public List<ChatChange> parseEditedContent(String editedContent) {
        List<ChatChange> changes = new ArrayList<>();

        // 1. Check for title changes
        String editedTitle = extractTitle(editedContent);
        if (editedTitle != null && !editedTitle.equals(chatTitle)) {
            changes.add(ChatChange.titleModified(chatTitle, editedTitle));
        }

        // 2. Extract chunks from edited content
        Map<String, String> editedChunks = extractChunks(editedContent);

        Set<String> originalIds = originalChunks.keySet();
        Set<String> editedIds = editedChunks.keySet();

        // 3. Detect deletions
        for (String chunkId : originalIds) {
            if (!editedIds.contains(chunkId)) {
                PersistedChatMessage msg = messageMap.get(chunkId);
                if (msg != null) {
                    changes.add(ChatChange.deleted(chunkId, msg.getDbId(), msg.getContent()));
                }
            }
        }

        // 4. Detect modifications
        for (String chunkId : editedIds) {
            if (originalIds.contains(chunkId)) {
                PersistedChatMessage msg = messageMap.get(chunkId);
                if (msg != null) {
                    String original = msg.getContent();
                    String edited = editedChunks.get(chunkId);
                    if (!Objects.equals(original, edited)) {
                        changes.add(ChatChange.modified(
                                chunkId, msg.getDbId(), original, edited,
                                msg.getRole(),
                                msg.getTimestamp() != null ? msg.getTimestamp().toString() : null
                        ));
                    }
                }
            }
        }

        // 5. Detect additions (new content without markers)
        List<ParsedBlock> newBlocks = extractNewContent(editedContent);
        for (ParsedBlock block : newBlocks) {
            changes.add(ChatChange.added(
                    block.content, block.role,
                    block.timestamp != null ? block.timestamp : "edited",
                    messageMap.size()
            ));
        }

        return changes;
    }

    /**
     * Extract ALL messages from edited markdown for full rebuild.
     * This is the primary method used for saving - handles both
     * chunk-marked and unmarked content.
     *
     * @param editedContent The edited markdown content
     * @return List of extracted messages in order
     */
    public List<ExtractedMessage> extractAllMessages(String editedContent) {
        List<ExtractedMessage> messages = new ArrayList<>();

        // Split by chunk markers
        String[] parts = editedContent.split("(<!-- CHUNK:[^>]+ -->)");
        Matcher markerMatcher = Pattern.compile("<!-- CHUNK:([^>]+) -->").matcher(editedContent);

        List<String> chunkIds = new ArrayList<>();
        while (markerMatcher.find()) {
            chunkIds.add(markerMatcher.group(1));
        }

        // Process parts (parts[0] is before first marker, skip it)
        for (int i = 0; i < chunkIds.size() && i + 1 < parts.length; i++) {
            String chunkContent = parts[i + 1];

            // Parse header for role
            Matcher headerMatch = HEADER_PATTERN.matcher(chunkContent);
            if (headerMatch.find()) {
                String roleText = headerMatch.group(1).toLowerCase();
                String role = RoleNormalizer.normalize(roleText);

                // Extract content (skip header line)
                String[] lines = chunkContent.split("\n");
                StringBuilder contentBuilder = new StringBuilder();
                boolean foundHeader = false;
                for (String line : lines) {
                    if (!foundHeader && line.matches("\\s*##?#?\\s*\\w+.*")) {
                        foundHeader = true;
                        continue;
                    }
                    if (foundHeader) {
                        contentBuilder.append(line).append("\n");
                    }
                }

                String content = contentBuilder.toString().trim();
                // Remove trailing separators
                while (content.endsWith("---")) {
                    content = content.substring(0, content.length() - 3).trim();
                }

                if (!content.isEmpty()) {
                    ExtractedMessage msg = new ExtractedMessage();
                    msg.role = role;
                    msg.content = content;
                    msg.timestamp = "edited";
                    msg.dbId = null;
                    messages.add(msg);
                }
            }
        }

        // Fallback: header-based extraction if no chunks found
        if (messages.isEmpty()) {
            messages = extractByHeaders(editedContent);
        }

        return messages;
    }

    // Helper methods

    private String extractTitle(String content) {
        Matcher matcher = TITLE_PATTERN.matcher(content);
        if (matcher.find()) {
            return matcher.group(1).trim();
        }
        return null;
    }

    private Map<String, String> extractChunks(String content) {
        Map<String, String> chunks = new HashMap<>();
        Matcher matcher = CHUNK_PATTERN.matcher(content);

        while (matcher.find()) {
            String chunkId = matcher.group(1);
            String chunkContent = matcher.group(2).trim();

            // Skip header line, remove trailing separators
            String[] lines = chunkContent.split("\n");
            if (lines.length > 1) {
                StringBuilder contentLines = new StringBuilder();
                boolean skippedHeader = false;
                for (String line : lines) {
                    if (!skippedHeader && line.matches("\\s*##?#?\\s*\\w+.*")) {
                        skippedHeader = true;
                        continue;
                    }
                    contentLines.append(line).append("\n");
                }
                String extracted = contentLines.toString().trim();
                while (extracted.endsWith("---") || extracted.endsWith("\n")) {
                    if (extracted.endsWith("---")) {
                        extracted = extracted.substring(0, extracted.length() - 3).trim();
                    } else if (extracted.endsWith("\n")) {
                        extracted = extracted.substring(0, extracted.length() - 1);
                    }
                }
                chunks.put(chunkId, extracted);
            }
        }

        return chunks;
    }

    private List<ParsedBlock> extractNewContent(String content) {
        // Look for content that has headers but no chunk markers
        // This is a simplified implementation - full version would be more robust
        List<ParsedBlock> newBlocks = new ArrayList<>();

        // Find headers that are NOT preceded by chunk markers
        Pattern unmarkedHeaderPattern = Pattern.compile(
                "(?<!<!-- CHUNK:[^>]+ -->\\s*\\n)##\\s+(User|Assistant|Error|Edited)\\s*\\([^)]*\\)\\s*\\n(.*?)(?=##\\s+|$)",
                Pattern.DOTALL | Pattern.CASE_INSENSITIVE
        );

        Matcher matcher = unmarkedHeaderPattern.matcher(content);
        while (matcher.find()) {
            String role = RoleNormalizer.normalize(matcher.group(1));
            String blockContent = matcher.group(2).trim();

            // Clean up separators
            while (blockContent.endsWith("---")) {
                blockContent = blockContent.substring(0, blockContent.length() - 3).trim();
            }

            if (!blockContent.isEmpty()) {
                ParsedBlock block = new ParsedBlock();
                block.role = role;
                block.content = blockContent;
                block.timestamp = "edited";
                newBlocks.add(block);
            }
        }

        return newBlocks;
    }

    private List<ExtractedMessage> extractByHeaders(String content) {
        List<ExtractedMessage> messages = new ArrayList<>();

        // Pattern for ## User or ## Assistant headers with timestamp
        Pattern headerPattern = Pattern.compile(
                "##\\s+(User|Assistant|Error|Edited)\\s*(?:\\([^)]*\\))?\\s*\\n(.*?)(?=##\\s+(User|Assistant|Error|Edited)|$)",
                Pattern.DOTALL | Pattern.CASE_INSENSITIVE
        );

        Matcher matcher = headerPattern.matcher(content);
        while (matcher.find()) {
            String role = RoleNormalizer.normalize(matcher.group(1));
            String msgContent = matcher.group(2).trim();

            // Clean up separators
            while (msgContent.endsWith("---")) {
                msgContent = msgContent.substring(0, msgContent.length() - 3).trim();
            }

            if (!msgContent.isEmpty()) {
                ExtractedMessage msg = new ExtractedMessage();
                msg.role = role;
                msg.content = msgContent;
                msg.timestamp = "edited";
                messages.add(msg);
            }
        }

        return messages;
    }

    /**
     * Helper class for extracted messages during save.
     */
    public static class ExtractedMessage {
        public String role;
        public String content;
        public String timestamp;
        public Integer dbId;

        @Override
        public String toString() {
            return String.format("ExtractedMessage{role='%s', content='%s...'}",
                    role, content != null && content.length() > 20 ? content.substring(0, 20) : content);
        }
    }

    /**
     * Helper class for parsed blocks.
     */
    private static class ParsedBlock {
        String role;
        String content;
        String timestamp;
    }

    // Getters

    public String getChatTitle() {
        return chatTitle;
    }

    public Map<String, PersistedChatMessage> getMessageMap() {
        return Collections.unmodifiableMap(messageMap);
    }

    /**
     * Reset the manager state.
     */
    public void reset() {
        messageMap.clear();
        originalChunks.clear();
        chatTitle = "";
        conversationPairCount = 0;
    }
}

```

`src/main/java/ghidrassist/chat/PersistedChatMessage.java`:

```java
package ghidrassist.chat;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;

import ghidrassist.apiprovider.ChatMessage;
import ghidrassist.chat.message.ThreadSafeMessageStore;
import ghidrassist.chat.util.RoleNormalizer;

/**
 * Represents a single message in a chat conversation with persistence support.
 * Used for per-message storage and chunk-based editing.
 */
public class PersistedChatMessage {
    private Integer dbId;           // Database row ID (null for new messages)
    private String role;            // user/assistant/tool_call/tool_response/error/edited
    private String content;         // Message content
    private Timestamp timestamp;    // Message timestamp
    private int order;              // Message order in conversation
    private String chunkId;         // Generated for tracking edits
    private String providerType;    // anthropic/openai/ollama/edited
    private String nativeMessageData; // JSON with essential tool info (name, args, result)
    private String messageType;     // standard/tool_call/tool_response/edited

    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

    /**
     * Create a new PersistedChatMessage.
     *
     * @param dbId Database row ID (null for new messages)
     * @param role Message role (user/assistant/tool_call/tool_response/error/edited)
     * @param content Message content
     * @param timestamp Message timestamp
     * @param order Message order in conversation (0-indexed)
     */
    public PersistedChatMessage(Integer dbId, String role, String content,
                                Timestamp timestamp, int order) {
        this.dbId = dbId;
        this.role = role;
        this.content = content;
        this.timestamp = timestamp;
        this.order = order;
        this.chunkId = generateChunkId();
        this.providerType = "unknown";
        this.nativeMessageData = "{}";
        this.messageType = "standard";
    }

    /**
     * Generate a stable chunk ID for tracking edits.
     * Format: msg_{dbId}_{role}_{order}_{contentHash}
     */
    private String generateChunkId() {
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            String contentToHash = content != null ? content : "";
            byte[] digest = md.digest(contentToHash.getBytes("UTF-8"));
            String hash = bytesToHex(digest).substring(0, 8);
            return String.format("msg_%s_%s_%d_%s",
                dbId != null ? dbId.toString() : "new",
                role != null ? role : "unknown",
                order,
                hash);
        } catch (NoSuchAlgorithmException | java.io.UnsupportedEncodingException e) {
            // Fallback without hash
            return String.format("msg_%s_%s_%d",
                dbId != null ? dbId.toString() : "new",
                role != null ? role : "unknown",
                order);
        }
    }

    /**
     * Regenerate the chunk ID. Call after content changes.
     */
    public void regenerateChunkId() {
        this.chunkId = generateChunkId();
    }

    /**
     * Get the markdown header for this role.
     *
     * @return Formatted header like "## User (2025-01-15 10:30:00)"
     */
    public String getRoleHeader() {
        String timestampStr = timestamp != null ? DATE_FORMAT.format(timestamp) : "";

        if (role == null) {
            return "## Unknown (" + timestampStr + ")";
        }

        switch (role.toLowerCase()) {
            case "user":
                return "## User (" + timestampStr + ")";
            case "assistant":
                return "## Assistant (" + timestampStr + ")";
            case "tool_call":
                return "### Tool Call (" + timestampStr + ")";
            case "tool_response":
                return "### Tool Response (" + timestampStr + ")";
            case "error":
                return "## Error (" + timestampStr + ")";
            case "edited":
                return "## Edited (" + timestampStr + ")";
            default:
                return "## " + capitalize(role) + " (" + timestampStr + ")";
        }
    }

    /**
     * Convert this message to a markdown chunk with embedded tracking marker.
     *
     * @return Markdown string with chunk marker
     */
    public String toMarkdownChunk() {
        String marker = "<!-- CHUNK:" + chunkId + " -->";
        String header = getRoleHeader();
        String contentText = content != null ? content : "";
        return marker + "\n" + header + "\n" + contentText + "\n\n";
    }

    // Getters

    public Integer getDbId() {
        return dbId;
    }

    public String getRole() {
        return role;
    }

    public String getContent() {
        return content;
    }

    public Timestamp getTimestamp() {
        return timestamp;
    }

    public int getOrder() {
        return order;
    }

    public String getChunkId() {
        return chunkId;
    }

    public String getProviderType() {
        return providerType;
    }

    public String getNativeMessageData() {
        return nativeMessageData;
    }

    public String getMessageType() {
        return messageType;
    }

    // Setters

    public void setDbId(Integer dbId) {
        this.dbId = dbId;
        regenerateChunkId();
    }

    public void setRole(String role) {
        this.role = role;
        regenerateChunkId();
    }

    public void setContent(String content) {
        this.content = content;
        regenerateChunkId();
    }

    public void setTimestamp(Timestamp timestamp) {
        this.timestamp = timestamp;
    }

    public void setOrder(int order) {
        this.order = order;
        regenerateChunkId();
    }

    public void setProviderType(String providerType) {
        this.providerType = providerType;
    }

    public void setNativeMessageData(String nativeMessageData) {
        this.nativeMessageData = nativeMessageData;
    }

    public void setMessageType(String messageType) {
        this.messageType = messageType;
    }

    // ==================== API Conversion Methods ====================

    /**
     * Convert this persisted message to a ChatMessage for API calls.
     * Restores thinking content, tool calls, and other metadata from nativeMessageData.
     *
     * @return A ChatMessage with all metadata restored
     */
    public ChatMessage toChatMessage() {
        String apiRole = normalizeRoleForApi(this.role);
        return ThreadSafeMessageStore.deserializeNativeData(
                this.nativeMessageData,
                apiRole,
                this.content
        );
    }

    /**
     * Normalize display/internal role to API role format.
     * Maps tool_call, tool_response, error etc. to standard API roles.
     *
     * @param displayRole The role as stored/displayed
     * @return The role in API format (user, assistant, tool, system)
     */
    private String normalizeRoleForApi(String displayRole) {
        if (displayRole == null) {
            return ChatMessage.ChatMessageRole.USER;
        }

        String normalized = RoleNormalizer.normalize(displayRole);
        switch (normalized) {
            case RoleNormalizer.ROLE_USER:
                return ChatMessage.ChatMessageRole.USER;
            case RoleNormalizer.ROLE_ASSISTANT:
                return ChatMessage.ChatMessageRole.ASSISTANT;
            case RoleNormalizer.ROLE_TOOL_CALL:
            case RoleNormalizer.ROLE_TOOL_RESPONSE:
                return ChatMessage.ChatMessageRole.TOOL;
            case RoleNormalizer.ROLE_ERROR:
                // Errors are typically assistant messages
                return ChatMessage.ChatMessageRole.ASSISTANT;
            case RoleNormalizer.ROLE_EDITED:
                // Edited messages retain original role, default to user
                return ChatMessage.ChatMessageRole.USER;
            default:
                return ChatMessage.ChatMessageRole.USER;
        }
    }

    // Utility methods

    private static String capitalize(String s) {
        if (s == null || s.isEmpty()) {
            return s;
        }
        return s.substring(0, 1).toUpperCase() + s.substring(1);
    }

    private static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02x", b));
        }
        return sb.toString();
    }

    @Override
    public String toString() {
        return String.format("PersistedChatMessage{dbId=%d, role='%s', order=%d, chunkId='%s'}",
            dbId, role, order, chunkId);
    }
}

```

`src/main/java/ghidrassist/chat/message/MessageRepository.java`:

```java
package ghidrassist.chat.message;

import ghidrassist.chat.PersistedChatMessage;

import java.util.List;

/**
 * Repository interface for message persistence operations.
 * Implementations handle database operations atomically.
 */
public interface MessageRepository {

    /**
     * Save a single message. Upserts if message with same order exists.
     *
     * @param programHash The program hash
     * @param sessionId The session ID
     * @param message The message to save
     * @return The database ID of the saved message, or -1 on failure
     */
    int saveMessage(String programHash, int sessionId, PersistedChatMessage message);

    /**
     * Save multiple messages in a single transaction.
     * Replaces all existing messages for the session.
     *
     * @param programHash The program hash
     * @param sessionId The session ID
     * @param messages The messages to save
     * @return true if successful
     */
    boolean replaceAllMessages(String programHash, int sessionId, List<PersistedChatMessage> messages);

    /**
     * Load all messages for a session, ordered by message_order.
     *
     * @param programHash The program hash
     * @param sessionId The session ID
     * @return List of messages in order
     */
    List<PersistedChatMessage> loadMessages(String programHash, int sessionId);

    /**
     * Delete all messages for a session.
     *
     * @param programHash The program hash
     * @param sessionId The session ID
     * @return Number of deleted messages
     */
    int deleteAllMessages(String programHash, int sessionId);

    /**
     * Check if session has any persisted messages.
     *
     * @param programHash The program hash
     * @param sessionId The session ID
     * @return true if messages exist
     */
    boolean hasMessages(String programHash, int sessionId);

    /**
     * Get message count for a session.
     *
     * @param programHash The program hash
     * @param sessionId The session ID
     * @return Number of messages
     */
    int getMessageCount(String programHash, int sessionId);

    /**
     * Update a specific message's content (for editing).
     *
     * @param messageId The database ID of the message
     * @param newContent The new content
     * @param newMessageType The new message type (e.g., "edited")
     * @return true if successful
     */
    boolean updateMessageContent(int messageId, String newContent, String newMessageType);

    /**
     * Delete a specific message by ID.
     *
     * @param messageId The database ID of the message
     * @return true if deleted
     */
    boolean deleteMessage(int messageId);
}

```

`src/main/java/ghidrassist/chat/message/MessageStore.java`:

```java
package ghidrassist.chat.message;

import ghidrassist.apiprovider.ChatMessage;
import ghidrassist.chat.PersistedChatMessage;

import java.util.List;

/**
 * Single source of truth for in-memory chat messages.
 * Replaces the dual conversationHistory/messageList pattern.
 *
 * Implementations must be thread-safe for concurrent access.
 */
public interface MessageStore {

    /**
     * Add a user message to the store.
     *
     * @param content The message content
     * @param providerType The provider type (anthropic/openai/ollama)
     * @param apiMessage Optional API message with tool call info
     */
    void addUserMessage(String content, String providerType, ChatMessage apiMessage);

    /**
     * Add an assistant message to the store.
     *
     * @param content The message content
     * @param providerType The provider type
     * @param apiMessage Optional API message with tool call info
     */
    void addAssistantMessage(String content, String providerType, ChatMessage apiMessage);

    /**
     * Add a tool call message to the store.
     *
     * @param toolName The name of the tool
     * @param args The tool arguments (JSON)
     * @param result The tool result
     */
    void addToolCallMessage(String toolName, String args, String result);

    /**
     * Add an error message to the store.
     *
     * @param errorMessage The error message content
     */
    void addErrorMessage(String errorMessage);

    /**
     * Add a generic message to the store.
     *
     * @param message The message to add
     */
    void addMessage(PersistedChatMessage message);

    /**
     * Get all messages as an immutable list.
     * Returns a defensive copy to prevent external modification.
     *
     * @return List of all messages in order
     */
    List<PersistedChatMessage> getMessages();

    /**
     * Replace all messages (for loading from DB or after edit).
     * This clears the current messages and sets new ones.
     *
     * @param messages The new messages to set
     */
    void setMessages(List<PersistedChatMessage> messages);

    /**
     * Get formatted conversation string for LLM context.
     * Format: **User**:\n{content}\n\n**Assistant**:\n{content}\n\n
     *
     * @return Formatted conversation as a string
     */
    String getFormattedConversation();

    /**
     * Clear all messages.
     */
    void clear();

    /**
     * Get message count.
     *
     * @return Number of messages in the store
     */
    int size();

    /**
     * Check if the store is empty.
     *
     * @return true if no messages in store
     */
    boolean isEmpty();

    /**
     * Get the provider type for the current conversation.
     *
     * @return The current provider type
     */
    String getCurrentProviderType();

    /**
     * Set the current provider type.
     *
     * @param providerType The provider type to set
     */
    void setCurrentProviderType(String providerType);

    /**
     * Get messages as ChatMessage objects for API calls.
     * This preserves thinking content, tool calls, and other metadata needed
     * for multi-turn conversations with extended thinking.
     *
     * @return List of ChatMessage objects with all metadata restored
     */
    List<ChatMessage> getMessagesForApi();
}

```

`src/main/java/ghidrassist/chat/message/ThreadSafeMessageStore.java`:

```java
package ghidrassist.chat.message;

import com.google.gson.Gson;
import com.google.gson.JsonObject;

import ghidra.util.Msg;
import ghidrassist.apiprovider.ChatMessage;
import ghidrassist.chat.PersistedChatMessage;
import ghidrassist.chat.util.RoleNormalizer;

import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * Thread-safe implementation of MessageStore.
 * Uses ReadWriteLock for concurrent access - allows concurrent reads during LLM streaming,
 * with exclusive lock only for writes.
 *
 * Replaces the dual conversationHistory/messageList pattern with a single source of truth.
 */
public class ThreadSafeMessageStore implements MessageStore {

    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    private final List<PersistedChatMessage> messages = new ArrayList<>();
    private volatile String cachedConversation = null;
    private volatile String currentProviderType = "unknown";

    @Override
    public void addUserMessage(String content, String providerType, ChatMessage apiMessage) {
        PersistedChatMessage msg = createMessage(
                RoleNormalizer.ROLE_USER,
                content,
                providerType,
                apiMessage,
                "standard"
        );
        addMessage(msg);
    }

    @Override
    public void addAssistantMessage(String content, String providerType, ChatMessage apiMessage) {
        String messageType = (apiMessage != null && apiMessage.getToolCalls() != null)
                ? "tool_call" : "standard";

        PersistedChatMessage msg = createMessage(
                RoleNormalizer.ROLE_ASSISTANT,
                content,
                providerType,
                apiMessage,
                messageType
        );
        addMessage(msg);
    }

    @Override
    public void addToolCallMessage(String toolName, String args, String result) {
        String content = String.format("Tool: %s\nArguments: %s\nResult: %s", toolName, args, result);
        String nativeData = String.format("{\"tool\":\"%s\",\"args\":%s,\"result\":\"%s\"}",
                escapeJson(toolName), args, escapeJson(result));

        lock.writeLock().lock();
        try {
            PersistedChatMessage msg = new PersistedChatMessage(
                    null,
                    RoleNormalizer.ROLE_TOOL_CALL,
                    content,
                    new Timestamp(System.currentTimeMillis()),
                    messages.size()
            );
            msg.setProviderType(currentProviderType);
            msg.setNativeMessageData(nativeData);
            msg.setMessageType("tool_call");

            messages.add(msg);
            cachedConversation = null; // Invalidate cache
        } finally {
            lock.writeLock().unlock();
        }
    }

    @Override
    public void addErrorMessage(String errorMessage) {
        lock.writeLock().lock();
        try {
            PersistedChatMessage msg = new PersistedChatMessage(
                    null,
                    RoleNormalizer.ROLE_ERROR,
                    errorMessage,
                    new Timestamp(System.currentTimeMillis()),
                    messages.size()
            );
            msg.setProviderType(currentProviderType);
            msg.setNativeMessageData("{}");
            msg.setMessageType("standard");

            messages.add(msg);
            cachedConversation = null; // Invalidate cache
        } finally {
            lock.writeLock().unlock();
        }
    }

    @Override
    public void addMessage(PersistedChatMessage message) {
        lock.writeLock().lock();
        try {
            messages.add(message);
            cachedConversation = null; // Invalidate cache
        } finally {
            lock.writeLock().unlock();
        }
    }

    @Override
    public List<PersistedChatMessage> getMessages() {
        lock.readLock().lock();
        try {
            // Return defensive copy
            return new ArrayList<>(messages);
        } finally {
            lock.readLock().unlock();
        }
    }

    @Override
    public void setMessages(List<PersistedChatMessage> newMessages) {
        lock.writeLock().lock();
        try {
            messages.clear();
            if (newMessages != null) {
                messages.addAll(newMessages);
            }
            cachedConversation = null; // Invalidate cache
        } finally {
            lock.writeLock().unlock();
        }
    }

    @Override
    public String getFormattedConversation() {
        lock.readLock().lock();
        try {
            if (cachedConversation == null) {
                cachedConversation = formatMessages();
            }
            return cachedConversation;
        } finally {
            lock.readLock().unlock();
        }
    }

    @Override
    public void clear() {
        lock.writeLock().lock();
        try {
            messages.clear();
            cachedConversation = null;
        } finally {
            lock.writeLock().unlock();
        }
    }

    @Override
    public int size() {
        lock.readLock().lock();
        try {
            return messages.size();
        } finally {
            lock.readLock().unlock();
        }
    }

    @Override
    public boolean isEmpty() {
        lock.readLock().lock();
        try {
            return messages.isEmpty();
        } finally {
            lock.readLock().unlock();
        }
    }

    @Override
    public String getCurrentProviderType() {
        return currentProviderType;
    }

    @Override
    public void setCurrentProviderType(String providerType) {
        this.currentProviderType = providerType != null ? providerType : "unknown";
    }

    @Override
    public List<ChatMessage> getMessagesForApi() {
        lock.readLock().lock();
        try {
            List<ChatMessage> apiMessages = new ArrayList<>();
            for (PersistedChatMessage msg : messages) {
                apiMessages.add(msg.toChatMessage());
            }
            return apiMessages;
        } finally {
            lock.readLock().unlock();
        }
    }

    // ==================== Private Helper Methods ====================

    /**
     * Create a PersistedChatMessage with proper initialization.
     */
    private PersistedChatMessage createMessage(String role, String content, String providerType,
                                                ChatMessage apiMessage, String messageType) {
        lock.writeLock().lock();
        try {
            PersistedChatMessage msg = new PersistedChatMessage(
                    null,
                    role,
                    content,
                    new Timestamp(System.currentTimeMillis()),
                    messages.size()
            );
            msg.setProviderType(providerType != null ? providerType : currentProviderType);
            msg.setNativeMessageData(serializeToolInfo(apiMessage));
            msg.setMessageType(messageType);
            return msg;
        } finally {
            lock.writeLock().unlock();
        }
    }

    /**
     * Format all messages into a conversation string.
     * Format: **User**:\n{content}\n\n**Assistant**:\n{content}\n\n
     */
    private String formatMessages() {
        StringBuilder sb = new StringBuilder();
        for (PersistedChatMessage msg : messages) {
            String displayRole = RoleNormalizer.toDisplayFormat(msg.getRole());
            sb.append("**").append(displayRole).append("**:\n");
            sb.append(msg.getContent()).append("\n\n");
        }
        return sb.toString();
    }

    /**
     * Serialize ChatMessage metadata to JSON including tool calls and thinking data.
     * This ensures extended thinking content/signature are preserved for multi-turn conversations.
     */
    private static String serializeToolInfo(ChatMessage apiMessage) {
        if (apiMessage == null) {
            return "{}";
        }

        JsonObject json = new JsonObject();

        // Serialize tool calls
        if (apiMessage.getToolCalls() != null) {
            json.add("tool_calls", apiMessage.getToolCalls());
        }

        // Serialize tool call ID
        if (apiMessage.getToolCallId() != null) {
            json.addProperty("tool_call_id", apiMessage.getToolCallId());
        }

        // Serialize thinking content (for Anthropic extended thinking)
        if (apiMessage.getThinkingContent() != null) {
            json.addProperty("thinking_content", apiMessage.getThinkingContent());
        }

        // Serialize thinking signature (for Anthropic extended thinking)
        if (apiMessage.getThinkingSignature() != null) {
            json.addProperty("thinking_signature", apiMessage.getThinkingSignature());
        }

        return json.toString();
    }

    /**
     * Deserialize native message data JSON back to a ChatMessage.
     * Used when loading messages from database to restore thinking data and tool calls.
     *
     * @param nativeData The JSON string containing serialized metadata
     * @param role The message role
     * @param content The message content text
     * @return A ChatMessage with all metadata restored
     */
    public static ChatMessage deserializeNativeData(String nativeData, String role, String content) {
        ChatMessage message = new ChatMessage(role, content);

        if (nativeData == null || nativeData.isEmpty() || nativeData.equals("{}")) {
            return message;
        }

        try {
            Gson gson = new Gson();
            JsonObject json = gson.fromJson(nativeData, JsonObject.class);

            // Restore tool calls
            if (json.has("tool_calls")) {
                message.setToolCalls(json.get("tool_calls").getAsJsonArray());
            }

            // Restore tool call ID
            if (json.has("tool_call_id")) {
                message.setToolCallId(json.get("tool_call_id").getAsString());
            }

            // Restore thinking content (for Anthropic extended thinking)
            if (json.has("thinking_content")) {
                message.setThinkingContent(json.get("thinking_content").getAsString());
            }

            // Restore thinking signature (for Anthropic extended thinking)
            if (json.has("thinking_signature")) {
                message.setThinkingSignature(json.get("thinking_signature").getAsString());
            }
        } catch (Exception e) {
            Msg.warn(ThreadSafeMessageStore.class,
                    "Failed to deserialize native message data: " + e.getMessage());
        }

        return message;
    }

    /**
     * Escape string for JSON.
     */
    private static String escapeJson(String input) {
        if (input == null) {
            return "";
        }
        return input.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }
}

```

`src/main/java/ghidrassist/chat/persistence/ChatHistoryDAO.java`:

```java
package ghidrassist.chat.persistence;

import ghidra.util.Msg;
import ghidrassist.chat.PersistedChatMessage;
import ghidrassist.chat.message.MessageRepository;
import ghidrassist.chat.session.ChatSession;
import ghidrassist.chat.session.ChatSessionRepository;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Unified DAO for all chat history database operations.
 * Implements both MessageRepository and ChatSessionRepository interfaces.
 * Uses TransactionManager for atomic multi-statement operations.
 */
public class ChatHistoryDAO implements MessageRepository, ChatSessionRepository {

    private final TransactionManager transactionManager;

    public ChatHistoryDAO(TransactionManager transactionManager) {
        this.transactionManager = transactionManager;
    }

    // ==================== ChatSessionRepository Implementation ====================

    @Override
    public int createSession(String programHash, String description) {
        String sql = "INSERT INTO GHChatHistory (program_hash, description, conversation) VALUES (?, ?, '')";

        try (PreparedStatement pstmt = transactionManager.getConnection()
                .prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            pstmt.setString(1, programHash);
            pstmt.setString(2, description);
            pstmt.executeUpdate();

            ResultSet rs = pstmt.getGeneratedKeys();
            if (rs.next()) {
                return rs.getInt(1);
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to create chat session: " + e.getMessage());
        }
        return -1;
    }

    @Override
    public List<ChatSession> getSessionsForProgram(String programHash) {
        List<ChatSession> sessions = new ArrayList<>();
        String sql = "SELECT id, description, last_update FROM GHChatHistory " +
                     "WHERE program_hash = ? ORDER BY last_update DESC";

        try (PreparedStatement pstmt = transactionManager.getConnection().prepareStatement(sql)) {
            pstmt.setString(1, programHash);
            ResultSet rs = pstmt.executeQuery();

            while (rs.next()) {
                sessions.add(new ChatSession.Builder()
                        .id(rs.getInt("id"))
                        .programHash(programHash)
                        .description(rs.getString("description"))
                        .lastUpdate(rs.getTimestamp("last_update"))
                        .build());
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to get chat sessions: " + e.getMessage());
        }
        return sessions;
    }

    @Override
    public Optional<ChatSession> getSession(int sessionId) {
        String sql = "SELECT id, program_hash, description, last_update FROM GHChatHistory WHERE id = ?";

        try (PreparedStatement pstmt = transactionManager.getConnection().prepareStatement(sql)) {
            pstmt.setInt(1, sessionId);
            ResultSet rs = pstmt.executeQuery();

            if (rs.next()) {
                return Optional.of(new ChatSession.Builder()
                        .id(rs.getInt("id"))
                        .programHash(rs.getString("program_hash"))
                        .description(rs.getString("description"))
                        .lastUpdate(rs.getTimestamp("last_update"))
                        .isReActSession(isReActSession(sessionId))
                        .build());
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to get session: " + e.getMessage());
        }
        return Optional.empty();
    }

    @Override
    public boolean updateDescription(int sessionId, String description) {
        String sql = "UPDATE GHChatHistory SET description = ? WHERE id = ?";

        try (PreparedStatement pstmt = transactionManager.getConnection().prepareStatement(sql)) {
            pstmt.setString(1, description);
            pstmt.setInt(2, sessionId);
            return pstmt.executeUpdate() > 0;
        } catch (SQLException e) {
            Msg.error(this, "Failed to update description: " + e.getMessage());
            return false;
        }
    }

    @Override
    public boolean touchSession(int sessionId) {
        String sql = "UPDATE GHChatHistory SET last_update = CURRENT_TIMESTAMP WHERE id = ?";

        try (PreparedStatement pstmt = transactionManager.getConnection().prepareStatement(sql)) {
            pstmt.setInt(1, sessionId);
            return pstmt.executeUpdate() > 0;
        } catch (SQLException e) {
            Msg.error(this, "Failed to touch session: " + e.getMessage());
            return false;
        }
    }

    @Override
    public boolean deleteSession(int sessionId) {
        // Messages will cascade delete via FK
        String sql = "DELETE FROM GHChatHistory WHERE id = ?";

        try (PreparedStatement pstmt = transactionManager.getConnection().prepareStatement(sql)) {
            pstmt.setInt(1, sessionId);
            return pstmt.executeUpdate() > 0;
        } catch (SQLException e) {
            Msg.error(this, "Failed to delete session: " + e.getMessage());
            return false;
        }
    }

    @Override
    public boolean sessionExists(int sessionId) {
        String sql = "SELECT 1 FROM GHChatHistory WHERE id = ?";

        try (PreparedStatement pstmt = transactionManager.getConnection().prepareStatement(sql)) {
            pstmt.setInt(1, sessionId);
            return pstmt.executeQuery().next();
        } catch (SQLException e) {
            return false;
        }
    }

    @Override
    public boolean isReActSession(int sessionId) {
        String sql = "SELECT 1 FROM GHReActMessages WHERE session_id = ? LIMIT 1";

        try (PreparedStatement pstmt = transactionManager.getConnection().prepareStatement(sql)) {
            pstmt.setInt(1, sessionId);
            return pstmt.executeQuery().next();
        } catch (SQLException e) {
            return false;
        }
    }

    @Override
    public int getNextSessionNumber(String programHash) {
        String sql = "SELECT COUNT(*) FROM GHChatHistory WHERE program_hash = ?";

        try (PreparedStatement pstmt = transactionManager.getConnection().prepareStatement(sql)) {
            pstmt.setString(1, programHash);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return rs.getInt(1) + 1;
            }
        } catch (SQLException e) {
            Msg.warn(this, "Failed to get session count: " + e.getMessage());
        }
        return 1;
    }

    @Override
    public String getLegacyConversation(int sessionId) {
        String sql = "SELECT conversation FROM GHChatHistory WHERE id = ?";

        try (PreparedStatement pstmt = transactionManager.getConnection().prepareStatement(sql)) {
            pstmt.setInt(1, sessionId);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return rs.getString("conversation");
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to get legacy conversation: " + e.getMessage());
        }
        return null;
    }

    // ==================== MessageRepository Implementation ====================

    @Override
    public int saveMessage(String programHash, int sessionId, PersistedChatMessage message) {
        // Check if message already exists at this order
        Integer existingId = findExistingMessageId(programHash, sessionId, message.getOrder());

        if (existingId != null) {
            // Update existing message
            return updateExistingMessage(existingId, message) ? existingId : -1;
        } else {
            // Insert new message
            return insertMessage(programHash, sessionId, message);
        }
    }

    @Override
    public boolean replaceAllMessages(String programHash, int sessionId, List<PersistedChatMessage> messages) {
        return transactionManager.executeInTransaction(conn -> {
            try {
                // Delete all existing messages
                deleteAllMessages(programHash, sessionId);

                // Insert all new messages
                for (int i = 0; i < messages.size(); i++) {
                    PersistedChatMessage msg = messages.get(i);
                    // Ensure order is correct
                    if (msg.getOrder() != i) {
                        msg.setOrder(i);
                    }
                    insertMessage(programHash, sessionId, msg);
                }
                return true;
            } catch (Exception e) {
                Msg.error(this, "Failed to replace messages: " + e.getMessage());
                throw new RuntimeException(e);
            }
        });
    }

    @Override
    public List<PersistedChatMessage> loadMessages(String programHash, int sessionId) {
        List<PersistedChatMessage> messages = new ArrayList<>();
        String sql = "SELECT id, role, content_text, message_order, created_at, " +
                     "provider_type, native_message_data, message_type " +
                     "FROM GHChatMessages WHERE program_hash = ? AND chat_id = ? " +
                     "ORDER BY message_order ASC";

        try (PreparedStatement pstmt = transactionManager.getConnection().prepareStatement(sql)) {
            pstmt.setString(1, programHash);
            pstmt.setInt(2, sessionId);

            ResultSet rs = pstmt.executeQuery();
            while (rs.next()) {
                PersistedChatMessage msg = new PersistedChatMessage(
                        rs.getInt("id"),
                        rs.getString("role"),
                        rs.getString("content_text"),
                        rs.getTimestamp("created_at"),
                        rs.getInt("message_order")
                );
                msg.setProviderType(rs.getString("provider_type"));
                msg.setNativeMessageData(rs.getString("native_message_data"));
                msg.setMessageType(rs.getString("message_type"));
                messages.add(msg);
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to load messages: " + e.getMessage());
        }
        return messages;
    }

    @Override
    public int deleteAllMessages(String programHash, int sessionId) {
        String sql = "DELETE FROM GHChatMessages WHERE program_hash = ? AND chat_id = ?";

        try (PreparedStatement pstmt = transactionManager.getConnection().prepareStatement(sql)) {
            pstmt.setString(1, programHash);
            pstmt.setInt(2, sessionId);
            return pstmt.executeUpdate();
        } catch (SQLException e) {
            Msg.error(this, "Failed to delete messages: " + e.getMessage());
            return 0;
        }
    }

    @Override
    public boolean hasMessages(String programHash, int sessionId) {
        return getMessageCount(programHash, sessionId) > 0;
    }

    @Override
    public int getMessageCount(String programHash, int sessionId) {
        String sql = "SELECT COUNT(*) FROM GHChatMessages WHERE program_hash = ? AND chat_id = ?";

        try (PreparedStatement pstmt = transactionManager.getConnection().prepareStatement(sql)) {
            pstmt.setString(1, programHash);
            pstmt.setInt(2, sessionId);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return rs.getInt(1);
            }
        } catch (SQLException e) {
            Msg.warn(this, "Failed to get message count: " + e.getMessage());
        }
        return 0;
    }

    @Override
    public boolean updateMessageContent(int messageId, String newContent, String newMessageType) {
        String sql = "UPDATE GHChatMessages SET content_text = ?, message_type = ?, " +
                     "updated_at = CURRENT_TIMESTAMP WHERE id = ?";

        try (PreparedStatement pstmt = transactionManager.getConnection().prepareStatement(sql)) {
            pstmt.setString(1, newContent);
            pstmt.setString(2, newMessageType != null ? newMessageType : "edited");
            pstmt.setInt(3, messageId);
            return pstmt.executeUpdate() > 0;
        } catch (SQLException e) {
            Msg.error(this, "Failed to update message content: " + e.getMessage());
            return false;
        }
    }

    @Override
    public boolean deleteMessage(int messageId) {
        String sql = "DELETE FROM GHChatMessages WHERE id = ?";

        try (PreparedStatement pstmt = transactionManager.getConnection().prepareStatement(sql)) {
            pstmt.setInt(1, messageId);
            return pstmt.executeUpdate() > 0;
        } catch (SQLException e) {
            Msg.error(this, "Failed to delete message: " + e.getMessage());
            return false;
        }
    }

    // ==================== Private Helper Methods ====================

    private Integer findExistingMessageId(String programHash, int sessionId, int order) {
        String sql = "SELECT id FROM GHChatMessages WHERE program_hash = ? AND chat_id = ? AND message_order = ?";

        try (PreparedStatement pstmt = transactionManager.getConnection().prepareStatement(sql)) {
            pstmt.setString(1, programHash);
            pstmt.setInt(2, sessionId);
            pstmt.setInt(3, order);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return rs.getInt("id");
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to find message: " + e.getMessage());
        }
        return null;
    }

    private boolean updateExistingMessage(int messageId, PersistedChatMessage message) {
        String sql = "UPDATE GHChatMessages SET provider_type = ?, native_message_data = ?, " +
                     "role = ?, content_text = ?, message_type = ?, updated_at = CURRENT_TIMESTAMP " +
                     "WHERE id = ?";

        try (PreparedStatement pstmt = transactionManager.getConnection().prepareStatement(sql)) {
            pstmt.setString(1, message.getProviderType());
            pstmt.setString(2, message.getNativeMessageData() != null ? message.getNativeMessageData() : "{}");
            pstmt.setString(3, message.getRole());
            pstmt.setString(4, message.getContent());
            pstmt.setString(5, message.getMessageType() != null ? message.getMessageType() : "standard");
            pstmt.setInt(6, messageId);
            return pstmt.executeUpdate() > 0;
        } catch (SQLException e) {
            Msg.error(this, "Failed to update message: " + e.getMessage());
            return false;
        }
    }

    private int insertMessage(String programHash, int sessionId, PersistedChatMessage message) {
        // Include session_id and sequence_number for backward compatibility with databases
        // that may have NOT NULL constraints on these legacy columns
        String sql = "INSERT INTO GHChatMessages " +
                     "(program_hash, chat_id, session_id, message_order, sequence_number, " +
                     "provider_type, native_message_data, role, content_text, message_type, " +
                     "created_at, updated_at) " +
                     "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)";

        try (PreparedStatement pstmt = transactionManager.getConnection()
                .prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            pstmt.setString(1, programHash);
            pstmt.setInt(2, sessionId);
            pstmt.setInt(3, sessionId);  // session_id = chat_id for compatibility
            pstmt.setInt(4, message.getOrder());
            pstmt.setInt(5, message.getOrder());  // sequence_number = message_order for compatibility
            pstmt.setString(6, message.getProviderType() != null ? message.getProviderType() : "unknown");
            pstmt.setString(7, message.getNativeMessageData() != null ? message.getNativeMessageData() : "{}");
            pstmt.setString(8, message.getRole());
            pstmt.setString(9, message.getContent());
            pstmt.setString(10, message.getMessageType() != null ? message.getMessageType() : "standard");
            pstmt.executeUpdate();

            ResultSet rs = pstmt.getGeneratedKeys();
            if (rs.next()) {
                return rs.getInt(1);
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to insert message: " + e.getMessage());
        }
        return -1;
    }
}

```

`src/main/java/ghidrassist/chat/persistence/SqliteTransactionManager.java`:

```java
package ghidrassist.chat.persistence;

import ghidra.util.Msg;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.function.Consumer;
import java.util.function.Function;

/**
 * SQLite implementation of TransactionManager.
 * Provides transaction boundaries for atomic database operations.
 */
public class SqliteTransactionManager implements TransactionManager {

    private final Connection connection;

    /**
     * Create a new SqliteTransactionManager with the given connection.
     *
     * @param connection The SQLite database connection
     */
    public SqliteTransactionManager(Connection connection) {
        this.connection = connection;
    }

    @Override
    public <T> T executeInTransaction(Function<Connection, T> operation) {
        boolean wasAutoCommit = true;
        try {
            wasAutoCommit = connection.getAutoCommit();
            connection.setAutoCommit(false);

            T result = operation.apply(connection);

            connection.commit();
            return result;

        } catch (Exception e) {
            try {
                connection.rollback();
                Msg.warn(this, "Transaction rolled back due to error: " + e.getMessage());
            } catch (SQLException rollbackEx) {
                Msg.error(this, "Failed to rollback transaction: " + rollbackEx.getMessage());
            }
            throw new RuntimeException("Transaction failed: " + e.getMessage(), e);

        } finally {
            try {
                connection.setAutoCommit(wasAutoCommit);
            } catch (SQLException e) {
                Msg.error(this, "Failed to restore autocommit: " + e.getMessage());
            }
        }
    }

    @Override
    public void executeInTransaction(Consumer<Connection> operation) {
        executeInTransaction(conn -> {
            operation.accept(conn);
            return null;
        });
    }

    @Override
    public Connection getConnection() {
        return connection;
    }
}

```

`src/main/java/ghidrassist/chat/persistence/TransactionManager.java`:

```java
package ghidrassist.chat.persistence;

import java.sql.Connection;
import java.util.function.Consumer;
import java.util.function.Function;

/**
 * Manages database transactions for atomic operations.
 * Provides transaction boundaries for multi-statement database operations.
 */
public interface TransactionManager {

    /**
     * Execute operations within a transaction and return a result.
     * Commits on success, rolls back on exception.
     *
     * @param <T> The return type
     * @param operation The operation to execute with the connection
     * @return The result of the operation
     * @throws RuntimeException if the operation fails (wraps SQLException)
     */
    <T> T executeInTransaction(Function<Connection, T> operation);

    /**
     * Execute void operations within a transaction.
     * Commits on success, rolls back on exception.
     *
     * @param operation The operation to execute with the connection
     * @throws RuntimeException if the operation fails (wraps SQLException)
     */
    void executeInTransaction(Consumer<Connection> operation);

    /**
     * Get the underlying connection for read-only operations.
     * Note: For write operations, use executeInTransaction() instead.
     *
     * @return The database connection
     */
    Connection getConnection();
}

```

`src/main/java/ghidrassist/chat/session/ChatSession.java`:

```java
package ghidrassist.chat.session;

import java.sql.Timestamp;
import java.util.Objects;

/**
 * Represents a chat session with its metadata.
 * Immutable value object with builder pattern for construction.
 */
public final class ChatSession {

    private final int id;
    private final String programHash;
    private final String description;
    private final Timestamp lastUpdate;
    private final boolean isReActSession;

    private ChatSession(Builder builder) {
        this.id = builder.id;
        this.programHash = builder.programHash;
        this.description = builder.description;
        this.lastUpdate = builder.lastUpdate;
        this.isReActSession = builder.isReActSession;
    }

    /**
     * Create a ChatSession from legacy AnalysisDB.ChatSession for backward compatibility.
     */
    public static ChatSession fromLegacy(int id, String description, Timestamp lastUpdate) {
        return new Builder()
                .id(id)
                .description(description)
                .lastUpdate(lastUpdate)
                .build();
    }

    // ==================== Getters ====================

    public int getId() {
        return id;
    }

    public String getProgramHash() {
        return programHash;
    }

    public String getDescription() {
        return description;
    }

    public Timestamp getLastUpdate() {
        return lastUpdate;
    }

    public boolean isReActSession() {
        return isReActSession;
    }

    // ==================== Builder ====================

    public static class Builder {
        private int id = -1;
        private String programHash;
        private String description = "";
        private Timestamp lastUpdate;
        private boolean isReActSession = false;

        public Builder() {
            this.lastUpdate = new Timestamp(System.currentTimeMillis());
        }

        public Builder id(int id) {
            this.id = id;
            return this;
        }

        public Builder programHash(String programHash) {
            this.programHash = programHash;
            return this;
        }

        public Builder description(String description) {
            this.description = description != null ? description : "";
            return this;
        }

        public Builder lastUpdate(Timestamp lastUpdate) {
            this.lastUpdate = lastUpdate != null ? lastUpdate : new Timestamp(System.currentTimeMillis());
            return this;
        }

        public Builder isReActSession(boolean isReActSession) {
            this.isReActSession = isReActSession;
            return this;
        }

        public ChatSession build() {
            return new ChatSession(this);
        }
    }

    // ==================== Object Methods ====================

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ChatSession that = (ChatSession) o;
        return id == that.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return String.format("ChatSession{id=%d, description='%s', lastUpdate=%s, isReAct=%s}",
                id, description, lastUpdate, isReActSession);
    }
}

```

`src/main/java/ghidrassist/chat/session/ChatSessionManager.java`:

```java
package ghidrassist.chat.session;

import ghidrassist.chat.message.MessageRepository;
import ghidrassist.chat.message.MessageStore;
import ghidrassist.chat.PersistedChatMessage;

import java.util.List;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Thread-safe manager for chat session lifecycle.
 * Uses AtomicInteger for session ID to prevent race conditions.
 */
public class ChatSessionManager {

    /** Sentinel value indicating no active session */
    public static final int NO_SESSION = -1;

    private final AtomicInteger currentSessionId = new AtomicInteger(NO_SESSION);
    private final Object sessionLock = new Object();

    private final ChatSessionRepository sessionRepository;
    private final MessageRepository messageRepository;
    private final MessageStore messageStore;

    /**
     * Create a ChatSessionManager with the required dependencies.
     */
    public ChatSessionManager(ChatSessionRepository sessionRepository,
                              MessageRepository messageRepository,
                              MessageStore messageStore) {
        this.sessionRepository = sessionRepository;
        this.messageRepository = messageRepository;
        this.messageStore = messageStore;
    }

    // ==================== Session ID Accessors ====================

    /**
     * Get the current session ID.
     * Thread-safe read.
     *
     * @return Current session ID, or NO_SESSION (-1) if none
     */
    public int getCurrentSessionId() {
        return currentSessionId.get();
    }

    /**
     * Check if there is an active session.
     *
     * @return true if session is active
     */
    public boolean hasActiveSession() {
        return currentSessionId.get() != NO_SESSION;
    }

    // ==================== Session Lifecycle ====================

    /**
     * Create a new chat session and make it current.
     * Thread-safe via synchronized block.
     *
     * @param programHash The program hash
     * @return The new session ID, or NO_SESSION on failure
     */
    public int createNewSession(String programHash) {
        synchronized (sessionLock) {
            // Generate description based on session count
            int nextNumber = sessionRepository.getNextSessionNumber(programHash);
            String description = "Chat " + nextNumber;

            int sessionId = sessionRepository.createSession(programHash, description);
            if (sessionId != NO_SESSION) {
                currentSessionId.set(sessionId);
                messageStore.clear();
            }
            return sessionId;
        }
    }

    /**
     * Switch to a specific session.
     * Loads messages from database and updates the message store.
     * Thread-safe via synchronized block.
     *
     * @param programHash The program hash
     * @param sessionId The session ID to switch to
     * @return true if switch successful
     */
    public boolean switchToSession(String programHash, int sessionId) {
        synchronized (sessionLock) {
            if (!sessionRepository.sessionExists(sessionId)) {
                return false;
            }

            // Load messages from database
            List<PersistedChatMessage> messages = messageRepository.loadMessages(programHash, sessionId);

            // If no per-message storage, try legacy migration
            if (messages.isEmpty() && !messageRepository.hasMessages(programHash, sessionId)) {
                String legacyConversation = sessionRepository.getLegacyConversation(sessionId);
                if (legacyConversation != null && !legacyConversation.isEmpty()) {
                    // Migration will be handled by LegacyMigrator
                    // For now, just note that legacy data exists
                }
            }

            // Update state
            messageStore.setMessages(messages);
            currentSessionId.set(sessionId);
            return true;
        }
    }

    /**
     * Delete the current session.
     * Clears the message store and resets session ID.
     *
     * @return true if deleted successfully
     */
    public boolean deleteCurrentSession() {
        synchronized (sessionLock) {
            int sessionId = currentSessionId.get();
            if (sessionId == NO_SESSION) {
                return false;
            }

            boolean deleted = sessionRepository.deleteSession(sessionId);
            if (deleted) {
                messageStore.clear();
                currentSessionId.set(NO_SESSION);
            }
            return deleted;
        }
    }

    /**
     * Delete a specific session by ID.
     * If deleting the current session, also clears the message store and resets session ID.
     *
     * @param sessionId The session ID to delete
     * @return true if deleted successfully
     */
    public boolean deleteSession(int sessionId) {
        synchronized (sessionLock) {
            if (sessionId == NO_SESSION) {
                return false;
            }

            boolean deleted = sessionRepository.deleteSession(sessionId);
            if (deleted && sessionId == currentSessionId.get()) {
                // If we deleted the current session, clear state
                messageStore.clear();
                currentSessionId.set(NO_SESSION);
            }
            return deleted;
        }
    }

    /**
     * Clear the current session without deleting from database.
     * Used when starting fresh conversation.
     */
    public void clearCurrentSession() {
        synchronized (sessionLock) {
            messageStore.clear();
            currentSessionId.set(NO_SESSION);
        }
    }

    // ==================== Session Queries ====================

    /**
     * Get all sessions for a program.
     *
     * @param programHash The program hash
     * @return List of sessions (newest first)
     */
    public List<ChatSession> getSessions(String programHash) {
        return sessionRepository.getSessionsForProgram(programHash);
    }

    /**
     * Get current session details.
     *
     * @return Optional containing current session, or empty if none
     */
    public Optional<ChatSession> getCurrentSession() {
        int sessionId = currentSessionId.get();
        if (sessionId == NO_SESSION) {
            return Optional.empty();
        }
        return sessionRepository.getSession(sessionId);
    }

    /**
     * Check if current session is a ReAct session.
     *
     * @return true if current session is ReAct
     */
    public boolean isCurrentSessionReAct() {
        int sessionId = currentSessionId.get();
        if (sessionId == NO_SESSION) {
            return false;
        }
        return sessionRepository.isReActSession(sessionId);
    }

    // ==================== Session Updates ====================

    /**
     * Update current session description.
     *
     * @param description The new description
     * @return true if successful
     */
    public boolean updateCurrentDescription(String description) {
        int sessionId = currentSessionId.get();
        if (sessionId == NO_SESSION) {
            return false;
        }
        return sessionRepository.updateDescription(sessionId, description);
    }

    /**
     * Update a specific session's description.
     *
     * @param sessionId The session ID
     * @param description The new description
     * @return true if successful
     */
    public boolean updateSessionDescription(int sessionId, String description) {
        return sessionRepository.updateDescription(sessionId, description);
    }

    /**
     * Touch current session to update last_update timestamp.
     */
    public void touchCurrentSession() {
        int sessionId = currentSessionId.get();
        if (sessionId != NO_SESSION) {
            sessionRepository.touchSession(sessionId);
        }
    }

    // ==================== Ensure Session ====================

    /**
     * Ensure a session exists for the current conversation.
     * Creates a new session if none exists and message store has content.
     *
     * @param programHash The program hash
     * @return The session ID (existing or newly created)
     */
    public int ensureSession(String programHash) {
        synchronized (sessionLock) {
            if (currentSessionId.get() == NO_SESSION && !messageStore.isEmpty()) {
                return createNewSession(programHash);
            }
            return currentSessionId.get();
        }
    }
}

```

`src/main/java/ghidrassist/chat/session/ChatSessionRepository.java`:

```java
package ghidrassist.chat.session;

import java.util.List;
import java.util.Optional;

/**
 * Repository interface for chat session persistence operations.
 */
public interface ChatSessionRepository {

    /**
     * Create a new chat session.
     *
     * @param programHash The program hash
     * @param description The session description
     * @return The new session ID, or -1 on failure
     */
    int createSession(String programHash, String description);

    /**
     * Get all sessions for a program, ordered by last_update DESC.
     *
     * @param programHash The program hash
     * @return List of sessions (newest first)
     */
    List<ChatSession> getSessionsForProgram(String programHash);

    /**
     * Get a session by ID.
     *
     * @param sessionId The session ID
     * @return Optional containing the session if found
     */
    Optional<ChatSession> getSession(int sessionId);

    /**
     * Update session description.
     *
     * @param sessionId The session ID
     * @param description The new description
     * @return true if successful
     */
    boolean updateDescription(int sessionId, String description);

    /**
     * Update session last_update timestamp to current time.
     *
     * @param sessionId The session ID
     * @return true if successful
     */
    boolean touchSession(int sessionId);

    /**
     * Delete a session (messages will cascade delete via FK).
     *
     * @param sessionId The session ID
     * @return true if deleted
     */
    boolean deleteSession(int sessionId);

    /**
     * Check if session exists.
     *
     * @param sessionId The session ID
     * @return true if exists
     */
    boolean sessionExists(int sessionId);

    /**
     * Check if session is a ReAct session.
     *
     * @param sessionId The session ID
     * @return true if ReAct session
     */
    boolean isReActSession(int sessionId);

    /**
     * Get the next available session number for a program.
     * Used for generating default session descriptions like "Chat 1", "Chat 2".
     *
     * @param programHash The program hash
     * @return Next session number
     */
    int getNextSessionNumber(String programHash);

    /**
     * Get the legacy conversation blob for a session.
     * Used for backward compatibility during migration.
     *
     * @param sessionId The session ID
     * @return The conversation blob, or null if not found
     */
    String getLegacyConversation(int sessionId);
}

```

`src/main/java/ghidrassist/chat/util/RoleNormalizer.java`:

```java
package ghidrassist.chat.util;

/**
 * Utility class for normalizing chat message roles.
 * Provides consistent role strings across all chat-related components.
 */
public final class RoleNormalizer {

    // Standard role constants
    public static final String ROLE_USER = "user";
    public static final String ROLE_ASSISTANT = "assistant";
    public static final String ROLE_TOOL_CALL = "tool_call";
    public static final String ROLE_TOOL_RESPONSE = "tool_response";
    public static final String ROLE_ERROR = "error";
    public static final String ROLE_EDITED = "edited";
    public static final String ROLE_UNKNOWN = "unknown";

    private RoleNormalizer() {
        // Utility class - no instantiation
    }

    /**
     * Normalize role string from various formats to standard lowercase form.
     * Handles variations like "User", "ASSISTANT", "Tool Call", "tool_call", etc.
     *
     * @param role The role string to normalize (case-insensitive)
     * @return Normalized lowercase role string
     */
    public static String normalize(String role) {
        if (role == null || role.isEmpty()) {
            return ROLE_UNKNOWN;
        }

        switch (role.toLowerCase().trim()) {
            case "user":
                return ROLE_USER;

            case "assistant":
            case "ghidrassist":  // Legacy format
                return ROLE_ASSISTANT;

            case "tool call":
            case "tool_call":
            case "tool":
                return ROLE_TOOL_CALL;

            case "tool response":
            case "tool_response":
                return ROLE_TOOL_RESPONSE;

            case "error":
                return ROLE_ERROR;

            case "edited":
                return ROLE_EDITED;

            default:
                return role.toLowerCase().trim();
        }
    }

    /**
     * Format role for display in headers (capitalized form).
     * Used for generating markdown headers like "## User (timestamp)".
     *
     * @param role The role string (can be normalized or not)
     * @return Formatted role for display
     */
    public static String toDisplayFormat(String role) {
        if (role == null || role.isEmpty()) {
            return "Unknown";
        }

        String normalized = normalize(role);
        switch (normalized) {
            case ROLE_USER:
                return "User";
            case ROLE_ASSISTANT:
                return "Assistant";
            case ROLE_TOOL_CALL:
                return "Tool Call";
            case ROLE_TOOL_RESPONSE:
                return "Tool Response";
            case ROLE_ERROR:
                return "Error";
            case ROLE_EDITED:
                return "Edited";
            default:
                // Capitalize first letter
                if (normalized.isEmpty()) {
                    return "Unknown";
                }
                return normalized.substring(0, 1).toUpperCase() + normalized.substring(1);
        }
    }

    /**
     * Check if the role represents a user message.
     *
     * @param role The role to check
     * @return true if this is a user role
     */
    public static boolean isUser(String role) {
        return ROLE_USER.equals(normalize(role));
    }

    /**
     * Check if the role represents an assistant message.
     *
     * @param role The role to check
     * @return true if this is an assistant role
     */
    public static boolean isAssistant(String role) {
        return ROLE_ASSISTANT.equals(normalize(role));
    }

    /**
     * Check if the role represents a tool-related message.
     *
     * @param role The role to check
     * @return true if this is a tool call or tool response
     */
    public static boolean isTool(String role) {
        String normalized = normalize(role);
        return ROLE_TOOL_CALL.equals(normalized) || ROLE_TOOL_RESPONSE.equals(normalized);
    }
}

```

`src/main/java/ghidrassist/context/CharacterBasedTokenCounter.java`:

```java
package ghidrassist.context;

import ghidrassist.apiprovider.ChatMessage;
import com.google.gson.Gson;

import java.util.List;
import java.util.Map;

/**
 * Fallback token counter that uses character-based estimation.
 * Uses a 4-characters-per-token heuristic, which is reasonably accurate
 * for English text and matches OpenAI's general guidance.
 */
public class CharacterBasedTokenCounter implements TokenCounter {

    private static final int CHARS_PER_TOKEN = 4;
    private static final int TOOL_DEFINITION_AVG_TOKENS = 150; // Rough estimate per tool
    private final Gson gson = new Gson();

    @Override
    public int countTokens(List<ChatMessage> messages) {
        if (messages == null || messages.isEmpty()) {
            return 0;
        }

        int totalChars = 0;

        for (ChatMessage message : messages) {
            // Count role name (adds small overhead)
            if (message.getRole() != null) {
                totalChars += message.getRole().length();
            }

            // Count message content
            if (message.getContent() != null) {
                totalChars += message.getContent().length();
            }

            // Count tool call information if present
            if (message.getToolCalls() != null && !message.getToolCalls().isEmpty()) {
                String toolCallsJson = gson.toJson(message.getToolCalls());
                totalChars += toolCallsJson.length();
            }

            // Count tool call ID if present
            if (message.getToolCallId() != null) {
                totalChars += message.getToolCallId().length();
            }

            // Count thinking content if present
            if (message.getThinkingContent() != null) {
                totalChars += message.getThinkingContent().length();
            }
        }

        return totalChars / CHARS_PER_TOKEN;
    }

    @Override
    public int countTokens(String text) {
        if (text == null || text.isEmpty()) {
            return 0;
        }
        return text.length() / CHARS_PER_TOKEN;
    }

    @Override
    public int estimateTokensForTools(List<Map<String, Object>> tools) {
        if (tools == null || tools.isEmpty()) {
            return 0;
        }

        // Approach 1: If we want to be precise, serialize and count
        String toolsJson = gson.toJson(tools);
        int jsonTokens = toolsJson.length() / CHARS_PER_TOKEN;

        // Approach 2: Use average estimate
        int avgEstimate = tools.size() * TOOL_DEFINITION_AVG_TOKENS;

        // Return the larger of the two (conservative estimate)
        return Math.max(jsonTokens, avgEstimate);
    }
}

```

`src/main/java/ghidrassist/context/ContextStatus.java`:

```java
package ghidrassist.context;

/**
 * Represents the current status of context window usage.
 * Provides information about token counts, percentages, and whether compression is needed.
 */
public class ContextStatus {

    private final int currentTokens;
    private final int maxTokens;
    private final int compressionThresholdTokens;
    private final int messageCount;
    private final boolean needsCompression;
    private final String statusMessage;

    public ContextStatus(
        int currentTokens,
        int maxTokens,
        int compressionThresholdTokens,
        int messageCount,
        boolean needsCompression,
        String statusMessage
    ) {
        this.currentTokens = currentTokens;
        this.maxTokens = maxTokens;
        this.compressionThresholdTokens = compressionThresholdTokens;
        this.messageCount = messageCount;
        this.needsCompression = needsCompression;
        this.statusMessage = statusMessage;
    }

    /**
     * Calculate percentage of context window used.
     */
    public int getPercentageUsed() {
        if (maxTokens <= 0) {
            return 0;
        }
        return (currentTokens * 100) / maxTokens;
    }

    /**
     * Get percentage of threshold reached.
     */
    public int getThresholdPercentage() {
        if (compressionThresholdTokens <= 0) {
            return 0;
        }
        return (currentTokens * 100) / compressionThresholdTokens;
    }

    /**
     * Get tokens remaining before hitting max.
     */
    public int getTokensRemaining() {
        return Math.max(0, maxTokens - currentTokens);
    }

    // Getters
    public int getCurrentTokens() {
        return currentTokens;
    }

    public int getMaxTokens() {
        return maxTokens;
    }

    public int getCompressionThresholdTokens() {
        return compressionThresholdTokens;
    }

    public int getMessageCount() {
        return messageCount;
    }

    public boolean needsCompression() {
        return needsCompression;
    }

    public String getStatusMessage() {
        return statusMessage;
    }

    @Override
    public String toString() {
        return String.format(
            "ContextStatus{%d/%d tokens (%d%%), %d messages, compression:%s - %s}",
            currentTokens, maxTokens, getPercentageUsed(), messageCount,
            needsCompression ? "NEEDED" : "not needed", statusMessage
        );
    }

    /**
     * Create status indicating compression is needed.
     */
    public static ContextStatus needsCompression(
        int currentTokens,
        int maxTokens,
        int compressionThresholdTokens,
        int messageCount
    ) {
        return new ContextStatus(
            currentTokens,
            maxTokens,
            compressionThresholdTokens,
            messageCount,
            true,
            String.format("Exceeded threshold: %d > %d tokens", currentTokens, compressionThresholdTokens)
        );
    }

    /**
     * Create status indicating context is within limits.
     */
    public static ContextStatus withinLimits(
        int currentTokens,
        int maxTokens,
        int compressionThresholdTokens,
        int messageCount
    ) {
        return new ContextStatus(
            currentTokens,
            maxTokens,
            compressionThresholdTokens,
            messageCount,
            false,
            String.format("Within limits: %d/%d tokens", currentTokens, maxTokens)
        );
    }
}

```

`src/main/java/ghidrassist/context/ContextWindowConfig.java`:

```java
package ghidrassist.context;

/**
 * Configuration for context window management.
 * Defines limits, thresholds, and preservation rules for managing conversation history.
 */
public class ContextWindowConfig {

    // Token limits
    private final int maxContextTokens;           // Maximum tokens allowed in context window
    private final int compressionThresholdPercent; // Trigger compression at this % of max
    private final int maxToolResultTokens;         // Max tokens per individual tool result

    // Preservation rules
    private final int preserveRecentMessages;      // Always keep last N messages
    private final int preserveToolPairs;           // Always keep last N complete tool pairs

    // Summarization
    private final boolean enableLlmSummarization;  // Use LLM to summarize old messages

    /**
     * Create context window config with default values.
     */
    public ContextWindowConfig() {
        this(200000, 75, 10000, 10, 2, true);
    }

    /**
     * Create context window config with custom values.
     *
     * @param maxContextTokens Maximum tokens in context window
     * @param compressionThresholdPercent Percentage of max to trigger compression (0-100)
     * @param maxToolResultTokens Maximum tokens per tool result
     * @param preserveRecentMessages Always keep last N messages
     * @param preserveToolPairs Always keep last N complete tool pairs
     * @param enableLlmSummarization Use LLM for summarization
     */
    public ContextWindowConfig(
        int maxContextTokens,
        int compressionThresholdPercent,
        int maxToolResultTokens,
        int preserveRecentMessages,
        int preserveToolPairs,
        boolean enableLlmSummarization
    ) {
        this.maxContextTokens = maxContextTokens;
        this.compressionThresholdPercent = Math.max(1, Math.min(100, compressionThresholdPercent));
        this.maxToolResultTokens = maxToolResultTokens;
        this.preserveRecentMessages = preserveRecentMessages;
        this.preserveToolPairs = preserveToolPairs;
        this.enableLlmSummarization = enableLlmSummarization;
    }

    // Getters
    public int getMaxContextTokens() {
        return maxContextTokens;
    }

    public int getCompressionThresholdPercent() {
        return compressionThresholdPercent;
    }

    public int getCompressionThresholdTokens() {
        return (maxContextTokens * compressionThresholdPercent) / 100;
    }

    public int getMaxToolResultTokens() {
        return maxToolResultTokens;
    }

    public int getPreserveRecentMessages() {
        return preserveRecentMessages;
    }

    public int getPreserveToolPairs() {
        return preserveToolPairs;
    }

    public boolean isEnableLlmSummarization() {
        return enableLlmSummarization;
    }

    @Override
    public String toString() {
        return String.format(
            "ContextWindowConfig{max=%d, threshold=%d%%, toolResult=%d, recent=%d, toolPairs=%d, llmSumm=%s}",
            maxContextTokens, compressionThresholdPercent, maxToolResultTokens,
            preserveRecentMessages, preserveToolPairs, enableLlmSummarization
        );
    }
}

```

`src/main/java/ghidrassist/context/ContextWindowManager.java`:

```java
package ghidrassist.context;

import ghidrassist.LlmApi;
import ghidrassist.apiprovider.ChatMessage;
import ghidra.util.Msg;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Manages context window to prevent token overflow.
 * Provides token-based thresholds, LLM-based summarization, tool result truncation,
 * and orphaned tool call cleanup.
 *
 * Design: Standalone, reusable component with no ReAct dependencies.
 * Can be used by any feature requiring context management.
 */
public class ContextWindowManager {

    private final ContextWindowConfig config;
    private final TokenCounter tokenCounter;
    private final LlmApi llmApi; // For LLM-based summarization (optional)

    public ContextWindowManager(ContextWindowConfig config, TokenCounter tokenCounter) {
        this(config, tokenCounter, null);
    }

    public ContextWindowManager(ContextWindowConfig config, TokenCounter tokenCounter, LlmApi llmApi) {
        this.config = config;
        this.tokenCounter = tokenCounter;
        this.llmApi = llmApi;
    }

    /**
     * Main entry point: Check and manage conversation history before LLM request.
     * Compresses history if threshold exceeded, otherwise returns original.
     *
     * @param conversationHistory Current conversation messages
     * @param tools Tool definitions (for token estimation)
     * @return Managed conversation history (compressed if needed)
     */
    public CompletableFuture<List<ChatMessage>> checkAndManage(
        List<ChatMessage> conversationHistory,
        List<Map<String, Object>> tools
    ) {
        CompletableFuture<List<ChatMessage>> future = new CompletableFuture<>();

        try {
            // Get current status
            ContextStatus status = getStatus(conversationHistory, tools).join();

            // If within limits, return original history
            if (!status.needsCompression()) {
                Msg.debug(this, "Context within limits: " + status);
                future.complete(conversationHistory);
                return future;
            }

            // Compression needed
            Msg.info(this, "Context compression needed: " + status);

            // Perform compression
            compressHistory(conversationHistory)
                .thenAccept(compressedHistory -> {
                    Msg.info(this, String.format(
                        "Context compressed: %d → %d messages",
                        conversationHistory.size(), compressedHistory.size()
                    ));
                    future.complete(compressedHistory);
                })
                .exceptionally(throwable -> {
                    Msg.error(this, "Context compression failed: " + throwable.getMessage(), throwable);
                    // Fall back to original history on error
                    future.complete(conversationHistory);
                    return null;
                });

        } catch (Exception e) {
            Msg.error(this, "Context management failed: " + e.getMessage(), e);
            future.complete(conversationHistory); // Fall back to original
        }

        return future;
    }

    /**
     * Get context status without modification.
     *
     * @param conversationHistory Current conversation messages
     * @param tools Tool definitions (for token estimation)
     * @return Context status
     */
    public CompletableFuture<ContextStatus> getStatus(
        List<ChatMessage> conversationHistory,
        List<Map<String, Object>> tools
    ) {
        return CompletableFuture.supplyAsync(() -> {
            // Count tokens in conversation
            int conversationTokens = tokenCounter.countTokens(conversationHistory);

            // Estimate tokens for tools (if present)
            int toolTokens = 0;
            if (tools != null && !tools.isEmpty()) {
                toolTokens = tokenCounter.estimateTokensForTools(tools);
            }

            // Total tokens
            int totalTokens = conversationTokens + toolTokens;

            // Check if compression needed
            boolean needsCompression = totalTokens > config.getCompressionThresholdTokens();

            if (needsCompression) {
                return ContextStatus.needsCompression(
                    totalTokens,
                    config.getMaxContextTokens(),
                    config.getCompressionThresholdTokens(),
                    conversationHistory.size()
                );
            } else {
                return ContextStatus.withinLimits(
                    totalTokens,
                    config.getMaxContextTokens(),
                    config.getCompressionThresholdTokens(),
                    conversationHistory.size()
                );
            }
        });
    }

    /**
     * Truncate individual tool result to max tokens.
     * Preserves start and end with ellipsis marker.
     *
     * @param result Tool result text
     * @param maxTokens Maximum tokens (default: config.getMaxToolResultTokens())
     * @return Truncated result
     */
    public String truncateToolResult(String result, int maxTokens) {
        if (result == null || result.isEmpty()) {
            return result;
        }

        int actualMaxTokens = maxTokens > 0 ? maxTokens : config.getMaxToolResultTokens();

        // Count tokens in result
        int resultTokens = tokenCounter.countTokens(result);

        if (resultTokens <= actualMaxTokens) {
            return result; // No truncation needed
        }

        // Calculate how much to keep
        double keepRatio = (double) actualMaxTokens / resultTokens;
        int charsToKeep = (int) (result.length() * keepRatio);

        // Keep first 70% of allowed space, last 30%
        int startChars = (int) (charsToKeep * 0.7);
        int endChars = (int) (charsToKeep * 0.3);

        String truncated = result.substring(0, Math.min(startChars, result.length())) +
            "\n\n[... truncated for context management ...]\n\n" +
            result.substring(Math.max(0, result.length() - endChars));

        return truncated;
    }

    /**
     * Truncate with default max tokens from config.
     */
    public String truncateToolResult(String result) {
        return truncateToolResult(result, config.getMaxToolResultTokens());
    }

    /**
     * Cleanup orphaned tool calls (for cancellation handling).
     * Removes assistant messages with tool_calls that don't have corresponding tool results.
     *
     * @param messages Conversation messages
     * @return Cleaned messages
     */
    public List<ChatMessage> removeOrphanedToolCalls(List<ChatMessage> messages) {
        List<ChatMessage> cleaned = new ArrayList<>();
        Set<String> toolCallIdsWithResults = new HashSet<>();

        // First pass: identify tool call IDs that have results
        for (ChatMessage message : messages) {
            if (ChatMessage.ChatMessageRole.TOOL.equals(message.getRole()) &&
                message.getToolCallId() != null) {
                toolCallIdsWithResults.add(message.getToolCallId());
            }
        }

        // Second pass: remove assistant messages with orphaned tool calls
        for (int i = 0; i < messages.size(); i++) {
            ChatMessage message = messages.get(i);

            // Check if this is an assistant message with tool calls
            if (ChatMessage.ChatMessageRole.ASSISTANT.equals(message.getRole()) &&
                message.getToolCalls() != null &&
                !message.getToolCalls().isEmpty()) {

                // Check if all tool calls have results
                boolean allHaveResults = true;
                for (Object toolCall : message.getToolCalls()) {
                    // Extract tool call ID (implementation depends on toolCall structure)
                    String toolCallId = extractToolCallId(toolCall);
                    if (toolCallId != null && !toolCallIdsWithResults.contains(toolCallId)) {
                        allHaveResults = false;
                        break;
                    }
                }

                if (allHaveResults) {
                    cleaned.add(message);
                } else {
                    Msg.debug(this, "Removed orphaned tool call message at index " + i);
                }
            } else {
                cleaned.add(message);
            }
        }

        return cleaned;
    }

    /**
     * Compress conversation history when threshold exceeded.
     * Preserves system messages, recent messages, and complete tool pairs.
     * Summarizes older messages using LLM.
     *
     * @param messages Current conversation messages
     * @return Compressed messages
     */
    private CompletableFuture<List<ChatMessage>> compressHistory(List<ChatMessage> messages) {
        CompletableFuture<List<ChatMessage>> future = new CompletableFuture<>();

        try {
            List<ChatMessage> result = new ArrayList<>();

            // 1. Extract and preserve system messages
            List<ChatMessage> systemMessages = new ArrayList<>();
            List<ChatMessage> nonSystemMessages = new ArrayList<>();

            for (ChatMessage message : messages) {
                if (ChatMessage.ChatMessageRole.SYSTEM.equals(message.getRole())) {
                    systemMessages.add(message);
                } else {
                    nonSystemMessages.add(message);
                }
            }

            // 2. Preserve recent messages
            int preserveCount = config.getPreserveRecentMessages();
            int startIndexForRecent = Math.max(0, nonSystemMessages.size() - preserveCount);
            List<ChatMessage> recentMessages = nonSystemMessages.subList(startIndexForRecent, nonSystemMessages.size());

            // 3. Extract complete tool pairs from recent messages
            List<ToolPair> recentToolPairs = extractToolPairs(recentMessages);
            int preserveToolPairCount = Math.min(config.getPreserveToolPairs(), recentToolPairs.size());

            // 4. Identify messages to summarize (older messages not in recent/tool pairs)
            Set<ChatMessage> preservedMessages = new HashSet<>(recentMessages);

            // Add tool pair messages to preserved set
            for (int i = recentToolPairs.size() - preserveToolPairCount; i < recentToolPairs.size(); i++) {
                preservedMessages.addAll(recentToolPairs.get(i).getAllMessages());
            }

            List<ChatMessage> toSummarize = new ArrayList<>();
            for (ChatMessage message : nonSystemMessages) {
                if (!preservedMessages.contains(message)) {
                    toSummarize.add(message);
                }
            }

            // 5. Summarize older messages
            if (!toSummarize.isEmpty() && config.isEnableLlmSummarization() && llmApi != null) {
                summarizeMessages(toSummarize)
                    .thenAccept(summaryText -> {
                        // Build result: system + summary + recent
                        result.addAll(systemMessages);

                        // Add summary as user message
                        ChatMessage summaryMessage = new ChatMessage(
                            ChatMessage.ChatMessageRole.USER,
                            "## Conversation Summary (Older Messages)\n\n" + summaryText
                        );
                        result.add(summaryMessage);

                        // Add recent messages
                        result.addAll(recentMessages);

                        future.complete(result);
                    })
                    .exceptionally(throwable -> {
                        Msg.error(this, "Summarization failed: " + throwable.getMessage(), throwable);
                        // Fall back to keeping only system + recent
                        result.addAll(systemMessages);
                        result.addAll(recentMessages);
                        future.complete(result);
                        return null;
                    });
            } else {
                // No LLM summarization - just keep system + recent
                result.addAll(systemMessages);
                result.addAll(recentMessages);
                future.complete(result);
            }

        } catch (Exception e) {
            Msg.error(this, "History compression failed: " + e.getMessage(), e);
            future.completeExceptionally(e);
        }

        return future;
    }

    /**
     * Extract complete tool pairs from messages.
     */
    private List<ToolPair> extractToolPairs(List<ChatMessage> messages) {
        List<ToolPair> pairs = new ArrayList<>();
        ToolPair currentPair = null;

        for (ChatMessage message : messages) {
            // Check for assistant message with tool calls
            if (ChatMessage.ChatMessageRole.ASSISTANT.equals(message.getRole()) &&
                message.getToolCalls() != null &&
                !message.getToolCalls().isEmpty()) {

                // Start new pair
                currentPair = new ToolPair(message);
                pairs.add(currentPair);

            } else if (ChatMessage.ChatMessageRole.TOOL.equals(message.getRole()) &&
                       currentPair != null) {

                // Add tool result to current pair
                currentPair.addToolResult(message);
            }
        }

        return pairs;
    }

    /**
     * Use LLM to summarize older messages into compact form.
     */
    private CompletableFuture<String> summarizeMessages(List<ChatMessage> messages) {
        CompletableFuture<String> future = new CompletableFuture<>();

        if (messages.isEmpty()) {
            future.complete("");
            return future;
        }

        // Build summarization prompt
        StringBuilder prompt = new StringBuilder();
        prompt.append("Summarize the following conversation messages concisely, ");
        prompt.append("preserving key information, discoveries, and context:\n\n");

        for (ChatMessage message : messages) {
            prompt.append(String.format("**%s**: %s\n\n",
                message.getRole(),
                message.getContent() != null ? message.getContent() : "(no content)"));
        }

        prompt.append("\nProvide a compact summary (2-3 paragraphs) that captures the essential information.");

        // Use LLM to generate summary
        AtomicBoolean completed = new AtomicBoolean(false);
        StringBuilder summaryBuilder = new StringBuilder();

        llmApi.sendRequestAsync(prompt.toString(), new LlmApi.LlmResponseHandler() {
            @Override
            public void onStart() {
                summaryBuilder.setLength(0);
            }

            @Override
            public void onUpdate(String partialResponse) {
                summaryBuilder.append(partialResponse);
            }

            @Override
            public void onComplete(String fullResponse) {
                if (!completed.getAndSet(true)) {
                    future.complete(summaryBuilder.toString());
                }
            }

            @Override
            public void onError(Throwable error) {
                if (!completed.getAndSet(true)) {
                    future.completeExceptionally(error);
                }
            }
        });

        return future;
    }

    /**
     * Extract tool call ID from tool call object.
     * Handles different tool call formats from different providers.
     */
    private String extractToolCallId(Object toolCall) {
        if (toolCall == null) {
            return null;
        }

        // Try to extract ID from Map structure (most common)
        if (toolCall instanceof Map) {
            Map<?, ?> toolCallMap = (Map<?, ?>) toolCall;
            Object id = toolCallMap.get("id");
            return id != null ? id.toString() : null;
        }

        // Could add more extraction logic for other formats if needed

        return null;
    }

    // Getters
    public ContextWindowConfig getConfig() {
        return config;
    }
}

```

`src/main/java/ghidrassist/context/ProviderTokenCounter.java`:

```java
package ghidrassist.context;

import ghidrassist.apiprovider.APIProvider;
import ghidrassist.apiprovider.ChatMessage;
import ghidrassist.apiprovider.exceptions.APIProviderException;
import ghidra.util.Msg;

import java.util.List;
import java.util.Map;

/**
 * Token counter that delegates to provider-specific token counting when available,
 * falling back to character-based estimation when not supported.
 */
public class ProviderTokenCounter implements TokenCounter {

    private final APIProvider provider;
    private final CharacterBasedTokenCounter fallback;

    public ProviderTokenCounter(APIProvider provider) {
        this.provider = provider;
        this.fallback = new CharacterBasedTokenCounter();
    }

    @Override
    public int countTokens(List<ChatMessage> messages) {
        try {
            // Try provider-specific counting first
            int providerCount = provider.countTokens(messages);
            if (providerCount >= 0) {
                return providerCount;
            }
        } catch (APIProviderException e) {
            Msg.debug(this, "Provider token counting failed, using fallback: " + e.getMessage());
        }

        // Fall back to character-based estimation
        return fallback.countTokens(messages);
    }

    @Override
    public int countTokens(String text) {
        try {
            // Try provider-specific counting first
            int providerCount = provider.countTokens(text);
            if (providerCount >= 0) {
                return providerCount;
            }
        } catch (APIProviderException e) {
            Msg.debug(this, "Provider token counting failed, using fallback: " + e.getMessage());
        }

        // Fall back to character-based estimation
        return fallback.countTokens(text);
    }

    @Override
    public int estimateTokensForTools(List<Map<String, Object>> tools) {
        try {
            // Try provider-specific estimation first
            int providerEstimate = provider.estimateTokensForTools(tools);
            if (providerEstimate >= 0) {
                return providerEstimate;
            }
        } catch (APIProviderException e) {
            Msg.debug(this, "Provider tool token estimation failed, using fallback: " + e.getMessage());
        }

        // Fall back to character-based estimation
        return fallback.estimateTokensForTools(tools);
    }
}

```

`src/main/java/ghidrassist/context/TokenCounter.java`:

```java
package ghidrassist.context;

import ghidrassist.apiprovider.ChatMessage;

import java.util.List;
import java.util.Map;

/**
 * Interface for counting tokens in messages and text.
 * Provides abstraction over different token counting methods (provider-specific or estimation).
 */
public interface TokenCounter {

    /**
     * Count tokens in a list of chat messages.
     *
     * @param messages List of chat messages
     * @return Estimated token count, or -1 if unable to count
     */
    int countTokens(List<ChatMessage> messages);

    /**
     * Count tokens in a text string.
     *
     * @param text Text to count tokens for
     * @return Estimated token count, or -1 if unable to count
     */
    int countTokens(String text);

    /**
     * Estimate tokens required for tool definitions.
     * Tools are passed to LLM as part of the request and consume tokens.
     *
     * @param tools List of tool definitions in OpenAI function format
     * @return Estimated token count for tools, or -1 if unable to estimate
     */
    int estimateTokensForTools(List<Map<String, Object>> tools);
}

```

`src/main/java/ghidrassist/context/ToolPair.java`:

```java
package ghidrassist.context;

import ghidrassist.apiprovider.ChatMessage;

import java.util.ArrayList;
import java.util.List;

/**
 * Represents a complete tool calling pair:
 * - Assistant message with tool_calls
 * - One or more tool result messages
 *
 * Tool pairs must be kept together during context compression to maintain
 * conversation coherence. Splitting a pair would leave orphaned tool calls
 * or orphaned tool results, confusing the LLM.
 */
public class ToolPair {

    private final ChatMessage assistantMessage;    // Assistant message with tool_calls
    private final List<ChatMessage> toolResults;   // Tool result messages

    public ToolPair(ChatMessage assistantMessage) {
        this.assistantMessage = assistantMessage;
        this.toolResults = new ArrayList<>();
    }

    /**
     * Add a tool result message to this pair.
     */
    public void addToolResult(ChatMessage toolResult) {
        toolResults.add(toolResult);
    }

    /**
     * Get all messages in this pair (assistant + tool results).
     */
    public List<ChatMessage> getAllMessages() {
        List<ChatMessage> all = new ArrayList<>();
        all.add(assistantMessage);
        all.addAll(toolResults);
        return all;
    }

    /**
     * Check if this pair is complete (has at least one tool result).
     */
    public boolean isComplete() {
        return !toolResults.isEmpty();
    }

    /**
     * Get the number of tool calls in the assistant message.
     */
    public int getToolCallCount() {
        if (assistantMessage == null || assistantMessage.getToolCalls() == null) {
            return 0;
        }
        return assistantMessage.getToolCalls().size();
    }

    /**
     * Get the number of tool results.
     */
    public int getToolResultCount() {
        return toolResults.size();
    }

    // Getters
    public ChatMessage getAssistantMessage() {
        return assistantMessage;
    }

    public List<ChatMessage> getToolResults() {
        return toolResults;
    }

    @Override
    public String toString() {
        return String.format(
            "ToolPair{assistant with %d tool_calls, %d tool results, complete=%s}",
            getToolCallCount(), getToolResultCount(), isComplete()
        );
    }
}

```

`src/main/java/ghidrassist/core/ActionConstants.java`:

```java
package ghidrassist.core;

import java.util.*;

@SuppressWarnings("unchecked")  // Intentional use of generic varargs for function template creation
public class ActionConstants {

    public static final List<Map<String, Object>> FN_TEMPLATES = Arrays.asList(
        createFunctionTemplate(
            "rename_function",
            "Rename a function",
            createParameters(
                createParameter("new_name", "string", "The new name for the function. (e.g., recv_data)")
            )
        ),
        createFunctionTemplate(
            "rename_variable",
            "Rename a variable within a function",
            createParameters(
                createParameter("func_name", "string", "The name of the function containing the variable. (e.g., sub_40001234)"),
                createParameter("var_name", "string", "The current name of the variable. (e.g., var_20)"),
                createParameter("new_name", "string", "The new name for the variable. (e.g., recv_buf)")
            )
        ),
        createFunctionTemplate(
            "retype_variable",
            "Set a variable data type within a function",
            createParameters(
                createParameter("func_name", "string", "The name of the function containing the variable. (e.g., sub_40001234)"),
                createParameter("var_name", "string", "The current name of the variable. (e.g., rax_12)"),
                createParameter("new_type", "string", "The new type for the variable. (e.g., int32_t)")
            )
        ),
        createFunctionTemplate(
            "auto_create_struct",
            "Automatically create a structure datatype from a variable given its offset uses in a given function.",
            createParameters(
                createParameter("func_name", "string", "The name of the function containing the variable. (e.g., sub_40001234)"),
                createParameter("var_name", "string", "The current name of the variable. (e.g., rax_12)")
            )
        )
    );

    public static final Map<String, String> ACTION_PROMPTS = new HashMap<>();

    static {
        ACTION_PROMPTS.put("rename_function",
            "Analyze this decompiled function and suggest better names:\n```\n{code}\n```\n" +
            "Consider the code functionality, strings, API calls, and log parameters.\n" +
            "For C++ methods, prefer Class::Method naming. Otherwise use descriptive procedural names.\n" +
            "Call the rename_function tool 3 times with your best name suggestions."
        );
        ACTION_PROMPTS.put("rename_variable",
            "Analyze this decompiled function and suggest better variable names:\n```\n{code}\n```\n" +
            "Consider the code functionality, how variables are used, and any contextual hints.\n" +
            "Call the rename_variable tool for each variable that would benefit from a clearer name."
        );
        ACTION_PROMPTS.put("retype_variable",
            "Analyze this decompiled function and suggest better variable types:\n```\n{code}\n```\n" +
            "Consider how variables are used, pointer arithmetic, and common type patterns.\n" +
            "Call the retype_variable tool for each variable that would benefit from a more accurate type."
        );
        ACTION_PROMPTS.put("auto_create_struct",
            "Analyze this decompiled function for structure/class usage:\n```\n{code}\n```\n" +
            "Look for variables with offset access patterns like `*(ptr + 0xc)` or field-like usage.\n" +
            "Call the auto_create_struct tool for each variable that appears to be a structure or class instance."
        );
    }

    // Helper methods for creating function templates
    private static Map<String, Object> createFunctionTemplate(String name, String description, Map<String, Object> parameters) {
        Map<String, Object> functionMap = new HashMap<>();
        functionMap.put("name", name);
        functionMap.put("description", description);
        functionMap.put("parameters", parameters);
        
        Map<String, Object> template = new HashMap<>();
        template.put("type", "function");
        template.put("function", functionMap);
        return template;
    }

    private static Map<String, Object> createParameters(Map<String, Object>... parameters) {
        Map<String, Object> parametersMap = new HashMap<>();
        parametersMap.put("type", "object");
        
        Map<String, Object> properties = new HashMap<>();
        List<String> required = new ArrayList<>();
        
        for (Map<String, Object> param : parameters) {
            String name = (String) param.get("name");
            properties.put(name, param);
            required.add(name);
        }
        
        parametersMap.put("properties", properties);
        parametersMap.put("required", required);
        return parametersMap;
    }

    private static Map<String, Object> createParameter(String name, String type, String description) {
        Map<String, Object> param = new HashMap<>();
        param.put("name", name);
        param.put("type", type);
        param.put("description", description);
        return param;
    }
}
```

`src/main/java/ghidrassist/core/ActionExecutor.java`:

```java
package ghidrassist.core;

import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.JsonObject;

import ghidra.app.decompiler.DecompInterface;
import ghidra.app.decompiler.DecompileOptions;
import ghidra.app.decompiler.DecompileResults;
import ghidra.app.decompiler.util.FillOutStructureHelper;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeConflictHandler;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.InvalidDataTypeException;
import ghidra.program.model.data.PointerDataType;
import ghidra.program.model.data.Structure;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Parameter;
import ghidra.program.model.listing.Program;
import ghidra.program.model.listing.Variable;
import ghidra.program.model.listing.Function.FunctionUpdateType;
import ghidra.program.model.pcode.HighFunction;
import ghidra.program.model.pcode.HighFunctionDBUtil;
import ghidra.program.model.pcode.HighSymbol;
import ghidra.program.model.pcode.HighVariable;
import ghidra.program.model.symbol.SourceType;
import ghidra.util.Msg;
import ghidra.util.data.DataTypeParser;
import ghidra.util.exception.CancelledException;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.exception.InvalidInputException;
import ghidra.util.task.TaskMonitor;

public class ActionExecutor {

    private static final Gson gson = new Gson();

    /**
     * Execute a specific action with the given arguments.
     * @param action The action to execute
     * @param argumentsJson JSON string containing action arguments
     * @param program The current program
     * @param address The current address
     * @throws Exception if action execution fails
     */
    public static void executeAction(String action, String argumentsJson, Program program, Address address) 
            throws Exception {
        JsonObject arguments = gson.fromJson(argumentsJson, JsonObject.class);
        
        // Start transaction
        int transaction = program.startTransaction("Execute " + action);
        boolean success = false;
        
        try {
            switch (action) {
                case "rename_function":
                    executeFunctionRename(arguments, program, address);
                    break;
                case "rename_variable":
                    executeVariableRename(arguments, program, address);
                    break;
                case "retype_variable":
                    executeVariableRetype(arguments, program, address);
                    break;
                case "auto_create_struct":
                    executeAutoCreateStruct(arguments, program, address);
                    break;
                default:
                    throw new InvalidInputException("Unknown action: " + action);
            }
            success = true;
        } finally {
            program.endTransaction(transaction, success);
        }
    }

    private static void executeFunctionRename(JsonObject arguments, Program program, Address address) 
            throws InvalidInputException, DuplicateNameException {
        String newName = arguments.get("new_name").getAsString().strip();
        Function function = getFunctionAtAddress(program, address);
        
        function.setName(newName, SourceType.USER_DEFINED);
    }

    private static void executeVariableRename(JsonObject arguments, Program program, Address address) 
            throws InvalidInputException, DuplicateNameException {
        String varName = arguments.get("var_name").getAsString().strip();
        String newName = arguments.get("new_name").getAsString().strip();
        
        Function function = getFunctionAtAddress(program, address);
        Variable variable = findVariable(function, varName);
        
        variable.setName(newName, SourceType.USER_DEFINED);
    }

    private static void executeVariableRetype(JsonObject arguments, Program program, Address address) 
            throws Exception {
        String varName = arguments.get("var_name").getAsString().strip();
        String newTypeStr = arguments.get("new_type").getAsString().strip();
        
        Function function = getFunctionAtAddress(program, address);
        Variable variable = findVariable(function, varName);
        
        DataType newType = parseDataType(newTypeStr, program.getDataTypeManager(), program);
        if (newType == null) {
            throw new InvalidInputException("Failed to parse data type: " + newTypeStr);
        }
        
        variable.setDataType(newType, true, true, SourceType.USER_DEFINED);
    }

    private static void executeAutoCreateStruct(JsonObject arguments, Program program, Address address) 
            throws Exception {
        String varName = arguments.get("var_name").getAsString().strip();
        Function function = getFunctionAtAddress(program, address);
        
        DecompInterface decompiler = new DecompInterface();
        try {
            setupDecompiler(decompiler, program);
            DecompileResults results = decompiler.decompileFunction(function, 30, TaskMonitor.DUMMY);
            
            if (!results.decompileCompleted()) {
                throw new Exception("Decompilation failed for function: " + function.getName());
            }

            HighFunction highFunction = results.getHighFunction();
            HighVariable highVar = findHighVariable(highFunction, varName);
            
            if (highVar == null) {
                throw new InvalidInputException("Variable not found: " + varName);
            }

            createAndApplyStructure(program, function, highVar, decompiler);
            
        } finally {
            decompiler.dispose();
        }
    }

    private static Function getFunctionAtAddress(Program program, Address address) 
            throws InvalidInputException {
        Function function = program.getFunctionManager().getFunctionContaining(address);
        if (function == null) {
            throw new InvalidInputException("No function at address: " + address);
        }
        return function;
    }

    private static Variable findVariable(Function function, String varName) 
            throws InvalidInputException {
        // Commit local names to ensure all variables are available
        commitLocalNames(function.getProgram(), function);
        
        // Search in all variables and parameters
        List<Variable> allVars = new ArrayList<>();
        allVars.addAll(Arrays.asList(function.getAllVariables()));
        allVars.addAll(Arrays.asList(function.getParameters()));
        
        for (Variable var : allVars) {
            if (var.getName().equals(varName)) {
                return var;
            }
        }
        
        throw new InvalidInputException("Variable not found: " + varName);
    }

    private static DataType parseDataType(String typeStr, DataTypeManager dtm, Program program) 
            throws InvalidInputException, CancelledException, InvalidDataTypeException {
        // Try direct lookup first
        DataType dataType = dtm.getDataType(new CategoryPath("/"), typeStr);
        
        // If not found, try parsing
        if (dataType == null) {
            DataTypeParser parser = new DataTypeParser(dtm, program.getDataTypeManager(), null, DataTypeParser.AllowedDataTypes.ALL);
            dataType = parser.parse(typeStr);
        }
        
        return dataType;
    }

    private static void setupDecompiler(DecompInterface decompiler, Program program) {
        DecompileOptions options = new DecompileOptions();
        options.grabFromProgram(program);
        decompiler.setOptions(options);
        decompiler.openProgram(program);
    }

    private static HighVariable findHighVariable(HighFunction highFunction, String varName) {
        var symbols = highFunction.getLocalSymbolMap().getSymbols();
        while (symbols.hasNext()) {
            HighSymbol sym = symbols.next();
            if (sym.getName().equals(varName)) {
                return sym.getHighVariable();
            }
        }
        return null;
    }

    private static void createAndApplyStructure(Program program, Function function, 
            HighVariable highVar, DecompInterface decompiler) throws Exception {
        
        FillOutStructureHelper fillHelper = new FillOutStructureHelper(program, TaskMonitor.DUMMY);
        Structure structDT = fillHelper.processStructure(highVar, function, false, true, decompiler);
        
        if (structDT == null) {
            throw new Exception("Failed to create structure");
        }

        // Add structure to data type manager
        DataTypeManager dtm = program.getDataTypeManager();
        structDT = (Structure) dtm.addDataType(structDT, DataTypeConflictHandler.DEFAULT_HANDLER);
        PointerDataType ptrStruct = new PointerDataType(structDT);

        // First get variable from function
        Variable var = findVariable(function, highVar.getSymbol().getName());
        
        if (var instanceof ghidra.program.model.listing.AutoParameterImpl) {
            // Modify the function signature to change the data type of the auto-parameter
            updateFunctionParameter(function, var.getName(), ptrStruct);
        } else {
            // Update local variable
            HighFunctionDBUtil.updateDBVariable(highVar.getSymbol(), null, ptrStruct, SourceType.USER_DEFINED);
        }
    }

    private static void updateFunctionParameter(Function function, String paramName, 
            DataType newType) throws InvalidInputException, DuplicateNameException {
        
        Parameter[] parameters = function.getParameters();
        Parameter[] newParams = new Parameter[parameters.length];

        for (int i = 0; i < parameters.length; i++) {
            if (parameters[i].getName().equals(paramName)) {
                newParams[i] = new ghidra.program.model.listing.ParameterImpl(
                    parameters[i].getName(),
                    newType,
                    parameters[i].getVariableStorage(),
                    function.getProgram(),
                    SourceType.USER_DEFINED
                );
            } else {
                newParams[i] = parameters[i];
            }
        }

        function.updateFunction(
            function.getCallingConventionName(),
            null, // Keep return type
            FunctionUpdateType.CUSTOM_STORAGE,
            true,
            SourceType.USER_DEFINED,
            newParams
        );
    }

    /**
     * Commits local variable names to the database for a function
     */
    public static void commitLocalNames(Program program, Function function) {
        DecompInterface ifc = new DecompInterface();
        ifc.openProgram(program);
        
        DecompileResults res = ifc.decompileFunction(function, 30, null);
        if (res.decompileCompleted()) {
            try {
                function.setName(function.getName(), SourceType.USER_DEFINED); // Commit the function parameters
                HighFunction hf = res.getHighFunction();
                HighFunctionDBUtil.commitLocalNamesToDatabase(hf, SourceType.ANALYSIS);
                HighFunctionDBUtil.commitParamsToDatabase(hf, true, null, SourceType.ANALYSIS);
            } catch (Exception e) {
                Msg.error(ActionExecutor.class, "Error committing local names: " + e.getMessage());
            }
        }
        
        ifc.closeProgram();
    }
}
```

`src/main/java/ghidrassist/core/ActionParser.java`:

```java
package ghidrassist.core;

import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import javax.swing.table.DefaultTableModel;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonSyntaxException;
import com.google.gson.stream.JsonReader;

public class ActionParser {
    private static final Gson gson = new Gson();
    
    /**
     * Parse the LLM response and display actions in the table model.
     * @param response Raw response from LLM
     * @param model Table model to populate
     * @throws Exception if parsing fails
     */
    public static void parseAndDisplay(String response, DefaultTableModel model) throws Exception {
        String jsonStr = extractToolCallsJson(response);
        JsonObject jsonObject = parseJson(jsonStr);
        
        if (!jsonObject.has("tool_calls")) {
            throw new Exception("Response does not contain 'tool_calls' field");
        }
        
        JsonArray toolCallsArray = jsonObject.getAsJsonArray("tool_calls");
        processToolCalls(toolCallsArray, model);
    }
    
    /**
     * Extract tool calls JSON from various response formats (Anthropic, OpenAI, etc.).
     */
    private static String extractToolCallsJson(String response) throws Exception {
        // First check if this is already a tool calls JSON object
        try {
            JsonObject responseObj = gson.fromJson(response, JsonObject.class);

            // Check if this is already tool calls JSON
            if (responseObj.has("tool_calls")) {
                return response;
            }

            // Check for OpenAI format: choices[].message.tool_calls
            if (responseObj.has("choices")) {
                JsonArray choices = responseObj.getAsJsonArray("choices");
                if (choices.size() > 0) {
                    JsonObject choice = choices.get(0).getAsJsonObject();
                    if (choice.has("message")) {
                        JsonObject message = choice.getAsJsonObject("message");

                        // OpenAI style tool_calls in message
                        if (message.has("tool_calls")) {
                            JsonArray toolCalls = message.getAsJsonArray("tool_calls");
                            JsonObject result = new JsonObject();
                            result.add("tool_calls", toolCalls);
                            return gson.toJson(result);
                        }

                        // Anthropic/Bedrock style - content array with tool_use blocks
                        if (message.has("content") && message.get("content").isJsonArray()) {
                            JsonArray convertedToolCalls = convertAnthropicToolUseToToolCalls(
                                    message.getAsJsonArray("content"));
                            if (convertedToolCalls != null && convertedToolCalls.size() > 0) {
                                JsonObject result = new JsonObject();
                                result.add("tool_calls", convertedToolCalls);
                                return gson.toJson(result);
                            }
                        }
                    }
                }
            }

            // Check if this is an Anthropic response with content array at top level
            if (responseObj.has("content") && responseObj.get("content").isJsonArray()) {
                JsonArray contentArray = responseObj.getAsJsonArray("content");

                // First check for tool_use blocks (Anthropic native format)
                JsonArray convertedToolCalls = convertAnthropicToolUseToToolCalls(contentArray);
                if (convertedToolCalls != null && convertedToolCalls.size() > 0) {
                    JsonObject result = new JsonObject();
                    result.add("tool_calls", convertedToolCalls);
                    return gson.toJson(result);
                }

                // Fall back to checking for text content with embedded JSON
                if (contentArray.size() > 0) {
                    JsonObject firstContent = contentArray.get(0).getAsJsonObject();
                    if (firstContent.has("type") && "text".equals(firstContent.get("type").getAsString())
                        && firstContent.has("text")) {
                        String textContent = firstContent.get("text").getAsString();
                        return preprocessJsonResponse(textContent);
                    }
                }
            }
        } catch (JsonSyntaxException e) {
            // Not a JSON object, treat as raw text that needs preprocessing
        }

        // This is likely text content from Anthropic provider that needs preprocessing
        return preprocessJsonResponse(response);
    }

    /**
     * Convert Anthropic tool_use content blocks to OpenAI-style tool_calls array.
     *
     * Anthropic format:
     *   { "type": "tool_use", "id": "...", "name": "func_name", "input": {...} }
     *
     * OpenAI format:
     *   { "function": { "name": "func_name", "arguments": "{...}" } }
     */
    private static JsonArray convertAnthropicToolUseToToolCalls(JsonArray contentArray) {
        JsonArray toolCalls = new JsonArray();

        for (JsonElement item : contentArray) {
            if (!item.isJsonObject()) continue;

            JsonObject contentBlock = item.getAsJsonObject();
            if (!contentBlock.has("type")) continue;

            String type = contentBlock.get("type").getAsString();
            if ("tool_use".equals(type)) {
                JsonObject toolCall = new JsonObject();
                JsonObject function = new JsonObject();

                // Get function name
                if (contentBlock.has("name")) {
                    function.addProperty("name", contentBlock.get("name").getAsString());
                }

                // Get arguments (called "input" in Anthropic format)
                if (contentBlock.has("input")) {
                    // Convert input object to JSON string (OpenAI stores arguments as string)
                    function.add("arguments", contentBlock.get("input"));
                }

                toolCall.add("function", function);

                // Preserve ID if present
                if (contentBlock.has("id")) {
                    toolCall.addProperty("id", contentBlock.get("id").getAsString());
                }

                toolCalls.add(toolCall);
            }
        }

        return toolCalls;
    }

    /**
     * Preprocess the response to extract JSON from potential code blocks.
     */
    private static String preprocessJsonResponse(String response) {
        String json = response.trim();

        // Define regex patterns to match code block markers
        Pattern codeBlockPattern = Pattern.compile("(?s)^[`']{3}(\\w+)?\\s*(.*?)\\s*[`']{3}$");
        Matcher matcher = codeBlockPattern.matcher(json);

        if (matcher.find()) {
            // Extract the content inside the code block
            json = matcher.group(2).trim();
        } else {
            // If no code block markers, attempt to find the JSON content directly
            // Remove any leading or trailing quotes (but be careful about JSON strings)
            if ((json.startsWith("\"") && json.endsWith("\"")) || 
                (json.startsWith("'") && json.endsWith("'"))) {
                // Only remove if it's wrapping the entire content, not part of JSON
                String withoutQuotes = json.substring(1, json.length() - 1).trim();
                try {
                    // Test if removing quotes gives us valid JSON
                    gson.fromJson(withoutQuotes, JsonElement.class);
                    json = withoutQuotes;
                } catch (JsonSyntaxException e) {
                    // Keep original if removing quotes breaks JSON
                }
            }
        }
        
        // Handle escaped quotes in JSON strings from Anthropic
        // This handles the case where the JSON content itself has escaped quotes
        if (json.contains("\\\"")) {
            // Try to parse with escaped quotes
            try {
                gson.fromJson(json, JsonElement.class);
                // If it parses, return as-is
                return json;
            } catch (JsonSyntaxException e) {
                // If parsing fails, try unescaping quotes
                json = json.replace("\\\"", "\"");
            }
        }
        
        // Clean up escaped whitespace
        json = json.replace("\\n", "\n").replace("\\t", "\t").replace("\\r", "\r");
        
        // Clean up some specific malformed patterns but preserve valid escapes
        json = json.replace(":\"{\"", ":{\"").replace("\"}\"}", "\"}}");
        
        return json;
    }
    
    /**
     * Parse JSON string into JsonObject with lenient parsing.
     */
    private static JsonObject parseJson(String jsonStr) throws JsonSyntaxException {
        JsonReader jsonReader = new JsonReader(new StringReader(jsonStr));
        jsonReader.setLenient(true);
        JsonElement jsonElement = gson.fromJson(jsonReader, JsonElement.class);
        
        if (!jsonElement.isJsonObject()) {
            throw new JsonSyntaxException("Unexpected JSON structure in response");
        }
        
        return jsonElement.getAsJsonObject();
    }
    
    /**
     * Process tool calls array and populate table model.
     */
    private static void processToolCalls(JsonArray toolCallsArray, DefaultTableModel model) {
        // Get list of valid function names
        List<String> validFunctions = new ArrayList<>();
        for (Map<String, Object> fnTemplate : ActionConstants.FN_TEMPLATES) {
            @SuppressWarnings("unchecked")
            Map<String, Object> functionMap = (Map<String, Object>) fnTemplate.get("function");
            validFunctions.add(functionMap.get("name").toString());
        }
        
        // Process each tool call
        for (JsonElement toolCallElement : toolCallsArray) {
            if (!toolCallElement.isJsonObject()) {
                continue;
            }
            
            JsonObject toolCallObject;
            if (toolCallElement.getAsJsonObject().has("function")) {
            	toolCallObject = toolCallElement.getAsJsonObject().get("function").getAsJsonObject();
            } else {
            	toolCallObject = toolCallElement.getAsJsonObject();
            }
            
            // Validate tool call has required fields
            if (!toolCallObject.has("name") || !toolCallObject.has("arguments")) {
                continue;
            }
            
            String functionName = toolCallObject.get("name").getAsString();
            JsonObject arguments;
            
            // Handle arguments field - can be either JsonObject or JSON string
            JsonElement argumentsElement = toolCallObject.get("arguments");
            if (argumentsElement.isJsonObject()) {
                arguments = argumentsElement.getAsJsonObject();
            } else if (argumentsElement.isJsonPrimitive()) {
                // Parse JSON string (common in OpenAI responses)
                try {
                    arguments = gson.fromJson(argumentsElement.getAsString(), JsonObject.class);
                } catch (JsonSyntaxException e) {
                    // If parsing fails, skip this tool call
                    continue;
                }
            } else {
                // Skip if arguments is neither object nor string
                continue;
            }
            
            // Skip if function is not in our templates
            if (!validFunctions.contains(functionName)) {
                continue;
            }
            
            // Add to actions table
            Object[] rowData = new Object[]{
                Boolean.FALSE,  // Initially unchecked
                functionName.replace("_", " "),
                formatDescription(functionName, arguments),
                "",  // Status
                arguments.toString()  // Store full arguments JSON
            };
            model.addRow(rowData);
        }
    }
    
    /**
     * Format the description based on action type and arguments.
     */
    private static String formatDescription(String functionName, JsonObject arguments) {
        try {
            switch (functionName) {
                case "rename_function":
                    return arguments.get("new_name").getAsString();
                    
                case "rename_variable":
                    return arguments.get("var_name").getAsString() + " -> " + 
                           arguments.get("new_name").getAsString();
                    
                case "retype_variable":
                    return arguments.get("var_name").getAsString() + " -> " + 
                           arguments.get("new_type").getAsString();
                    
                case "auto_create_struct":
                    return arguments.get("var_name").getAsString();
                    
                default:
                    return "";
            }
        } catch (Exception e) {
            return "Error: Failed to parse arguments";
        }
    }
}

```

`src/main/java/ghidrassist/core/CodeUtils.java`:

```java
package ghidrassist.core;

import ghidra.app.decompiler.ClangLine;
import ghidra.app.decompiler.ClangNode;
import ghidra.app.decompiler.ClangToken;
import ghidra.app.decompiler.ClangTokenGroup;
import ghidra.app.decompiler.DecompInterface;
import ghidra.app.decompiler.DecompileResults;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Instruction;
import ghidra.program.model.listing.InstructionIterator;
import ghidra.program.model.listing.Listing;
import ghidra.program.model.listing.Program;
import ghidra.util.task.TaskMonitor;

public class CodeUtils {

    /**
     * View type enumeration for line explanation context.
     */
    public enum ViewType {
        DECOMPILER,
        DISASSEMBLY
    }

    /**
     * Data class holding line context for explanation generation.
     */
    public static class LineContext {
        private final String currentLine;
        private final String linesBefore;
        private final String linesAfter;
        private final ViewType viewType;
        private final long lineAddress;
        private final String functionName;

        public LineContext(String currentLine, String linesBefore, String linesAfter,
                           ViewType viewType, long lineAddress, String functionName) {
            this.currentLine = currentLine;
            this.linesBefore = linesBefore;
            this.linesAfter = linesAfter;
            this.viewType = viewType;
            this.lineAddress = lineAddress;
            this.functionName = functionName;
        }

        public String getCurrentLine() { return currentLine; }
        public String getLinesBefore() { return linesBefore; }
        public String getLinesAfter() { return linesAfter; }
        public ViewType getViewType() { return viewType; }
        public long getLineAddress() { return lineAddress; }
        public String getFunctionName() { return functionName; }

        /**
         * Check if this context has valid content.
         */
        public boolean isValid() {
            return currentLine != null && !currentLine.trim().isEmpty();
        }
    }

    /**
     * Gets the decompiled code for a function.
     * @param function The function to decompile
     * @param monitor Task monitor for tracking progress
     * @return The decompiled code as a string
     */
    public static String getFunctionCode(Function function, TaskMonitor monitor) {
        DecompInterface decompiler = new DecompInterface();
        decompiler.openProgram(function.getProgram());

        try {
            DecompileResults results = decompiler.decompileFunction(function, 60, monitor);
            if (results != null && results.decompileCompleted()) {
                return results.getDecompiledFunction().getC();
            } else {
                return "Failed to decompile function.";
            }
        } catch (Exception e) {
            return "Failed to decompile function: " + e.getMessage();
        } finally {
            decompiler.dispose();
        }
    }

    /**
     * Gets the disassembly for a function.
     * @param function The function to disassemble
     * @return The disassembled code as a string
     */
    public static String getFunctionDisassembly(Function function) {
        StringBuilder sb = new StringBuilder();
        Listing listing = function.getProgram().getListing();
        InstructionIterator instructions = listing.getInstructions(function.getBody(), true);

        while (instructions.hasNext()) {
            Instruction instr = instructions.next();
            sb.append(formatInstruction(instr)).append("\n");
        }

        return sb.toString();
    }

    /**
     * Gets the decompiled code for a specific line at an address.
     * @param address The address to get code for
     * @param monitor Task monitor for tracking progress
     * @param program The current program
     * @return The decompiled line as a string
     */
    public static String getLineCode(Address address, TaskMonitor monitor, Program program) {
        DecompInterface decompiler = new DecompInterface();
        decompiler.openProgram(program);

        try {
            Function function = program.getFunctionManager().getFunctionContaining(address);
            if (function == null) {
                return "No function containing the address.";
            }

            DecompileResults results = decompiler.decompileFunction(function, 60, monitor);
            if (results != null && results.decompileCompleted()) {
                ClangTokenGroup tokens = results.getCCodeMarkup();
                if (tokens != null) {
                    // Find closest token to the address
                    ClangToken closestToken = findClosestTokenForAddress(tokens, address);
                    if (closestToken != null) {
                        // Get the line content from the token's line parent
                        ClangLine lineParent = closestToken.getLineParent();
                        if (lineParent != null) {
                            StringBuilder lineText = new StringBuilder();
                            // Use ClangLine's getAllTokens() method
                            for (ClangToken lineToken : lineParent.getAllTokens()) {
                                String text = lineToken.getText();
                                if (text != null) {
                                    lineText.append(text);
                                }
                            }
                            if (lineText.length() > 0) {
                                return lineText.toString().trim();
                            }
                        }
                        // Fallback to just the token text
                        return closestToken.getText();
                    }
                    return "No code line found at the address.";
                } else {
                    return "Failed to get code tokens.";
                }
            } else {
                return "Failed to decompile function.";
            }
        } catch (Exception e) {
            return "Failed to decompile line: " + e.getMessage();
        } finally {
            decompiler.dispose();
        }
    }

    /**
     * Gets the disassembly for a specific address.
     * @param address The address to get disassembly for
     * @param program The current program
     * @return The disassembled instruction as a string
     */
    public static String getLineDisassembly(Address address, Program program) {
        Instruction instruction = program.getListing().getInstructionAt(address);
        if (instruction != null) {
            return formatInstruction(instruction);
        }
        return null;
    }

    /**
     * Gets decompiled line with surrounding context.
     * @param address The target address
     * @param monitor Task monitor
     * @param program The current program
     * @param contextLines Number of context lines before/after (default 5)
     * @return LineContext with the target line and surrounding context
     */
    public static LineContext getDecompiledLineWithContext(Address address, TaskMonitor monitor,
                                                            Program program, int contextLines) {
        ghidra.util.Msg.info(CodeUtils.class, "getDecompiledLineWithContext: address=" + address);

        Function function = program.getFunctionManager().getFunctionContaining(address);
        if (function == null) {
            ghidra.util.Msg.warn(CodeUtils.class, "getDecompiledLineWithContext: No function at address " + address);
            return null;
        }
        ghidra.util.Msg.info(CodeUtils.class, "getDecompiledLineWithContext: function=" + function.getName());

        DecompInterface decompiler = new DecompInterface();
        decompiler.openProgram(program);

        try {
            ghidra.util.Msg.info(CodeUtils.class, "getDecompiledLineWithContext: Decompiling function...");
            DecompileResults results = decompiler.decompileFunction(function, 60, monitor);
            if (results == null) {
                ghidra.util.Msg.warn(CodeUtils.class, "getDecompiledLineWithContext: Decompile results is null");
                return null;
            }
            if (!results.decompileCompleted()) {
                ghidra.util.Msg.warn(CodeUtils.class, "getDecompiledLineWithContext: Decompile did not complete");
                return null;
            }

            String fullCode = results.getDecompiledFunction().getC();
            if (fullCode == null || fullCode.isEmpty()) {
                ghidra.util.Msg.warn(CodeUtils.class, "getDecompiledLineWithContext: No decompiled code");
                return null;
            }
            ghidra.util.Msg.info(CodeUtils.class, "getDecompiledLineWithContext: Got decompiled code, length=" + fullCode.length());

            // Split code into lines
            String[] lines = fullCode.split("\n");
            ghidra.util.Msg.info(CodeUtils.class, "getDecompiledLineWithContext: Total lines=" + lines.length);

            // Get the specific line at this address using token analysis
            ClangTokenGroup tokens = results.getCCodeMarkup();
            int targetLineNum = -1;

            if (tokens != null) {
                ghidra.util.Msg.info(CodeUtils.class, "getDecompiledLineWithContext: Got tokens, finding closest token...");
                // Try to find a token at or near this address
                ClangToken closestToken = findClosestTokenForAddress(tokens, address);
                if (closestToken != null) {
                    ghidra.util.Msg.info(CodeUtils.class, "getDecompiledLineWithContext: Found closestToken: '" +
                        closestToken.getText() + "' at addr=" + closestToken.getMinAddress());
                    // Get line number by finding the token's line in the decompiled output
                    targetLineNum = getLineNumberFromToken(closestToken, lines);
                    ghidra.util.Msg.info(CodeUtils.class, "getDecompiledLineWithContext: targetLineNum from token=" + targetLineNum);
                } else {
                    ghidra.util.Msg.warn(CodeUtils.class, "getDecompiledLineWithContext: No closest token found");
                }
            } else {
                ghidra.util.Msg.warn(CodeUtils.class, "getDecompiledLineWithContext: No tokens from decompiler");
            }

            // Fallback: if token-based lookup failed, use a simple heuristic
            // Find a line that might correspond to this address based on function structure
            if (targetLineNum < 0) {
                ghidra.util.Msg.info(CodeUtils.class, "getDecompiledLineWithContext: Using fallback heuristic");
                // Default to first non-signature line (typically line 2 or 3 in decompiled output)
                targetLineNum = Math.min(2, lines.length - 1);
                // Try to find a line with actual code (not just braces or whitespace)
                for (int i = 2; i < lines.length - 1; i++) {
                    String trimmed = lines[i].trim();
                    if (!trimmed.isEmpty() && !trimmed.equals("{") && !trimmed.equals("}")) {
                        targetLineNum = i;
                        break;
                    }
                }
                ghidra.util.Msg.info(CodeUtils.class, "getDecompiledLineWithContext: Fallback targetLineNum=" + targetLineNum);
            }

            if (targetLineNum < 0 || targetLineNum >= lines.length) {
                ghidra.util.Msg.warn(CodeUtils.class, "getDecompiledLineWithContext: Invalid line number " +
                    targetLineNum + " (lines.length=" + lines.length + ")");
                return null;
            }

            String currentLine = lines[targetLineNum];
            ghidra.util.Msg.info(CodeUtils.class, "getDecompiledLineWithContext: Selected line " +
                targetLineNum + ": '" + currentLine + "'");

            // Gather context lines before
            StringBuilder beforeBuilder = new StringBuilder();
            int startIdx = Math.max(0, targetLineNum - contextLines);
            for (int i = startIdx; i < targetLineNum; i++) {
                beforeBuilder.append(lines[i]).append("\n");
            }

            // Gather context lines after
            StringBuilder afterBuilder = new StringBuilder();
            int endIdx = Math.min(lines.length, targetLineNum + 1 + contextLines);
            for (int i = targetLineNum + 1; i < endIdx; i++) {
                afterBuilder.append(lines[i]).append("\n");
            }

            ghidra.util.Msg.info(CodeUtils.class, "getDecompiledLineWithContext: SUCCESS - returning LineContext");
            return new LineContext(
                currentLine.trim(),
                beforeBuilder.toString(),
                afterBuilder.toString(),
                ViewType.DECOMPILER,
                address.getOffset(),
                function.getName()
            );

        } catch (Exception e) {
            ghidra.util.Msg.error(CodeUtils.class, "getDecompiledLineWithContext: Exception: " + e.getMessage(), e);
            return null;
        } finally {
            decompiler.dispose();
        }
    }

    /**
     * Find the closest token to a given address.
     */
    private static ClangToken findClosestTokenForAddress(ClangTokenGroup tokens, Address targetAddress) {
        ClangToken[] result = new ClangToken[1];
        long[] bestDistance = new long[]{Long.MAX_VALUE};

        findClosestTokenRecursive(tokens, targetAddress, result, bestDistance);
        return result[0];
    }

    /**
     * Recursive helper to find the closest token to an address.
     */
    private static void findClosestTokenRecursive(ClangNode node, Address targetAddress,
                                                   ClangToken[] result, long[] bestDistance) {
        if (node instanceof ClangToken) {
            ClangToken token = (ClangToken) node;
            Address minAddr = token.getMinAddress();
            Address maxAddr = token.getMaxAddress();

            if (minAddr != null) {
                // Check if address is within range
                if (maxAddr != null &&
                    minAddr.compareTo(targetAddress) <= 0 &&
                    maxAddr.compareTo(targetAddress) >= 0) {
                    // Exact match - this is the best possible
                    result[0] = token;
                    bestDistance[0] = 0;
                    return;
                }

                // Calculate distance to this token
                long distance = Math.abs(minAddr.getOffset() - targetAddress.getOffset());
                if (distance < bestDistance[0]) {
                    bestDistance[0] = distance;
                    result[0] = token;
                }
            }
        }

        if (node instanceof ClangTokenGroup) {
            ClangTokenGroup group = (ClangTokenGroup) node;
            for (int i = 0; i < group.numChildren(); i++) {
                findClosestTokenRecursive(group.Child(i), targetAddress, result, bestDistance);
                // Early exit if we found an exact match
                if (bestDistance[0] == 0) {
                    return;
                }
            }
        }
    }

    /**
     * Get the line number of a token using ClangLine.getLineNumber().
     * The line number from ClangLine is 1-indexed, so we subtract 1 to get 0-indexed.
     */
    private static int getLineNumberFromToken(ClangToken token, String[] lines) {
        if (token == null) {
            ghidra.util.Msg.warn(CodeUtils.class, "getLineNumberFromToken: token is null");
            return -1;
        }

        // Get the ClangLine parent which has the line number
        ClangLine lineParent = token.getLineParent();
        if (lineParent != null) {
            // ClangLine.getLineNumber() returns 1-indexed line number
            int lineNum = lineParent.getLineNumber();
            ghidra.util.Msg.info(CodeUtils.class, "getLineNumberFromToken: ClangLine.getLineNumber()=" + lineNum);

            // Convert to 0-indexed and validate
            int zeroIndexed = lineNum - 1;
            if (zeroIndexed >= 0 && zeroIndexed < lines.length) {
                return zeroIndexed;
            }
            ghidra.util.Msg.warn(CodeUtils.class, "getLineNumberFromToken: lineNum " + lineNum +
                " out of range (lines.length=" + lines.length + ")");
        } else {
            ghidra.util.Msg.warn(CodeUtils.class, "getLineNumberFromToken: lineParent is null");
        }

        // Fallback: try to match the token text in the lines
        String tokenText = token.getText();
        if (tokenText != null && !tokenText.trim().isEmpty()) {
            ghidra.util.Msg.info(CodeUtils.class, "getLineNumberFromToken: Fallback - searching for token text: '" + tokenText + "'");
            for (int i = 0; i < lines.length; i++) {
                if (lines[i].contains(tokenText.trim())) {
                    ghidra.util.Msg.info(CodeUtils.class, "getLineNumberFromToken: Found token text at line " + i);
                    return i;
                }
            }
        }

        return -1;
    }

    /**
     * Collect all text from a node and its children.
     */
    private static void collectTokenText(ClangNode node, StringBuilder sb) {
        if (node instanceof ClangToken) {
            String text = ((ClangToken) node).getText();
            if (text != null) {
                sb.append(text);
            }
        } else if (node instanceof ClangTokenGroup) {
            ClangTokenGroup group = (ClangTokenGroup) node;
            for (int i = 0; i < group.numChildren(); i++) {
                collectTokenText(group.Child(i), sb);
            }
        }
    }

    /**
     * Gets disassembly line with surrounding instruction context.
     * @param address The target address
     * @param program The current program
     * @param contextLines Number of instructions before/after (default 5)
     * @return LineContext with the target instruction and surrounding context
     */
    public static LineContext getDisassemblyLineWithContext(Address address, Program program, int contextLines) {
        Function function = program.getFunctionManager().getFunctionContaining(address);
        if (function == null) {
            return null;
        }

        Listing listing = program.getListing();
        Instruction currentInstr = listing.getInstructionAt(address);
        if (currentInstr == null) {
            // Try to find nearest instruction
            currentInstr = listing.getInstructionContaining(address);
            if (currentInstr == null) {
                return null;
            }
        }

        String currentLine = formatInstruction(currentInstr);

        // Gather instructions before
        StringBuilder beforeBuilder = new StringBuilder();
        Instruction prevInstr = currentInstr;
        java.util.List<String> beforeList = new java.util.ArrayList<>();
        for (int i = 0; i < contextLines; i++) {
            prevInstr = prevInstr.getPrevious();
            if (prevInstr == null || !function.getBody().contains(prevInstr.getAddress())) {
                break;
            }
            beforeList.add(0, formatInstruction(prevInstr));
        }
        for (String line : beforeList) {
            beforeBuilder.append(line).append("\n");
        }

        // Gather instructions after
        StringBuilder afterBuilder = new StringBuilder();
        Instruction nextInstr = currentInstr;
        for (int i = 0; i < contextLines; i++) {
            nextInstr = nextInstr.getNext();
            if (nextInstr == null || !function.getBody().contains(nextInstr.getAddress())) {
                break;
            }
            afterBuilder.append(formatInstruction(nextInstr)).append("\n");
        }

        return new LineContext(
            currentLine,
            beforeBuilder.toString(),
            afterBuilder.toString(),
            ViewType.DISASSEMBLY,
            address.getOffset(),
            function.getName()
        );
    }


    /**
     * Formats an instruction with its address and representation.
     * @param instruction The instruction to format
     * @return A formatted string representation of the instruction
     */
    private static String formatInstruction(Instruction instruction) {
        return String.format("%s  %s", 
            instruction.getAddressString(true, true), 
            instruction.toString());
    }
}

```

`src/main/java/ghidrassist/core/ConversationalToolHandler.java`:

```java
package ghidrassist.core;

import ghidrassist.LlmApi;
import ghidrassist.apiprovider.AnthropicPlatformApiProvider;
import ghidrassist.apiprovider.OpenAIPlatformApiProvider;
import ghidrassist.apiprovider.LMStudioProvider;
import ghidrassist.apiprovider.ChatMessage;
import ghidrassist.apiprovider.exceptions.RateLimitException;
import ghidrassist.tools.api.ToolResult;
import ghidrassist.tools.registry.ToolRegistry;
import ghidra.util.Msg;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

/**
 * Handles conversational tool calling with proper finish_reason monitoring.
 * Manages the turn-by-turn conversation flow with the LLM and MCP tool execution.
 */
public class ConversationalToolHandler {

    private final LlmApiClient apiClient;
    private final List<Map<String, Object>> availableFunctions;
    private final ResponseProcessor responseProcessor;
    private final LlmApi.LlmResponseHandler userHandler;
    @SuppressWarnings("unused")  // Reserved for future error handling enhancement
    private final LlmErrorHandler errorHandler;
    private final Runnable onCompletionCallback;
    private final ToolRegistry toolRegistry;

    private final List<ChatMessage> conversationHistory;
    private volatile boolean isConversationActive = false;
    private volatile boolean isCancelled = false;
    private int rateLimitRetries = 0;
    private int toolCallRound = 0; // Track tool calling rounds within iteration
    private static final int MAX_RATE_LIMIT_BACKOFF_SECONDS = 60;
    private static final int MAX_CONVERSATION_HISTORY = 20; // Keep last 20 messages to prevent token overflow
    private final int maxToolRounds; // Maximum tool calling rounds per iteration (configurable)
    private static final int API_TIMEOUT_SECONDS = 300; // Timeout for blocking API calls (generous for rate limit retries)

    public ConversationalToolHandler(
            LlmApiClient apiClient,
            List<Map<String, Object>> functions,
            ResponseProcessor responseProcessor,
            LlmApi.LlmResponseHandler userHandler,
            LlmErrorHandler errorHandler,
            Runnable onCompletionCallback,
            int maxToolRounds,
            ToolRegistry toolRegistry) {

        this.apiClient = apiClient;
        this.availableFunctions = functions;
        this.responseProcessor = responseProcessor;
        this.userHandler = userHandler;
        this.errorHandler = errorHandler;
        this.onCompletionCallback = onCompletionCallback;
        this.conversationHistory = new ArrayList<>();
        this.maxToolRounds = maxToolRounds > 0 ? maxToolRounds : 10; // Default to 10 if invalid
        this.toolRegistry = toolRegistry;
    }
    
    /**
     * Start the conversational tool calling session
     */
    public void startConversation(String userPrompt) {
        if (isConversationActive) {
            Msg.warn(this, "Conversation already active, ignoring new request");
            return;
        }

        // Validate prompt is not empty - this can happen on first load with stale state
        if (userPrompt == null || userPrompt.trim().isEmpty()) {
            Msg.warn(this, "Empty prompt received, cannot start conversation");
            userHandler.onError(new IllegalArgumentException(
                "Cannot process empty query. Please try again."));
            if (onCompletionCallback != null) {
                onCompletionCallback.run();
            }
            return;
        }

        isConversationActive = true;
        isCancelled = false; // Reset cancellation flag
        conversationHistory.clear();
        rateLimitRetries = 0; // Reset retry counter
        toolCallRound = 0; // Reset tool call round counter

        // Add initial user message
        conversationHistory.addAll(apiClient.createFunctionMessages(userPrompt));
        
        // Start the conversation loop
        userHandler.onStart();

        // Provide user feedback about automatic rate limit handling
        userHandler.onUpdate("🔄 Starting conversational tool calling (automatic retry on rate limits)...\n\n");

        continueConversation();
    }

    /**
     * Start the conversational tool calling session with existing history.
     * This preserves thinking content, tool calls, and other metadata from previous turns.
     *
     * @param existingHistory List of ChatMessages from previous conversation (with thinking data)
     * @param newUserPrompt The new user message to add
     */
    public void startConversationWithHistory(List<ChatMessage> existingHistory, String newUserPrompt) {
        if (isConversationActive) {
            Msg.warn(this, "Conversation already active, ignoring new request");
            return;
        }

        // Validate prompt is not empty
        if (newUserPrompt == null || newUserPrompt.trim().isEmpty()) {
            Msg.warn(this, "Empty prompt received, cannot start conversation");
            userHandler.onError(new IllegalArgumentException(
                "Cannot process empty query. Please try again."));
            if (onCompletionCallback != null) {
                onCompletionCallback.run();
            }
            return;
        }

        isConversationActive = true;
        isCancelled = false;
        conversationHistory.clear();
        rateLimitRetries = 0;
        toolCallRound = 0;

        // Add system message first
        conversationHistory.add(new ChatMessage(
            ChatMessage.ChatMessageRole.SYSTEM,
            apiClient.getCurrentContext()
        ));

        // Add existing history (preserving thinking data, tool calls, etc.)
        // Skip any system messages in the history since we just added our own
        if (existingHistory != null) {
            for (ChatMessage msg : existingHistory) {
                if (!ChatMessage.ChatMessageRole.SYSTEM.equals(msg.getRole())) {
                    conversationHistory.add(msg);
                }
            }
        }

        // Add new user message
        conversationHistory.add(new ChatMessage(ChatMessage.ChatMessageRole.USER, newUserPrompt));

        // Start the conversation loop
        userHandler.onStart();
        userHandler.onUpdate("🔄 Continuing conversation with history...\n\n");

        continueConversation();
    }

    /**
     * Cancel the ongoing conversation
     */
    public void cancel() {
        isCancelled = true;
        isConversationActive = false;
        userHandler.onUpdate("\n❌ **Cancelled**\n");
        userHandler.onComplete("Conversation cancelled");
        
        // Notify completion callback
        if (onCompletionCallback != null) {
            onCompletionCallback.run();
        }
    }
    
    /**
     * Continue the conversation with the current message history.
     * Supports multi-turn tool calling with safety limit (max 10 rounds per iteration).
     */
    private void continueConversation() {
        if (!isConversationActive || isCancelled) {
            return;
        }

        // Check tool calling round limit (safety mechanism for infinite loops)
        if (toolCallRound >= maxToolRounds) {
            Msg.warn(this, String.format(
                "Reached maximum tool calling rounds (%d). Completing conversation to prevent infinite loops.",
                maxToolRounds
            ));
            userHandler.onUpdate(String.format(
                "\n⚠️ **Maximum tool rounds reached (%d)** - Completing investigation with current findings.\n\n",
                maxToolRounds
            ));
            isConversationActive = false;
            userHandler.onComplete("Maximum tool calling rounds reached");
            if (onCompletionCallback != null) {
                onCompletionCallback.run();
            }
            return;
        }

        try {
            // Trim conversation history to prevent token overflow
            trimConversationHistory();

            // Call LLM with current conversation history
            // Use streaming if provider supports it (Anthropic, OpenAI, LMStudio), otherwise blocking
            if (apiClient.getProvider() instanceof AnthropicPlatformApiProvider ||
                apiClient.getProvider() instanceof OpenAIPlatformApiProvider ||
                apiClient.getProvider() instanceof LMStudioProvider) {
                streamingConversationWithFunctions();
            } else {
                // Non-streaming providers (OpenWebUI, Ollama, etc.) - use timeout protection
                CompletableFuture<String> apiFuture = CompletableFuture.supplyAsync(() -> {
                    try {
                        // Check cancellation before making API call
                        if (isCancelled) {
                            return null;
                        }

                        return apiClient.createChatCompletionWithFunctionsFullResponse(
                            conversationHistory, availableFunctions);

                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }
                });

                // Apply timeout to prevent indefinite hangs
                apiFuture
                    .orTimeout(API_TIMEOUT_SECONDS, java.util.concurrent.TimeUnit.SECONDS)
                    .thenAccept(fullResponse -> {
                        // Check cancellation after API call
                        if (isCancelled || fullResponse == null) {
                            return;
                        }

                        // Parse the response to check for tool calls and finish_reason
                        handleLLMResponse(fullResponse);
                    })
                    .exceptionally(e -> {
                        Throwable cause = e.getCause() != null ? e.getCause() : e;

                        // Handle timeout specifically
                        if (e instanceof java.util.concurrent.TimeoutException ||
                            cause instanceof java.util.concurrent.TimeoutException) {
                            Msg.warn(this, "API call timed out after " + API_TIMEOUT_SECONDS + " seconds");
                            isConversationActive = false;
                            userHandler.onUpdate("❌ **Request timed out** - The model stopped responding. Please try again.\n");
                            userHandler.onError(new Exception("API request timed out after " + API_TIMEOUT_SECONDS + " seconds. The model may be overloaded."));

                            if (onCompletionCallback != null) {
                                onCompletionCallback.run();
                            }
                            return null;
                        }

                        // Handle rate limit errors - always retry, never give up
                        String errorMsg = cause.getMessage() != null ? cause.getMessage() : "";
                        if (cause instanceof ghidrassist.apiprovider.exceptions.RateLimitException ||
                            errorMsg.contains("rate limit") ||
                            errorMsg.contains("429")) {

                            rateLimitRetries++;
                            Msg.warn(this, String.format("Rate limit exceeded during conversational tool calling (attempt %d). Retrying with backoff...",
                                rateLimitRetries));

                            // Backoff: 10s, 20s, 30s, ... capped at MAX_RATE_LIMIT_BACKOFF_SECONDS
                            int backoffSeconds = Math.min(10 * rateLimitRetries, MAX_RATE_LIMIT_BACKOFF_SECONDS);
                            userHandler.onUpdate(String.format("⏳ Rate limit hit. Pausing for %d seconds...\n",
                                backoffSeconds));

                            CompletableFuture.delayedExecutor(backoffSeconds, java.util.concurrent.TimeUnit.SECONDS)
                                .execute(() -> {
                                    if (isConversationActive && !isCancelled) {
                                        userHandler.onUpdate("🔄 Resuming...\n");
                                        continueConversation();
                                    }
                                });
                        } else {
                            // Non-rate-limit errors stop the conversation
                            isConversationActive = false;
                            userHandler.onError(cause instanceof Exception ? (Exception) cause : new Exception(cause));

                            if (onCompletionCallback != null) {
                                onCompletionCallback.run();
                            }
                        }
                        return null;
                    });
            }

        } catch (Exception e) {
            isConversationActive = false;
            userHandler.onError(e);

            // Notify completion callback
            if (onCompletionCallback != null) {
                onCompletionCallback.run();
            }
        }
    }

    /**
     * Stream conversation with functions using provider's streaming API.
     * Supports Anthropic, OpenAI, and LMStudio providers.
     * Text content streams immediately; tool calls execute after streaming completes.
     */
    private void streamingConversationWithFunctions() {
        try {
            if (apiClient.getProvider() instanceof AnthropicPlatformApiProvider) {
                streamWithAnthropicPlatformApiProvider();
            } else if (apiClient.getProvider() instanceof OpenAIPlatformApiProvider) {
                streamWithOpenAIPlatformApiProvider();
            } else if (apiClient.getProvider() instanceof LMStudioProvider) {
                streamWithLMStudioProvider();
            }
        } catch (Exception e) {
            isConversationActive = false;
            userHandler.onError(e);

            if (onCompletionCallback != null) {
                onCompletionCallback.run();
            }
        }
    }

    /**
     * Stream conversation using Anthropic provider.
     */
    private void streamWithAnthropicPlatformApiProvider() {
        try {
            AnthropicPlatformApiProvider provider = (AnthropicPlatformApiProvider) apiClient.getProvider();

            provider.streamChatCompletionWithFunctions(
                conversationHistory,
                availableFunctions,
                new AnthropicPlatformApiProvider.StreamingFunctionHandler() {
                    @Override
                    public void onTextUpdate(String textDelta) {
                        // Stream text to UI immediately
                        javax.swing.SwingUtilities.invokeLater(() -> {
                            if (!isCancelled) {
                                userHandler.onUpdate(textDelta);
                            }
                        });
                    }

                    @Override
                    public void onStreamComplete(String stopReason, String fullText, String thinkingContent, String thinkingSignature, List<AnthropicPlatformApiProvider.ToolCall> toolCalls) {
                        // Create assistant message with text content
                        ChatMessage assistantMsg = new ChatMessage(ChatMessage.ChatMessageRole.ASSISTANT, fullText);

                        // Store thinking content and signature if present
                        if (thinkingContent != null && !thinkingContent.isEmpty()) {
                            assistantMsg.setThinkingContent(thinkingContent);
                        }
                        if (thinkingSignature != null && !thinkingSignature.isEmpty()) {
                            assistantMsg.setThinkingSignature(thinkingSignature);
                        }

                        // If we have tool calls, convert them to JsonArray and attach to assistant message
                        if (!toolCalls.isEmpty()) {
                            JsonArray toolCallsArray = new JsonArray();
                            for (AnthropicPlatformApiProvider.ToolCall toolCall : toolCalls) {
                                JsonObject toolCallObj = new JsonObject();
                                toolCallObj.addProperty("id", toolCall.id);
                                toolCallObj.addProperty("type", "function");

                                JsonObject function = new JsonObject();
                                function.addProperty("name", toolCall.name);
                                function.addProperty("arguments", toolCall.arguments);
                                toolCallObj.add("function", function);

                                toolCallsArray.add(toolCallObj);
                            }

                            // Attach tool calls to assistant message
                            assistantMsg.setToolCalls(toolCallsArray);
                        }

                        // Add assistant message to conversation history
                        conversationHistory.add(assistantMsg);

                        if ("tool_use".equals(stopReason) && !toolCalls.isEmpty()) {
                            // Increment tool call round counter (multi-turn tracking)
                            toolCallRound++;
                            Msg.debug(ConversationalToolHandler.this,
                                String.format("Tool calling round %d/%d", toolCallRound, maxToolRounds));

                            // Execute tools after text streaming completes
                            handleToolCallsFromStream(toolCalls);
                        } else {
                            // Conversation complete - pass the full response text
                            handleConversationEndFromStream(fullText);
                        }
                    }

                    @Override
                    public void onError(Throwable error) {
                        // Handle rate limit errors - always retry, never give up
                        if (error instanceof RateLimitException ||
                            error.getMessage().contains("rate limit") ||
                            error.getMessage().contains("429")) {

                            rateLimitRetries++;
                            Msg.warn(ConversationalToolHandler.this,
                                String.format("Rate limit exceeded during streaming (attempt %d). Retrying with backoff...",
                                    rateLimitRetries));

                            int backoffSeconds = Math.min(10 * rateLimitRetries, MAX_RATE_LIMIT_BACKOFF_SECONDS);
                            userHandler.onUpdate(String.format("⏳ Rate limit hit. Pausing for %d seconds...\n",
                                backoffSeconds));

                            CompletableFuture.delayedExecutor(backoffSeconds, java.util.concurrent.TimeUnit.SECONDS)
                                .execute(() -> {
                                    if (isConversationActive && !isCancelled) {
                                        userHandler.onUpdate("🔄 Resuming...\n");
                                        continueConversation();
                                    }
                                });
                        } else {
                            // Non-rate-limit errors stop the conversation
                            isConversationActive = false;
                            userHandler.onError(error);

                            if (onCompletionCallback != null) {
                                onCompletionCallback.run();
                            }
                        }
                    }

                    @Override
                    public boolean shouldContinue() {
                        return !isCancelled && isConversationActive;
                    }
                }
            );

        } catch (Exception e) {
            isConversationActive = false;
            userHandler.onError(e);

            if (onCompletionCallback != null) {
                onCompletionCallback.run();
            }
        }
    }

    /**
     * Stream conversation using OpenAI provider.
     */
    private void streamWithOpenAIPlatformApiProvider() {
        try {
            OpenAIPlatformApiProvider provider = (OpenAIPlatformApiProvider) apiClient.getProvider();

            provider.streamChatCompletionWithFunctions(
                conversationHistory,
                availableFunctions,
                new OpenAIPlatformApiProvider.StreamingFunctionHandler() {
                    @Override
                    public void onTextUpdate(String textDelta) {
                        javax.swing.SwingUtilities.invokeLater(() -> {
                            if (!isCancelled) {
                                userHandler.onUpdate(textDelta);
                            }
                        });
                    }

                    @Override
                    public void onStreamComplete(String stopReason, String fullText, List<OpenAIPlatformApiProvider.ToolCall> toolCalls) {
                        ChatMessage assistantMsg = new ChatMessage(ChatMessage.ChatMessageRole.ASSISTANT, fullText);

                        if (!toolCalls.isEmpty()) {
                            JsonArray toolCallsArray = new JsonArray();
                            for (OpenAIPlatformApiProvider.ToolCall toolCall : toolCalls) {
                                JsonObject toolCallObj = new JsonObject();
                                toolCallObj.addProperty("id", toolCall.id);
                                toolCallObj.addProperty("type", "function");

                                JsonObject function = new JsonObject();
                                function.addProperty("name", toolCall.name);
                                function.addProperty("arguments", toolCall.arguments);
                                toolCallObj.add("function", function);

                                toolCallsArray.add(toolCallObj);
                            }
                            assistantMsg.setToolCalls(toolCallsArray);
                        }

                        conversationHistory.add(assistantMsg);

                        if ("tool_calls".equals(stopReason) && !toolCalls.isEmpty()) {
                            // Increment tool call round counter (multi-turn tracking)
                            toolCallRound++;
                            Msg.debug(ConversationalToolHandler.this,
                                String.format("Tool calling round %d/%d", toolCallRound, maxToolRounds));

                            handleToolCallsFromOpenAIStream(toolCalls);
                        } else {
                            // Conversation complete - pass the full response text
                            handleConversationEndFromStream(fullText);
                        }
                    }

                    @Override
                    public void onError(Throwable error) {
                        handleStreamingError(error);
                    }

                    @Override
                    public boolean shouldContinue() {
                        return !isCancelled && isConversationActive;
                    }
                }
            );

        } catch (Exception e) {
            isConversationActive = false;
            userHandler.onError(e);

            if (onCompletionCallback != null) {
                onCompletionCallback.run();
            }
        }
    }

    /**
     * Stream conversation using LMStudio provider.
     */
    private void streamWithLMStudioProvider() {
        try {
            LMStudioProvider provider = (LMStudioProvider) apiClient.getProvider();

            provider.streamChatCompletionWithFunctions(
                conversationHistory,
                availableFunctions,
                new LMStudioProvider.StreamingFunctionHandler() {
                    @Override
                    public void onTextUpdate(String textDelta) {
                        javax.swing.SwingUtilities.invokeLater(() -> {
                            if (!isCancelled) {
                                userHandler.onUpdate(textDelta);
                            }
                        });
                    }

                    @Override
                    public void onStreamComplete(String stopReason, String fullText, List<LMStudioProvider.ToolCall> toolCalls) {
                        ChatMessage assistantMsg = new ChatMessage(ChatMessage.ChatMessageRole.ASSISTANT, fullText);

                        if (!toolCalls.isEmpty()) {
                            JsonArray toolCallsArray = new JsonArray();
                            for (LMStudioProvider.ToolCall toolCall : toolCalls) {
                                JsonObject toolCallObj = new JsonObject();
                                toolCallObj.addProperty("id", toolCall.id);
                                toolCallObj.addProperty("type", "function");

                                JsonObject function = new JsonObject();
                                function.addProperty("name", toolCall.name);
                                function.addProperty("arguments", toolCall.arguments);
                                toolCallObj.add("function", function);

                                toolCallsArray.add(toolCallObj);
                            }
                            assistantMsg.setToolCalls(toolCallsArray);
                        }

                        conversationHistory.add(assistantMsg);

                        if ("tool_calls".equals(stopReason) && !toolCalls.isEmpty()) {
                            // Increment tool call round counter (multi-turn tracking)
                            toolCallRound++;
                            Msg.debug(ConversationalToolHandler.this,
                                String.format("Tool calling round %d/%d", toolCallRound, maxToolRounds));

                            handleToolCallsFromLMStudioStream(toolCalls);
                        } else {
                            // Conversation complete - pass the full response text
                            handleConversationEndFromStream(fullText);
                        }
                    }

                    @Override
                    public void onError(Throwable error) {
                        handleStreamingError(error);
                    }

                    @Override
                    public boolean shouldContinue() {
                        return !isCancelled && isConversationActive;
                    }
                }
            );

        } catch (Exception e) {
            isConversationActive = false;
            userHandler.onError(e);

            if (onCompletionCallback != null) {
                onCompletionCallback.run();
            }
        }
    }

    /**
     * Common error handling for streaming providers.
     */
    private void handleStreamingError(Throwable error) {
        if (error instanceof RateLimitException ||
            error.getMessage().contains("rate limit") ||
            error.getMessage().contains("429")) {

            rateLimitRetries++;
            Msg.warn(ConversationalToolHandler.this,
                String.format("Rate limit exceeded during streaming (attempt %d). Retrying with backoff...",
                    rateLimitRetries));

            int backoffSeconds = Math.min(10 * rateLimitRetries, MAX_RATE_LIMIT_BACKOFF_SECONDS);
            userHandler.onUpdate(String.format("⏳ Rate limit hit. Pausing for %d seconds...\n",
                backoffSeconds));

            CompletableFuture.delayedExecutor(backoffSeconds, java.util.concurrent.TimeUnit.SECONDS)
                .execute(() -> {
                    if (isConversationActive && !isCancelled) {
                        userHandler.onUpdate("🔄 Resuming...\n");
                        continueConversation();
                    }
                });
        } else {
            isConversationActive = false;
            userHandler.onError(error);

            if (onCompletionCallback != null) {
                onCompletionCallback.run();
            }
        }
    }

    /**
     * Handle tool calls from streaming response.
     * Simplified version of handleToolCalls for use with streaming.
     */
    private void handleToolCallsFromStream(List<AnthropicPlatformApiProvider.ToolCall> toolCalls) {
        try {
            // Update UI with tool calling status
            String toolExecutionHeader = "\n\n🔧 **Executing tools...**\n";
            javax.swing.SwingUtilities.invokeLater(() -> {
                userHandler.onUpdate(toolExecutionHeader);
            });

            // Convert AnthropicPlatformApiProvider.ToolCall to JsonArray format expected by existing methods
            JsonArray toolCallsArray = new JsonArray();
            for (AnthropicPlatformApiProvider.ToolCall toolCall : toolCalls) {
                JsonObject toolCallObj = new JsonObject();
                toolCallObj.addProperty("id", toolCall.id);
                toolCallObj.addProperty("type", "function");

                JsonObject function = new JsonObject();
                function.addProperty("name", toolCall.name);
                function.addProperty("arguments", toolCall.arguments);
                toolCallObj.add("function", function);

                toolCallsArray.add(toolCallObj);
            }

            // Execute tools sequentially using existing infrastructure
            executeToolsSequentially(toolCallsArray, 0, new ArrayList<>());

        } catch (Exception e) {
            Msg.error(this, "Error handling tool calls from stream: " + e.getMessage());
            isConversationActive = false;
            userHandler.onError(e);

            if (onCompletionCallback != null) {
                onCompletionCallback.run();
            }
        }
    }

    /**
     * Handle tool calls from OpenAI streaming response.
     */
    private void handleToolCallsFromOpenAIStream(List<OpenAIPlatformApiProvider.ToolCall> toolCalls) {
        try {
            String toolExecutionHeader = "\n\n🔧 **Executing tools...**\n";
            javax.swing.SwingUtilities.invokeLater(() -> {
                userHandler.onUpdate(toolExecutionHeader);
            });

            JsonArray toolCallsArray = new JsonArray();
            for (OpenAIPlatformApiProvider.ToolCall toolCall : toolCalls) {
                JsonObject toolCallObj = new JsonObject();
                toolCallObj.addProperty("id", toolCall.id);
                toolCallObj.addProperty("type", "function");

                JsonObject function = new JsonObject();
                function.addProperty("name", toolCall.name);
                function.addProperty("arguments", toolCall.arguments);
                toolCallObj.add("function", function);

                toolCallsArray.add(toolCallObj);
            }

            executeToolsSequentially(toolCallsArray, 0, new ArrayList<>());

        } catch (Exception e) {
            Msg.error(this, "Error handling tool calls from OpenAI stream: " + e.getMessage());
            isConversationActive = false;
            userHandler.onError(e);

            if (onCompletionCallback != null) {
                onCompletionCallback.run();
            }
        }
    }

    /**
     * Handle tool calls from LMStudio streaming response.
     */
    private void handleToolCallsFromLMStudioStream(List<LMStudioProvider.ToolCall> toolCalls) {
        try {
            String toolExecutionHeader = "\n\n🔧 **Executing tools...**\n";
            javax.swing.SwingUtilities.invokeLater(() -> {
                userHandler.onUpdate(toolExecutionHeader);
            });

            JsonArray toolCallsArray = new JsonArray();
            for (LMStudioProvider.ToolCall toolCall : toolCalls) {
                JsonObject toolCallObj = new JsonObject();
                toolCallObj.addProperty("id", toolCall.id);
                toolCallObj.addProperty("type", "function");

                JsonObject function = new JsonObject();
                function.addProperty("name", toolCall.name);
                function.addProperty("arguments", toolCall.arguments);
                toolCallObj.add("function", function);

                toolCallsArray.add(toolCallObj);
            }

            executeToolsSequentially(toolCallsArray, 0, new ArrayList<>());

        } catch (Exception e) {
            Msg.error(this, "Error handling tool calls from LMStudio stream: " + e.getMessage());
            isConversationActive = false;
            userHandler.onError(e);

            if (onCompletionCallback != null) {
                onCompletionCallback.run();
            }
        }
    }

    /**
     * Handle conversation end from streaming (no tool calls).
     */
    private void handleConversationEndFromStream(String fullText) {
        isConversationActive = false;

        // Pass the accumulated response text to onComplete
        String responseText = fullText != null ? fullText : "";

        javax.swing.SwingUtilities.invokeLater(() -> {
            userHandler.onComplete(responseText);
        });

        // Notify completion callback
        if (onCompletionCallback != null) {
            onCompletionCallback.run();
        }
    }

    /**
     * Handle the LLM response and determine next action based on finish_reason
     */
    private void handleLLMResponse(String rawResponse) {
        try {
            // Check cancellation before processing response
            if (isCancelled) {
                return;
            }
            
            Msg.debug(this, "Raw LLM response: " + (rawResponse != null ? rawResponse : "NULL"));
            
            // Validate response is not null or empty
            if (rawResponse == null || rawResponse.trim().isEmpty()) {
                throw new IllegalArgumentException("LLM response is null or empty");
            }
            
            // Parse the complete response including metadata
            JsonElement responseElement = JsonParser.parseString(rawResponse);
            if (responseElement == null || responseElement.isJsonNull()) {
                throw new IllegalArgumentException("LLM response parsed to null JSON");
            }
            
            if (!responseElement.isJsonObject()) {
                throw new IllegalArgumentException("LLM response is not a JSON object: " + responseElement.getClass().getSimpleName());
            }
            
            JsonObject responseObj = responseElement.getAsJsonObject();
            
            // Extract finish_reason from choices array
            String finishReason = extractFinishReason(responseObj);
            JsonObject assistantMessage = extractAssistantMessage(responseObj);
            
            Msg.debug(this, "LLM finish_reason: " + finishReason);
            
            if ("tool_calls".equals(finishReason) || "tool_use".equals(finishReason)) {
                handleToolCalls(assistantMessage, rawResponse);
            } else if ("stop".equals(finishReason) || "unknown".equals(finishReason)) {
                // Handle normal completion (no tools needed) or unknown finish_reason
                handleConversationEnd(assistantMessage);
            } else {
                // Other finish_reason types (length, content_filter, etc.)
                Msg.debug(this, "LLM finished with reason: " + finishReason + ", ending conversation");
                handleConversationEnd(assistantMessage);
            }
            
        } catch (Exception e) {
            Msg.error(this, "Error handling LLM response: " + e.getMessage());
            Msg.error(this, "Response content: " + (rawResponse != null ? rawResponse.substring(0, Math.min(500, rawResponse.length())) : "NULL"));
            isConversationActive = false;
            userHandler.onError(e);
            
            // Notify completion callback
            if (onCompletionCallback != null) {
                onCompletionCallback.run();
            }
        }
    }
    
    /**
     * Extract finish_reason from the LLM response
     */
    private String extractFinishReason(JsonObject responseObj) {
        try {
            if (responseObj != null && responseObj.has("choices")) {
                JsonElement choicesElement = responseObj.get("choices");
                if (choicesElement != null && !choicesElement.isJsonNull() && choicesElement.isJsonArray()) {
                    JsonArray choices = choicesElement.getAsJsonArray();
                    if (choices.size() > 0) {
                        JsonElement firstChoiceElement = choices.get(0);
                        if (firstChoiceElement != null && !firstChoiceElement.isJsonNull() && firstChoiceElement.isJsonObject()) {
                            JsonObject firstChoice = firstChoiceElement.getAsJsonObject();
                            if (firstChoice.has("finish_reason")) {
                                JsonElement finishReasonElement = firstChoice.get("finish_reason");
                                if (finishReasonElement != null && !finishReasonElement.isJsonNull()) {
                                    return finishReasonElement.getAsString();
                                }
                            }
                        }
                    }
                }
            }
            return "unknown";
        } catch (Exception e) {
            Msg.warn(this, "Could not extract finish_reason: " + e.getMessage());
            return "unknown";
        }
    }
    
    /**
     * Extract the assistant message from the LLM response
     */
    private JsonObject extractAssistantMessage(JsonObject responseObj) {
        try {
            if (responseObj != null && responseObj.has("choices")) {
                JsonElement choicesElement = responseObj.get("choices");
                if (choicesElement != null && !choicesElement.isJsonNull() && choicesElement.isJsonArray()) {
                    JsonArray choices = choicesElement.getAsJsonArray();
                    if (choices.size() > 0) {
                        JsonElement firstChoiceElement = choices.get(0);
                        if (firstChoiceElement != null && !firstChoiceElement.isJsonNull() && firstChoiceElement.isJsonObject()) {
                            JsonObject firstChoice = firstChoiceElement.getAsJsonObject();
                            if (firstChoice.has("message")) {
                                JsonElement messageElement = firstChoice.get("message");
                                if (messageElement != null && !messageElement.isJsonNull() && messageElement.isJsonObject()) {
                                    return messageElement.getAsJsonObject();
                                }
                            }
                        }
                    }
                }
            }
            // Fallback: try to find message directly
            if (responseObj != null && responseObj.has("message")) {
                JsonElement messageElement = responseObj.get("message");
                if (messageElement != null && !messageElement.isJsonNull() && messageElement.isJsonObject()) {
                    return messageElement.getAsJsonObject();
                }
            }
            return new JsonObject();
        } catch (Exception e) {
            Msg.warn(this, "Could not extract assistant message: " + e.getMessage());
            return new JsonObject();
        }
    }
    
    /**
     * Handle tool calls when finish_reason is "tool_calls"
     */
    private void handleToolCalls(JsonObject assistantMessage, String rawResponse) {
        try {
            // Create assistant message with tool calls
            String content = null;
            if (assistantMessage.has("content")) {
                JsonElement contentElement = assistantMessage.get("content");
                if (contentElement != null && !contentElement.isJsonNull()) {
                    content = contentElement.getAsString();
                }
            }
            
            ChatMessage assistantMsg = new ChatMessage(
                ChatMessage.ChatMessageRole.ASSISTANT, 
                content
            );
            
            // Add tool calls to the assistant message
            if (assistantMessage.has("tool_calls")) {
                assistantMsg.setToolCalls(assistantMessage.getAsJsonArray("tool_calls"));
            }
            
            conversationHistory.add(assistantMsg);
            
            // Extract tool calls
            JsonArray toolCalls = null;
            if (assistantMessage.has("tool_calls")) {
                toolCalls = assistantMessage.getAsJsonArray("tool_calls");
            } else if (assistantMessage.has("content")) {
                // Try to parse tool calls from content
                // This line should not be reached now, but adding safety
                String contentStr = "";
                if (assistantMessage.has("content")) {
                    JsonElement contentElement = assistantMessage.get("content");
                    if (contentElement != null && !contentElement.isJsonNull()) {
                        contentStr = contentElement.getAsString();
                    }
                }
                JsonObject contentObj = JsonParser.parseString(contentStr).getAsJsonObject();
                if (contentObj.has("tool_calls")) {
                    toolCalls = contentObj.getAsJsonArray("tool_calls");
                }
            }
            
            if (toolCalls == null || toolCalls.size() == 0) {
                Msg.warn(this, "No tool calls found despite finish_reason being tool_calls");
                handleConversationEnd(assistantMessage);
                return;
            }
            
            // Display text response if present, before tool execution metadata
            if (content != null && !content.trim().isEmpty()) {
                String filteredContent = responseProcessor.filterThinkBlocks(content);
                if (filteredContent != null && !filteredContent.trim().isEmpty()) {
                    javax.swing.SwingUtilities.invokeLater(() -> {
                        userHandler.onUpdate("\n" + filteredContent + "\n\n");
                    });
                }
            }
            
            // Update UI with tool calling status
            String toolExecutionHeader = "🔧 **Executing tools...**\n";
            javax.swing.SwingUtilities.invokeLater(() -> {
                userHandler.onUpdate(toolExecutionHeader);
            });
            
            // Execute tools and collect results
            executeToolsSequentially(toolCalls, 0, new ArrayList<>());
            
        } catch (Exception e) {
            Msg.error(this, "Error handling tool calls: " + e.getMessage());
            isConversationActive = false;
            userHandler.onError(e);
            
            // Notify completion callback
            if (onCompletionCallback != null) {
                onCompletionCallback.run();
            }
        }
    }
    
    /**
     * Execute tools sequentially and collect results
     */
    private void executeToolsSequentially(JsonArray toolCalls, int index, List<JsonObject> toolResults) {
        // Check cancellation before processing next tool
        if (isCancelled) {
            return;
        }
        
        if (index >= toolCalls.size()) {
            // All tools executed, add results to conversation and continue
            addToolResultsToConversation(toolResults);
            
            // Add a small delay before making the next API call to avoid rapid sequential requests
            // that could trigger rate limits
            CompletableFuture.delayedExecutor(500, java.util.concurrent.TimeUnit.MILLISECONDS)
                .execute(() -> {
                    if (!isCancelled) {
                        continueConversation();
                    }
                });
            return;
        }
        
        JsonObject toolCall = toolCalls.get(index).getAsJsonObject();
        executeSingleTool(toolCall)
            .thenAccept(result -> {
                if (!isCancelled) {
                    toolResults.add(result);
                    
                    // Add small delay between tool executions to be gentle on API rate limits
                    CompletableFuture.delayedExecutor(200, java.util.concurrent.TimeUnit.MILLISECONDS)
                        .execute(() -> {
                            if (!isCancelled) {
                                executeToolsSequentially(toolCalls, index + 1, toolResults);
                            }
                        });
                }
            })
            .exceptionally(throwable -> {
                if (!isCancelled) {
                    Msg.error(this, "Tool execution failed: " + throwable.getMessage());
                    
                    // Create error result and continue
                    JsonObject errorResult = new JsonObject();
                    errorResult.addProperty("tool_call_id", extractToolCallId(toolCall));
                    errorResult.addProperty("role", "tool");
                    errorResult.addProperty("content", "Error: " + throwable.getMessage());
                    toolResults.add(errorResult);
                    
                    // Add same delay for error case to maintain consistent pacing
                    CompletableFuture.delayedExecutor(200, java.util.concurrent.TimeUnit.MILLISECONDS)
                        .execute(() -> {
                            if (!isCancelled) {
                                executeToolsSequentially(toolCalls, index + 1, toolResults);
                            }
                        });
                }
                return null;
            });
    }
    
    /**
     * Execute a single tool and return the result
     */
    private CompletableFuture<JsonObject> executeSingleTool(JsonObject toolCall) {
        try {
            // Check cancellation before executing tool
            if (isCancelled) {
                return CompletableFuture.failedFuture(new Exception("Execution cancelled"));
            }

            String toolName = extractToolName(toolCall);
            JsonObject arguments = extractToolArguments(toolCall);
            String toolCallId = extractToolCallId(toolCall);

            // Update UI with current tool execution including parameters
            String paramDisplay = formatToolParameters(arguments);
            String executingMessage = "🛠️ Tool call in progress: *" + toolName + "(" + paramDisplay + ")*\n";
            javax.swing.SwingUtilities.invokeLater(() -> {
                userHandler.onUpdate(executingMessage);
            });

            // Execute via ToolRegistry with proper transaction handling
            return executeToolWithTransaction(toolName, arguments)
                .thenApply(result -> {
                    // Check cancellation before processing result
                    if (isCancelled) {
                        throw new RuntimeException("Execution cancelled");
                    }

                    // Debug logging for development (keep for troubleshooting)
                    Msg.debug(this, String.format("Tool '%s' completed: success=%s, length=%d",
                        toolName, result.isSuccess(),
                        result.getContent() != null ? result.getContent().length() : 0));

                    // Don't show verbose tool results to user - they'll be included in LLM response
                    String paramDisplayComplete = formatToolParameters(arguments);
                    String completionMessage = "✓ Completed: *" + toolName + "(" + paramDisplayComplete + ")*\n";

                    javax.swing.SwingUtilities.invokeLater(() -> {
                        if (!isCancelled) {
                            userHandler.onUpdate(completionMessage);
                        }
                    });

                    // Create tool result for conversation
                    JsonObject toolResult = new JsonObject();
                    toolResult.addProperty("tool_call_id", toolCallId);
                    toolResult.addProperty("role", "tool");
                    toolResult.addProperty("content", result.getContent());

                    return toolResult;
                });

        } catch (Exception e) {
            return CompletableFuture.failedFuture(e);
        }
    }
    
    /**
     * Add tool results to conversation history
     */
    private void addToolResultsToConversation(List<JsonObject> toolResults) {
        for (JsonObject result : toolResults) {
            // Safely extract content
            String content = "";
            if (result.has("content")) {
                JsonElement contentElement = result.get("content");
                if (contentElement != null && !contentElement.isJsonNull()) {
                    content = contentElement.getAsString();
                }
            }
            
            // Safely extract tool_call_id
            String toolCallId = "";
            if (result.has("tool_call_id")) {
                JsonElement idElement = result.get("tool_call_id");
                if (idElement != null && !idElement.isJsonNull()) {
                    toolCallId = idElement.getAsString();
                }
            }
            
            ChatMessage toolMessage = new ChatMessage(ChatMessage.ChatMessageRole.TOOL, content);
            toolMessage.setToolCallId(toolCallId);
            conversationHistory.add(toolMessage);
        }
    }
    
    /**
     * Handle conversation end when finish_reason is "stop"
     */
    private void handleConversationEnd(JsonObject assistantMessage) {
        isConversationActive = false;
        
        try {
            // Extract and filter the final response
            String content = "";
            if (assistantMessage != null && assistantMessage.has("content")) {
                JsonElement contentElement = assistantMessage.get("content");
                if (contentElement != null && !contentElement.isJsonNull()) {
                    content = contentElement.getAsString();
                }
            }
            
            // Handle case where content is null or empty
            if (content == null || content.trim().isEmpty()) {
                content = "I'm ready to help you with this function analysis.";
                Msg.info(this, "LLM response had no content, using default message");
            }
            
            String filteredContent = responseProcessor.filterThinkBlocks(content);
            
            // Debug logging for final response
            Msg.info(this, String.format("Final LLM response: length=%d", 
                filteredContent != null ? filteredContent.length() : 0));
            if (filteredContent != null && filteredContent.length() > 0) {
                Msg.info(this, "Final response preview: " + 
                    (filteredContent.length() > 200 ? filteredContent.substring(0, 200) + "..." : filteredContent));
            }
            
            // Send only the final LLM response (tool execution messages were already sent individually)
            javax.swing.SwingUtilities.invokeLater(() -> {
                userHandler.onUpdate("\n" + filteredContent);
                userHandler.onComplete("\n" + filteredContent);
            });
            
        } catch (Exception e) {
            Msg.error(this, "Error handling conversation end: " + e.getMessage());
            // Provide fallback response
            javax.swing.SwingUtilities.invokeLater(() -> {
                userHandler.onUpdate("I encountered an error processing the response. Please try again.");
                userHandler.onComplete("Error processing response");
            });
        }
        
        // Notify completion callback
        if (onCompletionCallback != null) {
            onCompletionCallback.run();
        }
    }
    
    /**
     * Extract tool name from tool call
     */
    private String extractToolName(JsonObject toolCall) {
        if (toolCall.has("function")) {
            JsonObject function = toolCall.getAsJsonObject("function");
            if (function != null && function.has("name") && !function.get("name").isJsonNull()) {
                return function.get("name").getAsString();
            }
        } else if (toolCall.has("name") && !toolCall.get("name").isJsonNull()) {
            return toolCall.get("name").getAsString();
        }

        Msg.error(this, "No tool name found in tool call: " + toolCall.toString());
        throw new IllegalArgumentException("No tool name found in tool call: " + toolCall.toString());
    }
    
    /**
     * Extract arguments from tool call
     */
    private JsonObject extractToolArguments(JsonObject toolCall) {
        JsonObject arguments = new JsonObject();

        try {
            if (toolCall.has("function")) {
                JsonObject function = toolCall.getAsJsonObject("function");
                if (function != null && function.has("arguments") && !function.get("arguments").isJsonNull()) {
                    JsonElement argsElement = function.get("arguments");
                    if (argsElement.isJsonObject()) {
                        arguments = argsElement.getAsJsonObject();
                    } else if (argsElement.isJsonPrimitive()) {
                        // Parse string arguments
                        String argsStr = argsElement.getAsString();
                        if (argsStr != null && !argsStr.trim().isEmpty()) {
                            arguments = JsonParser.parseString(argsStr).getAsJsonObject();
                        }
                    }
                }
            } else if (toolCall.has("arguments") && !toolCall.get("arguments").isJsonNull()) {
                JsonElement argsElement = toolCall.get("arguments");
                if (argsElement.isJsonObject()) {
                    arguments = argsElement.getAsJsonObject();
                } else if (argsElement.isJsonPrimitive()) {
                    String argsStr = argsElement.getAsString();
                    if (argsStr != null && !argsStr.trim().isEmpty()) {
                        arguments = JsonParser.parseString(argsStr).getAsJsonObject();
                    }
                }
            }
        } catch (Exception e) {
            Msg.error(this, "Failed to extract arguments from tool call: " + e.getMessage());
            Msg.error(this, "Tool call JSON: " + toolCall.toString());
        }

        return arguments;
    }
    
    /**
     * Extract tool call ID from tool call
     */
    private String extractToolCallId(JsonObject toolCall) {
        if (toolCall.has("id")) {
            return toolCall.get("id").getAsString();
        }
        // Generate a fallback ID
        return "call_" + System.currentTimeMillis();
    }
    
    /**
     * Trim conversation history to prevent token overflow
     * Keeps the first message and ensures tool call/result pairs stay together
     */
    private void trimConversationHistory() {
        if (conversationHistory.size() <= MAX_CONVERSATION_HISTORY) {
            return; // No trimming needed
        }
        
        List<ChatMessage> trimmedHistory = new ArrayList<>();

        // Always keep the system message (index 0) and the first user message (original query)
        if (!conversationHistory.isEmpty()) {
            trimmedHistory.add(conversationHistory.get(0));  // System message

            // Find and keep the first USER message (the original query)
            for (int i = 1; i < conversationHistory.size(); i++) {
                ChatMessage msg = conversationHistory.get(i);
                if (ChatMessage.ChatMessageRole.USER.equals(msg.getRole())) {
                    trimmedHistory.add(msg);
                    break;  // Only keep the first user message
                }
            }
        }

        // Find a safe cutoff point that doesn't break tool call/result pairs
        int safeStartIndex = findSafeTrimPoint();
        
        // Add messages from safe point to end
        for (int i = safeStartIndex; i < conversationHistory.size(); i++) {
            trimmedHistory.add(conversationHistory.get(i));
        }
        
        // Replace conversation history
        conversationHistory.clear();
        conversationHistory.addAll(trimmedHistory);
        
        Msg.info(this, String.format("Trimmed conversation history to %d messages (safe tool-call trimming)", 
            conversationHistory.size()));
    }
    
    /**
     * Find a safe point to start trimming that doesn't break tool call/result pairs
     */
    private int findSafeTrimPoint() {
        int targetSize = MAX_CONVERSATION_HISTORY - 2; // -2 for system message + first user query we always keep
        int startFromEnd = Math.min(targetSize, conversationHistory.size() - 1);
        
        // Start from desired point and look backwards for a safe boundary
        for (int lookback = 0; lookback < startFromEnd; lookback++) {
            int candidateIndex = conversationHistory.size() - startFromEnd + lookback;
            
            // Check if this is a safe cut point (not in middle of tool call/result sequence)
            if (isSafeTrimPoint(candidateIndex)) {
                return candidateIndex;
            }
        }
        
        // Fallback: keep last half of conversation
        return Math.max(1, conversationHistory.size() / 2);
    }
    
    /**
     * Check if we can safely trim at this point without breaking tool call/result pairs
     */
    private boolean isSafeTrimPoint(int index) {
        if (index <= 0 || index >= conversationHistory.size()) {
            return false;
        }
        
        ChatMessage prevMessage = conversationHistory.get(index - 1);
        ChatMessage currentMessage = conversationHistory.get(index);
        
        // Don't trim if previous message has tool calls (next messages might be tool results)
        if (prevMessage.getToolCalls() != null && prevMessage.getToolCalls().size() > 0) {
            return false;
        }
        
        // Don't trim if current message is a tool result (it needs its tool call)
        if (ChatMessage.ChatMessageRole.TOOL.equals(currentMessage.getRole())) {
            return false;
        }
        
        return true;
    }
    
    /**
     * Format tool parameters for display in execution logs
     */
    private String formatToolParameters(JsonObject arguments) {
        if (arguments == null || arguments.size() == 0) {
            return "";
        }
        
        StringBuilder params = new StringBuilder();
        boolean first = true;
        
        for (String key : arguments.keySet()) {
            if (!first) {
                params.append(", ");
            }
            first = false;
            
            JsonElement value = arguments.get(key);
            if (value.isJsonPrimitive()) {
                String strValue = value.getAsString();
                // Add quotes around string values for clarity
                if (value.getAsJsonPrimitive().isString()) {
                    params.append("\"").append(strValue).append("\"");
                } else {
                    params.append(strValue);
                }
            } else {
                // For complex objects, just show the key
                params.append(key).append("=").append(value.toString());
            }
        }
        
        return params.toString();
    }
    
    /**
     * Execute tool with proper Ghidra transaction handling via ToolRegistry
     * Run transaction on Swing EDT to match how Actions tab works
     */
    private CompletableFuture<ToolResult> executeToolWithTransaction(String toolName, JsonObject arguments) {
        CompletableFuture<ToolResult> future = new CompletableFuture<>();

        ghidra.program.model.listing.Program program = apiClient.getPlugin().getCurrentProgram();

        if (program == null) {
            // If no program is loaded, execute without transaction
            return toolRegistry.execute(toolName, arguments);
        }

        // Execute tool call on background thread to avoid blocking EDT
        CompletableFuture.runAsync(() -> {
            // Start transaction on EDT
            final int[] transaction = new int[1];
            try {
                javax.swing.SwingUtilities.invokeAndWait(() -> {
                    transaction[0] = program.startTransaction("Tool: " + toolName);
                });
            } catch (Exception e) {
                throw new RuntimeException("Failed to start transaction", e);
            }

            // Execute tool via ToolRegistry
            toolRegistry.execute(toolName, arguments)
                .thenAccept(result -> {
                    // End transaction on EDT
                    javax.swing.SwingUtilities.invokeLater(() -> {
                        boolean success = result.isSuccess();
                        program.endTransaction(transaction[0], success);
                        future.complete(result);
                    });
                })
                .exceptionally(throwable -> {
                    // End transaction on EDT with failure
                    javax.swing.SwingUtilities.invokeLater(() -> {
                        program.endTransaction(transaction[0], false);
                        Msg.error(this, "Tool execution failed: " + throwable.getMessage());
                        future.complete(ToolResult.error("Tool execution failed: " + throwable.getMessage()));
                    });
                    return null;
                });

        }).exceptionally(throwable -> {
            Msg.error(this, "Failed to start transaction: " + throwable.getMessage());
            future.complete(ToolResult.error("Failed to start transaction: " + throwable.getMessage()));
            return null;
        });

        return future;
    }

    /**
     * Get the current conversation history.
     * Useful for persisting ReAct conversations.
     *
     * @return Copy of conversation history
     */
    public List<ChatMessage> getConversationHistory() {
        return new ArrayList<>(conversationHistory);
    }
}
```

`src/main/java/ghidrassist/core/LlmApiClient.java`:

```java
package ghidrassist.core;

import ghidrassist.AnalysisDB;
import ghidrassist.GhidrAssistPlugin;
import ghidrassist.LlmApi;
import ghidrassist.apiprovider.APIProvider;
import ghidrassist.apiprovider.APIProviderConfig;
import ghidrassist.apiprovider.ChatMessage;
import ghidrassist.apiprovider.exceptions.APIProviderException;
import ghidrassist.graphrag.GraphRAGService;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Handles API provider management and low-level API calls.
 * Focused solely on provider configuration and basic API interactions.
 */
public class LlmApiClient {
    private APIProvider provider;
    private final AnalysisDB analysisDB;
    private final GhidrAssistPlugin plugin;
    
    private final String DEFAULT_SYSTEM_PROMPT = 
            "You are a professional software reverse engineer specializing in cybersecurity. You are intimately \n"
            + "familiar with x86_64, ARM, PPC and MIPS architectures. You are an expert C and C++ developer.\n"
            + "You are an expert Python and Rust developer. You are familiar with common frameworks and libraries \n"
            + "such as WinSock, OpenSSL, MFC, etc. You are an expert in TCP/IP network programming and packet analysis.\n"
            + "You always respond to queries in a structured format using Markdown styling for headings and lists. \n"
            + "You format code blocks using back-tick code-fencing.\n";
            
    private final String FUNCTION_SYSTEM_PROMPT =
            "You are a professional software reverse engineer. "
            + "You MUST use the provided tools to gather information, then present the results clearly to the user. "
            + "If multiple suggestions are appropriate, make multiple tool calls.";

    public LlmApiClient(APIProviderConfig config, GhidrAssistPlugin plugin) {
        this.provider = config.createProvider();
        this.analysisDB = new AnalysisDB();
        this.plugin = plugin;

        // Get the global API timeout and set it if the provider doesn't have one
        if (provider != null && provider.getTimeout() == null) {
            Integer timeout = GhidrAssistPlugin.getGlobalApiTimeout();
            provider.setTimeout(timeout);
        }

        // Initialize GraphRAGService with LLM provider for background semantic analysis
        initializeGraphRAGService();
    }

    /**
     * Initialize GraphRAGService with the LLM provider.
     * This enables background semantic analysis when tools trigger on-demand indexing.
     */
    private void initializeGraphRAGService() {
        try {
            GraphRAGService graphRAG = GraphRAGService.getInstance(analysisDB);

            // Set LLM provider for background semantic analysis
            if (provider != null) {
                graphRAG.setLLMProvider(provider);
            }

            // Set current program context if available
            if (plugin != null && plugin.getCurrentProgram() != null) {
                graphRAG.setCurrentProgram(plugin.getCurrentProgram());
            }
        } catch (Exception e) {
            ghidra.util.Msg.warn(this, "Failed to initialize GraphRAGService: " + e.getMessage());
        }
    }

    public String getSystemPrompt() {
        return this.DEFAULT_SYSTEM_PROMPT;
    }

    public GhidrAssistPlugin getPlugin() {
        return plugin;
    }

    public APIProvider getProvider() {
        return provider;
    }

    public String getCurrentContext() {
        if (plugin.getCurrentProgram() != null) {
            String programHash = plugin.getCurrentProgram().getExecutableSHA256();
            String context = analysisDB.getContext(programHash);
            if (context != null) {
                return context;
            }
        }
        return DEFAULT_SYSTEM_PROMPT;
    }
    
    /**
     * Create messages for regular chat completion
     */
    public List<ChatMessage> createChatMessages(String prompt) {
        String systemUser = ChatMessage.ChatMessageRole.SYSTEM;
        if (isO1OrO3Model()) {
            systemUser = ChatMessage.ChatMessageRole.USER;
        }
        
        List<ChatMessage> messages = new ArrayList<>();
        messages.add(new ChatMessage(systemUser, getCurrentContext()));
        messages.add(new ChatMessage(ChatMessage.ChatMessageRole.USER, prompt));
        return messages;
    }
    
    /**
     * Create messages for function calling
     */
    public List<ChatMessage> createFunctionMessages(String prompt) {
        String systemRole = ChatMessage.ChatMessageRole.SYSTEM;
        if (isO1OrO3Model()) {
            systemRole = ChatMessage.ChatMessageRole.USER;
        }

        List<ChatMessage> messages = new ArrayList<>();
        messages.add(new ChatMessage(systemRole, FUNCTION_SYSTEM_PROMPT));
        messages.add(new ChatMessage(ChatMessage.ChatMessageRole.USER, prompt));
        return messages;
    }
    
    /**
     * Check if the current model is O1 or O3 series (which handle system prompts differently)
     */
    private boolean isO1OrO3Model() {
        return provider != null && (
            provider.getModel().startsWith("o1-") || 
            provider.getModel().startsWith("o3-") || 
            provider.getModel().startsWith("o4-")
        );
    }
    
    /**
     * Stream chat completion
     */
    public void streamChatCompletion(List<ChatMessage> messages, LlmApi.LlmResponseHandler handler) 
            throws APIProviderException {
        if (provider == null) {
            throw new IllegalStateException("LLM provider is not initialized.");
        }
        provider.streamChatCompletion(messages, handler);
    }
    
    /**
     * Create chat completion with functions
     */
    public String createChatCompletionWithFunctions(List<ChatMessage> messages, List<Map<String, Object>> functions) 
            throws APIProviderException {
        if (provider == null) {
            throw new IllegalStateException("LLM provider is not initialized.");
        }
        return provider.createChatCompletionWithFunctions(messages, functions);
    }
    
    /**
     * Create chat completion with functions - returns full response including finish_reason
     */
    public String createChatCompletionWithFunctionsFullResponse(List<ChatMessage> messages, List<Map<String, Object>> functions) 
            throws APIProviderException {
        if (provider == null) {
            throw new IllegalStateException("LLM provider is not initialized.");
        }
        return provider.createChatCompletionWithFunctionsFullResponse(messages, functions);
    }
    
    /**
     * Check if provider is available
     */
    public boolean isProviderAvailable() {
        return provider != null;
    }
    
    /**
     * Get provider name for logging/error handling
     */
    public String getProviderName() {
        return provider != null ? provider.getName() : "Unknown";
    }
    
    /**
     * Get provider model for logging/error handling
     */
    public String getProviderModel() {
        return provider != null ? provider.getModel() : "Unknown";
    }
}
```

`src/main/java/ghidrassist/core/LlmErrorHandler.java`:

```java
package ghidrassist.core;

import ghidra.util.Msg;
import ghidrassist.GhidrAssistPlugin;
import ghidrassist.apiprovider.APIProviderLogger;
import ghidrassist.apiprovider.ErrorAction;
import ghidrassist.apiprovider.exceptions.APIProviderException;
import ghidrassist.apiprovider.exceptions.StreamCancelledException;
import ghidrassist.ui.EnhancedErrorDialog;

import java.util.ArrayList;
import java.util.List;

/**
 * Handles error processing, logging, and user interaction for LLM operations.
 * Focused solely on error handling logic and user feedback.
 */
public class LlmErrorHandler {
    
    private final GhidrAssistPlugin plugin;
    private final Object source;
    
    public LlmErrorHandler(GhidrAssistPlugin plugin, Object source) {
        this.plugin = plugin;
        this.source = source;
    }
    
    /**
     * Handle an error with enhanced error dialogs and logging
     */
    public void handleError(Throwable error, String operation, Runnable retryAction) {
        if (error instanceof APIProviderException) {
            APIProviderException ape = (APIProviderException) error;
            
            // Log the error with structured information
            APIProviderLogger.logError(source, ape);
            
            // Skip showing error dialog for cancellations unless it's unexpected
            if (shouldSkipErrorDialog(ape)) {
                return;
            }
            
            // Create appropriate error actions
            List<ErrorAction> actions = createErrorActions(ape, retryAction);
            
            // Show enhanced error dialog
            java.awt.Window parentWindow = getParentWindow();
            EnhancedErrorDialog.showError(parentWindow, ape, actions);
            
        } else {
            // Handle non-API provider exceptions (fallback)
            handleGenericError(error, operation);
        }
    }
    
    /**
     * Handle generic (non-API provider) errors
     */
    private void handleGenericError(Throwable error, String operation) {
        String message = error.getMessage() != null ? error.getMessage() : error.getClass().getSimpleName();
        Msg.showError(source, null, "Unexpected Error", 
            "An unexpected error occurred during " + operation + ": " + message);
        
        // Log the error
        Msg.error(source, "Unexpected error during " + operation, error);
    }
    
    /**
     * Determine if error dialog should be skipped for certain cancellation types
     */
    private boolean shouldSkipErrorDialog(APIProviderException ape) {
        if (ape.getCategory() == APIProviderException.ErrorCategory.CANCELLED) {
            if (ape instanceof StreamCancelledException) {
                StreamCancelledException sce = (StreamCancelledException) ape;
                if (sce.getCancellationReason() == StreamCancelledException.CancellationReason.USER_REQUESTED) {
                    return true; // Don't show dialog for user-requested cancellations
                }
            }
        }
        return false;
    }
    
    /**
     * Create appropriate error actions based on the exception type
     */
    private List<ErrorAction> createErrorActions(APIProviderException ape, Runnable retryAction) {
        List<ErrorAction> actions = new ArrayList<>();
        
        // Add retry action for retryable errors
        if (ape.isRetryable() && retryAction != null) {
            actions.add(ErrorAction.createRetryAction(retryAction));
        }
        
        // Add settings action for configuration-related errors
        if (isConfigurationError(ape)) {
            actions.add(ErrorAction.createSettingsAction(() -> openSettings()));
        }
        
        // Add provider switching action for persistent errors
        APIProviderLogger.ErrorStats stats = APIProviderLogger.getErrorStats(ape.getProviderName());
        if (stats != null && stats.isFrequentErrorsDetected()) {
            actions.add(ErrorAction.createSwitchProviderAction(() -> suggestProviderSwitch()));
        }
        
        // Add copy error details action
        actions.add(ErrorAction.createCopyErrorAction(ape.getTechnicalDetails()));
        
        // Add dismiss action
        actions.add(ErrorAction.createDismissAction());
        
        return actions;
    }
    
    /**
     * Check if error is configuration-related
     */
    private boolean isConfigurationError(APIProviderException ape) {
        return ape.getCategory() == APIProviderException.ErrorCategory.AUTHENTICATION ||
               ape.getCategory() == APIProviderException.ErrorCategory.CONFIGURATION ||
               ape.getCategory() == APIProviderException.ErrorCategory.MODEL_ERROR;
    }
    
    /**
     * Get the parent window for error dialogs
     */
    private java.awt.Window getParentWindow() {
        try {
            // Try to get the main Ghidra window
            if (plugin != null && plugin.getTool() != null) {
                return plugin.getTool().getToolFrame();
            }
        } catch (Exception e) {
            // Ignore errors getting parent window
        }
        return null;
    }
    
    /**
     * Open the settings dialog
     */
    private void openSettings() {
        try {
            if (plugin != null) {
                // This would typically call the plugin's settings dialog
                // The actual implementation depends on how settings are accessed
                Msg.showInfo(source, null, "Settings", 
                    "Please go to Tools -> GhidrAssist Settings to configure API providers.");
            }
        } catch (Exception e) {
            Msg.showError(source, null, "Error", "Could not open settings: " + e.getMessage());
        }
    }
    
    /**
     * Suggest switching to a different provider
     */
    private void suggestProviderSwitch() {
        try {
            // Generate a simple suggestion message
            StringBuilder suggestion = new StringBuilder();
            suggestion.append("Current provider is experiencing frequent errors.\n\n");
            suggestion.append("Consider switching to a different provider in Settings.\n\n");
            suggestion.append("Provider Error Statistics:\n");
            suggestion.append(APIProviderLogger.generateDiagnosticsReport());
            
            Msg.showInfo(source, null, "Provider Reliability", suggestion.toString());
        } catch (Exception e) {
            Msg.showError(source, null, "Error", "Could not generate provider statistics: " + e.getMessage());
        }
    }
}
```

`src/main/java/ghidrassist/core/LlmTaskExecutor.java`:

```java
package ghidrassist.core;

import ghidrassist.LlmApi;
import ghidrassist.apiprovider.exceptions.APIProviderException;

import javax.swing.SwingWorker;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Handles background task execution for LLM operations.
 * Focused on managing SwingWorker tasks and request lifecycle.
 */
public class LlmTaskExecutor {
    
    private final Object streamLock = new Object();
    private volatile boolean isStreaming = false;
    private final AtomicBoolean shouldCancel = new AtomicBoolean(false);
    
    /**
     * Execute a streaming chat request in the background
     */
    public void executeStreamingRequest(
            LlmApiClient client, 
            String prompt, 
            ResponseProcessor responseProcessor,
            LlmResponseHandler responseHandler) {
        
        if (!client.isProviderAvailable()) {
            responseHandler.onError(new IllegalStateException("LLM provider is not initialized."));
            return;
        }

        // Cancel any existing stream
        cancelCurrentRequest();
        shouldCancel.set(false);

        try {
            synchronized (streamLock) {
                isStreaming = true;
                ResponseProcessor.StreamingResponseFilter filter = responseProcessor.createStreamingFilter();
                
                client.streamChatCompletion(client.createChatMessages(prompt), new LlmApi.LlmResponseHandler() {
                    private boolean isFirst = true;

                    @Override
                    public void onStart() {
                        if (isFirst && shouldCancel.get() == false) {
                            responseHandler.onStart();
                            isFirst = false;
                        }
                    }

                    @Override
                    public void onUpdate(String partialResponse) {
                        if (shouldCancel.get()) {
                            return;
                        }
                        String filteredContent = filter.processChunk(partialResponse);
                        if (filteredContent != null && !filteredContent.isEmpty()) {
                            responseHandler.onUpdate(filteredContent);
                        }
                    }

                    @Override
                    public void onComplete(String fullResponse) {
                        synchronized (streamLock) {
                            isStreaming = false;
                        }
                        if (!shouldCancel.get()) {
                            responseHandler.onComplete(filter.getFilteredContent());
                        }
                    }

                    @Override
                    public void onError(Throwable error) {
                        synchronized (streamLock) {
                            isStreaming = false;
                        }
                        if (!shouldCancel.get()) {
                            responseHandler.onError(error);
                        }
                    }

                    @Override
                    public boolean shouldContinue() {
                        return !shouldCancel.get() && responseHandler.shouldContinue();
                    }
                });
            }
        } catch (Exception e) {
            synchronized (streamLock) {
                isStreaming = false;
            }
            if (!shouldCancel.get()) {
                responseHandler.onError(e);
            }
        }
    }
    
    /**
     * Execute a function calling request in the background
     */
    public void executeFunctionRequest(
            LlmApiClient client,
            String prompt,
            List<Map<String, Object>> functions,
            ResponseProcessor responseProcessor,
            LlmResponseHandler responseHandler) {
        
        if (!client.isProviderAvailable()) {
            responseHandler.onError(new IllegalStateException("LLM provider is not initialized."));
            return;
        }

        shouldCancel.set(false);

        // Create a background task
        SwingWorker<Void, String> worker = new SwingWorker<>() {
            @Override
            protected Void doInBackground() {
                try {
                    synchronized (streamLock) {
                        isStreaming = true;
                    }
                    
                    if (!shouldCancel.get()) {
                        responseHandler.onStart();
                        String response = client.createChatCompletionWithFunctions(
                            client.createFunctionMessages(prompt), functions);
                        
                        if (!shouldCancel.get() && responseHandler.shouldContinue()) {
                            String filteredResponse = responseProcessor.filterThinkBlocks(response);
                            responseHandler.onComplete(filteredResponse);
                        }
                    }
                } catch (APIProviderException e) {
                    if (!shouldCancel.get() && responseHandler.shouldContinue()) {
                        responseHandler.onError(e);
                    }
                } finally {
                    synchronized (streamLock) {
                        isStreaming = false;
                    }
                }
                return null;
            }

            @Override
            protected void done() {
                try {
                    get(); // Check for exceptions
                } catch (Exception e) {
                    if (!shouldCancel.get() && responseHandler.shouldContinue()) {
                        responseHandler.onError(e);
                    }
                }
            }
        };

        worker.execute();
    }
    
    /**
     * Cancel the current request
     */
    public void cancelCurrentRequest() {
        shouldCancel.set(true);
        synchronized (streamLock) {
            isStreaming = false;
        }
    }
    
    /**
     * Check if currently streaming
     */
    public boolean isStreaming() {
        synchronized (streamLock) {
            return isStreaming;
        }
    }
    
    /**
     * Interface for handling LLM responses
     */
    public interface LlmResponseHandler {
        void onStart();
        void onUpdate(String partialResponse);
        void onComplete(String fullResponse);
        void onError(Throwable error);
        default boolean shouldContinue() {
            return true;
        }
    }
}
```

`src/main/java/ghidrassist/core/MarkdownHelper.java`:

```java
package ghidrassist.core;

import com.vladsch.flexmark.html.HtmlRenderer;
import com.vladsch.flexmark.html2md.converter.FlexmarkHtmlConverter;
import com.vladsch.flexmark.parser.Parser;
import com.vladsch.flexmark.util.ast.Document;
import com.vladsch.flexmark.util.data.MutableDataSet;
import com.vladsch.flexmark.ext.tables.TablesExtension;
import com.vladsch.flexmark.util.misc.Extension;

import java.util.Arrays;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class MarkdownHelper {
    /**
     * Shared CSS for consistent markdown rendering in Swing JEditorPane.
     * Used for both streaming and final rendering.
     * Minimal/empty to rely on JEditorPane's clean default styling.
     */
    public static final String MARKDOWN_CSS = "";

    private final Parser parser;
    private final HtmlRenderer renderer;
    private final FlexmarkHtmlConverter htmlToMdConverter;

    public MarkdownHelper() {
        MutableDataSet options = new MutableDataSet();

        // Enable table extension for proper table rendering
        options.set(Parser.EXTENSIONS, Arrays.asList(TablesExtension.create()));

        // Configure rendering options
        options.set(HtmlRenderer.SOFT_BREAK, "<br />\n");

        this.parser = Parser.builder(options).build();
        this.renderer = HtmlRenderer.builder(options).build();
        this.htmlToMdConverter = FlexmarkHtmlConverter.builder().build();
    }
    
    /**
     * Convert Markdown text to HTML for display
     * Includes feedback buttons in the HTML output
     * 
     * @param markdown The markdown text to convert
     * @return HTML representation of the markdown
     */
    public String markdownToHtml(String markdown) {
        if (markdown == null) {
            return "";
        }
        
        Document document = parser.parse(markdown);
        String html = renderer.render(document);
        
        // Add feedback buttons (using BMP-compatible symbols for JEditorPane compatibility)
        String feedbackLinks = "<br><div style=\"text-align: center; color: grey; font-size: 18px;\">" +
            "<a href='thumbsup'>\u2714</a> | <a href='thumbsdown'>\u2716</a></div>";
            
        return "<html><head><style>" + MARKDOWN_CSS + "</style></head><body>" +
               html + feedbackLinks + "</body></html>";
    }
    
    /**
     * Convert Markdown text to HTML without adding feedback buttons
     * Used for preview or when feedback isn't needed
     *
     * @param markdown The markdown text to convert
     * @return HTML representation of the markdown
     */
    public String markdownToHtmlSimple(String markdown) {
        if (markdown == null) {
            return "";
        }

        Document document = parser.parse(markdown);
        String html = renderer.render(document);

        return "<html><head><style>" + MARKDOWN_CSS + "</style></head><body>" +
               html + "</body></html>";
    }

    /**
     * Convert Markdown text to HTML fragment without any wrapper tags.
     * Used for streaming rendering where fragments are inserted into an existing document.
     * Includes table attribute post-processing for Swing compatibility.
     *
     * @param markdown The markdown text to convert
     * @return HTML fragment without html/body wrapper tags
     */
    public String markdownToHtmlFragment(String markdown) {
        if (markdown == null || markdown.isEmpty()) {
            return "";
        }

        Document document = parser.parse(markdown);
        String html = renderer.render(document);

        // Post-process: add HTML attributes for table rendering in Swing
        // (Swing's HTMLDocument doesn't support CSS border on td/th,
        //  but does support border/cellpadding/cellspacing attributes)
        html = html.replace("<table>", "<table border=\"1\" cellpadding=\"4\" cellspacing=\"0\">");

        return html;
    }

    /**
     * Convert plain text to HTML without markdown parsing.
     * PERFORMANCE OPTIMIZATION: Used during streaming for better responsiveness.
     * Full markdown rendering happens at completion.
     *
     * @param plainText The plain text to convert
     * @return HTML representation with proper escaping
     */
    public String plainTextToHtml(String plainText) {
        if (plainText == null || plainText.isEmpty()) {
            return "<html><body></body></html>";
        }

        // Escape HTML entities to prevent rendering issues
        String escaped = plainText
            .replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace("\"", "&quot;")
            .replace("\n", "<br>");

        // Wrap in HTML structure with monospace font for readability
        StringBuilder html = new StringBuilder();
        html.append("<html><body>");
        html.append("<div style='font-family: monospace; padding: 10px; white-space: pre-wrap;'>");
        html.append(escaped);
        html.append("</div>");
        html.append("</body></html>");

        return html.toString();
    }

    /**
     * Convert HTML to Markdown
     * 
     * @param html The HTML to convert
     * @return Markdown representation of the HTML
     */
    public String htmlToMarkdown(String html) {
        if (html == null || html.isEmpty()) {
            return "";
        }
        
        // Remove feedback buttons if present
        html = removeFeedbackButtons(html);
        
        // Remove html wrapper tags if present
        html = removeHtmlWrapperTags(html);
        
        // Use flexmark converter for the HTML to Markdown conversion
        return htmlToMdConverter.convert(html);
    }
    
    /**
     * Extract markdown from a response that might be in various formats
     * 
     * @param response The response to extract markdown from
     * @return Extracted markdown content
     */
    public String extractMarkdownFromLlmResponse(String response) {
        if (response == null || response.isEmpty()) {
            return "";
        }
        
        // Check if it's HTML
        if (response.toLowerCase().contains("<html>") || response.toLowerCase().contains("<body>")) {
            return htmlToMarkdown(response);
        }
        
        // Otherwise, assume it's already markdown or plain text
        return response;
    }
    
    /**
     * Remove feedback buttons from HTML string
     */
    private String removeFeedbackButtons(String html) {
        // Pattern to match the feedback buttons div
        Pattern feedbackPattern = Pattern.compile("<br><div style=\"text-align: center; color: grey; font-size: 18px;\">.*?</div>");
        Matcher matcher = feedbackPattern.matcher(html);
        return matcher.replaceAll("");
    }
    
    /**
     * Remove HTML and BODY wrapper tags
     */
    private String removeHtmlWrapperTags(String html) {
        return html.replaceAll("(?i)<html>|</html>|<body>|</body>", "");
    }
}
```

`src/main/java/ghidrassist/core/OperationStateManager.java`:

```java
package ghidrassist.core;

import ghidra.util.Msg;
import ghidrassist.LlmApi;
import ghidrassist.agent.react.ReActOrchestrator;
import ghidrassist.services.ActionAnalysisService;
import ghidrassist.ui.tabs.ActionsTab;
import ghidrassist.ui.tabs.ExplainTab;
import ghidrassist.ui.tabs.QueryTab;

import javax.swing.*;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Manages operation state and cancellation for LLM interactions.
 * Handles UI state transitions and safety timeouts.
 *
 * Extracted from TabController as part of decomposition refactoring.
 */
public class OperationStateManager {

    // UI state flags - volatile for thread safety
    private volatile boolean isQueryRunning = false;
    private volatile boolean isLineQueryRunning = false;
    private volatile boolean isCancelling = false;

    // Current operation references
    private volatile LlmApi currentLlmApi;
    private volatile LlmApi currentLineExplainLlmApi;
    private volatile ReActOrchestrator currentOrchestrator;

    // Safety scheduler for timeout-based reset
    private final ScheduledExecutorService safetyScheduler = Executors.newSingleThreadScheduledExecutor();

    // Tab references for UI updates
    private ExplainTab explainTab;
    private QueryTab queryTab;
    private ActionsTab actionsTab;

    // External services
    private ActionAnalysisService actionAnalysisService;
    private StreamingResponseManager streamingManager;

    // ==== Configuration ====

    public void setExplainTab(ExplainTab tab) {
        this.explainTab = tab;
    }

    public void setQueryTab(QueryTab tab) {
        this.queryTab = tab;
    }

    public void setActionsTab(ActionsTab tab) {
        this.actionsTab = tab;
    }

    public void setActionAnalysisService(ActionAnalysisService service) {
        this.actionAnalysisService = service;
    }

    public void setStreamingManager(StreamingResponseManager manager) {
        this.streamingManager = manager;
    }

    // ==== State Accessors ====

    public boolean isQueryRunning() {
        return isQueryRunning;
    }

    public void setQueryRunning(boolean running) {
        this.isQueryRunning = running;
    }

    public boolean isLineQueryRunning() {
        return isLineQueryRunning;
    }

    public void setLineQueryRunning(boolean running) {
        this.isLineQueryRunning = running;
    }

    public boolean isCancelling() {
        return isCancelling;
    }

    // ==== LLM API Management ====

    public LlmApi getCurrentLlmApi() {
        return currentLlmApi;
    }

    public void setCurrentLlmApi(LlmApi api) {
        this.currentLlmApi = api;
    }

    public LlmApi getCurrentLineExplainLlmApi() {
        return currentLineExplainLlmApi;
    }

    public void setCurrentLineExplainLlmApi(LlmApi api) {
        this.currentLineExplainLlmApi = api;
    }

    public ReActOrchestrator getCurrentOrchestrator() {
        return currentOrchestrator;
    }

    public void setCurrentOrchestrator(ReActOrchestrator orchestrator) {
        this.currentOrchestrator = orchestrator;
    }

    // ==== Cancellation Operations ====

    /**
     * Cancel the current main operation (query, explain, agentic analysis).
     * Cleans up streaming renderers and schedules safety timeout.
     */
    public void cancelCurrentOperation() {
        // Mark that we're cancelling to prevent concurrent operations
        isCancelling = true;

        // Clean up streaming renderers FIRST to stop stale UI updates
        if (streamingManager != null) {
            streamingManager.cancelAllRenderers();
        }

        // Cancel the ReAct orchestrator if it exists
        if (currentOrchestrator != null) {
            currentOrchestrator.cancel();
            // Don't set to null here - let the completion handler do it
        }

        // Cancel the current LLM API instance if it exists
        if (currentLlmApi != null) {
            currentLlmApi.cancelCurrentRequest();
            // Don't set to null here - let the completion handler do it
        }

        // Cancel action analysis if running
        if (actionAnalysisService != null) {
            actionAnalysisService.cancelAnalysis();
        }

        // Update button text immediately to show cancellation is in progress
        SwingUtilities.invokeLater(() -> {
            if (queryTab != null) {
                queryTab.setSubmitButtonText("Cancelling...");
            }
        });

        // Schedule a safety reset in case the completion handlers don't fire
        scheduleSafetyReset();
    }

    /**
     * Cancel the current line explanation operation.
     */
    public void cancelLineExplainOperation() {
        if (currentLineExplainLlmApi != null) {
            currentLineExplainLlmApi.cancelCurrentRequest();
            currentLineExplainLlmApi = null;
        }

        // Clean up line explanation streaming renderer
        if (streamingManager != null) {
            streamingManager.setCurrentLineExplainStreamingRenderer(null);
        }

        setLineExplainUIState(false, "Explain Line");
    }

    /**
     * Schedule a safety reset in case completion handlers don't fire.
     * Prevents the UI from getting stuck.
     */
    private void scheduleSafetyReset() {
        safetyScheduler.schedule(() -> {
            if (isCancelling) {
                Msg.warn(this, "Cancellation safety timeout - forcing UI reset");
                SwingUtilities.invokeLater(() -> {
                    forceReset();
                });
            }
        }, 5, TimeUnit.SECONDS);
    }

    /**
     * Force reset all state. Used by safety timeout.
     */
    private void forceReset() {
        isCancelling = false;
        isQueryRunning = false;
        currentOrchestrator = null;
        currentLlmApi = null;

        if (streamingManager != null) {
            streamingManager.cancelAllRenderers();
        }

        setUIState(false, "Submit", null);
    }

    // ==== UI State Management ====

    /**
     * Set the main UI state (query running/not running).
     */
    public void setUIState(boolean running, String buttonText, String statusText) {
        isQueryRunning = running;
        // Reset cancellation flag when transitioning to non-running state
        if (!running) {
            isCancelling = false;
        }

        SwingUtilities.invokeLater(() -> {
            if (buttonText != null && explainTab != null) {
                explainTab.setFunctionButtonText(buttonText);
                explainTab.setLineButtonText(buttonText.equals("Stop") ? "Stop" : "Explain Line");
            }
            if (buttonText != null && queryTab != null) {
                queryTab.setSubmitButtonText(buttonText.equals("Stop") ? "Stop" : "Submit");
            }
            if (buttonText != null && actionsTab != null) {
                actionsTab.setAnalyzeFunctionButtonText(buttonText.equals("Stop") ? "Stop" : "Analyze Function");
            }
            if (statusText != null && explainTab != null) {
                explainTab.setExplanationText(statusText);
            }
        });
    }

    /**
     * Set the line explanation UI state.
     */
    public void setLineExplainUIState(boolean running, String buttonText) {
        isLineQueryRunning = running;
        SwingUtilities.invokeLater(() -> {
            if (explainTab != null) {
                explainTab.setLineButtonText(buttonText);
            }
        });
    }

    /**
     * Check if the UI should block a new operation.
     * Returns true if already running or cancelling.
     */
    public boolean shouldBlockOperation() {
        return isCancelling || isQueryRunning;
    }

    /**
     * Check if the UI should block a new line explain operation.
     */
    public boolean shouldBlockLineOperation() {
        return isLineQueryRunning;
    }

    // ==== Cleanup ====

    /**
     * Clean up resources when disposing.
     */
    public void dispose() {
        if (safetyScheduler != null) {
            safetyScheduler.shutdown();
        }
    }

    /**
     * Complete cleanup after an operation finishes.
     * Clears the LLM API reference and resets state.
     */
    public void completeOperation() {
        currentLlmApi = null;
        currentOrchestrator = null;
        setUIState(false, "Submit", null);
    }

    /**
     * Complete cleanup after a line explain operation finishes.
     */
    public void completeLineOperation() {
        currentLineExplainLlmApi = null;
        setLineExplainUIState(false, "Explain Line");
    }
}

```

`src/main/java/ghidrassist/core/QueryProcessor.java`:

```java
package ghidrassist.core;

import java.util.List;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressFactory;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.util.task.TaskMonitor;
import ghidrassist.GhidrAssistPlugin;
import ghidrassist.GhidrAssistPlugin.CodeViewType;

public class QueryProcessor {

    private static final Pattern RANGE_PATTERN = Pattern.compile("#range\\(([^,]+),\\s*([^\\)]+)\\)");
    private static final int MAX_SEARCH_RESULTS = 5;

    /**
     * Process all macros in the query and replace them with actual content.
     * @param query The original query containing macros
     * @param plugin The GhidrAssist plugin instance
     * @return Processed query with macros replaced
     */
    public static String processMacrosInQuery(String query, GhidrAssistPlugin plugin) {
        String processedQuery = query;
        
        try {
            CodeViewType viewType = plugin.checkLastActiveCodeView();
            TaskMonitor monitor = TaskMonitor.DUMMY;

            // Process #line macro
            if (processedQuery.contains("#line")) {
                String codeLine = getCurrentLine(plugin, viewType, monitor);
                if (codeLine != null) {
                    processedQuery = processedQuery.replace("#line", codeLine);
                }
            }

            // Process #func macro
            if (processedQuery.contains("#func")) {
                String functionCode = getCurrentFunction(plugin, viewType, monitor);
                if (functionCode != null) {
                    processedQuery = processedQuery.replace("#func", functionCode);
                }
            }

            // Process #addr macro
            if (processedQuery.contains("#addr")) {
                String addressString = getCurrentAddress(plugin);
                processedQuery = processedQuery.replace("#addr", addressString);
            }

            // Process #range macros
            processedQuery = processRangeMacros(processedQuery, plugin);

        } catch (Exception e) {
            throw new RuntimeException("Failed to process macros: " + e.getMessage(), e);
        }

        return processedQuery;
    }

    /**
     * Append RAG context to the query based on similarity search.
     * @param query The original query
     * @return Query with RAG context prepended
     * @throws Exception if RAG search fails
     */
    public static String appendRAGContext(String query) throws Exception {
        List<SearchResult> results = RAGEngine.hybridSearch(query, MAX_SEARCH_RESULTS);
        if (results.isEmpty()) {
            return query;
        }

        StringBuilder contextBuilder = new StringBuilder();
        contextBuilder.append("<context>\n");
        
        for (SearchResult result : results) {
            contextBuilder.append("<result>\n");
            contextBuilder.append("</br><file>").append(result.getFilename()).append("</file>\n");
            contextBuilder.append("</br><chunkid>").append(result.getChunkId()).append("</chunkid>\n");
            contextBuilder.append("</br><score>").append(result.getScore()).append("</score>\n");
            contextBuilder.append("</br><content>\n").append(result.getSnippet()).append("\n</content>\n");
            contextBuilder.append("\n</result>\n\n");
        }
        
        contextBuilder.append("\n</context>\n");
        return contextBuilder.toString() + query;
    }

    /**
     * Get the current line based on view type.
     */
    private static String getCurrentLine(GhidrAssistPlugin plugin, CodeViewType viewType, TaskMonitor monitor) {
        Address currentAddress = plugin.getCurrentAddress();
        if (currentAddress == null) {
            return "No current address available.";
        }

        if (viewType == CodeViewType.IS_DECOMPILER) {
            return CodeUtils.getLineCode(currentAddress, monitor, plugin.getCurrentProgram());
        } else if (viewType == CodeViewType.IS_DISASSEMBLER) {
            return CodeUtils.getLineDisassembly(currentAddress, plugin.getCurrentProgram());
        }
        
        return "Unknown code view type.";
    }

    /**
     * Get the current function based on view type.
     */
    private static String getCurrentFunction(GhidrAssistPlugin plugin, CodeViewType viewType, TaskMonitor monitor) {
        Function currentFunction = plugin.getCurrentFunction();
        if (currentFunction == null) {
            return "No function at current location.";
        }

        if (viewType == CodeViewType.IS_DECOMPILER) {
            return CodeUtils.getFunctionCode(currentFunction, monitor);
        } else if (viewType == CodeViewType.IS_DISASSEMBLER) {
            return CodeUtils.getFunctionDisassembly(currentFunction);
        }
        
        return "Unknown code view type.";
    }

    /**
     * Get the current address as a string.
     */
    private static String getCurrentAddress(GhidrAssistPlugin plugin) {
        Address currentAddress = plugin.getCurrentAddress();
        return (currentAddress != null) ? currentAddress.toString() : "No address available.";
    }

    /**
     * Process all #range macros in the query.
     */
    private static String processRangeMacros(String query, GhidrAssistPlugin plugin) {
        Matcher matcher = RANGE_PATTERN.matcher(query);
        while (matcher.find()) {
            String startStr = matcher.group(1);
            String endStr = matcher.group(2);
            String rangeData = getRangeData(startStr.trim(), endStr.trim(), plugin);
            query = query.replace(matcher.group(0), rangeData);
            matcher = RANGE_PATTERN.matcher(query);
        }
        return query;
    }

    /**
     * Get the data for a specific address range.
     */
    private static String getRangeData(String startStr, String endStr, GhidrAssistPlugin plugin) {
        try {
            Program program = plugin.getCurrentProgram();
            if (program == null) {
                return "No program loaded.";
            }

            AddressFactory addressFactory = program.getAddressFactory();
            Address startAddr = addressFactory.getAddress(startStr);
            Address endAddr = addressFactory.getAddress(endStr);

            if (startAddr == null || endAddr == null) {
                return "Invalid addresses.";
            }

            // Get the bytes in the range
            long size = endAddr.getOffset() - startAddr.getOffset() + 1;
            if (size <= 0 || size > 1024) { // Limit to reasonable size
                return "Invalid range size.";
            }

            byte[] bytes = new byte[(int) size];
            program.getMemory().getBytes(startAddr, bytes);

            // Convert bytes to hex string
            StringBuilder sb = new StringBuilder();
            for (byte b : bytes) {
                sb.append(String.format("%02X ", b));
            }
            return sb.toString().trim();

        } catch (Exception e) {
            return "Failed to get range data: " + e.getMessage();
        }
    }
}

```

`src/main/java/ghidrassist/core/RAGDocumentInfo.java`:

```java
package ghidrassist.core;

/**
 * Information about an indexed RAG document.
 */
public class RAGDocumentInfo {
    private String filename;
    private long sizeBytes;
    private int chunkCount;

    public RAGDocumentInfo(String filename, long sizeBytes, int chunkCount) {
        this.filename = filename;
        this.sizeBytes = sizeBytes;
        this.chunkCount = chunkCount;
    }

    public String getFilename() {
        return filename;
    }

    public long getSizeBytes() {
        return sizeBytes;
    }

    public int getChunkCount() {
        return chunkCount;
    }

    /**
     * Get formatted file size string (e.g., "5.6 KB", "1.2 MB").
     */
    public String getFormattedSize() {
        if (sizeBytes < 0) {
            return "N/A";
        }
        if (sizeBytes < 1024) {
            return sizeBytes + " B";
        } else if (sizeBytes < 1024 * 1024) {
            return String.format("%.1f KB", sizeBytes / 1024.0);
        } else if (sizeBytes < 1024 * 1024 * 1024) {
            return String.format("%.1f MB", sizeBytes / (1024.0 * 1024));
        } else {
            return String.format("%.1f GB", sizeBytes / (1024.0 * 1024 * 1024));
        }
    }
}

```

`src/main/java/ghidrassist/core/RAGEngine.java`:

```java
package ghidrassist.core;

import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.analysis.standard.StandardAnalyzer;
import org.apache.lucene.document.*;
import org.apache.lucene.index.*;
import org.apache.lucene.queryparser.classic.QueryParser;
import org.apache.lucene.search.*;
import org.apache.lucene.search.similarities.BM25Similarity;
import org.apache.lucene.store.*;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;

import ghidra.framework.preferences.Preferences;
import ghidrassist.GAUtils;
import ghidrassist.GhidrAssistPlugin;
import ghidrassist.apiprovider.APIProvider;
import ghidrassist.apiprovider.APIProviderConfig;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.stream.Collectors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

public class RAGEngine {
    private static Directory indexDirectory;
    private static Analyzer analyzer;
    private static IndexWriter indexWriter;
    private static ReentrantLock indexLock = new ReentrantLock();
    private static final int MAX_SNIPPET_LENGTH = 500;
    private static final int MAX_CACHE_SIZE = 1000; // Adjust based on your needs
    private static Cache<String, double[]> embeddingCache = CacheBuilder.newBuilder()
        .maximumSize(MAX_CACHE_SIZE)
        .expireAfterWrite(24, TimeUnit.HOURS)
        .build();

    static {
        try {
            initialize();
        } catch (IOException e) {
            throw new RuntimeException("Failed to initialize RAGEngine", e);
        }
    }

    private static void initialize() throws IOException {
        String indexPath = Preferences.getProperty("GhidrAssist.LuceneIndexPath", "");
        GAUtils.OperatingSystem os = GAUtils.OperatingSystem.detect();

        if (indexPath == null || indexPath.isEmpty()) {
            indexPath = GAUtils.getDefaultLucenePath(os);
            System.out.println("No index path specified. Using default: " + indexPath);
            Files.createDirectories(Paths.get(indexPath));
        }
        
        initializeIndex(indexPath);
    }

    private static void initializeIndex(String indexPath) throws IOException {
        Path path = Paths.get(indexPath);
        indexDirectory = FSDirectory.open(path);
        analyzer = new StandardAnalyzer();
        IndexWriterConfig config = new IndexWriterConfig(analyzer);
        indexWriter = new IndexWriter(indexDirectory, config);

        // Load persisted embeddings into cache
        loadEmbeddingsFromIndex();
    }

    /**
     * Load embeddings from Lucene index into memory cache.
     * Called during initialization to restore embeddings after restart.
     */
    private static void loadEmbeddingsFromIndex() throws IOException {
        indexLock.lock();
        try (DirectoryReader reader = DirectoryReader.open(indexWriter)) {
            StoredFields storedFields = reader.storedFields();
            for (int i = 0; i < reader.maxDoc(); i++) {
                Document doc = storedFields.document(i);
                String filename = doc.get("filename");
                IndexableField chunkIdField = doc.getField("chunk_id");
                String embeddingStr = doc.get("embedding");

                if (filename != null && chunkIdField != null && embeddingStr != null && !embeddingStr.isEmpty()) {
                    int chunkId = chunkIdField.numericValue().intValue();
                    double[] embedding = deserializeEmbedding(embeddingStr);
                    if (embedding != null) {
                        String chunkKey = filename + "_" + chunkId;
                        embeddingCache.put(chunkKey, embedding);
                    }
                }
            }
            System.out.println("Loaded " + embeddingCache.size() + " embeddings from index");
        } finally {
            indexLock.unlock();
        }
    }

    /**
     * Serialize embedding array to string for storage.
     */
    private static String serializeEmbedding(double[] embedding) {
        if (embedding == null || embedding.length == 0) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < embedding.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(embedding[i]);
        }
        return sb.toString();
    }

    /**
     * Deserialize embedding string back to array.
     */
    private static double[] deserializeEmbedding(String str) {
        if (str == null || str.isEmpty()) {
            return null;
        }
        String[] parts = str.split(",");
        double[] embedding = new double[parts.length];
        for (int i = 0; i < parts.length; i++) {
            embedding[i] = Double.parseDouble(parts[i]);
        }
        return embedding;
    }

    private static APIProvider getProvider() {
        APIProviderConfig config = GhidrAssistPlugin.getCurrentProviderConfig();
        if (config == null) {
            throw new RuntimeException("No API provider configured");
        }
        return config.createProvider();
    }

    public static void ingestDocuments(List<File> files) throws IOException {
        APIProvider provider = getProvider();

        indexLock.lock();
        try {
            for (File file : files) {
                String content = readFileContent(file);
                if (content != null && !content.isEmpty()) {
                    List<String> chunks = chunkContent(content);
                    long fileSize = file.length();  // Store original file size

                    for (int i = 0; i < chunks.size(); i++) {
                        String chunk = chunks.get(i);

                        // Generate embedding synchronously
                        double[] embedding = null;
                        try {
                            embedding = provider.getEmbeddings(chunk);
                        } catch (Exception e) {
                            System.err.println("Warning: Failed to generate embedding for chunk " + i + ": " + e.getMessage());
                        }

                        // Create document with all fields including embedding
                        Document doc = new Document();
                        doc.add(new StringField("filename", file.getName(), Field.Store.YES));
                        doc.add(new IntPoint("chunk_id", i));
                        doc.add(new StoredField("chunk_id", i));
                        doc.add(new StoredField("file_size", fileSize));
                        doc.add(new TextField("content", chunk, Field.Store.YES));

                        // Store embedding as serialized string (persists to disk)
                        if (embedding != null) {
                            String embeddingStr = serializeEmbedding(embedding);
                            doc.add(new StoredField("embedding", embeddingStr));

                            // Also add to cache for immediate use
                            String chunkKey = file.getName() + "_" + i;
                            embeddingCache.put(chunkKey, embedding);
                        }

                        indexWriter.addDocument(doc);
                    }
                }
            }

            indexWriter.commit();
        } finally {
            indexLock.unlock();
        }
    }

    public static List<SearchResult> hybridSearch(String queryStr, int maxResults) throws Exception {
        List<SearchResult> results = new ArrayList<>();
        APIProvider provider = getProvider();

        // Step 1: Generate embedding for the query
        double[] queryEmbedding = provider.getEmbeddings(queryStr);

        // Step 2: Retrieve the closest vector matches
        List<VectorSearchResult> vectorResults = searchSimilar(queryEmbedding, maxResults);

        // Step 3: Run BM25-based keyword search using Lucene
        List<SearchResult> keywordResults = search(queryStr, maxResults);

        // Step 4: Combine both result sets
        results.addAll(vectorResults.stream()
            .map(vr -> new SearchResult(vr.getFilename(), vr.getSnippet(), vr.getScore(), vr.getChunkId()))
            .collect(Collectors.toList()));
        results.addAll(keywordResults);

        // Sort by score and limit results
        return results.stream()
            .sorted((a, b) -> Double.compare(b.getScore(), a.getScore()))
            .limit(maxResults)
            .collect(Collectors.toList());
    }

    private static final double SEMANTIC_MIN_THRESHOLD = 0.50;  // Low floor - just filter noise
    private static final double SEMANTIC_RELATIVE_THRESHOLD = 0.95;  // Must be within 95% of top score
    private static final int SEMANTIC_MAX_RESULTS = 5;  // Hard limit on semantic results

    private static List<VectorSearchResult> searchSimilar(double[] queryEmbedding, int maxResults) {
        // First pass: collect all candidates above minimum threshold, sorted by score
        List<VectorSearchResult> candidates = embeddingCache.asMap().entrySet().stream()
            .map(entry -> {
                String key = entry.getKey();
                double[] embedding = entry.getValue();
                double similarity = cosineSimilarity(queryEmbedding, embedding);

                String[] keyParts = key.split("_");
                String filename = keyParts[0];
                int chunkId = Integer.parseInt(keyParts[1]);

                try {
                    String snippet = getSnippetFromIndex(filename, chunkId);
                    return new VectorSearchResult(filename, snippet, similarity, chunkId);
                } catch (IOException e) {
                    return null;
                }
            })
            .filter(result -> result != null && result.getScore() >= SEMANTIC_MIN_THRESHOLD)
            .sorted((a, b) -> Double.compare(b.getScore(), a.getScore()))
            .collect(Collectors.toList());

        if (candidates.isEmpty()) {
            return candidates;
        }

        // Apply relative threshold: only keep results within 95% of top score
        double topScore = candidates.get(0).getScore();
        double relativeThreshold = topScore * SEMANTIC_RELATIVE_THRESHOLD;

        int limit = Math.min(maxResults, SEMANTIC_MAX_RESULTS);
        return candidates.stream()
            .filter(result -> result.getScore() >= relativeThreshold)
            .limit(limit)
            .collect(Collectors.toList());
    }

    private static double cosineSimilarity(double[] vecA, double[] vecB) {
        double dotProduct = 0.0;
        double normA = 0.0;
        double normB = 0.0;
        for (int i = 0; i < vecA.length; i++) {
            dotProduct += vecA[i] * vecB[i];
            normA += Math.pow(vecA[i], 2);
            normB += Math.pow(vecB[i], 2);
        }
        return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
    }

    private static String getSnippetFromIndex(String filename, int chunkId) throws IOException {
        indexLock.lock();
        try (DirectoryReader reader = DirectoryReader.open(indexWriter)) {
            IndexSearcher searcher = new IndexSearcher(reader);
            Query query = new BooleanQuery.Builder()
                    .add(new TermQuery(new Term("filename", filename)), BooleanClause.Occur.MUST)
                    .add(IntPoint.newExactQuery("chunk_id", chunkId), BooleanClause.Occur.MUST)
                    .build();

            TopDocs topDocs = searcher.search(query, 1);
            if (topDocs.totalHits.value == 0) {
                return "";
            }
            StoredFields storedFields = searcher.storedFields();
            Document doc = storedFields.document(topDocs.scoreDocs[0].doc);
            return doc.get("content");
        } finally {
            indexLock.unlock();
        }
    }

    private static List<String> chunkContent(String content) {
        List<String> chunks = new ArrayList<>();
        int start = 0;
        while (start < content.length()) {
            int end = start + 500;
            if (end >= content.length()) {
                chunks.add(content.substring(start));
                break;
            }
            int splitPos = content.indexOf("\n\n", end);
            if (splitPos == -1) {
                chunks.add(content.substring(start));
                break;
            } else {
                chunks.add(content.substring(start, splitPos + 2));
                start = splitPos + 2;
            }
        }
        return chunks;
    }

    private static String readFileContent(File file) throws IOException {
        return new String(Files.readAllBytes(file.toPath()));
    }

    public static List<SearchResult> search(String queryStr, int maxResults) throws Exception {
        List<SearchResult> results = new ArrayList<>();

        indexLock.lock();
        try (DirectoryReader reader = DirectoryReader.open(indexWriter)) {
            IndexSearcher searcher = new IndexSearcher(reader);
            searcher.setSimilarity(new BM25Similarity());

            BooleanQuery.Builder queryBuilder = new BooleanQuery.Builder();

            QueryParser contentParser = new QueryParser("content", analyzer);
            Query contentQuery = contentParser.parse(QueryParser.escape(queryStr));
            queryBuilder.add(new BoostQuery(contentQuery, 2.0f), BooleanClause.Occur.SHOULD);

            QueryParser filenameParser = new QueryParser("filename", analyzer);
            Query filenameQuery = filenameParser.parse(QueryParser.escape(queryStr));
            queryBuilder.add(filenameQuery, BooleanClause.Occur.SHOULD);

            TopDocs topDocs = searcher.search(queryBuilder.build(), maxResults * 3);

            List<ScoreDoc> scoreDocs = Arrays.asList(topDocs.scoreDocs);
            scoreDocs.sort((a, b) -> Float.compare(b.score, a.score));

            Set<String> uniqueFiles = new HashSet<>();
            for (ScoreDoc sd : scoreDocs) {
                Document doc = searcher.storedFields().document(sd.doc);
                String filename = doc.get("filename");
                String content = doc.get("content");
                int chunkId = doc.getField("chunk_id").numericValue().intValue();

                if (!uniqueFiles.contains(filename) && uniqueFiles.size() < maxResults) {
                    String snippet = generateSnippet(content, queryStr);
                    // Normalize BM25 score to 0-1 range using saturation function
                    // This aligns with cosine similarity scoring (also 0-1)
                    double normalizedScore = sd.score / (sd.score + 1.0);
                    results.add(new SearchResult(filename, snippet, normalizedScore, chunkId));
                    uniqueFiles.add(filename);
                }
            }
        } finally {
            indexLock.unlock();
        }

        return results;
    }

    public static List<String> listIndexedFiles() throws IOException {
        List<String> files = new ArrayList<>();
        indexLock.lock();
        try (DirectoryReader reader = DirectoryReader.open(indexWriter)) {
            for (int i = 0; i < reader.maxDoc(); i++) {
            	StoredFields readerStoredFields = reader.storedFields();
            	Document doc = readerStoredFields.document(i);
                String filename = doc.get("filename");
                if (!files.contains(filename)) {
                    files.add(filename);
                }
            }
        } finally {
            indexLock.unlock();
        }
        return files;
    }

    public static void deleteDocument(String filename) throws IOException {
        indexLock.lock();
        try {
            Term term = new Term("filename", filename);
            indexWriter.deleteDocuments(term);
            indexWriter.commit();
            // Also remove embeddings from cache
            embeddingCache.asMap().entrySet().removeIf(entry -> entry.getKey().startsWith(filename + "_"));
        } finally {
            indexLock.unlock();
        }
    }

    /**
     * Get the chunk count for a specific document.
     * @param filename The document filename
     * @return Number of chunks for this document
     */
    public static int getChunkCount(String filename) throws IOException {
        indexLock.lock();
        try (DirectoryReader reader = DirectoryReader.open(indexWriter)) {
            IndexSearcher searcher = new IndexSearcher(reader);
            Query query = new TermQuery(new Term("filename", filename));
            TopDocs topDocs = searcher.search(query, Integer.MAX_VALUE);
            return (int) topDocs.totalHits.value;
        } finally {
            indexLock.unlock();
        }
    }

    /**
     * Get the total chunk count across all documents.
     * @return Total number of chunks in the index
     */
    public static int getTotalChunkCount() throws IOException {
        indexLock.lock();
        try (DirectoryReader reader = DirectoryReader.open(indexWriter)) {
            return reader.numDocs();
        } finally {
            indexLock.unlock();
        }
    }

    /**
     * Get the number of cached embeddings.
     * @return Number of embeddings in cache
     */
    public static int getEmbeddingCount() {
        return (int) embeddingCache.size();
    }

    /**
     * Get the original file size for a document.
     * @param filename The document filename
     * @return File size in bytes, or -1 if not found
     */
    public static long getDocumentSize(String filename) throws IOException {
        indexLock.lock();
        try (DirectoryReader reader = DirectoryReader.open(indexWriter)) {
            IndexSearcher searcher = new IndexSearcher(reader);
            Query query = new TermQuery(new Term("filename", filename));
            TopDocs topDocs = searcher.search(query, 1);
            if (topDocs.totalHits.value > 0) {
                Document doc = searcher.storedFields().document(topDocs.scoreDocs[0].doc);
                IndexableField sizeField = doc.getField("file_size");
                if (sizeField != null) {
                    return sizeField.numericValue().longValue();
                }
            }
            return -1; // Not found or no size stored (legacy documents)
        } finally {
            indexLock.unlock();
        }
    }

    /**
     * Perform semantic (vector) search using embeddings.
     * @param queryStr The search query
     * @param maxResults Maximum number of results
     * @return List of search results
     */
    public static List<SearchResult> semanticSearch(String queryStr, int maxResults) throws Exception {
        APIProvider provider = getProvider();
        double[] queryEmbedding = provider.getEmbeddings(queryStr);
        List<VectorSearchResult> vectorResults = searchSimilar(queryEmbedding, maxResults);
        return vectorResults.stream()
            .map(vr -> new SearchResult(vr.getFilename(), vr.getSnippet(), vr.getScore(), vr.getChunkId()))
            .collect(Collectors.toList());
    }

    /**
     * Clear the entire index and embedding cache.
     */
    public static void clearIndex() throws IOException {
        indexLock.lock();
        try {
            indexWriter.deleteAll();
            indexWriter.commit();
            embeddingCache.invalidateAll();
        } finally {
            indexLock.unlock();
        }
    }

    private static String generateSnippet(String content, String query) {
        String[] queryTerms = query.toLowerCase().split("\s+");
        int bestPosition = content.length();
        for (String term : queryTerms) {
            int pos = content.toLowerCase().indexOf(term);
            if (pos != -1 && pos < bestPosition) {
                bestPosition = pos;
            }
        }

        int start = Math.max(0, bestPosition - MAX_SNIPPET_LENGTH / 2);
        int end = Math.min(content.length(), start + MAX_SNIPPET_LENGTH);
        String snippet = content.substring(start, end);

        if (start > 0) snippet = "..." + snippet;
        if (end < content.length()) snippet = snippet + "...";

        return snippet;
    }
}

class EmbeddingData {
    private double[] embedding;
    private String provider;

    public EmbeddingData(double[] embedding, String provider) {
        this.embedding = embedding;
        this.provider = provider;
    }

    public double[] getEmbedding() {
        return embedding;
    }

    public String getProvider() {
        return provider;
    }
}

class VectorSearchResult {
    private String filename;
    private String snippet;
    private double score;
    private int chunkId;

    public VectorSearchResult(String filename, String snippet, double score, int chunkId) {
        this.filename = filename;
        this.snippet = snippet;
        this.score = score;
        this.chunkId = chunkId;
    }

    public String getFilename() { return filename; }
    public String getSnippet() { return snippet; }
    public double getScore() { return score; }
    public int getChunkId() { return chunkId; }
}

```

`src/main/java/ghidrassist/core/ResponseProcessor.java`:

```java
package ghidrassist.core;

import java.util.regex.Pattern;

/**
 * Handles response processing including streaming filters and thinking block removal.
 * Focused solely on text processing and filtering logic.
 */
public class ResponseProcessor {

    // Pattern for matching complete <think> blocks and opening/closing tags
    private static final Pattern COMPLETE_THINK_PATTERN = Pattern.compile("<think>.*?</think>", Pattern.DOTALL);

    // Storage for thinking content (for potential future display)
    private volatile String lastThinkingContent;
    private final StringBuilder thinkingBuffer = new StringBuilder();
    
    /**
     * Create a new streaming filter for processing chunks
     */
    public StreamingResponseFilter createStreamingFilter() {
        return new StreamingResponseFilter();
    }
    
    /**
     * Filter thinking blocks from a complete response
     */
    public String filterThinkBlocks(String response) {
        if (response == null) {
            return null;
        }
        return COMPLETE_THINK_PATTERN.matcher(response).replaceAll("").trim();
    }

    /**
     * Store thinking content from an LLM response.
     * This is used to capture thinking from structured API responses (like Anthropic's thinking blocks).
     */
    public void storeThinkingContent(String thinking) {
        if (thinking != null && !thinking.isEmpty()) {
            synchronized (thinkingBuffer) {
                thinkingBuffer.append(thinking);
                lastThinkingContent = thinkingBuffer.toString();
            }
        }
    }

    /**
     * Get the last stored thinking content.
     * Returns null if no thinking content has been stored.
     */
    public String getLastThinkingContent() {
        return lastThinkingContent;
    }

    /**
     * Clear the stored thinking content.
     * Called when starting a new query to reset state.
     */
    public void clearThinkingContent() {
        synchronized (thinkingBuffer) {
            thinkingBuffer.setLength(0);
            lastThinkingContent = null;
        }
    }

    /**
     * Streaming filter that processes chunks of text and removes thinking blocks in real-time
     */
    public static class StreamingResponseFilter {
        private StringBuilder buffer = new StringBuilder();
        private StringBuilder visibleBuffer = new StringBuilder();
        private boolean insideThinkBlock = false;
        
        /**
         * Process a chunk of streaming text, filtering out thinking blocks
         * @param chunk The text chunk to process
         * @return The filtered content that should be displayed, or null if nothing to display
         */
        public String processChunk(String chunk) {
            if (chunk == null) {
                return null;
            }
            
            buffer.append(chunk);
            
            // Process the buffer until we can't anymore
            String currentBuffer = buffer.toString();
            int lastSafeIndex = 0;
            
            for (int i = 0; i < currentBuffer.length(); i++) {
                // Look for start tag
                if (!insideThinkBlock && currentBuffer.startsWith("<think>", i)) {
                    // Append everything up to this point to visible buffer
                    visibleBuffer.append(currentBuffer.substring(lastSafeIndex, i));
                    insideThinkBlock = true;
                    lastSafeIndex = i + 7; // Skip "<think>"
                    i += 6; // Move past "<think>"
                }
                // Look for end tag
                else if (insideThinkBlock && currentBuffer.startsWith("</think>", i)) {
                    insideThinkBlock = false;
                    lastSafeIndex = i + 8; // Skip "</think>"
                    i += 7; // Move past "</think>"
                }
            }
            
            // If we're not in a think block, append any remaining safe content
            if (!insideThinkBlock) {
                visibleBuffer.append(currentBuffer.substring(lastSafeIndex));
                // Clear processed content from buffer
                buffer.setLength(0);
            } else {
                // Keep everything from lastSafeIndex in buffer
                buffer = new StringBuilder(currentBuffer.substring(lastSafeIndex));
            }
            
            return visibleBuffer.toString();
        }
        
        /**
         * Get the complete filtered content processed so far
         */
        public String getFilteredContent() {
            return visibleBuffer.toString();
        }
        
        /**
         * Reset the filter state for reuse
         */
        public void reset() {
            buffer.setLength(0);
            visibleBuffer.setLength(0);
            insideThinkBlock = false;
        }
        
        /**
         * Check if currently inside a thinking block
         */
        public boolean isInsideThinkBlock() {
            return insideThinkBlock;
        }
    }
}
```

`src/main/java/ghidrassist/core/SearchResult.java`:

```java
package ghidrassist.core;

/**
 * Search result from RAG queries.
 */
public class SearchResult {
    private String filename;
    private String snippet;
    private double score;
    private int chunkId;

    public SearchResult(String filename, String snippet, double score, int chunkId) {
        this.filename = filename;
        this.snippet = snippet;
        this.score = score;
        this.chunkId = chunkId;
    }

    public String getFilename() { return filename; }
    public String getSnippet() { return snippet; }
    public double getScore() { return score; }
    public int getChunkId() { return chunkId; }
}

```

`src/main/java/ghidrassist/core/SemanticGraphController.java`:

```java
package ghidrassist.core;

import ghidra.app.services.GoToService;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Function;
import ghidra.util.Msg;
import ghidra.util.task.Task;
import ghidra.util.task.TaskLauncher;
import ghidra.util.task.TaskMonitor;
import ghidrassist.AnalysisDB;
import ghidrassist.GhidrAssistPlugin;
import ghidrassist.graphrag.BinaryKnowledgeGraph;
import ghidrassist.graphrag.nodes.EdgeType;
import ghidrassist.graphrag.nodes.KnowledgeNode;
import ghidrassist.ui.tabs.SemanticGraphTab;
import ghidrassist.ui.tabs.semanticgraph.GraphViewPanel;
import ghidrassist.ui.tabs.semanticgraph.ListViewPanel;
import ghidrassist.workers.*;

import javax.swing.*;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Controller for Semantic Graph operations.
 * Handles indexing, analysis, navigation, and visualization of the knowledge graph.
 *
 * Extracted from TabController as part of decomposition refactoring.
 */
public class SemanticGraphController {

    private final GhidrAssistPlugin plugin;
    private final AnalysisDB analysisDB;
    private SemanticGraphTab semanticGraphTab;

    // Background workers for non-blocking analysis
    private volatile ReindexWorker reindexWorker;
    private volatile SemanticAnalysisWorker semanticAnalysisWorker;
    private volatile SecurityAnalysisWorker securityAnalysisWorker;
    private volatile RefreshNamesWorker refreshNamesWorker;
    private volatile NetworkFlowAnalysisWorker networkFlowWorker;
    private volatile CommunityDetectionWorker communityDetectionWorker;

    public SemanticGraphController(GhidrAssistPlugin plugin, AnalysisDB analysisDB) {
        this.plugin = plugin;
        this.analysisDB = analysisDB;
    }

    // ==== Tab Registration ====

    public void setSemanticGraphTab(SemanticGraphTab tab) {
        this.semanticGraphTab = tab;
    }

    // ==== Navigation Operations ====

    /**
     * Handle navigation to a function/address in the semantic graph tab.
     */
    public void handleGo(String text) {
        if (plugin.getCurrentProgram() == null) {
            return;
        }

        try {
            // Try to parse as address
            long address = 0;
            text = text.trim();
            if (text.startsWith("0x") || text.startsWith("0X")) {
                address = Long.parseLong(text.substring(2), 16);
            } else if (text.matches("[0-9a-fA-F]+")) {
                address = Long.parseLong(text, 16);
            } else {
                // Try to find function by name
                ghidra.program.model.listing.FunctionManager fm = plugin.getCurrentProgram().getFunctionManager();
                for (Function func : fm.getFunctions(true)) {
                    if (func.getName().equalsIgnoreCase(text) ||
                        text.contains(func.getName())) {
                        address = func.getEntryPoint().getOffset();
                        break;
                    }
                }
            }

            if (address != 0) {
                Address addr = plugin.getCurrentProgram().getAddressFactory()
                        .getDefaultAddressSpace().getAddress(address);
                navigateToAddress(addr);
            }
        } catch (NumberFormatException e) {
            Msg.showWarn(this, null, "Invalid Address", "Could not parse address: " + text);
        }
    }

    /**
     * Handle navigation to a specific address.
     */
    public void handleNavigate(long address) {
        if (plugin.getCurrentProgram() == null) {
            return;
        }

        Address addr = plugin.getCurrentProgram().getAddressFactory()
                .getDefaultAddressSpace().getAddress(address);
        navigateToAddress(addr);
    }

    /**
     * Navigate to an address using GoToService.
     */
    private void navigateToAddress(Address addr) {
        GoToService goToService = plugin.getTool().getService(GoToService.class);
        if (goToService != null) {
            goToService.goTo(addr);
        }
    }

    // ==== Graph Management Operations ====

    /**
     * Handle reset graph button.
     */
    public void handleReset() {
        if (plugin.getCurrentProgram() == null) {
            Msg.showWarn(this, null, "No Program", "No program loaded");
            return;
        }

        Task task = new Task("Reset Graph", true, true, true) {
            @Override
            public void run(TaskMonitor monitor) throws ghidra.util.exception.CancelledException {
                try {
                    ghidrassist.graphrag.GraphRAGService service =
                            ghidrassist.graphrag.GraphRAGService.getInstance(analysisDB);
                    service.clearGraph(plugin.getCurrentProgram());

                    SwingUtilities.invokeLater(() -> {
                        semanticGraphTab.refreshCurrentView();
                        semanticGraphTab.updateStats(0, 0, 0, null);
                        Msg.showInfo(this, null, "Graph Reset", "Knowledge graph has been cleared.");
                    });
                } catch (Exception e) {
                    Msg.showError(this, null, "Error", "Failed to reset graph: " + e.getMessage());
                }
            }
        };
        TaskLauncher.launch(task);
    }

    /**
     * Handle reindex button with background progress.
     * Uses SwingWorker for non-blocking operation.
     */
    public void handleReindex() {
        if (plugin.getCurrentProgram() == null) {
            Msg.showWarn(this, null, "No Program", "No program loaded");
            return;
        }

        // If already running, cancel it
        if (reindexWorker != null && !reindexWorker.isDone()) {
            reindexWorker.requestCancel();
            return;
        }

        // Create and configure the worker
        reindexWorker = new ReindexWorker(analysisDB, plugin.getCurrentProgram());

        reindexWorker.setProgressCallback(progress -> {
            semanticGraphTab.showProgress(progress.getPercentage(), progress.message);
        });

        reindexWorker.setCompletedCallback(result -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setReindexRunning(false);
            semanticGraphTab.refreshCurrentView();

            String programHash = plugin.getCurrentProgram().getExecutableSHA256();
            Long lastIndexed = analysisDB.getKnowledgeGraphLastIndexed(programHash);
            if (lastIndexed == null) {
                lastIndexed = System.currentTimeMillis();
            }
            semanticGraphTab.updateStats(
                    result.functionsExtracted,
                    result.callEdgesCreated,
                    0,
                    formatIndexedTimestamp(lastIndexed)
            );

            Msg.info(this, String.format("Structure indexing complete: %d functions, %d edges. Starting Security Analysis...",
                    result.functionsExtracted, result.callEdgesCreated));

            // Chain to Security Analysis (which will chain to Network Flow, then Community Detection)
            startSecurityAnalysisChain();
        });

        reindexWorker.setCancelledCallback(() -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setReindexRunning(false);
            semanticGraphTab.refreshCurrentView();
        });

        reindexWorker.setFailedCallback(error -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setReindexRunning(false);
            Msg.showError(this, null, "Error", "Failed to index binary: " + error);
        });

        // Start the worker
        semanticGraphTab.setReindexRunning(true);
        semanticGraphTab.showProgress(0, "Starting reindex...");
        reindexWorker.execute();
    }

    /**
     * Handle refresh names button.
     * Uses SwingWorker for non-blocking operation.
     */
    public void handleRefreshNames() {
        if (plugin.getCurrentProgram() == null) {
            return;
        }

        // If already running, cancel it
        if (refreshNamesWorker != null && !refreshNamesWorker.isDone()) {
            refreshNamesWorker.requestCancel();
            return;
        }

        // Create and configure the worker
        refreshNamesWorker = new RefreshNamesWorker(analysisDB, plugin.getCurrentProgram());

        refreshNamesWorker.setProgressCallback(progress -> {
            semanticGraphTab.showIndeterminateProgress(progress.message);
        });

        refreshNamesWorker.setCompletedCallback(result -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setRefreshNamesRunning(false);
            semanticGraphTab.refreshCurrentView();
            Msg.showInfo(this, null, "Names Refreshed", "Function names have been refreshed.");
        });

        refreshNamesWorker.setCancelledCallback(() -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setRefreshNamesRunning(false);
        });

        refreshNamesWorker.setFailedCallback(error -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setRefreshNamesRunning(false);
            Msg.showError(this, null, "Error", "Failed to refresh names: " + error);
        });

        // Start the worker
        semanticGraphTab.setRefreshNamesRunning(true);
        semanticGraphTab.showIndeterminateProgress("Refreshing function names...");
        refreshNamesWorker.execute();
    }

    // ==== Analysis Operations ====

    /**
     * Handle community detection - group related functions.
     */
    public void handleCommunityDetection() {
        if (plugin.getCurrentProgram() == null) {
            Msg.showWarn(this, null, "No Program", "No program loaded");
            return;
        }

        // If already running, cancel it
        if (communityDetectionWorker != null && !communityDetectionWorker.isDone()) {
            communityDetectionWorker.requestCancel();
            return;
        }

        // Create and configure the worker
        communityDetectionWorker = new CommunityDetectionWorker(analysisDB, plugin.getCurrentProgram());

        communityDetectionWorker.setProgressCallback(progress -> {
            semanticGraphTab.showProgress(progress.getPercentage(), progress.message);
        });

        communityDetectionWorker.setCompletedCallback(result -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setCommunityDetectionRunning(false);
            semanticGraphTab.refreshCurrentView();
            Msg.showInfo(this, null, "Community Detection Complete",
                    String.format("Detected %d communities", result.communityCount));
        });

        communityDetectionWorker.setCancelledCallback(() -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setCommunityDetectionRunning(false);
            semanticGraphTab.refreshCurrentView();
        });

        communityDetectionWorker.setFailedCallback(error -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setCommunityDetectionRunning(false);
            Msg.showError(this, null, "Error", "Failed to run community detection: " + error);
        });

        // Start the worker
        semanticGraphTab.setCommunityDetectionRunning(true);
        semanticGraphTab.showProgress(0, "Starting community detection...");
        communityDetectionWorker.execute();
    }

    /**
     * Handle semantic analysis button - LLM summarization of stale nodes.
     * Uses SwingWorker for non-blocking operation.
     */
    public void handleSemanticAnalysis() {
        if (plugin.getCurrentProgram() == null) {
            Msg.showWarn(this, null, "No Program", "No program loaded");
            return;
        }

        // If already running, cancel it
        if (semanticAnalysisWorker != null && !semanticAnalysisWorker.isDone()) {
            semanticAnalysisWorker.requestCancel();
            return;
        }

        // Create and configure the worker
        semanticAnalysisWorker = new SemanticAnalysisWorker(analysisDB, plugin.getCurrentProgram());

        semanticAnalysisWorker.setProgressCallback(progress -> {
            semanticGraphTab.showProgress(progress.getPercentage(), progress.message);
        });

        semanticAnalysisWorker.setCompletedCallback(result -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setSemanticAnalysisRunning(false);
            semanticGraphTab.refreshCurrentView();
            Msg.showInfo(this, null, "Semantic Analysis Complete",
                    String.format("Summarized %d nodes (%d errors) in %.1fs",
                            result.summarized, result.errors, result.elapsedMs / 1000.0));
        });

        semanticAnalysisWorker.setCancelledCallback(() -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setSemanticAnalysisRunning(false);
            semanticGraphTab.refreshCurrentView();
        });

        semanticAnalysisWorker.setFailedCallback(error -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setSemanticAnalysisRunning(false);
            Msg.showError(this, null, "Error", "Failed to run semantic analysis: " + error);
        });

        // Start the worker
        semanticGraphTab.setSemanticAnalysisRunning(true);
        semanticGraphTab.showProgress(0, "Starting semantic analysis...");
        semanticAnalysisWorker.execute();
    }

    /**
     * Handle security analysis button - taint analysis + VULNERABLE_VIA edges.
     * Uses SwingWorker for non-blocking operation.
     */
    public void handleSecurityAnalysis() {
        if (plugin.getCurrentProgram() == null) {
            Msg.showWarn(this, null, "No Program", "No program loaded");
            return;
        }

        // If already running, cancel it
        if (securityAnalysisWorker != null && !securityAnalysisWorker.isDone()) {
            securityAnalysisWorker.requestCancel();
            return;
        }

        // Create and configure the worker
        securityAnalysisWorker = new SecurityAnalysisWorker(analysisDB, plugin.getCurrentProgram());

        securityAnalysisWorker.setProgressCallback(progress -> {
            semanticGraphTab.showProgress(progress.getPercentage(), progress.message);
        });

        securityAnalysisWorker.setCompletedCallback(result -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setSecurityAnalysisRunning(false);
            semanticGraphTab.refreshCurrentView();
            Msg.showInfo(this, null, "Security Analysis Complete",
                    String.format("Found %d taint paths\nCreated %d VULNERABLE_VIA edges",
                            result.pathCount, result.vulnerableViaEdges));
        });

        securityAnalysisWorker.setCancelledCallback(() -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setSecurityAnalysisRunning(false);
            semanticGraphTab.refreshCurrentView();
        });

        securityAnalysisWorker.setFailedCallback(error -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setSecurityAnalysisRunning(false);
            Msg.showError(this, null, "Error", "Failed to run security analysis: " + error);
        });

        // Start the worker
        semanticGraphTab.setSecurityAnalysisRunning(true);
        semanticGraphTab.showProgress(0, "Starting security analysis...");
        securityAnalysisWorker.execute();
    }

    /**
     * Handle network flow analysis button - trace send/recv data flow paths.
     * Uses SwingWorker for non-blocking operation.
     */
    public void handleNetworkFlowAnalysis() {
        if (plugin.getCurrentProgram() == null) {
            Msg.showWarn(this, null, "No Program", "No program loaded");
            return;
        }

        // If already running, cancel it
        if (networkFlowWorker != null && !networkFlowWorker.isDone()) {
            networkFlowWorker.requestCancel();
            return;
        }

        // Create and configure the worker
        networkFlowWorker = new NetworkFlowAnalysisWorker(analysisDB, plugin.getCurrentProgram());

        networkFlowWorker.setProgressCallback(progress -> {
            semanticGraphTab.showProgress(progress.getPercentage(), progress.message);
        });

        networkFlowWorker.setCompletedCallback(result -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setNetworkFlowRunning(false);
            semanticGraphTab.refreshCurrentView();
            Msg.showInfo(this, null, "Network Flow Analysis Complete",
                    String.format("Found %d functions calling send APIs\n" +
                            "Found %d functions calling recv APIs\n" +
                            "Created %d NETWORK_SEND_PATH edges\n" +
                            "Created %d NETWORK_RECV_PATH edges",
                            result.sendFunctionsFound, result.recvFunctionsFound,
                            result.sendPathEdges, result.recvPathEdges));
        });

        networkFlowWorker.setCancelledCallback(() -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setNetworkFlowRunning(false);
            semanticGraphTab.refreshCurrentView();
        });

        networkFlowWorker.setFailedCallback(error -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setNetworkFlowRunning(false);
            Msg.showError(this, null, "Error", "Failed to run network flow analysis: " + error);
        });

        // Start the worker
        semanticGraphTab.setNetworkFlowRunning(true);
        semanticGraphTab.showProgress(0, "Starting network flow analysis...");
        networkFlowWorker.execute();
    }

    // ==== Analysis Chain Helpers (for ReIndex pipeline) ====

    /**
     * Start the Security Analysis as part of the ReIndex chain.
     * On completion, chains to Network Flow Analysis.
     */
    private void startSecurityAnalysisChain() {
        if (plugin.getCurrentProgram() == null) {
            return;
        }

        securityAnalysisWorker = new SecurityAnalysisWorker(analysisDB, plugin.getCurrentProgram());

        securityAnalysisWorker.setProgressCallback(progress -> {
            semanticGraphTab.showProgress(progress.getPercentage(), "Security: " + progress.message);
        });

        securityAnalysisWorker.setCompletedCallback(result -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setSecurityAnalysisRunning(false);
            Msg.info(this, String.format("Security Analysis complete: %d taint paths, %d VULNERABLE_VIA edges. Starting Network Flow Analysis...",
                    result.pathCount, result.vulnerableViaEdges));
            startNetworkFlowAnalysisChain();
        });

        securityAnalysisWorker.setFailedCallback(error -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setSecurityAnalysisRunning(false);
            Msg.warn(this, "Security Analysis failed: " + error + ". Continuing with Network Flow Analysis...");
            startNetworkFlowAnalysisChain();
        });

        securityAnalysisWorker.setCancelledCallback(() -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setSecurityAnalysisRunning(false);
            // Don't continue chain if cancelled
        });

        semanticGraphTab.setSecurityAnalysisRunning(true);
        securityAnalysisWorker.execute();
    }

    /**
     * Start Network Flow Analysis as part of the ReIndex chain.
     * On completion, chains to Community Detection.
     */
    private void startNetworkFlowAnalysisChain() {
        if (plugin.getCurrentProgram() == null) {
            return;
        }

        networkFlowWorker = new NetworkFlowAnalysisWorker(analysisDB, plugin.getCurrentProgram());

        networkFlowWorker.setProgressCallback(progress -> {
            semanticGraphTab.showProgress(progress.getPercentage(), "Network: " + progress.message);
        });

        networkFlowWorker.setCompletedCallback(result -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setNetworkFlowRunning(false);
            Msg.info(this, String.format("Network Flow Analysis complete: %d send edges, %d recv edges. Starting Community Detection...",
                    result.sendPathEdges, result.recvPathEdges));
            startCommunityDetectionChain();
        });

        networkFlowWorker.setFailedCallback(error -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setNetworkFlowRunning(false);
            Msg.warn(this, "Network Flow Analysis failed: " + error + ". Continuing with Community Detection...");
            startCommunityDetectionChain();
        });

        networkFlowWorker.setCancelledCallback(() -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setNetworkFlowRunning(false);
            // Don't continue chain if cancelled
        });

        semanticGraphTab.setNetworkFlowRunning(true);
        networkFlowWorker.execute();
    }

    /**
     * Start Community Detection as the final step of the ReIndex chain.
     * Shows completion dialog when done.
     */
    private void startCommunityDetectionChain() {
        if (plugin.getCurrentProgram() == null) {
            return;
        }

        communityDetectionWorker = new CommunityDetectionWorker(analysisDB, plugin.getCurrentProgram());

        communityDetectionWorker.setProgressCallback(progress -> {
            semanticGraphTab.showProgress(progress.getPercentage(), "Community: " + progress.message);
        });

        communityDetectionWorker.setCompletedCallback(result -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setCommunityDetectionRunning(false);
            semanticGraphTab.refreshCurrentView();
            Msg.showInfo(this, null, "Full Pipeline Complete",
                    String.format("ReIndex pipeline completed:\n" +
                            "• Structure extraction\n" +
                            "• Security analysis\n" +
                            "• Network flow analysis\n" +
                            "• Community detection (%d communities)", result.communityCount));
        });

        communityDetectionWorker.setFailedCallback(error -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setCommunityDetectionRunning(false);
            semanticGraphTab.refreshCurrentView();
            Msg.warn(this, "Community Detection failed: " + error);
            Msg.showInfo(this, null, "Pipeline Complete (with errors)",
                    "ReIndex pipeline completed with some errors.\nCheck console for details.");
        });

        communityDetectionWorker.setCancelledCallback(() -> {
            semanticGraphTab.hideProgress();
            semanticGraphTab.setCommunityDetectionRunning(false);
            semanticGraphTab.refreshCurrentView();
        });

        semanticGraphTab.setCommunityDetectionRunning(true);
        communityDetectionWorker.execute();
    }

    // ==== Single Function Operations ====

    /**
     * Handle index single function button.
     */
    public void handleIndexFunction(long address) {
        if (plugin.getCurrentProgram() == null) {
            return;
        }

        Task task = new Task("Index Function", true, true, true) {
            @Override
            public void run(TaskMonitor monitor) throws ghidra.util.exception.CancelledException {
                try {
                    Address addr = plugin.getCurrentProgram().getAddressFactory()
                            .getDefaultAddressSpace().getAddress(address);
                    Function function = plugin.getCurrentProgram().getFunctionManager()
                            .getFunctionContaining(addr);

                    if (function == null) {
                        Msg.showWarn(this, null, "No Function", "No function at this address");
                        return;
                    }

                    ghidrassist.graphrag.GraphRAGService service =
                            ghidrassist.graphrag.GraphRAGService.getInstance(analysisDB);
                    service.setCurrentProgram(plugin.getCurrentProgram());

                    // Index just this function
                    BinaryKnowledgeGraph graph =
                            analysisDB.getKnowledgeGraph(plugin.getCurrentProgram().getExecutableSHA256());
                    ghidrassist.graphrag.extraction.StructureExtractor extractor =
                            new ghidrassist.graphrag.extraction.StructureExtractor(
                                    plugin.getCurrentProgram(), graph, monitor);
                    try {
                        extractor.extractFunction(function);
                    } finally {
                        extractor.dispose();
                    }

                    SwingUtilities.invokeLater(() -> {
                        semanticGraphTab.refreshCurrentView();
                        Msg.showInfo(this, null, "Function Indexed",
                                "Function " + function.getName() + " has been indexed.");
                    });
                } catch (Exception e) {
                    Msg.showError(this, null, "Error", "Failed to index function: " + e.getMessage());
                }
            }
        };
        TaskLauncher.launch(task);
    }

    // ==== View Refresh Operations ====

    /**
     * Handle list view refresh.
     */
    public void handleListViewRefresh(ListViewPanel listView, long address) {
        if (plugin.getCurrentProgram() == null) {
            listView.showNotIndexed();
            return;
        }

        SwingUtilities.invokeLater(() -> {
            try {
                BinaryKnowledgeGraph graph =
                        analysisDB.getKnowledgeGraph(plugin.getCurrentProgram().getExecutableSHA256());

                KnowledgeNode node = graph.getNodeByAddress(address);

                if (node == null) {
                    listView.showNotIndexed();
                    semanticGraphTab.updateStatus(false, 0, 0, 0);
                    return;
                }

                listView.showContent();

                // Get callers and callees
                List<KnowledgeNode> callers = graph.getCallers(node.getId());
                List<KnowledgeNode> callees = graph.getCallees(node.getId());
                List<BinaryKnowledgeGraph.GraphEdge> outgoing = graph.getOutgoingEdges(node.getId());
                List<BinaryKnowledgeGraph.GraphEdge> incoming = graph.getIncomingEdges(node.getId());

                // Combine all edges
                List<BinaryKnowledgeGraph.GraphEdge> allEdges = new ArrayList<>();
                allEdges.addAll(outgoing);
                allEdges.addAll(incoming);

                listView.setCallers(callers);
                listView.setCallees(callees);
                listView.setEdges(allEdges);
                listView.setSecurityFlags(node.getSecurityFlags());
                listView.setSummary(node.getLlmSummary());

                semanticGraphTab.setCurrentNodeId(node.getId());
                semanticGraphTab.updateStatus(true, callers.size(), callees.size(),
                        node.getSecurityFlags().size());

                // Update stats
                int nodeCount = graph.getNodeCount();
                int edgeCount = graph.getEdgeCount();
                Long lastIndexed = analysisDB.getKnowledgeGraphLastIndexed(
                        plugin.getCurrentProgram().getExecutableSHA256());
                semanticGraphTab.updateStats(nodeCount, edgeCount, 0, formatIndexedTimestamp(lastIndexed));

            } catch (Exception e) {
                Msg.error(this, "Failed to refresh list view: " + e.getMessage(), e);
                listView.showNotIndexed();
            }
        });
    }

    /**
     * Handle visual graph refresh.
     */
    public void handleVisualRefresh(GraphViewPanel graphView, long address, int nHops, Set<EdgeType> edgeTypes) {
        if (plugin.getCurrentProgram() == null) {
            graphView.showNotIndexed();
            return;
        }

        SwingUtilities.invokeLater(() -> {
            try {
                BinaryKnowledgeGraph graph =
                        analysisDB.getKnowledgeGraph(plugin.getCurrentProgram().getExecutableSHA256());

                KnowledgeNode centerNode = graph.getNodeByAddress(address);

                if (centerNode == null) {
                    graphView.showNotIndexed();
                    return;
                }

                graphView.showContent();

                // Get N-hop neighborhood
                List<KnowledgeNode> neighbors = graph.getNeighborsBatch(centerNode.getId(), nHops);

                // Include center node in the list
                List<KnowledgeNode> allNodes = new ArrayList<>();
                allNodes.add(centerNode);
                allNodes.addAll(neighbors);

                // Find and add direct callers of the center node
                Set<String> existingNodeIds = new HashSet<>();
                for (KnowledgeNode node : allNodes) {
                    existingNodeIds.add(node.getId());
                }

                // Track caller nodes separately
                Set<String> callerNodeIds = new HashSet<>();
                List<BinaryKnowledgeGraph.GraphEdge> callerEdges = new ArrayList<>();

                for (BinaryKnowledgeGraph.GraphEdge edge : graph.getIncomingEdges(centerNode.getId())) {
                    if (edge.getType() == EdgeType.CALLS &&
                        !existingNodeIds.contains(edge.getSourceId())) {
                        KnowledgeNode callerNode = graph.getNode(edge.getSourceId());
                        if (callerNode != null) {
                            allNodes.add(callerNode);
                            existingNodeIds.add(callerNode.getId());
                            callerNodeIds.add(callerNode.getId());
                            callerEdges.add(edge);
                        }
                    }
                }

                // Collect all edges between non-caller nodes
                Set<String> nodeIds = new HashSet<>();
                for (KnowledgeNode node : allNodes) {
                    nodeIds.add(node.getId());
                }

                List<BinaryKnowledgeGraph.GraphEdge> allEdges = new ArrayList<>();

                // Add the caller→root edges first
                allEdges.addAll(callerEdges);

                // For non-caller nodes, collect their edges normally
                for (KnowledgeNode node : allNodes) {
                    // Skip caller nodes
                    if (callerNodeIds.contains(node.getId())) {
                        continue;
                    }
                    // Include outgoing edges
                    for (BinaryKnowledgeGraph.GraphEdge edge : graph.getOutgoingEdges(node.getId())) {
                        if (nodeIds.contains(edge.getTargetId()) && edgeTypes.contains(edge.getType())) {
                            allEdges.add(edge);
                        }
                    }
                }

                graphView.buildGraph(centerNode, allNodes, allEdges);

            } catch (Exception e) {
                Msg.error(this, "Failed to refresh visual graph: " + e.getMessage(), e);
                graphView.showNotIndexed();
            }
        });
    }

    // ==== Node Editing Operations ====

    /**
     * Handle adding a security flag.
     */
    public void handleAddFlag(long address, String flag) {
        if (plugin.getCurrentProgram() == null) {
            return;
        }

        try {
            BinaryKnowledgeGraph graph =
                    analysisDB.getKnowledgeGraph(plugin.getCurrentProgram().getExecutableSHA256());
            KnowledgeNode node = graph.getNodeByAddress(address);

            if (node != null) {
                node.addSecurityFlag(flag);
                graph.upsertNode(node);
            }
        } catch (Exception e) {
            Msg.error(this, "Failed to add security flag: " + e.getMessage(), e);
        }
    }

    /**
     * Handle removing a security flag.
     */
    public void handleRemoveFlag(long address, String flag) {
        if (plugin.getCurrentProgram() == null) {
            return;
        }

        try {
            BinaryKnowledgeGraph graph =
                    analysisDB.getKnowledgeGraph(plugin.getCurrentProgram().getExecutableSHA256());
            KnowledgeNode node = graph.getNodeByAddress(address);

            if (node != null) {
                List<String> flags = new ArrayList<>(node.getSecurityFlags());
                flags.remove(flag);
                node.setSecurityFlags(flags);
                graph.upsertNode(node);
            }
        } catch (Exception e) {
            Msg.error(this, "Failed to remove security flag: " + e.getMessage(), e);
        }
    }

    /**
     * Handle saving LLM summary.
     */
    public void handleSaveSummary(long address, String summary) {
        if (plugin.getCurrentProgram() == null) {
            return;
        }

        try {
            BinaryKnowledgeGraph graph =
                    analysisDB.getKnowledgeGraph(plugin.getCurrentProgram().getExecutableSHA256());
            KnowledgeNode node = graph.getNodeByAddress(address);

            if (node != null) {
                node.setLlmSummary(summary);
                graph.upsertNode(node);
                Msg.info(this, "Summary saved for node at 0x" + Long.toHexString(address));
            }
        } catch (Exception e) {
            Msg.error(this, "Failed to save summary: " + e.getMessage(), e);
        }
    }

    /**
     * Handle edge click in list view.
     */
    public void handleEdgeClick(String targetId) {
        if (plugin.getCurrentProgram() == null) {
            return;
        }

        try {
            BinaryKnowledgeGraph graph =
                    analysisDB.getKnowledgeGraph(plugin.getCurrentProgram().getExecutableSHA256());
            KnowledgeNode node = graph.getNode(targetId);

            if (node != null) {
                handleNavigate(node.getAddress());
            }
        } catch (Exception e) {
            Msg.error(this, "Failed to navigate to edge target: " + e.getMessage(), e);
        }
    }

    // ==== Search Query Operations ====

    /**
     * Handle semantic graph search query.
     * Executes a semantic query tool and returns the result via callback.
     *
     * @param queryType The tool name (e.g., "ga_search_semantic")
     * @param args The query arguments as JsonObject
     * @param resultCallback Callback to receive the JSON result string
     */
    public void handleSearchQuery(String queryType, com.google.gson.JsonObject args,
                                  java.util.function.Consumer<String> resultCallback) {
        if (plugin.getCurrentProgram() == null) {
            resultCallback.accept("{\"error\": \"No program loaded\"}");
            return;
        }

        Task task = new Task("Semantic Query", true, true, true) {
            @Override
            public void run(TaskMonitor monitor) throws ghidra.util.exception.CancelledException {
                try {
                    monitor.setMessage("Executing " + queryType + "...");

                    // Create query tools instance
                    ghidrassist.graphrag.query.SemanticQueryTools tools =
                            new ghidrassist.graphrag.query.SemanticQueryTools(analysisDB);
                    tools.setCurrentProgram(plugin.getCurrentProgram());

                    // Execute the query
                    ghidrassist.mcp2.tools.MCPToolResult result = tools.executeTool(queryType, args).join();

                    // Return result via callback on EDT
                    final String resultJson;
                    if (!result.isSuccess()) {
                        resultJson = "{\"error\": \"" + escapeJsonString(result.getError()) + "\"}";
                    } else {
                        resultJson = result.getContent();
                    }

                    SwingUtilities.invokeLater(() -> resultCallback.accept(resultJson));

                } catch (Exception e) {
                    Msg.error(this, "Failed to execute semantic query: " + e.getMessage(), e);
                    final String errorJson = "{\"error\": \"" + escapeJsonString(e.getMessage()) + "\"}";
                    SwingUtilities.invokeLater(() -> resultCallback.accept(errorJson));
                }
            }
        };
        TaskLauncher.launch(task);
    }

    // ==== Helper Methods ====

    private String formatIndexedTimestamp(Long epochMs) {
        if (epochMs == null || epochMs <= 0) {
            return "unknown";
        }
        DateTimeFormatter formatter =
                DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").withZone(ZoneId.systemDefault());
        return formatter.format(Instant.ofEpochMilli(epochMs));
    }

    /**
     * Escape a string for safe inclusion in JSON.
     */
    private String escapeJsonString(String input) {
        if (input == null) {
            return "";
        }
        return input
                .replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }
}

```

`src/main/java/ghidrassist/core/StreamingResponseManager.java`:

```java
package ghidrassist.core;

import ghidra.util.Msg;
import ghidrassist.LlmApi;
import ghidrassist.core.streaming.RenderUpdate;
import ghidrassist.core.streaming.StreamingMarkdownRenderer;
import ghidrassist.services.FeedbackService;
import ghidrassist.services.QueryService;
import ghidrassist.ui.tabs.ExplainTab;
import ghidrassist.ui.tabs.QueryTab;
import ghidrassist.ui.tabs.ActionsTab;

import javax.swing.*;
import java.util.function.Consumer;
import java.util.function.Supplier;

/**
 * Manages streaming response handlers and renderers for LLM interactions.
 * Provides factory methods for creating response handlers with standardized patterns.
 *
 * Extracted from TabController as part of decomposition refactoring.
 */
public class StreamingResponseManager {

    private final MarkdownHelper markdownHelper;

    // Streaming renderers - volatile for thread safety
    private volatile StreamingMarkdownRenderer currentStreamingRenderer;
    private volatile StreamingMarkdownRenderer currentExplainStreamingRenderer;
    private volatile StreamingMarkdownRenderer currentLineExplainStreamingRenderer;

    public StreamingResponseManager(MarkdownHelper markdownHelper) {
        this.markdownHelper = markdownHelper;
    }

    // ==== Renderer Access ====

    public StreamingMarkdownRenderer getCurrentStreamingRenderer() {
        return currentStreamingRenderer;
    }

    public void setCurrentStreamingRenderer(StreamingMarkdownRenderer renderer) {
        this.currentStreamingRenderer = renderer;
    }

    public StreamingMarkdownRenderer getCurrentExplainStreamingRenderer() {
        return currentExplainStreamingRenderer;
    }

    public void setCurrentExplainStreamingRenderer(StreamingMarkdownRenderer renderer) {
        this.currentExplainStreamingRenderer = renderer;
    }

    public StreamingMarkdownRenderer getCurrentLineExplainStreamingRenderer() {
        return currentLineExplainStreamingRenderer;
    }

    public void setCurrentLineExplainStreamingRenderer(StreamingMarkdownRenderer renderer) {
        this.currentLineExplainStreamingRenderer = renderer;
    }

    // ==== Cleanup ====

    /**
     * Cancel all active renderers.
     * Used during operation cancellation.
     */
    public void cancelAllRenderers() {
        currentStreamingRenderer = null;
        currentExplainStreamingRenderer = null;
        currentLineExplainStreamingRenderer = null;
    }

    /**
     * Clean up a specific renderer.
     */
    public void cleanupRenderer(StreamingMarkdownRenderer renderer) {
        if (renderer == currentStreamingRenderer) {
            currentStreamingRenderer = null;
        } else if (renderer == currentExplainStreamingRenderer) {
            currentExplainStreamingRenderer = null;
        } else if (renderer == currentLineExplainStreamingRenderer) {
            currentLineExplainStreamingRenderer = null;
        }
    }

    // ==== Handler Factory Methods ====

    /**
     * Create a conversation handler for the Query tab.
     * Handles streaming responses with conversation history prefix.
     */
    public LlmApi.LlmResponseHandler createConversationHandler(
            QueryTab queryTab,
            QueryService queryService,
            FeedbackService feedbackService,
            Supplier<Boolean> isRunning,
            Runnable onComplete,
            Consumer<LlmApi> clearLlmApi) {

        return new LlmApi.LlmResponseHandler() {
            private final StringBuilder responseBuffer = new StringBuilder();
            private final Object bufferLock = new Object();

            @Override
            public void onStart() {
                synchronized (bufferLock) {
                    responseBuffer.setLength(0);
                }

                // Render existing conversation history as prefix
                String existingHtml = markdownHelper.markdownToHtmlFragment(
                    queryService.getConversationHistory());

                // Create streaming renderer
                currentStreamingRenderer = new StreamingMarkdownRenderer(
                    update -> queryTab.applyRenderUpdate(update),
                    markdownHelper
                );
                currentStreamingRenderer.setConversationPrefix(existingHtml);

                // Initialize streaming display
                SwingUtilities.invokeLater(() -> queryTab.initializeForStreaming(existingHtml));
            }

            @Override
            public void onUpdate(String partialResponse) {
                if (partialResponse == null || partialResponse.isEmpty()) {
                    return;
                }

                String delta;
                synchronized (bufferLock) {
                    String currentBuffer = responseBuffer.toString();
                    if (partialResponse.startsWith(currentBuffer)) {
                        delta = partialResponse.substring(currentBuffer.length());
                        if (!delta.isEmpty()) {
                            responseBuffer.append(delta);
                        }
                    } else {
                        delta = partialResponse;
                        responseBuffer.append(delta);
                    }
                }

                // Send delta to streaming renderer
                if (!delta.isEmpty() && currentStreamingRenderer != null) {
                    currentStreamingRenderer.onChunkReceived(delta);
                }
            }

            @Override
            public void onComplete(String fullResponse) {
                synchronized (bufferLock) {
                    if (fullResponse != null && fullResponse.length() > responseBuffer.length()) {
                        responseBuffer.setLength(0);
                        responseBuffer.append(fullResponse);
                    }

                    final String finalResponse = responseBuffer.toString();

                    // Signal stream complete
                    if (currentStreamingRenderer != null) {
                        currentStreamingRenderer.onStreamComplete();
                        currentStreamingRenderer = null;
                    }

                    SwingUtilities.invokeLater(() -> {
                        feedbackService.cacheLastInteraction(feedbackService.getLastPrompt(), finalResponse);
                        queryService.addAssistantResponse(finalResponse);

                        // Final markdown rendering
                        String conversationHistory = queryService.getConversationHistory();
                        String html = markdownHelper.markdownToHtml(conversationHistory);
                        queryTab.setResponseText(html);
                        queryTab.setMarkdownSource(conversationHistory);

                        onComplete.run();
                        clearLlmApi.accept(null);
                    });
                }
            }

            @Override
            public void onError(Throwable error) {
                // Clean up streaming renderer
                if (currentStreamingRenderer != null) {
                    currentStreamingRenderer = null;
                }

                synchronized (bufferLock) {
                    if (responseBuffer.length() > 0) {
                        final String partialResponse = responseBuffer.toString();
                        SwingUtilities.invokeLater(() -> {
                            queryService.addAssistantMessage(partialResponse + "\n\n[Incomplete - Error occurred]",
                                queryService.getCurrentProviderType(), null);
                        });
                    }
                }

                SwingUtilities.invokeLater(() -> {
                    queryService.addError(error.getMessage());
                    String html = markdownHelper.markdownToHtml(queryService.getConversationHistory());
                    queryTab.setResponseText(html);
                    onComplete.run();
                    clearLlmApi.accept(null);
                });
            }

            @Override
            public boolean shouldContinue() {
                if (!isRunning.get()) {
                    savePartialResponseOnCancel();
                }
                return isRunning.get();
            }

            private void savePartialResponseOnCancel() {
                synchronized (bufferLock) {
                    if (responseBuffer.length() > 0) {
                        final String partialResponse = responseBuffer.toString();
                        responseBuffer.setLength(0);

                        if (currentStreamingRenderer != null) {
                            currentStreamingRenderer = null;
                        }

                        SwingUtilities.invokeLater(() -> {
                            queryService.addAssistantMessage(partialResponse + "\n\n[Cancelled by user]",
                                queryService.getCurrentProviderType(), null);

                            String html = markdownHelper.markdownToHtml(queryService.getConversationHistory());
                            queryTab.setResponseText(html);
                            onComplete.run();
                            clearLlmApi.accept(null);
                        });
                    }
                }
            }
        };
    }

    /**
     * Create a simple explain handler (non-streaming full replacement).
     */
    public LlmApi.LlmResponseHandler createExplainHandler(
            ExplainTab explainTab,
            FeedbackService feedbackService,
            Supplier<Boolean> isRunning,
            Runnable onComplete) {

        return new LlmApi.LlmResponseHandler() {
            @Override
            public void onStart() {
                SwingUtilities.invokeLater(() ->
                    explainTab.setExplanationText("Processing..."));
            }

            @Override
            public void onUpdate(String partialResponse) {
                SwingUtilities.invokeLater(() ->
                    explainTab.setExplanationText(
                        markdownHelper.markdownToHtml(partialResponse)));
            }

            @Override
            public void onComplete(String fullResponse) {
                SwingUtilities.invokeLater(() -> {
                    feedbackService.cacheLastInteraction(feedbackService.getLastPrompt(), fullResponse);
                    explainTab.setExplanationText(
                        markdownHelper.markdownToHtml(fullResponse));
                    explainTab.setMarkdownSource(fullResponse);
                    onComplete.run();
                });
            }

            @Override
            public void onError(Throwable error) {
                SwingUtilities.invokeLater(() -> {
                    explainTab.setExplanationText("An error occurred: " + error.getMessage());
                    onComplete.run();
                });
            }

            @Override
            public boolean shouldContinue() {
                return isRunning.get();
            }
        };
    }

    /**
     * Create a handler for line explanation with streaming support.
     */
    public LlmApi.LlmResponseHandler createLineExplainHandler(
            ExplainTab explainTab,
            ghidrassist.AnalysisDB analysisDB,
            String programHash,
            long functionAddress,
            long lineAddress,
            String viewType,
            String lineContent,
            String contextBefore,
            String contextAfter,
            Supplier<Boolean> isRunning,
            Runnable onComplete) {

        return new LlmApi.LlmResponseHandler() {
            private final StringBuilder responseBuffer = new StringBuilder();

            @Override
            public void onStart() {
                responseBuffer.setLength(0);

                // Initialize streaming
                currentLineExplainStreamingRenderer = new StreamingMarkdownRenderer(
                    update -> explainTab.applyLineRenderUpdate(update),
                    markdownHelper
                );

                SwingUtilities.invokeLater(() -> explainTab.initializeLineExplanationForStreaming());
            }

            @Override
            public void onUpdate(String partialResponse) {
                if (partialResponse == null || partialResponse.isEmpty()) {
                    return;
                }

                // Extract delta
                String currentBuffer = responseBuffer.toString();
                String delta;
                if (partialResponse.startsWith(currentBuffer)) {
                    delta = partialResponse.substring(currentBuffer.length());
                    responseBuffer.append(delta);
                } else {
                    delta = partialResponse;
                    responseBuffer.append(delta);
                }

                // Feed delta to renderer
                if (!delta.isEmpty() && currentLineExplainStreamingRenderer != null) {
                    currentLineExplainStreamingRenderer.onChunkReceived(delta);
                }
            }

            @Override
            public void onComplete(String fullResponse) {
                final String finalResponse = (fullResponse != null && !fullResponse.isEmpty())
                        ? fullResponse : responseBuffer.toString();

                // Complete streaming
                if (currentLineExplainStreamingRenderer != null) {
                    currentLineExplainStreamingRenderer.onStreamComplete();
                    currentLineExplainStreamingRenderer = null;
                }

                // Cache the result
                analysisDB.upsertLineExplanation(
                        programHash, functionAddress, lineAddress,
                        viewType, lineContent, contextBefore, contextAfter,
                        finalResponse
                );

                SwingUtilities.invokeLater(() -> {
                    onComplete.run();
                });
            }

            @Override
            public void onError(Throwable error) {
                if (currentLineExplainStreamingRenderer != null) {
                    currentLineExplainStreamingRenderer.onStreamComplete();
                    currentLineExplainStreamingRenderer = null;
                }

                SwingUtilities.invokeLater(() -> {
                    String partialContent = responseBuffer.toString();
                    if (!partialContent.isEmpty()) {
                        String html = markdownHelper.markdownToHtml(partialContent + "\n\n[Error: " + error.getMessage() + "]");
                        explainTab.setLineExplanationText(html);
                    } else {
                        explainTab.setLineExplanationText("<html><body>Error: " + error.getMessage() + "</body></html>");
                    }
                    onComplete.run();
                });
            }

            @Override
            public boolean shouldContinue() {
                return isRunning.get();
            }
        };
    }

    /**
     * Create a streaming handler that renders to a generic target.
     */
    public LlmApi.LlmResponseHandler createGenericStreamingHandler(
            Consumer<RenderUpdate> renderCallback,
            Runnable initializeCallback,
            Consumer<String> completeCallback,
            Consumer<String> errorCallback,
            Supplier<Boolean> isRunning) {

        return new LlmApi.LlmResponseHandler() {
            private final StringBuilder responseBuffer = new StringBuilder();
            private StreamingMarkdownRenderer renderer;

            @Override
            public void onStart() {
                responseBuffer.setLength(0);
                renderer = new StreamingMarkdownRenderer(renderCallback, markdownHelper);
                if (initializeCallback != null) {
                    SwingUtilities.invokeLater(initializeCallback);
                }
            }

            @Override
            public void onUpdate(String partialResponse) {
                if (partialResponse == null || partialResponse.isEmpty()) {
                    return;
                }

                String currentBuffer = responseBuffer.toString();
                String delta;
                if (partialResponse.startsWith(currentBuffer)) {
                    delta = partialResponse.substring(currentBuffer.length());
                    responseBuffer.append(delta);
                } else {
                    delta = partialResponse;
                    responseBuffer.append(delta);
                }

                if (!delta.isEmpty() && renderer != null) {
                    renderer.onChunkReceived(delta);
                }
            }

            @Override
            public void onComplete(String fullResponse) {
                final String finalResponse = (fullResponse != null && !fullResponse.isEmpty())
                        ? fullResponse : responseBuffer.toString();

                if (renderer != null) {
                    renderer.onStreamComplete();
                    renderer = null;
                }

                if (completeCallback != null) {
                    SwingUtilities.invokeLater(() -> completeCallback.accept(finalResponse));
                }
            }

            @Override
            public void onError(Throwable error) {
                if (renderer != null) {
                    renderer = null;
                }

                if (errorCallback != null) {
                    SwingUtilities.invokeLater(() -> errorCallback.accept(error.getMessage()));
                }
            }

            @Override
            public boolean shouldContinue() {
                return isRunning.get();
            }
        };
    }

    // ==== MarkdownHelper access ====

    public MarkdownHelper getMarkdownHelper() {
        return markdownHelper;
    }
}

```

`src/main/java/ghidrassist/core/SymGraphController.java`:

```java
package ghidrassist.core;

import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import ghidra.util.task.Task;
import ghidra.util.task.TaskLauncher;
import ghidra.util.task.TaskMonitor;
import ghidrassist.AnalysisDB;
import ghidrassist.GhidrAssistPlugin;
import ghidrassist.graphrag.BinaryKnowledgeGraph;
import ghidrassist.graphrag.nodes.KnowledgeNode;
import ghidrassist.graphrag.nodes.NodeType;
import ghidrassist.services.symgraph.SymGraphService;
import ghidrassist.services.symgraph.SymGraphModels.*;
import ghidrassist.ui.tabs.SymGraphTab;
import ghidrassist.workers.SymGraphApplyWorker;
import ghidrassist.workers.SymGraphPullWorker;

import javax.swing.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Controller for SymGraph operations.
 * Handles query, push, pull, and apply operations for symbol sharing.
 *
 * Extracted from TabController as part of decomposition refactoring.
 */
public class SymGraphController {

    private final GhidrAssistPlugin plugin;
    private final AnalysisDB analysisDB;
    private SymGraphService symGraphService;
    private SymGraphTab symGraphTab;
    private SymGraphApplyWorker applyWorker;
    private SymGraphPullWorker pullWorker;

    public SymGraphController(GhidrAssistPlugin plugin, AnalysisDB analysisDB) {
        this.plugin = plugin;
        this.analysisDB = analysisDB;
    }

    // ==== Tab Registration ====

    public void setSymGraphTab(SymGraphTab tab) {
        this.symGraphTab = tab;
        if (this.symGraphService == null) {
            this.symGraphService = new SymGraphService();
        }
    }

    // ==== Query Operations ====

    /**
     * Handle SymGraph query request.
     */
    public void handleQuery() {
        if (symGraphTab == null || symGraphService == null) {
            Msg.showError(this, null, "Error", "SymGraph tab not initialized");
            return;
        }

        String sha256 = getProgramSHA256();
        if (sha256 == null) {
            Msg.showInfo(this, symGraphTab, "No Binary", "No binary loaded or unable to compute hash.");
            return;
        }

        symGraphTab.setQueryStatus("Checking...", false);
        symGraphTab.hideStats();
        symGraphTab.setButtonsEnabled(false);

        Task task = new Task("Query SymGraph", true, true, false) {
            @Override
            public void run(TaskMonitor monitor) {
                try {
                    QueryResult result = symGraphService.queryBinary(sha256);

                    SwingUtilities.invokeLater(() -> {
                        symGraphTab.setButtonsEnabled(true);
                        if (result.getError() != null) {
                            symGraphTab.setQueryStatus("Error: " + result.getError(), false);
                        } else if (result.isExists()) {
                            symGraphTab.setQueryStatus("Found in SymGraph", true);
                            if (result.getStats() != null) {
                                BinaryStats stats = result.getStats();
                                symGraphTab.setStats(
                                    stats.getSymbolCount(),
                                    stats.getFunctionCount(),
                                    stats.getGraphNodeCount(),
                                    stats.getLastQueriedAt()
                                );
                            }
                        } else {
                            symGraphTab.setQueryStatus("Not found in SymGraph", false);
                            symGraphTab.hideStats();
                        }
                    });
                } catch (Exception e) {
                    Msg.error(this, "Query error: " + e.getMessage(), e);
                    SwingUtilities.invokeLater(() -> {
                        symGraphTab.setButtonsEnabled(true);
                        symGraphTab.setQueryStatus("Error: " + e.getMessage(), false);
                    });
                }
            }
        };
        TaskLauncher.launch(task);
    }

    // ==== Push Operations ====

    /**
     * Handle SymGraph push request.
     */
    public void handlePush(String scope, boolean pushSymbols, boolean pushGraph) {
        if (symGraphTab == null || symGraphService == null) {
            Msg.showError(this, null, "Error", "SymGraph tab not initialized");
            return;
        }

        String sha256 = getProgramSHA256();
        if (sha256 == null) {
            Msg.showInfo(this, symGraphTab, "No Binary", "No binary loaded or unable to compute hash.");
            return;
        }

        if (!symGraphService.hasApiKey()) {
            Msg.showError(this, symGraphTab, "API Key Required",
                "Push requires a SymGraph API key.\n\nAdd your API key in Settings > General > SymGraph");
            return;
        }

        // Use atomic boolean for cancellation
        final java.util.concurrent.atomic.AtomicBoolean cancelled = new java.util.concurrent.atomic.AtomicBoolean(false);

        // Show progress bar with cancel callback
        symGraphTab.setPushStatus("Preparing...", null);
        symGraphTab.showPushProgress(() -> cancelled.set(true));

        // Create progress callback that updates the UI
        SymGraphService.ProgressCallback progressCallback = new SymGraphService.ProgressCallback() {
            @Override
            public void onProgress(int current, int total, String message) {
                SwingUtilities.invokeLater(() -> {
                    symGraphTab.updatePushProgress(current, total, message);
                });
            }

            @Override
            public boolean isCancelled() {
                return cancelled.get();
            }
        };

        // Run in background thread (no modal dialog)
        Thread pushThread = new Thread(() -> {
            try {
                List<Map<String, Object>> symbols = new ArrayList<>();
                Map<String, Object> graphData = null;

                if (pushSymbols) {
                    SwingUtilities.invokeLater(() -> symGraphTab.updatePushProgress(0, 100, "Collecting symbols..."));
                    symbols = collectLocalSymbols(scope);
                    Msg.info(this, "Collected " + symbols.size() + " symbols to push");
                }

                if (cancelled.get()) {
                    handlePushCancelled();
                    return;
                }

                if (pushGraph) {
                    SwingUtilities.invokeLater(() -> symGraphTab.updatePushProgress(0, 100, "Collecting graph data..."));
                    graphData = collectLocalGraph(scope);
                }

                if (cancelled.get()) {
                    handlePushCancelled();
                    return;
                }

                if (symbols.isEmpty() && graphData == null) {
                    SwingUtilities.invokeLater(() -> {
                        symGraphTab.hidePushProgress();
                        symGraphTab.setButtonsEnabled(true);
                        symGraphTab.setPushStatus("No data to push", false);
                    });
                    return;
                }

                PushResult totalResult = PushResult.success(0, 0, 0);

                // Push symbols in chunks with progress
                if (!symbols.isEmpty()) {
                    PushResult symbolResult = symGraphService.pushSymbolsChunked(sha256, symbols, progressCallback);
                    if (!symbolResult.isSuccess()) {
                        throw new Exception(symbolResult.getError());
                    }
                    totalResult.setSymbolsPushed(symbolResult.getSymbolsPushed());
                }

                if (cancelled.get()) {
                    handlePushCancelled();
                    return;
                }

                // Push graph in chunks with progress
                if (graphData != null) {
                    PushResult graphResult = symGraphService.importGraphChunked(sha256, graphData, progressCallback);
                    if (!graphResult.isSuccess()) {
                        throw new Exception(graphResult.getError());
                    }
                    totalResult.setNodesPushed(graphResult.getNodesPushed());
                    totalResult.setEdgesPushed(graphResult.getEdgesPushed());
                }

                if (cancelled.get()) {
                    handlePushCancelled();
                    return;
                }

                // Add fingerprints for debug symbol matching (BuildID for ELF, etc.)
                SwingUtilities.invokeLater(() -> symGraphTab.updatePushProgress(100, 100, "Adding fingerprints..."));
                addBinaryFingerprints(sha256);

                final PushResult result = totalResult;
                SwingUtilities.invokeLater(() -> {
                    symGraphTab.hidePushProgress();
                    symGraphTab.setButtonsEnabled(true);
                    StringBuilder msg = new StringBuilder("Pushed: ");
                    List<String> parts = new ArrayList<>();
                    if (result.getSymbolsPushed() > 0) parts.add(result.getSymbolsPushed() + " symbols");
                    if (result.getNodesPushed() > 0) parts.add(result.getNodesPushed() + " nodes");
                    if (result.getEdgesPushed() > 0) parts.add(result.getEdgesPushed() + " edges");
                    msg.append(parts.isEmpty() ? "complete" : String.join(", ", parts));
                    symGraphTab.setPushStatus(msg.toString(), true);
                });
            } catch (Exception e) {
                Msg.error(this, "Push error: " + e.getMessage(), e);
                SwingUtilities.invokeLater(() -> {
                    symGraphTab.hidePushProgress();
                    symGraphTab.setButtonsEnabled(true);
                    symGraphTab.setPushStatus("Error: " + e.getMessage(), false);
                });
            }
        }, "SymGraph-Push-Worker");
        pushThread.setDaemon(true);
        pushThread.start();
    }

    private void handlePushCancelled() {
        SwingUtilities.invokeLater(() -> {
            symGraphTab.hidePushProgress();
            symGraphTab.setButtonsEnabled(true);
            symGraphTab.setPushStatus("Cancelled", false);
        });
    }

    // ==== Pull Operations ====

    /**
     * Handle SymGraph pull preview request.
     */
    public void handlePullPreview() {
        if (symGraphTab == null || symGraphService == null) {
            Msg.showError(this, null, "Error", "SymGraph tab not initialized");
            return;
        }

        // If a worker is already running, cancel it
        if (pullWorker != null && !pullWorker.isDone()) {
            pullWorker.requestCancel();
            return;
        }

        String sha256 = getProgramSHA256();
        if (sha256 == null) {
            Msg.showInfo(this, symGraphTab, "No Binary", "No binary loaded or unable to compute hash.");
            return;
        }

        if (!symGraphService.hasApiKey()) {
            Msg.showError(this, symGraphTab, "API Key Required",
                "Pull requires a SymGraph API key.\n\nAdd your API key in Settings > General > SymGraph");
            return;
        }

        // Get pull configuration from the tab
        SymGraphTab.PullConfig pullConfig = symGraphTab.getPullConfig();
        List<String> symbolTypes = pullConfig.getSymbolTypes();
        double minConfidence = pullConfig.getMinConfidence();
        boolean includeGraph = pullConfig.isIncludeGraph();

        if (symbolTypes.isEmpty()) {
            Msg.showInfo(this, symGraphTab, "No Types Selected", "Select at least one symbol type to pull.");
            return;
        }

        Msg.info(this, "Fetching symbols from SymGraph: " + sha256 + " (types: " + symbolTypes + ")");
        symGraphTab.clearConflicts();
        symGraphTab.setGraphPreviewData(null, 0, 0, 0);
        symGraphTab.setButtonsEnabled(false);

        pullWorker = new SymGraphPullWorker(
            plugin.getCurrentProgram(),
            symGraphService,
            sha256,
            symbolTypes,
            minConfidence,
            includeGraph
        );

        setupPullWorkerCallbacks(pullWorker);
        pullWorker.execute();
    }

    /**
     * Set up callbacks for the pull worker.
     */
    private void setupPullWorkerCallbacks(SymGraphPullWorker worker) {
        // Progress callback - called on EDT
        worker.setProgressCallback(progress -> {
            symGraphTab.updatePullProgress(progress.current, 100, progress.message);
        });

        // Completed callback - called on EDT
        worker.setCompletedCallback(result -> {
            symGraphTab.hidePullProgress();
            symGraphTab.setButtonsEnabled(true);

            if (result.cancelled) {
                symGraphTab.setPullStatus("Cancelled", false);
            } else if (result.error != null) {
                symGraphTab.setGraphPreviewData(null, 0, 0, 0);
                symGraphTab.setPullStatus("Error: " + result.error, false);
            } else if (result.conflicts.isEmpty() && result.graphExport == null) {
                symGraphTab.setPullStatus("No symbols found", false);
            } else {
                symGraphTab.setGraphPreviewData(result.graphExport, result.graphNodes,
                    result.graphEdges, result.graphCommunities);
                symGraphTab.populateConflicts(result.conflicts);

                int conflictCount = (int) result.conflicts.stream()
                    .filter(c -> c.getAction() == ConflictAction.CONFLICT).count();
                int newCount = (int) result.conflicts.stream()
                    .filter(c -> c.getAction() == ConflictAction.NEW).count();
                String status = String.format("Found %d symbols (%d conflicts, %d new)",
                    result.conflicts.size(), conflictCount, newCount);
                if (result.conflicts.isEmpty() && result.graphExport != null) {
                    status = "No symbols found (graph data available)";
                } else if (result.graphExport != null) {
                    status += String.format(" | Graph: %d nodes, %d edges, %d communities",
                        result.graphNodes, result.graphEdges, result.graphCommunities);
                }
                symGraphTab.setPullStatus(status, true);
            }
        });

        // Cancelled callback - called on EDT
        worker.setCancelledCallback(() -> {
            symGraphTab.hidePullProgress();
            symGraphTab.setButtonsEnabled(true);
            symGraphTab.setPullStatus("Cancelled", false);
        });

        // Failed callback - called on EDT
        worker.setFailedCallback(error -> {
            symGraphTab.hidePullProgress();
            symGraphTab.setButtonsEnabled(true);
            symGraphTab.setGraphPreviewData(null, 0, 0, 0);
            symGraphTab.setPullStatus("Error: " + error, false);
        });

        // Show progress
        symGraphTab.showPullProgress("Fetching...");
    }

    /**
     * Cancel the current pull operation if running.
     */
    public void cancelPull() {
        if (pullWorker != null && !pullWorker.isDone()) {
            pullWorker.requestCancel();
        }
    }

    // ==== Apply Operations ====

    /**
     * Handle applying selected symbols from SymGraph.
     */
    public void handleApplySelected(List<ConflictEntry> selectedConflicts) {
        if (symGraphTab == null || plugin.getCurrentProgram() == null) {
            return;
        }

        // If a worker is already running, cancel it
        if (applyWorker != null && !applyWorker.isDone()) {
            applyWorker.requestCancel();
            return;
        }

        GraphExport graphExport = symGraphTab.getGraphPreviewData();
        if (selectedConflicts.isEmpty() && graphExport == null) {
            symGraphTab.setPullStatus("No items selected", false);
            return;
        }

        String programHash = getProgramSHA256();
        if (graphExport != null && programHash == null) {
            symGraphTab.setPullStatus("Unable to resolve program hash", false);
            return;
        }

        applyWorker = new SymGraphApplyWorker(
            plugin.getCurrentProgram(),
            analysisDB,
            selectedConflicts,
            graphExport,
            programHash,
            symGraphTab.getGraphMergePolicy()
        );

        setupApplyWorkerCallbacks(applyWorker, selectedConflicts.size());
        applyWorker.execute();
    }

    /**
     * Handle applying all NEW symbols from SymGraph (wizard shortcut).
     */
    public void handleApplyAllNew() {
        if (symGraphTab == null || plugin.getCurrentProgram() == null) {
            return;
        }

        // If a worker is already running, cancel it
        if (applyWorker != null && !applyWorker.isDone()) {
            applyWorker.requestCancel();
            return;
        }

        List<ConflictEntry> newConflicts = symGraphTab.getAllNewConflicts();
        GraphExport graphExport = symGraphTab.getGraphPreviewData();
        if (newConflicts.isEmpty() && graphExport == null) {
            symGraphTab.setPullStatus("No new symbols to apply", false);
            return;
        }

        String programHash = getProgramSHA256();
        if (graphExport != null && programHash == null) {
            symGraphTab.setPullStatus("Unable to resolve program hash", false);
            return;
        }

        applyWorker = new SymGraphApplyWorker(
            plugin.getCurrentProgram(),
            analysisDB,
            newConflicts,
            graphExport,
            programHash,
            symGraphTab.getGraphMergePolicy()
        );

        setupApplyWorkerCallbacks(applyWorker, newConflicts.size());
        applyWorker.execute();
    }

    /**
     * Set up callbacks for the apply worker.
     */
    private void setupApplyWorkerCallbacks(SymGraphApplyWorker worker, int totalSymbols) {
        // Progress callback - called on EDT
        worker.setProgressCallback(progress -> {
            symGraphTab.updateApplyProgress(progress.current, 100, progress.message);
        });

        // Completed callback - called on EDT
        worker.setCompletedCallback(result -> {
            symGraphTab.hideApplyProgress();
            if (result.cancelled) {
                symGraphTab.showCompletePage(
                    String.format("Cancelled after applying %d symbols", result.symbolsApplied), false);
            } else if (result.error != null) {
                symGraphTab.showCompletePage("Error: " + result.error, false);
            } else {
                StringBuilder message = new StringBuilder("Applied ");
                List<String> parts = new ArrayList<>();
                if (result.symbolsApplied > 0) {
                    parts.add(result.symbolsApplied + " symbols");
                }
                if (result.nodesApplied > 0) {
                    parts.add(result.nodesApplied + " nodes");
                }
                if (result.edgesApplied > 0) {
                    parts.add(result.edgesApplied + " edges");
                }
                if (parts.isEmpty()) {
                    message.append("no changes");
                } else {
                    message.append(String.join(", ", parts));
                }
                symGraphTab.showCompletePage(message.toString(), true);
            }
        });

        // Cancelled callback - called on EDT
        worker.setCancelledCallback(() -> {
            symGraphTab.hideApplyProgress();
            symGraphTab.showCompletePage("Apply cancelled", false);
        });

        // Failed callback - called on EDT
        worker.setFailedCallback(error -> {
            symGraphTab.hideApplyProgress();
            symGraphTab.showCompletePage("Error: " + error, false);
        });

        // Show the applying page with progress
        String message = totalSymbols > 0 ?
            String.format("Applying %d symbols...", totalSymbols) :
            "Applying graph data...";
        symGraphTab.showApplyingPage(message);
    }

    /**
     * Cancel the current apply operation if running.
     */
    public void cancelApply() {
        if (applyWorker != null && !applyWorker.isDone()) {
            applyWorker.requestCancel();
        }
    }

    // ==== Binary Info ====

    /**
     * Update SymGraph tab binary info when program changes.
     */
    public void updateBinaryInfo() {
        if (symGraphTab == null) {
            return;
        }

        if (plugin.getCurrentProgram() != null) {
            String name = plugin.getCurrentProgram().getName();
            String sha256 = getProgramSHA256();
            symGraphTab.setBinaryInfo(name, sha256);
        } else {
            symGraphTab.setBinaryInfo(null, null);
        }
    }

    // ==== Helper Methods ====

    private String getProgramSHA256() {
        try {
            if (plugin.getCurrentProgram() != null) {
                return plugin.getCurrentProgram().getExecutableSHA256();
            }
        } catch (Exception e) {
            Msg.error(this, "Error getting SHA256: " + e.getMessage());
        }
        return null;
    }

    /**
     * Add fingerprints to the binary for debug symbol matching.
     * Extracts BuildID (for ELF) or other identifiers and adds them as fingerprints.
     */
    private void addBinaryFingerprints(String sha256) {
        if (plugin.getCurrentProgram() == null || symGraphService == null) {
            return;
        }

        Program program = plugin.getCurrentProgram();

        try {
            // Check executable format
            String format = program.getExecutableFormat();

            if ("Executable and Linking Format (ELF)".equals(format) ||
                (format != null && format.contains("ELF"))) {
                // Extract BuildID from ELF
                String buildId = extractElfBuildId(program);
                if (buildId != null && !buildId.isEmpty()) {
                    Msg.info(this, "Extracted ELF BuildID: " + buildId);
                    try {
                        symGraphService.addFingerprint(sha256, "build_id", buildId);
                    } catch (Exception e) {
                        Msg.warn(this, "Failed to add BuildID fingerprint: " + e.getMessage());
                    }
                }
            }
            // PE/PDB GUID extraction would go here if needed

        } catch (Exception e) {
            Msg.warn(this, "Error extracting fingerprints: " + e.getMessage());
        }
    }

    /**
     * Extract GNU BuildID from an ELF binary.
     */
    private String extractElfBuildId(Program program) {
        try {
            // Look for .note.gnu.build-id section
            ghidra.program.model.mem.MemoryBlock buildIdBlock = null;
            for (ghidra.program.model.mem.MemoryBlock block : program.getMemory().getBlocks()) {
                if (".note.gnu.build-id".equals(block.getName())) {
                    buildIdBlock = block;
                    break;
                }
            }

            if (buildIdBlock == null) {
                // Try alternative names
                for (ghidra.program.model.mem.MemoryBlock block : program.getMemory().getBlocks()) {
                    String name = block.getName();
                    if (name != null && name.contains("build") && name.contains("id")) {
                        buildIdBlock = block;
                        break;
                    }
                }
            }

            if (buildIdBlock != null) {
                // Read the note section
                int size = (int) buildIdBlock.getSize();
                if (size > 256) size = 256; // Sanity limit

                byte[] data = new byte[size];
                buildIdBlock.getBytes(buildIdBlock.getStart(), data);

                if (data.length >= 16) {
                    // GNU note format: namesz (4), descsz (4), type (4), name, desc
                    int namesz = readLittleEndianInt(data, 0);
                    int descsz = readLittleEndianInt(data, 4);
                    int noteType = readLittleEndianInt(data, 8);

                    if (noteType == 3) { // NT_GNU_BUILD_ID
                        // Name is padded to 4-byte boundary
                        int nameEnd = 12 + ((namesz + 3) & ~3);
                        if (data.length >= nameEnd + descsz) {
                            StringBuilder sb = new StringBuilder();
                            for (int i = nameEnd; i < nameEnd + descsz; i++) {
                                sb.append(String.format("%02x", data[i] & 0xff));
                            }
                            return sb.toString();
                        }
                    }
                }
            }
        } catch (Exception e) {
            Msg.debug(this, "Error extracting ELF BuildID: " + e.getMessage());
        }
        return null;
    }

    private int readLittleEndianInt(byte[] data, int offset) {
        return (data[offset] & 0xff) |
               ((data[offset + 1] & 0xff) << 8) |
               ((data[offset + 2] & 0xff) << 16) |
               ((data[offset + 3] & 0xff) << 24);
    }

    private List<Map<String, Object>> collectLocalSymbols(String scope) {
        List<Map<String, Object>> symbols = new ArrayList<>();

        if (plugin.getCurrentProgram() == null) {
            return symbols;
        }

        Program program = plugin.getCurrentProgram();

        try {
            if ("function".equals(scope)) {
                Function currentFunc = plugin.getCurrentFunction();
                if (currentFunc != null) {
                    symbols.add(functionToSymbolMap(currentFunc));
                    // Collect function comments and local variables
                    symbols.addAll(collectFunctionComments(currentFunc));
                    symbols.addAll(collectFunctionVariables(currentFunc));
                }
            } else {
                // Full binary - all symbol types

                // 1. Functions
                for (Function func : program.getFunctionManager().getFunctions(true)) {
                    symbols.add(functionToSymbolMap(func));
                }

                // 2. Data (global variables)
                symbols.addAll(collectDataSymbols(program));

                // 3. Types and enums
                symbols.addAll(collectTypesAndEnums(program));

                // 4. Comments
                symbols.addAll(collectAllComments(program));
            }
        } catch (Exception e) {
            Msg.error(this, "Error collecting symbols: " + e.getMessage());
        }

        return symbols;
    }

    private Map<String, Object> functionToSymbolMap(Function func) {
        Map<String, Object> map = new HashMap<>();
        map.put("address", String.format("0x%x", func.getEntryPoint().getOffset()));
        map.put("symbol_type", "function");
        map.put("name", getQualifiedFunctionName(func));
        // Include function signature as data_type
        if (func.getSignature() != null) {
            map.put("data_type", func.getSignature().getPrototypeString());
        }
        // Use unified default name detection for cross-tool compatibility
        boolean isAuto = ghidrassist.services.symgraph.SymGraphUtils.isDefaultName(func.getName());
        map.put("confidence", isAuto ? 0.5 : 0.9);
        map.put("provenance", isAuto ? "decompiler" : "user");
        return map;
    }

    private List<Map<String, Object>> collectDataSymbols(Program program) {
        List<Map<String, Object>> symbols = new ArrayList<>();
        try {
            ghidra.program.model.listing.Listing listing = program.getListing();
            ghidra.program.model.listing.DataIterator dataIter = listing.getDefinedData(true);

            while (dataIter.hasNext()) {
                ghidra.program.model.listing.Data data = dataIter.next();
                if (data != null) {
                    ghidra.program.model.address.Address addr = data.getAddress();
                    ghidra.program.model.symbol.Symbol sym = program.getSymbolTable().getPrimarySymbol(addr);
                    String name = (sym != null) ? sym.getName() : null;

                    // Skip variables without names
                    if (name == null || name.isEmpty()) {
                        continue;
                    }

                    // Use unified default name detection for cross-tool compatibility
                    boolean isAutoNamed = ghidrassist.services.symgraph.SymGraphUtils.isDefaultName(name);

                    Map<String, Object> map = new HashMap<>();
                    map.put("address", String.format("0x%x", addr.getOffset()));
                    map.put("symbol_type", "variable");
                    map.put("name", name);
                    if (data.getDataType() != null) {
                        map.put("data_type", data.getDataType().getName());
                    }
                    map.put("confidence", isAutoNamed ? 0.3 : 0.85);
                    map.put("provenance", isAutoNamed ? "decompiler" : "user");
                    symbols.add(map);
                }
            }
        } catch (Exception e) {
            Msg.error(this, "Error collecting data symbols: " + e.getMessage());
        }
        return symbols;
    }

    private List<Map<String, Object>> collectFunctionVariables(Function func) {
        List<Map<String, Object>> symbols = new ArrayList<>();
        try {
            // Parameters - use ordinal for index
            ghidra.program.model.listing.Parameter[] params = func.getParameters();
            for (int i = 0; i < params.length; i++) {
                ghidra.program.model.listing.Parameter param = params[i];
                if (param.getName() != null) {
                    // Use unified default name detection for cross-tool compatibility
                    boolean isAuto = ghidrassist.services.symgraph.SymGraphUtils.isDefaultName(param.getName());
                    Map<String, Object> map = new HashMap<>();
                    map.put("address", String.format("0x%x", func.getEntryPoint().getOffset()));
                    map.put("symbol_type", "variable");
                    map.put("name", param.getName());
                    if (param.getDataType() != null) {
                        map.put("data_type", param.getDataType().getName());
                    }
                    map.put("confidence", isAuto ? 0.3 : 0.8);
                    map.put("provenance", isAuto ? "decompiler" : "user");

                    Map<String, Object> metadata = new HashMap<>();
                    metadata.put("scope", "parameter");
                    metadata.put("function", getQualifiedFunctionName(func));
                    metadata.put("storage_class", "parameter");
                    metadata.put("parameter_index", param.getOrdinal());

                    // Also capture actual storage location
                    try {
                        if (param.isRegisterVariable()) {
                            ghidra.program.model.lang.Register reg = param.getRegister();
                            if (reg != null) {
                                metadata.put("register", reg.getName());
                            }
                        } else if (param.isStackVariable()) {
                            metadata.put("stack_offset", param.getStackOffset());
                        }
                    } catch (Exception e) {
                        // Storage info optional
                    }

                    map.put("metadata", metadata);
                    symbols.add(map);
                }
            }

            // Local variables
            for (ghidra.program.model.listing.Variable var : func.getLocalVariables()) {
                if (var.getName() != null) {
                    // Use unified default name detection for cross-tool compatibility
                    boolean isAuto = ghidrassist.services.symgraph.SymGraphUtils.isDefaultName(var.getName());
                    Map<String, Object> map = new HashMap<>();
                    map.put("address", String.format("0x%x", func.getEntryPoint().getOffset()));
                    map.put("symbol_type", "variable");
                    map.put("name", var.getName());
                    if (var.getDataType() != null) {
                        map.put("data_type", var.getDataType().getName());
                    }
                    map.put("confidence", isAuto ? 0.3 : 0.75);
                    map.put("provenance", isAuto ? "decompiler" : "user");

                    Map<String, Object> metadata = new HashMap<>();
                    metadata.put("scope", "local");
                    metadata.put("function", getQualifiedFunctionName(func));

                    try {
                        if (var.isStackVariable()) {
                            metadata.put("storage_class", "stack");
                            metadata.put("stack_offset", var.getStackOffset());
                        } else if (var.isRegisterVariable()) {
                            metadata.put("storage_class", "register");
                            ghidra.program.model.lang.Register reg = var.getRegister();
                            if (reg != null) {
                                metadata.put("register", reg.getName());
                            }
                        } else {
                            metadata.put("storage_class", "compound");
                            metadata.put("storage_string", var.getVariableStorage().toString());
                        }
                    } catch (UnsupportedOperationException e) {
                        metadata.put("storage_class", "compound");
                        metadata.put("storage_string", var.getVariableStorage().toString());
                    }

                    map.put("metadata", metadata);
                    symbols.add(map);
                }
            }
        } catch (Exception e) {
            Msg.error(this, "Error collecting function variables: " + e.getMessage());
        }
        return symbols;
    }

    private List<Map<String, Object>> collectTypesAndEnums(Program program) {
        List<Map<String, Object>> symbols = new ArrayList<>();
        try {
            ghidra.program.model.data.DataTypeManager dtm = program.getDataTypeManager();

            // Iterate through all user-defined types
            java.util.Iterator<ghidra.program.model.data.DataType> iter = dtm.getAllDataTypes();
            while (iter.hasNext()) {
                ghidra.program.model.data.DataType dt = iter.next();
                // Skip built-in types (only collect user-defined)
                ghidra.program.model.data.SourceArchive srcArchive = dt.getSourceArchive();
                if (srcArchive == null) {
                    continue;
                }
                // Skip types from built-in archives
                if (srcArchive.getArchiveType() == ghidra.program.model.data.ArchiveType.BUILT_IN) {
                    continue;
                }

                Map<String, Object> map = new HashMap<>();
                map.put("address", "0x0"); // Types don't have addresses
                map.put("name", dt.getName());
                map.put("data_type", dt.getDisplayName());
                map.put("confidence", 0.9);
                map.put("provenance", "user");

                if (dt instanceof ghidra.program.model.data.Enum) {
                    ghidra.program.model.data.Enum enumType = (ghidra.program.model.data.Enum) dt;
                    map.put("symbol_type", "enum");
                    // Collect enum members
                    Map<String, Object> metadata = new HashMap<>();
                    Map<String, Long> members = new HashMap<>();
                    StringBuilder contentBuilder = new StringBuilder();
                    contentBuilder.append("enum ").append(dt.getName()).append(" {\n");
                    for (String name : enumType.getNames()) {
                        long value = enumType.getValue(name);
                        members.put(name, value);
                        contentBuilder.append(String.format("    %s = 0x%x,\n", name, value));
                    }
                    contentBuilder.append("}");
                    metadata.put("members", members);
                    map.put("metadata", metadata);
                    map.put("content", contentBuilder.toString());
                    map.put("data_type", contentBuilder.toString());
                } else if (dt instanceof ghidra.program.model.data.Structure) {
                    ghidra.program.model.data.Structure struct = (ghidra.program.model.data.Structure) dt;
                    map.put("symbol_type", "struct");
                    // Collect struct fields
                    List<Map<String, Object>> fields = new ArrayList<>();
                    StringBuilder contentBuilder = new StringBuilder();
                    contentBuilder.append("struct ").append(dt.getName()).append(" {\n");
                    for (ghidra.program.model.data.DataTypeComponent comp : struct.getComponents()) {
                        Map<String, Object> field = new HashMap<>();
                        String fieldName = comp.getFieldName();
                        String fieldType = comp.getDataType().getName();
                        int offset = comp.getOffset();
                        field.put("name", fieldName);
                        field.put("type", fieldType);
                        field.put("offset", offset);
                        fields.add(field);
                        contentBuilder.append(String.format("    /* 0x%02x */ %s %s;\n",
                            offset, fieldType, fieldName != null ? fieldName : "field_" + offset));
                    }
                    contentBuilder.append("}");
                    Map<String, Object> metadata = new HashMap<>();
                    metadata.put("fields", fields);
                    map.put("metadata", metadata);
                    map.put("content", contentBuilder.toString());
                    map.put("data_type", contentBuilder.toString());
                } else {
                    map.put("symbol_type", "type");
                }

                symbols.add(map);
            }
        } catch (Exception e) {
            Msg.error(this, "Error collecting types and enums: " + e.getMessage());
        }
        return symbols;
    }

    private List<Map<String, Object>> collectAllComments(Program program) {
        List<Map<String, Object>> symbols = new ArrayList<>();
        try {
            // Collect function-level and address comments
            for (Function func : program.getFunctionManager().getFunctions(true)) {
                symbols.addAll(collectFunctionComments(func));
            }
        } catch (Exception e) {
            Msg.error(this, "Error collecting comments: " + e.getMessage());
        }
        return symbols;
    }

    private List<Map<String, Object>> collectFunctionComments(Function func) {
        List<Map<String, Object>> symbols = new ArrayList<>();
        Program program = func.getProgram();

        try {
            // Function comment (plate comment)
            String funcComment = func.getComment();
            if (funcComment != null && !funcComment.isEmpty()) {
                Map<String, Object> map = new HashMap<>();
                map.put("address", String.format("0x%x", func.getEntryPoint().getOffset()));
                map.put("symbol_type", "comment");
                map.put("content", funcComment);
                map.put("confidence", 1.0);
                map.put("provenance", "user");
                Map<String, Object> metadata = new HashMap<>();
                metadata.put("type", "function");
                map.put("metadata", metadata);
                symbols.add(map);
            }

            // EOL and PRE comments within the function
            ghidra.program.model.listing.Listing listing = program.getListing();
            ghidra.program.model.address.AddressSetView body = func.getBody();

            for (ghidra.program.model.address.Address addr : body.getAddresses(true)) {
                ghidra.program.model.listing.CodeUnit codeUnit = listing.getCodeUnitAt(addr);
                if (codeUnit == null) continue;

                String eolComment = codeUnit.getComment(ghidra.program.model.listing.CommentType.EOL);
                if (eolComment != null && !eolComment.isEmpty()) {
                    Map<String, Object> map = new HashMap<>();
                    map.put("address", String.format("0x%x", addr.getOffset()));
                    map.put("symbol_type", "comment");
                    map.put("content", eolComment);
                    map.put("confidence", 1.0);
                    map.put("provenance", "user");
                    Map<String, Object> metadata = new HashMap<>();
                    metadata.put("type", "eol");
                    metadata.put("function", getQualifiedFunctionName(func));
                    map.put("metadata", metadata);
                    symbols.add(map);
                }

                String preComment = codeUnit.getComment(ghidra.program.model.listing.CommentType.PRE);
                if (preComment != null && !preComment.isEmpty()) {
                    Map<String, Object> map = new HashMap<>();
                    map.put("address", String.format("0x%x", addr.getOffset()));
                    map.put("symbol_type", "comment");
                    map.put("content", preComment);
                    map.put("confidence", 1.0);
                    map.put("provenance", "user");
                    Map<String, Object> metadata = new HashMap<>();
                    metadata.put("type", "pre");
                    metadata.put("function", getQualifiedFunctionName(func));
                    map.put("metadata", metadata);
                    symbols.add(map);
                }
            }
        } catch (Exception e) {
            Msg.error(this, "Error collecting function comments: " + e.getMessage());
        }
        return symbols;
    }

    private Map<String, Object> collectLocalGraph(String scope) {
        if (plugin.getCurrentProgram() == null || analysisDB == null) {
            return null;
        }

        List<Map<String, Object>> nodes = new ArrayList<>();
        List<Map<String, Object>> edges = new ArrayList<>();

        try {
            String programHash = plugin.getCurrentProgram().getExecutableSHA256();
            BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);

            if (graph == null || graph.getNodeCount() == 0) {
                Msg.warn(this, "No graph data found. Please index the binary first using the Semantic Graph tab.");
                return null;
            }

            // Step 1: Collect all node IDs to export
            java.util.Set<String> nodeIdsToExport = new java.util.HashSet<>();

            if ("function".equals(scope)) {
                // Just the current function and its immediate neighbors
                Function currentFunc = plugin.getCurrentFunction();
                if (currentFunc != null) {
                    KnowledgeNode funcNode = graph.getNodeByAddress(currentFunc.getEntryPoint().getOffset());
                    if (funcNode != null) {
                        nodeIdsToExport.add(funcNode.getId());
                        // Add 1-hop neighbors
                        for (KnowledgeNode neighbor : graph.getNeighborsBatch(funcNode.getId(), 1)) {
                            nodeIdsToExport.add(neighbor.getId());
                        }
                    }
                }
            } else {
                // Full binary - export all nodes
                for (NodeType nodeType : NodeType.values()) {
                    for (KnowledgeNode node : graph.getNodesByType(nodeType)) {
                        nodeIdsToExport.add(node.getId());
                    }
                }
            }

            // Step 2: BATCH fetch all nodes in ONE query
            java.util.Map<String, KnowledgeNode> nodeCache = graph.getNodes(nodeIdsToExport);

            // Step 3: BATCH fetch all edges in ONE query
            java.util.List<BinaryKnowledgeGraph.GraphEdge> allEdges = graph.getEdgesForNodes(nodeIdsToExport);

            // Step 4: Process nodes from cache
            for (KnowledgeNode node : nodeCache.values()) {
                nodes.add(nodeToExportMap(node));
            }

            // Step 5: Process edges using cache
            for (BinaryKnowledgeGraph.GraphEdge edge : allEdges) {
                // Only include edges where both endpoints are in our export set
                if (nodeIdsToExport.contains(edge.getTargetId())) {
                    KnowledgeNode sourceNode = nodeCache.get(edge.getSourceId());
                    KnowledgeNode targetNode = nodeCache.get(edge.getTargetId());

                    if (sourceNode != null && targetNode != null) {
                        Map<String, Object> edgeMap = new HashMap<>();
                        edgeMap.put("source_address", sourceNode.getAddress() != null ?
                            String.format("0x%x", sourceNode.getAddress()) : "0x0");
                        edgeMap.put("target_address", targetNode.getAddress() != null ?
                            String.format("0x%x", targetNode.getAddress()) : "0x0");
                        edgeMap.put("edge_type", edge.getType().name().toLowerCase());
                        edgeMap.put("weight", edge.getWeight());
                        edges.add(edgeMap);
                    }
                }
            }

            Msg.info(this, String.format("Collected %d nodes and %d edges for export", nodes.size(), edges.size()));

        } catch (Exception e) {
            Msg.error(this, "Error collecting graph: " + e.getMessage(), e);
        }

        if (nodes.isEmpty()) {
            return null;
        }

        Map<String, Object> graphData = new HashMap<>();
        graphData.put("nodes", nodes);
        graphData.put("edges", edges);
        return graphData;
    }

    /**
     * Convert a KnowledgeNode to a Map for export.
     */
    private Map<String, Object> nodeToExportMap(KnowledgeNode node) {
        Map<String, Object> nodeMap = new HashMap<>();
        nodeMap.put("address", node.getAddress() != null ?
            String.format("0x%x", node.getAddress()) : "0x0");
        nodeMap.put("node_type", node.getType().name().toLowerCase());
        nodeMap.put("name", node.getName());
        nodeMap.put("raw_content", node.getRawContent());
        nodeMap.put("llm_summary", node.getLlmSummary());
        nodeMap.put("confidence", node.getConfidence());
        nodeMap.put("provenance", "user");

        // Add security-related fields if present
        if (node.getSecurityFlags() != null && !node.getSecurityFlags().isEmpty()) {
            nodeMap.put("security_flags", new ArrayList<>(node.getSecurityFlags()));
        }
        if (node.getNetworkAPIs() != null && !node.getNetworkAPIs().isEmpty()) {
            nodeMap.put("network_apis", new ArrayList<>(node.getNetworkAPIs()));
        }
        if (node.getFileIOAPIs() != null && !node.getFileIOAPIs().isEmpty()) {
            nodeMap.put("file_io_apis", new ArrayList<>(node.getFileIOAPIs()));
        }
        if (node.getIPAddresses() != null && !node.getIPAddresses().isEmpty()) {
            nodeMap.put("ip_addresses", new ArrayList<>(node.getIPAddresses()));
        }
        if (node.getURLs() != null && !node.getURLs().isEmpty()) {
            nodeMap.put("urls", new ArrayList<>(node.getURLs()));
        }
        if (node.getFilePaths() != null && !node.getFilePaths().isEmpty()) {
            nodeMap.put("file_paths", new ArrayList<>(node.getFilePaths()));
        }
        if (node.getDomains() != null && !node.getDomains().isEmpty()) {
            nodeMap.put("domains", new ArrayList<>(node.getDomains()));
        }
        if (node.getRegistryKeys() != null && !node.getRegistryKeys().isEmpty()) {
            nodeMap.put("registry_keys", new ArrayList<>(node.getRegistryKeys()));
        }

        return nodeMap;
    }

    /**
     * Get the fully qualified name of a function including its namespace.
     * Delegates to shared utility in SymGraphUtils.
     */
    private String getQualifiedFunctionName(Function func) {
        return ghidrassist.services.symgraph.SymGraphUtils.getQualifiedFunctionName(func);
    }
}

```

`src/main/java/ghidrassist/core/TabController.java`:

```java
package ghidrassist.core;

import ghidra.app.services.GoToService;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.program.util.ProgramLocation;
import ghidra.util.Msg;
import ghidra.util.task.Task;
import ghidra.util.task.TaskLauncher;
import ghidra.util.task.TaskMonitor;
import ghidrassist.AnalysisDB;
import ghidrassist.GhidrAssistPlugin;
import ghidrassist.LlmApi;
import ghidrassist.apiprovider.APIProviderConfig;
import ghidrassist.apiprovider.ReasoningConfig;
import ghidrassist.chat.ChatChange;
import ghidrassist.chat.ChatEditManager;
import ghidrassist.chat.ChangeType;
import ghidrassist.chat.PersistedChatMessage;
import ghidrassist.services.*;
import ghidrassist.services.RAGManagementService.RAGIndexStats;
import ghidrassist.ui.tabs.*;
import ghidrassist.graphrag.BinaryKnowledgeGraph;
import ghidrassist.graphrag.nodes.EdgeType;
import ghidrassist.graphrag.nodes.KnowledgeNode;
import ghidrassist.graphrag.nodes.NodeType;
import ghidrassist.graphrag.extraction.StructureExtractor;
import ghidrassist.graphrag.extraction.SemanticExtractor;
import ghidrassist.graphrag.extraction.SecurityFeatureExtractor;
import ghidrassist.graphrag.extraction.SecurityFeatures;
import ghidrassist.services.symgraph.SymGraphService;
import ghidrassist.services.symgraph.SymGraphModels.*;
import ghidrassist.workers.*;
import ghidrassist.core.streaming.StreamingMarkdownRenderer;

import com.google.gson.Gson;

import java.sql.Timestamp;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;

import javax.swing.*;
import javax.swing.event.HyperlinkEvent;
import javax.swing.table.DefaultTableModel;
import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Responsibilities:
 * - UI event coordination
 * - Task lifecycle management
 * - Service orchestration
 * - UI state updates
 *
 * Refactored to delegate specialized operations to sub-controllers:
 * - SymGraphController: SymGraph query/push/pull operations
 * - SemanticGraphController: Semantic graph indexing and analysis
 */
public class TabController {

    // Services (business logic)
    private final CodeAnalysisService codeAnalysisService;
    private final QueryService queryService;
    private final ActionAnalysisService actionAnalysisService;
    private final RAGManagementService ragManagementService;
    private final AnalysisDataService analysisDataService;
    private final FeedbackService feedbackService;

    // UI utilities
    private final GhidrAssistPlugin plugin;
    private final MarkdownHelper markdownHelper;

    // Sub-controllers (extracted for decomposition)
    private final SymGraphController symGraphController;
    private final SemanticGraphController semanticGraphController;

    // Shared LLM API instance for cancellation
    private volatile LlmApi currentLlmApi;

    // Line explanation LLM API instance (separate from function explain)
    private volatile LlmApi currentLineExplainLlmApi;

    // ReAct orchestrator for cancellation
    private volatile ghidrassist.agent.react.ReActOrchestrator currentOrchestrator;

    // UI state
    private volatile boolean isQueryRunning;
    private volatile boolean isLineQueryRunning;
    private volatile boolean isCancelling;  // Guard against concurrent operations during cancellation
    private volatile ReasoningConfig currentReasoningConfig;  // Current reasoning/thinking effort setting

    // Streaming markdown renderer for incremental HTML updates
    private volatile StreamingMarkdownRenderer currentStreamingRenderer;

    // Streaming markdown renderer for Explain tab (separate from Query tab)
    private volatile StreamingMarkdownRenderer currentExplainStreamingRenderer;

    // Streaming markdown renderer for Line Explanation (separate from Function Explain)
    private volatile StreamingMarkdownRenderer currentLineExplainStreamingRenderer;

    // Scheduler for safety timeouts
    private final ScheduledExecutorService safetyScheduler = Executors.newSingleThreadScheduledExecutor();

    // Chat edit manager for chunked editing
    private final ChatEditManager chatEditManager = new ChatEditManager();

    // UI Component references
    private ExplainTab explainTab;
    private QueryTab queryTab;
    private ActionsTab actionsTab;
    private RAGManagementTab ragManagementTab;
    private SettingsTab settingsTab;
    private SemanticGraphTab semanticGraphTab;
    private SymGraphTab symGraphTab;

    // Database for semantic graph operations
    private final AnalysisDB analysisDB;

    public TabController(GhidrAssistPlugin plugin) {
        this.plugin = plugin;
        this.markdownHelper = new MarkdownHelper();
        this.isQueryRunning = false;
        this.isCancelling = false;
        this.currentReasoningConfig = new ReasoningConfig(); // Default to NONE

        // Initialize services
        this.codeAnalysisService = new CodeAnalysisService(plugin);
        this.queryService = new QueryService(plugin);
        this.actionAnalysisService = new ActionAnalysisService(plugin);
        this.ragManagementService = new RAGManagementService();
        this.analysisDataService = new AnalysisDataService(plugin);
        this.feedbackService = new FeedbackService(plugin);
        this.analysisDB = new AnalysisDB();

        // Initialize sub-controllers
        this.symGraphController = new SymGraphController(plugin, analysisDB);
        this.semanticGraphController = new SemanticGraphController(plugin, analysisDB);

        new UIState();
    }

    // ==== UI Component Registration ====
    
    public void setTabs(ExplainTab explainTab, QueryTab queryTab, 
                       ActionsTab actionsTab, RAGManagementTab ragManagementTab) {
        this.explainTab = explainTab;
        this.queryTab = queryTab;
        this.actionsTab = actionsTab;
        this.ragManagementTab = ragManagementTab;
    }

    public void setExplainTab(ExplainTab tab) { this.explainTab = tab; }
    public void setQueryTab(QueryTab tab) {
        this.queryTab = tab;
    }
    public void setActionsTab(ActionsTab tab) { this.actionsTab = tab; }
    public void setRAGManagementTab(RAGManagementTab tab) { this.ragManagementTab = tab; }
    public void setSemanticGraphTab(SemanticGraphTab tab) {
        this.semanticGraphTab = tab;
        semanticGraphController.setSemanticGraphTab(tab);
    }
    public void setSymGraphTab(SymGraphTab tab) {
        this.symGraphTab = tab;
        symGraphController.setSymGraphTab(tab);
    }
    public void setSettingsTab(SettingsTab tab) { this.settingsTab = tab; }

    // ==== Plugin Access ====

    public GhidrAssistPlugin getPlugin() {
        return plugin;
    }

    // ==== Reasoning Configuration ====

    /**
     * Set the reasoning/thinking effort level.
     * Called by the UI when the user changes the dropdown selection.
     */
    public void setReasoningEffort(String level) {
        this.currentReasoningConfig = ReasoningConfig.fromString(level);

        // Save to database
        try {
            analysisDataService.saveReasoningEffort(level.toLowerCase());
            Msg.info(this, "Reasoning effort set to: " + level);
        } catch (IllegalStateException e) {
            // No program loaded - just update in-memory config
            Msg.info(this, "Reasoning effort set to: " + level + " (not saved - no program loaded)");
        }
    }

    /**
     * Get the current reasoning effort level as a string for UI display.
     * Loads from database if available.
     */
    public String getReasoningEffort() {
        // Try to load from database first
        try {
            String savedEffort = analysisDataService.getReasoningEffort();
            if (savedEffort != null && !savedEffort.equalsIgnoreCase("none")) {
                // Update in-memory config to match saved value
                this.currentReasoningConfig = ReasoningConfig.fromString(savedEffort);
                // Return with proper capitalization for UI
                return savedEffort.substring(0, 1).toUpperCase() + savedEffort.substring(1);
            }
        } catch (Exception e) {
            // Fall through to in-memory value
        }

        // Fall back to in-memory config
        if (currentReasoningConfig == null || !currentReasoningConfig.isEnabled()) {
            return "None";
        }
        String effort = currentReasoningConfig.getEffortString();
        return effort != null ? effort.substring(0, 1).toUpperCase() + effort.substring(1) : "None";
    }

    /**
     * Set the max tool calls per iteration.
     * Saves to database for persistence across sessions.
     */
    public void setMaxToolCalls(int maxToolCalls) {
        // Validate range (must be at least 1)
        if (maxToolCalls < 1) {
            maxToolCalls = 10;
        }

        // Save to database
        try {
            analysisDataService.saveMaxToolCalls(maxToolCalls);
            Msg.info(this, "Max tool calls per iteration set to: " + maxToolCalls);
        } catch (IllegalStateException e) {
            // No program loaded - just log
            Msg.info(this, "Max tool calls set to: " + maxToolCalls + " (not saved - no program loaded)");
        }
    }

    /**
     * Get the max tool calls per iteration.
     * Loads from database if available.
     */
    public int getMaxToolCalls() {
        // Try to load from database first
        try {
            return analysisDataService.getMaxToolCalls();
        } catch (Exception e) {
            // Fall back to default
            return 10;
        }
    }

    // ==== Code Analysis Operations ====
    
    public void handleExplainFunction() {
        Msg.info(this, "handleExplainFunction called, isQueryRunning=" + isQueryRunning);

        if (isQueryRunning) {
            Msg.info(this, "Query already running, cancelling...");
            cancelCurrentOperation();
            return;
        }

        Function currentFunction = plugin.getCurrentFunction();
        if (currentFunction == null) {
            Msg.showInfo(getClass(), explainTab, "No Function", "No function at current location.");
            return;
        }

        Msg.info(this, "Explaining function: " + currentFunction.getName());

        try {
            setUIState(true, "Stop", "Processing...");
        } catch (Exception e) {
            Msg.error(this, "Failed to set UI state: " + e.getMessage());
            return;
        }

        // Run in background thread (no modal dialog)
        Thread explainThread = new Thread(() -> {
            try {
                String programHash = plugin.getCurrentProgram().getExecutableSHA256();
                BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);
                long address = currentFunction.getEntryPoint().getOffset();

                // Step 1: Check if node exists with decompilation, if not extract structure
                KnowledgeNode node = graph.getNodeByAddress(address);
                boolean needsExtraction = (node == null) ||
                    (node.getRawContent() == null || node.getRawContent().isEmpty());

                if (needsExtraction) {
                    // Need to index/re-index this function
                    SwingUtilities.invokeLater(() ->
                        explainTab.setExplanationText("<html><body><i>Indexing function structure...</i></body></html>"));

                    StructureExtractor extractor = new StructureExtractor(
                            plugin.getCurrentProgram(), graph, TaskMonitor.DUMMY);
                    try {
                        node = extractor.extractFunction(currentFunction);

                        // If still no rawContent, try to get decompilation directly
                        if (node != null && (node.getRawContent() == null || node.getRawContent().isEmpty())) {
                            String decompilation = extractor.getDecompiledCode(currentFunction);
                            if (decompilation != null && !decompilation.isEmpty()) {
                                node.setRawContent(decompilation);
                                graph.upsertNode(node);
                            }
                        }
                    } finally {
                        extractor.dispose();
                    }
                }

                // Step 2: Extract security features if not present or incomplete
                boolean needsSecurityAnalysis = node != null && (
                    (node.getSecurityFlags() == null || node.getSecurityFlags().isEmpty()) ||
                    (node.getNetworkAPIs() == null || node.getNetworkAPIs().isEmpty())
                );
                if (needsSecurityAnalysis) {
                    SecurityFeatureExtractor secExtractor = new SecurityFeatureExtractor(
                            plugin.getCurrentProgram(), TaskMonitor.DUMMY);
                    // Pass decompiled code for additional API detection via regex parsing
                    String decompiledCode = node.getRawContent();
                    SecurityFeatures features = secExtractor.extractFeatures(currentFunction, decompiledCode);
                    if (features != null) {
                        node.applySecurityFeatures(features);
                    }
                }

                // Step 3: Run semantic analysis if no summary OR stale AND not user-edited
                if (node != null) {
                    boolean hasExistingSummary = node.getLlmSummary() != null && !node.getLlmSummary().isEmpty();
                    boolean isStaleAndNotEdited = node.isStale() && !node.isUserEdited();
                    boolean needsSummary = !hasExistingSummary || isStaleAndNotEdited;

                    Msg.info(this, String.format("Semantic analysis check: hasExistingSummary=%b, isStale=%b, isUserEdited=%b, needsSummary=%b",
                            hasExistingSummary, node.isStale(), node.isUserEdited(), needsSummary));

                    if (needsSummary) {
                        // Create semantic extractor
                        APIProviderConfig providerConfig = GhidrAssistPlugin.getCurrentProviderConfig();
                        if (providerConfig == null) {
                            throw new Exception("No LLM provider configured. Please configure an API provider in Analysis Options.");
                        }

                        Msg.info(this, "Creating SemanticExtractor with provider: " + providerConfig.getType());
                        SemanticExtractor semanticExtractor = new SemanticExtractor(
                                providerConfig.createProvider(), graph);

                        // Initialize streaming UI
                        // Note: StreamingMarkdownRenderer already calls invokeLater, so callback runs on EDT
                        currentExplainStreamingRenderer = new StreamingMarkdownRenderer(
                            update -> explainTab.applyRenderUpdate(update),
                            markdownHelper
                        );
                        SwingUtilities.invokeLater(() -> explainTab.initializeForStreaming(""));

                        // Use streaming summarizeNode method
                        Msg.info(this, "Calling summarizeNodeStreaming...");
                        semanticExtractor.summarizeNodeStreaming(node, new SemanticExtractor.StreamingSummaryCallback() {
                            // Track previously received content to compute deltas
                            private final StringBuilder previousContent = new StringBuilder();

                            @Override
                            public void onStart() {
                                previousContent.setLength(0);
                                Msg.info(this, "Streaming started for function explain");
                            }

                            @Override
                            public void onPartialSummary(String accumulated) {
                                if (currentExplainStreamingRenderer != null) {
                                    // Compute delta from accumulated content
                                    String prev = previousContent.toString();
                                    String delta;
                                    if (accumulated.startsWith(prev)) {
                                        delta = accumulated.substring(prev.length());
                                    } else {
                                        // Fallback: treat as new content
                                        delta = accumulated;
                                        previousContent.setLength(0);
                                    }
                                    previousContent.append(delta);

                                    if (!delta.isEmpty()) {
                                        currentExplainStreamingRenderer.onChunkReceived(delta);
                                    }
                                }
                            }

                            @Override
                            public void onSummaryComplete(String fullSummary, KnowledgeNode updatedNode) {
                                Msg.info(this, "Streaming complete for function explain");

                                // Complete streaming
                                if (currentExplainStreamingRenderer != null) {
                                    currentExplainStreamingRenderer.onStreamComplete();
                                    currentExplainStreamingRenderer = null;
                                }

                                // Mark as not stale
                                updatedNode.setStale(false);
                                graph.upsertNode(updatedNode);

                                // Update security info panel only (don't overwrite streamed content)
                                SwingUtilities.invokeLater(() -> {
                                    explainTab.setMarkdownSource(fullSummary);
                                    explainTab.updateSecurityInfo(
                                        updatedNode.getRiskLevel(),
                                        updatedNode.getActivityProfile(),
                                        updatedNode.getSecurityFlags(),
                                        updatedNode.getNetworkAPIs(),
                                        updatedNode.getFileIOAPIs()
                                    );
                                    setUIState(false, "Explain Function", null);
                                });
                            }

                            @Override
                            public void onError(Throwable error) {
                                Msg.error(this, "Streaming error: " + error.getMessage());
                                currentExplainStreamingRenderer = null;
                                SwingUtilities.invokeLater(() -> {
                                    explainTab.setExplanationText("Error: " + error.getMessage());
                                    setUIState(false, "Explain Function", null);
                                });
                            }

                            @Override
                            public boolean shouldContinue() {
                                return isQueryRunning;
                            }
                        });

                        // Return early - the callback will handle completion
                        return;
                    } else {
                        Msg.info(this, "Skipping semantic analysis - using existing summary");
                    }

                    // Step 4: Save node to graph (only reached if no summary needed)
                    graph.upsertNode(node);

                    // Step 5: Update display
                    final KnowledgeNode finalNode = node;
                    SwingUtilities.invokeLater(() -> {
                        updateExplainDisplay(finalNode);
                        setUIState(false, "Explain Function", null);
                    });
                } else {
                    SwingUtilities.invokeLater(() -> {
                        explainTab.setExplanationText("Failed to analyze function.");
                        explainTab.clearSecurityInfo();
                        setUIState(false, "Explain Function", null);
                    });
                }

            } catch (Exception e) {
                // Clean up any active streaming renderer
                if (currentExplainStreamingRenderer != null) {
                    currentExplainStreamingRenderer = null;
                }
                SwingUtilities.invokeLater(() -> {
                    Msg.showError(getClass(), explainTab, "Error",
                        "Failed to explain function: " + e.getMessage());
                    setUIState(false, "Explain Function", null);
                });
            }
        }, "GhidrAssist-ExplainFunction");

        explainThread.start();
    }

    /**
     * Update the Explain tab display with data from a KnowledgeNode.
     */
    private void updateExplainDisplay(KnowledgeNode node) {
        if (node == null) {
            explainTab.setExplanationText("");
            explainTab.clearSecurityInfo();
            return;
        }

        // Update main summary
        String summary = node.getLlmSummary();
        if (summary != null && !summary.isEmpty()) {
            explainTab.setExplanationText(markdownHelper.markdownToHtml(summary));
        } else {
            explainTab.setExplanationText("<i>No summary available. Click 'Explain Function' to analyze.</i>");
        }

        // Update security info panel
        explainTab.updateSecurityInfo(
            node.getRiskLevel(),
            node.getActivityProfile(),
            node.getSecurityFlags(),
            node.getNetworkAPIs(),
            node.getFileIOAPIs()
        );
    }

    public void handleExplainLine() {
        Msg.info(this, "handleExplainLine called, isLineQueryRunning=" + isLineQueryRunning);

        if (isLineQueryRunning) {
            Msg.info(this, "Line query already running, cancelling...");
            cancelLineExplainOperation();
            return;
        }

        Address currentAddress = plugin.getCurrentAddress();
        if (currentAddress == null) {
            Msg.showInfo(getClass(), explainTab, "No Address", "No address at current location.");
            return;
        }

        Function currentFunction = plugin.getCurrentFunction();
        if (currentFunction == null) {
            Msg.showInfo(getClass(), explainTab, "No Function", "Current address is not within a function.");
            return;
        }

        Program program = plugin.getCurrentProgram();
        if (program == null) {
            return;
        }

        String programHash = program.getExecutableSHA256();
        long lineAddress = currentAddress.getOffset();

        // Determine view type based on current location
        GhidrAssistPlugin.CodeViewType codeViewType = plugin.checkLastActiveCodeView();
        String viewType = (codeViewType == GhidrAssistPlugin.CodeViewType.IS_DECOMPILER) ? "DECOMPILER" : "DISASSEMBLY";
        Msg.info(this, "ExplainLine: Detected view type: " + viewType + " (codeViewType=" + codeViewType + ")");

        // Check cache first
        AnalysisDB.LineExplanation cached = analysisDB.getLineExplanation(programHash, lineAddress, viewType);
        if (cached != null) {
            Msg.info(this, "Using cached line explanation for address " + currentAddress);
            SwingUtilities.invokeLater(() -> {
                String html = markdownHelper.markdownToHtml(cached.getExplanation());
                explainTab.setLineExplanationText(html);
            });
            return;
        }

        // Set UI state for line explanation
        isLineQueryRunning = true;
        SwingUtilities.invokeLater(() -> {
            explainTab.setLineButtonText("Stop");
            explainTab.setLineExplanationText("<html><body><i>Extracting line context...</i></body></html>");
        });

        // Run in background thread
        Thread lineExplainThread = new Thread(() -> {
            try {
                Msg.info(this, "ExplainLine: Starting extraction for address " + currentAddress +
                         " (offset=0x" + Long.toHexString(currentAddress.getOffset()) + ")" +
                         ", viewType=" + viewType + ", function=" + currentFunction.getName());

                // Extract line context with 5 lines before/after
                CodeUtils.LineContext lineContext;

                if (viewType.equals("DECOMPILER")) {
                    Msg.info(this, "ExplainLine: Calling getDecompiledLineWithContext...");
                    lineContext = CodeUtils.getDecompiledLineWithContext(
                            currentAddress, ghidra.util.task.TaskMonitor.DUMMY, program, 5);
                } else {
                    Msg.info(this, "ExplainLine: Calling getDisassemblyLineWithContext...");
                    lineContext = CodeUtils.getDisassemblyLineWithContext(currentAddress, program, 5);
                }

                if (lineContext == null) {
                    Msg.warn(this, "ExplainLine: lineContext is NULL - extraction failed");
                    SwingUtilities.invokeLater(() -> {
                        explainTab.setLineExplanationText("<html><body><i>Could not extract code (null context). Check Ghidra console for details.</i></body></html>");
                        setLineExplainUIState(false, "Explain Line");
                    });
                    return;
                }

                if (!lineContext.isValid()) {
                    Msg.warn(this, "ExplainLine: lineContext is invalid - currentLine is empty or null");
                    Msg.warn(this, "ExplainLine: currentLine='" + lineContext.getCurrentLine() + "'");
                    SwingUtilities.invokeLater(() -> {
                        explainTab.setLineExplanationText("<html><body><i>Could not extract code (empty line). Check Ghidra console for details.</i></body></html>");
                        setLineExplainUIState(false, "Explain Line");
                    });
                    return;
                }

                Msg.info(this, "ExplainLine: SUCCESS - extracted line context:");
                Msg.info(this, "  currentLine: '" + lineContext.getCurrentLine() + "'");
                Msg.info(this, "  linesBefore (" + (lineContext.getLinesBefore() != null ? lineContext.getLinesBefore().split("\n").length : 0) + " lines)");
                Msg.info(this, "  linesAfter (" + (lineContext.getLinesAfter() != null ? lineContext.getLinesAfter().split("\n").length : 0) + " lines)");

                // Update UI to show we're generating explanation
                SwingUtilities.invokeLater(() ->
                        explainTab.setLineExplanationText("<html><body><i>Generating explanation...</i></body></html>"));

                // Generate prompt
                String prompt = ghidrassist.graphrag.extraction.ExtractionPrompts.lineExplanationPrompt(
                        lineContext.getCurrentLine(),
                        lineContext.getLinesBefore(),
                        lineContext.getLinesAfter(),
                        lineContext.getFunctionName(),
                        viewType.equals("DECOMPILER")
                );

                // Create LLM API and send request
                APIProviderConfig providerConfig = GhidrAssistPlugin.getCurrentProviderConfig();
                if (providerConfig == null) {
                    throw new Exception("No LLM provider configured.");
                }

                currentLineExplainLlmApi = new LlmApi(providerConfig, plugin);

                // Create response handler
                LlmApi.LlmResponseHandler handler = createLineExplainResponseHandler(
                        programHash,
                        currentFunction.getEntryPoint().getOffset(),
                        lineAddress,
                        viewType,
                        lineContext.getCurrentLine(),
                        lineContext.getLinesBefore(),
                        lineContext.getLinesAfter()
                );

                // Execute streaming request
                currentLineExplainLlmApi.sendRequestAsync(prompt, handler);

            } catch (Exception e) {
                Msg.error(this, "Line explanation failed: " + e.getMessage(), e);
                SwingUtilities.invokeLater(() -> {
                    explainTab.setLineExplanationText("<html><body>Error: " + e.getMessage() + "</body></html>");
                    setLineExplainUIState(false, "Explain Line");
                });
            }
        }, "GhidrAssist-ExplainLine");

        lineExplainThread.start();
    }

    /**
     * Cancel the current line explanation operation.
     */
    private void cancelLineExplainOperation() {
        if (currentLineExplainLlmApi != null) {
            currentLineExplainLlmApi.cancelCurrentRequest();
            currentLineExplainLlmApi = null;
        }

        // Clean up streaming renderer
        if (currentLineExplainStreamingRenderer != null) {
            currentLineExplainStreamingRenderer = null;
        }

        setLineExplainUIState(false, "Explain Line");
    }

    /**
     * Set the line explanation UI state.
     */
    private void setLineExplainUIState(boolean running, String buttonText) {
        isLineQueryRunning = running;
        SwingUtilities.invokeLater(() -> {
            if (explainTab != null) {
                explainTab.setLineButtonText(buttonText);
            }
        });
    }

    /**
     * Create a response handler for line explanation streaming.
     * Uses StreamingMarkdownRenderer for incremental HTML updates.
     */
    private LlmApi.LlmResponseHandler createLineExplainResponseHandler(
            String programHash, long functionAddress, long lineAddress,
            String viewType, String lineContent, String contextBefore, String contextAfter) {

        return new LlmApi.LlmResponseHandler() {
            private final StringBuilder responseBuffer = new StringBuilder();

            @Override
            public void onStart() {
                responseBuffer.setLength(0);

                // Initialize streaming for line explanation pane
                // Note: StreamingMarkdownRenderer already calls invokeLater, so callback runs on EDT
                currentLineExplainStreamingRenderer = new StreamingMarkdownRenderer(
                    update -> explainTab.applyLineRenderUpdate(update),
                    markdownHelper
                );

                SwingUtilities.invokeLater(() -> explainTab.initializeLineExplanationForStreaming());
            }

            @Override
            public void onUpdate(String partialResponse) {
                if (partialResponse == null || partialResponse.isEmpty()) {
                    return;
                }

                // Extract delta from cumulative response
                String currentBuffer = responseBuffer.toString();
                String delta;
                if (partialResponse.startsWith(currentBuffer)) {
                    delta = partialResponse.substring(currentBuffer.length());
                    responseBuffer.append(delta);
                } else {
                    delta = partialResponse;
                    responseBuffer.append(delta);
                }

                // Feed delta to streaming renderer
                if (!delta.isEmpty() && currentLineExplainStreamingRenderer != null) {
                    currentLineExplainStreamingRenderer.onChunkReceived(delta);
                }
            }

            @Override
            public void onComplete(String fullResponse) {
                final String finalResponse = (fullResponse != null && !fullResponse.isEmpty())
                        ? fullResponse : responseBuffer.toString();

                // Complete streaming
                if (currentLineExplainStreamingRenderer != null) {
                    currentLineExplainStreamingRenderer.onStreamComplete();
                    currentLineExplainStreamingRenderer = null;
                }

                // Cache the result
                analysisDB.upsertLineExplanation(
                        programHash, functionAddress, lineAddress,
                        viewType, lineContent, contextBefore, contextAfter,
                        finalResponse
                );

                SwingUtilities.invokeLater(() -> {
                    setLineExplainUIState(false, "Explain Line");
                    currentLineExplainLlmApi = null;
                });
            }

            @Override
            public void onError(Throwable error) {
                // Clean up streaming renderer
                if (currentLineExplainStreamingRenderer != null) {
                    // Try to complete with what we have
                    currentLineExplainStreamingRenderer.onStreamComplete();
                    currentLineExplainStreamingRenderer = null;
                }

                SwingUtilities.invokeLater(() -> {
                    String partialContent = responseBuffer.toString();
                    if (!partialContent.isEmpty()) {
                        String html = markdownHelper.markdownToHtml(partialContent + "\n\n[Error: " + error.getMessage() + "]");
                        explainTab.setLineExplanationText(html);
                    } else {
                        explainTab.setLineExplanationText("<html><body>Error: " + error.getMessage() + "</body></html>");
                    }
                    setLineExplainUIState(false, "Explain Line");
                    currentLineExplainLlmApi = null;
                });
            }

            @Override
            public boolean shouldContinue() {
                return isLineQueryRunning;
            }
        };
    }

    // ==== Query Operations ====

    public void handleQuerySubmit(String query, boolean useRAG, boolean useMCP, boolean useAgentic) {
        // If cancellation is in progress, ignore the click
        if (isCancelling) {
            Msg.info(this, "Cancellation in progress, please wait...");
            return;
        }

        // If a query is running, cancel it
        if (isQueryRunning) {
            cancelCurrentOperation();
            return;
        }

        // Agentic mode requires MCP tools
        if (useAgentic && !useMCP) {
            Msg.showInfo(getClass(), queryTab, "MCP Required",
                "Agentic mode requires MCP tools to be enabled.");
            return;
        }

        setUIState(true, "Stop", null);

        // Route to appropriate handler
        if (useAgentic) {
            handleAgenticQuery(query);
        } else {
            handleRegularQuery(query, useRAG, useMCP);
        }
    }

    private void handleRegularQuery(String query, boolean useRAG, boolean useMCP) {
        Task task = new Task("Query", true, true, true) {
            @Override
            public void run(TaskMonitor monitor) {
                try {
                    QueryService.QueryRequest request = queryService.createQueryRequest(query, useRAG, useMCP);

                    feedbackService.cacheLastInteraction(request.getProcessedQuery(), null);

                    // Use shared LlmApi instance for cancellation support
                    LlmApi llmApi = getCurrentLlmApi();
                    queryService.executeQuery(request, llmApi, createConversationHandler());

                } catch (Exception e) {
                    SwingUtilities.invokeLater(() -> {
                        Msg.showError(getClass(), queryTab, "Error",
                            "Failed to perform query: " + e.getMessage());
                        setUIState(false, "Submit", null);
                        currentLlmApi = null; // Clear on error
                    });
                }
            }
        };

        new TaskLauncher(task, plugin.getTool().getToolFrame());
    }

    private void handleAgenticQuery(String query) {
        // Add user query to conversation history and ensure we have a session
        try {
            String processedQuery = ghidrassist.core.QueryProcessor.processMacrosInQuery(query, plugin);
            queryService.addUserQuery(processedQuery);
        } catch (Exception e) {
            Msg.error(this, "Failed to add query to conversation history: " + e.getMessage(), e);
        }

        // Get initial context (decompiled code if available)
        final String initialContext;
        ghidra.program.model.listing.Function currentFunction = plugin.getCurrentFunction();
        if (currentFunction != null) {
            initialContext = ghidrassist.core.CodeUtils.getFunctionCode(currentFunction, ghidra.util.task.TaskMonitor.DUMMY);
        } else {
            initialContext = "";
        }

        // Container to hold iteration history so it can be accessed in the final result handler
        final StringBuilder[] historyContainer = new StringBuilder[]{new StringBuilder()};

        // Initialize MCP servers if needed
        ghidrassist.mcp2.tools.MCPToolManager toolManager =
            ghidrassist.mcp2.tools.MCPToolManager.getInstance();

        // NOTE: Program context for semantic tools is now handled via ToolRegistry
        // in ReActOrchestrator. MCPToolManager only handles MCP server tools.

        java.util.concurrent.CompletableFuture<Void> initFuture;
        if (!toolManager.isInitialized()) {
            Msg.info(this, "Initializing MCP servers for agentic analysis...");
            SwingUtilities.invokeLater(() ->
                queryTab.setResponseText("<html><body>Initializing MCP servers...</body></html>"));
            initFuture = toolManager.initializeServers();
        } else {
            initFuture = java.util.concurrent.CompletableFuture.completedFuture(null);
        }

        // Chain the analysis after MCP initialization
        initFuture.thenCompose(v -> {
            // Create ReAct orchestrator with new architecture
            int maxToolRounds = getMaxToolCalls();  // Load user's max tool calls setting
            currentOrchestrator = new ghidrassist.agent.react.ReActOrchestrator(
                    ghidrassist.GhidrAssistPlugin.getCurrentProviderConfig(),
                    plugin,
                    18,  // maxIterations
                    8000,  // contextSummaryThreshold
                    maxToolRounds  // maxToolRounds per iteration
                );

            // Create progress handler for UI updates with todos and findings support
            ghidrassist.agent.react.ReActProgressHandler progressHandler =
                createReActProgressHandler(historyContainer);

            // Start analysis asynchronously
            return currentOrchestrator.analyze(
                query,
                initialContext,
                String.valueOf(queryService.getCurrentSessionId()),
                progressHandler
            );
        }).thenAccept(result -> {
            // Display result on EDT
            SwingUtilities.invokeLater(() -> {
                // historyContainer[0] now contains the complete investigation including:
                // - All iterations and tool calls
                // - The final synthesis (streamed answer)
                // - Completion metadata (status, iterations, duration)
                // No need to append result.toMarkdown() which would duplicate the answer

                // Save ReAct analysis with proper chunking to database
                // Pass the FULL chronological history, not just summaries
                queryService.saveReActAnalysis(
                    query,
                    historyContainer[0].toString(),  // Full investigation details
                    result.getAnswer()
                );

                // Show in UI - display the full chronological history
                String html = markdownHelper.markdownToHtml(historyContainer[0].toString());
                queryTab.setResponseText(html);

                // Clear the orchestrator reference
                currentOrchestrator = null;
                setUIState(false, "Submit", null);

                // Refresh chat history to show updated timestamp
                refreshChatHistory();
            });
        }).exceptionally(error -> {
            // Handle errors on EDT - but SAVE progress first!
            String errorMsg = error.getMessage() != null ? error.getMessage() : "Unknown error";
            Msg.error(this, "Agentic analysis failed: " + errorMsg, error);

            SwingUtilities.invokeLater(() -> {
                // Save partial progress even on error/cancellation
                String partialHistory = historyContainer[0].toString();
                if (partialHistory != null && !partialHistory.isEmpty()) {
                    // Determine if this was a cancellation or error
                    boolean isCancellation = errorMsg.toLowerCase().contains("cancel");

                    String suffix = isCancellation ?
                        "\n\n---\n\n**[Analysis cancelled by user]**" :
                        "\n\n---\n\n**[Analysis failed: " + errorMsg + "]**";

                    // Save the partial investigation to database
                    queryService.saveReActAnalysis(
                        query,
                        partialHistory + suffix,
                        isCancellation ? "[Cancelled]" : "[Error: " + errorMsg + "]"
                    );

                    // Show partial progress in UI
                    String html = markdownHelper.markdownToHtml(partialHistory + suffix);
                    queryTab.setResponseText(html);

                    // Refresh chat history to show the saved session
                    refreshChatHistory();
                }

                if (!errorMsg.toLowerCase().contains("cancel")) {
                    Msg.showError(getClass(), queryTab, "Agentic Analysis Error",
                        "Analysis failed: " + errorMsg);
                }

                // Clear the orchestrator reference
                currentOrchestrator = null;
                setUIState(false, "Submit", null);
            });
            return null;
        });
    }

    // ==== Action Analysis Operations ====
    
    public void handleAnalyzeFunction(Map<String, JCheckBox> filterCheckBoxes) {
        // Refresh MCP state before analyzing
        if (queryTab != null) {
            queryTab.refreshMCPState();
        }
        
        if (isQueryRunning) {
            cancelCurrentOperation();
            return;
        }

        // Extract selected actions
        List<String> selectedActions = new ArrayList<>();
        for (Map.Entry<String, JCheckBox> entry : filterCheckBoxes.entrySet()) {
            if (entry.getValue().isSelected()) {
                selectedActions.add(entry.getKey());
            }
        }
        
        if (selectedActions.isEmpty()) {
            Msg.showInfo(getClass(), actionsTab, "No Actions Selected", 
                "Please select at least one analysis type.");
            return;
        }
        
        Function currentFunction = plugin.getCurrentFunction();
        if (currentFunction == null) {
            Msg.showInfo(getClass(), actionsTab, "No Function", 
                "No function at current location.");
            return;
        }
        
        setUIState(true, "Stop", null);
        
        try {
            ActionAnalysisService.ActionAnalysisRequest request = 
                actionAnalysisService.createAnalysisRequest(currentFunction, selectedActions);
            
            actionAnalysisService.executeActionAnalysis(request, createActionAnalysisHandler());
            
        } catch (Exception e) {
            Msg.showError(this, actionsTab, "Error", e.getMessage());
            setUIState(false, "Analyze Function", null);
        }
    }

    public void handleApplyActions(JTable actionsTable) {
        DefaultTableModel model = (DefaultTableModel) actionsTable.getModel();
        actionAnalysisService.applyActions(model, plugin.getCurrentProgram(), plugin.getCurrentAddress());
    }

    // ==== RAG Management Operations ====

    /**
     * Handle adding documents to RAG index.
     */
    public void handleAddDocuments() {
        JFileChooser fileChooser = createDocumentFileChooser();

        int result = fileChooser.showOpenDialog(ragManagementTab);
        if (result == JFileChooser.APPROVE_OPTION) {
            File[] files = fileChooser.getSelectedFiles();
            try {
                ragManagementService.addDocuments(files);
                refreshRAGDocuments();
                Msg.showInfo(this, ragManagementTab, "Success", "Documents added to RAG.");
            } catch (Exception ex) {
                Msg.showError(this, ragManagementTab, "Error",
                        "Failed to ingest documents: " + ex.getMessage());
            }
        }
    }

    /**
     * Handle deleting a single document from RAG index.
     */
    public void handleDeleteDocument(String filename) {
        if (filename == null || filename.isEmpty()) {
            Msg.showInfo(this, ragManagementTab, "No Selection",
                    "No document selected for deletion.");
            return;
        }

        int confirmation = JOptionPane.showConfirmDialog(ragManagementTab,
                "Are you sure you want to delete '" + filename + "'?",
                "Confirm Deletion", JOptionPane.YES_NO_OPTION);

        if (confirmation == JOptionPane.YES_OPTION) {
            try {
                ragManagementService.deleteDocuments(java.util.Collections.singletonList(filename));
                refreshRAGDocuments();
                Msg.showInfo(this, ragManagementTab, "Success",
                        "Document deleted from RAG.");
            } catch (Exception ex) {
                Msg.showError(this, ragManagementTab, "Error",
                        "Failed to delete document: " + ex.getMessage());
            }
        }
    }

    /**
     * Handle clearing the entire RAG index.
     */
    public void handleClearIndex() {
        int confirmation = JOptionPane.showConfirmDialog(ragManagementTab,
                "Are you sure you want to clear the entire RAG index?\nThis will delete all indexed documents.",
                "Confirm Clear Index", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);

        if (confirmation == JOptionPane.YES_OPTION) {
            try {
                ragManagementService.clearAllDocuments();
                refreshRAGDocuments();
                if (ragManagementTab != null) {
                    ragManagementTab.clearSearchResults();
                }
                Msg.showInfo(this, ragManagementTab, "Success", "RAG index cleared.");
            } catch (Exception ex) {
                Msg.showError(this, ragManagementTab, "Error",
                        "Failed to clear index: " + ex.getMessage());
            }
        }
    }

    /**
     * Refresh the document table and statistics.
     */
    public void refreshRAGDocuments() {
        if (ragManagementTab == null) {
            return;
        }
        try {
            // Get documents with metadata
            List<RAGDocumentInfo> docs = ragManagementService.getIndexedDocumentsWithInfo();
            ragManagementTab.updateDocumentTable(docs);

            // Get statistics
            RAGIndexStats stats = ragManagementService.getIndexStats();
            ragManagementTab.updateStats(
                    stats.getTotalFiles(),
                    stats.getTotalChunks(),
                    stats.getTotalEmbeddings()
            );
        } catch (Exception ex) {
            Msg.showError(this, ragManagementTab, "Error",
                    "Failed to load indexed files: " + ex.getMessage());
        }
    }

    /**
     * Handle RAG search.
     */
    public void handleRAGSearch(String query, String searchType, RAGManagementTab tab) {
        if (query == null || query.trim().isEmpty()) {
            return;
        }

        try {
            List<SearchResult> results;
            int maxResults = 10;

            switch (searchType) {
                case "Semantic":
                    results = ragManagementService.searchSemantic(query, maxResults);
                    break;
                case "Keyword":
                    results = ragManagementService.searchKeyword(query, maxResults);
                    break;
                case "Hybrid":
                default:
                    results = ragManagementService.searchHybrid(query, maxResults);
                    break;
            }

            tab.displaySearchResults(query, results, searchType);
        } catch (Exception ex) {
            Msg.showError(this, tab, "Search Error",
                    "Failed to perform search: " + ex.getMessage());
        }
    }

    // ==== Analysis Data Operations ====

    public void handleContextSave(String context) {
        try {
            analysisDataService.saveContext(context);
            Msg.showInfo(this, settingsTab, "Success", "Context saved successfully.");
        } catch (Exception e) {
            Msg.showError(this, settingsTab, "Error",
                "Failed to save context: " + e.getMessage());
        }
    }

    public void handleContextLoad() {
        try {
            String currentContext = analysisDataService.getContext();
            if (settingsTab != null) {
                settingsTab.setContextText(currentContext);
                settingsTab.loadReasoningEffort();
                settingsTab.loadMaxToolCalls();
            }
        } catch (Exception e) {
            Msg.showError(this, settingsTab, "Error",
                "Failed to load context: " + e.getMessage());
        }
    }

    public void handleContextRevert() {
        try {
            String defaultContext = analysisDataService.revertToDefaultContext();
            if (settingsTab != null) {
                settingsTab.setContextText(defaultContext);
            }
        } catch (Exception e) {
            Msg.showError(this, settingsTab, "Error",
                "Failed to revert context: " + e.getMessage());
        }
    }

    // ==== Feedback Operations ====
    
    public void handleHyperlinkEvent(HyperlinkEvent e) {
        if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
            String desc = e.getDescription();

            // Feedback links can appear when viewing old chat content.
            // In that case there may be no in-memory "latest interaction" cached yet.
            if (("thumbsup".equals(desc) || "thumbsdown".equals(desc))
                    && !feedbackService.hasPendingFeedback()) {
                Msg.showInfo(getClass(), null, "Feedback",
                    "No recent response is cached for feedback yet. Run a new query first.");
                return;
            }

            try {
                if (desc.equals("thumbsup")) {
                    feedbackService.storePositiveFeedback();
                    Msg.showInfo(getClass(), null, "Feedback", "Thank you for your positive feedback!");
                } else if (desc.equals("thumbsdown")) {
                    feedbackService.storeNegativeFeedback();
                    Msg.showInfo(getClass(), null, "Feedback", "Thank you for your feedback!");
                }
            } catch (IllegalStateException ex) {
                Msg.showInfo(getClass(), null, "Feedback", ex.getMessage());
            } catch (Exception ex) {
                Msg.showError(this, null, "Error", "Failed to store feedback: " + ex.getMessage());
            }
        }
    }

    // ==== Location Updates ====

    public void handleLocationUpdate(ProgramLocation loc) {
        if (loc != null && loc.getAddress() != null) {
            Msg.info(this, "handleLocationUpdate: address=" + loc.getAddress());
            explainTab.updateOffset(loc.getAddress().toString());
            updateAnalysisDisplay();
            updateLineExplanationDisplay(loc.getAddress());
        }
    }

    /**
     * Update the line explanation display when the cursor moves.
     * Shows cached explanation if available, otherwise clears the panel.
     */
    private void updateLineExplanationDisplay(Address address) {
        Msg.info(this, "updateLineExplanationDisplay: address=" + address);

        if (address == null || explainTab == null) {
            Msg.info(this, "updateLineExplanationDisplay: address or explainTab is null, returning");
            return;
        }

        // Don't update if a line query is currently running
        if (isLineQueryRunning) {
            Msg.info(this, "updateLineExplanationDisplay: line query running, skipping");
            return;
        }

        Program program = plugin.getCurrentProgram();
        if (program == null) {
            Msg.info(this, "updateLineExplanationDisplay: no program, clearing");
            explainTab.clearLineExplanation();
            return;
        }

        // Must be within a function
        Function function = plugin.getCurrentFunction();
        if (function == null) {
            Msg.info(this, "updateLineExplanationDisplay: no function at address, clearing");
            explainTab.clearLineExplanation();
            return;
        }

        String programHash = program.getExecutableSHA256();
        long lineAddress = address.getOffset();

        // Detect current view type
        GhidrAssistPlugin.CodeViewType codeViewType = plugin.checkLastActiveCodeView();
        String viewType = (codeViewType == GhidrAssistPlugin.CodeViewType.IS_DECOMPILER) ? "DECOMPILER" : "DISASSEMBLY";

        Msg.info(this, "updateLineExplanationDisplay: Looking up cache for hash=" + programHash.substring(0, 8) +
                 "..., address=0x" + Long.toHexString(lineAddress) + ", viewType=" + viewType);

        // Check for cached explanation for this view type
        AnalysisDB.LineExplanation cached = analysisDB.getLineExplanation(programHash, lineAddress, viewType);
        if (cached != null) {
            Msg.info(this, "updateLineExplanationDisplay: CACHE HIT - displaying cached explanation");
            String html = markdownHelper.markdownToHtml(cached.getExplanation());
            explainTab.setLineExplanationText(html);
        } else {
            Msg.info(this, "updateLineExplanationDisplay: CACHE MISS - clearing panel");
            explainTab.clearLineExplanation();
        }
    }

    public void updateAnalysis(ProgramLocation loc) {
        updateAnalysisDisplay();
    }
    
    public void handleUpdateAnalysis(String updatedContent) {
        Function function = plugin.getCurrentFunction();
        if (function == null) {
            return;
        }

        try {
            String programHash = function.getProgram().getExecutableSHA256();
            BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);
            KnowledgeNode node = graph.getNodeByAddress(function.getEntryPoint().getOffset());

            if (node == null) {
                Msg.showWarn(this, explainTab, "Not Indexed",
                    "Function not indexed. Run 'Explain Function' first.");
                return;
            }

            node.setLlmSummary(updatedContent);
            node.setUserEdited(true);  // Protect from auto-overwrite
            node.markUpdated();
            graph.upsertNode(node);
        } catch (Exception e) {
            Msg.showError(this, null, "Error", "Failed to update analysis: " + e.getMessage());
        }
    }

    public void handleClearAnalysisData() {
        Function function = plugin.getCurrentFunction();
        if (function == null) {
            return;
        }

        try {
            String programHash = function.getProgram().getExecutableSHA256();
            BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);
            KnowledgeNode node = graph.getNodeByAddress(function.getEntryPoint().getOffset());

            if (node != null) {
                node.setLlmSummary(null);
                node.setUserEdited(false);
                node.markStale();
                graph.upsertNode(node);
            }

            // Clear all line explanations for this function
            int deletedLines = analysisDB.clearLineExplanationsForFunction(
                programHash, function.getEntryPoint().getOffset()
            );
            if (deletedLines > 0) {
                Msg.info(this, "Cleared " + deletedLines + " line explanation(s) for function");
            }

            explainTab.setExplanationText("");
            explainTab.clearSecurityInfo();
        } catch (Exception e) {
            Msg.showError(this, null, "Error", "Failed to clear analysis: " + e.getMessage());
        }
    }

    // ==== State Management ====
    
    public void clearConversationHistory() {
        queryService.clearConversationHistory();
    }
    
    // ==== Chat History Management ====
    
    public void handleNewChatSession() {
        // Cancel any running operation first
        if (isQueryRunning) {
            cancelCurrentOperation();
        }
        // Clean up any active streaming renderer
        if (currentStreamingRenderer != null) {
            currentStreamingRenderer = null;
        }

        SwingUtilities.invokeLater(() -> {
            // Clear current conversation and create new session immediately
            queryService.clearConversationHistory();
            queryTab.setResponseText("");
            queryTab.clearChatSelection();
            
            // Create new session immediately instead of waiting for first query
            int newSessionId = queryService.createNewChatSession();
            if (newSessionId != -1) {
                refreshChatHistory();
                // Select the new session in the table
                java.util.List<ghidrassist.AnalysisDB.ChatSession> sessions = queryService.getChatSessions();
                for (int i = 0; i < sessions.size(); i++) {
                    if (sessions.get(i).getId() == newSessionId) {
                        queryTab.selectChatSession(i);
                        break;
                    }
                }
            }
        });
    }
    
    public void handleDeleteCurrentSession() {
        // Cancel any running operation first
        if (isQueryRunning) {
            cancelCurrentOperation();
        }
        // Clean up any active streaming renderer
        if (currentStreamingRenderer != null) {
            currentStreamingRenderer = null;
        }

        // Get all selected rows from the table (supports multi-select)
        int[] selectedRows = queryTab.getSelectedChatSessions();
        java.util.List<ghidrassist.AnalysisDB.ChatSession> sessions = queryService.getChatSessions();

        int deletedCount = 0;
        if (selectedRows != null && selectedRows.length > 0) {
            // Delete in reverse order to avoid index shifting issues
            for (int i = selectedRows.length - 1; i >= 0; i--) {
                int rowIndex = selectedRows[i];
                if (rowIndex >= 0 && rowIndex < sessions.size()) {
                    int sessionId = sessions.get(rowIndex).getId();
                    if (queryService.deleteSession(sessionId)) {
                        deletedCount++;
                    }
                }
            }
        } else {
            // Fall back to deleting current session if no table selection
            if (queryService.deleteCurrentSession()) {
                deletedCount = 1;
            }
        }

        final boolean anyDeleted = deletedCount > 0;
        SwingUtilities.invokeLater(() -> {
            if (anyDeleted) {
                queryTab.setResponseText("");
                queryTab.clearChatSelection();
                refreshChatHistory();
            } else {
                // If no session to delete, just clear the UI
                queryTab.setResponseText("");
                queryService.clearConversationHistory();
            }
        });
    }
    
    public void handleChatSessionSelection(int rowIndex) {
        java.util.List<ghidrassist.AnalysisDB.ChatSession> sessions = queryService.getChatSessions();
        if (rowIndex >= 0 && rowIndex < sessions.size()) {
            ghidrassist.AnalysisDB.ChatSession selectedSession = sessions.get(rowIndex);
            boolean success = queryService.switchToChatSession(selectedSession.getId());
            
            if (success) {
                SwingUtilities.invokeLater(() -> {
                    String conversationHistory = queryService.getConversationHistory();
                    String html = markdownHelper.markdownToHtml(conversationHistory);
                    queryTab.setResponseText(html);
                    queryTab.setMarkdownSource(conversationHistory);
                });
            }
        }
    }
    
    public void handleChatDescriptionUpdate(int rowIndex, String newDescription) {
        java.util.List<ghidrassist.AnalysisDB.ChatSession> sessions = queryService.getChatSessions();
        if (rowIndex >= 0 && rowIndex < sessions.size()) {
            ghidrassist.AnalysisDB.ChatSession session = sessions.get(rowIndex);
            queryService.updateChatDescription(session.getId(), newDescription);
        }
    }
    
    public void refreshChatHistory() {
        if (queryTab != null) {
            java.util.List<ghidrassist.AnalysisDB.ChatSession> sessions = queryService.getChatSessions();
            SwingUtilities.invokeLater(() -> {
                queryTab.updateChatHistory(sessions);
            });
        }
    }

    // ==== Chat Edit Mode Handlers ====

    /**
     * Handle when user clicks Edit button - prepare editable content
     */
    public void handleChatEditStart() {
        if (queryTab == null) {
            return;
        }

        int currentSessionId = queryService.getCurrentSessionId();
        Msg.info(this, "Edit Start: currentSessionId=" + currentSessionId);
        if (currentSessionId == -1) {
            Msg.showInfo(this, queryTab, "No Chat",
                    "No active chat session to edit.");
            queryTab.exitEditMode();
            return;
        }

        // Load messages from database if not already loaded
        queryService.loadMessagesFromDatabase();

        // Get messages for current session
        List<PersistedChatMessage> messages = queryService.getMessages();
        Msg.info(this, "Edit Start: loaded " + messages.size() + " messages from memory");

        // DEBUG: Log first few messages to see if user query is present
        for (int i = 0; i < Math.min(3, messages.size()); i++) {
            PersistedChatMessage msg = messages.get(i);
            Msg.info(this, String.format("  Message[%d]: role=%s, order=%d, content=%s",
                i, msg.getRole(), msg.getOrder(),
                msg.getContent().substring(0, Math.min(50, msg.getContent().length()))));
        }

        if (messages.isEmpty()) {
            Msg.showInfo(this, queryTab, "Empty Chat",
                    "No messages to edit in this chat.");
            queryTab.exitEditMode();
            return;
        }

        // Get chat name from sessions list
        List<AnalysisDB.ChatSession> sessions = queryService.getChatSessions();
        String chatName = "Untitled";
        for (AnalysisDB.ChatSession session : sessions) {
            if (session.getId() == currentSessionId) {
                chatName = session.getDescription();
                break;
            }
        }

        // Generate editable content with chunk markers
        String editableContent = chatEditManager.generateEditableContent(chatName, messages);
        queryTab.setEditableContent(editableContent);
    }

    /**
     * Handle when user clicks Save button - parse and apply changes
     */
    public void handleChatEditSave(String editedContent) {
        if (queryTab == null || editedContent == null) {
            Msg.info(this, "Edit Save: null queryTab or editedContent");
            return;
        }

        int currentSessionId = queryService.getCurrentSessionId();
        Msg.info(this, "Edit Save: currentSessionId=" + currentSessionId);
        if (currentSessionId == -1) {
            return;
        }

        String programHash = getProgramHash();
        Msg.info(this, "Edit Save: programHash=" + (programHash != null ? programHash.substring(0, 8) + "..." : "null"));
        if (programHash == null) {
            return;
        }

        // Detect changes
        List<ChatChange> changes = chatEditManager.parseEditedContent(editedContent);
        Msg.info(this, "Edit Save: detected " + changes.size() + " changes");
        for (ChatChange change : changes) {
            Msg.info(this, "  Change: " + change.getChangeType() + " - " + change.getChunkId());
        }

        if (!changes.isEmpty()) {
            applyChanges(programHash, currentSessionId, changes, editedContent);
            reloadCurrentChat();
        } else {
            // No changes detected - still save all messages as a full rebuild
            Msg.info(this, "Edit Save: no changes detected, performing full rebuild anyway");
            List<ChatEditManager.ExtractedMessage> finalMessages =
                    chatEditManager.extractAllMessages(editedContent);
            Msg.info(this, "Edit Save: extracted " + finalMessages.size() + " messages for rebuild");

            if (!finalMessages.isEmpty()) {
                List<PersistedChatMessage> newMessageList = new ArrayList<>();
                for (int i = 0; i < finalMessages.size(); i++) {
                    ChatEditManager.ExtractedMessage msg = finalMessages.get(i);
                    Msg.info(this, "  Saving message " + i + ": role=" + msg.role);

                    PersistedChatMessage persistedMsg = new PersistedChatMessage(
                            null, msg.role, msg.content,
                            new Timestamp(System.currentTimeMillis()), i
                    );
                    persistedMsg.setProviderType("edited");
                    persistedMsg.setMessageType("edited");
                    newMessageList.add(persistedMsg);
                }

                queryService.replaceAllMessages(newMessageList);
            }
            reloadCurrentChat();
        }
    }

    /**
     * Apply detected changes to the database
     */
    private void applyChanges(String programHash, int chatId,
                              List<ChatChange> changes, String editedContent) {
        boolean messagesUpdated = false;
        boolean titleUpdated = false;
        String newTitle = null;

        // Detect what changed
        for (ChatChange change : changes) {
            if (change.getChangeType() == ChangeType.MODIFIED) {
                if (change.isTitleChange()) {
                    titleUpdated = true;
                    newTitle = change.getNewContent();
                } else {
                    messagesUpdated = true;
                }
            } else if (change.getChangeType() == ChangeType.DELETED ||
                       change.getChangeType() == ChangeType.ADDED) {
                messagesUpdated = true;
            }
        }

        // Full rebuild from scratch
        if (messagesUpdated) {
            List<ChatEditManager.ExtractedMessage> finalMessages =
                    chatEditManager.extractAllMessages(editedContent);

            // Build new message list
            List<PersistedChatMessage> newMessageList = new ArrayList<>();
            for (int i = 0; i < finalMessages.size(); i++) {
                ChatEditManager.ExtractedMessage msg = finalMessages.get(i);

                PersistedChatMessage persistedMsg = new PersistedChatMessage(
                        null, msg.role, msg.content,
                        new Timestamp(System.currentTimeMillis()), i
                );
                persistedMsg.setProviderType("edited");
                persistedMsg.setMessageType("edited");
                newMessageList.add(persistedMsg);
            }

            // Replace all messages in memory and database atomically
            queryService.replaceAllMessages(newMessageList);
        }

        // Handle title changes
        if (titleUpdated && newTitle != null) {
            queryService.updateChatDescription(chatId, newTitle);
            refreshChatHistory();
        }
    }

    /**
     * Reload and display the current chat
     */
    private void reloadCurrentChat() {
        if (queryTab == null) {
            return;
        }

        // Get updated conversation history
        String conversationHistory = queryService.getConversationHistory();

        // Convert to HTML and display
        String html = markdownHelper.markdownToHtml(conversationHistory);
        queryTab.setResponseText(html);
        queryTab.setMarkdownSource(conversationHistory);
    }

    /**
     * Get program hash for current program
     */
    private String getProgramHash() {
        if (plugin.getCurrentProgram() != null) {
            return plugin.getCurrentProgram().getExecutableSHA256();
        }
        return null;
    }

    private String formatIndexedTimestamp(Long epochMs) {
        if (epochMs == null || epochMs <= 0) {
            return "unknown";
        }
        DateTimeFormatter formatter =
                DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").withZone(ZoneId.systemDefault());
        return formatter.format(Instant.ofEpochMilli(epochMs));
    }

    public boolean isQueryRunning() {
        return isQueryRunning;
    }

    public void setQueryRunning(boolean running) {
        this.isQueryRunning = running;
    }

    // ==== Private Helper Methods ====
    
    private LlmApi getCurrentLlmApi() throws Exception {
        APIProviderConfig config = GhidrAssistPlugin.getCurrentProviderConfig();
        if (config == null) {
            throw new Exception("No API provider configured.");
        }

        // Debug: Log current in-memory config before creating API
        if (currentReasoningConfig != null) {
            Msg.info(this, "DEBUG: In-memory reasoning config before create: " +
                currentReasoningConfig.getEffort() + ", enabled=" + currentReasoningConfig.isEnabled());
        } else {
            Msg.info(this, "DEBUG: In-memory reasoning config is NULL");
        }

        // Create new instance for this operation
        currentLlmApi = new LlmApi(config, plugin);

        // Load and apply reasoning configuration from database
        try {
            String savedEffort = analysisDataService.getReasoningEffort();
            Msg.info(this, "DEBUG: Database returned reasoning effort: " + savedEffort);
            // Only override in-memory config if we have a saved non-none value
            // Otherwise keep the current in-memory setting (e.g., when no program is loaded)
            if (savedEffort != null && !savedEffort.equalsIgnoreCase("none")) {
                currentReasoningConfig = ReasoningConfig.fromString(savedEffort);
                Msg.info(this, "DEBUG: Loaded from DB, new config: " + currentReasoningConfig.getEffort());
            } else {
                Msg.info(this, "DEBUG: Keeping in-memory config (DB returned none or null)");
            }
        } catch (Exception e) {
            // Use current in-memory config if database load fails
            Msg.info(this, "DEBUG: Database load failed: " + e.getMessage());
        }

        // Always set reasoning config (even if NONE) to ensure provider has correct state
        if (currentReasoningConfig != null) {
            Msg.info(this, "DEBUG: Setting reasoning config on LlmApi: " +
                currentReasoningConfig.getEffort() + ", enabled=" + currentReasoningConfig.isEnabled());
            currentLlmApi.setReasoningConfig(currentReasoningConfig);
        } else {
            Msg.info(this, "DEBUG: currentReasoningConfig is NULL, setting default NONE");
            currentLlmApi.setReasoningConfig(new ReasoningConfig()); // Default to NONE
        }

        // Verify it was set
        ReasoningConfig verifyConfig = currentLlmApi.getReasoningConfig();
        Msg.info(this, "DEBUG: Verified LlmApi config after set: " +
            verifyConfig.getEffort() + ", enabled=" + verifyConfig.isEnabled());

        return currentLlmApi;
    }
    
    private void cancelCurrentOperation() {
        // Mark that we're cancelling to prevent concurrent operations
        isCancelling = true;

        // Clean up streaming renderers FIRST to stop stale UI updates
        if (currentStreamingRenderer != null) {
            currentStreamingRenderer = null;
        }
        if (currentExplainStreamingRenderer != null) {
            currentExplainStreamingRenderer = null;
        }

        // Cancel the ReAct orchestrator if it exists
        if (currentOrchestrator != null) {
            currentOrchestrator.cancel();
            // Don't set to null here - let the completion handler do it
        }

        // Cancel the current LLM API instance if it exists
        if (currentLlmApi != null) {
            currentLlmApi.cancelCurrentRequest();
            // Don't set to null here - let the completion handler do it
        }

        actionAnalysisService.cancelAnalysis();

        // Update button text immediately to show cancellation is in progress
        SwingUtilities.invokeLater(() -> {
            if (queryTab != null) {
                queryTab.setSubmitButtonText("Cancelling...");
            }
        });

        // Schedule a safety reset in case the completion handlers don't fire
        // This prevents the UI from getting stuck if something goes wrong
        safetyScheduler.schedule(() -> {
            if (isCancelling) {
                Msg.warn(this, "Cancellation safety timeout - forcing UI reset");
                SwingUtilities.invokeLater(() -> {
                    isCancelling = false;
                    isQueryRunning = false;
                    currentOrchestrator = null;
                    currentLlmApi = null;
                    currentStreamingRenderer = null;
                    setUIState(false, "Submit", null);
                });
            }
        }, 5, TimeUnit.SECONDS);
    }
    
    private void setUIState(boolean running, String buttonText, String statusText) {
        isQueryRunning = running;
        // Reset cancellation flag when transitioning to non-running state
        if (!running) {
            isCancelling = false;
        }

        SwingUtilities.invokeLater(() -> {
            if (buttonText != null && explainTab != null) {
                explainTab.setFunctionButtonText(buttonText);
                explainTab.setLineButtonText(buttonText.equals("Stop") ? "Stop" : "Explain Line");
            }
            if (buttonText != null && queryTab != null) {
                queryTab.setSubmitButtonText(buttonText.equals("Stop") ? "Stop" : "Submit");
            }
            if (buttonText != null && actionsTab != null) {
                actionsTab.setAnalyzeFunctionButtonText(buttonText.equals("Stop") ? "Stop" : "Analyze Function");
            }
            if (statusText != null && explainTab != null) {
                explainTab.setExplanationText(statusText);
            }
        });
    }
    
    private void updateAnalysisDisplay() {
        Function function = plugin.getCurrentFunction();
        if (function == null) {
            explainTab.setExplanationText("");
            explainTab.clearSecurityInfo();
            return;
        }

        try {
            String programHash = function.getProgram().getExecutableSHA256();
            BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);
            KnowledgeNode node = graph.getNodeByAddress(function.getEntryPoint().getOffset());

            updateExplainDisplay(node);
        } catch (Exception e) {
            // Fall back to empty display on error
            explainTab.setExplanationText("");
            explainTab.clearSecurityInfo();
        }
    }
    
    private JFileChooser createDocumentFileChooser() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Select Documents to Add to RAG");
        fileChooser.setMultiSelectionEnabled(true);
        fileChooser.addChoosableFileFilter(
            new javax.swing.filechooser.FileNameExtensionFilter(
                "Text and Markdown Files", "txt", "md"));
        fileChooser.addChoosableFileFilter(
            new javax.swing.filechooser.FileNameExtensionFilter(
                "Source Code", "c", "h", "cpp", "hpp", "py", "java", "rs", "asm"));
        return fileChooser;
    }
    
    // ==== Response Handler Factories ====
    
    private LlmApi.LlmResponseHandler createExplainResponseHandler() {
        return new LlmApi.LlmResponseHandler() {
            @Override
            public void onStart() {
                SwingUtilities.invokeLater(() -> 
                    explainTab.setExplanationText("Processing..."));
            }

            @Override
            public void onUpdate(String partialResponse) {
                SwingUtilities.invokeLater(() -> 
                    explainTab.setExplanationText(
                        markdownHelper.markdownToHtml(partialResponse)));
            }

            @Override
            public void onComplete(String fullResponse) {
                SwingUtilities.invokeLater(() -> {
                    feedbackService.cacheLastInteraction(feedbackService.getLastPrompt(), fullResponse);
                    explainTab.setExplanationText(
                        markdownHelper.markdownToHtml(fullResponse));
                    explainTab.setMarkdownSource(fullResponse);
                    setUIState(false, "Explain Line", null);
                });
            }

            @Override
            public void onError(Throwable error) {
                SwingUtilities.invokeLater(() -> {
                    explainTab.setExplanationText("An error occurred: " + error.getMessage());
                    setUIState(false, "Explain Line", null);
                });
            }

            @Override
            public boolean shouldContinue() {
                return isQueryRunning;
            }
        };
    }
    
    private LlmApi.LlmResponseHandler createConversationHandler() {
        return new LlmApi.LlmResponseHandler() {
            private final StringBuilder responseBuffer = new StringBuilder();
            private final Object bufferLock = new Object();

            @Override
            public void onStart() {
                synchronized (bufferLock) {
                    responseBuffer.setLength(0);
                }

                // Render existing conversation history as prefix
                String existingHtml = markdownHelper.markdownToHtmlFragment(
                    queryService.getConversationHistory());

                // Create streaming renderer with callback to update UI
                // Note: StreamingMarkdownRenderer already calls invokeLater, so callback runs on EDT
                currentStreamingRenderer = new StreamingMarkdownRenderer(
                    update -> queryTab.applyRenderUpdate(update),
                    markdownHelper
                );
                currentStreamingRenderer.setConversationPrefix(existingHtml);

                // Initialize streaming display with conversation history
                SwingUtilities.invokeLater(() -> queryTab.initializeForStreaming(existingHtml));
            }

            @Override
            public void onUpdate(String partialResponse) {
                if (partialResponse == null || partialResponse.isEmpty()) {
                    return;
                }

                String delta;
                synchronized (bufferLock) {
                    // Handle cumulative vs delta responses - extract only new content
                    String currentBuffer = responseBuffer.toString();
                    if (partialResponse.startsWith(currentBuffer)) {
                        delta = partialResponse.substring(currentBuffer.length());
                        if (!delta.isEmpty()) {
                            responseBuffer.append(delta);
                        }
                    } else {
                        delta = partialResponse;
                        responseBuffer.append(delta);
                    }
                }

                // Send delta to streaming renderer for incremental processing
                if (!delta.isEmpty() && currentStreamingRenderer != null) {
                    currentStreamingRenderer.onChunkReceived(delta);
                }
            }

            @Override
            public void onComplete(String fullResponse) {
                synchronized (bufferLock) {
                    // IMPORTANT: Don't clear responseBuffer!
                    // It contains all streaming content including tool calling details.
                    // fullResponse might only contain the final text without tool call history.
                    // Only replace if fullResponse is more complete than current buffer.
                    if (fullResponse != null && fullResponse.length() > responseBuffer.length()) {
                        responseBuffer.setLength(0);
                        responseBuffer.append(fullResponse);
                    }

                    final String finalResponse = responseBuffer.toString();

                    // Signal stream complete to renderer
                    if (currentStreamingRenderer != null) {
                        currentStreamingRenderer.onStreamComplete();
                        currentStreamingRenderer = null;
                    }

                    SwingUtilities.invokeLater(() -> {
                        feedbackService.cacheLastInteraction(feedbackService.getLastPrompt(), finalResponse);
                        queryService.addAssistantResponse(finalResponse);

                        // Final markdown rendering
                        String conversationHistory = queryService.getConversationHistory();
                        String html = markdownHelper.markdownToHtml(conversationHistory);
                        queryTab.setResponseText(html);
                        queryTab.setMarkdownSource(conversationHistory);
                        setUIState(false, "Submit", null);
                        currentLlmApi = null;

                        refreshChatHistory();
                    });
                }
            }

            @Override
            public void onError(Throwable error) {
                // Clean up streaming renderer
                if (currentStreamingRenderer != null) {
                    currentStreamingRenderer = null;
                }

                // Save partial response if we have content before the error
                synchronized (bufferLock) {
                    if (responseBuffer.length() > 0) {
                        final String partialResponse = responseBuffer.toString();
                        SwingUtilities.invokeLater(() -> {
                            // Save partial response as assistant message before the error
                            queryService.addAssistantMessage(partialResponse + "\n\n[Incomplete - Error occurred]",
                                queryService.getCurrentProviderType(), null);
                        });
                    }
                }

                SwingUtilities.invokeLater(() -> {
                    queryService.addError(error.getMessage());
                    String html = markdownHelper.markdownToHtml(queryService.getConversationHistory());
                    queryTab.setResponseText(html);
                    setUIState(false, "Submit", null);
                    currentLlmApi = null;
                });
            }

            @Override
            public boolean shouldContinue() {
                // Check if we should continue - if not, save partial progress
                if (!isQueryRunning) {
                    savePartialResponseOnCancel();
                }
                return isQueryRunning;
            }

            /**
             * Save partial response when cancellation is detected.
             * This ensures we don't lose work even if the user cancels.
             */
            private void savePartialResponseOnCancel() {
                synchronized (bufferLock) {
                    if (responseBuffer.length() > 0) {
                        final String partialResponse = responseBuffer.toString();
                        // Clear buffer to prevent duplicate saves
                        responseBuffer.setLength(0);

                        // Clean up streaming renderer
                        if (currentStreamingRenderer != null) {
                            currentStreamingRenderer = null;
                        }

                        SwingUtilities.invokeLater(() -> {
                            // Save partial response
                            queryService.addAssistantMessage(partialResponse + "\n\n[Cancelled by user]",
                                queryService.getCurrentProviderType(), null);

                            // Update UI with saved content
                            String html = markdownHelper.markdownToHtml(queryService.getConversationHistory());
                            queryTab.setResponseText(html);
                            setUIState(false, "Submit", null);
                            currentLlmApi = null;

                            refreshChatHistory();
                        });
                    }
                }
            }
        };
    }
    
    private ghidrassist.agent.react.ReActProgressHandler createReActProgressHandler(final StringBuilder[] historyContainer) {
        return new ghidrassist.agent.react.ReActProgressHandler() {
            private final StringBuilder chronologicalHistory = new StringBuilder();  // Single sequential history
            private final Object historyLock = new Object();  // Protect concurrent access
            private String currentIterationOutput = "";
            private final StringBuilder synthesisBuffer = new StringBuilder();  // Separate buffer for synthesis streaming
            private boolean synthesisStarted = false;
            private int lastIterationSeen = -1;  // Start at -1 so iteration 0 triggers header
            private StreamingMarkdownRenderer synthesisRenderer = null;  // Used for synthesis phase streaming

            @Override
            public void onStart(String objective) {
                synchronized (historyLock) {
                    chronologicalHistory.setLength(0);
                    chronologicalHistory.append("# ReAct Investigation\n\n");
                    chronologicalHistory.append("**Objective**: ").append(objective).append("\n\n");
                    chronologicalHistory.append("---\n\n");
                    currentIterationOutput = "";
                    lastIterationSeen = -1;
                    synthesisBuffer.setLength(0);
                    synthesisStarted = false;
                }

                // Initialize streaming display
                SwingUtilities.invokeLater(() -> queryTab.initializeForStreaming(""));

                // Render initial state
                renderCurrentContent();
            }

            @Override
            public void onThought(String thought, int iteration) {
                synchronized (historyLock) {
                    // If this is a new iteration, archive the previous iteration
                    if (iteration > lastIterationSeen) {
                        if (!currentIterationOutput.isEmpty()) {
                            chronologicalHistory.append(currentIterationOutput).append("\n\n");
                            chronologicalHistory.append("---\n\n");
                        }
                        chronologicalHistory.append("### Iteration ").append(iteration).append("\n\n");
                        lastIterationSeen = iteration;
                        currentIterationOutput = "";
                    }
                    currentIterationOutput = thought;
                }
                // Render immediately for thought updates (they're discrete events)
                renderCurrentContent();
            }

            @Override
            public void onAction(String toolName, com.google.gson.JsonObject args) {
                // Actions are shown via streaming thought output
            }

            @Override
            public void onObservation(String toolName, String result) {
                // Observations are shown via streaming thought output
            }

            @Override
            public void onFinding(String finding) {
                synchronized (historyLock) {
                    if (!currentIterationOutput.isEmpty()) {
                        chronologicalHistory.append(currentIterationOutput).append("\n\n");
                        currentIterationOutput = "";
                    }
                    chronologicalHistory.append("💡 **Finding**: ").append(finding).append("\n\n");
                }
                renderCurrentContent();
            }

            @Override
            public void onComplete(ghidrassist.agent.react.ReActResult result) {
                // Clean up synthesis renderer if used
                synthesisRenderer = null;

                synchronized (historyLock) {
                    if (!currentIterationOutput.isEmpty()) {
                        chronologicalHistory.append(currentIterationOutput).append("\n\n");
                        chronologicalHistory.append("---\n\n");
                        currentIterationOutput = "";
                    }
                    // Archive synthesis buffer if present
                    if (synthesisBuffer.length() > 0) {
                        chronologicalHistory.append(synthesisBuffer).append("\n\n");
                    }

                    // Add completion metadata
                    chronologicalHistory.append("---\n\n");
                    chronologicalHistory.append("**Status**: ").append(result.isSuccess() ? "✓ Complete" : result.getStatus()).append("\n");
                    chronologicalHistory.append("**Iterations**: ").append(result.getIterationCount()).append("\n");
                    chronologicalHistory.append("**Tool Calls**: ").append(result.getToolCallCount()).append("\n");
                    if (result.getDuration() != null) {
                        long seconds = result.getDuration().getSeconds();
                        chronologicalHistory.append("**Duration**: ").append(seconds).append("s\n");
                    }
                    chronologicalHistory.append("\n");

                    historyContainer[0] = chronologicalHistory;
                }

                // Do a final render immediately to ensure complete content is shown
                renderCurrentContent();
            }

            @Override
            public void onError(Throwable error) {
                // Clean up synthesis renderer
                synthesisRenderer = null;

                synchronized (historyLock) {
                    chronologicalHistory.append("\n\n❌ **ERROR**: ").append(error.getMessage()).append("\n");
                }
                // Render error immediately
                renderCurrentContent();
            }

            @Override
            public boolean shouldContinue() {
                return isQueryRunning;
            }

            @Override
            public void onIterationWarning(int remaining) {
                synchronized (historyLock) {
                    chronologicalHistory.append("⚠️ *").append(remaining).append(" iteration(s) remaining*\n\n");
                }
                renderCurrentContent();
            }

            @Override
            public void onToolCallWarning(int remaining) {
                synchronized (historyLock) {
                    chronologicalHistory.append("⚠️ *").append(remaining).append(" tool call(s) remaining*\n\n");
                }
                renderCurrentContent();
            }

            @Override
            public void onTodosUpdated(String todosFormatted) {
                synchronized (historyLock) {
                    if (!currentIterationOutput.isEmpty()) {
                        chronologicalHistory.append(currentIterationOutput).append("\n\n");
                        currentIterationOutput = "";
                    }
                    chronologicalHistory.append("## 📋 Investigation Progress\n\n");
                    chronologicalHistory.append(todosFormatted).append("\n\n");
                    chronologicalHistory.append("---\n\n");
                }
                renderCurrentContent();
            }

            @Override
            public void onSummarizing(String summary) {
                synchronized (historyLock) {
                    chronologicalHistory.append("📝 **Summarizing context...**\n\n");
                    chronologicalHistory.append("```\n").append(summary).append("\n```\n\n");
                }
                renderCurrentContent();
            }

            @Override
            public void onSynthesisChunk(String chunk) {
                String delta;
                synchronized (historyLock) {
                    // Add synthesis header on first chunk
                    if (!synthesisStarted) {
                        // Archive any remaining iteration output
                        if (!currentIterationOutput.isEmpty()) {
                            chronologicalHistory.append(currentIterationOutput).append("\n\n");
                            currentIterationOutput = "";
                        }
                        chronologicalHistory.append("---\n\n");
                        chronologicalHistory.append("## 🎯 Final Analysis\n\n");
                        synthesisStarted = true;

                        // Create streaming renderer for synthesis phase with committed history as prefix
                        String prefixHtml = markdownHelper.markdownToHtmlFragment(chronologicalHistory.toString());
                        synthesisRenderer = new StreamingMarkdownRenderer(
                            update -> queryTab.applyRenderUpdate(update),
                            markdownHelper
                        );
                        synthesisRenderer.setConversationPrefix(prefixHtml);
                        SwingUtilities.invokeLater(() -> queryTab.initializeForStreaming(prefixHtml));
                    }

                    // Handle cumulative vs delta responses - extract only new content
                    String currentBuffer = synthesisBuffer.toString();
                    if (chunk.startsWith(currentBuffer)) {
                        // Cumulative response - extract delta
                        delta = chunk.substring(currentBuffer.length());
                        if (!delta.isEmpty()) {
                            synthesisBuffer.append(delta);
                        }
                    } else {
                        // Delta response - append directly
                        delta = chunk;
                        synthesisBuffer.append(delta);
                    }
                }

                // Send delta to streaming renderer for incremental processing
                if (!delta.isEmpty() && synthesisRenderer != null) {
                    synthesisRenderer.onChunkReceived(delta);
                }
            }

            /**
             * Render the current content state to the UI.
             * Used for discrete event updates (not during synthesis streaming).
             */
            private void renderCurrentContent() {
                final String content;
                synchronized (historyLock) {
                    StringBuilder display = new StringBuilder();
                    display.append(chronologicalHistory);

                    // Include current iteration output if present
                    if (!currentIterationOutput.isEmpty()) {
                        display.append(currentIterationOutput).append("\n\n");
                    }

                    // Include synthesis buffer if streaming (only if not using streaming renderer)
                    if (synthesisBuffer.length() > 0 && synthesisRenderer == null) {
                        display.append(synthesisBuffer);
                    }

                    content = display.toString();
                }

                if (content.isEmpty()) {
                    return;
                }

                SwingUtilities.invokeLater(() -> {
                    String html = markdownHelper.markdownToHtml(content);
                    queryTab.setResponseText(html);
                });
            }
        };
    }

    private ActionAnalysisService.ActionAnalysisHandler createActionAnalysisHandler() {
        return new ActionAnalysisService.ActionAnalysisHandler() {
            @Override
            public void onActionStart(String action) {
                SwingUtilities.invokeLater(() -> {
                    actionsTab.setAnalyzeFunctionButtonText("Stop");
                });
            }

            @Override
            public void onActionComplete(String action, String response) {
                SwingUtilities.invokeLater(() -> {
                    try {
                        actionAnalysisService.parseAndDisplayActions(response, actionsTab.getTableModel());
                    } catch (Exception e) {
                        Msg.showError(this, actionsTab, "Error",
                            "Failed to parse actions: " + e.getMessage());
                    }
                });
            }

            @Override
            public void onActionError(String action, Throwable error) {
                SwingUtilities.invokeLater(() -> {
                    Msg.showError(this, actionsTab, "Error", 
                        "Action " + action + " failed: " + error.getMessage());
                });
            }

            @Override
            public void onAllActionsComplete() {
                SwingUtilities.invokeLater(() -> {
                    setUIState(false, "Analyze Function", null);
                });
            }

            @Override
            public boolean shouldContinue() {
                return isQueryRunning;
            }
        };
    }
    
    // ==== Semantic Graph Tab Handlers ====

    /**
     * Update the semantic graph tab when the Ghidra cursor location changes.
     */
    public void updateSemanticGraphLocation(ProgramLocation loc) {
        if (semanticGraphTab == null || loc == null || loc.getAddress() == null) {
            return;
        }

        long address = loc.getAddress().getOffset();
        Function function = plugin.getCurrentFunction();
        String functionName = function != null ?
            ghidrassist.services.symgraph.SymGraphUtils.getQualifiedFunctionName(function) : null;

        SwingUtilities.invokeLater(() -> {
            semanticGraphTab.updateLocation(address, functionName);
        });
    }

    /**
     * Handle navigation to a function/address in the semantic graph tab.
     * Delegates to SemanticGraphController.
     */
    public void handleSemanticGraphGo(String text) {
        semanticGraphController.handleGo(text);
    }

    /**
     * Handle navigation to a specific address.
     * Delegates to SemanticGraphController.
     */
    public void handleSemanticGraphNavigate(long address) {
        semanticGraphController.handleNavigate(address);
    }

    /**
     * Navigate to an address using GoToService.
     */
    private void navigateToAddress(Address addr) {
        GoToService goToService = plugin.getTool().getService(GoToService.class);
        if (goToService != null) {
            goToService.goTo(addr);
        }
    }

    /**
     * Handle reset graph button.
     * Delegates to SemanticGraphController.
     */
    public void handleSemanticGraphReset() {
        semanticGraphController.handleReset();
    }

    /**
     * Handle reindex button with background progress.
     * Delegates to SemanticGraphController.
     */
    public void handleSemanticGraphReindex() {
        semanticGraphController.handleReindex();
    }

    /**
     * Handle refresh names button.
     * Delegates to SemanticGraphController.
     */
    public void handleSemanticGraphRefreshNames() {
        semanticGraphController.handleRefreshNames();
    }

    /**
     * Handle community detection - group related functions.
     * Delegates to SemanticGraphController.
     */
    public void handleSemanticGraphCommunityDetection() {
        semanticGraphController.handleCommunityDetection();
    }

    // ========================================
    // Analysis methods - delegated to SemanticGraphController
    // ========================================

    /**
     * Handle semantic analysis button - LLM summarization of stale nodes.
     * Delegates to SemanticGraphController.
     */
    public void handleSemanticGraphSemanticAnalysis() {
        semanticGraphController.handleSemanticAnalysis();
    }

    /**
     * Handle security analysis button - taint analysis + VULNERABLE_VIA edges.
     * Delegates to SemanticGraphController.
     */
    public void handleSemanticGraphSecurityAnalysis() {
        semanticGraphController.handleSecurityAnalysis();
    }

    /**
     * Handle network flow analysis button - trace send/recv data flow paths.
     * Delegates to SemanticGraphController.
     */
    public void handleSemanticGraphNetworkFlowAnalysis() {
        semanticGraphController.handleNetworkFlowAnalysis();
    }

    /**
     * Handle index single function button.
     * Delegates to SemanticGraphController.
     */
    public void handleSemanticGraphIndexFunction(long address) {
        semanticGraphController.handleIndexFunction(address);
    }

    /**
     * Handle list view refresh.
     * Delegates to SemanticGraphController.
     */
    public void handleSemanticGraphListViewRefresh(
            ghidrassist.ui.tabs.semanticgraph.ListViewPanel listView, long address) {
        semanticGraphController.handleListViewRefresh(listView, address);
    }

    /**
     * Handle visual graph refresh.
     * Delegates to SemanticGraphController.
     */
    public void handleSemanticGraphVisualRefresh(
            ghidrassist.ui.tabs.semanticgraph.GraphViewPanel graphView,
            long address, int nHops, java.util.Set<ghidrassist.graphrag.nodes.EdgeType> edgeTypes) {
        semanticGraphController.handleVisualRefresh(graphView, address, nHops, edgeTypes);
    }

    /**
     * Handle adding a security flag.
     * Delegates to SemanticGraphController.
     */
    public void handleSemanticGraphAddFlag(long address, String flag) {
        semanticGraphController.handleAddFlag(address, flag);
    }

    /**
     * Handle removing a security flag.
     * Delegates to SemanticGraphController.
     */
    public void handleSemanticGraphRemoveFlag(long address, String flag) {
        semanticGraphController.handleRemoveFlag(address, flag);
    }

    /**
     * Handle saving LLM summary.
     * Delegates to SemanticGraphController.
     */
    public void handleSemanticGraphSaveSummary(long address, String summary) {
        semanticGraphController.handleSaveSummary(address, summary);
    }

    /**
     * Handle edge click in list view.
     * Delegates to SemanticGraphController.
     */
    public void handleSemanticGraphEdgeClick(String targetId) {
        semanticGraphController.handleEdgeClick(targetId);
    }

    /**
     * Handle semantic graph search query.
     * Delegates to SemanticGraphController.
     */
    public void handleSemanticGraphSearchQuery(String queryType, com.google.gson.JsonObject args,
                                                java.util.function.Consumer<String> resultCallback) {
        semanticGraphController.handleSearchQuery(queryType, args, resultCallback);
    }

    // ==== SymGraph Operations (delegated to SymGraphController) ====

    /**
     * Handle SymGraph query request.
     * Delegates to SymGraphController.
     */
    public void handleSymGraphQuery() {
        symGraphController.handleQuery();
    }

    /**
     * Handle SymGraph push request.
     * Delegates to SymGraphController.
     */
    public void handleSymGraphPush(String scope, boolean pushSymbols, boolean pushGraph) {
        symGraphController.handlePush(scope, pushSymbols, pushGraph);
    }

    /**
     * Handle SymGraph pull preview request.
     * Delegates to SymGraphController.
     */
    public void handleSymGraphPullPreview() {
        symGraphController.handlePullPreview();
    }

    /**
     * Handle applying selected symbols from SymGraph.
     */
    private int getGraphCommunityCount(GraphExport export) {
        if (export == null || export.getMetadata() == null) {
            return 0;
        }
        Object countValue = export.getMetadata().get("community_count");
        if (countValue instanceof Number) {
            return ((Number) countValue).intValue();
        }
        Object communitiesValue = export.getMetadata().get("communities");
        if (communitiesValue instanceof List) {
            return ((List<?>) communitiesValue).size();
        }
        return 0;
    }

    private List<String> getListProperty(Map<String, Object> props, String key) {
        if (props == null) {
            return new ArrayList<>();
        }
        Object value = props.get(key);
        if (value instanceof List) {
            List<String> list = new ArrayList<>();
            for (Object item : (List<?>) value) {
                if (item != null) {
                    list.add(item.toString());
                }
            }
            return list;
        }
        return new ArrayList<>();
    }

    private double getDoubleProperty(Map<String, Object> props, String key, double defaultValue) {
        if (props == null) {
            return defaultValue;
        }
        Object value = props.get(key);
        if (value instanceof Number) {
            return ((Number) value).doubleValue();
        }
        return defaultValue;
    }

    private void mergeGraphData(GraphExport export, String programHash, String mergePolicy) {
        if (export == null) {
            return;
        }
        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);
        if ("replace".equals(mergePolicy)) {
            graph.clearGraph();
        }

        Map<Long, String> addressToId = new HashMap<>();
        for (GraphNode node : export.getNodes()) {
            NodeType nodeType = NodeType.fromString(node.getNodeType());
            if (nodeType == null) {
                nodeType = NodeType.FUNCTION;
            }

            KnowledgeNode existing = graph.getNodeByAddress(node.getAddress());
            if ("prefer_local".equals(mergePolicy) && existing != null) {
                addressToId.put(node.getAddress(), existing.getId());
                continue;
            }

            KnowledgeNode localNode = node.getId() != null
                    ? new KnowledgeNode(node.getId(), nodeType, programHash)
                    : new KnowledgeNode(nodeType, programHash);
            if (existing != null) {
                localNode.setId(existing.getId());
            }

            localNode.setAddress(node.getAddress());
            localNode.setName(node.getName());

            Map<String, Object> props = node.getProperties();
            String rawContent = props != null ? (String) props.get("raw_content") : null;
            if (rawContent == null && props != null) {
                rawContent = (String) props.get("raw_code");
            }
            String summary = node.getSummary();
            if (summary == null && props != null) {
                summary = (String) props.get("llm_summary");
            }

            localNode.setRawContent(rawContent);
            localNode.setLlmSummary(summary);
            localNode.setConfidence((float) getDoubleProperty(props, "confidence", 0.0));
            localNode.setSecurityFlags(getListProperty(props, "security_flags"));
            localNode.setNetworkAPIs(getListProperty(props, "network_apis"));
            localNode.setFileIOAPIs(getListProperty(props, "file_io_apis"));
            localNode.setIPAddresses(getListProperty(props, "ip_addresses"));
            localNode.setURLs(getListProperty(props, "urls"));
            localNode.setFilePaths(getListProperty(props, "file_paths"));
            localNode.setDomains(getListProperty(props, "domains"));
            localNode.setRegistryKeys(getListProperty(props, "registry_keys"));
            if (props != null) {
                localNode.setRiskLevel((String) props.get("risk_level"));
                localNode.setActivityProfile((String) props.get("activity_profile"));
                Object depth = props.get("analysis_depth");
                if (depth instanceof Number) {
                    localNode.setAnalysisDepth(((Number) depth).intValue());
                }
                Object isStale = props.get("is_stale");
                if (isStale instanceof Boolean) {
                    localNode.setStale((Boolean) isStale);
                }
                Object userEdited = props.get("user_edited");
                if (userEdited instanceof Boolean) {
                    localNode.setUserEdited((Boolean) userEdited);
                }
            }

            graph.upsertNode(localNode);
            addressToId.put(node.getAddress(), localNode.getId());
        }

        Gson gson = new Gson();
        for (GraphEdge edge : export.getEdges()) {
            String sourceId = addressToId.get(edge.getSourceAddress());
            String targetId = addressToId.get(edge.getTargetAddress());
            if (sourceId == null || targetId == null) {
                continue;
            }
            EdgeType edgeType = EdgeType.fromString(edge.getEdgeType());
            if (edgeType == null) {
                edgeType = EdgeType.CALLS;
            }
            Map<String, Object> props = edge.getProperties();
            double weight = getDoubleProperty(props, "weight", 1.0);
            String metadata = props != null ? gson.toJson(props) : null;
            graph.addEdge(sourceId, targetId, edgeType, weight, metadata);
        }
    }

    private boolean applyVariableSymbol(Function func,
            ghidrassist.services.symgraph.SymGraphModels.Symbol remoteSymbol) {
        if (remoteSymbol == null || remoteSymbol.getName() == null) {
            return false;
        }

        Map<String, Object> metadata = remoteSymbol.getMetadata();
        if (metadata == null) {
            return false;
        }

        String storageClass = (String) metadata.get("storage_class");
        String targetName = remoteSymbol.getName();

        try {
            if ("parameter".equals(storageClass)) {
                Object paramIdxObj = metadata.get("parameter_index");
                if (paramIdxObj != null) {
                    int paramIdx = ((Number) paramIdxObj).intValue();
                    ghidra.program.model.listing.Parameter[] params = func.getParameters();
                    if (paramIdx < params.length) {
                        params[paramIdx].setName(targetName,
                            ghidra.program.model.symbol.SourceType.USER_DEFINED);
                        return true;
                    }
                }
            } else if ("stack".equals(storageClass)) {
                Object stackOffsetObj = metadata.get("stack_offset");
                if (stackOffsetObj != null) {
                    int stackOffset = ((Number) stackOffsetObj).intValue();
                    for (ghidra.program.model.listing.Variable var : func.getLocalVariables()) {
                        if (var.isStackVariable()) {
                            try {
                                if (var.getStackOffset() == stackOffset) {
                                    var.setName(targetName,
                                        ghidra.program.model.symbol.SourceType.USER_DEFINED);
                                    return true;
                                }
                            } catch (UnsupportedOperationException e) {
                                // Not a simple stack var
                            }
                        }
                    }
                }
            } else if ("register".equals(storageClass)) {
                String regName = (String) metadata.get("register");
                if (regName != null) {
                    for (ghidra.program.model.listing.Variable var : func.getLocalVariables()) {
                        if (var.isRegisterVariable()) {
                            ghidra.program.model.lang.Register reg = var.getRegister();
                            if (reg != null && regName.equals(reg.getName())) {
                                var.setName(targetName,
                                    ghidra.program.model.symbol.SourceType.USER_DEFINED);
                                return true;
                            }
                        }
                    }
                }
            }
        } catch (Exception e) {
            Msg.error(this, "Error applying variable: " + e.getMessage());
        }

        return false;
    }

    public void handleSymGraphApplySelected(List<ConflictEntry> selectedConflicts) {
        symGraphController.handleApplySelected(selectedConflicts);
    }

    public void handleSymGraphApplyAllNew() {
        symGraphController.handleApplyAllNew();
    }

    public void cancelSymGraphApply() {
        symGraphController.cancelApply();
    }

    public void cancelSymGraphPull() {
        symGraphController.cancelPull();
    }

    public void updateSymGraphBinaryInfo() {
        symGraphController.updateBinaryInfo();
    }




    // ==== Cleanup ====


    public void dispose() {
        codeAnalysisService.close();
        analysisDataService.close();
        feedbackService.close();

        // Shutdown safety scheduler
        if (safetyScheduler != null) {
            safetyScheduler.shutdown();
        }
    }
}

```

`src/main/java/ghidrassist/core/UIState.java`:

```java
package ghidrassist.core;

public class UIState {
    private volatile boolean isQueryRunning;
    private int activeRunners;
    
    public UIState() {
        this.isQueryRunning = false;
        this.activeRunners = 0;
    }
    
    public synchronized boolean isQueryRunning() {
        return isQueryRunning;
    }
    
    public synchronized void setQueryRunning(boolean running) {
        this.isQueryRunning = running;
    }
    
    public synchronized void incrementRunners() {
        activeRunners++;
    }
    
    public synchronized void decrementRunners() {
        activeRunners--;
        if (activeRunners <= 0) {
            activeRunners = 0;
            isQueryRunning = false;
        }
    }
    
    public synchronized int getActiveRunners() {
        return activeRunners;
    }
}

```

`src/main/java/ghidrassist/core/WorkerExecutor.java`:

```java
package ghidrassist.core;

import ghidra.util.Msg;
import ghidrassist.workers.AnalysisWorker;
import ghidrassist.workers.ProgressUpdate;

import javax.swing.*;
import java.util.function.Consumer;

/**
 * Utility class for executing AnalysisWorker instances with standardized callback patterns.
 * Eliminates code duplication across worker setup in controllers.
 *
 * Extracted from TabController as part of decomposition refactoring.
 */
public class WorkerExecutor {

    /**
     * Interface for UI components that can show progress.
     * Controllers pass implementations to WorkerExecutor for progress feedback.
     */
    public interface ProgressUI {
        /**
         * Show progress bar with percentage and message.
         */
        void showProgress(int percentage, String message);

        /**
         * Show indeterminate progress (spinner) with message.
         */
        default void showIndeterminateProgress(String message) {
            showProgress(-1, message);
        }

        /**
         * Hide the progress indicator.
         */
        void hideProgress();

        /**
         * Set the running state for this operation.
         * @param running true if operation is starting, false if ending
         */
        void setRunning(boolean running);

        /**
         * Refresh the view after operation completes.
         */
        default void refreshView() {
            // Optional - override if needed
        }
    }

    /**
     * Configuration for worker execution.
     * Uses builder pattern for optional callbacks.
     */
    public static class ExecutionConfig<R> {
        private final AnalysisWorker<R> worker;
        private final ProgressUI ui;
        private String progressPrefix = "";
        private Consumer<R> onComplete;
        private Runnable onNextStep;
        private Consumer<String> onFailed;
        private Runnable onCancelled;
        private String operationName = "Operation";
        private String successMessage;
        private boolean showSuccessDialog = false;

        public ExecutionConfig(AnalysisWorker<R> worker, ProgressUI ui) {
            this.worker = worker;
            this.ui = ui;
        }

        /**
         * Set prefix for progress messages (e.g., "Security: ").
         */
        public ExecutionConfig<R> progressPrefix(String prefix) {
            this.progressPrefix = prefix;
            return this;
        }

        /**
         * Set callback when work completes successfully.
         */
        public ExecutionConfig<R> onComplete(Consumer<R> callback) {
            this.onComplete = callback;
            return this;
        }

        /**
         * Set callback to run next step in a chain after completion.
         */
        public ExecutionConfig<R> onNextStep(Runnable nextStep) {
            this.onNextStep = nextStep;
            return this;
        }

        /**
         * Set callback when work fails.
         */
        public ExecutionConfig<R> onFailed(Consumer<String> callback) {
            this.onFailed = callback;
            return this;
        }

        /**
         * Set callback when work is cancelled.
         */
        public ExecutionConfig<R> onCancelled(Runnable callback) {
            this.onCancelled = callback;
            return this;
        }

        /**
         * Set operation name for logging and error messages.
         */
        public ExecutionConfig<R> operationName(String name) {
            this.operationName = name;
            return this;
        }

        /**
         * Set success message to show when operation completes.
         * If set with showSuccessDialog(true), shows a dialog.
         */
        public ExecutionConfig<R> successMessage(String message) {
            this.successMessage = message;
            return this;
        }

        /**
         * Whether to show success dialog on completion.
         */
        public ExecutionConfig<R> showSuccessDialog(boolean show) {
            this.showSuccessDialog = show;
            return this;
        }
    }

    /**
     * Execute a worker with the given configuration.
     * If the worker is already running, cancels it instead.
     *
     * @param config Execution configuration
     * @return true if execution started, false if cancelled existing execution
     */
    public static <R> boolean execute(ExecutionConfig<R> config) {
        AnalysisWorker<R> worker = config.worker;
        ProgressUI ui = config.ui;

        // If already running, cancel
        if (!worker.isDone()) {
            worker.requestCancel();
            return false;
        }

        // Configure callbacks
        worker.setProgressCallback(progress -> {
            String message = config.progressPrefix.isEmpty()
                ? progress.message
                : config.progressPrefix + progress.message;
            ui.showProgress(progress.getPercentage(), message);
        });

        worker.setCompletedCallback(result -> {
            ui.hideProgress();
            ui.setRunning(false);
            ui.refreshView();

            if (config.onComplete != null) {
                config.onComplete.accept(result);
            }

            if (config.successMessage != null && config.showSuccessDialog) {
                Msg.showInfo(WorkerExecutor.class, null, config.operationName + " Complete",
                    config.successMessage);
            }

            if (config.onNextStep != null) {
                config.onNextStep.run();
            }
        });

        worker.setCancelledCallback(() -> {
            ui.hideProgress();
            ui.setRunning(false);
            ui.refreshView();

            if (config.onCancelled != null) {
                config.onCancelled.run();
            }
        });

        worker.setFailedCallback(error -> {
            ui.hideProgress();
            ui.setRunning(false);

            if (config.onFailed != null) {
                config.onFailed.accept(error);
            } else {
                Msg.showError(WorkerExecutor.class, null, "Error",
                    "Failed to run " + config.operationName.toLowerCase() + ": " + error);
            }
        });

        // Start the worker
        ui.setRunning(true);
        ui.showProgress(0, "Starting " + config.operationName.toLowerCase() + "...");
        worker.execute();
        return true;
    }

    /**
     * Simple execution with standard callbacks.
     * Convenience method for common use cases.
     *
     * @param worker Worker to execute
     * @param ui Progress UI implementation
     * @param operationName Name for logging
     * @param onComplete Callback on completion
     */
    public static <R> void executeSimple(
            AnalysisWorker<R> worker,
            ProgressUI ui,
            String operationName,
            Consumer<R> onComplete) {

        ExecutionConfig<R> config = new ExecutionConfig<>(worker, ui)
            .operationName(operationName)
            .onComplete(onComplete);

        execute(config);
    }

    /**
     * Execute a worker as part of a chain.
     * On completion, runs the next step. On failure, optionally continues the chain.
     *
     * @param worker Worker to execute
     * @param ui Progress UI implementation
     * @param operationName Name for logging
     * @param progressPrefix Prefix for progress messages
     * @param onComplete Callback on completion
     * @param nextStep Next step to run on completion
     * @param continueOnFailure Whether to run nextStep even on failure
     */
    public static <R> void executeInChain(
            AnalysisWorker<R> worker,
            ProgressUI ui,
            String operationName,
            String progressPrefix,
            Consumer<R> onComplete,
            Runnable nextStep,
            boolean continueOnFailure) {

        ExecutionConfig<R> config = new ExecutionConfig<>(worker, ui)
            .operationName(operationName)
            .progressPrefix(progressPrefix)
            .onComplete(onComplete)
            .onNextStep(nextStep);

        if (continueOnFailure && nextStep != null) {
            config.onFailed(error -> {
                Msg.warn(WorkerExecutor.class,
                    operationName + " failed: " + error + ". Continuing with next step...");
                nextStep.run();
            });
        }

        execute(config);
    }

    /**
     * Check if a worker can be started (not currently running).
     *
     * @param worker Worker to check
     * @return true if worker can be started
     */
    public static <R> boolean canStart(AnalysisWorker<R> worker) {
        return worker == null || worker.isDone();
    }

    /**
     * Cancel a worker if it's running.
     *
     * @param worker Worker to cancel
     * @return true if worker was cancelled, false if not running
     */
    public static <R> boolean cancelIfRunning(AnalysisWorker<R> worker) {
        if (worker != null && !worker.isDone()) {
            worker.requestCancel();
            return true;
        }
        return false;
    }
}

```

`src/main/java/ghidrassist/core/streaming/BlockBoundaryDetector.java`:

```java
package ghidrassist.core.streaming;

import java.util.regex.Pattern;

/**
 * Detects stable block boundaries in markdown text during streaming.
 * This allows us to identify content that is "complete" and won't be
 * reinterpreted as more text arrives.
 */
public class BlockBoundaryDetector {

    private static final Pattern ATX_HEADING = Pattern.compile("^#{1,6}\\s");
    private static final Pattern THEMATIC_BREAK = Pattern.compile("^(\\*{3,}|-{3,}|_{3,})\\s*$");
    private static final Pattern FENCE_OPEN = Pattern.compile("^(`{3,}|~{3,})");
    private static final Pattern LIST_ITEM = Pattern.compile("^(\\s*([-*+]|\\d+[.)]))\\s");
    private static final Pattern BLOCK_QUOTE = Pattern.compile("^>\\s?");
    private static final Pattern TABLE_ROW = Pattern.compile("^\\|.*\\|\\s*$");

    /**
     * Finds the last position in the pending markdown where all preceding content
     * is considered "stable" (i.e., complete blocks that won't be reinterpreted).
     *
     * @param pendingMarkdown the current pending markdown text
     * @return the index into pendingMarkdown up to which content is stable,
     *         or 0 if nothing is stable yet
     */
    public static int findLastStableBoundary(String pendingMarkdown) {
        if (pendingMarkdown.isEmpty()) {
            return 0;
        }

        String[] lines = pendingMarkdown.split("\n", -1);
        int lastStableBoundary = 0;
        int currentOffset = 0;
        boolean inFence = false;
        String fenceMarker = null;

        for (int i = 0; i < lines.length; i++) {
            String line = lines[i];
            int lineEnd = currentOffset + line.length();
            // Account for the \n that was consumed by split (except possibly the last element)
            boolean hasNewline = (lineEnd < pendingMarkdown.length());

            if (!hasNewline && i == lines.length - 1) {
                // Last line without trailing newline - potentially incomplete, never promote
                break;
            }

            if (inFence) {
                // Check if this line closes the fence
                if (isClosingFence(line, fenceMarker)) {
                    inFence = false;
                    fenceMarker = null;
                    // The fence block is now complete; boundary is after this line
                    lastStableBoundary = lineEnd + 1; // +1 for the \n
                }
                // Lines inside an unclosed fence are not stable
            } else {
                // Check for fence opening
                var fenceMatcher = FENCE_OPEN.matcher(line);
                if (fenceMatcher.find()) {
                    fenceMarker = fenceMatcher.group(1);
                    inFence = true;
                } else if (isBlockBoundary(line, i, lines)) {
                    // This line starts a new block, meaning everything before it is stable
                    // But we need the *previous* block to be complete.
                    // A blank line or block-start means the preceding block is done.
                    lastStableBoundary = lineEnd + 1; // +1 for the \n
                }
            }

            currentOffset = lineEnd + 1; // +1 for the \n
        }

        return Math.min(lastStableBoundary, pendingMarkdown.length());
    }

    private static boolean isClosingFence(String line, String fenceMarker) {
        if (fenceMarker == null) return false;
        String trimmed = line.trim();
        char fenceChar = fenceMarker.charAt(0);
        if (trimmed.isEmpty()) return false;
        // Closing fence must use same character, at least as many, and nothing else
        for (char c : trimmed.toCharArray()) {
            if (c != fenceChar) return false;
        }
        return trimmed.length() >= fenceMarker.length();
    }

    private static boolean isBlockBoundary(String line, int lineIndex, String[] lines) {
        // Table rows are never boundaries - the table stays in pending
        // until a non-table line (blank, heading, etc.) terminates it
        if (TABLE_ROW.matcher(line).matches()) {
            return false;
        }

        // Blank line is always a block boundary
        if (line.trim().isEmpty()) {
            return true;
        }

        // ATX heading
        if (ATX_HEADING.matcher(line).find()) {
            return true;
        }

        // Thematic break
        if (THEMATIC_BREAK.matcher(line).matches()) {
            return true;
        }

        // List item start
        if (LIST_ITEM.matcher(line).find()) {
            return true;
        }

        // Block quote
        if (BLOCK_QUOTE.matcher(line).find()) {
            return true;
        }

        return false;
    }
}

```

`src/main/java/ghidrassist/core/streaming/RenderUpdate.java`:

```java
package ghidrassist.core.streaming;

/**
 * Represents an update to be applied to the streaming markdown display.
 * Supports both incremental updates (append to committed, replace pending)
 * and full document replacements.
 */
public class RenderUpdate {

    public enum UpdateType {
        /** Append to committed div, replace pending div */
        INCREMENTAL,
        /** Replace entire document content */
        FULL_REPLACE
    }

    private final UpdateType type;
    private final String committedHtmlToAppend;
    private final String pendingHtml;
    private final String fullHtml;

    private RenderUpdate(UpdateType type, String committedHtmlToAppend, String pendingHtml, String fullHtml) {
        this.type = type;
        this.committedHtmlToAppend = committedHtmlToAppend;
        this.pendingHtml = pendingHtml;
        this.fullHtml = fullHtml;
    }

    /**
     * Create an incremental update that appends to committed content
     * and replaces pending content.
     *
     * @param committedHtmlToAppend HTML to append to the committed div (may be empty)
     * @param pendingHtml HTML to replace in the pending div
     * @return A new RenderUpdate for incremental application
     */
    public static RenderUpdate incremental(String committedHtmlToAppend, String pendingHtml) {
        return new RenderUpdate(UpdateType.INCREMENTAL, committedHtmlToAppend, pendingHtml, null);
    }

    /**
     * Create a full replacement update that replaces the entire document body.
     * Used at stream completion for final render.
     *
     * @param fullHtml The complete HTML content
     * @return A new RenderUpdate for full replacement
     */
    public static RenderUpdate fullReplace(String fullHtml) {
        return new RenderUpdate(UpdateType.FULL_REPLACE, null, null, fullHtml);
    }

    public UpdateType getType() {
        return type;
    }

    public String getCommittedHtmlToAppend() {
        return committedHtmlToAppend;
    }

    public String getPendingHtml() {
        return pendingHtml;
    }

    public String getFullHtml() {
        return fullHtml;
    }
}

```

`src/main/java/ghidrassist/core/streaming/StreamingMarkdownRenderer.java`:

```java
package ghidrassist.core.streaming;

import ghidrassist.core.MarkdownHelper;

import javax.swing.SwingUtilities;
import java.util.function.Consumer;

/**
 * Handles incremental markdown rendering during LLM streaming.
 * Uses a committed/pending model where stable blocks are promoted
 * to committed status for efficient DOM updates.
 */
public class StreamingMarkdownRenderer {

    private final StringBuilder committedMarkdown = new StringBuilder();
    private final StringBuilder pendingMarkdown = new StringBuilder();
    private final Consumer<RenderUpdate> updateCallback;
    private final MarkdownHelper markdownHelper;
    private String conversationPrefix = "";  // HTML for prior conversation history

    /**
     * Create a new streaming renderer.
     *
     * @param updateCallback Callback to receive render updates (called on EDT)
     * @param markdownHelper Helper for markdown-to-HTML conversion
     */
    public StreamingMarkdownRenderer(Consumer<RenderUpdate> updateCallback, MarkdownHelper markdownHelper) {
        this.updateCallback = updateCallback;
        this.markdownHelper = markdownHelper;
    }

    /**
     * Set the conversation prefix HTML that appears before streaming content.
     * This is the rendered HTML of prior conversation history.
     *
     * @param prefixHtml Pre-rendered HTML for conversation history
     */
    public void setConversationPrefix(String prefixHtml) {
        this.conversationPrefix = prefixHtml != null ? prefixHtml : "";
    }

    /**
     * Get the conversation prefix HTML.
     *
     * @return The prefix HTML
     */
    public String getConversationPrefix() {
        return conversationPrefix;
    }

    /**
     * Process a new chunk of streaming text.
     * Detects block boundaries and issues incremental or pending updates.
     *
     * @param chunk The new text chunk to process
     */
    public void onChunkReceived(String chunk) {
        if (chunk == null || chunk.isEmpty()) {
            return;
        }

        pendingMarkdown.append(chunk);

        int boundary = BlockBoundaryDetector.findLastStableBoundary(pendingMarkdown.toString());

        String committedHtmlToAppend = "";
        if (boundary > 0) {
            String stablePrefix = pendingMarkdown.substring(0, boundary);
            committedMarkdown.append(stablePrefix);
            pendingMarkdown.delete(0, boundary);

            // Parse the newly committed portion to HTML
            committedHtmlToAppend = parseMarkdownFragment(stablePrefix);
        }

        // Parse the remaining pending portion
        String pendingText = pendingMarkdown.toString();
        String pendingHtml;
        if (pendingText.isEmpty()) {
            pendingHtml = "<span></span>";
        } else {
            pendingHtml = parseMarkdownFragment(pendingText);
        }

        RenderUpdate update = RenderUpdate.incremental(committedHtmlToAppend, pendingHtml);
        SwingUtilities.invokeLater(() -> updateCallback.accept(update));
    }

    /**
     * Signal that the stream is complete.
     * Promotes all pending content and issues a full replace update.
     */
    public void onStreamComplete() {
        // Promote all remaining pending content
        committedMarkdown.append(pendingMarkdown);
        pendingMarkdown.setLength(0);

        // Do a full parse of the complete document
        String fullHtml = parseMarkdownFragment(committedMarkdown.toString());

        RenderUpdate update = RenderUpdate.fullReplace(fullHtml);
        SwingUtilities.invokeLater(() -> updateCallback.accept(update));
    }

    /**
     * Reset the renderer state for a new stream.
     */
    public void reset() {
        committedMarkdown.setLength(0);
        pendingMarkdown.setLength(0);
        conversationPrefix = "";
    }

    /**
     * Get the current accumulated markdown content (committed + pending).
     *
     * @return The full markdown text received so far
     */
    public String getCurrentMarkdown() {
        return committedMarkdown.toString() + pendingMarkdown.toString();
    }

    /**
     * Get only the committed markdown content.
     *
     * @return The committed (stable) markdown text
     */
    public String getCommittedMarkdown() {
        return committedMarkdown.toString();
    }

    /**
     * Parse a markdown fragment to HTML using the MarkdownHelper.
     * Applies table attribute post-processing for Swing compatibility.
     *
     * @param markdown The markdown to convert
     * @return The resulting HTML fragment
     */
    private String parseMarkdownFragment(String markdown) {
        if (markdown == null || markdown.isEmpty()) {
            return "";
        }

        // Use markdownHelper's parsing - get raw HTML without wrapper
        String html = markdownHelper.markdownToHtmlFragment(markdown);

        // Post-process: add HTML attributes for table rendering in Swing
        // (Swing's HTMLDocument doesn't support CSS border on td/th,
        //  but does support border/cellpadding/cellspacing attributes)
        html = html.replace("<table>", "<table border=\"1\" cellpadding=\"4\" cellspacing=\"0\">");

        return html;
    }
}

```

`src/main/java/ghidrassist/core/streaming/StreamingScrollManager.java`:

```java
package ghidrassist.core.streaming;

import javax.swing.JScrollBar;
import javax.swing.JScrollPane;

/**
 * Manages scroll position during streaming updates.
 * Auto-scrolls to bottom when user is already at bottom,
 * but preserves scroll position when user has scrolled up.
 *
 * Based on working reference implementation from java-text-widget-test.
 */
public class StreamingScrollManager {

    private static final int BOTTOM_THRESHOLD = 50;
    private final JScrollPane scrollPane;

    public StreamingScrollManager(JScrollPane scrollPane) {
        this.scrollPane = scrollPane;
    }

    /**
     * Check if the viewport is currently at the bottom (within threshold).
     *
     * @return true if scrolled to bottom
     */
    public boolean isAtBottom() {
        JScrollBar verticalBar = scrollPane.getVerticalScrollBar();
        int extent = verticalBar.getModel().getExtent();
        int maximum = verticalBar.getMaximum();
        int value = verticalBar.getValue();
        return (maximum - (value + extent)) <= BOTTOM_THRESHOLD;
    }

    /**
     * Scroll to the bottom of the content.
     */
    public void scrollToBottom() {
        JScrollBar verticalBar = scrollPane.getVerticalScrollBar();
        verticalBar.setValue(verticalBar.getMaximum());
    }

    /**
     * Get the current scroll position value.
     *
     * @return The vertical scrollbar value
     */
    public int getScrollPosition() {
        return scrollPane.getVerticalScrollBar().getValue();
    }

    /**
     * Set the scroll position value.
     *
     * @param position The position to scroll to
     */
    public void setScrollPosition(int position) {
        scrollPane.getVerticalScrollBar().setValue(position);
    }

    /**
     * Get the scroll pane for direct access.
     *
     * @return The scroll pane
     */
    public JScrollPane getScrollPane() {
        return scrollPane;
    }
}

```

`src/main/java/ghidrassist/db/migration/SchemaMigration.java`:

```java
package ghidrassist.db.migration;

import java.sql.Connection;
import java.sql.SQLException;

/**
 * Interface for database schema migrations.
 * Each migration represents a specific schema version transition.
 */
public interface SchemaMigration {

    /**
     * Get the schema version this migration produces.
     * @return Version number (must be unique and sequential)
     */
    int getVersion();

    /**
     * Get a human-readable description of this migration.
     * @return Description of what this migration does
     */
    String getDescription();

    /**
     * Apply the migration to the database.
     * Implementations should be idempotent where possible.
     *
     * @param connection The database connection
     * @throws SQLException if migration fails
     */
    void migrate(Connection connection) throws SQLException;
}

```

`src/main/java/ghidrassist/db/migration/SchemaMigrationRunner.java`:

```java
package ghidrassist.db.migration;

import ghidra.util.Msg;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

/**
 * Orchestrates database schema migrations.
 * Detects current version, applies necessary migrations, and handles errors.
 */
public class SchemaMigrationRunner {

    private final Connection connection;
    private final SchemaVersionDetector versionDetector;
    private final List<SchemaMigration> migrations;

    public SchemaMigrationRunner(Connection connection) {
        this.connection = connection;
        this.versionDetector = new SchemaVersionDetector(connection);
        this.migrations = new ArrayList<>();
        registerMigrations();
    }

    /**
     * Register all available migrations in order.
     */
    private void registerMigrations() {
        migrations.add(new V1_BaseSchema());
        migrations.add(new V2_GraphRAGCore());
        migrations.add(new V3_SecurityColumns());
        migrations.add(new V4_UserEditedColumn());
        migrations.add(new V5_UniqueAddressIndex());
        migrations.add(new V6_LineExplanations());

        // Sort by version number to ensure correct order
        migrations.sort(Comparator.comparingInt(SchemaMigration::getVersion));
    }

    /**
     * Run all pending migrations.
     * Detects current version and applies migrations sequentially.
     *
     * @throws SQLException if a critical error occurs
     */
    public void runMigrations() throws SQLException {
        int currentVersion = versionDetector.detectVersion();
        int targetVersion = getTargetVersion();

        if (currentVersion >= targetVersion) {
            Msg.info(this, "Database schema is up to date (version " + currentVersion + ")");
            return;
        }

        Msg.info(this, "Starting database migration from version " + currentVersion + " to " + targetVersion);

        // Ensure schema_migrations table exists
        ensureMigrationTable();

        for (SchemaMigration migration : migrations) {
            if (migration.getVersion() > currentVersion) {
                applyMigration(migration);
            }
        }

        Msg.info(this, "Database migration completed successfully. Version: " + getTargetVersion());
    }

    /**
     * Apply a single migration.
     * On failure, backs up affected tables and recreates them.
     *
     * @param migration The migration to apply
     * @throws SQLException if migration cannot be completed
     */
    private void applyMigration(SchemaMigration migration) throws SQLException {
        Msg.info(this, "Applying migration V" + migration.getVersion() + ": " + migration.getDescription());

        boolean autoCommit = connection.getAutoCommit();
        try {
            connection.setAutoCommit(false);

            migration.migrate(connection);

            // Update version after successful migration
            versionDetector.setUserVersion(migration.getVersion());
            recordMigration(migration);

            connection.commit();
            Msg.info(this, "Migration V" + migration.getVersion() + " completed successfully");

        } catch (SQLException e) {
            connection.rollback();
            Msg.warn(this, "Migration V" + migration.getVersion() + " failed: " + e.getMessage());

            // Attempt recovery: backup and recreate
            if (attemptRecovery(migration, e)) {
                Msg.warn(this, "Migration V" + migration.getVersion() + " recovered via backup/recreate strategy");
            } else {
                throw new SQLException("Migration V" + migration.getVersion() + " failed and recovery unsuccessful", e);
            }
        } finally {
            connection.setAutoCommit(autoCommit);
        }
    }

    /**
     * Attempt to recover from a failed migration by backing up and recreating tables.
     *
     * @param migration The failed migration
     * @param originalError The original error
     * @return true if recovery was successful
     */
    private boolean attemptRecovery(SchemaMigration migration, SQLException originalError) {
        try {
            Msg.warn(this, "Attempting recovery for migration V" + migration.getVersion());

            // For Graph-RAG migrations, backup the affected tables
            if (migration.getVersion() >= SchemaVersionDetector.VERSION_GRAPHRAG_CORE) {
                backupAndDropGraphRagTables();
            }

            // Retry the migration
            connection.setAutoCommit(false);
            migration.migrate(connection);
            versionDetector.setUserVersion(migration.getVersion());
            recordMigration(migration);
            connection.commit();

            return true;

        } catch (SQLException e) {
            Msg.error(this, "Recovery failed for migration V" + migration.getVersion() + ": " + e.getMessage(), e);
            try {
                connection.rollback();
            } catch (SQLException rollbackError) {
                Msg.error(this, "Rollback failed: " + rollbackError.getMessage());
            }
            return false;
        }
    }

    /**
     * Backup Graph-RAG tables by renaming them with _bak suffix.
     */
    private void backupAndDropGraphRagTables() throws SQLException {
        String[] graphRagTables = {"node_fts", "community_members", "graph_communities", "graph_edges", "graph_nodes"};

        // First drop triggers to avoid issues
        dropGraphNodeTriggers();

        for (String tableName : graphRagTables) {
            if (versionDetector.tableExists(tableName)) {
                String backupName = getNextBackupName(tableName);
                Msg.warn(this, "Backing up table " + tableName + " to " + backupName);

                try (Statement stmt = connection.createStatement()) {
                    // For virtual tables (FTS), just drop - can't rename
                    if (tableName.equals("node_fts")) {
                        stmt.execute("DROP TABLE IF EXISTS " + tableName);
                    } else {
                        stmt.execute("ALTER TABLE " + tableName + " RENAME TO " + backupName);
                    }
                }
            }
        }
    }

    /**
     * Drop FTS triggers.
     */
    private void dropGraphNodeTriggers() throws SQLException {
        try (Statement stmt = connection.createStatement()) {
            stmt.execute("DROP TRIGGER IF EXISTS graph_nodes_ai");
            stmt.execute("DROP TRIGGER IF EXISTS graph_nodes_ad");
            stmt.execute("DROP TRIGGER IF EXISTS graph_nodes_au");
        }
    }

    /**
     * Get next available backup name for a table.
     *
     * @param tableName Original table name
     * @return Backup table name (e.g., tablename_bak or tablename_bak_2)
     */
    private String getNextBackupName(String tableName) throws SQLException {
        String baseName = tableName + "_bak";
        if (!versionDetector.tableExists(baseName)) {
            return baseName;
        }

        int suffix = 2;
        while (versionDetector.tableExists(baseName + "_" + suffix)) {
            suffix++;
        }
        return baseName + "_" + suffix;
    }

    /**
     * Ensure the schema_migrations metadata table exists.
     */
    private void ensureMigrationTable() throws SQLException {
        String sql = "CREATE TABLE IF NOT EXISTS schema_migrations ("
                + "version INTEGER PRIMARY KEY,"
                + "description TEXT NOT NULL,"
                + "applied_at INTEGER NOT NULL"
                + ")";
        try (Statement stmt = connection.createStatement()) {
            stmt.execute(sql);
        }
    }

    /**
     * Record a completed migration in the metadata table.
     *
     * @param migration The completed migration
     */
    private void recordMigration(SchemaMigration migration) throws SQLException {
        String sql = "INSERT OR REPLACE INTO schema_migrations (version, description, applied_at) VALUES (?, ?, ?)";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setInt(1, migration.getVersion());
            stmt.setString(2, migration.getDescription());
            stmt.setLong(3, System.currentTimeMillis());
            stmt.executeUpdate();
        }
    }

    /**
     * Get the target (highest) version number.
     *
     * @return Target version
     */
    public int getTargetVersion() {
        return migrations.stream()
                .mapToInt(SchemaMigration::getVersion)
                .max()
                .orElse(0);
    }

    /**
     * Get the current database version.
     *
     * @return Current version
     * @throws SQLException on database error
     */
    public int getCurrentVersion() throws SQLException {
        return versionDetector.detectVersion();
    }

    /**
     * Check if any migrations are pending.
     *
     * @return true if migrations need to be applied
     * @throws SQLException on database error
     */
    public boolean hasPendingMigrations() throws SQLException {
        return getCurrentVersion() < getTargetVersion();
    }

    /**
     * Get list of applied migrations from the metadata table.
     *
     * @return List of applied version numbers
     */
    public List<Integer> getAppliedMigrations() {
        List<Integer> applied = new ArrayList<>();
        try {
            if (!versionDetector.tableExists("schema_migrations")) {
                return applied;
            }

            String sql = "SELECT version FROM schema_migrations ORDER BY version";
            try (Statement stmt = connection.createStatement();
                 ResultSet rs = stmt.executeQuery(sql)) {
                while (rs.next()) {
                    applied.add(rs.getInt("version"));
                }
            }
        } catch (SQLException e) {
            Msg.warn(this, "Error reading applied migrations: " + e.getMessage());
        }
        return applied;
    }
}

```

`src/main/java/ghidrassist/db/migration/SchemaVersionDetector.java`:

```java
package ghidrassist.db.migration;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.HashSet;
import java.util.Set;

/**
 * Detects the current schema version of the database.
 * Uses PRAGMA user_version first, then fingerprints by table/column existence.
 */
public class SchemaVersionDetector {

    /** Fresh database with no tables */
    public static final int VERSION_EMPTY = 0;

    /** Base schema: GHAnalysis, GHContext, GHChatHistory, GHChatMessages, etc. */
    public static final int VERSION_BASE = 1;

    /** Graph-RAG core tables without security columns */
    public static final int VERSION_GRAPHRAG_CORE = 2;

    /** Graph-RAG with security columns, without user_edited */
    public static final int VERSION_GRAPHRAG_SECURITY = 3;

    /** Current full schema with user_edited column */
    public static final int VERSION_CURRENT = 4;

    private final Connection connection;

    public SchemaVersionDetector(Connection connection) {
        this.connection = connection;
    }

    /**
     * Detect the current schema version.
     * First checks PRAGMA user_version, then uses fingerprinting for legacy databases.
     *
     * @return Detected version number
     * @throws SQLException on database error
     */
    public int detectVersion() throws SQLException {
        // First check explicit version stored in PRAGMA user_version
        int userVersion = getUserVersion();
        if (userVersion > 0) {
            return userVersion;
        }

        // Fingerprint detection for legacy databases (user_version = 0)
        return detectByFingerprint();
    }

    /**
     * Get the PRAGMA user_version value.
     *
     * @return user_version, or 0 if not set
     * @throws SQLException on database error
     */
    public int getUserVersion() throws SQLException {
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery("PRAGMA user_version")) {
            if (rs.next()) {
                return rs.getInt(1);
            }
        }
        return 0;
    }

    /**
     * Set the PRAGMA user_version value.
     *
     * @param version Version number to set
     * @throws SQLException on database error
     */
    public void setUserVersion(int version) throws SQLException {
        try (Statement stmt = connection.createStatement()) {
            stmt.execute("PRAGMA user_version = " + version);
        }
    }

    /**
     * Detect version by examining which tables and columns exist.
     * Used for databases that don't have user_version set (legacy databases).
     *
     * @return Detected version based on schema fingerprint
     * @throws SQLException on database error
     */
    private int detectByFingerprint() throws SQLException {
        // Check if any base tables exist
        if (!tableExists("GHAnalysis")) {
            return VERSION_EMPTY;
        }

        // Check if Graph-RAG tables exist
        if (!tableExists("graph_nodes")) {
            return VERSION_BASE;
        }

        // Check for security columns in graph_nodes
        Set<String> graphNodeColumns = getTableColumns("graph_nodes");

        if (!graphNodeColumns.contains("network_apis")) {
            return VERSION_GRAPHRAG_CORE;
        }

        if (!graphNodeColumns.contains("user_edited")) {
            return VERSION_GRAPHRAG_SECURITY;
        }

        return VERSION_CURRENT;
    }

    /**
     * Check if a table exists in the database.
     *
     * @param tableName Name of the table
     * @return true if table exists
     * @throws SQLException on database error
     */
    public boolean tableExists(String tableName) throws SQLException {
        String sql = "SELECT name FROM sqlite_master WHERE type='table' AND name=?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, tableName);
            try (ResultSet rs = stmt.executeQuery()) {
                return rs.next();
            }
        }
    }

    /**
     * Get the set of column names for a table.
     *
     * @param tableName Name of the table
     * @return Set of column names (lowercase)
     * @throws SQLException on database error
     */
    public Set<String> getTableColumns(String tableName) throws SQLException {
        Set<String> columns = new HashSet<>();
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery("PRAGMA table_info(" + tableName + ")")) {
            while (rs.next()) {
                columns.add(rs.getString("name").toLowerCase());
            }
        }
        return columns;
    }

    /**
     * Check if a column exists in a table.
     *
     * @param tableName Name of the table
     * @param columnName Name of the column
     * @return true if column exists
     * @throws SQLException on database error
     */
    public boolean columnExists(String tableName, String columnName) throws SQLException {
        return getTableColumns(tableName).contains(columnName.toLowerCase());
    }
}

```

`src/main/java/ghidrassist/db/migration/V1_BaseSchema.java`:

```java
package ghidrassist.db.migration;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * Migration V1: Base schema.
 * Creates the core tables: GHAnalysis, GHContext, GHChatHistory, GHChatMessages,
 * GHReActMessages, GHReActIterationChunks.
 */
public class V1_BaseSchema implements SchemaMigration {

    @Override
    public int getVersion() {
        return 1;
    }

    @Override
    public String getDescription() {
        return "Base schema with analysis, context, and chat tables";
    }

    @Override
    public void migrate(Connection connection) throws SQLException {
        try (Statement stmt = connection.createStatement()) {
            // GHAnalysis table
            stmt.execute("CREATE TABLE IF NOT EXISTS GHAnalysis ("
                    + "program_hash TEXT NOT NULL,"
                    + "function_address TEXT NOT NULL,"
                    + "query TEXT NOT NULL,"
                    + "response TEXT NOT NULL,"
                    + "timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,"
                    + "PRIMARY KEY (program_hash, function_address)"
                    + ")");

            // GHContext table
            stmt.execute("CREATE TABLE IF NOT EXISTS GHContext ("
                    + "program_hash TEXT PRIMARY KEY,"
                    + "system_context TEXT NOT NULL,"
                    + "reasoning_effort TEXT DEFAULT 'none',"
                    + "max_tool_calls INTEGER DEFAULT 10,"
                    + "timestamp DATETIME DEFAULT CURRENT_TIMESTAMP"
                    + ")");

            // Migration: Add reasoning_effort column if it doesn't exist (for upgrades)
            addColumnIfNotExists(connection, "GHContext", "reasoning_effort", "TEXT DEFAULT 'none'");

            // Migration: Add max_tool_calls column if it doesn't exist (for upgrades)
            addColumnIfNotExists(connection, "GHContext", "max_tool_calls", "INTEGER DEFAULT 10");

            // GHChatHistory table
            stmt.execute("CREATE TABLE IF NOT EXISTS GHChatHistory ("
                    + "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                    + "program_hash TEXT NOT NULL,"
                    + "description TEXT NOT NULL,"
                    + "conversation TEXT NOT NULL,"
                    + "last_update DATETIME DEFAULT CURRENT_TIMESTAMP"
                    + ")");

            // GHChatMessages table
            stmt.execute("CREATE TABLE IF NOT EXISTS GHChatMessages ("
                    + "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                    + "program_hash TEXT NOT NULL,"
                    + "chat_id INTEGER NOT NULL,"
                    + "message_order INTEGER NOT NULL,"
                    + "provider_type TEXT NOT NULL,"
                    + "native_message_data TEXT NOT NULL,"
                    + "role TEXT NOT NULL,"
                    + "content_text TEXT,"
                    + "message_type TEXT DEFAULT 'standard',"
                    + "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,"
                    + "updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,"
                    + "UNIQUE(program_hash, chat_id, message_order),"
                    + "FOREIGN KEY (chat_id) REFERENCES GHChatHistory(id) ON DELETE CASCADE"
                    + ")");

            stmt.execute("CREATE INDEX IF NOT EXISTS idx_chat_messages_lookup "
                    + "ON GHChatMessages(program_hash, chat_id, message_order)");
            stmt.execute("CREATE INDEX IF NOT EXISTS idx_chat_messages_role "
                    + "ON GHChatMessages(role)");

            // GHReActMessages table
            stmt.execute("CREATE TABLE IF NOT EXISTS GHReActMessages ("
                    + "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                    + "program_hash TEXT NOT NULL,"
                    + "session_id INTEGER NOT NULL,"
                    + "message_order INTEGER NOT NULL,"
                    + "phase TEXT NOT NULL,"
                    + "iteration_number INTEGER,"
                    + "role TEXT NOT NULL,"
                    + "content_text TEXT,"
                    + "native_message_data TEXT,"
                    + "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,"
                    + "UNIQUE(program_hash, session_id, message_order),"
                    + "FOREIGN KEY (session_id) REFERENCES GHChatHistory(id) ON DELETE CASCADE"
                    + ")");

            stmt.execute("CREATE INDEX IF NOT EXISTS idx_react_messages_lookup "
                    + "ON GHReActMessages(program_hash, session_id, phase, iteration_number)");
            stmt.execute("CREATE INDEX IF NOT EXISTS idx_react_messages_order "
                    + "ON GHReActMessages(session_id, message_order)");

            // GHReActIterationChunks table
            stmt.execute("CREATE TABLE IF NOT EXISTS GHReActIterationChunks ("
                    + "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                    + "program_hash TEXT NOT NULL,"
                    + "session_id INTEGER NOT NULL,"
                    + "iteration_number INTEGER NOT NULL,"
                    + "iteration_summary TEXT,"
                    + "message_start_index INTEGER NOT NULL,"
                    + "message_end_index INTEGER NOT NULL,"
                    + "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,"
                    + "UNIQUE(program_hash, session_id, iteration_number),"
                    + "FOREIGN KEY (session_id) REFERENCES GHChatHistory(id) ON DELETE CASCADE"
                    + ")");

            stmt.execute("CREATE INDEX IF NOT EXISTS idx_react_chunks_lookup "
                    + "ON GHReActIterationChunks(program_hash, session_id, iteration_number)");
        }
    }

    /**
     * Add a column to a table if it doesn't exist.
     * Uses try-catch to handle "duplicate column" errors silently.
     */
    private void addColumnIfNotExists(Connection connection, String tableName,
                                       String columnName, String columnDef) throws SQLException {
        try (Statement stmt = connection.createStatement()) {
            stmt.execute("ALTER TABLE " + tableName + " ADD COLUMN " + columnName + " " + columnDef);
        } catch (SQLException e) {
            // Column already exists, ignore
            if (!e.getMessage().contains("duplicate column")) {
                throw e;
            }
        }
    }
}

```

`src/main/java/ghidrassist/db/migration/V2_GraphRAGCore.java`:

```java
package ghidrassist.db.migration;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * Migration V2: Graph-RAG core tables.
 * Creates: graph_nodes (base columns), graph_edges, graph_communities,
 * community_members, node_fts (FTS5), and FTS triggers.
 */
public class V2_GraphRAGCore implements SchemaMigration {

    @Override
    public int getVersion() {
        return 2;
    }

    @Override
    public String getDescription() {
        return "Graph-RAG knowledge graph core tables";
    }

    @Override
    public void migrate(Connection connection) throws SQLException {
        try (Statement stmt = connection.createStatement()) {
            // graph_nodes table (base columns without security features)
            stmt.execute("CREATE TABLE IF NOT EXISTS graph_nodes ("
                    + "id TEXT PRIMARY KEY,"
                    + "type TEXT NOT NULL,"
                    + "address INTEGER,"
                    + "binary_id TEXT NOT NULL,"
                    + "name TEXT,"
                    + "raw_content TEXT,"
                    + "llm_summary TEXT,"
                    + "confidence REAL DEFAULT 0.0,"
                    + "embedding BLOB,"
                    + "security_flags TEXT,"
                    + "analysis_depth INTEGER DEFAULT 0,"
                    + "created_at INTEGER,"
                    + "updated_at INTEGER,"
                    + "is_stale INTEGER DEFAULT 0"
                    + ")");

            stmt.execute("CREATE INDEX IF NOT EXISTS idx_nodes_address ON graph_nodes(address)");
            stmt.execute("CREATE INDEX IF NOT EXISTS idx_nodes_type ON graph_nodes(type)");
            stmt.execute("CREATE INDEX IF NOT EXISTS idx_nodes_binary ON graph_nodes(binary_id)");
            stmt.execute("CREATE INDEX IF NOT EXISTS idx_nodes_name ON graph_nodes(name)");
            stmt.execute("CREATE INDEX IF NOT EXISTS idx_nodes_stale ON graph_nodes(binary_id, is_stale)");

            // graph_edges table
            stmt.execute("CREATE TABLE IF NOT EXISTS graph_edges ("
                    + "id TEXT PRIMARY KEY,"
                    + "source_id TEXT NOT NULL,"
                    + "target_id TEXT NOT NULL,"
                    + "type TEXT NOT NULL,"
                    + "weight REAL DEFAULT 1.0,"
                    + "metadata TEXT,"
                    + "created_at INTEGER,"
                    + "FOREIGN KEY (source_id) REFERENCES graph_nodes(id) ON DELETE CASCADE,"
                    + "FOREIGN KEY (target_id) REFERENCES graph_nodes(id) ON DELETE CASCADE"
                    + ")");

            stmt.execute("CREATE INDEX IF NOT EXISTS idx_edges_source ON graph_edges(source_id)");
            stmt.execute("CREATE INDEX IF NOT EXISTS idx_edges_target ON graph_edges(target_id)");
            stmt.execute("CREATE INDEX IF NOT EXISTS idx_edges_type ON graph_edges(type)");
            stmt.execute("CREATE INDEX IF NOT EXISTS idx_edges_source_type ON graph_edges(source_id, type)");

            // graph_communities table
            stmt.execute("CREATE TABLE IF NOT EXISTS graph_communities ("
                    + "id TEXT PRIMARY KEY,"
                    + "level INTEGER NOT NULL,"
                    + "binary_id TEXT NOT NULL,"
                    + "parent_community_id TEXT,"
                    + "name TEXT,"
                    + "summary TEXT,"
                    + "member_count INTEGER DEFAULT 0,"
                    + "is_stale INTEGER DEFAULT 1,"
                    + "created_at INTEGER,"
                    + "updated_at INTEGER,"
                    + "FOREIGN KEY (parent_community_id) REFERENCES graph_communities(id) ON DELETE SET NULL"
                    + ")");

            stmt.execute("CREATE INDEX IF NOT EXISTS idx_communities_binary ON graph_communities(binary_id)");
            stmt.execute("CREATE INDEX IF NOT EXISTS idx_communities_level ON graph_communities(level)");
            stmt.execute("CREATE INDEX IF NOT EXISTS idx_communities_parent ON graph_communities(parent_community_id)");

            // community_members table
            stmt.execute("CREATE TABLE IF NOT EXISTS community_members ("
                    + "community_id TEXT NOT NULL,"
                    + "node_id TEXT NOT NULL,"
                    + "membership_score REAL DEFAULT 1.0,"
                    + "PRIMARY KEY (community_id, node_id),"
                    + "FOREIGN KEY (community_id) REFERENCES graph_communities(id) ON DELETE CASCADE,"
                    + "FOREIGN KEY (node_id) REFERENCES graph_nodes(id) ON DELETE CASCADE"
                    + ")");

            stmt.execute("CREATE INDEX IF NOT EXISTS idx_community_members_node ON community_members(node_id)");

            // FTS5 virtual table for semantic search
            // Check if it exists first (FTS5 doesn't support IF NOT EXISTS)
            ResultSet rs = stmt.executeQuery(
                    "SELECT name FROM sqlite_master WHERE type='table' AND name='node_fts'");
            if (!rs.next()) {
                stmt.execute("CREATE VIRTUAL TABLE node_fts USING fts5("
                        + "id, "
                        + "name, "
                        + "llm_summary, "
                        + "security_flags, "
                        + "content='graph_nodes', "
                        + "content_rowid='rowid'"
                        + ")");
            }
            rs.close();

            // FTS triggers for synchronization
            stmt.execute("CREATE TRIGGER IF NOT EXISTS graph_nodes_ai AFTER INSERT ON graph_nodes BEGIN "
                    + "INSERT INTO node_fts(rowid, id, name, llm_summary, security_flags) "
                    + "VALUES (NEW.rowid, NEW.id, NEW.name, NEW.llm_summary, NEW.security_flags); "
                    + "END");

            stmt.execute("CREATE TRIGGER IF NOT EXISTS graph_nodes_ad AFTER DELETE ON graph_nodes BEGIN "
                    + "INSERT INTO node_fts(node_fts, rowid, id, name, llm_summary, security_flags) "
                    + "VALUES ('delete', OLD.rowid, OLD.id, OLD.name, OLD.llm_summary, OLD.security_flags); "
                    + "END");

            stmt.execute("CREATE TRIGGER IF NOT EXISTS graph_nodes_au AFTER UPDATE ON graph_nodes BEGIN "
                    + "INSERT INTO node_fts(node_fts, rowid, id, name, llm_summary, security_flags) "
                    + "VALUES ('delete', OLD.rowid, OLD.id, OLD.name, OLD.llm_summary, OLD.security_flags); "
                    + "INSERT INTO node_fts(rowid, id, name, llm_summary, security_flags) "
                    + "VALUES (NEW.rowid, NEW.id, NEW.name, NEW.llm_summary, NEW.security_flags); "
                    + "END");
        }
    }
}

```

`src/main/java/ghidrassist/db/migration/V3_SecurityColumns.java`:

```java
package ghidrassist.db.migration;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * Migration V3: Security analysis columns.
 * Adds security-related columns to graph_nodes table for detailed
 * security profiling of code entities.
 */
public class V3_SecurityColumns implements SchemaMigration {

    @Override
    public int getVersion() {
        return 3;
    }

    @Override
    public String getDescription() {
        return "Add security analysis columns to graph_nodes";
    }

    @Override
    public void migrate(Connection connection) throws SQLException {
        // Security detail columns to add
        String[] securityColumns = {
            "network_apis TEXT",
            "file_io_apis TEXT",
            "ip_addresses TEXT",
            "urls TEXT",
            "file_paths TEXT",
            "domains TEXT",
            "registry_keys TEXT",
            "risk_level TEXT",
            "activity_profile TEXT"
        };

        for (String columnDef : securityColumns) {
            addColumnIfNotExists(connection, "graph_nodes", columnDef);
        }
    }

    /**
     * Add a column to a table if it doesn't exist.
     * Uses try-catch to handle "duplicate column" errors silently.
     */
    private void addColumnIfNotExists(Connection connection, String tableName,
                                       String columnDef) throws SQLException {
        try (Statement stmt = connection.createStatement()) {
            stmt.execute("ALTER TABLE " + tableName + " ADD COLUMN " + columnDef);
        } catch (SQLException e) {
            // Column already exists, ignore
            if (!e.getMessage().contains("duplicate column")) {
                throw e;
            }
        }
    }
}

```

`src/main/java/ghidrassist/db/migration/V4_UserEditedColumn.java`:

```java
package ghidrassist.db.migration;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * Migration V4: User edited column.
 * Adds user_edited column to graph_nodes to protect LLM summaries
 * from being auto-overwritten when manually edited by user.
 */
public class V4_UserEditedColumn implements SchemaMigration {

    @Override
    public int getVersion() {
        return 4;
    }

    @Override
    public String getDescription() {
        return "Add user_edited column to graph_nodes";
    }

    @Override
    public void migrate(Connection connection) throws SQLException {
        try (Statement stmt = connection.createStatement()) {
            stmt.execute("ALTER TABLE graph_nodes ADD COLUMN user_edited INTEGER DEFAULT 0");
        } catch (SQLException e) {
            // Column already exists, ignore
            if (!e.getMessage().contains("duplicate column")) {
                throw e;
            }
        }
    }
}

```

`src/main/java/ghidrassist/db/migration/V5_UniqueAddressIndex.java`:

```java
package ghidrassist.db.migration;

import ghidra.util.Msg;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * Migration V5: Unique address index.
 * Adds a unique index on (binary_id, address) to prevent duplicate nodes
 * with the same address during parallel extraction.
 * Also cleans up any existing duplicate nodes.
 */
public class V5_UniqueAddressIndex implements SchemaMigration {

    @Override
    public int getVersion() {
        return 5;
    }

    @Override
    public String getDescription() {
        return "Add unique index on (binary_id, address) to prevent duplicate nodes";
    }

    @Override
    public void migrate(Connection connection) throws SQLException {
        try (Statement stmt = connection.createStatement()) {
            // First, clean up any existing duplicate nodes
            // Keep the node with the most edges (most likely to be the "correct" one)
            int duplicatesRemoved = cleanupDuplicateNodes(connection);
            if (duplicatesRemoved > 0) {
                Msg.info(this, "Cleaned up " + duplicatesRemoved + " duplicate nodes");
            }

            // Create unique partial index (only for non-null addresses)
            // SQLite supports partial indexes with WHERE clause
            stmt.execute("CREATE UNIQUE INDEX IF NOT EXISTS idx_graph_nodes_binary_address "
                    + "ON graph_nodes(binary_id, address) WHERE address IS NOT NULL");
        }
    }

    /**
     * Clean up duplicate nodes with the same (binary_id, address).
     * For each set of duplicates, keep the one with the most edge references.
     *
     * @param connection Database connection
     * @return Number of duplicate nodes removed
     */
    private int cleanupDuplicateNodes(Connection connection) throws SQLException {
        int totalRemoved = 0;

        try (Statement stmt = connection.createStatement()) {
            // Find all addresses with duplicates
            String findDuplicatesSql = "SELECT binary_id, address, COUNT(*) as cnt "
                    + "FROM graph_nodes "
                    + "WHERE address IS NOT NULL "
                    + "GROUP BY binary_id, address "
                    + "HAVING cnt > 1";

            ResultSet duplicates = stmt.executeQuery(findDuplicatesSql);

            while (duplicates.next()) {
                String binaryId = duplicates.getString("binary_id");
                long address = duplicates.getLong("address");

                // For each duplicate set, find the node with most edges
                String findBestNodeSql = "SELECT n.id, "
                        + "(SELECT COUNT(*) FROM graph_edges e WHERE e.source_id = n.id OR e.target_id = n.id) as edge_count "
                        + "FROM graph_nodes n "
                        + "WHERE n.binary_id = '" + binaryId.replace("'", "''") + "' "
                        + "AND n.address = " + address + " "
                        + "ORDER BY edge_count DESC "
                        + "LIMIT 1";

                try (Statement findStmt = connection.createStatement();
                     ResultSet best = findStmt.executeQuery(findBestNodeSql)) {

                    if (best.next()) {
                        String keepId = best.getString("id");

                        // Delete all other nodes with same binary_id and address
                        String deleteOthersSql = "DELETE FROM graph_nodes "
                                + "WHERE binary_id = '" + binaryId.replace("'", "''") + "' "
                                + "AND address = " + address + " "
                                + "AND id != '" + keepId.replace("'", "''") + "'";

                        try (Statement deleteStmt = connection.createStatement()) {
                            int deleted = deleteStmt.executeUpdate(deleteOthersSql);
                            totalRemoved += deleted;
                        }
                    }
                }
            }
        }

        return totalRemoved;
    }
}

```

`src/main/java/ghidrassist/db/migration/V6_LineExplanations.java`:

```java
package ghidrassist.db.migration;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * Migration V6: Line Explanations table.
 * Creates table for caching line-level explanations from decompiler/disassembly views.
 */
public class V6_LineExplanations implements SchemaMigration {

    @Override
    public int getVersion() {
        return 6;
    }

    @Override
    public String getDescription() {
        return "Add line_explanations table for per-line analysis cache";
    }

    @Override
    public void migrate(Connection connection) throws SQLException {
        try (Statement stmt = connection.createStatement()) {
            stmt.execute(
                "CREATE TABLE IF NOT EXISTS line_explanations (" +
                "    id INTEGER PRIMARY KEY AUTOINCREMENT," +
                "    binary_id TEXT NOT NULL," +
                "    function_address INTEGER NOT NULL," +
                "    line_address INTEGER NOT NULL," +
                "    view_type TEXT NOT NULL," +  // 'DECOMPILER' or 'DISASSEMBLY'
                "    line_content TEXT," +
                "    context_before TEXT," +
                "    context_after TEXT," +
                "    explanation TEXT NOT NULL," +
                "    created_at INTEGER NOT NULL," +
                "    updated_at INTEGER NOT NULL," +
                "    UNIQUE(binary_id, line_address, view_type)" +
                ")"
            );

            // Create index for efficient lookups
            stmt.execute(
                "CREATE INDEX IF NOT EXISTS idx_line_explanations_lookup " +
                "ON line_explanations(binary_id, line_address, view_type)"
            );

            // Create index for function-level operations (clear all lines for a function)
            stmt.execute(
                "CREATE INDEX IF NOT EXISTS idx_line_explanations_function " +
                "ON line_explanations(binary_id, function_address)"
            );
        }
    }
}

```

`src/main/java/ghidrassist/graphrag/BinaryKnowledgeGraph.java`:

```java
package ghidrassist.graphrag;

import ghidra.util.Msg;
import ghidrassist.AnalysisDB;
import ghidrassist.graphrag.nodes.EdgeType;
import ghidrassist.graphrag.nodes.KnowledgeNode;
import ghidrassist.graphrag.nodes.NodeType;

import org.jgrapht.Graph;
import org.jgrapht.graph.DefaultDirectedGraph;
import org.jgrapht.graph.DefaultEdge;
import org.jgrapht.traverse.BreadthFirstIterator;

import java.sql.*;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Core storage layer for the Binary Knowledge Graph.
 *
 * Combines SQLite for persistent storage with JGraphT for in-memory graph algorithms.
 * Provides CRUD operations for nodes and edges, graph traversal, and search capabilities.
 *
 * Architecture:
 * - SQLite stores all nodes/edges persistently
 * - JGraphT provides efficient in-memory graph operations for algorithms
 * - LRU cache for hot nodes (TODO: implement in MultiTierCache)
 */
public class BinaryKnowledgeGraph {

    private final Connection connection;
    private final AnalysisDB analysisDB;
    private Graph<String, LabeledEdge> memoryGraph;
    private final String binaryId;

    // Statistics
    private int nodeCount = 0;
    private int edgeCount = 0;

    // FTS repair attempted flag to prevent infinite retry loops
    private boolean ftsRepairAttempted = false;

    // Batch insert support for performance
    private static final int BATCH_SIZE = 200;
    private final List<KnowledgeNode> pendingNodes = Collections.synchronizedList(new ArrayList<>());
    private final List<PendingEdge> pendingEdges = Collections.synchronizedList(new ArrayList<>());
    private final Object batchLock = new Object();

    // Node caches for performance - populated on demand
    private final Map<String, KnowledgeNode> nodeCache = new ConcurrentHashMap<>();
    private final Map<NodeType, List<KnowledgeNode>> nodesByTypeCache = new ConcurrentHashMap<>();

    // Pending edge holder
    private static class PendingEdge {
        final String sourceId;
        final String targetId;
        final EdgeType type;
        final double weight;
        final String metadata;

        PendingEdge(String sourceId, String targetId, EdgeType type, double weight, String metadata) {
            this.sourceId = sourceId;
            this.targetId = targetId;
            this.type = type;
            this.weight = weight;
            this.metadata = metadata;
        }
    }

    // Pending community member holder
    private final List<PendingCommunityMember> pendingCommunityMembers = Collections.synchronizedList(new ArrayList<>());

    private static class PendingCommunityMember {
        final String communityId;
        final String nodeId;
        final double score;

        PendingCommunityMember(String communityId, String nodeId, double score) {
            this.communityId = communityId;
            this.nodeId = nodeId;
            this.score = score;
        }
    }

    /**
     * Create a BinaryKnowledgeGraph for a specific binary.
     *
     * @param connection SQLite database connection (shared with AnalysisDB)
     * @param binaryId   Program hash identifying the binary
     * @param analysisDB AnalysisDB instance for FTS table repair
     */
    public BinaryKnowledgeGraph(Connection connection, String binaryId, AnalysisDB analysisDB) {
        this.connection = connection;
        this.binaryId = binaryId;
        this.analysisDB = analysisDB;
        this.memoryGraph = new DefaultDirectedGraph<>(LabeledEdge.class);
        loadGraphIntoMemory();
    }

    // ========================================
    // Node Operations
    // ========================================

    /**
     * Get a node by its unique ID.
     * Uses cache for performance - nodes are cached on first access.
     */
    public KnowledgeNode getNode(String id) {
        if (id == null) {
            return null;
        }
        return nodeCache.computeIfAbsent(id, this::fetchNodeFromDB);
    }

    /**
     * Fetch a node from the database (internal method for cache miss).
     */
    private KnowledgeNode fetchNodeFromDB(String id) {
        String sql = "SELECT * FROM graph_nodes WHERE id = ?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, id);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return resultSetToNode(rs);
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to get node: " + e.getMessage(), e);
        }
        return null;
    }

    /**
     * Get a pending node by address (not yet committed to database).
     * Thread-safe - checks the pending batch.
     * This is critical for parallel extraction to avoid creating duplicate nodes.
     */
    public KnowledgeNode getPendingNodeByAddress(long address) {
        synchronized (pendingNodes) {
            for (KnowledgeNode node : pendingNodes) {
                if (node.getAddress() != null && node.getAddress() == address) {
                    return node;
                }
            }
        }
        return null;
    }

    /**
     * Get a node by its Ghidra address within this binary.
     * Checks pending nodes first (for parallel extraction), then database.
     */
    public KnowledgeNode getNodeByAddress(long address) {
        // FIRST check pending nodes (not yet committed to database)
        // This prevents duplicate node creation during parallel extraction
        KnowledgeNode pending = getPendingNodeByAddress(address);
        if (pending != null) {
            return pending;
        }

        // Then check database
        String sql = "SELECT * FROM graph_nodes WHERE binary_id = ? AND address = ?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, binaryId);
            stmt.setLong(2, address);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return resultSetToNode(rs);
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to get node by address: " + e.getMessage(), e);
        }
        return null;
    }

    /**
     * Get a pending node by name (not yet committed to database).
     * Thread-safe - checks the pending batch.
     */
    public KnowledgeNode getPendingNodeByName(String name) {
        synchronized (pendingNodes) {
            for (KnowledgeNode node : pendingNodes) {
                if (name != null && name.equals(node.getName())) {
                    return node;
                }
            }
        }
        return null;
    }

    /**
     * Get a function node by name.
     * Checks pending nodes first (for parallel extraction), then database.
     */
    public KnowledgeNode getNodeByName(String name) {
        // FIRST check pending nodes (not yet committed to database)
        // This prevents duplicate external function node creation during parallel extraction
        KnowledgeNode pending = getPendingNodeByName(name);
        if (pending != null) {
            return pending;
        }

        // Then check database
        String sql = "SELECT * FROM graph_nodes WHERE binary_id = ? AND name = ? AND type = ?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, binaryId);
            stmt.setString(2, name);
            stmt.setString(3, NodeType.FUNCTION.name());
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return resultSetToNode(rs);
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to get node by name: " + e.getMessage(), e);
        }
        return null;
    }

    /**
     * Get all nodes of a specific type for this binary.
     * Uses cache for performance - results are cached after first query.
     */
    public List<KnowledgeNode> getNodesByType(NodeType type) {
        List<KnowledgeNode> cached = nodesByTypeCache.get(type);
        if (cached != null) {
            return new ArrayList<>(cached); // Return copy to prevent external modification
        }

        List<KnowledgeNode> nodes = new ArrayList<>();
        String sql = "SELECT * FROM graph_nodes WHERE binary_id = ? AND type = ?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, binaryId);
            stmt.setString(2, type.name());
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                KnowledgeNode node = resultSetToNode(rs);
                nodes.add(node);
                // Also populate the individual node cache
                nodeCache.put(node.getId(), node);
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to get nodes by type: " + e.getMessage(), e);
        }

        // Cache the result
        nodesByTypeCache.put(type, nodes);
        return new ArrayList<>(nodes); // Return copy
    }

    /**
     * Bulk fetch nodes by IDs - single query instead of N separate queries.
     * This is a performance optimization for operations that need many nodes.
     * Uses cache for performance - checks cache first, only fetches uncached nodes from DB.
     *
     * @param nodeIds Collection of node IDs to fetch
     * @return Map of node ID to KnowledgeNode (missing nodes are simply not in the map)
     */
    public Map<String, KnowledgeNode> getNodes(Collection<String> nodeIds) {
        Map<String, KnowledgeNode> result = new HashMap<>();
        if (nodeIds == null || nodeIds.isEmpty()) {
            return result;
        }

        // Check cache first
        List<String> uncachedIds = new ArrayList<>();
        for (String id : nodeIds) {
            KnowledgeNode cached = nodeCache.get(id);
            if (cached != null) {
                result.put(id, cached);
            } else {
                uncachedIds.add(id);
            }
        }

        // If all nodes were cached, we're done
        if (uncachedIds.isEmpty()) {
            return result;
        }

        // SQLite has a limit on the number of parameters, so we batch in chunks
        int batchSize = 500; // SQLite default SQLITE_MAX_VARIABLE_NUMBER is 999

        for (int i = 0; i < uncachedIds.size(); i += batchSize) {
            List<String> batch = uncachedIds.subList(i, Math.min(i + batchSize, uncachedIds.size()));
            String placeholders = String.join(",", Collections.nCopies(batch.size(), "?"));
            String sql = "SELECT * FROM graph_nodes WHERE id IN (" + placeholders + ")";

            try (PreparedStatement stmt = connection.prepareStatement(sql)) {
                int idx = 1;
                for (String id : batch) {
                    stmt.setString(idx++, id);
                }
                ResultSet rs = stmt.executeQuery();
                while (rs.next()) {
                    KnowledgeNode node = resultSetToNode(rs);
                    result.put(node.getId(), node);
                    // Populate cache
                    nodeCache.put(node.getId(), node);
                }
            } catch (SQLException e) {
                Msg.error(this, "Failed to batch get nodes: " + e.getMessage(), e);
            }
        }
        return result;
    }

    /**
     * Clear all node caches.
     * Call this after bulk operations like reindexing to ensure fresh data.
     */
    public void invalidateNodeCache() {
        nodeCache.clear();
        nodesByTypeCache.clear();
    }

    /**
     * Bulk fetch all outgoing edges for a set of source nodes - single query.
     * This is a performance optimization to avoid N+1 queries when exporting graphs.
     *
     * @param sourceNodeIds Collection of source node IDs
     * @return List of all edges originating from the given nodes
     */
    public List<GraphEdge> getEdgesForNodes(Collection<String> sourceNodeIds) {
        List<GraphEdge> edges = new ArrayList<>();
        if (sourceNodeIds == null || sourceNodeIds.isEmpty()) {
            return edges;
        }

        // Batch in chunks for large node sets
        List<String> idList = new ArrayList<>(sourceNodeIds);
        int batchSize = 500;

        for (int i = 0; i < idList.size(); i += batchSize) {
            List<String> batch = idList.subList(i, Math.min(i + batchSize, idList.size()));
            String placeholders = String.join(",", Collections.nCopies(batch.size(), "?"));
            String sql = "SELECT * FROM graph_edges WHERE source_id IN (" + placeholders + ")";

            try (PreparedStatement stmt = connection.prepareStatement(sql)) {
                int idx = 1;
                for (String id : batch) {
                    stmt.setString(idx++, id);
                }
                ResultSet rs = stmt.executeQuery();
                while (rs.next()) {
                    edges.add(new GraphEdge(
                            rs.getString("id"),
                            rs.getString("source_id"),
                            rs.getString("target_id"),
                            EdgeType.fromString(rs.getString("type")),
                            rs.getDouble("weight"),
                            rs.getString("metadata")
                    ));
                }
            } catch (SQLException e) {
                Msg.error(this, "Failed to batch get edges: " + e.getMessage(), e);
            }
        }
        return edges;
    }

    /**
     * Insert or update a node.
     * If a node with the same address already exists, updates it instead of creating a duplicate.
     * Synchronized for thread-safe parallel processing.
     */
    public synchronized void upsertNode(KnowledgeNode node) {
        // Check if a node with this address already exists (for FUNCTION, BLOCK types)
        if (node.getAddress() != null && node.getAddress() != 0) {
            KnowledgeNode existing = getNodeByAddress(node.getAddress());
            if (existing != null) {
                // Reuse the existing node's ID to update it instead of creating duplicate
                node.setId(existing.getId());
            }
        }
        upsertNodeInternal(node, false);
    }

    /**
     * Internal upsert implementation with retry support for FTS corruption.
     * Uses INSERT OR IGNORE for new nodes, then UPDATE for existing nodes.
     */
    private void upsertNodeInternal(KnowledgeNode node, boolean isRetry) {
        // Step 1: Try INSERT OR IGNORE for new nodes (preserves edge references)
        String insertSql = "INSERT OR IGNORE INTO graph_nodes "
                + "(id, type, address, binary_id, name, raw_content, llm_summary, confidence, "
                + "embedding, security_flags, network_apis, file_io_apis, ip_addresses, urls, "
                + "file_paths, domains, registry_keys, risk_level, activity_profile, analysis_depth, "
                + "created_at, updated_at, is_stale, user_edited) "
                + "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

        // Step 2: UPDATE existing nodes (for when INSERT was ignored)
        String updateSql = "UPDATE graph_nodes SET "
                + "name = COALESCE(?, name), "
                + "raw_content = COALESCE(?, raw_content), "
                + "llm_summary = COALESCE(?, llm_summary), "
                + "confidence = ?, "
                + "embedding = COALESCE(?, embedding), "
                + "security_flags = COALESCE(?, security_flags), "
                + "network_apis = COALESCE(?, network_apis), "
                + "file_io_apis = COALESCE(?, file_io_apis), "
                + "ip_addresses = COALESCE(?, ip_addresses), "
                + "urls = COALESCE(?, urls), "
                + "file_paths = COALESCE(?, file_paths), "
                + "domains = COALESCE(?, domains), "
                + "registry_keys = COALESCE(?, registry_keys), "
                + "risk_level = COALESCE(?, risk_level), "
                + "activity_profile = COALESCE(?, activity_profile), "
                + "analysis_depth = ?, "
                + "updated_at = ?, "
                + "is_stale = ?, "
                + "user_edited = ? "
                + "WHERE id = ?";

        try {
            // Step 1: Try INSERT OR IGNORE for new nodes
            try (PreparedStatement insertStmt = connection.prepareStatement(insertSql)) {
                insertStmt.setString(1, node.getId());
                insertStmt.setString(2, node.getType().name());
                if (node.getAddress() != null) {
                    insertStmt.setLong(3, node.getAddress());
                } else {
                    insertStmt.setNull(3, Types.INTEGER);
                }
                insertStmt.setString(4, node.getBinaryId());
                insertStmt.setString(5, node.getName());
                insertStmt.setString(6, node.getRawContent());
                insertStmt.setString(7, node.getLlmSummary());
                insertStmt.setFloat(8, node.getConfidence());
                insertStmt.setBytes(9, node.serializeEmbedding());
                insertStmt.setString(10, node.serializeSecurityFlags());
                insertStmt.setString(11, node.serializeNetworkAPIs());
                insertStmt.setString(12, node.serializeFileIOAPIs());
                insertStmt.setString(13, node.serializeIPAddresses());
                insertStmt.setString(14, node.serializeURLs());
                insertStmt.setString(15, node.serializeFilePaths());
                insertStmt.setString(16, node.serializeDomains());
                insertStmt.setString(17, node.serializeRegistryKeys());
                insertStmt.setString(18, node.getRiskLevel());
                insertStmt.setString(19, node.getActivityProfile());
                insertStmt.setInt(20, node.getAnalysisDepth());
                insertStmt.setLong(21, node.getCreatedAt().toEpochMilli());
                insertStmt.setLong(22, node.getUpdatedAt().toEpochMilli());
                insertStmt.setInt(23, node.isStale() ? 1 : 0);
                insertStmt.setInt(24, node.isUserEdited() ? 1 : 0);

                insertStmt.executeUpdate();
            }

            // Step 2: UPDATE existing node data (handles case where INSERT was ignored)
            // This ensures summaries and other updated fields get saved
            try (PreparedStatement updateStmt = connection.prepareStatement(updateSql)) {
                updateStmt.setString(1, node.getName());
                updateStmt.setString(2, node.getRawContent());
                updateStmt.setString(3, node.getLlmSummary());
                updateStmt.setFloat(4, node.getConfidence());
                updateStmt.setBytes(5, node.serializeEmbedding());
                updateStmt.setString(6, node.serializeSecurityFlags());
                updateStmt.setString(7, node.serializeNetworkAPIs());
                updateStmt.setString(8, node.serializeFileIOAPIs());
                updateStmt.setString(9, node.serializeIPAddresses());
                updateStmt.setString(10, node.serializeURLs());
                updateStmt.setString(11, node.serializeFilePaths());
                updateStmt.setString(12, node.serializeDomains());
                updateStmt.setString(13, node.serializeRegistryKeys());
                updateStmt.setString(14, node.getRiskLevel());
                updateStmt.setString(15, node.getActivityProfile());
                updateStmt.setInt(16, node.getAnalysisDepth());
                updateStmt.setLong(17, node.getUpdatedAt().toEpochMilli());
                updateStmt.setInt(18, node.isStale() ? 1 : 0);
                updateStmt.setInt(19, node.isUserEdited() ? 1 : 0);
                updateStmt.setString(20, node.getId());

                updateStmt.executeUpdate();
            }

            // Add to in-memory graph if not present
            if (!memoryGraph.containsVertex(node.getId())) {
                memoryGraph.addVertex(node.getId());
                nodeCount++;
            }

            // Update node cache
            nodeCache.put(node.getId(), node);
            // Invalidate type cache since we may have added/modified a node
            nodesByTypeCache.remove(node.getType());
        } catch (SQLException e) {
            // Check if this is an FTS corruption error
            if (!isRetry && !ftsRepairAttempted && AnalysisDB.isFtsCorruptionError(e)) {
                Msg.warn(this, "FTS corruption detected, attempting repair...");
                ftsRepairAttempted = true;

                if (analysisDB != null && analysisDB.repairFtsTable()) {
                    Msg.info(this, "FTS repair successful, retrying upsert...");
                    upsertNodeInternal(node, true);
                    return;
                } else {
                    Msg.error(this, "FTS repair failed");
                }
            }
            Msg.error(this, "Failed to upsert node: " + e.getMessage(), e);
        }
    }

    /**
     * Delete a node and all its edges.
     */
    public boolean deleteNode(String id) {
        // Get node type before deletion for cache invalidation
        KnowledgeNode existingNode = nodeCache.get(id);
        NodeType nodeType = existingNode != null ? existingNode.getType() : null;

        // Edges will be deleted via CASCADE
        String sql = "DELETE FROM graph_nodes WHERE id = ?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, id);
            int affected = stmt.executeUpdate();
            if (affected > 0) {
                memoryGraph.removeVertex(id);
                nodeCount--;

                // Remove from caches
                nodeCache.remove(id);
                if (nodeType != null) {
                    nodesByTypeCache.remove(nodeType);
                }
                return true;
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to delete node: " + e.getMessage(), e);
        }
        return false;
    }

    // ========================================
    // Edge Operations
    // ========================================

    /**
     * Add an edge between two nodes.
     */
    public void addEdge(String sourceId, String targetId, EdgeType type) {
        addEdge(sourceId, targetId, type, 1.0, null);
    }

    /**
     * Add an edge with weight and metadata.
     * Skips if an edge of the same type already exists between source and target.
     */
    public void addEdge(String sourceId, String targetId, EdgeType type, double weight, String metadata) {
        // Check for existing edge first to prevent duplicates
        if (hasEdgeBetween(sourceId, targetId, type)) {
            return; // Edge already exists
        }

        String edgeId = UUID.randomUUID().toString();
        String sql = "INSERT INTO graph_edges (id, source_id, target_id, type, weight, metadata, created_at) "
                + "VALUES (?, ?, ?, ?, ?, ?, ?)";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, edgeId);
            stmt.setString(2, sourceId);
            stmt.setString(3, targetId);
            stmt.setString(4, type.name());
            stmt.setDouble(5, weight);
            stmt.setString(6, metadata);
            stmt.setLong(7, Instant.now().toEpochMilli());

            int affected = stmt.executeUpdate();
            if (affected > 0) {
                // Add to in-memory graph
                if (!memoryGraph.containsVertex(sourceId)) {
                    memoryGraph.addVertex(sourceId);
                }
                if (!memoryGraph.containsVertex(targetId)) {
                    memoryGraph.addVertex(targetId);
                }
                LabeledEdge edge = new LabeledEdge(type);
                memoryGraph.addEdge(sourceId, targetId, edge);
                edgeCount++;
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to add edge: " + e.getMessage(), e);
        }
    }

    // ========================================
    // Batch Insert Operations (for performance)
    // ========================================

    /**
     * Queue a node for batch insertion, returning the canonical node for this address/name.
     * This method is thread-safe and ensures no duplicate nodes are queued.
     * If a node with the same address (or name for external functions) already exists
     * in pending, returns the existing node instead of adding a duplicate.
     *
     * @param node The node to queue
     * @return The canonical node (either the input node if added, or existing node if duplicate)
     */
    public KnowledgeNode queueNodeForBatch(KnowledgeNode node) {
        synchronized (pendingNodes) {
            // Check if a node with same address already exists in pending
            if (node.getAddress() != null && node.getAddress() != 0) {
                for (KnowledgeNode existing : pendingNodes) {
                    if (existing.getAddress() != null &&
                        existing.getAddress().equals(node.getAddress())) {
                        // If existing node has no rawContent but new node does, merge the content
                        if ((existing.getRawContent() == null || existing.getRawContent().isEmpty()) &&
                            node.getRawContent() != null && !node.getRawContent().isEmpty()) {
                            existing.setRawContent(node.getRawContent());
                            Msg.debug(this, "Merged rawContent into existing node: " + existing.getName());
                        }
                        return existing; // Return existing node
                    }
                }
            } else if (node.getName() != null) {
                // External function - check by name
                for (KnowledgeNode existing : pendingNodes) {
                    if (node.getName().equals(existing.getName()) &&
                        (existing.getAddress() == null || existing.getAddress() == 0)) {
                        // Merge rawContent if needed
                        if ((existing.getRawContent() == null || existing.getRawContent().isEmpty()) &&
                            node.getRawContent() != null && !node.getRawContent().isEmpty()) {
                            existing.setRawContent(node.getRawContent());
                        }
                        return existing; // Return existing node
                    }
                }
            }

            // No duplicate found, add the node
            pendingNodes.add(node);
        }

        if (pendingNodes.size() >= BATCH_SIZE) {
            flushNodeBatch();
        }
        return node;
    }

    /**
     * Queue an edge for batch insertion.
     * Automatically flushes when batch size is reached.
     */
    public void queueEdgeForBatch(String sourceId, String targetId, EdgeType type) {
        queueEdgeForBatch(sourceId, targetId, type, 1.0, null);
    }

    /**
     * Queue an edge with weight and metadata for batch insertion.
     */
    public void queueEdgeForBatch(String sourceId, String targetId, EdgeType type, double weight, String metadata) {
        pendingEdges.add(new PendingEdge(sourceId, targetId, type, weight, metadata));
        if (pendingEdges.size() >= BATCH_SIZE) {
            flushEdgeBatch();
        }
    }

    /**
     * Flush all pending nodes to the database.
     */
    public void flushNodeBatch() {
        List<KnowledgeNode> toInsert;
        synchronized (batchLock) {
            if (pendingNodes.isEmpty()) {
                return;
            }
            toInsert = new ArrayList<>(pendingNodes);
            pendingNodes.clear();
        }

        // Deduplicate within the batch to avoid constraint violations
        // - By address for regular functions (preserves original node ID)
        // - By name for external functions (address=0 or null)
        Map<Long, KnowledgeNode> addressToNode = new LinkedHashMap<>();
        Map<String, KnowledgeNode> nameToNode = new LinkedHashMap<>();
        List<KnowledgeNode> deduped = new ArrayList<>();
        for (KnowledgeNode node : toInsert) {
            if (node.getAddress() != null && node.getAddress() != 0) {
                // Regular function with address - dedupe by address
                if (!addressToNode.containsKey(node.getAddress())) {
                    addressToNode.put(node.getAddress(), node);
                    deduped.add(node);
                }
            } else if (node.getName() != null) {
                // External function (no address) - dedupe by name
                if (!nameToNode.containsKey(node.getName())) {
                    nameToNode.put(node.getName(), node);
                    deduped.add(node);
                }
            } else {
                // No address and no name - just add it
                deduped.add(node);
            }
        }

        // Use INSERT OR IGNORE to keep existing nodes intact.
        // This preserves node IDs that edges may reference.
        // Duplicates are already filtered by getPendingNodeByAddress() check.
        String sql = "INSERT OR IGNORE INTO graph_nodes "
                + "(id, type, address, binary_id, name, raw_content, llm_summary, confidence, "
                + "embedding, security_flags, network_apis, file_io_apis, ip_addresses, urls, "
                + "file_paths, domains, registry_keys, risk_level, activity_profile, analysis_depth, "
                + "created_at, updated_at, is_stale, user_edited) "
                + "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

        synchronized (batchLock) {
            try {
                boolean originalAutoCommit = connection.getAutoCommit();
                connection.setAutoCommit(false);

                try (PreparedStatement stmt = connection.prepareStatement(sql)) {
                    for (KnowledgeNode node : deduped) {
                        stmt.setString(1, node.getId());
                        stmt.setString(2, node.getType().name());
                        if (node.getAddress() != null) {
                            stmt.setLong(3, node.getAddress());
                        } else {
                            stmt.setNull(3, Types.INTEGER);
                        }
                        stmt.setString(4, node.getBinaryId());
                        stmt.setString(5, node.getName());
                        stmt.setString(6, node.getRawContent());
                        stmt.setString(7, node.getLlmSummary());
                        stmt.setFloat(8, node.getConfidence());
                        stmt.setBytes(9, node.serializeEmbedding());
                        stmt.setString(10, node.serializeSecurityFlags());
                        stmt.setString(11, node.serializeNetworkAPIs());
                        stmt.setString(12, node.serializeFileIOAPIs());
                        stmt.setString(13, node.serializeIPAddresses());
                        stmt.setString(14, node.serializeURLs());
                        stmt.setString(15, node.serializeFilePaths());
                        stmt.setString(16, node.serializeDomains());
                        stmt.setString(17, node.serializeRegistryKeys());
                        stmt.setString(18, node.getRiskLevel());
                        stmt.setString(19, node.getActivityProfile());
                        stmt.setInt(20, node.getAnalysisDepth());
                        stmt.setLong(21, node.getCreatedAt().toEpochMilli());
                        stmt.setLong(22, node.getUpdatedAt().toEpochMilli());
                        stmt.setInt(23, node.isStale() ? 1 : 0);
                        stmt.setInt(24, node.isUserEdited() ? 1 : 0);
                        stmt.addBatch();

                        // Add to in-memory graph
                        if (!memoryGraph.containsVertex(node.getId())) {
                            memoryGraph.addVertex(node.getId());
                            nodeCount++;
                        }
                    }

                    stmt.executeBatch();
                    connection.commit();
                } catch (SQLException e) {
                    connection.rollback();
                    Msg.error(this, "Failed to batch insert nodes: " + e.getMessage(), e);
                } finally {
                    connection.setAutoCommit(originalAutoCommit);
                }
            } catch (SQLException e) {
                Msg.error(this, "Failed to manage transaction for batch insert: " + e.getMessage(), e);
            }
        }
    }

    /**
     * Flush all pending edges to the database.
     */
    public void flushEdgeBatch() {
        List<PendingEdge> toInsert;
        synchronized (batchLock) {
            if (pendingEdges.isEmpty()) {
                return;
            }
            toInsert = new ArrayList<>(pendingEdges);
            pendingEdges.clear();
        }

        // First, filter out edges that already exist
        Set<String> existingEdgeKeys = new HashSet<>();
        String checkSql = "SELECT source_id, target_id, type FROM graph_edges WHERE source_id IN (" +
                String.join(",", Collections.nCopies(toInsert.size(), "?")) + ")";

        try (PreparedStatement checkStmt = connection.prepareStatement(checkSql)) {
            Set<String> sourceIds = new HashSet<>();
            for (PendingEdge edge : toInsert) {
                sourceIds.add(edge.sourceId);
            }
            int idx = 1;
            for (String sourceId : sourceIds) {
                checkStmt.setString(idx++, sourceId);
            }
            // Pad remaining parameters if sourceIds < toInsert.size()
            for (int i = idx; i <= toInsert.size(); i++) {
                checkStmt.setString(i, "");
            }

            ResultSet rs = checkStmt.executeQuery();
            while (rs.next()) {
                String key = rs.getString("source_id") + "|" + rs.getString("target_id") + "|" + rs.getString("type");
                existingEdgeKeys.add(key);
            }
        } catch (SQLException e) {
            Msg.debug(this, "Failed to check existing edges: " + e.getMessage());
        }

        // Filter out existing edges
        List<PendingEdge> newEdges = new ArrayList<>();
        for (PendingEdge edge : toInsert) {
            String key = edge.sourceId + "|" + edge.targetId + "|" + edge.type.name();
            if (!existingEdgeKeys.contains(key)) {
                newEdges.add(edge);
            }
        }

        if (newEdges.isEmpty()) {
            return;
        }

        String sql = "INSERT INTO graph_edges (id, source_id, target_id, type, weight, metadata, created_at) "
                + "VALUES (?, ?, ?, ?, ?, ?, ?)";

        synchronized (batchLock) {
            try {
                boolean originalAutoCommit = connection.getAutoCommit();
                connection.setAutoCommit(false);

                try (PreparedStatement stmt = connection.prepareStatement(sql)) {
                    long now = Instant.now().toEpochMilli();

                    for (PendingEdge edge : newEdges) {
                        stmt.setString(1, UUID.randomUUID().toString());
                        stmt.setString(2, edge.sourceId);
                        stmt.setString(3, edge.targetId);
                        stmt.setString(4, edge.type.name());
                        stmt.setDouble(5, edge.weight);
                        stmt.setString(6, edge.metadata);
                        stmt.setLong(7, now);
                        stmt.addBatch();

                        // Add to in-memory graph
                        if (!memoryGraph.containsVertex(edge.sourceId)) {
                            memoryGraph.addVertex(edge.sourceId);
                        }
                        if (!memoryGraph.containsVertex(edge.targetId)) {
                            memoryGraph.addVertex(edge.targetId);
                        }
                        LabeledEdge memEdge = new LabeledEdge(edge.type);
                        memoryGraph.addEdge(edge.sourceId, edge.targetId, memEdge);
                        edgeCount++;
                    }

                    stmt.executeBatch();
                    connection.commit();
                } catch (SQLException e) {
                    connection.rollback();
                    Msg.error(this, "Failed to batch insert edges: " + e.getMessage(), e);
                } finally {
                    connection.setAutoCommit(originalAutoCommit);
                }
            } catch (SQLException e) {
                Msg.error(this, "Failed to manage transaction for edge batch insert: " + e.getMessage(), e);
            }
        }
    }

    /**
     * Queue a community member for batch insertion.
     */
    public void queueCommunityMemberForBatch(String communityId, String nodeId, double score) {
        pendingCommunityMembers.add(new PendingCommunityMember(communityId, nodeId, score));
        if (pendingCommunityMembers.size() >= BATCH_SIZE) {
            flushCommunityMemberBatch();
        }
    }

    /**
     * Flush all pending community members to the database.
     */
    public void flushCommunityMemberBatch() {
        List<PendingCommunityMember> toInsert;
        synchronized (batchLock) {
            if (pendingCommunityMembers.isEmpty()) {
                return;
            }
            toInsert = new ArrayList<>(pendingCommunityMembers);
            pendingCommunityMembers.clear();
        }

        String sql = "INSERT OR REPLACE INTO community_members (community_id, node_id, membership_score) VALUES (?, ?, ?)";

        synchronized (batchLock) {
            try {
                boolean originalAutoCommit = connection.getAutoCommit();
                connection.setAutoCommit(false);

                try (PreparedStatement stmt = connection.prepareStatement(sql)) {
                    for (PendingCommunityMember member : toInsert) {
                        stmt.setString(1, member.communityId);
                        stmt.setString(2, member.nodeId);
                        stmt.setDouble(3, member.score);
                        stmt.addBatch();
                    }
                    stmt.executeBatch();
                    connection.commit();
                } catch (SQLException e) {
                    connection.rollback();
                    Msg.error(this, "Failed to batch insert community members: " + e.getMessage(), e);
                } finally {
                    connection.setAutoCommit(originalAutoCommit);
                }
            } catch (SQLException e) {
                Msg.error(this, "Failed to manage transaction for community member batch insert: " + e.getMessage(), e);
            }
        }
    }

    /**
     * Resolve pending edge node IDs to their actual database IDs.
     * This fixes UUID mismatches that occur when upsertNode() changes a node's ID
     * to match an existing node with the same address.
     *
     * Called automatically before flushEdgeBatch() to ensure edges reference valid node IDs.
     */
    private void resolvePendingEdgeIds() {
        if (pendingEdges.isEmpty()) {
            return;
        }

        // Build lookup of address -> actual node ID from database
        Map<Long, String> addressToId = new HashMap<>();
        String sql = "SELECT id, address FROM graph_nodes WHERE binary_id = ? AND address IS NOT NULL AND address != 0";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, binaryId);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                long addr = rs.getLong("address");
                addressToId.put(addr, rs.getString("id"));
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to build address lookup for edge resolution: " + e.getMessage(), e);
            return;
        }

        // Build UUID -> address lookup from pending nodes
        // This allows us to find the address for a pending node's UUID
        Map<String, Long> pendingUuidToAddress = new HashMap<>();
        synchronized (pendingNodes) {
            for (KnowledgeNode node : pendingNodes) {
                if (node.getAddress() != null && node.getAddress() != 0) {
                    pendingUuidToAddress.put(node.getId(), node.getAddress());
                    // Also update addressToId with pending nodes (they may not be in DB yet)
                    addressToId.put(node.getAddress(), node.getId());
                }
            }
        }

        // Resolve each pending edge's source and target IDs
        List<PendingEdge> resolvedEdges = new ArrayList<>();
        int resolvedCount = 0;

        synchronized (pendingEdges) {
            for (PendingEdge edge : pendingEdges) {
                String resolvedSource = edge.sourceId;
                String resolvedTarget = edge.targetId;
                boolean changed = false;

                // Try to resolve source ID via address lookup
                Long sourceAddr = pendingUuidToAddress.get(edge.sourceId);
                if (sourceAddr != null && addressToId.containsKey(sourceAddr)) {
                    String actualId = addressToId.get(sourceAddr);
                    if (!actualId.equals(edge.sourceId)) {
                        resolvedSource = actualId;
                        changed = true;
                    }
                }

                // Try to resolve target ID via address lookup
                Long targetAddr = pendingUuidToAddress.get(edge.targetId);
                if (targetAddr != null && addressToId.containsKey(targetAddr)) {
                    String actualId = addressToId.get(targetAddr);
                    if (!actualId.equals(edge.targetId)) {
                        resolvedTarget = actualId;
                        changed = true;
                    }
                }

                if (changed) {
                    resolvedCount++;
                }
                resolvedEdges.add(new PendingEdge(resolvedSource, resolvedTarget, edge.type, edge.weight, edge.metadata));
            }

            pendingEdges.clear();
            pendingEdges.addAll(resolvedEdges);
        }

        if (resolvedCount > 0) {
            Msg.info(this, String.format("Resolved %d edge IDs to match actual node IDs", resolvedCount));
        }
    }

    /**
     * Flush all pending batches (nodes, edges, and community members).
     * Call this at the end of batch operations to ensure all data is written.
     */
    public void flushAllBatches() {
        // CRITICAL: Flush nodes FIRST so they exist in DB
        flushNodeBatch();

        // CRITICAL: Resolve edge IDs BEFORE flushing edges
        // This fixes UUID mismatches from parallel extraction
        resolvePendingEdgeIds();

        // Now flush edges with correct IDs
        flushEdgeBatch();
        flushCommunityMemberBatch();
    }

    /**
     * Get count of pending items in batches.
     */
    public int getPendingBatchCount() {
        return pendingNodes.size() + pendingEdges.size() + pendingCommunityMembers.size();
    }

    /**
     * Remove duplicate edges from the database.
     * Keeps the oldest edge (by created_at) for each unique (source_id, target_id, type) combination.
     *
     * @return Number of duplicate edges removed
     */
    public int removeDuplicateEdges() {
        // SQL to find and delete duplicates, keeping the one with MIN(created_at)
        String sql = "DELETE FROM graph_edges WHERE id NOT IN (" +
                "SELECT MIN(id) FROM graph_edges " +
                "GROUP BY source_id, target_id, type)";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            int deleted = stmt.executeUpdate();
            if (deleted > 0) {
                Msg.info(this, String.format("Removed %d duplicate edges", deleted));
                // Reload the in-memory graph to reflect changes
                loadGraphIntoMemory();
            }
            return deleted;
        } catch (SQLException e) {
            Msg.error(this, "Failed to remove duplicate edges: " + e.getMessage(), e);
        }
        return 0;
    }

    /**
     * Get all edges from a source node.
     */
    public List<GraphEdge> getOutgoingEdges(String nodeId) {
        return getEdges(nodeId, true);
    }

    /**
     * Get all edges to a target node.
     */
    public List<GraphEdge> getIncomingEdges(String nodeId) {
        return getEdges(nodeId, false);
    }

    private List<GraphEdge> getEdges(String nodeId, boolean outgoing) {
        List<GraphEdge> edges = new ArrayList<>();
        String sql = outgoing
                ? "SELECT * FROM graph_edges WHERE source_id = ?"
                : "SELECT * FROM graph_edges WHERE target_id = ?";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, nodeId);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                edges.add(new GraphEdge(
                        rs.getString("id"),
                        rs.getString("source_id"),
                        rs.getString("target_id"),
                        EdgeType.fromString(rs.getString("type")),
                        rs.getDouble("weight"),
                        rs.getString("metadata")
                ));
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to get edges: " + e.getMessage(), e);
        }
        return edges;
    }

    /**
     * Delete an edge by ID.
     */
    public boolean deleteEdge(String edgeId) {
        // First get the edge details for memory graph removal
        String selectSql = "SELECT source_id, target_id FROM graph_edges WHERE id = ?";
        String sourceId = null, targetId = null;

        try (PreparedStatement stmt = connection.prepareStatement(selectSql)) {
            stmt.setString(1, edgeId);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                sourceId = rs.getString("source_id");
                targetId = rs.getString("target_id");
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to get edge details: " + e.getMessage(), e);
        }

        String deleteSql = "DELETE FROM graph_edges WHERE id = ?";
        try (PreparedStatement stmt = connection.prepareStatement(deleteSql)) {
            stmt.setString(1, edgeId);
            int affected = stmt.executeUpdate();
            if (affected > 0 && sourceId != null && targetId != null) {
                memoryGraph.removeEdge(sourceId, targetId);
                edgeCount--;
                return true;
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to delete edge: " + e.getMessage(), e);
        }
        return false;
    }

    // ========================================
    // Graph Traversal Operations
    // ========================================

    /**
     * Get neighboring nodes within N hops.
     * @deprecated Use {@link #getNeighborsBatch(String, int)} for better performance
     */
    @Deprecated
    public List<KnowledgeNode> getNeighbors(String nodeId, int maxDepth) {
        // Delegate to batch version for better performance
        return getNeighborsBatch(nodeId, maxDepth);
    }

    /**
     * Get neighboring nodes within N hops using batch loading.
     * This method first collects all neighbor IDs from the in-memory graph,
     * then fetches all nodes in a single database query.
     *
     * @param nodeId   The starting node ID
     * @param maxDepth Maximum number of hops from the starting node
     * @return List of neighboring nodes within the specified depth
     */
    public List<KnowledgeNode> getNeighborsBatch(String nodeId, int maxDepth) {
        if (!memoryGraph.containsVertex(nodeId)) {
            return new ArrayList<>();
        }

        // Phase 1: Collect all neighbor IDs using in-memory graph (fast)
        Set<String> neighborIds = new HashSet<>();
        BreadthFirstIterator<String, LabeledEdge> iterator =
                new BreadthFirstIterator<>(memoryGraph, nodeId);

        while (iterator.hasNext()) {
            String vertexId = iterator.next();

            // Skip the starting node
            if (vertexId.equals(nodeId)) {
                continue;
            }

            // Use BFS iterator's depth tracking - stop if beyond maxDepth
            int vertexDepth = iterator.getDepth(vertexId);
            if (vertexDepth > maxDepth) {
                // BFS visits nodes in order of increasing depth, so we can stop here
                break;
            }

            neighborIds.add(vertexId);
        }

        // Phase 2: Batch fetch all nodes in a single query
        Map<String, KnowledgeNode> nodeMap = getNodes(neighborIds);
        return new ArrayList<>(nodeMap.values());
    }

    /**
     * Get all callers of a function (nodes that have CALLS edge to this function).
     * Uses in-memory graph for topology (no DB hit) + batch fetch for node data.
     */
    public List<KnowledgeNode> getCallers(String functionId) {
        if (!memoryGraph.containsVertex(functionId)) {
            return new ArrayList<>();
        }

        // Use in-memory graph for topology (no DB hit)
        Set<LabeledEdge> inEdges = memoryGraph.incomingEdgesOf(functionId);

        List<String> callerIds = new ArrayList<>();
        for (LabeledEdge edge : inEdges) {
            if (edge.getType() == EdgeType.CALLS) {
                callerIds.add(memoryGraph.getEdgeSource(edge));
            }
        }

        if (callerIds.isEmpty()) {
            return new ArrayList<>();
        }

        // Batch fetch all caller nodes at once (uses cache)
        Map<String, KnowledgeNode> nodeMap = getNodes(callerIds);
        return new ArrayList<>(nodeMap.values());
    }

    /**
     * Get all callees of a function (nodes this function CALLS).
     * Uses in-memory graph for topology (no DB hit) + batch fetch for node data.
     */
    public List<KnowledgeNode> getCallees(String functionId) {
        if (!memoryGraph.containsVertex(functionId)) {
            return new ArrayList<>();
        }

        // Use in-memory graph for topology (no DB hit)
        Set<LabeledEdge> outEdges = memoryGraph.outgoingEdgesOf(functionId);

        List<String> calleeIds = new ArrayList<>();
        for (LabeledEdge edge : outEdges) {
            if (edge.getType() == EdgeType.CALLS) {
                calleeIds.add(memoryGraph.getEdgeTarget(edge));
            }
        }

        if (calleeIds.isEmpty()) {
            return new ArrayList<>();
        }

        // Batch fetch all callee nodes at once (uses cache)
        Map<String, KnowledgeNode> nodeMap = getNodes(calleeIds);
        return new ArrayList<>(nodeMap.values());
    }

    /**
     * Check if a node has any edges of a specific type (outgoing).
     *
     * @param nodeId The node ID
     * @param edgeType The edge type to check for
     * @return true if the node has at least one edge of this type
     */
    public boolean hasEdgesOfType(String nodeId, EdgeType edgeType) {
        String sql = "SELECT 1 FROM graph_edges WHERE source_id = ? AND type = ? LIMIT 1";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, nodeId);
            stmt.setString(2, edgeType.name());
            ResultSet rs = stmt.executeQuery();
            return rs.next();
        } catch (SQLException e) {
            Msg.error(this, "Failed to check edges of type: " + e.getMessage(), e);
        }
        return false;
    }

    /**
     * Check if a node has any incoming edges of a specific type.
     *
     * @param nodeId The node ID
     * @param edgeType The edge type to check for
     * @return true if the node has at least one incoming edge of this type
     */
    public boolean hasIncomingEdgesOfType(String nodeId, EdgeType edgeType) {
        String sql = "SELECT 1 FROM graph_edges WHERE target_id = ? AND type = ? LIMIT 1";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, nodeId);
            stmt.setString(2, edgeType.name());
            ResultSet rs = stmt.executeQuery();
            return rs.next();
        } catch (SQLException e) {
            Msg.error(this, "Failed to check incoming edges of type: " + e.getMessage(), e);
        }
        return false;
    }

    /**
     * Check if an edge exists between two nodes with a specific type.
     *
     * @param sourceId The source node ID
     * @param targetId The target node ID
     * @param edgeType The edge type to check for
     * @return true if such an edge exists
     */
    public boolean hasEdgeBetween(String sourceId, String targetId, EdgeType edgeType) {
        String sql = "SELECT 1 FROM graph_edges WHERE source_id = ? AND target_id = ? AND type = ? LIMIT 1";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, sourceId);
            stmt.setString(2, targetId);
            stmt.setString(3, edgeType.name());
            ResultSet rs = stmt.executeQuery();
            return rs.next();
        } catch (SQLException e) {
            Msg.error(this, "Failed to check edge between nodes: " + e.getMessage(), e);
        }
        return false;
    }

    // ========================================
    // Search Operations
    // ========================================

    /**
     * Full-text search on node summaries and names.
     */
    public List<KnowledgeNode> ftsSearch(String query, int limit) {
        return ftsSearchInternal(query, limit, false);
    }

    /**
     * Internal FTS search with repair support for corruption.
     */
    private List<KnowledgeNode> ftsSearchInternal(String query, int limit, boolean isRetry) {
        List<KnowledgeNode> results = new ArrayList<>();
        // Join with graph_nodes to filter by binary_id BEFORE applying LIMIT
        String sql = "SELECT node_fts.id FROM node_fts, graph_nodes "
                   + "WHERE node_fts MATCH ? "
                   + "AND graph_nodes.rowid = node_fts.rowid "
                   + "AND graph_nodes.binary_id = ? "
                   + "LIMIT ?";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            String ftsQuery = escapeFtsQuery(query);
            stmt.setString(1, ftsQuery);
            stmt.setString(2, binaryId);
            stmt.setInt(3, limit);

            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                KnowledgeNode node = getNode(rs.getString("id"));
                if (node != null) {
                    results.add(node);
                }
            }
        } catch (SQLException e) {
            // Check if this is an FTS corruption error
            if (!isRetry && !ftsRepairAttempted && AnalysisDB.isFtsCorruptionError(e)) {
                Msg.warn(this, "FTS corruption detected during search, attempting repair...");
                ftsRepairAttempted = true;

                if (analysisDB != null && analysisDB.repairFtsTable()) {
                    Msg.info(this, "FTS repair successful, retrying search...");
                    return ftsSearchInternal(query, limit, true);
                } else {
                    Msg.error(this, "FTS repair failed");
                }
            }
            Msg.error(this, "FTS search failed: " + e.getMessage(), e);
        }
        return results;
    }

    /**
     * Get nodes that need summarization: either marked stale OR have empty/null summary.
     * This ensures nodes with failed previous summarization attempts are re-processed.
     * Results are ordered by address for predictable processing order.
     */
    public List<KnowledgeNode> getStaleNodes(int limit) {
        List<KnowledgeNode> nodes = new ArrayList<>();
        // Include nodes that are stale OR have no summary (null, empty, or whitespace-only)
        // Order by address for predictable sequential processing
        String sql = "SELECT * FROM graph_nodes WHERE binary_id = ? " +
                     "AND (is_stale = 1 OR llm_summary IS NULL OR TRIM(llm_summary) = '') " +
                     "ORDER BY address NULLS LAST LIMIT ?";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, binaryId);
            stmt.setInt(2, limit);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                nodes.add(resultSetToNode(rs));
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to get stale nodes: " + e.getMessage(), e);
        }
        return nodes;
    }

    // ========================================
    // Bulk Operations
    // ========================================

    /**
     * Mark all nodes in the graph as stale.
     * Used at the start of incremental reindex to identify unchanged nodes.
     *
     * @return Number of nodes marked stale
     */
    public int markAllStale() {
        String sql = "UPDATE graph_nodes SET is_stale = 1 WHERE binary_id = ?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, binaryId);
            return stmt.executeUpdate();
        } catch (SQLException e) {
            Msg.error(this, "Failed to mark nodes stale: " + e.getMessage(), e);
        }
        return 0;
    }

    /**
     * Get count of nodes with LLM summaries (non-stale with summary).
     * Useful for tracking how many summaries were preserved during incremental reindex.
     *
     * @return Count of nodes with preserved summaries
     */
    public int getPreservedSummaryCount() {
        String sql = "SELECT COUNT(*) FROM graph_nodes WHERE binary_id = ? " +
                     "AND is_stale = 0 AND llm_summary IS NOT NULL AND TRIM(llm_summary) != ''";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, binaryId);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return rs.getInt(1);
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to get preserved summary count: " + e.getMessage(), e);
        }
        return 0;
    }

    /**
     * Get count of nodes that are stale (need re-summarization).
     *
     * @return Count of stale nodes
     */
    public int getStaleNodeCount() {
        String sql = "SELECT COUNT(*) FROM graph_nodes WHERE binary_id = ? AND is_stale = 1";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, binaryId);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return rs.getInt(1);
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to get stale node count: " + e.getMessage(), e);
        }
        return 0;
    }

    /**
     * Delete all graph data for this binary.
     * Clears: edges, nodes, and communities.
     * FTS is synced separately via rebuildFts() after batch operations.
     */
    public void clearGraph() {
        String deleteEdges = "DELETE FROM graph_edges WHERE " +
                "source_id IN (SELECT id FROM graph_nodes WHERE binary_id = ?) OR " +
                "target_id IN (SELECT id FROM graph_nodes WHERE binary_id = ?)";
        String deleteNodes = "DELETE FROM graph_nodes WHERE binary_id = ?";
        String deleteCommunities = "DELETE FROM graph_communities WHERE binary_id = ?";

        try (PreparedStatement stmtEdges = connection.prepareStatement(deleteEdges);
             PreparedStatement stmtNodes = connection.prepareStatement(deleteNodes);
             PreparedStatement stmtCommunities = connection.prepareStatement(deleteCommunities)) {

            stmtEdges.setString(1, binaryId);
            stmtEdges.setString(2, binaryId);
            int edgesDeleted = stmtEdges.executeUpdate();

            stmtNodes.setString(1, binaryId);
            int nodesDeleted = stmtNodes.executeUpdate();

            stmtCommunities.setString(1, binaryId);
            int communitiesDeleted = stmtCommunities.executeUpdate();

            memoryGraph = new DefaultDirectedGraph<>(LabeledEdge.class);
            nodeCount = 0;
            edgeCount = 0;

            Msg.info(this, String.format("Cleared graph for binary %s: %d edges, %d nodes, %d communities",
                    binaryId, edgesDeleted, nodesDeleted, communitiesDeleted));
        } catch (SQLException e) {
            Msg.error(this, "Failed to clear graph: " + e.getMessage(), e);
        }
    }

    /**
     * Rebuild the FTS index from current graph_nodes data.
     * Call after batch operations to sync FTS with the base table.
     */
    public void rebuildFts() {
        if (analysisDB != null) {
            analysisDB.rebuildFts();
        }
    }

    // ========================================
    // Statistics
    // ========================================

    public int getNodeCount() {
        return nodeCount;
    }

    public int getEdgeCount() {
        return edgeCount;
    }

    public String getBinaryId() {
        return binaryId;
    }

    /**
     * Check if a function is already cached in the graph.
     */
    public boolean hasFunctionCached(long address) {
        return getNodeByAddress(address) != null;
    }

    /**
     * Check if a function's decompiled content is cached.
     */
    public String getCachedDecompiledCode(long address) {
        KnowledgeNode node = getNodeByAddress(address);
        return node != null ? node.getRawContent() : null;
    }

    /**
     * Get the in-memory JGraphT graph for algorithm operations.
     */
    public Graph<String, LabeledEdge> getMemoryGraph() {
        return memoryGraph;
    }

    // ========================================
    // Community Operations
    // ========================================

    /**
     * Insert or update a community record.
     */
    public void upsertCommunity(ghidrassist.graphrag.community.Community community) {
        String sql = "INSERT OR REPLACE INTO graph_communities " +
                "(id, level, binary_id, parent_community_id, name, summary, member_count, is_stale, created_at, updated_at) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, community.getId());
            stmt.setInt(2, community.getLevel());
            stmt.setString(3, community.getBinaryId());
            stmt.setString(4, community.getParentCommunityId());
            stmt.setString(5, community.getName());
            stmt.setString(6, community.getSummary());
            stmt.setInt(7, community.getMemberCount());
            stmt.setInt(8, community.isStale() ? 1 : 0);
            stmt.setLong(9, community.getCreatedAt());
            stmt.setLong(10, community.getUpdatedAt());

            stmt.executeUpdate();
        } catch (SQLException e) {
            Msg.error(this, "Failed to upsert community: " + e.getMessage(), e);
        }
    }

    /**
     * Get a community by ID.
     */
    public ghidrassist.graphrag.community.Community getCommunity(String communityId) {
        String sql = "SELECT * FROM graph_communities WHERE id = ?";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, communityId);
            ResultSet rs = stmt.executeQuery();

            if (rs.next()) {
                return resultSetToCommunity(rs);
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to get community: " + e.getMessage(), e);
        }
        return null;
    }

    /**
     * Get all communities for this binary at a specific level.
     */
    public List<ghidrassist.graphrag.community.Community> getCommunitiesForBinary(int level) {
        List<ghidrassist.graphrag.community.Community> communities = new ArrayList<>();
        String sql = "SELECT * FROM graph_communities WHERE binary_id = ? AND level = ? ORDER BY member_count DESC";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, binaryId);
            stmt.setInt(2, level);
            ResultSet rs = stmt.executeQuery();

            while (rs.next()) {
                communities.add(resultSetToCommunity(rs));
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to get communities: " + e.getMessage(), e);
        }
        return communities;
    }

    /**
     * Add a node to a community.
     */
    public void addCommunityMember(String communityId, String nodeId, double score) {
        String sql = "INSERT OR REPLACE INTO community_members (community_id, node_id, membership_score) VALUES (?, ?, ?)";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, communityId);
            stmt.setString(2, nodeId);
            stmt.setDouble(3, score);
            stmt.executeUpdate();
        } catch (SQLException e) {
            Msg.error(this, "Failed to add community member: " + e.getMessage(), e);
        }
    }

    /**
     * Get all member nodes of a community.
     */
    public List<KnowledgeNode> getCommunityMembers(String communityId) {
        List<KnowledgeNode> members = new ArrayList<>();
        String sql = "SELECT n.* FROM graph_nodes n " +
                "JOIN community_members cm ON n.id = cm.node_id " +
                "WHERE cm.community_id = ? " +
                "ORDER BY n.name";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, communityId);
            ResultSet rs = stmt.executeQuery();

            while (rs.next()) {
                members.add(resultSetToNode(rs));
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to get community members: " + e.getMessage(), e);
        }
        return members;
    }

    /**
     * Get the community a node belongs to.
     */
    public String getNodeCommunity(String nodeId) {
        String sql = "SELECT community_id FROM community_members WHERE node_id = ? LIMIT 1";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, nodeId);
            ResultSet rs = stmt.executeQuery();

            if (rs.next()) {
                return rs.getString("community_id");
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to get node community: " + e.getMessage(), e);
        }
        return null;
    }

    /**
     * Delete a community and its memberships.
     */
    public void deleteCommunity(String communityId) {
        String sql = "DELETE FROM graph_communities WHERE id = ?";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, communityId);
            stmt.executeUpdate();
            // community_members cascade delete handles memberships
        } catch (SQLException e) {
            Msg.error(this, "Failed to delete community: " + e.getMessage(), e);
        }
    }

    /**
     * Clear all communities for this binary.
     */
    public void clearCommunitiesForBinary() {
        String sql = "DELETE FROM graph_communities WHERE binary_id = ?";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, binaryId);
            stmt.executeUpdate();
            Msg.debug(this, "Cleared communities for binary: " + binaryId);
        } catch (SQLException e) {
            Msg.error(this, "Failed to clear communities: " + e.getMessage(), e);
        }
    }

    /**
     * Mark a community as stale (needs re-summarization).
     */
    public void markCommunityStale(String communityId) {
        String sql = "UPDATE graph_communities SET is_stale = 1, updated_at = ? WHERE id = ?";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setLong(1, System.currentTimeMillis());
            stmt.setString(2, communityId);
            stmt.executeUpdate();
        } catch (SQLException e) {
            Msg.error(this, "Failed to mark community stale: " + e.getMessage(), e);
        }
    }

    /**
     * Get community count for this binary.
     */
    public int getCommunityCount() {
        String sql = "SELECT COUNT(*) FROM graph_communities WHERE binary_id = ?";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, binaryId);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return rs.getInt(1);
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to get community count: " + e.getMessage(), e);
        }
        return 0;
    }

    /**
     * Convert a ResultSet row to a Community object.
     */
    private ghidrassist.graphrag.community.Community resultSetToCommunity(ResultSet rs) throws SQLException {
        return new ghidrassist.graphrag.community.Community(
                rs.getString("id"),
                rs.getInt("level"),
                rs.getString("binary_id"),
                rs.getString("parent_community_id"),
                rs.getString("name"),
                rs.getString("summary"),
                rs.getInt("member_count"),
                rs.getInt("is_stale") == 1,
                rs.getLong("created_at"),
                rs.getLong("updated_at")
        );
    }

    // ========================================
    // Internal Methods
    // ========================================

    /**
     * Reload the in-memory graph from the database.
     * Call this after bulk operations to ensure memoryGraph is synchronized with DB.
     */
    public void reloadFromDatabase() {
        loadGraphIntoMemory();
    }

    /**
     * Load graph structure from SQLite into JGraphT for algorithm operations.
     */
    private void loadGraphIntoMemory() {
        memoryGraph = new DefaultDirectedGraph<>(LabeledEdge.class);
        nodeCount = 0;
        edgeCount = 0;

        // Load all node IDs for this binary
        String nodesSql = "SELECT id FROM graph_nodes WHERE binary_id = ?";
        try (PreparedStatement stmt = connection.prepareStatement(nodesSql)) {
            stmt.setString(1, binaryId);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                String nodeId = rs.getString("id");
                memoryGraph.addVertex(nodeId);
                nodeCount++;
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to load nodes into memory: " + e.getMessage(), e);
        }

        // Load all edges for nodes in this binary (source OR target belongs to binary)
        // Use UNION to capture edges where either endpoint belongs to this binary
        String edgesSql = "SELECT DISTINCT e.source_id, e.target_id, e.type FROM graph_edges e "
                + "INNER JOIN graph_nodes n ON e.source_id = n.id "
                + "WHERE n.binary_id = ? "
                + "UNION "
                + "SELECT DISTINCT e.source_id, e.target_id, e.type FROM graph_edges e "
                + "INNER JOIN graph_nodes n ON e.target_id = n.id "
                + "WHERE n.binary_id = ?";
        try (PreparedStatement stmt = connection.prepareStatement(edgesSql)) {
            stmt.setString(1, binaryId);
            stmt.setString(2, binaryId);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                String sourceId = rs.getString("source_id");
                String targetId = rs.getString("target_id");
                EdgeType type = EdgeType.fromString(rs.getString("type"));

                // Dynamically add missing vertices instead of dropping edges
                // This ensures edges to/from external functions are included
                if (!memoryGraph.containsVertex(sourceId)) {
                    memoryGraph.addVertex(sourceId);
                }
                if (!memoryGraph.containsVertex(targetId)) {
                    memoryGraph.addVertex(targetId);
                }

                LabeledEdge edge = new LabeledEdge(type);
                try {
                    memoryGraph.addEdge(sourceId, targetId, edge);
                    edgeCount++;
                } catch (IllegalArgumentException e) {
                    // Edge already exists (can happen with UNION if both source and target
                    // belong to this binary) - silently skip
                }
            }
        } catch (SQLException e) {
            Msg.error(this, "Failed to load edges into memory: " + e.getMessage(), e);
        }

        Msg.info(this, String.format("Loaded graph for %s: %d nodes, %d edges",
                binaryId, nodeCount, edgeCount));
    }

    private KnowledgeNode resultSetToNode(ResultSet rs) throws SQLException {
        NodeType type = NodeType.fromString(rs.getString("type"));
        KnowledgeNode node = new KnowledgeNode(
                rs.getString("id"),
                type,
                rs.getString("binary_id")
        );

        long address = rs.getLong("address");
        if (!rs.wasNull()) {
            node.setAddress(address);
        }

        node.setName(rs.getString("name"));
        node.setRawContent(rs.getString("raw_content"));
        node.setLlmSummary(rs.getString("llm_summary"));
        node.setConfidence(rs.getFloat("confidence"));
        node.setEmbedding(KnowledgeNode.deserializeEmbedding(rs.getBytes("embedding")));
        node.setSecurityFlags(KnowledgeNode.deserializeSecurityFlags(rs.getString("security_flags")));
        node.setAnalysisDepth(rs.getInt("analysis_depth"));

        long createdAt = rs.getLong("created_at");
        if (createdAt > 0) {
            node.setCreatedAt(Instant.ofEpochMilli(createdAt));
        }

        long updatedAt = rs.getLong("updated_at");
        if (updatedAt > 0) {
            node.setUpdatedAt(Instant.ofEpochMilli(updatedAt));
        }

        node.setStale(rs.getInt("is_stale") == 1);

        // Load user_edited with fallback for older databases
        try {
            node.setUserEdited(rs.getInt("user_edited") == 1);
        } catch (SQLException e) {
            // Column doesn't exist in older databases
            node.setUserEdited(false);
        }

        // Load security detail columns with fallback for older databases
        try {
            node.setNetworkAPIs(KnowledgeNode.deserializeStringList(rs.getString("network_apis")));
        } catch (SQLException e) {
            // Column doesn't exist
        }
        try {
            node.setFileIOAPIs(KnowledgeNode.deserializeStringList(rs.getString("file_io_apis")));
        } catch (SQLException e) {
            // Column doesn't exist
        }
        try {
            node.setIPAddresses(KnowledgeNode.deserializeStringList(rs.getString("ip_addresses")));
        } catch (SQLException e) {
            // Column doesn't exist
        }
        try {
            node.setURLs(KnowledgeNode.deserializeStringList(rs.getString("urls")));
        } catch (SQLException e) {
            // Column doesn't exist
        }
        try {
            node.setFilePaths(KnowledgeNode.deserializeStringList(rs.getString("file_paths")));
        } catch (SQLException e) {
            // Column doesn't exist
        }
        try {
            node.setDomains(KnowledgeNode.deserializeStringList(rs.getString("domains")));
        } catch (SQLException e) {
            // Column doesn't exist
        }
        try {
            node.setRegistryKeys(KnowledgeNode.deserializeStringList(rs.getString("registry_keys")));
        } catch (SQLException e) {
            // Column doesn't exist
        }
        try {
            node.setRiskLevel(rs.getString("risk_level"));
        } catch (SQLException e) {
            // Column doesn't exist
        }
        try {
            node.setActivityProfile(rs.getString("activity_profile"));
        } catch (SQLException e) {
            // Column doesn't exist
        }

        return node;
    }

    private String escapeFtsQuery(String query) {
        if (query == null || query.trim().isEmpty()) {
            return "\"\"";
        }

        String[] words = query.trim().split("\\s+");
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < words.length; i++) {
            String word = words[i];
            if (word.isEmpty()) continue;

            // Skip FTS5 operator keywords so they don't become literal terms
            if (word.equalsIgnoreCase("OR") || word.equalsIgnoreCase("AND") || word.equalsIgnoreCase("NOT")) {
                continue;
            }

            word = word.replace("\"", "\"\"");
            word = word.replace("*", "");

            if (sb.length() > 0) {
                sb.append(" OR ");
            }

            sb.append("\"").append(word).append("\"");
        }

        return sb.length() > 0 ? sb.toString() : "\"\"";
    }

    // ========================================
    // Inner Classes
    // ========================================

    /**
     * Custom edge class that carries the edge type label.
     */
    public static class LabeledEdge extends DefaultEdge {
        private static final long serialVersionUID = 1L;
        private final EdgeType type;

        public LabeledEdge(EdgeType type) {
            this.type = type;
        }

        public EdgeType getType() {
            return type;
        }

        @Override
        public String toString() {
            return type != null ? type.getDisplayName() : "edge";
        }
    }

    /**
     * Data class representing a graph edge with full details.
     */
    public static class GraphEdge {
        private final String id;
        private final String sourceId;
        private final String targetId;
        private final EdgeType type;
        private final double weight;
        private final String metadata;

        public GraphEdge(String id, String sourceId, String targetId, EdgeType type,
                         double weight, String metadata) {
            this.id = id;
            this.sourceId = sourceId;
            this.targetId = targetId;
            this.type = type;
            this.weight = weight;
            this.metadata = metadata;
        }

        public String getId() { return id; }
        public String getSourceId() { return sourceId; }
        public String getTargetId() { return targetId; }
        public EdgeType getType() { return type; }
        public double getWeight() { return weight; }
        public String getMetadata() { return metadata; }
    }
}

```

`src/main/java/ghidrassist/graphrag/GraphRAGEngine.java`:

```java
package ghidrassist.graphrag;

import ghidra.util.Msg;

import ghidrassist.graphrag.community.Community;
import ghidrassist.graphrag.nodes.KnowledgeNode;
import ghidrassist.graphrag.nodes.NodeType;
import ghidrassist.graphrag.query.*;
import ghidrassist.graphrag.query.GlobalQueryResult.CommunityInsight;

import java.util.*;
import java.util.stream.Collectors;

/**
 * LLM-Free Query Engine for Graph-RAG semantic queries.
 *
 * CRITICAL: All query methods in this class are LLM-free. They only perform:
 * - Graph traversal
 * - SQLite queries
 * - Full-text search (FTS5)
 *
 * LLM calls happen ONLY during indexing (via SemanticExtractor), not here.
 *
 * This engine provides MCP-style tools that return pre-computed semantic analysis:
 * - get_semantic_analysis() - Returns cached LLM summary and metadata
 * - get_similar_functions() - Graph-based similarity search
 * - get_call_context() - Caller/callee context with summaries
 * - get_security_analysis() - Security flags and taint paths
 * - search_semantic() - FTS search on cached summaries
 * - get_module_summary() - Community/module summary
 */
public class GraphRAGEngine {

    private final BinaryKnowledgeGraph graph;
    // NOTE: No LLMClient field - queries don't use LLM!

    public GraphRAGEngine(BinaryKnowledgeGraph graph) {
        this.graph = graph;
    }

    // ========================================
    // LLM-FREE Query Tools (MCP-style)
    // ========================================

    /**
     * Get semantic analysis for a function by address.
     * Returns pre-computed LLM summary (NO LLM call at query time).
     *
     * @param address Function entry point address
     * @return SemanticAnalysis with cached summary, or "not indexed" if not found
     */
    public SemanticAnalysis getSemanticAnalysis(long address) {
        Msg.info(this, "getSemanticAnalysis: Looking up address 0x" + Long.toHexString(address));
        KnowledgeNode node = graph.getNodeByAddress(address);
        Msg.info(this, "getSemanticAnalysis: Graph lookup returned node=" + (node != null ? node.getName() : "null"));
        return buildSemanticAnalysis(node, address);
    }

    /**
     * Get semantic analysis for a function by name.
     * Returns pre-computed LLM summary (NO LLM call at query time).
     *
     * @param functionName Function name
     * @return SemanticAnalysis with cached summary, or "not indexed" if not found
     */
    public SemanticAnalysis getSemanticAnalysis(String functionName) {
        Msg.info(this, "getSemanticAnalysis: Looking up function name: " + functionName);
        KnowledgeNode node = graph.getNodeByName(functionName);
        Msg.info(this, "getSemanticAnalysis: Graph lookup returned node=" + (node != null ? node.getName() : "null"));
        return buildSemanticAnalysis(node, node != null && node.getAddress() != null ? node.getAddress() : 0);
    }

    private SemanticAnalysis buildSemanticAnalysis(KnowledgeNode node, long address) {
        if (node == null) {
            Msg.info(this, "buildSemanticAnalysis: Node is null for address 0x" + Long.toHexString(address));
            return SemanticAnalysis.notIndexed("unknown", address);
        }

        // Check if we have any useful data
        boolean hasRawContent = node.getRawContent() != null && !node.getRawContent().isEmpty();
        boolean hasLlmSummary = node.getLlmSummary() != null && !node.getLlmSummary().isEmpty();
        Msg.info(this, "buildSemanticAnalysis: Node found - name=" + node.getName() +
                ", hasRawContent=" + hasRawContent + ", hasLlmSummary=" + hasLlmSummary +
                ", rawContentLen=" + (node.getRawContent() != null ? node.getRawContent().length() : 0));

        // If no data at all, return not indexed
        if (!hasRawContent && !hasLlmSummary) {
            return SemanticAnalysis.notIndexed(node.getName(), address);
        }

        // Get callers and callees
        List<String> callers = graph.getCallers(node.getId()).stream()
                .map(n -> n.getName() != null ? n.getName() :
                        (n.getAddress() != null ? String.format("sub_%x", n.getAddress()) : "unknown"))
                .collect(Collectors.toList());

        List<String> callees = graph.getCallees(node.getId()).stream()
                .map(n -> n.getName() != null ? n.getName() :
                        (n.getAddress() != null ? String.format("sub_%x", n.getAddress()) : "unknown"))
                .collect(Collectors.toList());

        // Get community if available
        String community = getCommunityNameForNode(node.getId());

        // Extract category from summary if present
        String category = extractCategory(node.getLlmSummary());

        // indexed=true means we have SOME useful data (structure or semantic)
        // The SemanticAnalysis.hasSemanticAnalysis() method checks for LLM summary specifically
        boolean indexed = hasRawContent || hasLlmSummary;

        return new SemanticAnalysis(
                node.getName(),
                node.getAddress(),
                node.getLlmSummary(),
                node.getSecurityFlags() != null ? node.getSecurityFlags() : List.of(),
                category,
                node.getConfidence(),
                callers,
                callees,
                community,
                node.getRawContent(),
                indexed
        );
    }

    /**
     * Get similar functions based on graph structure.
     * NO LLM call - uses graph traversal and FTS matching.
     *
     * @param address Function address
     * @param limit Maximum results to return
     * @return List of similar functions with similarity scores
     */
    public List<SimilarFunction> getSimilarFunctions(long address, int limit) {
        List<SimilarFunction> results = new ArrayList<>();
        KnowledgeNode sourceNode = graph.getNodeByAddress(address);

        if (sourceNode == null) {
            return results;
        }

        Set<String> addedIds = new HashSet<>();
        addedIds.add(sourceNode.getId()); // Exclude self

        // Strategy 1: Functions in same community (highest similarity)
        // TODO: Implement when community detection is ready

        // Strategy 2: Functions that share callers (similar role)
        List<KnowledgeNode> callers = graph.getCallers(sourceNode.getId());
        for (KnowledgeNode caller : callers) {
            for (KnowledgeNode sibling : graph.getCallees(caller.getId())) {
                if (!addedIds.contains(sibling.getId()) && sibling.getType() == NodeType.FUNCTION && sibling.getAddress() != null) {
                    addedIds.add(sibling.getId());
                    results.add(new SimilarFunction(
                            sibling.getName(),
                            sibling.getAddress(),
                            sibling.getLlmSummary(),
                            0.7f,
                            SimilarFunction.SimilarityType.SHARED_CALLERS
                    ));
                    if (results.size() >= limit) break;
                }
            }
            if (results.size() >= limit) break;
        }

        // Strategy 3: Functions that share callees (similar dependencies)
        if (results.size() < limit) {
            List<KnowledgeNode> callees = graph.getCallees(sourceNode.getId());
            for (KnowledgeNode callee : callees) {
                for (KnowledgeNode sibling : graph.getCallers(callee.getId())) {
                    if (!addedIds.contains(sibling.getId()) && sibling.getType() == NodeType.FUNCTION && sibling.getAddress() != null) {
                        addedIds.add(sibling.getId());
                        results.add(new SimilarFunction(
                                sibling.getName(),
                                sibling.getAddress(),
                                sibling.getLlmSummary(),
                                0.6f,
                                SimilarFunction.SimilarityType.SHARED_CALLEES
                        ));
                        if (results.size() >= limit) break;
                    }
                }
                if (results.size() >= limit) break;
            }
        }

        // Strategy 4: FTS search on summary keywords
        if (results.size() < limit && sourceNode.getLlmSummary() != null) {
            // Extract keywords from summary
            String[] keywords = extractKeywords(sourceNode.getLlmSummary());
            if (keywords.length > 0) {
                String query = String.join(" OR ", keywords);
                List<KnowledgeNode> ftsResults = graph.ftsSearch(query, limit - results.size() + 5);
                for (KnowledgeNode match : ftsResults) {
                    if (!addedIds.contains(match.getId()) && match.getType() == NodeType.FUNCTION && match.getAddress() != null) {
                        addedIds.add(match.getId());
                        results.add(new SimilarFunction(
                                match.getName(),
                                match.getAddress(),
                                match.getLlmSummary(),
                                0.5f,
                                SimilarFunction.SimilarityType.FTS_MATCH
                        ));
                        if (results.size() >= limit) break;
                    }
                }
            }
        }

        // Sort by similarity score descending
        results.sort((a, b) -> Float.compare(b.getSimilarityScore(), a.getSimilarityScore()));

        return results.subList(0, Math.min(results.size(), limit));
    }

    /**
     * Get call context for a function with semantic summaries.
     * NO LLM call - retrieves pre-computed summaries from graph.
     *
     * @param address Function address
     * @param depth How many levels of callers/callees to include
     * @param direction CALLERS, CALLEES, or BOTH
     * @return CallContext with caller/callee summaries
     */
    public CallContext getCallContext(long address, int depth, CallContext.Direction direction) {
        KnowledgeNode centerNode = graph.getNodeByAddress(address);

        if (centerNode == null) {
            return new CallContext(
                    new CallContext.FunctionSummary("unknown", address, "Function not found in graph", List.of()),
                    List.of(),
                    List.of()
            );
        }

        CallContext.FunctionSummary center = nodeToFunctionSummary(centerNode);

        List<CallContext.ContextEntry> callers = new ArrayList<>();
        List<CallContext.ContextEntry> callees = new ArrayList<>();

        if (direction == CallContext.Direction.CALLERS || direction == CallContext.Direction.BOTH) {
            collectCallContext(centerNode.getId(), depth, true, callers, new HashSet<>());
        }

        if (direction == CallContext.Direction.CALLEES || direction == CallContext.Direction.BOTH) {
            collectCallContext(centerNode.getId(), depth, false, callees, new HashSet<>());
        }

        return new CallContext(center, callers, callees);
    }

    private void collectCallContext(String nodeId, int maxDepth, boolean callers,
                                     List<CallContext.ContextEntry> results, Set<String> visited) {
        collectCallContextRecursive(nodeId, 1, maxDepth, callers, results, visited);
    }

    private void collectCallContextRecursive(String nodeId, int currentDepth, int maxDepth,
                                              boolean callers, List<CallContext.ContextEntry> results,
                                              Set<String> visited) {
        if (currentDepth > maxDepth) return;

        List<KnowledgeNode> neighbors = callers ?
                graph.getCallers(nodeId) : graph.getCallees(nodeId);

        for (KnowledgeNode neighbor : neighbors) {
            // Skip nodes without addresses (external functions, modules, etc.)
            if (neighbor.getAddress() == null) {
                continue;
            }
            if (visited.contains(neighbor.getId())) continue;
            visited.add(neighbor.getId());

            CallContext.FunctionSummary summary = nodeToFunctionSummary(neighbor);
            results.add(new CallContext.ContextEntry(currentDepth, summary));

            // Recurse
            collectCallContextRecursive(neighbor.getId(), currentDepth + 1, maxDepth,
                    callers, results, visited);
        }
    }

    private CallContext.FunctionSummary nodeToFunctionSummary(KnowledgeNode node) {
        return new CallContext.FunctionSummary(
                node.getName() != null ? node.getName() : String.format("sub_%x", node.getAddress()),
                node.getAddress(),
                node.getLlmSummary(),
                node.getSecurityFlags() != null ? node.getSecurityFlags() : List.of()
        );
    }

    /**
     * Get security analysis for a function.
     * NO LLM call - retrieves pre-computed security flags from graph.
     *
     * @param address Function address
     * @return SecurityAnalysis with flags and taint paths
     */
    public SecurityAnalysis getSecurityAnalysis(long address) {
        KnowledgeNode node = graph.getNodeByAddress(address);

        if (node == null) {
            return new SecurityAnalysis("function", "unknown", List.of(), List.of(), List.of(), List.of());
        }

        // Get security flags for this function
        List<String> flags = node.getSecurityFlags() != null ?
                node.getSecurityFlags() : List.of();

        // Find callers of this function that might propagate vulnerabilities
        List<String> vulnerableCallers = new ArrayList<>();
        for (KnowledgeNode caller : graph.getCallers(node.getId())) {
            if (caller.hasSecurityFlags()) {
                vulnerableCallers.add(caller.getName() != null ? caller.getName() :
                        String.format("sub_%x", caller.getAddress()));
            }
        }

        // TODO: Implement taint path finding
        List<SecurityAnalysis.TaintPath> taintPaths = List.of();

        // TODO: Implement attack surface detection
        List<String> attackSurface = List.of();

        return new SecurityAnalysis(
                "function",
                node.getName() != null ? node.getName() : String.format("sub_%x", node.getAddress()),
                flags,
                taintPaths,
                attackSurface,
                vulnerableCallers
        );
    }

    /**
     * Get security analysis for entire binary.
     * NO LLM call - aggregates pre-computed security flags from graph.
     *
     * @param binaryId Program hash
     * @return SecurityAnalysis with binary-wide security information
     */
    public SecurityAnalysis getBinarySecurityAnalysis(String binaryId) {
        // Get all nodes with security flags
        List<KnowledgeNode> allNodes = graph.getNodesByType(NodeType.FUNCTION);

        Set<String> allFlags = new HashSet<>();
        List<String> flaggedFunctions = new ArrayList<>();

        for (KnowledgeNode node : allNodes) {
            if (node.hasSecurityFlags()) {
                allFlags.addAll(node.getSecurityFlags());
                flaggedFunctions.add(node.getName() != null ? node.getName() :
                        String.format("sub_%x", node.getAddress()));
            }
        }

        // Get attack surface (entry points, external-facing functions)
        List<String> attackSurface = new ArrayList<>();
        List<KnowledgeNode> binaryNodes = graph.getNodesByType(NodeType.BINARY);
        if (!binaryNodes.isEmpty()) {
            // TODO: Extract entry points from binary node
        }

        return new SecurityAnalysis(
                "binary",
                binaryId,
                new ArrayList<>(allFlags),
                List.of(), // TODO: Binary-wide taint paths
                attackSurface,
                flaggedFunctions
        );
    }

    /**
     * Search for functions by semantic query.
     * NO LLM call - uses SQLite FTS5 on pre-computed summaries.
     *
     * @param query Search query (keywords, phrases)
     * @param limit Maximum results
     * @return List of matching functions with relevance scores
     */
    public List<SearchResult> searchSemantic(String query, int limit) {
        List<KnowledgeNode> ftsResults = graph.ftsSearch(query, limit);

        return ftsResults.stream()
                .filter(node -> node.getType() == NodeType.FUNCTION)
                .map(node -> new SearchResult(
                        node.getName() != null ? node.getName() : String.format("sub_%x", node.getAddress()),
                        node.getAddress(),
                        node.getLlmSummary(),
                        1.0f, // TODO: Get actual FTS rank
                        "fts_match",
                        null // TODO: Extract matched text
                ))
                .collect(Collectors.toList());
    }

    /**
     * Get module/community summary for a function.
     * NO LLM call - retrieves pre-computed community summary from graph.
     *
     * @param functionAddress Address of function to get community for
     * @return ModuleSummary with community information
     */
    public ModuleSummary getModuleSummary(long functionAddress) {
        KnowledgeNode node = graph.getNodeByAddress(functionAddress);

        if (node == null) {
            return ModuleSummary.notFound(String.format("sub_%x", functionAddress));
        }

        String functionName = node.getName() != null ? node.getName() :
                String.format("sub_%x", functionAddress);

        // Look up community for this node
        String communityId = graph.getNodeCommunity(node.getId());
        if (communityId == null) {
            return ModuleSummary.notFound(functionName);
        }

        // Get community details
        Community community = graph.getCommunity(communityId);
        if (community == null) {
            return ModuleSummary.notFound(functionName);
        }

        // Get community members
        List<KnowledgeNode> members = graph.getCommunityMembers(communityId);
        List<String> memberNames = members.stream()
                .map(m -> m.getName() != null ? m.getName() : String.format("sub_%x", m.getAddress()))
                .collect(Collectors.toList());

        // Identify key functions (those with security flags or most connections)
        List<String> keyFunctions = members.stream()
                .filter(m -> m.getSecurityFlags() != null && !m.getSecurityFlags().isEmpty())
                .map(m -> m.getName() != null ? m.getName() : String.format("sub_%x", m.getAddress()))
                .limit(5)
                .collect(Collectors.toList());

        // Collect security relevance from member security flags
        Set<String> allFlags = new HashSet<>();
        for (KnowledgeNode member : members) {
            if (member.getSecurityFlags() != null) {
                allFlags.addAll(member.getSecurityFlags());
            }
        }
        String securityRelevance = allFlags.isEmpty() ? null : String.join(", ", allFlags);

        // Build ModuleSummary
        return new ModuleSummary(
                communityId,
                community.getName(),
                community.getSummary(),
                memberNames,
                keyFunctions,
                securityRelevance,
                community.getLevel()
        );
    }

    /**
     * Get community name for a node ID.
     * Helper method for community lookup.
     */
    private String getCommunityNameForNode(String nodeId) {
        String communityId = graph.getNodeCommunity(nodeId);
        if (communityId == null) {
            return null;
        }

        Community community = graph.getCommunity(communityId);
        return community != null ? community.getName() : null;
    }

    // ========================================
    // Global Query (Map-Reduce over Communities)
    // ========================================

    /**
     * Execute a global query across all communities.
     * NO LLM call - aggregates pre-computed community/function data.
     *
     * @param communityLevel Community level to query (0 = function communities)
     * @return GlobalQueryResult with aggregated insights
     */
    public GlobalQueryResult globalQuery(int communityLevel) {
        Msg.info(this, "Executing global query at community level " + communityLevel);

        GlobalQueryResult result = new GlobalQueryResult(graph.getBinaryId());

        // Get all communities at this level
        List<Community> communities = graph.getCommunitiesForBinary(communityLevel);
        if (communities.isEmpty()) {
            result.addKeyFinding("No communities detected. Run community detection first.");
            return result;
        }

        // Count total functions
        int totalFunctions = graph.getNodesByType(NodeType.FUNCTION).size();
        result.setTotalFunctions(totalFunctions);

        // MAP PHASE: Extract insights from each community
        Map<String, Integer> allFlags = new HashMap<>();
        List<String> attackSurfaceFunctions = new ArrayList<>();

        for (Community community : communities) {
            CommunityInsight insight = buildCommunityInsight(community);
            result.addCommunity(insight);

            // Aggregate security flags
            for (String flag : insight.getSecurityFlags()) {
                allFlags.merge(flag, 1, Integer::sum);
            }

            // Collect attack surface functions (those with dangerous flags)
            for (String func : insight.getKeyFunctions()) {
                if (isAttackSurfaceCandidate(insight.getSecurityFlags())) {
                    attackSurfaceFunctions.add(func);
                }
            }
        }

        // Set aggregated security flags
        result.setSecurityFlagCounts(allFlags);

        // Set attack surface
        result.setAttackSurface(attackSurfaceFunctions);

        // REDUCE PHASE: Sort communities by security relevance then size
        List<CommunityInsight> sortedCommunities = new ArrayList<>(result.getCommunities());
        sortedCommunities.sort((a, b) -> {
            // First by security score (higher first)
            int scoreCompare = Integer.compare(b.getSecurityScore(), a.getSecurityScore());
            if (scoreCompare != 0) return scoreCompare;
            // Then by member count (larger first)
            return Integer.compare(b.getMemberCount(), a.getMemberCount());
        });
        result.setCommunities(sortedCommunities);

        // Generate key findings
        List<String> keyFindings = generateKeyFindings(sortedCommunities, allFlags, totalFunctions);
        result.setKeyFindings(keyFindings);

        Msg.info(this, String.format("Global query complete: %d communities, %d functions, %d security flags",
                result.getCommunityCount(), totalFunctions, allFlags.size()));

        return result;
    }

    /**
     * Build insight for a single community.
     * Extracts key functions and aggregates security flags from members.
     */
    private CommunityInsight buildCommunityInsight(Community community) {
        CommunityInsight insight = new CommunityInsight(community.getId(), community.getName());
        insight.setMemberCount(community.getMemberCount());
        insight.setSummary(community.getSummary());

        // Get community members
        List<KnowledgeNode> members = graph.getCommunityMembers(community.getId());

        Set<String> flags = new HashSet<>();
        int securityScore = 0;

        for (KnowledgeNode member : members) {
            String funcName = member.getName() != null ? member.getName() :
                    String.format("sub_%x", member.getAddress());

            // Collect security flags
            if (member.getSecurityFlags() != null && !member.getSecurityFlags().isEmpty()) {
                flags.addAll(member.getSecurityFlags());
                securityScore += member.getSecurityFlags().size();

                // Add as key function if it has security flags
                insight.addKeyFunction(funcName + " @ 0x" + Long.toHexString(member.getAddress()));
            } else if (!funcName.startsWith("FUN_") && !funcName.startsWith("sub_")) {
                // Named functions are also key functions (up to limit)
                if (insight.getKeyFunctions().size() < 10) {
                    insight.addKeyFunction(funcName);
                }
            }
        }

        insight.setSecurityFlags(new ArrayList<>(flags));
        insight.setSecurityScore(securityScore);

        return insight;
    }

    /**
     * Check if a function is an attack surface candidate based on its flags.
     */
    private boolean isAttackSurfaceCandidate(List<String> flags) {
        if (flags == null || flags.isEmpty()) return false;

        Set<String> attackSurfaceFlags = Set.of(
                "BUFFER_OVERFLOW_RISK",
                "COMMAND_INJECTION_RISK",
                "FORMAT_STRING_RISK",
                "PATH_TRAVERSAL_RISK",
                "SQL_INJECTION_RISK",
                "NETWORK_CAPABLE",
                "CALLS_VULNERABLE_FUNCTION"
        );

        for (String flag : flags) {
            if (attackSurfaceFlags.contains(flag)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Generate key findings from aggregated community data.
     */
    private List<String> generateKeyFindings(List<CommunityInsight> communities,
                                              Map<String, Integer> allFlags,
                                              int totalFunctions) {
        List<String> findings = new ArrayList<>();

        // Basic stats
        findings.add(String.format("%d communities detected with %d total functions",
                communities.size(), totalFunctions));

        // Average community size
        if (!communities.isEmpty()) {
            int avgSize = totalFunctions / communities.size();
            findings.add(String.format("Average community size: %d functions", avgSize));
        }

        // Security flag distribution
        if (!allFlags.isEmpty()) {
            // Sort by count descending
            List<Map.Entry<String, Integer>> sortedFlags = allFlags.entrySet().stream()
                    .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
                    .collect(Collectors.toList());

            for (Map.Entry<String, Integer> entry : sortedFlags) {
                // Count how many communities have this flag
                long communitiesWithFlag = communities.stream()
                        .filter(c -> c.getSecurityFlags().contains(entry.getKey()))
                        .count();

                findings.add(String.format("%d functions with %s across %d communities",
                        entry.getValue(), entry.getKey(), communitiesWithFlag));
            }
        }

        // Identify the most security-critical community
        if (!communities.isEmpty() && communities.get(0).getSecurityScore() > 0) {
            CommunityInsight topCommunity = communities.get(0);
            findings.add(String.format("Most security-relevant: %s (%d flags)",
                    topCommunity.getCommunityName(), topCommunity.getSecurityScore()));
        }

        return findings;
    }

    // ========================================
    // Context Building (LLM-free, for LLM input)
    // ========================================

    /**
     * Build rich context string from graph for LLM input.
     * NO LLM call - just formats pre-computed data.
     *
     * @param address Function address
     * @param depth How many levels of context to include
     * @return Formatted context string
     */
    public String buildLocalContext(long address, int depth) {
        SemanticAnalysis analysis = getSemanticAnalysis(address);
        CallContext context = getCallContext(address, depth, CallContext.Direction.BOTH);

        StringBuilder sb = new StringBuilder();
        sb.append("## Function Context\n\n");

        // Function info
        sb.append("### ").append(analysis.getName()).append(" (0x")
                .append(Long.toHexString(analysis.getAddress())).append(")\n\n");

        if (analysis.isIndexed()) {
            if (analysis.getSummary() != null) {
                sb.append("**Summary:** ").append(analysis.getSummary()).append("\n\n");
            }
            if (analysis.hasSecurityConcerns()) {
                sb.append("**Security Flags:** ").append(String.join(", ", analysis.getSecurityFlags())).append("\n\n");
            }
        } else {
            sb.append("*Function not yet indexed - summary unavailable*\n\n");
        }

        // Callers
        if (!context.getCallers().isEmpty()) {
            sb.append("**Called by:**\n");
            for (CallContext.ContextEntry entry : context.getCallers()) {
                sb.append("- ").append(entry.getFunction().getName());
                if (entry.getFunction().getSummary() != null) {
                    sb.append(": ").append(truncate(entry.getFunction().getSummary(), 100));
                }
                sb.append("\n");
            }
            sb.append("\n");
        }

        // Callees
        if (!context.getCallees().isEmpty()) {
            sb.append("**Calls:**\n");
            for (CallContext.ContextEntry entry : context.getCallees()) {
                sb.append("- ").append(entry.getFunction().getName());
                if (entry.getFunction().getSummary() != null) {
                    sb.append(": ").append(truncate(entry.getFunction().getSummary(), 100));
                }
                sb.append("\n");
            }
            sb.append("\n");
        }

        // Raw code (truncated)
        if (analysis.getRawCode() != null) {
            sb.append("**Decompiled Code:**\n```c\n");
            sb.append(truncate(analysis.getRawCode(), 2000));
            sb.append("\n```\n");
        }

        return sb.toString();
    }

    /**
     * Build global context for binary.
     * NO LLM call - aggregates pre-computed data.
     */
    public String buildGlobalContext(String binaryId) {
        StringBuilder sb = new StringBuilder();
        sb.append("## Binary Context\n\n");

        // Get binary node
        List<KnowledgeNode> binaryNodes = graph.getNodesByType(NodeType.BINARY);
        if (!binaryNodes.isEmpty()) {
            KnowledgeNode binaryNode = binaryNodes.get(0);
            if (binaryNode.getLlmSummary() != null) {
                sb.append("**Summary:** ").append(binaryNode.getLlmSummary()).append("\n\n");
            }
            if (binaryNode.getRawContent() != null) {
                sb.append(binaryNode.getRawContent()).append("\n\n");
            }
        }

        // Get security overview
        SecurityAnalysis security = getBinarySecurityAnalysis(binaryId);
        if (security.hasSecurityIssues()) {
            sb.append("**Security Flags:** ").append(String.join(", ", security.getSecurityFlags())).append("\n\n");
        }

        // Graph stats
        sb.append("**Graph Statistics:**\n");
        sb.append("- Functions: ").append(graph.getNodesByType(NodeType.FUNCTION).size()).append("\n");
        sb.append("- Total nodes: ").append(graph.getNodeCount()).append("\n");
        sb.append("- Total edges: ").append(graph.getEdgeCount()).append("\n");

        return sb.toString();
    }

    // ========================================
    // Helper Methods
    // ========================================

    private String extractCategory(String summary) {
        if (summary == null) return null;

        String lower = summary.toLowerCase();
        if (lower.contains("crypto") || lower.contains("encrypt") || lower.contains("decrypt")) {
            return "crypto";
        } else if (lower.contains("network") || lower.contains("socket") || lower.contains("connect")) {
            return "network";
        } else if (lower.contains("auth") || lower.contains("login") || lower.contains("password")) {
            return "authentication";
        } else if (lower.contains("file") || lower.contains("read") || lower.contains("write")) {
            return "io_operations";
        } else if (lower.contains("init") || lower.contains("setup") || lower.contains("constructor")) {
            return "initialization";
        } else if (lower.contains("error") || lower.contains("exception") || lower.contains("handler")) {
            return "error_handling";
        }
        return "utility";
    }

    private String[] extractKeywords(String summary) {
        if (summary == null || summary.isEmpty()) {
            return new String[0];
        }

        // Extract significant words (skip common words)
        Set<String> stopWords = Set.of("the", "a", "an", "is", "are", "was", "were", "be", "been",
                "being", "have", "has", "had", "do", "does", "did", "will", "would", "could", "should",
                "may", "might", "must", "shall", "can", "this", "that", "these", "those", "and", "or",
                "but", "if", "then", "else", "when", "where", "which", "who", "what", "how", "why",
                "to", "from", "for", "with", "without", "in", "on", "at", "by", "of", "as", "it");

        return Arrays.stream(summary.toLowerCase().split("\\W+"))
                .filter(word -> word.length() > 3 && !stopWords.contains(word))
                .limit(5)
                .toArray(String[]::new);
    }

    private String truncate(String text, int maxLength) {
        if (text == null || text.length() <= maxLength) {
            return text;
        }
        return text.substring(0, maxLength) + "...";
    }
}

```

`src/main/java/ghidrassist/graphrag/GraphRAGService.java`:

```java
package ghidrassist.graphrag;

import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import ghidra.util.task.TaskMonitor;

import ghidrassist.AnalysisDB;
import ghidrassist.apiprovider.APIProvider;
import ghidrassist.graphrag.extraction.BackgroundIndexer;
import ghidrassist.graphrag.extraction.SemanticExtractor;
import ghidrassist.graphrag.extraction.StructureExtractor;
import ghidrassist.graphrag.nodes.KnowledgeNode;
import ghidrassist.graphrag.nodes.NodeType;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Main service facade for the Graph-RAG knowledge system.
 *
 * Provides high-level APIs for:
 * - Cached decompilation (primary use case to avoid redundant decompile calls)
 * - Graph population and indexing
 * - Semantic search and traversal
 * - Context building for LLM queries
 *
 * This is the main entry point for other components to interact with the Graph-RAG system.
 */
public class GraphRAGService {

    private static GraphRAGService instance;

    private final AnalysisDB analysisDB;
    private final Map<String, BackgroundIndexer> activeIndexers = new ConcurrentHashMap<>();

    // Optional LLM provider for semantic extraction
    private APIProvider llmProvider;

    // Background semantic analysis queue
    private final ScheduledExecutorService semanticWorker = Executors.newSingleThreadScheduledExecutor(r -> {
        Thread t = new Thread(r, "GraphRAG-SemanticWorker");
        t.setDaemon(true);
        return t;
    });
    private final ConcurrentLinkedQueue<SemanticQueueEntry> semanticQueue = new ConcurrentLinkedQueue<>();
    private volatile boolean semanticWorkerRunning = false;
    private volatile Program currentProgram;  // For background processing
    private volatile SemanticExtractor currentExtractor;  // For cancellation support

    /**
     * Entry in the semantic analysis queue.
     */
    private static class SemanticQueueEntry {
        final long address;
        final String programHash;
        int retryCount;

        SemanticQueueEntry(long address, String programHash) {
            this.address = address;
            this.programHash = programHash;
            this.retryCount = 0;
        }
    }

    private GraphRAGService(AnalysisDB analysisDB) {
        this.analysisDB = analysisDB;
    }

    /**
     * Get the singleton instance.
     */
    public static synchronized GraphRAGService getInstance(AnalysisDB analysisDB) {
        if (instance == null) {
            instance = new GraphRAGService(analysisDB);
        }
        return instance;
    }

    /**
     * Set the LLM provider for semantic extraction.
     * Required for LLM summarization; if not set, only structural extraction works.
     */
    public void setLLMProvider(APIProvider provider) {
        this.llmProvider = provider;
        if (provider != null) {
            Msg.info(this, "LLM provider set for background semantic analysis: " + provider.getType());
        } else {
            Msg.warn(this, "LLM provider set to null - background semantic analysis disabled");
        }
        // Start background worker if provider is now available and queue has items
        if (provider != null && !semanticQueue.isEmpty()) {
            ensureSemanticWorkerRunning();
        }
    }

    /**
     * Check if an LLM provider is configured.
     */
    public boolean hasLlmProvider() {
        return llmProvider != null;
    }

    /**
     * Set the current program for background processing.
     * This should be called when the program changes in the UI.
     */
    public void setCurrentProgram(Program program) {
        this.currentProgram = program;
    }

    // ========================================
    // Background Semantic Analysis Queue
    // ========================================

    /**
     * Queue a function for background LLM semantic analysis.
     * This method returns immediately; analysis happens asynchronously.
     *
     * @param address Function entry point address
     * @param programHash SHA256 hash of the program binary
     */
    public void queueForSemanticAnalysis(long address, String programHash) {
        if (programHash == null) {
            Msg.warn(this, "Cannot queue for semantic analysis: no program hash");
            return;
        }

        // Check if already in queue (simple O(n) check, acceptable for typical queue sizes)
        boolean alreadyQueued = semanticQueue.stream()
                .anyMatch(e -> e.address == address && e.programHash.equals(programHash));

        if (!alreadyQueued) {
            semanticQueue.offer(new SemanticQueueEntry(address, programHash));
            Msg.info(this, String.format("Queued function 0x%x for background semantic analysis (%d in queue)",
                    address, semanticQueue.size()));
            ensureSemanticWorkerRunning();
        }
    }

    /**
     * Queue a function for background LLM semantic analysis using current program.
     *
     * @param address Function entry point address
     */
    public void queueForSemanticAnalysis(long address) {
        if (currentProgram != null) {
            queueForSemanticAnalysis(address, currentProgram.getExecutableSHA256());
        } else {
            Msg.warn(this, "Cannot queue for semantic analysis: no current program set");
        }
    }

    /**
     * Get the current size of the semantic analysis queue.
     */
    public int getSemanticQueueSize() {
        return semanticQueue.size();
    }

    /**
     * Ensure the background semantic worker is running.
     */
    private void ensureSemanticWorkerRunning() {
        if (semanticWorkerRunning) {
            Msg.debug(this, "Semantic worker already running");
            return;
        }
        if (llmProvider == null) {
            Msg.warn(this, "Cannot start semantic worker: no LLM provider configured");
            return;
        }
        semanticWorkerRunning = true;
        // Start worker: initial delay 2 seconds, then every 5 seconds
        semanticWorker.scheduleWithFixedDelay(this::processSemanticQueue, 2, 5, TimeUnit.SECONDS);
        Msg.info(this, "Started background semantic analysis worker");
    }

    /**
     * Background worker method: processes the semantic analysis queue.
     * Runs periodically and respects rate limits.
     */
    private void processSemanticQueue() {
        if (llmProvider == null) {
            Msg.debug(this, "processSemanticQueue: no LLM provider");
            return;
        }
        if (semanticQueue.isEmpty()) {
            return; // Normal case, don't log
        }

        Msg.info(this, "processSemanticQueue: processing " + semanticQueue.size() + " queued functions");

        // Determine batch size based on provider type
        int batchSize = isLocalProvider() ? 10 : 3;
        List<SemanticQueueEntry> batch = new ArrayList<>();

        // Poll batch from queue
        for (int i = 0; i < batchSize && !semanticQueue.isEmpty(); i++) {
            SemanticQueueEntry entry = semanticQueue.poll();
            if (entry != null) {
                batch.add(entry);
            }
        }

        if (batch.isEmpty()) {
            return;
        }

        Msg.info(this, String.format("Processing semantic analysis batch: %d functions", batch.size()));

        for (SemanticQueueEntry entry : batch) {
            try {
                processSemanticEntry(entry);
            } catch (Exception e) {
                Msg.error(this, "Failed to process semantic entry: " + e.getMessage(), e);
                // Re-queue with retry limit
                if (entry.retryCount < 3) {
                    entry.retryCount++;
                    semanticQueue.offer(entry);
                } else {
                    Msg.warn(this, String.format("Giving up on function 0x%x after %d retries",
                            entry.address, entry.retryCount));
                }
            }
        }

        // Rebuild FTS to reflect newly-summarized nodes
        analysisDB.rebuildFts();
    }

    /**
     * Process a single semantic queue entry.
     */
    private void processSemanticEntry(SemanticQueueEntry entry) {
        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(entry.programHash);
        if (graph == null) {
            Msg.warn(this, "No graph found for program hash: " + entry.programHash);
            return;
        }

        // Check if node exists and needs summarization
        KnowledgeNode node = graph.getNodeByAddress(entry.address);
        if (node == null) {
            Msg.debug(this, String.format("Node not found for 0x%x, skipping semantic analysis", entry.address));
            return;
        }

        // Skip if already has a summary and is not stale
        if (node.getLlmSummary() != null && !node.getLlmSummary().isEmpty() && !node.isStale()) {
            Msg.debug(this, String.format("Node 0x%x already has summary, skipping", entry.address));
            return;
        }

        // Run semantic extraction
        SemanticExtractor extractor = new SemanticExtractor(llmProvider, graph);
        boolean success = extractor.summarizeNode(node);

        if (success) {
            Msg.info(this, String.format("Completed semantic analysis for 0x%x", entry.address));
        } else {
            Msg.warn(this, String.format("Semantic analysis failed for 0x%x", entry.address));
        }
    }

    /**
     * Check if the current LLM provider is local (faster rate limits).
     */
    private boolean isLocalProvider() {
        if (llmProvider == null) return false;
        APIProvider.ProviderType type = llmProvider.getType();
        return type == APIProvider.ProviderType.OLLAMA ||
               type == APIProvider.ProviderType.LMSTUDIO;
    }

    // ========================================
    // Cached Decompilation (Primary Use Case)
    // ========================================

    /**
     * Get decompiled code for a function, using cache if available.
     * This is the main method to replace direct decompilation calls.
     *
     * Falls back to live decompilation if not cached.
     *
     * @param function The function to decompile
     * @param monitor  Task monitor for decompilation
     * @return Decompiled code, or null if failed
     */
    public String getCachedDecompiledCode(Function function, TaskMonitor monitor) {
        if (function == null) {
            return null;
        }

        Program program = function.getProgram();
        String programHash = program.getExecutableSHA256();
        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);

        // Check cache first
        String cached = graph.getCachedDecompiledCode(function.getEntryPoint().getOffset());
        if (cached != null) {
            Msg.debug(this, "GraphRAG cache hit: " + function.getName());
            return cached;
        }

        // Cache miss - decompile and cache
        Msg.debug(this, "GraphRAG cache miss: " + function.getName() + " - decompiling...");
        StructureExtractor extractor = new StructureExtractor(program, graph, monitor);
        try {
            return extractor.getDecompiledCode(function);
        } finally {
            extractor.dispose();
        }
    }

    /**
     * Get decompiled code by address.
     */
    public String getCachedDecompiledCode(Program program, Address address, TaskMonitor monitor) {
        if (program == null || address == null) {
            return null;
        }

        Function function = program.getFunctionManager().getFunctionContaining(address);
        if (function == null) {
            return null;
        }

        return getCachedDecompiledCode(function, monitor);
    }

    /**
     * Check if a function is already cached.
     */
    public boolean isFunctionCached(Function function) {
        if (function == null) {
            return false;
        }

        String programHash = function.getProgram().getExecutableSHA256();
        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);
        return graph.hasFunctionCached(function.getEntryPoint().getOffset());
    }

    // ========================================
    // Graph Population / Indexing
    // ========================================

    /**
     * Start background indexing of a program.
     *
     * @param program       The program to index
     * @param monitor       Task monitor
     * @param includeBlocks Whether to extract basic blocks (increases size)
     * @param runSemantic   Whether to run LLM summarization
     * @param callback      Optional callback for status updates
     * @return The BackgroundIndexer instance for tracking progress
     */
    public BackgroundIndexer startIndexing(Program program, TaskMonitor monitor,
                                            boolean includeBlocks, boolean runSemantic,
                                            BackgroundIndexer.IndexingCallback callback) {
        String programHash = program.getExecutableSHA256();

        // Check if already indexing
        BackgroundIndexer existing = activeIndexers.get(programHash);
        if (existing != null && existing.isRunning()) {
            Msg.warn(this, "Indexing already in progress for: " + program.getName());
            return existing;
        }

        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);
        BackgroundIndexer indexer = new BackgroundIndexer(program, graph, monitor);

        if (llmProvider != null) {
            indexer.setProvider(llmProvider);
        }

        if (callback != null) {
            indexer.setCallback(callback);
        }

        activeIndexers.put(programHash, indexer);

        int summarizeLimit = runSemantic ? 500 : 0; // Limit initial summarization
        indexer.start(includeBlocks, runSemantic, summarizeLimit);

        return indexer;
    }

    /**
     * Run structure extraction synchronously (blocking).
     * Use when you need immediate results.
     */
    public StructureExtractor.ExtractionResult indexStructureSync(Program program,
                                                                    TaskMonitor monitor,
                                                                    boolean includeBlocks) {
        return indexStructureSync(program, monitor, includeBlocks, false);
    }

    /**
     * Run structure extraction synchronously with optional incremental mode.
     *
     * @param program       The program to index
     * @param monitor       Task monitor for progress/cancellation
     * @param includeBlocks Whether to extract basic blocks
     * @param incremental   If true, preserves existing semantic data (summaries, embeddings, flags)
     * @return Extraction result with statistics
     */
    public StructureExtractor.ExtractionResult indexStructureSync(Program program,
                                                                    TaskMonitor monitor,
                                                                    boolean includeBlocks,
                                                                    boolean incremental) {
        String programHash = program.getExecutableSHA256();
        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);

        return BackgroundIndexer.runStructureSync(program, graph, monitor, includeBlocks, incremental);
    }

    /**
     * Run semantic extraction (LLM summarization) on stale nodes.
     *
     * @param program  The program
     * @param limit    Max nodes to summarize (0 = all)
     * @param callback Progress callback
     * @return Extraction result
     */
    public SemanticExtractor.ExtractionResult summarizeStaleNodes(Program program,
                                                                    int limit,
                                                                    SemanticExtractor.ProgressCallback callback) {
        if (llmProvider == null) {
            Msg.warn(this, "No LLM provider configured for semantic extraction");
            return new SemanticExtractor.ExtractionResult(0, 0, 0, 0);
        }

        String programHash = program.getExecutableSHA256();
        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);

        currentExtractor = new SemanticExtractor(llmProvider, graph);
        try {
            return currentExtractor.summarizeStaleNodes(limit, callback);
        } finally {
            currentExtractor = null;  // Clear when done
        }
    }

    /**
     * Cancel any running semantic extraction.
     */
    public void cancelSemanticExtraction() {
        SemanticExtractor extractor = currentExtractor;
        if (extractor != null) {
            extractor.cancel();
        }
    }

    // ========================================
    // Security Flags Update
    // ========================================

    /**
     * Update security flags for a specific function.
     * Re-extracts security features and updates the node's security_flags field.
     *
     * @param function The function to update
     * @param monitor  Task monitor
     * @return true if updated successfully
     */
    public boolean updateSecurityFlags(Function function, TaskMonitor monitor) {
        if (function == null || function.isThunk() || function.isExternal()) {
            return false;
        }

        Program program = function.getProgram();
        String programHash = program.getExecutableSHA256();
        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);

        KnowledgeNode node = graph.getNodeByAddress(function.getEntryPoint().getOffset());
        if (node == null) {
            Msg.debug(this, "No node found for function: " + function.getName());
            return false;
        }

        try {
            ghidrassist.graphrag.extraction.SecurityFeatureExtractor extractor =
                    new ghidrassist.graphrag.extraction.SecurityFeatureExtractor(program, monitor);
            // Pass decompiled code for additional API detection via regex parsing
            String decompiledCode = node.getRawContent();
            ghidrassist.graphrag.extraction.SecurityFeatures features = extractor.extractFeatures(function, decompiledCode);

            if (!features.isEmpty()) {
                node.applySecurityFeatures(features);
                java.util.List<String> securityFlags = features.generateSecurityFlags();
                node.setSecurityFlags(securityFlags);
                graph.upsertNode(node);

                Msg.debug(this, String.format("Updated security flags for %s: %s",
                        function.getName(), securityFlags));
                return true;
            }
        } catch (Exception e) {
            Msg.error(this, "Failed to update security flags for " + function.getName() + ": " + e.getMessage());
        }

        return false;
    }

    /**
     * Update security flags for all function nodes in a program.
     * Useful for populating flags on existing nodes that were indexed before this feature.
     *
     * @param program The program to update
     * @param monitor Task monitor
     * @return Number of nodes updated
     */
    public int updateAllSecurityFlags(Program program, TaskMonitor monitor) {
        if (program == null) {
            return 0;
        }

        String programHash = program.getExecutableSHA256();
        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);
        java.util.List<KnowledgeNode> functionNodes = graph.getNodesByType(NodeType.FUNCTION);

        int updated = 0;
        int total = functionNodes.size();

        monitor.setMessage("Updating security flags...");
        monitor.setMaximum(total);

        ghidrassist.graphrag.extraction.SecurityFeatureExtractor extractor =
                new ghidrassist.graphrag.extraction.SecurityFeatureExtractor(program, monitor);

        for (int i = 0; i < total; i++) {
            if (monitor.isCancelled()) {
                break;
            }

            KnowledgeNode node = functionNodes.get(i);
            monitor.setProgress(i);

            // Skip if node already has security flags
            java.util.List<String> existingFlags = node.getSecurityFlags();
            if (existingFlags != null && !existingFlags.isEmpty()) {
                continue;
            }

            // Get function by address
            Long address = node.getAddress();
            if (address == null || address == 0) {
                continue;
            }

            Function function = program.getFunctionManager().getFunctionAt(
                    program.getAddressFactory().getDefaultAddressSpace().getAddress(address));

            if (function == null || function.isThunk() || function.isExternal()) {
                continue;
            }

            try {
                // Pass decompiled code for additional API detection via regex parsing
                String decompiledCode = node.getRawContent();
                ghidrassist.graphrag.extraction.SecurityFeatures features = extractor.extractFeatures(function, decompiledCode);
                if (!features.isEmpty()) {
                    node.applySecurityFeatures(features);
                    java.util.List<String> securityFlags = features.generateSecurityFlags();
                    node.setSecurityFlags(securityFlags);
                    graph.upsertNode(node);
                    updated++;
                }
            } catch (Exception e) {
                Msg.debug(this, "Failed to update flags for " + node.getName() + ": " + e.getMessage());
            }
        }

        Msg.info(this, String.format("Updated security flags for %d/%d functions", updated, total));
        return updated;
    }

    /**
     * Check if a node needs security flags update.
     * Returns true if the node exists but has no security flags.
     *
     * @param function The function to check
     * @return true if security flags need to be updated
     */
    public boolean needsSecurityFlagsUpdate(Function function) {
        if (function == null) {
            return false;
        }

        String programHash = function.getProgram().getExecutableSHA256();
        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);
        KnowledgeNode node = graph.getNodeByAddress(function.getEntryPoint().getOffset());

        if (node == null) {
            return false;  // Node doesn't exist yet
        }

        java.util.List<String> flags = node.getSecurityFlags();
        return flags == null || flags.isEmpty();
    }

    // ========================================
    // Graph Queries
    // ========================================

    /**
     * Get a knowledge node by function.
     */
    public KnowledgeNode getNode(Function function) {
        if (function == null) {
            return null;
        }

        String programHash = function.getProgram().getExecutableSHA256();
        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);
        return graph.getNodeByAddress(function.getEntryPoint().getOffset());
    }

    /**
     * Get callers of a function.
     */
    public List<KnowledgeNode> getCallers(Function function) {
        KnowledgeNode node = getNode(function);
        if (node == null) {
            return List.of();
        }

        String programHash = function.getProgram().getExecutableSHA256();
        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);
        return graph.getCallers(node.getId());
    }

    /**
     * Get callees of a function.
     */
    public List<KnowledgeNode> getCallees(Function function) {
        KnowledgeNode node = getNode(function);
        if (node == null) {
            return List.of();
        }

        String programHash = function.getProgram().getExecutableSHA256();
        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);
        return graph.getCallees(node.getId());
    }

    /**
     * Full-text search on node summaries.
     */
    public List<KnowledgeNode> searchNodes(Program program, String query, int limit) {
        String programHash = program.getExecutableSHA256();
        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);
        return graph.ftsSearch(query, limit);
    }

    /**
     * Get neighboring nodes within N hops.
     */
    public List<KnowledgeNode> getNeighborhood(Function function, int depth) {
        KnowledgeNode node = getNode(function);
        if (node == null) {
            return List.of();
        }

        String programHash = function.getProgram().getExecutableSHA256();
        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);
        return graph.getNeighborsBatch(node.getId(), depth);
    }

    // ========================================
    // Context Building for LLM
    // ========================================

    /**
     * Build context for a function query (local search).
     * Includes the function's decompiled code, summary, callers, and callees.
     *
     * @param function The function to build context for
     * @param depth    How many hops to include (1 = direct callers/callees)
     * @return Formatted context string for LLM
     */
    public String buildFunctionContext(Function function, int depth) {
        if (function == null) {
            return "";
        }

        KnowledgeNode node = getNode(function);
        if (node == null) {
            return "Function not yet indexed: " + function.getName();
        }

        StringBuilder context = new StringBuilder();

        // Function info
        context.append("## Function: ").append(function.getName()).append("\n\n");

        // Summary if available
        if (node.getLlmSummary() != null && !node.getLlmSummary().isEmpty()) {
            context.append("**Summary:** ").append(node.getLlmSummary()).append("\n\n");
        }

        // Security flags
        if (node.hasSecurityFlags()) {
            context.append("**Security Flags:** ").append(String.join(", ", node.getSecurityFlags())).append("\n\n");
        }

        // Callers
        List<KnowledgeNode> callers = getCallers(function);
        if (!callers.isEmpty()) {
            context.append("**Called by:** ");
            context.append(formatNodeList(callers, 5));
            context.append("\n\n");
        }

        // Callees
        List<KnowledgeNode> callees = getCallees(function);
        if (!callees.isEmpty()) {
            context.append("**Calls:** ");
            context.append(formatNodeList(callees, 5));
            context.append("\n\n");
        }

        // Decompiled code (truncated)
        if (node.getRawContent() != null) {
            String code = node.getRawContent();
            if (code.length() > 3000) {
                code = code.substring(0, 3000) + "\n// ... (truncated)";
            }
            context.append("**Decompiled Code:**\n```c\n").append(code).append("\n```\n");
        }

        return context.toString();
    }

    /**
     * Build global context for a program (binary-level summary).
     */
    public String buildProgramContext(Program program) {
        String programHash = program.getExecutableSHA256();
        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);

        // Get binary node
        List<KnowledgeNode> binaryNodes = graph.getNodesByType(NodeType.BINARY);
        if (binaryNodes.isEmpty()) {
            return "Program not yet indexed: " + program.getName();
        }

        KnowledgeNode binaryNode = binaryNodes.get(0);

        StringBuilder context = new StringBuilder();
        context.append("## Binary: ").append(program.getName()).append("\n\n");

        if (binaryNode.getLlmSummary() != null) {
            context.append(binaryNode.getLlmSummary()).append("\n\n");
        } else if (binaryNode.getRawContent() != null) {
            context.append(binaryNode.getRawContent()).append("\n\n");
        }

        // Add graph stats
        Map<String, Integer> stats = analysisDB.getKnowledgeGraphStats(programHash);
        context.append("**Graph Statistics:**\n");
        context.append("- Nodes: ").append(stats.get("nodes")).append("\n");
        context.append("- Edges: ").append(stats.get("edges")).append("\n");
        context.append("- Stale nodes: ").append(stats.get("stale_nodes")).append("\n");

        return context.toString();
    }

    // ========================================
    // Status and Utilities
    // ========================================

    /**
     * Check if a program has been indexed.
     */
    public boolean isProgramIndexed(Program program) {
        return analysisDB.hasKnowledgeGraph(program.getExecutableSHA256());
    }

    /**
     * Get indexing status for a program.
     */
    public String getIndexingStatus(Program program) {
        String programHash = program.getExecutableSHA256();

        BackgroundIndexer indexer = activeIndexers.get(programHash);
        if (indexer != null && indexer.isRunning()) {
            return String.format("Indexing: %s (%d%%)",
                    indexer.getCurrentPhase(), (int) indexer.getProgressPercent());
        }

        if (analysisDB.hasKnowledgeGraph(programHash)) {
            Map<String, Integer> stats = analysisDB.getKnowledgeGraphStats(programHash);
            return String.format("Indexed: %d nodes, %d edges (%d stale)",
                    stats.get("nodes"), stats.get("edges"), stats.get("stale_nodes"));
        }

        return "Not indexed";
    }

    /**
     * Get graph statistics for a program.
     */
    public Map<String, Integer> getGraphStats(Program program) {
        return analysisDB.getKnowledgeGraphStats(program.getExecutableSHA256());
    }

    /**
     * Clear graph data for a program.
     */
    public void clearGraph(Program program) {
        String programHash = program.getExecutableSHA256();
        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);
        graph.clearGraph();
        analysisDB.rebuildFts();
        analysisDB.invalidateKnowledgeGraphCache(programHash);
    }

    // ========================================
    // Helper Methods
    // ========================================

    private String formatNodeList(List<KnowledgeNode> nodes, int limit) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < Math.min(nodes.size(), limit); i++) {
            if (i > 0) sb.append(", ");
            KnowledgeNode n = nodes.get(i);
            sb.append(n.getName() != null ? n.getName() : String.format("0x%x", n.getAddress()));
        }
        if (nodes.size() > limit) {
            sb.append(String.format(" (+%d more)", nodes.size() - limit));
        }
        return sb.toString();
    }
}

```

`src/main/java/ghidrassist/graphrag/analysis/TaintAnalyzer.java`:

```java
package ghidrassist.graphrag.analysis;

import java.util.*;
import java.util.stream.Collectors;

import org.jgrapht.Graph;
import org.jgrapht.GraphPath;
import org.jgrapht.alg.shortestpath.BFSShortestPath;

import ghidra.util.Msg;

import ghidrassist.graphrag.BinaryKnowledgeGraph;
import ghidrassist.graphrag.BinaryKnowledgeGraph.LabeledEdge;
import ghidrassist.graphrag.nodes.EdgeType;
import ghidrassist.graphrag.nodes.KnowledgeNode;
import ghidrassist.graphrag.nodes.NodeType;

/**
 * Taint analysis for finding data flow paths from sources to sinks.
 *
 * Taint sources are functions that introduce external/untrusted data:
 * - Network input (recv, recvfrom, read from socket)
 * - File input (fread, fgets, ReadFile)
 * - User input (scanf, gets, getenv)
 * - IPC input (recv from pipes, shared memory)
 *
 * Taint sinks are dangerous functions where tainted data can cause harm:
 * - Buffer operations (strcpy, strcat, sprintf, gets)
 * - Command execution (system, popen, exec*, CreateProcess)
 * - File operations (fopen, WriteFile with user-controlled paths)
 * - Format strings (printf with non-constant format)
 */
public class TaintAnalyzer {

    // Maximum path length to prevent explosion
    private static final int MAX_PATH_LENGTH = 10;

    // Taint sources - functions that introduce external/untrusted data
    private static final Set<String> TAINT_SOURCES = new HashSet<>(Arrays.asList(
            // Network input
            "recv", "recvfrom", "recvmsg", "read", "WSARecv", "WSARecvFrom",
            "InternetReadFile", "HttpQueryInfo", "WinHttpReadData",
            // File input
            "fread", "fgets", "fgetc", "getc", "ReadFile", "ReadFileEx",
            "NtReadFile", "ZwReadFile",
            // User input
            "scanf", "fscanf", "sscanf", "gets", "getline", "getdelim",
            "getenv", "GetEnvironmentVariable",
            // IPC input
            "msgrcv", "mq_receive", "ReadEventLog", "PeekNamedPipe",
            // Memory mapped
            "MapViewOfFile", "mmap"
    ));

    // Taint sinks - dangerous functions where tainted data causes harm
    private static final Set<String> TAINT_SINKS = new HashSet<>(Arrays.asList(
            // Buffer overflow risks
            "strcpy", "strcat", "sprintf", "vsprintf", "gets", "wcscpy", "wcscat",
            "lstrcpy", "lstrcpyA", "lstrcpyW", "lstrcat",
            // Format string risks
            "printf", "fprintf", "sprintf", "snprintf", "vprintf", "vfprintf",
            "wprintf", "fwprintf", "swprintf",
            // Command injection risks
            "system", "popen", "_popen", "exec", "execl", "execle", "execlp",
            "execv", "execve", "execvp", "CreateProcess", "CreateProcessA",
            "CreateProcessW", "ShellExecute", "ShellExecuteA", "ShellExecuteW",
            "WinExec",
            // Path traversal risks
            "fopen", "open", "CreateFile", "CreateFileA", "CreateFileW",
            "DeleteFile", "RemoveDirectory", "MoveFile", "CopyFile",
            // SQL injection (if detected)
            "mysql_query", "sqlite3_exec", "PQexec",
            // Memory operations
            "memcpy", "memmove", "memset", "RtlCopyMemory"
    ));

    // Functions that indicate security-relevant flags for sources/sinks
    private static final Set<String> SOURCE_FLAGS = new HashSet<>(Arrays.asList(
            "NETWORK_CAPABLE", "HANDLES_USER_INPUT", "PARSES_NETWORK_DATA",
            "FILE_READER", "ACCEPTS_CONNECTIONS"
    ));

    private static final Set<String> SINK_FLAGS = new HashSet<>(Arrays.asList(
            "BUFFER_OVERFLOW_RISK", "COMMAND_INJECTION_RISK", "FORMAT_STRING_RISK",
            "PATH_TRAVERSAL_RISK", "SQL_INJECTION_RISK", "CALLS_VULNERABLE_FUNCTION"
    ));

    // Network send APIs - functions that send data over the network
    private static final Set<String> NETWORK_SEND_APIS = new HashSet<>(Arrays.asList(
            // POSIX
            "send", "sendto", "sendmsg", "write",
            // WinSock
            "WSASend", "WSASendTo", "WSASendMsg", "WSASendDisconnect",
            // SSL/TLS
            "SSL_write",
            // WinHTTP
            "WinHttpWriteData", "WinHttpSendRequest",
            // WinINet
            "InternetWriteFile", "HttpSendRequest", "HttpSendRequestA", "HttpSendRequestW",
            "HttpSendRequestEx", "HttpSendRequestExA", "HttpSendRequestExW",
            // libcurl
            "curl_easy_send"
    ));

    // Network recv APIs - functions that receive data from the network
    private static final Set<String> NETWORK_RECV_APIS = new HashSet<>(Arrays.asList(
            // POSIX
            "recv", "recvfrom", "recvmsg", "read",
            // WinSock
            "WSARecv", "WSARecvFrom", "WSARecvMsg", "WSARecvDisconnect",
            // SSL/TLS
            "SSL_read",
            // WinHTTP
            "WinHttpReadData", "WinHttpReceiveResponse",
            // WinINet
            "InternetReadFile", "InternetReadFileEx", "HttpQueryInfo", "HttpQueryInfoA", "HttpQueryInfoW",
            // libcurl
            "curl_easy_recv"
    ));

    private final BinaryKnowledgeGraph graph;

    // Cancellation support
    private volatile boolean cancelRequested = false;

    // Progress callback for reporting analysis progress
    private volatile ProgressCallback progressCallback;

    /**
     * Callback interface for reporting analysis progress.
     */
    @FunctionalInterface
    public interface ProgressCallback {
        /**
         * Called to report progress.
         * @param current Current item being processed
         * @param total Total items to process
         * @param message Description of current phase
         */
        void onProgress(int current, int total, String message);
    }

    public TaintAnalyzer(BinaryKnowledgeGraph graph) {
        this.graph = graph;
    }

    /**
     * Set the progress callback for reporting analysis progress.
     */
    public void setProgressCallback(ProgressCallback callback) {
        this.progressCallback = callback;
    }

    /**
     * Report progress if a callback is set.
     */
    private void reportProgress(int current, int total, String message) {
        ProgressCallback callback = progressCallback;
        if (callback != null) {
            callback.onProgress(current, total, message);
        }
    }

    /**
     * Request cancellation of ongoing analysis.
     * Analysis methods will check this flag and exit early.
     */
    public void requestCancel() {
        this.cancelRequested = true;
    }

    /**
     * Check if cancellation has been requested.
     */
    public boolean isCancelRequested() {
        return cancelRequested;
    }

    /**
     * Reset cancellation flag (call before starting new analysis).
     */
    public void resetCancel() {
        this.cancelRequested = false;
    }

    /**
     * Find all taint paths in the binary.
     *
     * @param maxPaths Maximum number of paths to return
     * @param createEdges If true, create TAINT_FLOWS_TO edges along found paths
     * @return List of taint paths from sources to sinks
     */
    public List<TaintPath> findTaintPaths(int maxPaths, boolean createEdges) {
        Msg.info(this, "Starting taint path analysis...");

        List<TaintPath> allPaths = new ArrayList<>();

        // Find source nodes (functions that call taint sources or have source flags)
        List<KnowledgeNode> sourceNodes = findSourceNodes();
        Msg.info(this, String.format("Found %d potential taint source nodes", sourceNodes.size()));

        // Find sink nodes (functions that call taint sinks or have sink flags)
        List<KnowledgeNode> sinkNodes = findSinkNodes();
        Msg.info(this, String.format("Found %d potential taint sink nodes", sinkNodes.size()));

        if (sourceNodes.isEmpty() || sinkNodes.isEmpty()) {
            Msg.info(this, "No sources or sinks found - no taint paths possible");
            return allPaths;
        }

        // Use BFS for fast shortest path finding (linear time vs exponential for AllDirectedPaths)
        Graph<String, LabeledEdge> memGraph = graph.getMemoryGraph();
        BFSShortestPath<String, LabeledEdge> bfs = new BFSShortestPath<>(memGraph);

        for (KnowledgeNode source : sourceNodes) {
            if (allPaths.size() >= maxPaths) break;

            for (KnowledgeNode sink : sinkNodes) {
                if (allPaths.size() >= maxPaths) break;
                if (source.getId().equals(sink.getId())) continue;

                // Check if both vertices exist in memory graph
                if (!memGraph.containsVertex(source.getId()) ||
                    !memGraph.containsVertex(sink.getId())) {
                    continue;
                }

                try {
                    // Find shortest path only (BFS is O(V+E) vs O(k^n) for all paths)
                    GraphPath<String, LabeledEdge> path = bfs.getPath(source.getId(), sink.getId());

                    if (path != null && path.getLength() <= MAX_PATH_LENGTH) {
                        TaintPath taintPath = buildTaintPath(source, sink, path);
                        allPaths.add(taintPath);

                        // Optionally create TAINT_FLOWS_TO edges
                        if (createEdges) {
                            createTaintEdges(path);
                        }
                    }
                } catch (Exception e) {
                    // Path finding can throw on disconnected graphs
                    Msg.debug(this, "No path from " + source.getName() + " to " + sink.getName());
                }
            }
        }

        Msg.info(this, String.format("Found %d taint paths", allPaths.size()));
        return allPaths;
    }

    /**
     * Find taint paths from a specific source function.
     */
    public List<TaintPath> findTaintPathsFrom(long sourceAddress, int maxPaths, boolean createEdges) {
        KnowledgeNode sourceNode = graph.getNodeByAddress(sourceAddress);
        if (sourceNode == null) {
            return List.of();
        }

        List<TaintPath> allPaths = new ArrayList<>();
        List<KnowledgeNode> sinkNodes = findSinkNodes();
        Graph<String, LabeledEdge> memGraph = graph.getMemoryGraph();
        BFSShortestPath<String, LabeledEdge> bfs = new BFSShortestPath<>(memGraph);

        for (KnowledgeNode sink : sinkNodes) {
            if (allPaths.size() >= maxPaths) break;
            if (sourceNode.getId().equals(sink.getId())) continue;

            if (!memGraph.containsVertex(sourceNode.getId()) ||
                !memGraph.containsVertex(sink.getId())) {
                continue;
            }

            try {
                GraphPath<String, LabeledEdge> path = bfs.getPath(sourceNode.getId(), sink.getId());

                if (path != null && path.getLength() <= MAX_PATH_LENGTH) {
                    TaintPath taintPath = buildTaintPath(sourceNode, sink, path);
                    allPaths.add(taintPath);

                    if (createEdges) {
                        createTaintEdges(path);
                    }
                }
            } catch (Exception e) {
                // Ignore path-finding failures
            }
        }

        return allPaths;
    }

    /**
     * Find taint paths to a specific sink function.
     */
    public List<TaintPath> findTaintPathsTo(long sinkAddress, int maxPaths, boolean createEdges) {
        KnowledgeNode sinkNode = graph.getNodeByAddress(sinkAddress);
        if (sinkNode == null) {
            return List.of();
        }

        List<TaintPath> allPaths = new ArrayList<>();
        List<KnowledgeNode> sourceNodes = findSourceNodes();
        Graph<String, LabeledEdge> memGraph = graph.getMemoryGraph();
        BFSShortestPath<String, LabeledEdge> bfs = new BFSShortestPath<>(memGraph);

        for (KnowledgeNode source : sourceNodes) {
            if (allPaths.size() >= maxPaths) break;
            if (source.getId().equals(sinkNode.getId())) continue;

            if (!memGraph.containsVertex(source.getId()) ||
                !memGraph.containsVertex(sinkNode.getId())) {
                continue;
            }

            try {
                GraphPath<String, LabeledEdge> path = bfs.getPath(source.getId(), sinkNode.getId());

                if (path != null && path.getLength() <= MAX_PATH_LENGTH) {
                    TaintPath taintPath = buildTaintPath(source, sinkNode, path);
                    allPaths.add(taintPath);

                    if (createEdges) {
                        createTaintEdges(path);
                    }
                }
            } catch (Exception e) {
                // Ignore path-finding failures
            }
        }

        return allPaths;
    }

    /**
     * Find nodes that are potential taint sources.
     * A node is a source if:
     * - It calls a known taint source function, OR
     * - It has source-related security flags
     */
    private List<KnowledgeNode> findSourceNodes() {
        List<KnowledgeNode> sources = new ArrayList<>();

        for (KnowledgeNode node : graph.getNodesByType(NodeType.FUNCTION)) {
            // Check security flags
            List<String> flags = node.getSecurityFlags();
            if (flags != null) {
                for (String flag : flags) {
                    if (SOURCE_FLAGS.contains(flag)) {
                        sources.add(node);
                        break;
                    }
                }
            }

            // Check if function name is a known source
            String name = node.getName();
            if (name != null && TAINT_SOURCES.contains(name)) {
                if (!sources.contains(node)) {
                    sources.add(node);
                }
            }

            // Check callees for taint source functions
            if (!sources.contains(node)) {
                for (KnowledgeNode callee : graph.getCallees(node.getId())) {
                    if (callee.getName() != null && TAINT_SOURCES.contains(callee.getName())) {
                        sources.add(node);
                        break;
                    }
                }
            }
        }

        return sources;
    }

    /**
     * Find nodes that are potential taint sinks.
     */
    private List<KnowledgeNode> findSinkNodes() {
        List<KnowledgeNode> sinks = new ArrayList<>();

        for (KnowledgeNode node : graph.getNodesByType(NodeType.FUNCTION)) {
            // Check security flags
            List<String> flags = node.getSecurityFlags();
            if (flags != null) {
                for (String flag : flags) {
                    if (SINK_FLAGS.contains(flag)) {
                        sinks.add(node);
                        break;
                    }
                }
            }

            // Check if function name is a known sink
            String name = node.getName();
            if (name != null && TAINT_SINKS.contains(name)) {
                if (!sinks.contains(node)) {
                    sinks.add(node);
                }
            }

            // Check callees for taint sink functions
            if (!sinks.contains(node)) {
                for (KnowledgeNode callee : graph.getCallees(node.getId())) {
                    if (callee.getName() != null && TAINT_SINKS.contains(callee.getName())) {
                        sinks.add(node);
                        break;
                    }
                }
            }
        }

        return sinks;
    }

    /**
     * Build a TaintPath object from a JGraphT path.
     */
    private TaintPath buildTaintPath(KnowledgeNode source, KnowledgeNode sink,
                                      GraphPath<String, LabeledEdge> graphPath) {
        List<String> pathNodeIds = graphPath.getVertexList();
        List<TaintPath.PathNode> pathNodes = new ArrayList<>();

        for (String nodeId : pathNodeIds) {
            KnowledgeNode node = graph.getNode(nodeId);
            if (node != null) {
                String funcName = node.getName() != null ? node.getName() :
                        String.format("sub_%x", node.getAddress());
                pathNodes.add(new TaintPath.PathNode(
                        nodeId, funcName, node.getAddress(), node.getSecurityFlags()));
            }
        }

        // Determine severity based on sink type
        String severity = determineSeverity(sink);

        return new TaintPath(
                source.getName() != null ? source.getName() : String.format("sub_%x", source.getAddress()),
                source.getAddress(),
                sink.getName() != null ? sink.getName() : String.format("sub_%x", sink.getAddress()),
                sink.getAddress(),
                pathNodes,
                severity,
                graphPath.getLength()
        );
    }

    /**
     * Determine severity based on sink's security flags.
     */
    private String determineSeverity(KnowledgeNode sink) {
        List<String> flags = sink.getSecurityFlags();
        if (flags == null || flags.isEmpty()) {
            return "MEDIUM";
        }

        // Critical sinks
        if (flags.contains("COMMAND_INJECTION_RISK") ||
            flags.contains("VULN_COMMAND_INJECTION") ||
            flags.contains("SQL_INJECTION_RISK")) {
            return "CRITICAL";
        }

        // High severity sinks
        if (flags.contains("BUFFER_OVERFLOW_RISK") ||
            flags.contains("VULN_BUFFER_OVERFLOW") ||
            flags.contains("FORMAT_STRING_RISK")) {
            return "HIGH";
        }

        // Medium severity
        if (flags.contains("PATH_TRAVERSAL_RISK") ||
            flags.contains("CALLS_VULNERABLE_FUNCTION")) {
            return "MEDIUM";
        }

        return "LOW";
    }

    /**
     * Create TAINT_FLOWS_TO edges along a path.
     */
    private void createTaintEdges(GraphPath<String, LabeledEdge> path) {
        List<String> vertices = path.getVertexList();

        for (int i = 0; i < vertices.size() - 1; i++) {
            String from = vertices.get(i);
            String to = vertices.get(i + 1);

            // Check if edge already exists
            if (!graph.hasEdgeBetween(from, to, EdgeType.TAINT_FLOWS_TO)) {
                graph.addEdge(from, to, EdgeType.TAINT_FLOWS_TO);
            }
        }
    }

    /**
     * Create VULNERABLE_VIA edges from entry points to vulnerable sinks.
     * Entry points are functions that are:
     * - Exported
     * - Named "main", "WinMain", "DllMain", etc.
     * - Have the ENTRY_POINT security flag
     *
     * Vulnerable sinks are functions with *_RISK or VULN_* security flags.
     *
     * @return Number of VULNERABLE_VIA edges created
     */
    public int createVulnerableViaEdges() {
        Msg.info(this, "Creating VULNERABLE_VIA edges from entry points to vulnerable sinks...");

        int edgesCreated = 0;

        // Find entry points
        List<KnowledgeNode> entryPoints = findEntryPoints();
        Msg.info(this, String.format("Found %d entry points", entryPoints.size()));

        // Find vulnerable nodes (nodes with vulnerability flags)
        List<KnowledgeNode> vulnerableNodes = findVulnerableNodes();
        Msg.info(this, String.format("Found %d vulnerable nodes", vulnerableNodes.size()));

        if (entryPoints.isEmpty() || vulnerableNodes.isEmpty()) {
            Msg.info(this, "No entry points or vulnerable nodes found - no VULNERABLE_VIA edges to create");
            return 0;
        }

        // Use JGraphT to check path existence - BFS is O(V+E) per query vs exponential for AllDirectedPaths
        Graph<String, LabeledEdge> memGraph = graph.getMemoryGraph();
        BFSShortestPath<String, LabeledEdge> bfs = new BFSShortestPath<>(memGraph);

        for (KnowledgeNode entry : entryPoints) {
            for (KnowledgeNode vulnerable : vulnerableNodes) {
                if (entry.getId().equals(vulnerable.getId())) {
                    continue; // Skip self
                }

                // Check if both vertices exist in memory graph
                if (!memGraph.containsVertex(entry.getId()) ||
                    !memGraph.containsVertex(vulnerable.getId())) {
                    continue;
                }

                // Check if there's a path from entry to vulnerable
                try {
                    GraphPath<String, LabeledEdge> path = bfs.getPath(entry.getId(), vulnerable.getId());

                    if (path != null && path.getLength() <= MAX_PATH_LENGTH) {
                        // Path exists - create VULNERABLE_VIA edge
                        if (!graph.hasEdgeBetween(entry.getId(), vulnerable.getId(), EdgeType.VULNERABLE_VIA)) {
                            // Get the vulnerability type from the vulnerable node's flags
                            String vulnType = getVulnerabilityType(vulnerable);
                            String metadata = String.format("{\"path_length\":%d,\"vuln_type\":\"%s\"}",
                                    path.getLength(), vulnType);

                            graph.addEdge(entry.getId(), vulnerable.getId(),
                                    EdgeType.VULNERABLE_VIA, 1.0, metadata);
                            edgesCreated++;
                        }
                    }
                } catch (Exception e) {
                    // Path finding can throw on disconnected graphs - ignore
                    Msg.debug(this, "No path from " + entry.getName() + " to " + vulnerable.getName());
                }
            }
        }

        Msg.info(this, String.format("Created %d VULNERABLE_VIA edges", edgesCreated));
        return edgesCreated;
    }

    /**
     * Find entry point nodes (exported functions, main, etc.)
     */
    private List<KnowledgeNode> findEntryPoints() {
        List<KnowledgeNode> entryPoints = new ArrayList<>();

        // Common entry point names
        Set<String> entryPointNames = new HashSet<>(Arrays.asList(
                "main", "_main", "wmain", "_wmain",
                "WinMain", "wWinMain", "_WinMain@16", "_wWinMain@16",
                "DllMain", "_DllMain@12", "DllEntryPoint",
                "start", "_start", "entry", "_entry",
                "mainCRTStartup", "wmainCRTStartup",
                "WinMainCRTStartup", "wWinMainCRTStartup"
        ));

        for (KnowledgeNode node : graph.getNodesByType(NodeType.FUNCTION)) {
            boolean isEntryPoint = false;

            // Check security flags for ENTRY_POINT
            List<String> flags = node.getSecurityFlags();
            if (flags != null && flags.contains("ENTRY_POINT")) {
                isEntryPoint = true;
            }

            // Check for known entry point names
            String name = node.getName();
            if (name != null && entryPointNames.contains(name)) {
                isEntryPoint = true;
            }

            // Check if function is exported (has EXPORTED flag or is in symbol table as exported)
            if (flags != null && flags.contains("EXPORTED")) {
                isEntryPoint = true;
            }

            if (isEntryPoint && !entryPoints.contains(node)) {
                entryPoints.add(node);
            }
        }

        return entryPoints;
    }

    /**
     * Find nodes with vulnerability flags (*_RISK, VULN_*, etc.)
     */
    private List<KnowledgeNode> findVulnerableNodes() {
        List<KnowledgeNode> vulnerableNodes = new ArrayList<>();

        for (KnowledgeNode node : graph.getNodesByType(NodeType.FUNCTION)) {
            List<String> flags = node.getSecurityFlags();
            if (flags == null || flags.isEmpty()) {
                continue;
            }

            // Check for vulnerability-indicating flags
            for (String flag : flags) {
                if (flag.endsWith("_RISK") || flag.startsWith("VULN_")) {
                    if (!vulnerableNodes.contains(node)) {
                        vulnerableNodes.add(node);
                    }
                    break;
                }
            }
        }

        return vulnerableNodes;
    }

    /**
     * Extract the primary vulnerability type from a node's security flags.
     */
    private String getVulnerabilityType(KnowledgeNode node) {
        List<String> flags = node.getSecurityFlags();
        if (flags == null || flags.isEmpty()) {
            return "UNKNOWN";
        }

        // Prefer VULN_* flags, then *_RISK flags
        for (String flag : flags) {
            if (flag.startsWith("VULN_")) {
                return flag.substring(5); // Remove "VULN_" prefix
            }
        }
        for (String flag : flags) {
            if (flag.endsWith("_RISK")) {
                return flag.replace("_RISK", "");
            }
        }

        return "UNKNOWN";
    }

    /**
     * Get statistics about taint sources and sinks.
     */
    public Map<String, Object> getTaintStats() {
        Map<String, Object> stats = new HashMap<>();

        List<KnowledgeNode> sources = findSourceNodes();
        List<KnowledgeNode> sinks = findSinkNodes();

        stats.put("source_count", sources.size());
        stats.put("sink_count", sinks.size());

        // List source names
        List<String> sourceNames = sources.stream()
                .map(n -> n.getName() != null ? n.getName() : String.format("sub_%x", n.getAddress()))
                .limit(10)
                .collect(Collectors.toList());
        stats.put("sample_sources", sourceNames);

        // List sink names
        List<String> sinkNames = sinks.stream()
                .map(n -> n.getName() != null ? n.getName() : String.format("sub_%x", n.getAddress()))
                .limit(10)
                .collect(Collectors.toList());
        stats.put("sample_sinks", sinkNames);

        return stats;
    }

    /**
     * Represents a taint path from source to sink.
     */
    public static class TaintPath {
        private final String sourceName;
        private final long sourceAddress;
        private final String sinkName;
        private final long sinkAddress;
        private final List<PathNode> path;
        private final String severity;
        private final int pathLength;

        public TaintPath(String sourceName, long sourceAddress,
                         String sinkName, long sinkAddress,
                         List<PathNode> path, String severity, int pathLength) {
            this.sourceName = sourceName;
            this.sourceAddress = sourceAddress;
            this.sinkName = sinkName;
            this.sinkAddress = sinkAddress;
            this.path = path;
            this.severity = severity;
            this.pathLength = pathLength;
        }

        public String getSourceName() { return sourceName; }
        public long getSourceAddress() { return sourceAddress; }
        public String getSinkName() { return sinkName; }
        public long getSinkAddress() { return sinkAddress; }
        public List<PathNode> getPath() { return path; }
        public String getSeverity() { return severity; }
        public int getPathLength() { return pathLength; }

        /**
         * Format as tool output.
         */
        public String toToolOutput() {
            StringBuilder sb = new StringBuilder();
            sb.append("{\n");
            sb.append("  \"source\": \"").append(sourceName).append("\",\n");
            sb.append("  \"source_address\": \"0x").append(Long.toHexString(sourceAddress)).append("\",\n");
            sb.append("  \"sink\": \"").append(sinkName).append("\",\n");
            sb.append("  \"sink_address\": \"0x").append(Long.toHexString(sinkAddress)).append("\",\n");
            sb.append("  \"severity\": \"").append(severity).append("\",\n");
            sb.append("  \"path_length\": ").append(pathLength).append(",\n");
            sb.append("  \"path\": [\n");

            for (int i = 0; i < path.size(); i++) {
                PathNode node = path.get(i);
                sb.append("    {\"name\": \"").append(node.name)
                  .append("\", \"address\": \"0x").append(Long.toHexString(node.address)).append("\"}");
                if (i < path.size() - 1) sb.append(",");
                sb.append("\n");
            }

            sb.append("  ]\n");
            sb.append("}");
            return sb.toString();
        }

        /**
         * A node in the taint path.
         */
        public static class PathNode {
            private final String id;
            private final String name;
            private final long address;
            private final List<String> flags;

            public PathNode(String id, String name, long address, List<String> flags) {
                this.id = id;
                this.name = name;
                this.address = address;
                this.flags = flags != null ? flags : List.of();
            }

            public String getId() { return id; }
            public String getName() { return name; }
            public long getAddress() { return address; }
            public List<String> getFlags() { return flags; }
        }
    }

    // ========================================
    // Network Flow Analysis
    // ========================================

    /**
     * Analyze network data flow and create NETWORK_SEND and NETWORK_RECV edges.
     *
     * @return NetworkFlowResult with statistics about edges created
     */
    public NetworkFlowResult analyzeNetworkFlow() {
        Msg.info(this, "Starting network flow analysis...");
        resetCancel();  // Reset cancellation flag at start

        // Debug: Log memory graph statistics
        Graph<String, LabeledEdge> memGraph = graph.getMemoryGraph();
        int totalVertices = memGraph.vertexSet().size();
        int totalEdges = memGraph.edgeSet().size();
        long callEdges = memGraph.edgeSet().stream().filter(e -> e.getType() == EdgeType.CALLS).count();
        Msg.debug(this, String.format("Memory graph stats: %d vertices, %d edges (%d CALLS edges)",
                totalVertices, totalEdges, callEdges));

        reportProgress(0, 100, "Finding network send functions...");

        // Find network send/recv nodes
        List<KnowledgeNode> sendNodes = findNetworkSendNodes();
        if (cancelRequested) {
            Msg.info(this, "Network flow analysis cancelled during send node discovery");
            return new NetworkFlowResult(0, 0, 0, 0, Collections.emptyList(), Collections.emptyList());
        }

        reportProgress(2, 100, "Finding network recv functions...");

        List<KnowledgeNode> recvNodes = findNetworkRecvNodes();
        if (cancelRequested) {
            Msg.info(this, "Network flow analysis cancelled during recv node discovery");
            return new NetworkFlowResult(0, 0, 0, 0, Collections.emptyList(), Collections.emptyList());
        }

        Msg.info(this, String.format("Found %d functions that send network data", sendNodes.size()));
        Msg.info(this, String.format("Found %d functions that receive network data", recvNodes.size()));

        reportProgress(5, 100, String.format("Found %d send, %d recv functions. Creating send edges...",
                sendNodes.size(), recvNodes.size()));

        // Create edges (these methods check cancelRequested internally and report progress)
        // Returns int[]{created, existing}
        int[] sendResult = createNetworkSendEdges(sendNodes);
        int sendEdgesCreated = sendResult[0];
        int sendEdgesExisting = sendResult[1];

        if (cancelRequested) {
            Msg.info(this, "Network flow analysis cancelled during send edge creation");
            return new NetworkFlowResult(sendEdgesCreated, 0, sendEdgesExisting, 0,
                    sendNodes.stream().map(n -> n.getName() != null ? n.getName() : String.format("sub_%x", n.getAddress())).collect(Collectors.toList()),
                    Collections.emptyList());
        }

        int[] recvResult = createNetworkRecvEdges(recvNodes);
        int recvEdgesCreated = recvResult[0];
        int recvEdgesExisting = recvResult[1];

        // Collect function names for the result
        List<String> sendFunctionNames = sendNodes.stream()
                .map(n -> n.getName() != null ? n.getName() : String.format("sub_%x", n.getAddress()))
                .collect(Collectors.toList());

        List<String> recvFunctionNames = recvNodes.stream()
                .map(n -> n.getName() != null ? n.getName() : String.format("sub_%x", n.getAddress()))
                .collect(Collectors.toList());

        int totalSendEdges = sendEdgesCreated + sendEdgesExisting;
        int totalRecvEdges = recvEdgesCreated + recvEdgesExisting;

        if (cancelRequested) {
            Msg.info(this, "Network flow analysis cancelled");
        } else {
            reportProgress(100, 100, String.format("Complete: %d send edges (%d new), %d recv edges (%d new)",
                    totalSendEdges, sendEdgesCreated, totalRecvEdges, recvEdgesCreated));
            Msg.info(this, String.format("Network flow analysis complete: %d send edges (%d new, %d existing), %d recv edges (%d new, %d existing)",
                    totalSendEdges, sendEdgesCreated, sendEdgesExisting,
                    totalRecvEdges, recvEdgesCreated, recvEdgesExisting));
        }

        return new NetworkFlowResult(sendEdgesCreated, recvEdgesCreated, sendEdgesExisting, recvEdgesExisting,
                sendFunctionNames, recvFunctionNames);
    }

    /**
     * Find functions that call network send APIs.
     * Uses Set for O(1) deduplication.
     */
    public List<KnowledgeNode> findNetworkSendNodes() {
        Set<String> seenIds = new HashSet<>();
        List<KnowledgeNode> sendNodes = new ArrayList<>();

        for (KnowledgeNode node : graph.getNodesByType(NodeType.FUNCTION)) {
            // Check if function name is a known send API (for external function nodes)
            String name = node.getName();
            if (name != null && isNetworkSendAPI(name)) {
                if (seenIds.add(node.getId())) {
                    sendNodes.add(node);
                }
                continue;
            }

            // Check callees for network send functions
            for (KnowledgeNode callee : graph.getCallees(node.getId())) {
                if (callee.getName() != null && isNetworkSendAPI(callee.getName())) {
                    if (seenIds.add(node.getId())) {
                        sendNodes.add(node);
                    }
                    break;
                }
            }
        }

        return sendNodes;
    }

    /**
     * Find functions that call network recv APIs.
     * Uses Set for O(1) deduplication.
     */
    public List<KnowledgeNode> findNetworkRecvNodes() {
        Set<String> seenIds = new HashSet<>();
        List<KnowledgeNode> recvNodes = new ArrayList<>();
        int foundByName = 0;
        int foundByCallee = 0;
        int totalFunctions = 0;

        List<KnowledgeNode> allFunctions = graph.getNodesByType(NodeType.FUNCTION);
        Msg.info(this, String.format("Scanning %d function nodes for recv APIs...", allFunctions.size()));

        for (KnowledgeNode node : allFunctions) {
            totalFunctions++;
            String name = node.getName();

            // Check if function name is a known recv API (for external function nodes)
            if (name != null && isNetworkRecvAPI(name)) {
                if (seenIds.add(node.getId())) {
                    recvNodes.add(node);
                    foundByName++;
                    Msg.info(this, String.format("Found recv API by name: '%s' (normalized: '%s', id=%s)",
                            name, normalizeFunctionName(name), node.getId()));
                }
                continue;
            }

            // Check callees for network recv functions
            List<KnowledgeNode> callees = graph.getCallees(node.getId());
            for (KnowledgeNode callee : callees) {
                String calleeName = callee.getName();
                if (calleeName != null && isNetworkRecvAPI(calleeName)) {
                    if (seenIds.add(node.getId())) {
                        recvNodes.add(node);
                        foundByCallee++;
                        Msg.info(this, String.format("Found function calling recv API: '%s' calls '%s' (normalized: '%s')",
                                name != null ? name : "sub_" + Long.toHexString(node.getAddress()),
                                calleeName, normalizeFunctionName(calleeName)));
                    }
                    break;
                }
            }
        }

        Msg.info(this, String.format("Recv nodes breakdown: %d by API name, %d by callee match (scanned %d functions)",
                foundByName, foundByCallee, totalFunctions));
        return recvNodes;
    }

    /**
     * Check if a function name is a network send API.
     */
    private boolean isNetworkSendAPI(String name) {
        if (name == null) return false;
        // Normalize name (remove __imp_, leading _, trailing @N)
        String normalized = normalizeFunctionName(name);
        return NETWORK_SEND_APIS.contains(name) || NETWORK_SEND_APIS.contains(normalized);
    }

    /**
     * Check if a function name is a network recv API.
     */
    private boolean isNetworkRecvAPI(String name) {
        if (name == null) return false;
        // Normalize name (remove __imp_, leading _, trailing @N)
        String normalized = normalizeFunctionName(name);
        return NETWORK_RECV_APIS.contains(name) || NETWORK_RECV_APIS.contains(normalized);
    }

    /**
     * Normalize a function name by removing common decorations.
     */
    private String normalizeFunctionName(String name) {
        if (name == null) return null;

        String normalized = name;

        // Remove library prefix (e.g., "WS2_32.dll::" or "KERNEL32.DLL_")
        int colonIdx = normalized.indexOf("::");
        if (colonIdx > 0) {
            normalized = normalized.substring(colonIdx + 2);
        }
        // Also handle underscore-separated library prefix (e.g., "WS2_32.DLL_WSARecvFrom")
        if (normalized.contains(".DLL_") || normalized.contains(".dll_")) {
            int dllIdx = normalized.toLowerCase().indexOf(".dll_");
            if (dllIdx > 0) {
                normalized = normalized.substring(dllIdx + 5);
            }
        }

        // Remove <EXTERNAL>:: prefix
        if (normalized.startsWith("<EXTERNAL>::")) {
            normalized = normalized.substring(12);
        }

        // Remove __imp_ prefix (import thunk)
        if (normalized.startsWith("__imp_")) {
            normalized = normalized.substring(6);
        }

        // Remove leading underscores (one or two)
        while (normalized.startsWith("_") && normalized.length() > 1) {
            normalized = normalized.substring(1);
        }

        // Remove trailing @N (stdcall decoration)
        int atIndex = normalized.lastIndexOf('@');
        if (atIndex > 0) {
            String suffix = normalized.substring(atIndex + 1);
            if (suffix.matches("\\d+")) {
                normalized = normalized.substring(0, atIndex);
            }
        }

        return normalized;
    }

    /**
     * Create NETWORK_SEND edges from entry points to send functions.
     * Also creates edges from direct callers.
     * @return int array: [0] = edges created, [1] = edges already existing
     */
    private int[] createNetworkSendEdges(List<KnowledgeNode> sendNodes) {
        if (sendNodes.isEmpty()) {
            return new int[]{0, 0};
        }

        // Find entry points
        List<KnowledgeNode> entryPoints = findEntryPoints();
        Graph<String, LabeledEdge> memGraph = graph.getMemoryGraph();

        final int totalEntryPoints = entryPoints.size();
        final int totalSendNodes = sendNodes.size();
        Msg.info(this, String.format("Processing %d entry points × %d send nodes...",
                totalEntryPoints, totalSendNodes));

        // Debug: Log entry points and send nodes
        for (KnowledgeNode entry : entryPoints) {
            String name = entry.getName() != null ? entry.getName() : "sub_" + Long.toHexString(entry.getAddress());
            boolean inGraph = memGraph.containsVertex(entry.getId());
            int outEdges = inGraph ? memGraph.outgoingEdgesOf(entry.getId()).size() : 0;
            Msg.debug(this, String.format("Entry point '%s': inMemGraph=%b, outgoingEdges=%d",
                    name, inGraph, outEdges));
        }
        for (KnowledgeNode send : sendNodes) {
            String name = send.getName() != null ? send.getName() : "sub_" + Long.toHexString(send.getAddress());
            boolean inGraph = memGraph.containsVertex(send.getId());
            int inEdges = inGraph ? memGraph.incomingEdgesOf(send.getId()).size() : 0;
            Msg.debug(this, String.format("Send node '%s': inMemGraph=%b, incomingEdges=%d",
                    name, inGraph, inEdges));
        }

        // Use atomic counters for thread-safe counting
        java.util.concurrent.atomic.AtomicInteger edgesCreated = new java.util.concurrent.atomic.AtomicInteger(0);
        java.util.concurrent.atomic.AtomicInteger edgesExisting = new java.util.concurrent.atomic.AtomicInteger(0);
        java.util.concurrent.atomic.AtomicInteger entryPointsProcessed = new java.util.concurrent.atomic.AtomicInteger(0);

        // Progress reporting: send edges phase is 5-80% of total (75% range)
        final int PROGRESS_START = 5;
        final int PROGRESS_END = 80;

        // Process entry→send pairs sequentially for debugging
        org.jgrapht.alg.shortestpath.BFSShortestPath<String, LabeledEdge> bfs =
                new org.jgrapht.alg.shortestpath.BFSShortestPath<>(memGraph);

        for (KnowledgeNode entry : entryPoints) {
            if (cancelRequested) {
                break;
            }

            String entryName = entry.getName() != null ? entry.getName() : "sub_" + Long.toHexString(entry.getAddress());

            for (KnowledgeNode sendNode : sendNodes) {
                if (cancelRequested) {
                    break;
                }

                String sendName = sendNode.getName() != null ? sendNode.getName() : "sub_" + Long.toHexString(sendNode.getAddress());

                if (entry.getId().equals(sendNode.getId())) {
                    continue;
                }

                if (!memGraph.containsVertex(entry.getId()) ||
                    !memGraph.containsVertex(sendNode.getId())) {
                    Msg.debug(this, String.format("Skipping %s -> %s: vertex not in graph", entryName, sendName));
                    continue;
                }

                // Skip if edge already exists
                if (graph.hasEdgeBetween(entry.getId(), sendNode.getId(), EdgeType.NETWORK_SEND)) {
                    Msg.debug(this, String.format("SEND edge already exists: %s -> %s", entryName, sendName));
                    edgesExisting.incrementAndGet();
                    continue;
                }

                try {
                    // BFS finds shortest path only - much faster than AllDirectedPaths
                    GraphPath<String, LabeledEdge> path = bfs.getPath(entry.getId(), sendNode.getId());

                    if (path != null) {
                        if (path.getLength() <= MAX_PATH_LENGTH) {
                            String sendAPI = getSendAPIName(sendNode);
                            String metadata = String.format(
                                    "{\"path_length\":%d,\"send_api\":\"%s\",\"entry_point\":\"%s\"}",
                                    path.getLength(), sendAPI, entry.getName());

                            graph.addEdge(entry.getId(), sendNode.getId(),
                                    EdgeType.NETWORK_SEND, 1.0, metadata);
                            edgesCreated.incrementAndGet();
                            Msg.info(this, String.format("Created SEND edge: %s -> %s (path length %d)",
                                    entryName, sendName, path.getLength()));
                        } else {
                            Msg.debug(this, String.format("Path too long %s -> %s: %d > %d",
                                    entryName, sendName, path.getLength(), MAX_PATH_LENGTH));
                        }
                    } else {
                        Msg.debug(this, String.format("No path found: %s -> %s", entryName, sendName));
                    }
                } catch (Exception e) {
                    Msg.debug(this, String.format("Path finding error %s -> %s: %s", entryName, sendName, e.getMessage()));
                }
            }

            // Update progress after completing each entry point
            int completed = entryPointsProcessed.incrementAndGet();
            if (totalEntryPoints > 0) {
                int percent = PROGRESS_START + (completed * (PROGRESS_END - PROGRESS_START) / totalEntryPoints);
                reportProgress(completed, totalEntryPoints,
                        String.format("Send paths: %d/%d entry points (%d%%), %d edges",
                                completed, totalEntryPoints, percent, edgesCreated.get()));
            }
        }

        // Check cancellation before direct caller processing
        if (cancelRequested) {
            return new int[]{edgesCreated.get(), edgesExisting.get()};
        }

        // Also add direct caller edges for completeness (sequential - usually small)
        for (KnowledgeNode sendNode : sendNodes) {
            if (cancelRequested) {
                break;
            }
            for (KnowledgeNode caller : graph.getCallers(sendNode.getId())) {
                if (!graph.hasEdgeBetween(caller.getId(), sendNode.getId(), EdgeType.NETWORK_SEND)) {
                    String sendAPI = getSendAPIName(sendNode);
                    String metadata = String.format(
                            "{\"direct_caller\":true,\"send_api\":\"%s\"}", sendAPI);

                    graph.addEdge(caller.getId(), sendNode.getId(),
                            EdgeType.NETWORK_SEND, 0.5, metadata);
                    edgesCreated.incrementAndGet();
                } else {
                    edgesExisting.incrementAndGet();
                }
            }
        }

        return new int[]{edgesCreated.get(), edgesExisting.get()};
    }

    /**
     * Create NETWORK_RECV edges from recv functions to their callers.
     * Shows where received network data flows.
     * @return int array: [0] = edges created, [1] = edges already existing
     */
    private int[] createNetworkRecvEdges(List<KnowledgeNode> recvNodes) {
        if (recvNodes.isEmpty()) {
            return new int[]{0, 0};
        }

        final int totalRecvNodes = recvNodes.size();
        Msg.info(this, String.format("Processing %d recv nodes for caller tracing...", totalRecvNodes));

        // Debug: Check if recv nodes exist in memory graph and have callers
        Graph<String, LabeledEdge> memGraph = graph.getMemoryGraph();
        for (KnowledgeNode recvNode : recvNodes) {
            String recvName = recvNode.getName() != null ? recvNode.getName() : "sub_" + Long.toHexString(recvNode.getAddress());
            boolean inGraph = memGraph.containsVertex(recvNode.getId());
            int incomingEdgeCount = inGraph ? memGraph.incomingEdgesOf(recvNode.getId()).size() : 0;
            List<KnowledgeNode> callers = graph.getCallers(recvNode.getId());
            Msg.info(this, String.format("Recv node '%s' (id=%s): inMemGraph=%b, incomingEdges=%d, callers=%d",
                    recvName, recvNode.getId(), inGraph, incomingEdgeCount, callers.size()));

            // Log caller names for debugging
            if (callers.isEmpty() && incomingEdgeCount > 0) {
                Msg.warn(this, String.format("Recv node '%s' has %d incoming edges but getCallers() returned 0 - possible edge type mismatch",
                        recvName, incomingEdgeCount));
                // Log the actual edge types
                if (inGraph) {
                    for (LabeledEdge edge : memGraph.incomingEdgesOf(recvNode.getId())) {
                        String sourceId = memGraph.getEdgeSource(edge);
                        KnowledgeNode sourceNode = graph.getNode(sourceId);
                        String sourceName = sourceNode != null ? sourceNode.getName() : sourceId;
                        Msg.info(this, String.format("  Incoming edge: %s -[%s]-> %s",
                                sourceName, edge.getType(), recvName));
                    }
                }
            } else if (!callers.isEmpty()) {
                for (KnowledgeNode caller : callers) {
                    String callerName = caller.getName() != null ? caller.getName() : "sub_" + Long.toHexString(caller.getAddress());
                    Msg.info(this, String.format("  Caller of '%s': '%s'", recvName, callerName));
                }
            }
        }

        // Use atomic counters for thread-safe counting
        java.util.concurrent.atomic.AtomicInteger edgesCreated = new java.util.concurrent.atomic.AtomicInteger(0);
        java.util.concurrent.atomic.AtomicInteger edgesExisting = new java.util.concurrent.atomic.AtomicInteger(0);
        java.util.concurrent.atomic.AtomicInteger recvNodesProcessed = new java.util.concurrent.atomic.AtomicInteger(0);

        // Progress reporting: recv edges phase is 80-98% of total (18% range)
        final int PROGRESS_START = 80;
        final int PROGRESS_END = 98;

        // Process recv nodes
        for (KnowledgeNode recvNode : recvNodes) {
            // Check for cancellation at start of each recv node processing
            if (cancelRequested) {
                break;
            }

            String recvAPI = getRecvAPIName(recvNode);
            String recvNodeName = recvNode.getName() != null ? recvNode.getName() : "sub_" + Long.toHexString(recvNode.getAddress());

            // Get direct callers (1-hop)
            List<KnowledgeNode> callers = graph.getCallers(recvNode.getId());
            Msg.debug(this, String.format("Processing recv node '%s': found %d callers", recvNodeName, callers.size()));

            for (KnowledgeNode caller : callers) {
                // Check for cancellation periodically
                if (cancelRequested) {
                    break;
                }

                String callerName = caller.getName() != null ? caller.getName() : "sub_" + Long.toHexString(caller.getAddress());

                // Edge: recv -> caller (showing data flow direction)
                try {
                    boolean alreadyExists = graph.hasEdgeBetween(recvNode.getId(), caller.getId(), EdgeType.NETWORK_RECV);
                    if (!alreadyExists) {
                        String metadata = String.format(
                                "{\"recv_api\":\"%s\",\"hop\":1}", recvAPI);

                        graph.addEdge(recvNode.getId(), caller.getId(),
                                EdgeType.NETWORK_RECV, 1.0, metadata);
                        edgesCreated.incrementAndGet();
                        Msg.debug(this, String.format("Created NETWORK_RECV edge: %s -> %s", recvNodeName, callerName));
                    } else {
                        edgesExisting.incrementAndGet();
                        Msg.debug(this, String.format("Edge already exists: %s -> %s", recvNodeName, callerName));
                    }
                } catch (Exception e) {
                    Msg.error(this, String.format("Failed to create edge %s -> %s: %s", recvNodeName, callerName, e.getMessage()));
                }

                // Also trace 2-hop callers (for data propagation tracking)
                for (KnowledgeNode grandCaller : graph.getCallers(caller.getId())) {
                    try {
                        if (!graph.hasEdgeBetween(recvNode.getId(), grandCaller.getId(), EdgeType.NETWORK_RECV)) {
                            String metadata2 = String.format(
                                    "{\"recv_api\":\"%s\",\"hop\":2,\"via\":\"%s\"}",
                                    recvAPI, caller.getName());

                            graph.addEdge(recvNode.getId(), grandCaller.getId(),
                                    EdgeType.NETWORK_RECV, 0.5, metadata2);
                            edgesCreated.incrementAndGet();
                        } else {
                            edgesExisting.incrementAndGet();
                        }
                    } catch (Exception e) {
                        Msg.debug(this, "Failed to create 2-hop edge: " + e.getMessage());
                    }
                }
            }

            // Update progress after completing each recv node
            int completed = recvNodesProcessed.incrementAndGet();
            if (totalRecvNodes > 0) {
                int percent = PROGRESS_START + (completed * (PROGRESS_END - PROGRESS_START) / totalRecvNodes);
                reportProgress(completed, totalRecvNodes,
                        String.format("Recv paths: %d/%d recv nodes (%d%%), %d edges",
                                completed, totalRecvNodes, percent, edgesCreated.get()));
            }
        }

        return new int[]{edgesCreated.get(), edgesExisting.get()};
    }

    /**
     * Get the name of the send API called by a node.
     */
    private String getSendAPIName(KnowledgeNode node) {
        // If the node itself is a send API
        if (node.getName() != null && isNetworkSendAPI(node.getName())) {
            return normalizeFunctionName(node.getName());
        }

        // Check callees
        for (KnowledgeNode callee : graph.getCallees(node.getId())) {
            if (callee.getName() != null && isNetworkSendAPI(callee.getName())) {
                return normalizeFunctionName(callee.getName());
            }
        }

        return "unknown";
    }

    /**
     * Get the name of the recv API called by a node.
     */
    private String getRecvAPIName(KnowledgeNode node) {
        // If the node itself is a recv API
        if (node.getName() != null && isNetworkRecvAPI(node.getName())) {
            return normalizeFunctionName(node.getName());
        }

        // Check callees
        for (KnowledgeNode callee : graph.getCallees(node.getId())) {
            if (callee.getName() != null && isNetworkRecvAPI(callee.getName())) {
                return normalizeFunctionName(callee.getName());
            }
        }

        return "unknown";
    }

    /**
     * Result of network flow analysis.
     */
    public static class NetworkFlowResult {
        private final int sendPathEdgesCreated;
        private final int recvPathEdgesCreated;
        private final int sendPathEdgesExisting;
        private final int recvPathEdgesExisting;
        private final List<String> sendFunctions;
        private final List<String> recvFunctions;

        public NetworkFlowResult(int sendPathEdgesCreated, int recvPathEdgesCreated,
                                  int sendPathEdgesExisting, int recvPathEdgesExisting,
                                  List<String> sendFunctions, List<String> recvFunctions) {
            this.sendPathEdgesCreated = sendPathEdgesCreated;
            this.recvPathEdgesCreated = recvPathEdgesCreated;
            this.sendPathEdgesExisting = sendPathEdgesExisting;
            this.recvPathEdgesExisting = recvPathEdgesExisting;
            this.sendFunctions = sendFunctions;
            this.recvFunctions = recvFunctions;
        }

        public int getSendPathEdges() { return sendPathEdgesCreated + sendPathEdgesExisting; }
        public int getRecvPathEdges() { return recvPathEdgesCreated + recvPathEdgesExisting; }
        public int getSendPathEdgesCreated() { return sendPathEdgesCreated; }
        public int getRecvPathEdgesCreated() { return recvPathEdgesCreated; }
        public List<String> getSendFunctions() { return sendFunctions; }
        public List<String> getRecvFunctions() { return recvFunctions; }

        public String toSummary() {
            int totalSend = sendPathEdgesCreated + sendPathEdgesExisting;
            int totalRecv = recvPathEdgesCreated + recvPathEdgesExisting;
            return String.format(
                    "Network Flow Analysis Complete:\n" +
                    "- Found %d functions calling send APIs\n" +
                    "- NETWORK_SEND edges: %d total (%d new, %d existing)\n" +
                    "- Found %d functions calling recv APIs\n" +
                    "- NETWORK_RECV edges: %d total (%d new, %d existing)",
                    sendFunctions.size(), totalSend, sendPathEdgesCreated, sendPathEdgesExisting,
                    recvFunctions.size(), totalRecv, recvPathEdgesCreated, recvPathEdgesExisting);
        }
    }
}

```

`src/main/java/ghidrassist/graphrag/community/Community.java`:

```java
package ghidrassist.graphrag.community;

import java.util.UUID;

/**
 * Represents a community (cluster) of related functions in the knowledge graph.
 * Communities are detected using graph clustering algorithms and stored as MODULE nodes.
 */
public class Community {
    private String id;
    private int level;              // 0=functions, 1=modules, 2=subsystems, etc.
    private String binaryId;
    private String parentCommunityId;  // For hierarchical communities
    private String name;
    private String summary;         // LLM-generated community summary
    private int memberCount;
    private boolean isStale;        // Needs re-summarization
    private long createdAt;
    private long updatedAt;

    /**
     * Create a new community with generated ID.
     */
    public Community(String binaryId, int level) {
        this.id = UUID.randomUUID().toString();
        this.binaryId = binaryId;
        this.level = level;
        this.isStale = true;
        this.memberCount = 0;
        this.createdAt = System.currentTimeMillis();
        this.updatedAt = this.createdAt;
    }

    /**
     * Create a community from database row.
     */
    public Community(String id, int level, String binaryId, String parentCommunityId,
                     String name, String summary, int memberCount, boolean isStale,
                     long createdAt, long updatedAt) {
        this.id = id;
        this.level = level;
        this.binaryId = binaryId;
        this.parentCommunityId = parentCommunityId;
        this.name = name;
        this.summary = summary;
        this.memberCount = memberCount;
        this.isStale = isStale;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
    }

    // ========================================
    // Getters
    // ========================================

    public String getId() {
        return id;
    }

    public int getLevel() {
        return level;
    }

    public String getBinaryId() {
        return binaryId;
    }

    public String getParentCommunityId() {
        return parentCommunityId;
    }

    public String getName() {
        return name;
    }

    public String getSummary() {
        return summary;
    }

    public int getMemberCount() {
        return memberCount;
    }

    public boolean isStale() {
        return isStale;
    }

    public long getCreatedAt() {
        return createdAt;
    }

    public long getUpdatedAt() {
        return updatedAt;
    }

    // ========================================
    // Setters
    // ========================================

    public void setParentCommunityId(String parentCommunityId) {
        this.parentCommunityId = parentCommunityId;
        this.updatedAt = System.currentTimeMillis();
    }

    public void setName(String name) {
        this.name = name;
        this.updatedAt = System.currentTimeMillis();
    }

    public void setSummary(String summary) {
        this.summary = summary;
        this.isStale = false;
        this.updatedAt = System.currentTimeMillis();
    }

    public void setMemberCount(int memberCount) {
        this.memberCount = memberCount;
        this.updatedAt = System.currentTimeMillis();
    }

    public void markStale() {
        this.isStale = true;
        this.updatedAt = System.currentTimeMillis();
    }

    public void markFresh() {
        this.isStale = false;
        this.updatedAt = System.currentTimeMillis();
    }

    // ========================================
    // Utility Methods
    // ========================================

    /**
     * Generate a default name based on community ID and member count.
     */
    public String generateDefaultName() {
        return String.format("Community_%s (%d functions)",
                id.substring(0, 8), memberCount);
    }

    /**
     * Check if this community has a summary.
     */
    public boolean hasSummary() {
        return summary != null && !summary.isEmpty();
    }

    @Override
    public String toString() {
        return String.format("Community[id=%s, name=%s, members=%d, level=%d, stale=%b]",
                id.substring(0, 8), name, memberCount, level, isStale);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Community other = (Community) obj;
        return id.equals(other.id);
    }

    @Override
    public int hashCode() {
        return id.hashCode();
    }
}

```

`src/main/java/ghidrassist/graphrag/community/CommunityDetector.java`:

```java
package ghidrassist.graphrag.community;

import java.util.*;
import java.util.stream.Collectors;

import org.jgrapht.Graph;

import ghidra.util.Msg;
import ghidra.util.task.TaskMonitor;
import ghidrassist.graphrag.BinaryKnowledgeGraph;
import ghidrassist.graphrag.BinaryKnowledgeGraph.LabeledEdge;
import ghidrassist.graphrag.nodes.EdgeType;
import ghidrassist.graphrag.nodes.KnowledgeNode;
import ghidrassist.graphrag.nodes.NodeType;

/**
 * Detects communities (clusters) of related functions in a binary's call graph
 * using the Label Propagation algorithm.
 *
 * Label Propagation is an efficient O(E) algorithm that:
 * 1. Initializes each node with a unique label
 * 2. Iteratively updates labels to match the most frequent neighbor label
 * 3. Converges when no labels change
 *
 * The algorithm naturally groups densely connected functions into communities.
 */
public class CommunityDetector {

    private static final int DEFAULT_MAX_ITERATIONS = 100;
    private static final int DEFAULT_MIN_COMMUNITY_SIZE = 2;

    private final BinaryKnowledgeGraph graph;
    private final TaskMonitor monitor;
    private final Random random;

    public CommunityDetector(BinaryKnowledgeGraph graph, TaskMonitor monitor) {
        this.graph = graph;
        this.monitor = monitor;
        this.random = new Random();
    }

    /**
     * Detect communities in the call graph using Label Propagation.
     *
     * @param maxIterations Maximum iterations before stopping
     * @param minCommunitySize Minimum members for a community (smaller ones are merged)
     * @return Number of communities detected
     */
    public int detectCommunities(int maxIterations, int minCommunitySize) {
        Msg.info(this, "Starting community detection...");

        // Get the in-memory graph
        Graph<String, LabeledEdge> memGraph = graph.getMemoryGraph();
        if (memGraph == null || memGraph.vertexSet().isEmpty()) {
            Msg.warn(this, "No graph data available for community detection");
            return 0;
        }

        // Get only FUNCTION nodes (exclude BINARY, BLOCK, etc.)
        Set<String> functionNodeIds = getFunctionNodeIds();
        if (functionNodeIds.isEmpty()) {
            Msg.warn(this, "No function nodes found for community detection");
            return 0;
        }

        Msg.info(this, String.format("Detecting communities among %d functions", functionNodeIds.size()));

        // Run label propagation
        Map<String, Integer> nodeToLabel = runLabelPropagation(
                memGraph, functionNodeIds, maxIterations);

        // Group nodes by label
        Map<Integer, List<String>> communities = groupByLabel(nodeToLabel);

        // Merge small communities
        communities = mergeSmallCommunities(communities, minCommunitySize);

        Msg.info(this, String.format("Detected %d communities", communities.size()));

        // Clear existing communities for this binary
        graph.clearCommunitiesForBinary();

        // Create community records
        int communityCount = createCommunityRecords(communities);

        return communityCount;
    }

    /**
     * Detect communities with default parameters.
     */
    public int detectCommunities() {
        return detectCommunities(DEFAULT_MAX_ITERATIONS, DEFAULT_MIN_COMMUNITY_SIZE);
    }

    /**
     * Get IDs of all FUNCTION type nodes in the graph.
     */
    private Set<String> getFunctionNodeIds() {
        Set<String> ids = new HashSet<>();
        for (KnowledgeNode node : graph.getNodesByType(NodeType.FUNCTION)) {
            ids.add(node.getId());
        }
        return ids;
    }

    /**
     * Run Label Propagation algorithm on the graph.
     *
     * Algorithm:
     * 1. Initialize each node with unique label (0, 1, 2, ...)
     * 2. Shuffle nodes and iterate:
     *    - For each node, find most common label among neighbors
     *    - Update node's label to that most common label
     * 3. Stop when no labels change or max iterations reached
     */
    private Map<String, Integer> runLabelPropagation(
            Graph<String, LabeledEdge> memGraph,
            Set<String> nodeIds,
            int maxIterations) {

        // Initialize labels
        Map<String, Integer> labels = new HashMap<>();
        int labelCounter = 0;
        for (String nodeId : nodeIds) {
            labels.put(nodeId, labelCounter++);
        }

        // Convert to list for shuffling
        List<String> nodeList = new ArrayList<>(nodeIds);

        // Iterate until convergence
        for (int iteration = 0; iteration < maxIterations; iteration++) {
            if (monitor != null && monitor.isCancelled()) {
                break;
            }

            // Shuffle to avoid ordering bias
            Collections.shuffle(nodeList, random);

            boolean changed = false;

            for (String nodeId : nodeList) {
                if (!memGraph.containsVertex(nodeId)) {
                    continue;
                }

                // Get neighbor labels (considering only CALLS edges for call graph clustering)
                Map<Integer, Integer> labelCounts = new HashMap<>();

                // Outgoing edges (functions this node calls)
                for (LabeledEdge edge : memGraph.outgoingEdgesOf(nodeId)) {
                    if (isCallEdge(edge)) {
                        String targetId = memGraph.getEdgeTarget(edge);
                        if (labels.containsKey(targetId)) {
                            int targetLabel = labels.get(targetId);
                            labelCounts.merge(targetLabel, 1, Integer::sum);
                        }
                    }
                }

                // Incoming edges (functions that call this node)
                for (LabeledEdge edge : memGraph.incomingEdgesOf(nodeId)) {
                    if (isCallEdge(edge)) {
                        String sourceId = memGraph.getEdgeSource(edge);
                        if (labels.containsKey(sourceId)) {
                            int sourceLabel = labels.get(sourceId);
                            labelCounts.merge(sourceLabel, 1, Integer::sum);
                        }
                    }
                }

                // Find most common label
                if (!labelCounts.isEmpty()) {
                    int currentLabel = labels.get(nodeId);
                    int bestLabel = currentLabel;
                    int bestCount = labelCounts.getOrDefault(currentLabel, 0);

                    for (Map.Entry<Integer, Integer> entry : labelCounts.entrySet()) {
                        if (entry.getValue() > bestCount) {
                            bestLabel = entry.getKey();
                            bestCount = entry.getValue();
                        } else if (entry.getValue() == bestCount && entry.getKey() < bestLabel) {
                            // Tie-breaker: prefer smaller label for determinism
                            bestLabel = entry.getKey();
                        }
                    }

                    if (bestLabel != currentLabel) {
                        labels.put(nodeId, bestLabel);
                        changed = true;
                    }
                }
            }

            // Converged
            if (!changed) {
                Msg.debug(this, String.format("Label propagation converged after %d iterations", iteration + 1));
                break;
            }
        }

        return labels;
    }

    /**
     * Check if an edge represents a function call relationship.
     */
    private boolean isCallEdge(LabeledEdge edge) {
        EdgeType type = edge.getType();
        return type == EdgeType.CALLS || type == EdgeType.CALLS_VULNERABLE;
    }

    /**
     * Group node IDs by their community label.
     */
    private Map<Integer, List<String>> groupByLabel(Map<String, Integer> nodeToLabel) {
        Map<Integer, List<String>> communities = new HashMap<>();

        for (Map.Entry<String, Integer> entry : nodeToLabel.entrySet()) {
            communities.computeIfAbsent(entry.getValue(), k -> new ArrayList<>())
                    .add(entry.getKey());
        }

        return communities;
    }

    /**
     * Merge communities smaller than minSize into the nearest larger community.
     */
    private Map<Integer, List<String>> mergeSmallCommunities(
            Map<Integer, List<String>> communities,
            int minSize) {

        // Find small communities
        List<Integer> smallCommunityIds = communities.entrySet().stream()
                .filter(e -> e.getValue().size() < minSize)
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());

        if (smallCommunityIds.isEmpty()) {
            return communities;
        }

        // Find the largest community to merge orphans into
        int largestCommunityId = communities.entrySet().stream()
                .max(Comparator.comparingInt(e -> e.getValue().size()))
                .map(Map.Entry::getKey)
                .orElse(-1);

        if (largestCommunityId == -1) {
            return communities;
        }

        // Merge small communities
        for (Integer smallId : smallCommunityIds) {
            if (!smallId.equals(largestCommunityId)) {
                List<String> members = communities.remove(smallId);
                if (members != null) {
                    communities.get(largestCommunityId).addAll(members);
                }
            }
        }

        // Re-number communities to be contiguous
        Map<Integer, List<String>> renumbered = new HashMap<>();
        int newId = 0;
        for (List<String> members : communities.values()) {
            renumbered.put(newId++, members);
        }

        return renumbered;
    }

    /**
     * Helper class to hold prepared community data for batch processing.
     */
    @SuppressWarnings("unused")
    private static class CommunityData {
        final Community community;
        final List<String> memberIds;
        final int index;  // Reserved for batch processing index

        CommunityData(Community community, List<String> memberIds, int index) {
            this.community = community;
            this.memberIds = memberIds;
            this.index = index;
        }
    }

    /**
     * Create Community and membership records in the database.
     * Uses parallel processing for summary generation and batch DB operations.
     */
    private int createCommunityRecords(Map<Integer, List<String>> communities) {
        String binaryId = graph.getBinaryId();

        // Phase 1: Generate all community data in parallel
        // (names and summaries can be computed independently using the cached node data)
        List<CommunityData> communityDataList = communities.entrySet().parallelStream()
            .map(entry -> {
                List<String> memberIds = entry.getValue();
                int index = entry.getKey();

                Community community = new Community(binaryId, 0); // level 0 = function communities
                community.setMemberCount(memberIds.size());
                community.setName(generateCommunityName(memberIds, index));
                community.setSummary(generateCommunitySummary(memberIds));

                return new CommunityData(community, memberIds, index);
            })
            .collect(Collectors.toList());

        // Phase 2: Batch insert all records (sequential but using batch operations)
        int count = 0;
        for (CommunityData data : communityDataList) {
            if (monitor != null && monitor.isCancelled()) {
                break;
            }

            // Store community
            graph.upsertCommunity(data.community);

            // Add members and edges using batch operations
            for (String nodeId : data.memberIds) {
                graph.queueCommunityMemberForBatch(data.community.getId(), nodeId, 1.0);
                graph.queueEdgeForBatch(nodeId, data.community.getId(), EdgeType.BELONGS_TO_COMMUNITY);
            }

            count++;
        }

        // Flush remaining batches
        graph.flushAllBatches();

        Msg.info(this, String.format("Created %d community records", count));
        return count;
    }

    /**
     * Generate a descriptive name for a community based on its members.
     */
    private String generateCommunityName(List<String> memberIds, int communityIndex) {
        // Try to find a representative function name
        List<String> functionNames = new ArrayList<>();

        for (String nodeId : memberIds) {
            KnowledgeNode node = graph.getNode(nodeId);
            if (node != null && node.getName() != null) {
                String name = node.getName();
                // Skip generic names
                if (!name.startsWith("FUN_") && !name.startsWith("sub_")) {
                    functionNames.add(name);
                }
            }
        }

        if (!functionNames.isEmpty()) {
            // Use shortest meaningful name as representative
            functionNames.sort(Comparator.comparingInt(String::length));
            String representative = functionNames.get(0);
            return String.format("%s_group (%d)", representative, memberIds.size());
        }

        // Fallback to generic name
        return String.format("community_%d (%d functions)", communityIndex, memberIds.size());
    }

    /**
     * Generate a structural summary for a community based on its members.
     * This is LLM-free - aggregates data from member nodes.
     */
    private String generateCommunitySummary(List<String> memberIds) {
        StringBuilder summary = new StringBuilder();

        // Collect data from members
        List<String> namedFunctions = new ArrayList<>();
        Set<String> allSecurityFlags = new HashSet<>();
        int totalWithFlags = 0;

        for (String nodeId : memberIds) {
            KnowledgeNode node = graph.getNode(nodeId);
            if (node == null) continue;

            // Collect named functions (skip generic names)
            String name = node.getName();
            if (name != null && !name.startsWith("FUN_") && !name.startsWith("sub_")) {
                namedFunctions.add(name);
            }

            // Collect security flags
            List<String> flags = node.getSecurityFlags();
            if (flags != null && !flags.isEmpty()) {
                allSecurityFlags.addAll(flags);
                totalWithFlags++;
            }
        }

        // Build summary
        summary.append("Community of ").append(memberIds.size()).append(" functions. ");

        // Named functions
        if (!namedFunctions.isEmpty()) {
            int showCount = Math.min(5, namedFunctions.size());
            summary.append("Key functions: ");
            for (int i = 0; i < showCount; i++) {
                if (i > 0) summary.append(", ");
                summary.append(namedFunctions.get(i));
            }
            if (namedFunctions.size() > showCount) {
                summary.append(" (+").append(namedFunctions.size() - showCount).append(" more)");
            }
            summary.append(". ");
        }

        // Security flags
        if (!allSecurityFlags.isEmpty()) {
            summary.append("Security-relevant: ").append(totalWithFlags)
                   .append(" functions with flags [");

            List<String> flagList = new ArrayList<>(allSecurityFlags);
            Collections.sort(flagList);
            int showFlags = Math.min(5, flagList.size());
            for (int i = 0; i < showFlags; i++) {
                if (i > 0) summary.append(", ");
                summary.append(flagList.get(i));
            }
            if (flagList.size() > showFlags) {
                summary.append(", +").append(flagList.size() - showFlags).append(" more");
            }
            summary.append("]. ");
        }

        // Infer purpose from common patterns
        String inferredPurpose = inferCommunityPurpose(namedFunctions, allSecurityFlags);
        if (inferredPurpose != null) {
            summary.append("Likely purpose: ").append(inferredPurpose).append(".");
        }

        return summary.toString();
    }

    /**
     * Attempt to infer community purpose from function names and flags.
     */
    private String inferCommunityPurpose(List<String> functionNames, Set<String> flags) {
        String namesLower = String.join(" ", functionNames).toLowerCase();

        // Network-related
        if (namesLower.contains("recv") || namesLower.contains("send") ||
            namesLower.contains("socket") || namesLower.contains("connect") ||
            namesLower.contains("http") || namesLower.contains("network") ||
            flags.contains("NETWORK_CAPABLE")) {
            return "network I/O";
        }

        // File operations
        if (namesLower.contains("file") || namesLower.contains("read") ||
            namesLower.contains("write") || namesLower.contains("open") ||
            namesLower.contains("fopen") || namesLower.contains("fclose") ||
            flags.contains("FILE_READER") || flags.contains("FILE_WRITER")) {
            return "file operations";
        }

        // Crypto
        if (namesLower.contains("crypt") || namesLower.contains("encrypt") ||
            namesLower.contains("decrypt") || namesLower.contains("hash") ||
            namesLower.contains("aes") || namesLower.contains("sha") ||
            flags.contains("USES_CRYPTO")) {
            return "cryptographic operations";
        }

        // String handling
        if (namesLower.contains("str") || namesLower.contains("string") ||
            namesLower.contains("parse") || namesLower.contains("format")) {
            return "string processing";
        }

        // Memory management
        if (namesLower.contains("alloc") || namesLower.contains("malloc") ||
            namesLower.contains("free") || namesLower.contains("memory") ||
            namesLower.contains("heap")) {
            return "memory management";
        }

        // UI/Window
        if (namesLower.contains("window") || namesLower.contains("dialog") ||
            namesLower.contains("button") || namesLower.contains("menu") ||
            namesLower.contains("draw") || namesLower.contains("paint")) {
            return "UI/graphics";
        }

        // Process/thread
        if (namesLower.contains("thread") || namesLower.contains("process") ||
            namesLower.contains("create") || namesLower.contains("spawn") ||
            flags.contains("SPAWNS_PROCESSES")) {
            return "process/thread management";
        }

        // Registry (Windows)
        if (namesLower.contains("reg") || namesLower.contains("registry") ||
            namesLower.contains("hkey")) {
            return "registry operations";
        }

        // Initialization
        if (namesLower.contains("init") || namesLower.contains("setup") ||
            namesLower.contains("start") || namesLower.contains("main")) {
            return "initialization/entry";
        }

        return null;
    }

    /**
     * Get statistics about detected communities.
     */
    public Map<String, Object> getCommunityStats() {
        Map<String, Object> stats = new HashMap<>();

        List<Community> communities = graph.getCommunitiesForBinary(0);
        stats.put("total_communities", communities.size());

        if (!communities.isEmpty()) {
            int totalMembers = communities.stream()
                    .mapToInt(Community::getMemberCount)
                    .sum();
            int avgSize = totalMembers / communities.size();
            int maxSize = communities.stream()
                    .mapToInt(Community::getMemberCount)
                    .max()
                    .orElse(0);
            int minSize = communities.stream()
                    .mapToInt(Community::getMemberCount)
                    .min()
                    .orElse(0);

            stats.put("total_members", totalMembers);
            stats.put("avg_size", avgSize);
            stats.put("max_size", maxSize);
            stats.put("min_size", minSize);
        }

        return stats;
    }
}

```

`src/main/java/ghidrassist/graphrag/extraction/BackgroundIndexer.java`:

```java
package ghidrassist.graphrag.extraction;

import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import ghidra.util.task.TaskMonitor;

import ghidrassist.apiprovider.APIProvider;
import ghidrassist.graphrag.BinaryKnowledgeGraph;

import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Background indexer for populating the knowledge graph asynchronously.
 *
 * Manages the two-phase extraction process:
 * 1. Structure extraction (fast, no LLM) - runs immediately
 * 2. Semantic extraction (LLM summarization) - runs in background
 *
 * Provides status tracking and cancellation support.
 */
public class BackgroundIndexer {

    // Thread pool for background work
    private static final ExecutorService executor = Executors.newSingleThreadExecutor(r -> {
        Thread t = new Thread(r, "GraphRAG-Indexer");
        t.setDaemon(true);
        return t;
    });

    // Current indexing state
    private final AtomicBoolean isRunning = new AtomicBoolean(false);
    private final AtomicBoolean isCancelled = new AtomicBoolean(false);
    private final AtomicInteger progress = new AtomicInteger(0);
    private final AtomicInteger total = new AtomicInteger(0);

    private volatile String statusMessage = "Idle";
    private volatile Phase currentPhase = Phase.IDLE;
    private Future<?> currentTask;

    // References
    private final Program program;
    private final BinaryKnowledgeGraph graph;
    private final TaskMonitor monitor;
    private APIProvider provider;

    // Callbacks
    private IndexingCallback callback;

    /**
     * Indexing phases.
     */
    public enum Phase {
        IDLE,
        STRUCTURE_EXTRACTION,
        SEMANTIC_EXTRACTION,
        COMPLETED,
        ERROR,
        CANCELLED
    }

    /**
     * Create a BackgroundIndexer for a program.
     *
     * @param program The Ghidra program to index
     * @param graph   The knowledge graph to populate
     * @param monitor Task monitor for the Ghidra UI
     */
    public BackgroundIndexer(Program program, BinaryKnowledgeGraph graph, TaskMonitor monitor) {
        this.program = program;
        this.graph = graph;
        this.monitor = monitor;
    }

    /**
     * Set the LLM provider for semantic extraction.
     * If not set, only structure extraction will run.
     */
    public void setProvider(APIProvider provider) {
        this.provider = provider;
    }

    /**
     * Set a callback for status updates.
     */
    public void setCallback(IndexingCallback callback) {
        this.callback = callback;
    }

    /**
     * Start the indexing process.
     *
     * @param includeBlocks   Whether to extract basic blocks (increases graph size)
     * @param runSemantic     Whether to run LLM summarization
     * @param summarizeLimit  Max nodes to summarize (0 = all)
     */
    public void start(boolean includeBlocks, boolean runSemantic, int summarizeLimit) {
        if (isRunning.get()) {
            Msg.warn(this, "Indexer is already running");
            return;
        }

        isRunning.set(true);
        isCancelled.set(false);
        progress.set(0);
        total.set(0);

        currentTask = executor.submit(() -> {
            try {
                runIndexing(includeBlocks, runSemantic, summarizeLimit);
            } catch (Exception e) {
                Msg.error(this, "Indexing failed: " + e.getMessage(), e);
                setPhase(Phase.ERROR, "Error: " + e.getMessage());
            } finally {
                isRunning.set(false);
            }
        });
    }

    /**
     * Start structure extraction only (no LLM).
     * Fast operation suitable for immediate use.
     */
    public void startStructureOnly(boolean includeBlocks) {
        start(includeBlocks, false, 0);
    }

    /**
     * Start full indexing with LLM summarization.
     */
    public void startFull(boolean includeBlocks, int summarizeLimit) {
        start(includeBlocks, true, summarizeLimit);
    }

    /**
     * Cancel the current indexing operation.
     */
    public void cancel() {
        isCancelled.set(true);
        if (currentTask != null) {
            currentTask.cancel(false);
        }
        setPhase(Phase.CANCELLED, "Indexing cancelled");
    }

    /**
     * Wait for indexing to complete.
     *
     * @param timeoutSeconds Maximum time to wait
     * @return true if completed, false if timeout or error
     */
    public boolean waitForCompletion(int timeoutSeconds) {
        if (currentTask == null) {
            return true;
        }

        try {
            currentTask.get(timeoutSeconds, TimeUnit.SECONDS);
            return true;
        } catch (TimeoutException e) {
            Msg.warn(this, "Indexing timeout after " + timeoutSeconds + " seconds");
            return false;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return false;
        } catch (ExecutionException e) {
            Msg.error(this, "Indexing error: " + e.getCause().getMessage());
            return false;
        }
    }

    // ========================================
    // Status Getters
    // ========================================

    public boolean isRunning() {
        return isRunning.get();
    }

    public Phase getCurrentPhase() {
        return currentPhase;
    }

    public String getStatusMessage() {
        return statusMessage;
    }

    public int getProgress() {
        return progress.get();
    }

    public int getTotal() {
        return total.get();
    }

    public float getProgressPercent() {
        int t = total.get();
        return t > 0 ? (float) progress.get() / t * 100 : 0;
    }

    // ========================================
    // Internal Processing
    // ========================================

    private void runIndexing(boolean includeBlocks, boolean runSemantic, int summarizeLimit) {
        // Phase 1: Structure Extraction
        setPhase(Phase.STRUCTURE_EXTRACTION, "Extracting program structure...");

        StructureExtractor structureExtractor = new StructureExtractor(program, graph, monitor);
        try {
            StructureExtractor.ExtractionResult structResult = structureExtractor.extractAll(includeBlocks);

            total.set(structResult.functionsExtracted);
            progress.set(structResult.functionsExtracted);

            setPhase(Phase.STRUCTURE_EXTRACTION,
                    String.format("Extracted %d functions, %d call edges",
                            structResult.functionsExtracted, structResult.callEdgesCreated));

            notifyCallback(Phase.STRUCTURE_EXTRACTION, structResult.toString());

        } finally {
            structureExtractor.dispose();
        }

        if (isCancelled.get()) {
            setPhase(Phase.CANCELLED, "Cancelled during structure extraction");
            return;
        }

        // Phase 2: Semantic Extraction (optional)
        if (runSemantic && provider != null) {
            setPhase(Phase.SEMANTIC_EXTRACTION, "Running LLM summarization...");

            SemanticExtractor semanticExtractor = new SemanticExtractor(provider, graph);

            // Configure based on provider type (slower for cloud, faster for local)
            if (isLocalProvider()) {
                semanticExtractor.setBatchConfig(10, 100); // Faster for local
            } else {
                semanticExtractor.setBatchConfig(3, 1000); // Slower for cloud (rate limits)
            }

            SemanticExtractor.ExtractionResult semResult = semanticExtractor.summarizeStaleNodes(
                    summarizeLimit,
                    (processed, total, summarized, errors) -> {
                        this.progress.set(processed);
                        this.total.set(total);
                        setPhase(Phase.SEMANTIC_EXTRACTION,
                                String.format("Summarizing: %d/%d (%d errors)", summarized, total, errors));
                    }
            );

            if (isCancelled.get()) {
                setPhase(Phase.CANCELLED, "Cancelled during semantic extraction");
                graph.rebuildFts();
                return;
            }

            notifyCallback(Phase.SEMANTIC_EXTRACTION, semResult.toString());
        }

        // Rebuild FTS index after all extraction is complete
        graph.rebuildFts();

        // Done
        setPhase(Phase.COMPLETED, "Indexing complete");
        notifyCallback(Phase.COMPLETED, "Indexing complete: " + graph.getNodeCount() + " nodes");
    }

    private void setPhase(Phase phase, String message) {
        this.currentPhase = phase;
        this.statusMessage = message;
        Msg.info(this, "GraphRAG Indexer: [" + phase + "] " + message);
    }

    private void notifyCallback(Phase phase, String message) {
        if (callback != null) {
            callback.onStatusUpdate(phase, message, progress.get(), total.get());
        }
    }

    private boolean isLocalProvider() {
        if (provider == null) return false;
        APIProvider.ProviderType type = provider.getType();
        return type == APIProvider.ProviderType.OLLAMA ||
               type == APIProvider.ProviderType.LMSTUDIO;
    }

    // ========================================
    // Callback Interface
    // ========================================

    /**
     * Callback interface for indexing status updates.
     */
    public interface IndexingCallback {
        void onStatusUpdate(Phase phase, String message, int progress, int total);
    }

    // ========================================
    // Static Factory Methods
    // ========================================

    /**
     * Create an indexer and immediately start structure extraction.
     * Returns quickly - extraction runs in background.
     */
    public static BackgroundIndexer createAndStart(Program program, BinaryKnowledgeGraph graph,
                                                    TaskMonitor monitor, boolean includeBlocks) {
        BackgroundIndexer indexer = new BackgroundIndexer(program, graph, monitor);
        indexer.startStructureOnly(includeBlocks);
        return indexer;
    }

    /**
     * Run structure extraction synchronously (blocking).
     * Use this when you need immediate results.
     */
    public static StructureExtractor.ExtractionResult runStructureSync(
            Program program, BinaryKnowledgeGraph graph, TaskMonitor monitor, boolean includeBlocks) {
        return runStructureSync(program, graph, monitor, includeBlocks, false);
    }

    /**
     * Run structure extraction synchronously with optional incremental mode.
     *
     * @param program       The program to extract from
     * @param graph         The knowledge graph to populate
     * @param monitor       Task monitor for progress/cancellation
     * @param includeBlocks Whether to extract basic blocks
     * @param incremental   If true, preserves existing semantic data (summaries, embeddings, flags)
     * @return Extraction result with statistics
     */
    public static StructureExtractor.ExtractionResult runStructureSync(
            Program program, BinaryKnowledgeGraph graph, TaskMonitor monitor,
            boolean includeBlocks, boolean incremental) {

        StructureExtractor extractor = new StructureExtractor(program, graph, monitor);
        try {
            extractor.setIncrementalMode(incremental);
            return extractor.extractAll(includeBlocks);
        } finally {
            extractor.dispose();
        }
    }
}

```

`src/main/java/ghidrassist/graphrag/extraction/ExtractionPrompts.java`:

```java
package ghidrassist.graphrag.extraction;

import ghidrassist.graphrag.nodes.KnowledgeNode;

import java.util.List;

/**
 * Prompt templates for LLM-based semantic extraction.
 *
 * These prompts are designed for:
 * - Function summarization (purpose, behavior, security)
 * - Module/community summarization (subsystem identification)
 * - Binary-level summarization (overall purpose, attack surface)
 * - Security analysis (vulnerability patterns)
 */
public class ExtractionPrompts {

    // ========================================
    // Function Summarization
    // ========================================

    /**
     * Generate a prompt to summarize a function.
     *
     * @param functionName Name of the function
     * @param decompiledCode Decompiled C code
     * @param callers List of caller function names (context)
     * @param callees List of callee function names (context)
     * @return Prompt string for LLM
     */
    public static String functionSummaryPrompt(String functionName, String decompiledCode,
                                                List<String> callers, List<String> callees) {
        StringBuilder prompt = new StringBuilder();

        // Analyze complexity to determine appropriate summary length
        ComplexityMetrics complexity = analyzeComplexity(decompiledCode);

        prompt.append("Analyze this decompiled function and provide a structured summary.\n\n");

        prompt.append("## Function: ").append(functionName).append("\n\n");

        // Include complexity info for the LLM
        prompt.append("**Complexity:** ").append(complexity.toString()).append("\n");

        if (!callers.isEmpty()) {
            prompt.append("**Called by:** ").append(String.join(", ", callers)).append("\n");
        }
        if (!callees.isEmpty()) {
            prompt.append("**Calls:** ").append(String.join(", ", callees)).append("\n");
        }
        prompt.append("\n");

        // Use larger truncation limit for complex functions
        int truncateLimit = complexity.level.equals("very_complex") ? 4000 :
                           complexity.level.equals("complex") ? 3000 : 2000;
        prompt.append("```c\n").append(truncateCode(decompiledCode, truncateLimit)).append("\n```\n\n");

        // Output format instructions - explicit and mandatory
        prompt.append("## Output Format (REQUIRED - follow this structure exactly):\n\n");

        prompt.append("**Summary:** [1-3 sentences describing what this function does]\n\n");

        // Complexity-based section guidance
        if (complexity.level.equals("simple")) {
            prompt.append("For this simple function, provide ONLY the Summary and Category sections.\n\n");
        } else {
            prompt.append("[Include the following sections ONLY if applicable to this function:]\n\n");

            if (complexity.level.equals("very_complex") || complexity.level.equals("complex")) {
                prompt.append("**Details:** [Detailed explanation of the function's logic including:\n");
                prompt.append("- Main code paths and control flow\n");
                prompt.append("- Key data transformations and algorithms\n");
                prompt.append("- Important state changes and side effects\n");
                prompt.append("- Error handling patterns\n");
                prompt.append("Use multiple paragraphs as needed for complex functions.]\n\n");
            } else {
                prompt.append("**Details:** [Brief description of control flow and key operations. ");
                prompt.append("Skip this section for trivial utility functions.]\n\n");
            }

            prompt.append("**File IO:** [ONLY if this function performs file operations: ");
            prompt.append("list operations like fopen, fread, fwrite, fclose, CreateFile, ReadFile, etc. ");
            prompt.append("Otherwise OMIT this section entirely.]\n\n");

            prompt.append("**Network IO:** [ONLY if this function performs network operations: ");
            prompt.append("list operations like socket, connect, send, recv, WSAStartup, getaddrinfo, etc. ");
            prompt.append("Otherwise OMIT this section entirely.]\n\n");

            prompt.append("**Security:** [ONLY if security-relevant observations exist: ");
            prompt.append("buffer handling concerns, input validation issues, crypto usage, ");
            prompt.append("privilege operations, error handling gaps. Otherwise OMIT this section.]\n\n");
        }

        prompt.append("**Category:** [REQUIRED - One of: initialization, data_processing, io_operations, ");
        prompt.append("network, crypto, authentication, error_handling, utility, unknown]\n");

        return prompt.toString();
    }

    /**
     * Generate a complexity-scaled summary prompt for individual function processing.
     * Uses simplified format for batch/brief processing - Summary and Category only.
     */
    public static String functionBriefSummaryPrompt(String functionName, String decompiledCode) {
        ComplexityMetrics complexity = analyzeComplexity(decompiledCode);
        StringBuilder prompt = new StringBuilder();

        prompt.append("Summarize this decompiled function.\n\n");
        prompt.append("Function: ").append(functionName).append("\n");
        prompt.append("Complexity: ").append(complexity.toString()).append("\n\n");

        // Scale truncation limit with complexity
        int truncateLimit = complexity.level.equals("very_complex") ? 4000 :
                           complexity.level.equals("complex") ? 3000 :
                           complexity.level.equals("moderate") ? 2000 : 1500;
        prompt.append("```c\n").append(truncateCode(decompiledCode, truncateLimit)).append("\n```\n\n");

        prompt.append("## Output Format (REQUIRED):\n\n");
        prompt.append("**Summary:** [");
        if (complexity.level.equals("simple")) {
            prompt.append("1-2 sentences");
        } else if (complexity.level.equals("moderate")) {
            prompt.append("2-4 sentences");
        } else {
            prompt.append("1-2 paragraphs covering key functionality");
        }
        prompt.append(" describing what this function does]\n\n");

        prompt.append("**Category:** [One of: initialization, data_processing, io_operations, ");
        prompt.append("network, crypto, authentication, error_handling, utility, unknown]\n\n");

        prompt.append("Do NOT include other sections (Details, File IO, Network IO, Security) in this brief format.");

        return prompt.toString();
    }

    // ========================================
    // Module/Community Summarization
    // ========================================

    /**
     * Generate a prompt to summarize a module (community of functions).
     *
     * @param moduleName Name/ID of the module
     * @param memberSummaries Brief summaries of member functions
     * @param internalCallCount Number of calls within the module
     * @param externalCallCount Number of calls to/from outside
     * @return Prompt string for LLM
     */
    public static String moduleSummaryPrompt(String moduleName, List<String> memberSummaries,
                                              int internalCallCount, int externalCallCount) {
        StringBuilder prompt = new StringBuilder();

        prompt.append("Analyze this module (cluster of related functions) and provide a summary.\n\n");

        prompt.append("## Module: ").append(moduleName).append("\n\n");
        prompt.append("**Internal calls:** ").append(internalCallCount).append("\n");
        prompt.append("**External interface calls:** ").append(externalCallCount).append("\n\n");

        prompt.append("### Member Functions:\n");
        for (int i = 0; i < Math.min(memberSummaries.size(), 20); i++) {
            prompt.append("- ").append(memberSummaries.get(i)).append("\n");
        }
        if (memberSummaries.size() > 20) {
            prompt.append("- ... and ").append(memberSummaries.size() - 20).append(" more functions\n");
        }
        prompt.append("\n");

        prompt.append("Provide a summary in the following format:\n\n");
        prompt.append("**Subsystem:** [Name this subsystem/module based on its functions]\n\n");
        prompt.append("**Purpose:** [2-3 sentences describing what this module does]\n\n");
        prompt.append("**Key Functions:** [List 3-5 most important functions and their roles]\n\n");
        prompt.append("**Security Relevance:** [Attack surface, sensitive operations, trust boundaries]\n");

        return prompt.toString();
    }

    // ========================================
    // Binary-Level Summarization
    // ========================================

    /**
     * Generate a prompt to summarize the entire binary.
     *
     * @param binaryName Name of the binary
     * @param format Executable format (PE, ELF, etc.)
     * @param moduleSummaries Summaries of detected modules
     * @param entryPoints Entry point function names
     * @param imports Notable imported functions
     * @return Prompt string for LLM
     */
    public static String binarySummaryPrompt(String binaryName, String format,
                                              List<String> moduleSummaries,
                                              List<String> entryPoints,
                                              List<String> imports) {
        StringBuilder prompt = new StringBuilder();

        prompt.append("Analyze this binary based on its structure and provide a security-focused summary.\n\n");

        prompt.append("## Binary: ").append(binaryName).append("\n");
        prompt.append("**Format:** ").append(format).append("\n\n");

        if (!entryPoints.isEmpty()) {
            prompt.append("### Entry Points:\n");
            for (String entry : entryPoints) {
                prompt.append("- ").append(entry).append("\n");
            }
            prompt.append("\n");
        }

        if (!imports.isEmpty()) {
            prompt.append("### Notable Imports:\n");
            for (String imp : imports.subList(0, Math.min(imports.size(), 30))) {
                prompt.append("- ").append(imp).append("\n");
            }
            prompt.append("\n");
        }

        if (!moduleSummaries.isEmpty()) {
            prompt.append("### Detected Modules:\n");
            for (String mod : moduleSummaries) {
                prompt.append("- ").append(mod).append("\n");
            }
            prompt.append("\n");
        }

        prompt.append("Provide a summary in the following format:\n\n");
        prompt.append("**Program Type:** [What kind of program is this? e.g., server, client, utility, malware]\n\n");
        prompt.append("**Primary Purpose:** [2-3 sentences describing what this program does]\n\n");
        prompt.append("**Key Capabilities:** [Bullet list of main capabilities]\n\n");
        prompt.append("**Attack Surface:** [Input sources, network interfaces, file operations]\n\n");
        prompt.append("**Security Concerns:** [Potential vulnerabilities, dangerous patterns, trust issues]\n");

        return prompt.toString();
    }

    // ========================================
    // Security Analysis Prompts
    // ========================================

    /**
     * Generate a prompt to analyze a potential vulnerability.
     */
    public static String vulnerabilityAnalysisPrompt(String functionName, String code,
                                                      String vulnerabilityType) {
        StringBuilder prompt = new StringBuilder();

        prompt.append("Analyze this function for potential ").append(vulnerabilityType).append(" vulnerability.\n\n");

        prompt.append("## Function: ").append(functionName).append("\n\n");
        prompt.append("```c\n").append(truncateCode(code, 2000)).append("\n```\n\n");

        prompt.append("Provide analysis in the following format:\n\n");
        prompt.append("**Vulnerability Present:** [Yes/No/Possible]\n\n");
        prompt.append("**Evidence:** [Specific code patterns that indicate the vulnerability]\n\n");
        prompt.append("**Exploitation:** [How could this be exploited?]\n\n");
        prompt.append("**Severity:** [Critical/High/Medium/Low/Informational]\n\n");
        prompt.append("**Remediation:** [How to fix this issue]\n");

        return prompt.toString();
    }

    /**
     * Generate a prompt to explain a single line of code.
     *
     * @param lineContent The line to explain
     * @param contextBefore Lines before for context
     * @param contextAfter Lines after for context
     * @param functionName Name of the containing function
     * @param isDecompiled true if decompiled C code, false if assembly
     * @return Prompt string for LLM
     */
    public static String lineExplanationPrompt(String lineContent, String contextBefore,
                                                String contextAfter, String functionName,
                                                boolean isDecompiled) {
        StringBuilder prompt = new StringBuilder();

        if (isDecompiled) {
            prompt.append("Explain this line of decompiled C code in the context of the surrounding code.\n\n");
        } else {
            prompt.append("Explain this assembly instruction in the context of the surrounding instructions.\n\n");
        }

        prompt.append("## Function: ").append(functionName).append("\n\n");

        // Build code block with target line marked
        prompt.append("```");
        prompt.append(isDecompiled ? "c" : "asm");
        prompt.append("\n");

        // Context before
        if (contextBefore != null && !contextBefore.isEmpty()) {
            prompt.append(contextBefore);
            if (!contextBefore.endsWith("\n")) {
                prompt.append("\n");
            }
        }

        // Target line with marker
        prompt.append(">>> ").append(lineContent).append("  <<< [EXPLAIN THIS LINE]\n");

        // Context after
        if (contextAfter != null && !contextAfter.isEmpty()) {
            prompt.append(contextAfter);
        }

        prompt.append("```\n\n");

        prompt.append("## Instructions:\n");
        prompt.append("Explain the marked line (>>> ... <<<) in 2-4 sentences. Focus on:\n");

        if (isDecompiled) {
            prompt.append("1. What this statement does (data flow, function calls, assignments)\n");
            prompt.append("2. How it relates to the surrounding code context\n");
            prompt.append("3. Any security-relevant observations (if applicable)\n");
        } else {
            prompt.append("1. What this instruction does at the CPU level\n");
            prompt.append("2. Its role in the surrounding instruction sequence\n");
            prompt.append("3. What high-level operation this might represent\n");
        }

        prompt.append("\nProvide a concise, direct explanation without repeating the code.\n");

        return prompt.toString();
    }

    /**
     * Generate a prompt to analyze taint flow between functions.
     */
    public static String taintAnalysisPrompt(String sourceFunctionCode, String sinkFunctionCode,
                                              List<String> pathFunctions) {
        StringBuilder prompt = new StringBuilder();

        prompt.append("Analyze the data flow between these functions for security issues.\n\n");

        prompt.append("## Source (user input):\n");
        prompt.append("```c\n").append(truncateCode(sourceFunctionCode, 1000)).append("\n```\n\n");

        if (!pathFunctions.isEmpty()) {
            prompt.append("## Path through:\n");
            for (String func : pathFunctions) {
                prompt.append("- ").append(func).append("\n");
            }
            prompt.append("\n");
        }

        prompt.append("## Sink (sensitive operation):\n");
        prompt.append("```c\n").append(truncateCode(sinkFunctionCode, 1000)).append("\n```\n\n");

        prompt.append("Analyze:\n");
        prompt.append("1. Is user-controlled data reaching the sink without validation?\n");
        prompt.append("2. What type of vulnerability could this represent?\n");
        prompt.append("3. What exploitation scenario is possible?\n");

        return prompt.toString();
    }

    // ========================================
    // Batch Processing
    // ========================================

    /**
     * Generate a batch prompt for summarizing multiple functions at once.
     * Summary length scales with each function's complexity.
     *
     * @param nodes List of KnowledgeNodes to summarize
     * @return Prompt string for batch processing
     */
    public static String batchFunctionSummaryPrompt(List<KnowledgeNode> nodes) {
        StringBuilder prompt = new StringBuilder();

        prompt.append("Summarize each of these functions. Scale your summary length based on complexity:\n");
        prompt.append("- Simple functions (few lines, no loops/branches): 1-2 sentences\n");
        prompt.append("- Moderate functions: 3-5 sentences\n");
        prompt.append("- Complex functions (many branches, loops, calls): 1-2 paragraphs\n");
        prompt.append("- Very complex functions: 2-3 paragraphs covering all major code paths\n\n");
        prompt.append("Format your response as a numbered list matching the input.\n\n");

        for (int i = 0; i < nodes.size(); i++) {
            KnowledgeNode node = nodes.get(i);
            String code = node.getRawContent();
            ComplexityMetrics complexity = analyzeComplexity(code);

            // Scale truncation based on complexity
            int truncateLimit = complexity.level.equals("very_complex") ? 2000 :
                               complexity.level.equals("complex") ? 1500 :
                               complexity.level.equals("moderate") ? 1000 : 800;

            prompt.append(String.format("%d. **%s** [%s]\n```c\n%s\n```\n\n",
                    i + 1,
                    node.getName() != null ? node.getName() : "unknown",
                    complexity.level,
                    truncateCode(code, truncateLimit)
            ));
        }

        prompt.append("Summaries:\n");
        return prompt.toString();
    }

    // ========================================
    // Response Parsing Helpers
    // ========================================

    /**
     * Extract the Summary section from a function summary response.
     */
    public static String extractSummary(String response) {
        return extractSection(response, "Summary:");
    }

    /**
     * Extract the Details section from a function summary response.
     * Returns null if section not present.
     */
    public static String extractDetails(String response) {
        return extractSection(response, "Details:");
    }

    /**
     * Extract the File IO section from a function summary response.
     * Returns null if section not present.
     */
    public static String extractFileIO(String response) {
        return extractSection(response, "File IO:");
    }

    /**
     * Extract the Network IO section from a function summary response.
     * Returns null if section not present.
     */
    public static String extractNetworkIO(String response) {
        return extractSection(response, "Network IO:");
    }

    /**
     * Extract the Security section from a function summary response.
     * Returns null if section not present.
     */
    public static String extractSecurity(String response) {
        return extractSection(response, "Security:");
    }

    /**
     * Extract the category from a function summary response.
     */
    public static String extractCategory(String response) {
        return extractSection(response, "Category:");
    }

    /**
     * Legacy: Extract the purpose line (maps to Summary for backwards compatibility).
     * @deprecated Use extractSummary() instead
     */
    @Deprecated
    public static String extractPurpose(String response) {
        // Try new format first, fall back to old format
        String summary = extractSection(response, "Summary:");
        if (summary != null) return summary;
        return extractSection(response, "Purpose:");
    }

    /**
     * Legacy: Extract the security notes (maps to Security for backwards compatibility).
     * @deprecated Use extractSecurity() instead
     */
    @Deprecated
    public static String extractSecurityNotes(String response) {
        // Try new format first, fall back to old format
        String security = extractSection(response, "Security:");
        if (security != null) return security;
        return extractSection(response, "Security Notes:");
    }

    private static String extractSection(String response, String header) {
        if (response == null) return null;

        // Try with ** markdown formatting first
        int start = response.indexOf("**" + header);
        if (start != -1) {
            start = response.indexOf("**", start + 2);  // Find closing **
            if (start != -1) start += 2;  // Move past **
        }

        // Fall back to plain header
        if (start == -1) {
            start = response.indexOf(header);
            if (start != -1) start += header.length();
        }

        if (start == -1) return null;

        // Find the end of this section (next section header or end of text)
        int end = response.length();

        // Look for next section (with ** prefix)
        int nextSection = response.indexOf("\n**", start);
        if (nextSection != -1 && nextSection < end) end = nextSection;

        // Also check for double newline as section separator
        int doubleNewline = response.indexOf("\n\n", start);
        // Only use double newline if there's content after it that looks like a header
        if (doubleNewline != -1 && doubleNewline < end) {
            String afterNewline = response.substring(doubleNewline + 2).trim();
            if (afterNewline.startsWith("**") || afterNewline.matches("^[A-Z][a-z]+:.*")) {
                end = doubleNewline;
            }
        }

        String result = response.substring(start, end).trim();
        // Remove leading colon if present (from ** format)
        if (result.startsWith(":")) result = result.substring(1).trim();

        return result.isEmpty() ? null : result;
    }

    // ========================================
    // Complexity Analysis
    // ========================================

    /**
     * Complexity metrics for a function.
     */
    public static class ComplexityMetrics {
        public final int lineCount;
        public final int branchCount;     // if, while, for, switch, case
        public final int callCount;       // function calls
        public final int loopCount;       // while, for, do
        public final String level;        // "simple", "moderate", "complex", "very_complex"
        public final String summaryGuidance;

        public ComplexityMetrics(int lines, int branches, int calls, int loops) {
            this.lineCount = lines;
            this.branchCount = branches;
            this.callCount = calls;
            this.loopCount = loops;

            // Calculate complexity level
            int score = 0;
            score += lines > 50 ? 2 : (lines > 20 ? 1 : 0);
            score += branches > 10 ? 2 : (branches > 5 ? 1 : 0);
            score += calls > 8 ? 2 : (calls > 4 ? 1 : 0);
            score += loops > 3 ? 2 : (loops > 1 ? 1 : 0);

            if (score >= 6) {
                this.level = "very_complex";
                this.summaryGuidance = "This is a very complex function. Provide a detailed multi-paragraph summary (3-5 paragraphs) covering all major code paths, data transformations, and behaviors.";
            } else if (score >= 4) {
                this.level = "complex";
                this.summaryGuidance = "This is a complex function. Provide a thorough summary (2-3 paragraphs) explaining the main logic, key operations, and any notable patterns.";
            } else if (score >= 2) {
                this.level = "moderate";
                this.summaryGuidance = "This is a moderately complex function. Provide a detailed summary (1-2 paragraphs) explaining its purpose and key operations.";
            } else {
                this.level = "simple";
                this.summaryGuidance = "This is a simple function. Provide a concise summary (2-4 sentences) capturing its purpose and behavior.";
            }
        }

        @Override
        public String toString() {
            return String.format("%d lines, %d branches, %d calls, %d loops (%s)",
                    lineCount, branchCount, callCount, loopCount, level);
        }
    }

    /**
     * Analyze code complexity metrics.
     *
     * @param code Decompiled C code
     * @return Complexity metrics
     */
    public static ComplexityMetrics analyzeComplexity(String code) {
        if (code == null || code.isEmpty()) {
            return new ComplexityMetrics(0, 0, 0, 0);
        }

        // Count lines
        int lines = code.split("\n").length;

        // Count branches (if, else if, switch, case, ? ternary)
        int branches = 0;
        branches += countOccurrences(code, "\\bif\\s*\\(");
        branches += countOccurrences(code, "\\bswitch\\s*\\(");
        branches += countOccurrences(code, "\\bcase\\s+");
        branches += countOccurrences(code, "\\?.*:");  // ternary

        // Count loops (while, for, do)
        int loops = 0;
        loops += countOccurrences(code, "\\bwhile\\s*\\(");
        loops += countOccurrences(code, "\\bfor\\s*\\(");
        loops += countOccurrences(code, "\\bdo\\s*\\{");

        // Count function calls (identifier followed by parenthesis)
        int calls = countOccurrences(code, "\\b[a-zA-Z_][a-zA-Z0-9_]*\\s*\\(");
        // Subtract control structures which also match the pattern
        calls -= branches + loops;
        calls = Math.max(0, calls);

        return new ComplexityMetrics(lines, branches, calls, loops);
    }

    private static int countOccurrences(String text, String regex) {
        java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(regex);
        java.util.regex.Matcher matcher = pattern.matcher(text);
        int count = 0;
        while (matcher.find()) {
            count++;
        }
        return count;
    }

    // ========================================
    // Utility
    // ========================================

    private static String truncateCode(String code, int maxLength) {
        if (code == null) return "";
        if (code.length() <= maxLength) return code;

        // Try to truncate at a line boundary
        int cutoff = code.lastIndexOf('\n', maxLength);
        if (cutoff < maxLength / 2) cutoff = maxLength;

        return code.substring(0, cutoff) + "\n// ... (truncated)";
    }
}

```

`src/main/java/ghidrassist/graphrag/extraction/SecurityFeatureExtractor.java`:

```java
package ghidrassist.graphrag.extraction;

import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressSetView;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Reference;
import ghidra.program.model.symbol.ReferenceManager;
import ghidra.util.Msg;
import ghidra.util.task.TaskMonitor;

import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Extracts security-relevant features from functions for reverse engineering.
 *
 * Detects:
 * - Network API calls (socket, send, recv, SSL, etc.)
 * - File I/O API calls (open, read, write, fopen, etc.)
 * - Crypto API calls (CryptEncrypt, AES, etc.)
 * - Process API calls (CreateProcess, exec, system, etc.)
 * - String references (IPs, URLs, file paths, domains, registry keys)
 */
public class SecurityFeatureExtractor {

    // ========================================
    // API Signature Sets
    // ========================================

    // Network APIs - POSIX, WinSock, WinSock2
    private static final Set<String> NETWORK_APIS = Set.of(
        // POSIX socket operations
        "socket", "bind", "listen", "accept", "connect", "close", "shutdown",
        "setsockopt", "getsockopt", "getpeername", "getsockname",
        // POSIX data transfer
        "send", "sendto", "sendmsg", "recv", "recvfrom", "recvmsg",
        "read", "write",  // When used with sockets
        // POSIX multiplexing
        "select", "poll", "epoll_create", "epoll_ctl", "epoll_wait",
        "kqueue", "kevent",
        // WinSock / WinSock2 core
        "WSAStartup", "WSACleanup", "WSAGetLastError", "WSASetLastError",
        "closesocket",
        // WinSock2 socket creation
        "WSASocket", "WSASocketA", "WSASocketW",
        // WinSock2 connection
        "WSAConnect", "WSAConnectByName", "WSAConnectByNameA", "WSAConnectByNameW",
        "WSAConnectByList",
        // WinSock2 server (listen/accept)
        "WSAAccept",
        // WinSock2 data transfer
        "WSASend", "WSASendTo", "WSASendMsg", "WSASendDisconnect",
        "WSARecv", "WSARecvFrom", "WSARecvMsg", "WSARecvDisconnect",
        // WinSock2 async/event-based I/O
        "WSAAsyncSelect", "WSAEventSelect", "WSACreateEvent", "WSACloseEvent",
        "WSAWaitForMultipleEvents", "WSAEnumNetworkEvents", "WSAResetEvent", "WSASetEvent",
        // WinSock2 overlapped I/O
        "WSAIoctl", "WSAGetOverlappedResult",
        // WinSock2 address operations
        "WSAAddressToString", "WSAAddressToStringA", "WSAAddressToStringW",
        "WSAStringToAddress", "WSAStringToAddressA", "WSAStringToAddressW",
        // WinSock2 enumeration
        "WSAEnumProtocols", "WSAEnumProtocolsA", "WSAEnumProtocolsW",
        // DNS/resolution
        "getaddrinfo", "GetAddrInfo", "GetAddrInfoA", "GetAddrInfoW", "GetAddrInfoEx",
        "freeaddrinfo", "FreeAddrInfo", "FreeAddrInfoW",
        "gethostbyname", "gethostbyaddr", "gethostname",
        "getnameinfo", "GetNameInfo", "GetNameInfoW",
        "inet_addr", "inet_ntoa", "inet_pton", "inet_ntop",
        "InetPton", "InetPtonA", "InetPtonW", "InetNtop", "InetNtopA", "InetNtopW",
        "htons", "htonl", "ntohs", "ntohl",
        // SSL/TLS
        "SSL_connect", "SSL_accept", "SSL_read", "SSL_write", "SSL_new", "SSL_free",
        "SSL_CTX_new", "SSL_CTX_free", "SSL_set_fd", "SSL_shutdown",
        "SSL_library_init", "SSL_load_error_strings",
        "TLS_client_method", "TLS_server_method",
        // Windows Secure Channel (SChannel)
        "AcquireCredentialsHandle", "AcquireCredentialsHandleA", "AcquireCredentialsHandleW",
        "InitializeSecurityContext", "InitializeSecurityContextA", "InitializeSecurityContextW",
        "AcceptSecurityContext",
        "EncryptMessage", "DecryptMessage",
        // WinHTTP
        "WinHttpOpen", "WinHttpConnect", "WinHttpOpenRequest",
        "WinHttpSendRequest", "WinHttpReceiveResponse",
        "WinHttpReadData", "WinHttpWriteData", "WinHttpQueryHeaders",
        "WinHttpCloseHandle", "WinHttpSetOption", "WinHttpQueryOption",
        "WinHttpCrackUrl", "WinHttpCreateUrl",
        // WinINet
        "InternetOpen", "InternetOpenA", "InternetOpenW",
        "InternetConnect", "InternetConnectA", "InternetConnectW",
        "InternetOpenUrl", "InternetOpenUrlA", "InternetOpenUrlW",
        "InternetReadFile", "InternetReadFileEx",
        "InternetWriteFile",
        "InternetCloseHandle", "InternetSetOption", "InternetQueryOption",
        "HttpOpenRequest", "HttpOpenRequestA", "HttpOpenRequestW",
        "HttpSendRequest", "HttpSendRequestA", "HttpSendRequestW",
        "HttpSendRequestEx", "HttpSendRequestExA", "HttpSendRequestExW",
        "HttpQueryInfo", "HttpQueryInfoA", "HttpQueryInfoW",
        "HttpAddRequestHeaders", "HttpEndRequest",
        "FtpOpenFile", "FtpGetFile", "FtpPutFile", "FtpDeleteFile",
        "FtpCreateDirectory", "FtpRemoveDirectory", "FtpFindFirstFile",
        // libcurl
        "curl_easy_init", "curl_easy_perform", "curl_easy_cleanup",
        "curl_easy_setopt", "curl_easy_getinfo",
        "curl_multi_init", "curl_multi_add_handle", "curl_multi_perform"
    );

    // File I/O APIs - POSIX, C stdio, Win32
    private static final Set<String> FILE_IO_APIS = Set.of(
        // POSIX file operations
        "open", "close", "read", "write", "lseek", "pread", "pwrite",
        "creat", "dup", "dup2", "fcntl", "ioctl",
        "stat", "fstat", "lstat", "fstatat",
        "access", "faccessat", "chmod", "fchmod", "chown", "fchown",
        "truncate", "ftruncate",
        "mmap", "munmap", "msync",
        // C stdio
        "fopen", "fclose", "fread", "fwrite", "fgets", "fputs", "fgetc", "fputc",
        "fprintf", "fscanf", "fseek", "ftell", "fflush", "rewind", "feof", "ferror",
        "freopen", "fdopen", "fileno", "setvbuf", "setbuf",
        "getc", "putc", "ungetc", "getchar", "putchar",
        // POSIX directory operations
        "opendir", "closedir", "readdir", "readdir_r", "scandir", "seekdir", "telldir",
        "mkdir", "mkdirat", "rmdir", "chdir", "fchdir", "getcwd",
        // POSIX path operations
        "realpath", "basename", "dirname",
        "rename", "renameat", "remove", "unlink", "unlinkat",
        "link", "linkat", "symlink", "symlinkat", "readlink", "readlinkat",
        // Win32 file creation/opening
        "CreateFile", "CreateFileA", "CreateFileW",
        "CreateFile2",
        "OpenFile",
        // Win32 file read/write
        "ReadFile", "ReadFileEx", "ReadFileScatter",
        "WriteFile", "WriteFileEx", "WriteFileGather",
        "FlushFileBuffers",
        // Win32 file positioning
        "SetFilePointer", "SetFilePointerEx",
        "SetEndOfFile",
        // Win32 file info
        "GetFileSize", "GetFileSizeEx",
        "GetFileType",
        "GetFileTime", "SetFileTime",
        "GetFileInformationByHandle", "GetFileInformationByHandleEx",
        "SetFileInformationByHandle",
        // Win32 file attributes
        "GetFileAttributes", "GetFileAttributesA", "GetFileAttributesW",
        "GetFileAttributesEx", "GetFileAttributesExA", "GetFileAttributesExW",
        "SetFileAttributes", "SetFileAttributesA", "SetFileAttributesW",
        // Win32 file locking
        "LockFile", "LockFileEx", "UnlockFile", "UnlockFileEx",
        // Win32 file deletion/rename/copy/move
        "DeleteFile", "DeleteFileA", "DeleteFileW",
        "CopyFile", "CopyFileA", "CopyFileW",
        "CopyFileEx", "CopyFileExA", "CopyFileExW",
        "MoveFile", "MoveFileA", "MoveFileW",
        "MoveFileEx", "MoveFileExA", "MoveFileExW",
        "MoveFileWithProgress", "MoveFileWithProgressA", "MoveFileWithProgressW",
        "ReplaceFile", "ReplaceFileA", "ReplaceFileW",
        // Win32 file search/enumeration
        "FindFirstFile", "FindFirstFileA", "FindFirstFileW",
        "FindFirstFileEx", "FindFirstFileExA", "FindFirstFileExW",
        "FindNextFile", "FindNextFileA", "FindNextFileW",
        "FindClose",
        "SearchPath", "SearchPathA", "SearchPathW",
        // Win32 directory operations
        "CreateDirectory", "CreateDirectoryA", "CreateDirectoryW",
        "CreateDirectoryEx", "CreateDirectoryExA", "CreateDirectoryExW",
        "RemoveDirectory", "RemoveDirectoryA", "RemoveDirectoryW",
        "SetCurrentDirectory", "SetCurrentDirectoryA", "SetCurrentDirectoryW",
        "GetCurrentDirectory", "GetCurrentDirectoryA", "GetCurrentDirectoryW",
        // Win32 path operations
        "GetFullPathName", "GetFullPathNameA", "GetFullPathNameW",
        "GetLongPathName", "GetLongPathNameA", "GetLongPathNameW",
        "GetShortPathName", "GetShortPathNameA", "GetShortPathNameW",
        "GetTempPath", "GetTempPathA", "GetTempPathW",
        "GetTempFileName", "GetTempFileNameA", "GetTempFileNameW",
        "PathFileExists", "PathFileExistsA", "PathFileExistsW",
        // Win32 handle operations
        "CloseHandle", "DuplicateHandle",
        // Win32 memory-mapped files
        "CreateFileMapping", "CreateFileMappingA", "CreateFileMappingW",
        "OpenFileMapping", "OpenFileMappingA", "OpenFileMappingW",
        "MapViewOfFile", "MapViewOfFileEx", "UnmapViewOfFile",
        // Win32 async I/O
        "GetOverlappedResult", "GetOverlappedResultEx",
        "CancelIo", "CancelIoEx", "CancelSynchronousIo",
        // Win32 transacted file operations
        "CreateFileTransacted", "CreateFileTransactedA", "CreateFileTransactedW",
        "DeleteFileTransacted", "DeleteFileTransactedA", "DeleteFileTransactedW"
    );

    // Crypto APIs
    private static final Set<String> CRYPTO_APIS = Set.of(
        // Windows Crypto API
        "CryptAcquireContext", "CryptReleaseContext",
        "CryptGenKey", "CryptDeriveKey", "CryptDestroyKey",
        "CryptEncrypt", "CryptDecrypt",
        "CryptCreateHash", "CryptHashData", "CryptDestroyHash",
        "CryptSignHash", "CryptVerifySignature",
        "CryptImportKey", "CryptExportKey",
        // Windows CNG
        "BCryptOpenAlgorithmProvider", "BCryptCloseAlgorithmProvider",
        "BCryptGenerateKeyPair", "BCryptEncrypt", "BCryptDecrypt",
        "BCryptCreateHash", "BCryptHashData", "BCryptFinishHash",
        // OpenSSL
        "EVP_EncryptInit", "EVP_EncryptUpdate", "EVP_EncryptFinal",
        "EVP_DecryptInit", "EVP_DecryptUpdate", "EVP_DecryptFinal",
        "EVP_DigestInit", "EVP_DigestUpdate", "EVP_DigestFinal",
        "AES_encrypt", "AES_decrypt", "AES_set_encrypt_key", "AES_set_decrypt_key",
        "RSA_public_encrypt", "RSA_private_decrypt",
        "MD5_Init", "MD5_Update", "MD5_Final",
        "SHA1_Init", "SHA1_Update", "SHA1_Final",
        "SHA256_Init", "SHA256_Update", "SHA256_Final"
    );

    // Process/execution APIs
    private static final Set<String> PROCESS_APIS = Set.of(
        // POSIX
        "fork", "exec", "execl", "execle", "execlp", "execv", "execve", "execvp",
        "system", "popen", "pclose",
        "kill", "waitpid", "wait",
        // Windows
        "CreateProcess", "CreateProcessA", "CreateProcessW",
        "CreateProcessAsUser", "CreateProcessWithLogon",
        "ShellExecute", "ShellExecuteA", "ShellExecuteW",
        "ShellExecuteEx", "ShellExecuteExA", "ShellExecuteExW",
        "WinExec", "LoadLibrary", "LoadLibraryA", "LoadLibraryW",
        "GetProcAddress", "FreeLibrary",
        "OpenProcess", "TerminateProcess",
        "VirtualAlloc", "VirtualAllocEx", "VirtualProtect",
        "WriteProcessMemory", "ReadProcessMemory",
        "CreateRemoteThread", "CreateRemoteThreadEx"
    );

    // ========================================
    // Dangerous Functions - Vulnerability Indicators
    // ========================================

    /**
     * Map of dangerous function names to their vulnerability risk type.
     * These functions, when called, indicate potential security issues.
     */
    private static final Map<String, String> DANGEROUS_FUNCTIONS = Map.ofEntries(
        // Buffer overflow risks - unbounded string/memory operations
        Map.entry("strcpy", "BUFFER_OVERFLOW_RISK"),
        Map.entry("strcat", "BUFFER_OVERFLOW_RISK"),
        Map.entry("sprintf", "BUFFER_OVERFLOW_RISK"),
        Map.entry("vsprintf", "BUFFER_OVERFLOW_RISK"),
        Map.entry("gets", "BUFFER_OVERFLOW_RISK"),
        Map.entry("scanf", "BUFFER_OVERFLOW_RISK"),
        Map.entry("fscanf", "BUFFER_OVERFLOW_RISK"),
        Map.entry("sscanf", "BUFFER_OVERFLOW_RISK"),
        Map.entry("wcscpy", "BUFFER_OVERFLOW_RISK"),
        Map.entry("wcscat", "BUFFER_OVERFLOW_RISK"),
        Map.entry("lstrcpy", "BUFFER_OVERFLOW_RISK"),
        Map.entry("lstrcpyA", "BUFFER_OVERFLOW_RISK"),
        Map.entry("lstrcpyW", "BUFFER_OVERFLOW_RISK"),
        Map.entry("lstrcat", "BUFFER_OVERFLOW_RISK"),
        Map.entry("lstrcatA", "BUFFER_OVERFLOW_RISK"),
        Map.entry("lstrcatW", "BUFFER_OVERFLOW_RISK"),
        Map.entry("StrCpy", "BUFFER_OVERFLOW_RISK"),
        Map.entry("StrCat", "BUFFER_OVERFLOW_RISK"),
        Map.entry("_tcscpy", "BUFFER_OVERFLOW_RISK"),
        Map.entry("_tcscat", "BUFFER_OVERFLOW_RISK"),
        Map.entry("_mbscpy", "BUFFER_OVERFLOW_RISK"),
        Map.entry("_mbscat", "BUFFER_OVERFLOW_RISK"),

        // Format string risks
        Map.entry("printf", "FORMAT_STRING_RISK"),
        Map.entry("fprintf", "FORMAT_STRING_RISK"),
        Map.entry("wprintf", "FORMAT_STRING_RISK"),
        Map.entry("syslog", "FORMAT_STRING_RISK"),

        // Command injection risks
        Map.entry("system", "COMMAND_INJECTION_RISK"),
        Map.entry("popen", "COMMAND_INJECTION_RISK"),
        Map.entry("_popen", "COMMAND_INJECTION_RISK"),
        Map.entry("wpopen", "COMMAND_INJECTION_RISK"),
        Map.entry("execl", "COMMAND_INJECTION_RISK"),
        Map.entry("execle", "COMMAND_INJECTION_RISK"),
        Map.entry("execlp", "COMMAND_INJECTION_RISK"),
        Map.entry("execv", "COMMAND_INJECTION_RISK"),
        Map.entry("execve", "COMMAND_INJECTION_RISK"),
        Map.entry("execvp", "COMMAND_INJECTION_RISK"),
        Map.entry("WinExec", "COMMAND_INJECTION_RISK"),
        Map.entry("ShellExecute", "COMMAND_INJECTION_RISK"),
        Map.entry("ShellExecuteA", "COMMAND_INJECTION_RISK"),
        Map.entry("ShellExecuteW", "COMMAND_INJECTION_RISK"),
        Map.entry("ShellExecuteEx", "COMMAND_INJECTION_RISK"),
        Map.entry("ShellExecuteExA", "COMMAND_INJECTION_RISK"),
        Map.entry("ShellExecuteExW", "COMMAND_INJECTION_RISK"),

        // Integer overflow risks
        Map.entry("atoi", "INTEGER_OVERFLOW_RISK"),
        Map.entry("atol", "INTEGER_OVERFLOW_RISK"),
        Map.entry("atoll", "INTEGER_OVERFLOW_RISK"),
        Map.entry("strtol", "INTEGER_OVERFLOW_RISK"),
        Map.entry("strtoul", "INTEGER_OVERFLOW_RISK"),

        // Race condition risks
        Map.entry("access", "RACE_CONDITION_RISK"),
        Map.entry("stat", "RACE_CONDITION_RISK"),

        // Memory corruption risks
        Map.entry("alloca", "MEMORY_CORRUPTION_RISK"),
        Map.entry("_alloca", "MEMORY_CORRUPTION_RISK"),

        // Insecure random
        Map.entry("rand", "WEAK_RANDOM_RISK"),
        Map.entry("srand", "WEAK_RANDOM_RISK"),
        Map.entry("random", "WEAK_RANDOM_RISK"),

        // Deprecated/insecure crypto
        Map.entry("MD5_Init", "WEAK_CRYPTO_RISK"),
        Map.entry("MD5_Update", "WEAK_CRYPTO_RISK"),
        Map.entry("MD5_Final", "WEAK_CRYPTO_RISK"),
        Map.entry("MD5", "WEAK_CRYPTO_RISK"),
        Map.entry("SHA1_Init", "WEAK_CRYPTO_RISK"),
        Map.entry("SHA1_Update", "WEAK_CRYPTO_RISK"),
        Map.entry("SHA1_Final", "WEAK_CRYPTO_RISK"),
        Map.entry("DES_encrypt", "WEAK_CRYPTO_RISK"),
        Map.entry("DES_decrypt", "WEAK_CRYPTO_RISK")
    );

    // ========================================
    // String Pattern Matchers
    // ========================================

    // IP address pattern (IPv4)
    private static final Pattern IP_PATTERN = Pattern.compile(
        "^(\\d{1,3}\\.){3}\\d{1,3}$"
    );

    // URL pattern
    private static final Pattern URL_PATTERN = Pattern.compile(
        "^https?://[\\w.-]+(?:/[\\w./?%&=-]*)?$",
        Pattern.CASE_INSENSITIVE
    );

    // Unix file path pattern
    private static final Pattern UNIX_PATH_PATTERN = Pattern.compile(
        "^/[a-zA-Z0-9/_.-]+$"
    );

    // Windows file path pattern
    private static final Pattern WINDOWS_PATH_PATTERN = Pattern.compile(
        "^[A-Za-z]:\\\\[^<>:\"|?*]+$"
    );

    // Domain name pattern
    private static final Pattern DOMAIN_PATTERN = Pattern.compile(
        "^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?(\\.[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?)*\\.[a-zA-Z]{2,}$"
    );

    // Windows registry key pattern
    private static final Pattern REGISTRY_PATTERN = Pattern.compile(
        "^(HKEY_|HK[A-Z]{2})[\\\\A-Za-z0-9_-]+$"
    );

    // Pattern to extract function calls from decompiled code
    private static final Pattern CALL_PATTERN = Pattern.compile(
        "\\b([A-Za-z_@][A-Za-z0-9_@!:.]*)\\s*\\("
    );

    // Keywords to exclude from call extraction (control flow, not function calls)
    private static final Set<String> CALL_KEYWORDS = Set.of(
        "if", "for", "while", "switch", "case", "return", "sizeof",
        "do", "catch", "try", "else", "new", "delete"
    );

    // ========================================
    // Instance fields
    // ========================================

    private final Program program;
    private final TaskMonitor monitor;

    /**
     * Create a SecurityFeatureExtractor.
     *
     * @param program The Ghidra program to analyze
     * @param monitor Task monitor for cancellation
     */
    public SecurityFeatureExtractor(Program program, TaskMonitor monitor) {
        this.program = program;
        this.monitor = monitor;
    }

    // ========================================
    // Main Extraction Method
    // ========================================

    /**
     * Extract security features from a function.
     *
     * @param function The function to analyze
     * @return SecurityFeatures containing all detected features
     */
    public SecurityFeatures extractFeatures(Function function) {
        return extractFeatures(function, null);
    }

    /**
     * Extract security features from a function with optional decompiled code.
     * When decompiled code is provided, additional API calls are extracted via
     * regex parsing, catching calls that may not appear in the call graph.
     *
     * @param function The function to analyze
     * @param decompiledCode Optional decompiled C code for additional API extraction
     * @return SecurityFeatures containing all detected features
     */
    public SecurityFeatures extractFeatures(Function function, String decompiledCode) {
        SecurityFeatures features = new SecurityFeatures();

        if (function == null || program == null) {
            return features;
        }

        try {
            // 1. Detect API calls via called functions (from call graph)
            extractAPICalls(function, features);

            // 2. Extract API calls from decompiled code (catches more calls)
            if (decompiledCode != null && !decompiledCode.isEmpty()) {
                extractAPICallsFromCode(decompiledCode, features);
            }

            // 3. Extract string references
            extractStringReferences(function, features);

            // 4. Calculate activity profile and risk level
            features.calculateActivityProfile();
            features.calculateRiskLevel();

        } catch (Exception e) {
            Msg.warn(this, "Error extracting security features for " +
                function.getName() + ": " + e.getMessage());
        }

        return features;
    }

    // ========================================
    // API Call Detection
    // ========================================

    /**
     * Detect API calls by analyzing called functions.
     */
    private void extractAPICalls(Function function, SecurityFeatures features) {
        try {
            Set<Function> calledFunctions = function.getCalledFunctions(monitor);

            for (Function callee : calledFunctions) {
                if (monitor.isCancelled()) {
                    break;
                }

                String name = callee.getName();
                if (name == null || name.isEmpty()) {
                    continue;
                }

                // Normalize the function name to handle decorated names
                // Examples: _WSAGetLastError@0 -> WSAGetLastError, __imp_send -> send
                String normalizedName = normalizeFunctionName(name);

                // Check each API category using both original and normalized names
                if (NETWORK_APIS.contains(name) || NETWORK_APIS.contains(normalizedName)) {
                    features.addNetworkAPI(normalizedName);
                }
                if (FILE_IO_APIS.contains(name) || FILE_IO_APIS.contains(normalizedName)) {
                    features.addFileIOAPI(normalizedName);
                }
                if (CRYPTO_APIS.contains(name) || CRYPTO_APIS.contains(normalizedName)) {
                    features.addCryptoAPI(normalizedName);
                }
                if (PROCESS_APIS.contains(name) || PROCESS_APIS.contains(normalizedName)) {
                    features.addProcessAPI(normalizedName);
                }

                // Check for dangerous functions (vulnerability indicators)
                String vulnType = DANGEROUS_FUNCTIONS.get(name);
                if (vulnType == null) {
                    vulnType = DANGEROUS_FUNCTIONS.get(normalizedName);
                }
                if (vulnType != null) {
                    features.addDangerousFunction(normalizedName, vulnType);
                }
            }
        } catch (Exception e) {
            Msg.debug(this, "Error extracting API calls: " + e.getMessage());
        }
    }

    /**
     * Extract API calls from decompiled code using regex pattern matching.
     * This catches API calls that may not appear in the call graph, such as:
     * - Calls through function pointers
     * - Dynamically resolved imports
     * - Calls in inline code or macros
     *
     * @param decompiledCode The decompiled C code to analyze
     * @param features SecurityFeatures to update with detected APIs
     */
    private void extractAPICallsFromCode(String decompiledCode, SecurityFeatures features) {
        if (decompiledCode == null || decompiledCode.isEmpty()) {
            return;
        }

        Set<String> foundNames = new HashSet<>();
        Matcher matcher = CALL_PATTERN.matcher(decompiledCode);

        while (matcher.find()) {
            String candidate = matcher.group(1);
            if (candidate == null || candidate.isEmpty()) {
                continue;
            }

            // Skip control flow keywords
            if (CALL_KEYWORDS.contains(candidate.toLowerCase())) {
                continue;
            }

            foundNames.add(candidate);
        }

        // Check each found name against API sets
        for (String name : foundNames) {
            String normalizedName = normalizeFunctionName(name);

            // Check each API category
            if (NETWORK_APIS.contains(name) || NETWORK_APIS.contains(normalizedName)) {
                features.addNetworkAPI(normalizedName);
            }
            if (FILE_IO_APIS.contains(name) || FILE_IO_APIS.contains(normalizedName)) {
                features.addFileIOAPI(normalizedName);
            }
            if (CRYPTO_APIS.contains(name) || CRYPTO_APIS.contains(normalizedName)) {
                features.addCryptoAPI(normalizedName);
            }
            if (PROCESS_APIS.contains(name) || PROCESS_APIS.contains(normalizedName)) {
                features.addProcessAPI(normalizedName);
            }

            // Check for dangerous functions
            String vulnType = DANGEROUS_FUNCTIONS.get(name);
            if (vulnType == null) {
                vulnType = DANGEROUS_FUNCTIONS.get(normalizedName);
            }
            if (vulnType != null) {
                features.addDangerousFunction(normalizedName, vulnType);
            }
        }
    }

    /**
     * Normalize a function name by stripping common decorations:
     * - Leading underscores (_func, __func, __imp_func)
     * - Trailing @N suffix (stdcall decoration like @0, @4, @8)
     * - Trailing W or A suffix for Unicode/ANSI variants (if not in API set)
     */
    private String normalizeFunctionName(String name) {
        if (name == null || name.isEmpty()) {
            return name;
        }

        String normalized = name;

        // Strip __imp_ prefix (import thunk)
        if (normalized.startsWith("__imp_")) {
            normalized = normalized.substring(6);
        }

        // Strip leading underscores (but keep at least the core name)
        while (normalized.startsWith("_") && normalized.length() > 1) {
            normalized = normalized.substring(1);
        }

        // Strip trailing @N (stdcall decoration)
        int atIndex = normalized.lastIndexOf('@');
        if (atIndex > 0) {
            String suffix = normalized.substring(atIndex + 1);
            // Check if suffix is all digits
            if (suffix.matches("\\d+")) {
                normalized = normalized.substring(0, atIndex);
            }
        }

        return normalized;
    }

    // ========================================
    // String Reference Extraction
    // ========================================

    /**
     * Extract string references from the function body.
     */
    private void extractStringReferences(Function function, SecurityFeatures features) {
        ReferenceManager refMgr = program.getReferenceManager();
        AddressSetView body = function.getBody();

        try {
            // Iterate through all addresses in the function body
            for (Address addr : body.getAddresses(true)) {
                if (monitor.isCancelled()) {
                    break;
                }

                // Get references FROM this address
                Reference[] refs = refMgr.getReferencesFrom(addr);
                for (Reference ref : refs) {
                    Address toAddr = ref.getToAddress();

                    // Try to get data at the referenced address
                    Data data = program.getListing().getDataAt(toAddr);
                    if (data != null && data.hasStringValue()) {
                        Object value = data.getValue();
                        if (value != null) {
                            classifyString(value.toString(), features);
                        }
                    }
                }
            }
        } catch (Exception e) {
            Msg.debug(this, "Error extracting string references: " + e.getMessage());
        }
    }

    /**
     * Classify a string and add to appropriate category.
     */
    private void classifyString(String value, SecurityFeatures features) {
        if (value == null || value.isEmpty() || value.length() < 3) {
            return;
        }

        // Clean up the string
        value = value.trim();

        // Check patterns in order of specificity
        if (IP_PATTERN.matcher(value).matches()) {
            // Validate IP octets are 0-255
            if (isValidIPAddress(value)) {
                features.addIPAddress(value);
            }
        } else if (URL_PATTERN.matcher(value).matches()) {
            features.addURL(value);
        } else if (REGISTRY_PATTERN.matcher(value).matches()) {
            features.addRegistryKey(value);
        } else if (UNIX_PATH_PATTERN.matcher(value).matches()) {
            features.addFilePath(value);
        } else if (WINDOWS_PATH_PATTERN.matcher(value).matches()) {
            features.addFilePath(value);
        } else if (DOMAIN_PATTERN.matcher(value).matches()) {
            // Avoid false positives from common patterns
            if (!isCommonNonDomain(value)) {
                features.addDomain(value);
            }
        }
    }

    /**
     * Validate IP address octets are in valid range.
     */
    private boolean isValidIPAddress(String ip) {
        try {
            String[] parts = ip.split("\\.");
            if (parts.length != 4) {
                return false;
            }
            for (String part : parts) {
                int octet = Integer.parseInt(part);
                if (octet < 0 || octet > 255) {
                    return false;
                }
            }
            // Exclude common non-network IPs
            if (ip.equals("0.0.0.0") || ip.equals("255.255.255.255")) {
                return true;  // Include special IPs
            }
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }

    /**
     * Check if a string looks like a domain but is probably not.
     */
    private boolean isCommonNonDomain(String value) {
        // Common false positives
        String lower = value.toLowerCase();
        return lower.endsWith(".dll") ||
               lower.endsWith(".exe") ||
               lower.endsWith(".sys") ||
               lower.endsWith(".lib") ||
               lower.endsWith(".obj") ||
               lower.endsWith(".pdb") ||
               lower.endsWith(".h") ||
               lower.endsWith(".c") ||
               lower.endsWith(".cpp") ||
               lower.equals("version.rc") ||
               lower.contains("microsoft.com") && lower.contains("schema");
    }

    // ========================================
    // Static Analysis Helpers
    // ========================================

    /**
     * Check if a function name suggests network activity.
     */
    public static boolean suggestsNetworkActivity(String functionName) {
        if (functionName == null) return false;
        String lower = functionName.toLowerCase();
        return lower.contains("socket") ||
               lower.contains("connect") ||
               lower.contains("send") ||
               lower.contains("recv") ||
               lower.contains("http") ||
               lower.contains("download") ||
               lower.contains("upload") ||
               lower.contains("network") ||
               lower.contains("client") ||
               lower.contains("server");
    }

    /**
     * Check if a function name suggests file activity.
     */
    public static boolean suggestsFileActivity(String functionName) {
        if (functionName == null) return false;
        String lower = functionName.toLowerCase();
        return lower.contains("file") ||
               lower.contains("read") ||
               lower.contains("write") ||
               lower.contains("open") ||
               lower.contains("save") ||
               lower.contains("load") ||
               lower.contains("config") ||
               lower.contains("log");
    }

    /**
     * Check if a function name suggests crypto activity.
     */
    public static boolean suggestsCryptoActivity(String functionName) {
        if (functionName == null) return false;
        String lower = functionName.toLowerCase();
        return lower.contains("crypt") ||
               lower.contains("encrypt") ||
               lower.contains("decrypt") ||
               lower.contains("hash") ||
               lower.contains("aes") ||
               lower.contains("rsa") ||
               lower.contains("sha") ||
               lower.contains("md5");
    }
}

```

`src/main/java/ghidrassist/graphrag/extraction/SecurityFeatures.java`:

```java
package ghidrassist.graphrag.extraction;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.*;

/**
 * Container for security-relevant features extracted from a function.
 *
 * Captures:
 * - Network API calls (socket, send, recv, etc.)
 * - File I/O API calls (fopen, fread, fwrite, etc.)
 * - String references (IPs, URLs, file paths, domains)
 * - Activity profile classification
 * - Risk level assessment
 */
public class SecurityFeatures {

    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();

    // API call tracking
    private final Set<String> networkAPIs = new LinkedHashSet<>();
    private final Set<String> fileIOAPIs = new LinkedHashSet<>();
    private final Set<String> cryptoAPIs = new LinkedHashSet<>();
    private final Set<String> processAPIs = new LinkedHashSet<>();

    // Dangerous function tracking (function name -> vulnerability type)
    private final Map<String, String> dangerousFunctions = new LinkedHashMap<>();

    // String reference tracking
    private final Set<String> ipAddresses = new LinkedHashSet<>();
    private final Set<String> urls = new LinkedHashSet<>();
    private final Set<String> filePaths = new LinkedHashSet<>();
    private final Set<String> domains = new LinkedHashSet<>();
    private final Set<String> registryKeys = new LinkedHashSet<>();

    // Computed fields
    private String activityProfile;
    private String riskLevel;

    // ========================================
    // API Call Tracking
    // ========================================

    public void addNetworkAPI(String apiName) {
        if (apiName != null && !apiName.isEmpty()) {
            networkAPIs.add(apiName);
        }
    }

    public void addFileIOAPI(String apiName) {
        if (apiName != null && !apiName.isEmpty()) {
            fileIOAPIs.add(apiName);
        }
    }

    public void addCryptoAPI(String apiName) {
        if (apiName != null && !apiName.isEmpty()) {
            cryptoAPIs.add(apiName);
        }
    }

    public void addProcessAPI(String apiName) {
        if (apiName != null && !apiName.isEmpty()) {
            processAPIs.add(apiName);
        }
    }

    // ========================================
    // Dangerous Function Tracking
    // ========================================

    public void addDangerousFunction(String functionName, String vulnerabilityType) {
        if (functionName != null && !functionName.isEmpty() && vulnerabilityType != null) {
            dangerousFunctions.put(functionName, vulnerabilityType);
        }
    }

    public boolean hasDangerousFunctions() {
        return !dangerousFunctions.isEmpty();
    }

    public Map<String, String> getDangerousFunctions() {
        return Collections.unmodifiableMap(dangerousFunctions);
    }

    /**
     * Get unique vulnerability types from dangerous functions.
     */
    public Set<String> getVulnerabilityTypes() {
        return new LinkedHashSet<>(dangerousFunctions.values());
    }

    // ========================================
    // String Reference Tracking
    // ========================================

    public void addIPAddress(String ip) {
        if (ip != null && !ip.isEmpty()) {
            ipAddresses.add(ip);
        }
    }

    public void addURL(String url) {
        if (url != null && !url.isEmpty()) {
            urls.add(url);
        }
    }

    public void addFilePath(String path) {
        if (path != null && !path.isEmpty()) {
            filePaths.add(path);
        }
    }

    public void addDomain(String domain) {
        if (domain != null && !domain.isEmpty()) {
            domains.add(domain);
        }
    }

    public void addRegistryKey(String key) {
        if (key != null && !key.isEmpty()) {
            registryKeys.add(key);
        }
    }

    // ========================================
    // Query Methods
    // ========================================

    public boolean hasNetworkAPIs() {
        return !networkAPIs.isEmpty();
    }

    public boolean hasFileIOAPIs() {
        return !fileIOAPIs.isEmpty();
    }

    public boolean hasCryptoAPIs() {
        return !cryptoAPIs.isEmpty();
    }

    public boolean hasProcessAPIs() {
        return !processAPIs.isEmpty();
    }

    public boolean hasIPAddresses() {
        return !ipAddresses.isEmpty();
    }

    public boolean hasURLs() {
        return !urls.isEmpty();
    }

    public boolean hasFilePaths() {
        return !filePaths.isEmpty();
    }

    public boolean hasDomains() {
        return !domains.isEmpty();
    }

    public boolean hasRegistryKeys() {
        return !registryKeys.isEmpty();
    }

    public boolean hasSystemPaths() {
        return filePaths.stream().anyMatch(p ->
            p.startsWith("/etc") ||
            p.startsWith("/root") ||
            p.startsWith("/var") ||
            p.toLowerCase().contains("\\windows") ||
            p.toLowerCase().contains("\\system32") ||
            p.toLowerCase().contains("\\programdata")
        );
    }

    public boolean isEmpty() {
        return networkAPIs.isEmpty() && fileIOAPIs.isEmpty() &&
               cryptoAPIs.isEmpty() && processAPIs.isEmpty() &&
               dangerousFunctions.isEmpty() &&
               ipAddresses.isEmpty() && urls.isEmpty() &&
               filePaths.isEmpty() && domains.isEmpty() &&
               registryKeys.isEmpty();
    }

    // ========================================
    // Activity Profile Calculation
    // ========================================

    /**
     * Calculate the activity profile based on detected APIs.
     * Returns a classification like NETWORK_CLIENT, NETWORK_SERVER, FILE_WRITER, etc.
     */
    public void calculateActivityProfile() {
        List<String> profiles = new ArrayList<>();

        // Network patterns
        if (hasNetworkAPIs()) {
            // Server indicators: listen, accept, WSAAccept, AcceptSecurityContext
            boolean hasServerOps = networkAPIs.stream().anyMatch(a -> {
                String lower = a.toLowerCase();
                return lower.equals("listen") || lower.equals("accept") ||
                       lower.equals("wsaaccept") || lower.equals("acceptsecuritycontext") ||
                       lower.contains("_accept");
            });

            // Client connection indicators: connect, WSAConnect*, WinHttpConnect, InternetConnect
            boolean hasClientConnect = networkAPIs.stream().anyMatch(a -> {
                String lower = a.toLowerCase();
                return lower.equals("connect") || lower.startsWith("wsaconnect") ||
                       lower.equals("winhttpconnect") || lower.equals("internetconnect") ||
                       lower.contains("internetconnecta") || lower.contains("internetconnectw") ||
                       lower.equals("ssl_connect");
            });

            // Send/receive indicators
            boolean hasSend = networkAPIs.stream().anyMatch(a -> {
                String lower = a.toLowerCase();
                return lower.contains("send") || lower.contains("wsasend") ||
                       lower.equals("winhttpwritedata") || lower.equals("internetwritefile") ||
                       lower.equals("ssl_write");
            });
            boolean hasRecv = networkAPIs.stream().anyMatch(a -> {
                String lower = a.toLowerCase();
                return lower.contains("recv") || lower.contains("wsarecv") ||
                       lower.equals("winhttpreaddata") || lower.equals("internetreadfile") ||
                       lower.equals("ssl_read");
            });

            // HTTP client indicators
            boolean hasHttpClient = networkAPIs.stream().anyMatch(a -> {
                String lower = a.toLowerCase();
                return lower.contains("httpopen") || lower.contains("httpsend") ||
                       lower.contains("winhttp") || lower.contains("internet") ||
                       lower.contains("curl_");
            });

            // Classify network activity
            if (hasServerOps) {
                profiles.add("NETWORK_SERVER");
            }
            if (hasClientConnect || hasHttpClient) {
                profiles.add("NETWORK_CLIENT");
            }
            if ((hasSend || hasRecv) && !profiles.contains("NETWORK_SERVER") && !profiles.contains("NETWORK_CLIENT")) {
                profiles.add("NETWORK_IO");
            }
        }

        // DNS patterns
        if (hasNetworkAPIs() && networkAPIs.stream().anyMatch(a -> {
            String lower = a.toLowerCase();
            return lower.contains("getaddrinfo") || lower.contains("gethostbyname") ||
                   lower.contains("gethostbyaddr") || lower.contains("getnameinfo") ||
                   lower.contains("gethostname");
        })) {
            profiles.add("DNS_RESOLVER");
        }

        // File I/O patterns
        if (hasFileIOAPIs()) {
            // Read indicators
            boolean hasRead = fileIOAPIs.stream().anyMatch(a -> {
                String lower = a.toLowerCase();
                return lower.equals("read") || lower.equals("pread") ||
                       lower.equals("fread") || lower.equals("fgets") || lower.equals("fgetc") ||
                       lower.equals("getc") || lower.equals("fscanf") ||
                       lower.contains("readfile") || lower.contains("internetreadfile") ||
                       lower.equals("mapviewoffile");
            });

            // Write indicators
            boolean hasWrite = fileIOAPIs.stream().anyMatch(a -> {
                String lower = a.toLowerCase();
                return lower.equals("write") || lower.equals("pwrite") ||
                       lower.equals("fwrite") || lower.equals("fputs") || lower.equals("fputc") ||
                       lower.equals("putc") || lower.equals("fprintf") ||
                       lower.contains("writefile") || lower.contains("internetwritefile") ||
                       lower.contains("copyfile") || lower.contains("movefile");
            });

            // Delete/modify indicators
            boolean hasDelete = fileIOAPIs.stream().anyMatch(a -> {
                String lower = a.toLowerCase();
                return lower.contains("delete") || lower.equals("remove") ||
                       lower.equals("unlink") || lower.contains("removedirectory");
            });

            // Classify file activity
            if (hasRead && hasWrite) {
                profiles.add("FILE_RW");
            } else if (hasWrite) {
                profiles.add("FILE_WRITER");
            } else if (hasRead) {
                profiles.add("FILE_READER");
            }

            if (hasDelete) {
                profiles.add("FILE_DELETER");
            }
        }

        // Crypto patterns
        if (hasCryptoAPIs()) {
            boolean hasEncrypt = cryptoAPIs.stream().anyMatch(a ->
                a.toLowerCase().contains("encrypt"));
            boolean hasDecrypt = cryptoAPIs.stream().anyMatch(a ->
                a.toLowerCase().contains("decrypt"));
            boolean hasHash = cryptoAPIs.stream().anyMatch(a -> {
                String lower = a.toLowerCase();
                return lower.contains("hash") || lower.contains("md5") ||
                       lower.contains("sha1") || lower.contains("sha256") ||
                       lower.contains("digest");
            });

            if (hasEncrypt && hasDecrypt) {
                profiles.add("CRYPTO_CIPHER");
            } else if (hasEncrypt) {
                profiles.add("CRYPTO_ENCRYPT");
            } else if (hasDecrypt) {
                profiles.add("CRYPTO_DECRYPT");
            } else if (hasHash) {
                profiles.add("CRYPTO_HASH");
            } else {
                profiles.add("CRYPTO_USER");
            }
        }

        // Process patterns
        if (hasProcessAPIs()) {
            boolean hasInject = processAPIs.stream().anyMatch(a -> {
                String lower = a.toLowerCase();
                return lower.contains("writeprocessmemory") || lower.contains("createremotethread") ||
                       lower.contains("virtualalloc");
            });

            if (hasInject) {
                profiles.add("PROCESS_INJECTOR");
            } else {
                profiles.add("PROCESS_SPAWNER");
            }
        }

        // Combined patterns indicating potential data exfiltration
        if (hasNetworkAPIs() && hasFileIOAPIs()) {
            profiles.add("MIXED_IO");
        }

        if (profiles.isEmpty()) {
            this.activityProfile = "NONE";
        } else {
            this.activityProfile = String.join(", ", profiles);
        }
    }

    // ========================================
    // Risk Level Calculation
    // ========================================

    /**
     * Calculate risk level based on detected features.
     * Returns LOW, MEDIUM, or HIGH.
     */
    public void calculateRiskLevel() {
        int score = 0;

        // Network indicators
        if (hasNetworkAPIs()) score += 2;
        if (hasIPAddresses()) score += 3;  // Hardcoded IPs = suspicious
        if (hasURLs()) score += 2;
        if (hasDomains()) score += 1;

        // File I/O indicators
        if (hasFileIOAPIs()) score += 1;
        if (hasSystemPaths()) score += 3;  // System paths = suspicious

        // Crypto/process indicators
        if (hasCryptoAPIs()) score += 1;
        if (hasProcessAPIs()) score += 2;

        // Registry access (Windows)
        if (hasRegistryKeys()) score += 2;

        // Dangerous functions (vulnerability risks)
        if (hasDangerousFunctions()) {
            score += 3;  // Any dangerous function is a significant risk
            // Buffer overflow and command injection are especially critical
            Set<String> vulnTypes = getVulnerabilityTypes();
            if (vulnTypes.contains("BUFFER_OVERFLOW_RISK") ||
                vulnTypes.contains("COMMAND_INJECTION_RISK")) {
                score += 2;
            }
        }

        // Combined patterns (exfiltration potential)
        if (hasNetworkAPIs() && hasFileIOAPIs()) {
            score += 2;
        }

        // Network + crypto = potential secure C2
        if (hasNetworkAPIs() && hasCryptoAPIs()) {
            score += 2;
        }

        if (score >= 6) {
            this.riskLevel = "HIGH";
        } else if (score >= 3) {
            this.riskLevel = "MEDIUM";
        } else {
            this.riskLevel = "LOW";
        }
    }

    // ========================================
    // Security Flags Generation
    // ========================================

    /**
     * Generate security flags based on detected features.
     * These flags are stored in the graph_nodes.security_flags field.
     *
     * @return List of security flag strings
     */
    public List<String> generateSecurityFlags() {
        List<String> flags = new ArrayList<>();

        // Activity-based flags
        if (hasNetworkAPIs()) {
            flags.add("NETWORK_CAPABLE");
            String profile = getActivityProfile();
            if (profile != null) {
                if (profile.contains("NETWORK_SERVER")) {
                    flags.add("ACCEPTS_CONNECTIONS");
                }
                if (profile.contains("NETWORK_CLIENT")) {
                    flags.add("INITIATES_CONNECTIONS");
                }
                if (profile.contains("DNS_RESOLVER")) {
                    flags.add("PERFORMS_DNS_LOOKUP");
                }
            }
        }

        if (hasFileIOAPIs()) {
            flags.add("FILE_IO_CAPABLE");
            String profile = getActivityProfile();
            if (profile != null) {
                if (profile.contains("FILE_WRITER") || profile.contains("FILE_RW")) {
                    flags.add("WRITES_FILES");
                }
                if (profile.contains("FILE_READER") || profile.contains("FILE_RW")) {
                    flags.add("READS_FILES");
                }
                if (profile.contains("FILE_DELETER")) {
                    flags.add("DELETES_FILES");
                }
            }
        }

        if (hasCryptoAPIs()) {
            flags.add("USES_CRYPTO");
            String profile = getActivityProfile();
            if (profile != null) {
                if (profile.contains("CRYPTO_ENCRYPT")) {
                    flags.add("ENCRYPTS_DATA");
                }
                if (profile.contains("CRYPTO_DECRYPT")) {
                    flags.add("DECRYPTS_DATA");
                }
            }
        }

        if (hasProcessAPIs()) {
            flags.add("SPAWNS_PROCESSES");
            String profile = getActivityProfile();
            if (profile != null && profile.contains("PROCESS_INJECTOR")) {
                flags.add("PROCESS_INJECTION_CAPABLE");
            }
        }

        // Dangerous function flags (vulnerability indicators)
        if (hasDangerousFunctions()) {
            flags.add("CALLS_DANGEROUS_FUNCTIONS");
            // Add specific vulnerability type flags
            for (String vulnType : getVulnerabilityTypes()) {
                flags.add(vulnType);
            }
        }

        // String reference flags
        if (hasIPAddresses()) {
            flags.add("CONTAINS_HARDCODED_IPS");
        }
        if (hasURLs()) {
            flags.add("CONTAINS_URLS");
        }
        if (hasDomains()) {
            flags.add("CONTAINS_DOMAINS");
        }
        if (hasRegistryKeys()) {
            flags.add("ACCESSES_REGISTRY");
        }
        if (hasSystemPaths()) {
            flags.add("ACCESSES_SYSTEM_PATHS");
        }

        // Combined pattern flags
        if (hasNetworkAPIs() && hasFileIOAPIs()) {
            flags.add("POTENTIAL_DATA_EXFILTRATION");
        }
        if (hasNetworkAPIs() && hasCryptoAPIs()) {
            flags.add("ENCRYPTED_NETWORK_COMMS");
        }
        if (hasNetworkAPIs() && hasDangerousFunctions()) {
            flags.add("NETWORK_WITH_VULN_RISK");
        }

        // Risk level flag
        String risk = getRiskLevel();
        if ("HIGH".equals(risk)) {
            flags.add("HIGH_RISK");
        } else if ("MEDIUM".equals(risk)) {
            flags.add("MEDIUM_RISK");
        }

        return flags;
    }

    // ========================================
    // Getters
    // ========================================

    public Set<String> getNetworkAPIs() {
        return Collections.unmodifiableSet(networkAPIs);
    }

    public Set<String> getFileIOAPIs() {
        return Collections.unmodifiableSet(fileIOAPIs);
    }

    public Set<String> getCryptoAPIs() {
        return Collections.unmodifiableSet(cryptoAPIs);
    }

    public Set<String> getProcessAPIs() {
        return Collections.unmodifiableSet(processAPIs);
    }

    public Set<String> getIPAddresses() {
        return Collections.unmodifiableSet(ipAddresses);
    }

    public Set<String> getURLs() {
        return Collections.unmodifiableSet(urls);
    }

    public Set<String> getFilePaths() {
        return Collections.unmodifiableSet(filePaths);
    }

    public Set<String> getDomains() {
        return Collections.unmodifiableSet(domains);
    }

    public Set<String> getRegistryKeys() {
        return Collections.unmodifiableSet(registryKeys);
    }

    public String getActivityProfile() {
        if (activityProfile == null) {
            calculateActivityProfile();
        }
        return activityProfile;
    }

    public String getRiskLevel() {
        if (riskLevel == null) {
            calculateRiskLevel();
        }
        return riskLevel;
    }

    // ========================================
    // Serialization
    // ========================================

    /**
     * Convert to JSON for tool output.
     */
    public String toJson() {
        try {
            Map<String, Object> map = new LinkedHashMap<>();
            map.put("activity_profile", getActivityProfile());
            map.put("risk_level", getRiskLevel());

            if (!networkAPIs.isEmpty()) {
                map.put("network_apis", new ArrayList<>(networkAPIs));
            }
            if (!fileIOAPIs.isEmpty()) {
                map.put("file_io_apis", new ArrayList<>(fileIOAPIs));
            }
            if (!cryptoAPIs.isEmpty()) {
                map.put("crypto_apis", new ArrayList<>(cryptoAPIs));
            }
            if (!processAPIs.isEmpty()) {
                map.put("process_apis", new ArrayList<>(processAPIs));
            }
            if (!ipAddresses.isEmpty()) {
                map.put("ip_addresses", new ArrayList<>(ipAddresses));
            }
            if (!urls.isEmpty()) {
                map.put("urls", new ArrayList<>(urls));
            }
            if (!filePaths.isEmpty()) {
                map.put("file_paths", new ArrayList<>(filePaths));
            }
            if (!domains.isEmpty()) {
                map.put("domains", new ArrayList<>(domains));
            }
            if (!registryKeys.isEmpty()) {
                map.put("registry_keys", new ArrayList<>(registryKeys));
            }

            return OBJECT_MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(map);
        } catch (JsonProcessingException e) {
            return "{}";
        }
    }

    /**
     * Serialize lists to JSON strings for storage.
     */
    public String serializeNetworkAPIs() {
        return serializeSet(networkAPIs);
    }

    public String serializeFileIOAPIs() {
        return serializeSet(fileIOAPIs);
    }

    public String serializeIPAddresses() {
        return serializeSet(ipAddresses);
    }

    public String serializeURLs() {
        return serializeSet(urls);
    }

    public String serializeFilePaths() {
        return serializeSet(filePaths);
    }

    public String serializeDomains() {
        return serializeSet(domains);
    }

    private String serializeSet(Set<String> set) {
        if (set == null || set.isEmpty()) {
            return "[]";
        }
        try {
            return OBJECT_MAPPER.writeValueAsString(new ArrayList<>(set));
        } catch (JsonProcessingException e) {
            return "[]";
        }
    }

    @Override
    public String toString() {
        return String.format("SecurityFeatures[profile=%s, risk=%s, netAPIs=%d, fileAPIs=%d, ips=%d, urls=%d, paths=%d]",
            getActivityProfile(), getRiskLevel(),
            networkAPIs.size(), fileIOAPIs.size(),
            ipAddresses.size(), urls.size(), filePaths.size());
    }
}

```

`src/main/java/ghidrassist/graphrag/extraction/SemanticExtractor.java`:

```java
package ghidrassist.graphrag.extraction;

import ghidra.util.Msg;

import ghidrassist.apiprovider.APIProvider;
import ghidrassist.apiprovider.ChatMessage;
import ghidrassist.apiprovider.exceptions.APIProviderException;
import ghidrassist.graphrag.BinaryKnowledgeGraph;
import ghidrassist.graphrag.nodes.KnowledgeNode;
import ghidrassist.graphrag.nodes.NodeType;
import ghidrassist.LlmApi;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * LLM-powered semantic extraction for the knowledge graph.
 *
 * Handles:
 * - Function summarization with security focus
 * - Batch processing with rate limiting
 * - Embedding generation (when available)
 * - Module/community summarization
 *
 * Uses a tiered approach:
 * 1. If embeddings are available, generate them
 * 2. Generate LLM summaries in batches
 * 3. Track progress and allow cancellation
 */
@SuppressWarnings("deprecation")  // Uses legacy extractSecurityNotes() for backward compatibility
public class SemanticExtractor {

    private final APIProvider provider;
    private final BinaryKnowledgeGraph graph;
    @SuppressWarnings("unused")  // Reserved for future multi-binary support
    private final String binaryId;

    // Parallel processing workers
    private static final int PARALLEL_WORKERS = 3;

    // Rate limiting (legacy - kept for compatibility)
    private static final int DEFAULT_BATCH_SIZE = 5;
    private static final long DEFAULT_DELAY_MS = 500;
    @SuppressWarnings("unused")  // Legacy field kept for API compatibility
    private int batchSize;
    @SuppressWarnings("unused")  // Legacy field kept for API compatibility
    private long delayBetweenBatches;

    // Thread-safe statistics
    private AtomicInteger summarized = new AtomicInteger(0);
    private AtomicInteger embeddingsGenerated = new AtomicInteger(0);
    private AtomicInteger errors = new AtomicInteger(0);
    private AtomicInteger processed = new AtomicInteger(0);

    // Cancellation
    private volatile boolean cancelled = false;
    private ExecutorService executor;

    /**
     * Create a SemanticExtractor.
     *
     * @param provider LLM provider for summarization
     * @param graph    Knowledge graph to update
     */
    public SemanticExtractor(APIProvider provider, BinaryKnowledgeGraph graph) {
        this.provider = provider;
        this.graph = graph;
        this.binaryId = graph.getBinaryId();
        this.batchSize = DEFAULT_BATCH_SIZE;
        this.delayBetweenBatches = DEFAULT_DELAY_MS;
    }

    /**
     * Configure batch processing parameters.
     */
    public void setBatchConfig(int batchSize, long delayMs) {
        this.batchSize = Math.max(1, batchSize);
        this.delayBetweenBatches = Math.max(0, delayMs);
    }

    /**
     * Process all stale nodes that need summarization.
     *
     * @param limit Maximum number of nodes to process (0 = unlimited)
     * @param progressCallback Optional callback for progress updates
     * @return ExtractionResult with statistics
     */
    public ExtractionResult summarizeStaleNodes(int limit, ProgressCallback progressCallback) {
        long startTime = System.currentTimeMillis();
        cancelled = false;
        summarized.set(0);
        embeddingsGenerated.set(0);
        errors.set(0);
        processed.set(0);

        // Get stale nodes
        List<KnowledgeNode> staleNodes = graph.getStaleNodes(limit > 0 ? limit : Integer.MAX_VALUE);
        int total = staleNodes.size();

        if (total == 0) {
            Msg.info(this, "No stale nodes to summarize");
            return new ExtractionResult(0, 0, 0, 0);
        }

        Msg.info(this, "Starting summarization of " + total + " stale nodes");

        // Log first few node addresses for debugging
        if (total > 0) {
            StringBuilder firstNodes = new StringBuilder("First 10 nodes to process: ");
            for (int i = 0; i < Math.min(10, total); i++) {
                KnowledgeNode n = staleNodes.get(i);
                firstNodes.append(String.format("%s(0x%s) ",
                    n.getName(),
                    n.getAddress() != null ? Long.toHexString(n.getAddress()) : "EXT"));
            }
            Msg.info(this, firstNodes.toString());
        }

        // Process nodes with parallel workers
        Msg.info(this, "Using " + PARALLEL_WORKERS + " parallel workers");
        ExecutorService executor = Executors.newFixedThreadPool(PARALLEL_WORKERS);

        // Track active futures for cancellation
        List<Future<?>> activeFutures = new ArrayList<>();
        int submitted = 0;

        try {
            for (KnowledgeNode node : staleNodes) {
                // Check for cancellation before submitting new work
                if (cancelled) {
                    Msg.info(this, "Cancellation requested, stopping submission after " + submitted + " tasks");
                    break;
                }

                final KnowledgeNode nodeToProcess = node;
                Future<?> future = executor.submit(() -> {
                    try {
                        if (nodeToProcess.getType() == NodeType.FUNCTION) {
                            processSingleFunctionParallel(nodeToProcess);
                        } else {
                            // Log non-function nodes for debugging
                            Msg.info(this, "Processing non-FUNCTION node: " + nodeToProcess.getName() +
                                " (type=" + nodeToProcess.getType() + ", addr=" +
                                (nodeToProcess.getAddress() != null ? "0x" + Long.toHexString(nodeToProcess.getAddress()) : "null") + ")");
                            processOtherNodeParallel(nodeToProcess);
                        }
                    } catch (Exception e) {
                        Msg.warn(this, "Error processing node " + nodeToProcess.getName() + ": " + e.getMessage());
                        errors.incrementAndGet();
                    } finally {
                        // Update progress
                        int currentProcessed = processed.incrementAndGet();
                        if (progressCallback != null) {
                            progressCallback.onProgress(currentProcessed, total, summarized.get(), errors.get());
                        }
                    }
                });
                activeFutures.add(future);
                submitted++;

                // Limit outstanding tasks to avoid memory issues
                // Wait for some tasks to complete if we have too many pending
                while (activeFutures.size() >= PARALLEL_WORKERS * 2 && !cancelled) {
                    // Remove completed futures
                    activeFutures.removeIf(Future::isDone);
                    if (activeFutures.size() >= PARALLEL_WORKERS * 2) {
                        Thread.sleep(100);
                    }
                }
            }

            // Wait for remaining tasks to complete
            Msg.info(this, "Waiting for " + activeFutures.size() + " remaining tasks to complete...");
            while (!activeFutures.isEmpty() && !cancelled) {
                activeFutures.removeIf(Future::isDone);
                if (!activeFutures.isEmpty()) {
                    Thread.sleep(100);
                }
            }

            if (cancelled) {
                Msg.info(this, "Cancellation detected, cancelling remaining futures");
                for (Future<?> f : activeFutures) {
                    f.cancel(true);
                }
            }
        } catch (InterruptedException e) {
            Msg.warn(this, "Interrupted during processing: " + e.getMessage());
            Thread.currentThread().interrupt();
        } finally {
            executor.shutdownNow();
            try {
                executor.awaitTermination(5, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        long elapsed = System.currentTimeMillis() - startTime;
        Msg.info(this, String.format("Parallel semantic extraction completed in %dms: %d summarized, %d embeddings, %d errors",
                elapsed, summarized.get(), embeddingsGenerated.get(), errors.get()));

        return new ExtractionResult(summarized.get(), embeddingsGenerated.get(), errors.get(), elapsed);
    }

    /**
     * Summarize a single node on-demand.
     * For FUNCTION nodes, uses the full detailed prompt with context.
     */
    public boolean summarizeNode(KnowledgeNode node) {
        Msg.info(this, "summarizeNode called for: " + (node != null ? node.getName() : "null"));

        if (node == null) {
            Msg.warn(this, "summarizeNode: node is null");
            return false;
        }
        if (node.getRawContent() == null || node.getRawContent().isEmpty()) {
            Msg.warn(this, "summarizeNode: rawContent is null or empty for node " + node.getName());
            return false;
        }

        Msg.info(this, "summarizeNode: rawContent length = " + node.getRawContent().length());

        try {
            String response;

            // For FUNCTION nodes, use the full detailed prompt with context
            if (node.getType() == NodeType.FUNCTION) {
                // Get context (callers/callees) if graph is available
                List<String> callers = new ArrayList<>();
                List<String> callees = new ArrayList<>();

                if (graph != null) {
                    callers = graph.getCallers(node.getId()).stream()
                            .map(n -> n.getName() != null ? n.getName() : "unknown")
                            .limit(5)
                            .collect(Collectors.toList());

                    callees = graph.getCallees(node.getId()).stream()
                            .map(n -> n.getName() != null ? n.getName() : "unknown")
                            .limit(5)
                            .collect(Collectors.toList());
                }

                // Generate full detailed prompt
                String prompt = ExtractionPrompts.functionSummaryPrompt(
                        node.getName() != null ? node.getName() : "unknown",
                        node.getRawContent(),
                        callers,
                        callees
                );

                Msg.info(this, "summarizeNode: calling LLM with detailed function prompt...");
                response = callLLM(prompt);

                if (response != null && !response.isEmpty()) {
                    node.setLlmSummary(response);
                    node.setConfidence(0.85f);

                    // Extract security flags if present (supports both old and new format)
                    String security = ExtractionPrompts.extractSecurity(response);
                    if (security == null) {
                        security = ExtractionPrompts.extractSecurityNotes(response);
                    }
                    if (security != null && !security.toLowerCase().contains("none") &&
                        !security.toLowerCase().contains("no security") &&
                        !security.toLowerCase().contains("not applicable")) {
                        node.addSecurityFlag("LLM_FLAGGED");
                    }

                    // Extract and store category if present
                    String category = ExtractionPrompts.extractCategory(response);
                    if (category != null && !category.isEmpty()) {
                        node.addSecurityFlag("CATEGORY_" + category.toUpperCase().replace(" ", "_"));
                    }
                }
            } else {
                // For non-FUNCTION nodes, use the generic summary
                Msg.info(this, "summarizeNode: calling generateSummary for non-function node...");
                response = generateSummary(node);

                if (response != null && !response.isEmpty()) {
                    node.setLlmSummary(response);
                    node.setConfidence(0.7f);
                }
            }

            Msg.info(this, "summarizeNode: LLM returned " +
                    (response != null ? response.length() + " chars" : "null"));

            if (response != null && !response.isEmpty()) {
                node.markUpdated();

                // Try to generate embedding
                tryGenerateEmbedding(node);

                graph.upsertNode(node);
                Msg.info(this, "summarizeNode: success");
                return true;
            } else {
                Msg.warn(this, "summarizeNode: LLM returned null or empty response");
            }
        } catch (Exception e) {
            Msg.error(this, "Failed to summarize node " + node.getId() + ": " + e.getMessage(), e);
        }
        return false;
    }

    /**
     * Cancel ongoing extraction.
     */
    public void cancel() {
        cancelled = true;
        if (executor != null) {
            executor.shutdownNow();
        }
    }

    // ========================================
    // Parallel Processing Methods (thread-safe)
    // ========================================

    /**
     * Process a single function in parallel (thread-safe version).
     */
    private void processSingleFunctionParallel(KnowledgeNode node) {
        try {
            // Skip external functions - they have no function body to summarize
            if (node.getAddress() == null) {
                Msg.info(this, "Skipping external function (no body): " + node.getName());
                return;
            }

            // Skip functions without raw content
            if (node.getRawContent() == null || node.getRawContent().isEmpty()) {
                Msg.info(this, "Skipping function with no raw content: " + node.getName() +
                    " (addr=0x" + Long.toHexString(node.getAddress()) + ")");
                return;
            }

            Msg.info(this, "Processing function: " + node.getName() + " (id=" + node.getId() + ")");

            // Get context (callers/callees)
            List<String> callers = graph.getCallers(node.getId()).stream()
                    .map(n -> n.getName() != null ? n.getName() : "unknown")
                    .limit(5)
                    .collect(Collectors.toList());

            List<String> callees = graph.getCallees(node.getId()).stream()
                    .map(n -> n.getName() != null ? n.getName() : "unknown")
                    .limit(5)
                    .collect(Collectors.toList());

            // Generate prompt
            String prompt = ExtractionPrompts.functionSummaryPrompt(
                    node.getName() != null ? node.getName() : "unknown",
                    node.getRawContent(),
                    callers,
                    callees
            );

            String response = callLLM(prompt);
            if (response != null && !response.isEmpty()) {
                Msg.info(this, "Got response for " + node.getName() + ", length=" + response.length());
                node.setLlmSummary(response);
                node.setConfidence(0.85f);

                // Extract security flags if present
                String security = ExtractionPrompts.extractSecurity(response);
                if (security == null) {
                    security = ExtractionPrompts.extractSecurityNotes(response);
                }
                if (security != null && !security.toLowerCase().contains("none") &&
                    !security.toLowerCase().contains("no security") &&
                    !security.toLowerCase().contains("not applicable")) {
                    node.addSecurityFlag("LLM_FLAGGED");
                }

                // Extract and store category if present
                String category = ExtractionPrompts.extractCategory(response);
                if (category != null && !category.isEmpty()) {
                    node.addSecurityFlag("CATEGORY_" + category.toUpperCase().replace(" ", "_"));
                }

                node.markUpdated();
                node.setStale(false);
                tryGenerateEmbedding(node);

                Msg.info(this, "Upserting node " + node.getName() + " with summary length=" +
                    (node.getLlmSummary() != null ? node.getLlmSummary().length() : 0));
                graph.upsertNode(node);

                int count = summarized.incrementAndGet();
                Msg.info(this, "Successfully summarized " + node.getName() + " (total: " + count + ")");
            } else {
                Msg.warn(this, "Empty response for " + node.getName());
            }
        } catch (Exception e) {
            Msg.error(this, "Failed to summarize function " + node.getName() + ": " + e.getMessage(), e);
            errors.incrementAndGet();
        }
    }

    /**
     * Process a non-function node in parallel (thread-safe version).
     */
    private void processOtherNodeParallel(KnowledgeNode node) {
        try {
            String summary = generateSummary(node);
            if (summary != null) {
                node.setLlmSummary(summary);
                node.setConfidence(0.7f);
                node.markUpdated();
                tryGenerateEmbedding(node);
                graph.upsertNode(node);
                summarized.incrementAndGet();
            }
        } catch (Exception e) {
            Msg.warn(this, "Failed to summarize node " + node.getId() + ": " + e.getMessage());
            errors.incrementAndGet();
        }
    }

    // ========================================
    // Batch Processing (legacy - kept for compatibility)
    // ========================================

    private void processBatch(List<KnowledgeNode> batch) {
        // Separate by type for appropriate prompts
        List<KnowledgeNode> functions = batch.stream()
                .filter(n -> n.getType() == NodeType.FUNCTION)
                .collect(Collectors.toList());

        List<KnowledgeNode> others = batch.stream()
                .filter(n -> n.getType() != NodeType.FUNCTION)
                .collect(Collectors.toList());

        // Process functions (most common case)
        if (!functions.isEmpty()) {
            processFunctionBatch(functions);
        }

        // Process other node types individually
        for (KnowledgeNode node : others) {
            if (cancelled) break;
            processOtherNode(node);
        }
    }

    private void processFunctionBatch(List<KnowledgeNode> functions) {
        // Process ALL functions individually with the detailed prompt
        // This ensures consistent, high-quality summaries with caller/callee context
        // for both simple and complex functions (same as Explain Function)
        for (KnowledgeNode func : functions) {
            if (cancelled) break;
            processSingleFunction(func);
        }
    }

    private void processSingleFunction(KnowledgeNode node) {
        try {
            // Skip external functions - they have no function body to summarize
            if (node.getAddress() == null) {
                return;
            }

            // Skip functions without raw content
            if (node.getRawContent() == null || node.getRawContent().isEmpty()) {
                return;
            }

            // Get context (callers/callees)
            List<String> callers = graph.getCallers(node.getId()).stream()
                    .map(n -> n.getName() != null ? n.getName() : "unknown")
                    .limit(5)
                    .collect(Collectors.toList());

            List<String> callees = graph.getCallees(node.getId()).stream()
                    .map(n -> n.getName() != null ? n.getName() : "unknown")
                    .limit(5)
                    .collect(Collectors.toList());

            // Generate prompt
            String prompt = ExtractionPrompts.functionSummaryPrompt(
                    node.getName() != null ? node.getName() : "unknown",
                    node.getRawContent(),
                    callers,
                    callees
            );

            String response = callLLM(prompt);
            if (response != null) {
                node.setLlmSummary(response);
                node.setConfidence(0.85f);

                // Extract security flags if present (supports both old and new format)
                String security = ExtractionPrompts.extractSecurity(response);
                if (security == null) {
                    // Fall back to legacy format
                    security = ExtractionPrompts.extractSecurityNotes(response);
                }
                if (security != null && !security.toLowerCase().contains("none") &&
                    !security.toLowerCase().contains("no security") &&
                    !security.toLowerCase().contains("not applicable")) {
                    node.addSecurityFlag("LLM_FLAGGED");
                }

                // Extract and store category if present
                String category = ExtractionPrompts.extractCategory(response);
                if (category != null && !category.isEmpty()) {
                    // Store category as a security flag for searchability
                    node.addSecurityFlag("CATEGORY_" + category.toUpperCase().replace(" ", "_"));
                }

                node.markUpdated();
                tryGenerateEmbedding(node);
                graph.upsertNode(node);
                summarized.incrementAndGet();
            }
        } catch (Exception e) {
            Msg.warn(this, "Failed to summarize function " + node.getName() + ": " + e.getMessage());
            errors.incrementAndGet();
        }
    }

    private void processOtherNode(KnowledgeNode node) {
        try {
            String summary = generateSummary(node);
            if (summary != null) {
                node.setLlmSummary(summary);
                node.setConfidence(0.7f);
                node.markUpdated();
                tryGenerateEmbedding(node);
                graph.upsertNode(node);
                summarized.incrementAndGet();
            }
        } catch (Exception e) {
            Msg.warn(this, "Failed to summarize node " + node.getId() + ": " + e.getMessage());
            errors.incrementAndGet();
        }
    }

    private void parseBatchResponse(String response, List<KnowledgeNode> functions) {
        // Parse numbered list response
        String[] lines = response.split("\n");
        int index = 0;

        for (String line : lines) {
            line = line.trim();
            if (line.isEmpty()) continue;

            // Match numbered lines like "1. Summary text" or "1) Summary text"
            if (line.matches("^\\d+[.)].*")) {
                // Extract summary after number
                int pos = line.indexOf(' ');
                if (pos > 0 && index < functions.size()) {
                    String summary = line.substring(pos).trim();
                    if (!summary.isEmpty()) {
                        KnowledgeNode node = functions.get(index);
                        node.setLlmSummary(summary);
                        node.setConfidence(0.75f);
                        node.markUpdated();
                        graph.upsertNode(node);
                        summarized.incrementAndGet();
                    }
                    index++;
                }
            }
        }

        // Log if we didn't match all functions
        if (index < functions.size()) {
            Msg.warn(this, "Batch response only matched " + index + " of " + functions.size() + " functions");
        }
    }

    // ========================================
    // LLM and Embedding Helpers
    // ========================================

    private String generateSummary(KnowledgeNode node) {
        if (node.getRawContent() == null || node.getRawContent().isEmpty()) {
            return null;
        }

        String prompt;
        switch (node.getType()) {
            case FUNCTION:
                prompt = ExtractionPrompts.functionBriefSummaryPrompt(
                        node.getName() != null ? node.getName() : "unknown",
                        node.getRawContent()
                );
                break;
            case BINARY:
                prompt = "Summarize this binary in 2-3 sentences:\n\n" + node.getRawContent();
                break;
            case MODULE:
                prompt = "Summarize this module/component in 1-2 sentences:\n\n" + node.getRawContent();
                break;
            default:
                prompt = "Briefly describe this code:\n\n" + truncate(node.getRawContent(), 1000);
        }

        return callLLM(prompt);
    }

    private String callLLM(String prompt) {
        if (provider == null) {
            Msg.warn(this, "callLLM: No LLM provider available for summarization");
            return null;
        }

        Msg.info(this, "callLLM: calling provider " + provider.getClass().getSimpleName() +
                " with prompt length " + prompt.length());

        try {
            List<ChatMessage> messages = new ArrayList<>();
            messages.add(new ChatMessage("system",
                    "You are a binary analysis assistant. Provide concise, technical summaries focused on functionality and security."));
            messages.add(new ChatMessage("user", prompt));

            String response = provider.createChatCompletion(messages);
            Msg.info(this, "callLLM: received response " +
                    (response != null ? response.length() + " chars" : "null"));
            return response;
        } catch (APIProviderException e) {
            Msg.error(this, "callLLM failed: " + e.getMessage(), e);
            return null;
        }
    }

    private void tryGenerateEmbedding(KnowledgeNode node) {
        if (provider == null || node.getLlmSummary() == null) {
            return;
        }

        try {
            double[] embedding = provider.getEmbeddings(node.getLlmSummary());
            if (embedding != null && embedding.length > 0) {
                // Convert double[] to float[]
                float[] floatEmbedding = new float[embedding.length];
                for (int i = 0; i < embedding.length; i++) {
                    floatEmbedding[i] = (float) embedding[i];
                }
                node.setEmbedding(floatEmbedding);
                embeddingsGenerated.incrementAndGet();
            }
        } catch (Exception e) {
            // Embeddings are optional - don't log as error
            Msg.debug(this, "Embedding generation not available: " + e.getMessage());
        }
    }

    private String truncate(String text, int maxLength) {
        if (text == null || text.length() <= maxLength) {
            return text;
        }
        return text.substring(0, maxLength) + "...";
    }

    // ========================================
    // Result and Callback Types
    // ========================================

    /**
     * Results from semantic extraction.
     */
    public static class ExtractionResult {
        public final int summarized;
        public final int embeddingsGenerated;
        public final int errors;
        public final long elapsedMs;

        public ExtractionResult(int summarized, int embeddings, int errors, long elapsed) {
            this.summarized = summarized;
            this.embeddingsGenerated = embeddings;
            this.errors = errors;
            this.elapsedMs = elapsed;
        }

        @Override
        public String toString() {
            return String.format("Summarized %d nodes, %d embeddings, %d errors in %dms",
                    summarized, embeddingsGenerated, errors, elapsedMs);
        }
    }

    /**
     * Callback for progress updates.
     */
    public interface ProgressCallback {
        void onProgress(int processed, int total, int summarized, int errors);
    }

    // ========================================
    // Streaming Summary Support
    // ========================================

    /**
     * Callback interface for streaming summary updates.
     */
    public interface StreamingSummaryCallback {
        /**
         * Called when streaming starts.
         */
        void onStart();

        /**
         * Called when a partial summary is available.
         * @param accumulated The accumulated response so far
         */
        void onPartialSummary(String accumulated);

        /**
         * Called when the summary is complete.
         * @param fullSummary The complete summary
         * @param updatedNode The node with updated summary and metadata
         */
        void onSummaryComplete(String fullSummary, KnowledgeNode updatedNode);

        /**
         * Called when an error occurs.
         * @param error The error that occurred
         */
        void onError(Throwable error);

        /**
         * Check if streaming should continue.
         * @return true to continue, false to cancel
         */
        default boolean shouldContinue() { return true; }
    }

    /**
     * Summarize a node with streaming updates.
     * Similar to summarizeNode() but calls callback as text arrives.
     *
     * @param node The knowledge node to summarize (must be a FUNCTION node)
     * @param callback The callback to receive streaming updates
     */
    public void summarizeNodeStreaming(KnowledgeNode node, StreamingSummaryCallback callback) {
        if (node == null) {
            callback.onError(new IllegalArgumentException("Node cannot be null"));
            return;
        }

        if (node.getType() != NodeType.FUNCTION) {
            callback.onError(new IllegalArgumentException("Only FUNCTION nodes are supported for streaming summarization"));
            return;
        }

        if (node.getRawContent() == null || node.getRawContent().isEmpty()) {
            callback.onError(new IllegalArgumentException("Node has no raw content to summarize"));
            return;
        }

        // Get context (callers/callees) if graph is available
        List<String> callers = new ArrayList<>();
        List<String> callees = new ArrayList<>();

        if (graph != null) {
            callers = graph.getCallers(node.getId()).stream()
                    .map(n -> n.getName() != null ? n.getName() : "unknown")
                    .limit(5)
                    .collect(Collectors.toList());

            callees = graph.getCallees(node.getId()).stream()
                    .map(n -> n.getName() != null ? n.getName() : "unknown")
                    .limit(5)
                    .collect(Collectors.toList());
        }

        // Generate full detailed prompt
        String prompt = ExtractionPrompts.functionSummaryPrompt(
                node.getName() != null ? node.getName() : "unknown",
                node.getRawContent(),
                callers,
                callees
        );

        callback.onStart();

        // Use streaming LLM call
        callLLMStreaming(prompt, new LlmApi.LlmResponseHandler() {
            // Track accumulated content for streaming updates
            private final StringBuilder accumulated = new StringBuilder();
            // Safe accumulator that never resets - used for final storage
            private final StringBuilder safeAccumulated = new StringBuilder();

            @Override
            public void onStart() {
                // Already called callback.onStart() above
            }

            @Override
            public void onUpdate(String partialResponse) {
                // Extract delta from cumulative response
                String current = accumulated.toString();
                String delta;
                if (partialResponse.startsWith(current)) {
                    delta = partialResponse.substring(current.length());
                    accumulated.append(delta);
                } else {
                    // If provider gives full response each time
                    delta = partialResponse;
                    accumulated.setLength(0);
                    accumulated.append(partialResponse);
                }

                // Always append delta to safe accumulator (never reset)
                if (!delta.isEmpty()) {
                    safeAccumulated.append(delta);
                }

                if (!accumulated.toString().isEmpty()) {
                    callback.onPartialSummary(accumulated.toString());
                }
            }

            @Override
            public void onComplete(String fullResponse) {
                // Prefer fullResponse from provider, then safeAccumulated, then accumulated
                String finalResponse;
                if (fullResponse != null && !fullResponse.isEmpty()) {
                    finalResponse = fullResponse;
                } else if (safeAccumulated.length() > 0) {
                    finalResponse = safeAccumulated.toString();
                } else {
                    finalResponse = accumulated.toString();
                }

                // Update node with response
                extractAndUpdateNode(node, finalResponse);
                node.markUpdated();

                // Try to generate embedding
                tryGenerateEmbedding(node);

                // Save to graph
                graph.upsertNode(node);

                callback.onSummaryComplete(finalResponse, node);
            }

            @Override
            public void onError(Throwable error) {
                callback.onError(error);
            }

            @Override
            public boolean shouldContinue() {
                return callback.shouldContinue();
            }
        });
    }

    /**
     * Make a streaming LLM call.
     *
     * @param prompt The prompt to send
     * @param handler The handler for streaming responses
     */
    private void callLLMStreaming(String prompt, LlmApi.LlmResponseHandler handler) {
        if (provider == null) {
            handler.onError(new IllegalStateException("No LLM provider available for summarization"));
            return;
        }

        try {
            List<ChatMessage> messages = new ArrayList<>();
            messages.add(new ChatMessage("system",
                    "You are a binary analysis assistant. Provide concise, technical summaries focused on functionality and security."));
            messages.add(new ChatMessage("user", prompt));

            // Use streaming API
            provider.streamChatCompletion(messages, handler);
        } catch (APIProviderException e) {
            handler.onError(e);
        }
    }

    /**
     * Extract metadata from LLM response and update node.
     * Common logic shared between summarizeNode() and summarizeNodeStreaming().
     *
     * @param node The node to update
     * @param response The LLM response
     */
    private void extractAndUpdateNode(KnowledgeNode node, String response) {
        if (response == null || response.isEmpty()) {
            return;
        }

        node.setLlmSummary(response);
        node.setConfidence(0.85f);

        // Extract security flags if present (supports both old and new format)
        String security = ExtractionPrompts.extractSecurity(response);
        if (security == null) {
            security = ExtractionPrompts.extractSecurityNotes(response);
        }
        if (security != null && !security.toLowerCase().contains("none") &&
            !security.toLowerCase().contains("no security") &&
            !security.toLowerCase().contains("not applicable")) {
            node.addSecurityFlag("LLM_FLAGGED");
        }

        // Extract and store category if present
        String category = ExtractionPrompts.extractCategory(response);
        if (category != null && !category.isEmpty()) {
            node.addSecurityFlag("CATEGORY_" + category.toUpperCase().replace(" ", "_"));
        }
    }
}

```

`src/main/java/ghidrassist/graphrag/extraction/StructureExtractor.java`:

```java
package ghidrassist.graphrag.extraction;

import ghidra.app.decompiler.DecompInterface;
import ghidra.app.decompiler.DecompileResults;
import ghidra.app.decompiler.DecompiledFunction;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressIterator;
import ghidra.program.model.block.CodeBlock;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.FunctionIterator;
import ghidra.program.model.listing.FunctionManager;
import ghidra.program.model.listing.Instruction;
import ghidra.program.model.listing.InstructionIterator;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Reference;
import ghidra.program.model.symbol.ReferenceManager;
import ghidra.program.model.symbol.Symbol;
import ghidra.program.model.symbol.SymbolTable;
import ghidra.program.model.address.AddressSetView;
import ghidra.program.model.mem.MemoryBlock;
import ghidra.util.Msg;
import ghidra.util.task.TaskMonitor;

import ghidrassist.graphrag.BinaryKnowledgeGraph;
import ghidrassist.graphrag.nodes.EdgeType;
import ghidrassist.graphrag.nodes.KnowledgeNode;
import ghidrassist.graphrag.nodes.NodeType;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Extracts structural information from Ghidra binaries and populates the knowledge graph.
 *
 * This extractor handles:
 * - Function enumeration and decompilation caching
 * - Call graph extraction (CALLS edges)
 * - Basic block extraction (optional, for BLOCK nodes)
 * - Cross-reference extraction (REFERENCES edges)
 *
 * This is a "fast" extractor that doesn't use LLM - just Ghidra analysis data.
 * LLM summarization is handled separately by SemanticExtractor.
 */
public class StructureExtractor {

    private final Program program;
    private final BinaryKnowledgeGraph graph;
    private final String binaryId;
    private final TaskMonitor monitor;

    // Statistics (thread-safe)
    private final AtomicInteger functionsExtracted = new AtomicInteger(0);
    private final AtomicInteger callEdgesCreated = new AtomicInteger(0);
    private final AtomicInteger refEdgesCreated = new AtomicInteger(0);
    private final AtomicInteger vulnEdgesCreated = new AtomicInteger(0);

    // Decompiler instance (reused for efficiency) - only for single-threaded operations
    private DecompInterface decompiler;

    // Thread pool for parallel extraction (limited to avoid diminishing returns)
    private static final int DEFAULT_THREAD_COUNT = Math.max(2, Runtime.getRuntime().availableProcessors() / 2);
    private ExecutorService extractorPool;

    // Thread-local decompilers for parallel extraction
    private final ConcurrentHashMap<Long, DecompInterface> threadDecompilers = new ConcurrentHashMap<>();

    // Decompilation retry settings
    private static final int DECOMPILE_BASE_TIMEOUT = 30;  // seconds
    private static final int DECOMPILE_MAX_RETRIES = 3;

    // Incremental mode: when true, preserves existing semantic data (summaries, embeddings, flags)
    private boolean incrementalMode = false;

    /**
     * Create a StructureExtractor for a program.
     *
     * @param program The Ghidra program to extract from
     * @param graph   The knowledge graph to populate
     * @param monitor Task monitor for progress/cancellation
     */
    public StructureExtractor(Program program, BinaryKnowledgeGraph graph, TaskMonitor monitor) {
        this.program = program;
        this.graph = graph;
        this.binaryId = graph.getBinaryId();
        this.monitor = monitor;
    }

    /**
     * Set incremental mode for non-destructive reindexing.
     *
     * When enabled:
     * - Existing semantic data (summaries, embeddings, flags) is preserved via COALESCE
     * - Only structural data (names, addresses, edges) is updated
     * - Nodes are marked stale only if content actually changed
     *
     * @param incremental true to enable incremental mode
     */
    public void setIncrementalMode(boolean incremental) {
        this.incrementalMode = incremental;
        if (incremental) {
            Msg.info(this, "StructureExtractor: incremental mode enabled (preserving semantic data)");
        }
    }

    /**
     * Check if incremental mode is enabled.
     */
    public boolean isIncrementalMode() {
        return incrementalMode;
    }

    /**
     * Extract all functions and their relationships.
     * This is the main entry point for graph population.
     *
     * @param includeBlocks Whether to also extract basic blocks (increases graph size)
     * @return ExtractionResult with statistics
     */
    public ExtractionResult extractAll(boolean includeBlocks) {
        long startTime = System.currentTimeMillis();

        try {
            // Initialize decompiler
            decompiler = new DecompInterface();
            decompiler.openProgram(program);

            // Phase 1: Extract all functions as nodes AND their edges
            // Note: extractFunction() also extracts CALLS, REFERENCES, and
            // CALLS_VULNERABLE edges for each function, so we don't need separate bulk phases
            monitor.setMessage("Extracting functions and edges...");
            extractFunctions();

            // Check for cancellation between phases
            if (monitor.isCancelled()) {
                Msg.info(this, "Extraction cancelled after function extraction");
                return new ExtractionResult(functionsExtracted.get(), callEdgesCreated.get(),
                        refEdgesCreated.get(), vulnEdgesCreated.get(),
                        System.currentTimeMillis() - startTime);
            }

            // Phase 2: Create binary-level node
            monitor.setMessage("Creating binary summary node...");
            createBinaryNode();

            if (monitor.isCancelled()) {
                Msg.info(this, "Extraction cancelled after binary node creation");
                return new ExtractionResult(functionsExtracted.get(), callEdgesCreated.get(),
                        refEdgesCreated.get(), vulnEdgesCreated.get(),
                        System.currentTimeMillis() - startTime);
            }

            // Phase 4: Detect communities
            monitor.setMessage("Detecting function communities...");
            detectCommunities();

        } finally {
            if (decompiler != null) {
                decompiler.dispose();
                decompiler = null;
            }
        }

        long elapsed = System.currentTimeMillis() - startTime;
        Msg.info(this, String.format("Structure extraction completed in %dms: %d functions, %d call edges, %d ref edges, %d vuln edges",
                elapsed, functionsExtracted.get(), callEdgesCreated.get(), refEdgesCreated.get(), vulnEdgesCreated.get()));

        return new ExtractionResult(functionsExtracted.get(), callEdgesCreated.get(), refEdgesCreated.get(), vulnEdgesCreated.get(), elapsed);
    }

    /**
     * Extract a single function and its immediate relationships.
     * Used for incremental updates when a new function is discovered.
     *
     * @param function The function to extract
     * @return The created KnowledgeNode, or null on failure
     */
    public KnowledgeNode extractFunction(Function function) {
        if (function == null || function.isThunk()) {
            return null;
        }

        try {
            if (decompiler == null) {
                decompiler = new DecompInterface();
                decompiler.openProgram(program);
            }

            // Check if already cached
            KnowledgeNode existing = graph.getNodeByAddress(function.getEntryPoint().getOffset());
            if (existing != null && existing.getRawContent() != null) {
                // Node exists - but still update edges in case new edge types were added
                updateFunctionEdges(function, existing);
                return existing;
            }

            // Create or update node
            KnowledgeNode node = createFunctionNode(function);
            if (node != null) {
                graph.upsertNode(node);

                // Extract outgoing calls from this function (what it calls)
                extractFunctionCalls(function, node.getId());

                // Extract incoming calls to this function (what calls it)
                // This ensures callers list is populated for single-function extraction
                extractFunctionCallers(function, node.getId());

                // Extract references from this function (REFERENCES edges)
                extractFunctionReferences(function, node);

                // Extract vulnerable call edges for this function (CALLS_VULNERABLE edges)
                extractFunctionVulnerableCalls(function, node);

                functionsExtracted.incrementAndGet();

                // Flush batched items for single-function extraction
                graph.flushAllBatches();
            }

            return node;
        } catch (Exception e) {
            Msg.error(this, "Failed to extract function " + function.getName() + ": " + e.getMessage());
            return null;
        }
    }

    /**
     * Update edges for an existing function node.
     * Used to add new edge types to already-indexed functions.
     *
     * @param function The function
     * @param node The existing knowledge node
     */
    public void updateFunctionEdges(Function function, KnowledgeNode node) {
        if (function == null || node == null) {
            return;
        }

        try {
            // Check if edges need updating by looking for presence of new edge types
            // We use a simple heuristic: if there are no REFERENCES edges from this node, update
            boolean hasReferencesEdges = graph.hasEdgesOfType(node.getId(), EdgeType.REFERENCES);
            boolean hasVulnerableEdges = graph.hasEdgesOfType(node.getId(), EdgeType.CALLS_VULNERABLE);

            if (!hasReferencesEdges) {
                Msg.debug(this, "Updating REFERENCES edges for: " + function.getName());
                extractFunctionReferences(function, node);
            }

            if (!hasVulnerableEdges) {
                Msg.debug(this, "Updating CALLS_VULNERABLE edges for: " + function.getName());
                extractFunctionVulnerableCalls(function, node);
            }
        } catch (Exception e) {
            Msg.debug(this, "Failed to update edges for " + function.getName() + ": " + e.getMessage());
        }
    }

    /**
     * Get decompiled code for a function, using cache if available.
     * This is the primary caching mechanism to avoid redundant decompilation.
     *
     * @param function The function to decompile
     * @return Decompiled code string, or null on failure
     */
    public String getDecompiledCode(Function function) {
        if (function == null) {
            return null;
        }

        // Check cache first
        String cached = graph.getCachedDecompiledCode(function.getEntryPoint().getOffset());
        if (cached != null) {
            Msg.debug(this, "Cache hit for function: " + function.getName());
            return cached;
        }

        // Decompile and cache
        try {
            if (decompiler == null) {
                decompiler = new DecompInterface();
                decompiler.openProgram(program);
            }

            DecompileResults results = decompiler.decompileFunction(function, 60, monitor);
            if (results != null && results.decompileCompleted()) {
                String code = results.getDecompiledFunction().getC();

                // Cache in graph
                KnowledgeNode node = graph.getNodeByAddress(function.getEntryPoint().getOffset());
                if (node == null) {
                    node = KnowledgeNode.createFunction(
                            binaryId,
                            function.getEntryPoint().getOffset(),
                            function.getName()
                    );
                }
                node.setRawContent(code);
                graph.upsertNode(node);

                Msg.debug(this, "Cached decompiled code for: " + function.getName());
                return code;
            }
        } catch (Exception e) {
            Msg.error(this, "Decompilation failed for " + function.getName() + ": " + e.getMessage());
        }

        return null;
    }

    // ========================================
    // Private extraction methods
    // ========================================

    private void extractFunctions() {
        FunctionManager funcManager = program.getFunctionManager();

        // Collect all functions to process (excluding thunks and externals)
        List<Function> functionsToProcess = new ArrayList<>();
        FunctionIterator functions = funcManager.getFunctions(true);
        while (functions.hasNext()) {
            Function func = functions.next();
            if (!func.isThunk() && !func.isExternal()) {
                functionsToProcess.add(func);
            }
        }

        int actualTotal = functionsToProcess.size();
        Msg.info(this, String.format("Starting parallel extraction of %d functions using %d threads",
                actualTotal, DEFAULT_THREAD_COUNT));

        // Initialize progress monitor with correct total
        monitor.initialize(actualTotal);

        // Create thread pool
        extractorPool = Executors.newFixedThreadPool(DEFAULT_THREAD_COUNT, r -> {
            Thread t = new Thread(r, "StructureExtractor-Worker");
            t.setDaemon(true);
            return t;
        });

        AtomicInteger processed = new AtomicInteger(0);
        List<Future<?>> futures = new ArrayList<>();

        try {
            // Submit all functions to the thread pool
            for (Function func : functionsToProcess) {
                if (monitor.isCancelled()) {
                    break;
                }

                futures.add(extractorPool.submit(() -> {
                    if (monitor.isCancelled()) {
                        return;
                    }

                    try {
                        // Get thread-local decompiler for this worker
                        DecompInterface threadDecompiler = getThreadDecompiler();

                        // Extract function with decompilation
                        extractFunctionParallel(func, threadDecompiler);

                        // Update progress
                        int current = processed.incrementAndGet();
                        if (current % 100 == 0) {
                            monitor.setProgress(current);
                            monitor.setMessage(String.format("Extracting functions... %d/%d", current, actualTotal));
                        }
                    } catch (Exception e) {
                        Msg.debug(StructureExtractor.this, "Error extracting " + func.getName() + ": " + e.getMessage());
                    }
                }));
            }

            // Wait for all tasks to complete (with cancellation support)
            boolean wasCancelled = false;
            outerLoop:
            for (Future<?> future : futures) {
                // Wait for this future with periodic cancellation checks
                while (!future.isDone()) {
                    if (monitor.isCancelled()) {
                        wasCancelled = true;
                        break outerLoop;
                    }
                    try {
                        // Use timeout to allow periodic cancellation checks
                        future.get(100, TimeUnit.MILLISECONDS);
                    } catch (TimeoutException e) {
                        // Continue polling - will check cancellation on next iteration
                        continue;
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        wasCancelled = true;
                        break outerLoop;
                    } catch (ExecutionException e) {
                        Msg.debug(this, "Task failed: " + e.getCause().getMessage());
                        break; // Move to next future
                    }
                }
            }

            // If cancelled, cancel all pending futures
            if (wasCancelled) {
                Msg.info(this, "Cancellation requested - stopping extraction...");
                for (Future<?> future : futures) {
                    future.cancel(true);
                }
            }
        } finally {
            // Shutdown thread pool - use shutdownNow if cancelled
            if (monitor.isCancelled()) {
                extractorPool.shutdownNow();
            } else {
                extractorPool.shutdown();
            }
            try {
                if (!extractorPool.awaitTermination(5, TimeUnit.SECONDS)) {
                    extractorPool.shutdownNow();
                }
            } catch (InterruptedException e) {
                extractorPool.shutdownNow();
                Thread.currentThread().interrupt();
            }
        }

        // Flush any remaining batched items to database
        graph.flushAllBatches();

        Msg.info(this, String.format("Parallel extraction complete: %d functions processed", processed.get()));
    }

    /**
     * Get or create a decompiler for the current thread.
     */
    private DecompInterface getThreadDecompiler() {
        long threadId = Thread.currentThread().threadId();
        return threadDecompilers.computeIfAbsent(threadId, id -> {
            DecompInterface decomp = new DecompInterface();
            decomp.openProgram(program);
            return decomp;
        });
    }

    /**
     * Extract a function using a provided decompiler (for parallel execution).
     */
    private void extractFunctionParallel(Function function, DecompInterface threadDecompiler) {
        if (function == null || function.isThunk()) {
            return;
        }

        try {
            long address = function.getEntryPoint().getOffset();

            // Check if already cached (synchronized read)
            KnowledgeNode existing = graph.getNodeByAddress(address);
            if (existing != null && existing.getRawContent() != null) {
                // Node exists - update edges in case new edge types were added
                updateFunctionEdges(function, existing);
                return;
            }

            // Create or update node
            KnowledgeNode node = createFunctionNodeParallel(function, threadDecompiler);
            if (node != null) {
                // Queue for batch insert (thread-safe)
                // Use returned node - may be existing canonical node if duplicate
                node = graph.queueNodeForBatch(node);

                // Extract calls from this function (use canonical node ID)
                extractFunctionCalls(function, node.getId());

                // Extract references from this function (REFERENCES edges)
                extractFunctionReferences(function, node);

                // Extract vulnerable call edges for this function (CALLS_VULNERABLE edges)
                extractFunctionVulnerableCalls(function, node);

                functionsExtracted.incrementAndGet();
            }
        } catch (Exception e) {
            Msg.debug(this, "Failed to extract function " + function.getName() + ": " + e.getMessage());
        }
    }

    /**
     * Attempt to decompile a function with retry logic.
     * @param function The function to decompile
     * @param decompiler The decompiler instance to use
     * @return Decompiled C code, or null if all attempts fail
     */
    private String decompileWithRetry(Function function, DecompInterface decompiler) {
        for (int attempt = 1; attempt <= DECOMPILE_MAX_RETRIES; attempt++) {
            if (monitor.isCancelled()) {
                return null;
            }

            // Increase timeout with each retry: 30s, 60s, 90s
            int timeout = DECOMPILE_BASE_TIMEOUT * attempt;

            try {
                DecompileResults results = decompiler.decompileFunction(function, timeout, monitor);

                if (results != null && results.decompileCompleted()) {
                    DecompiledFunction decompiledFunc = results.getDecompiledFunction();
                    if (decompiledFunc != null) {
                        String code = decompiledFunc.getC();
                        if (code != null && !code.isEmpty()) {
                            if (attempt > 1) {
                                Msg.info(this, "Decompilation succeeded on attempt " + attempt +
                                    " for: " + function.getName());
                            }
                            return code;
                        }
                    }
                }

                // Log failure reason if available
                if (results != null) {
                    String errorMsg = results.getErrorMessage();
                    if (errorMsg != null && !errorMsg.isEmpty()) {
                        Msg.warn(this, "Decompilation attempt " + attempt + " failed for " +
                            function.getName() + ": " + errorMsg);
                    } else {
                        Msg.warn(this, "Decompilation attempt " + attempt + " incomplete for " +
                            function.getName() + " (no error message)");
                    }
                }

            } catch (Exception e) {
                Msg.warn(this, "Decompilation attempt " + attempt + " threw exception for " +
                    function.getName() + ": " + e.getMessage());
            }
        }

        return null;
    }

    /**
     * Create a function node using a provided decompiler (for parallel execution).
     * Uses thread-local decompiler for parallel decompilation.
     *
     * In incremental mode, preserves existing semantic data and only marks stale if content changed.
     */
    private KnowledgeNode createFunctionNodeParallel(Function function, DecompInterface threadDecompiler) {
        try {
            long address = function.getEntryPoint().getOffset();
            String name = function.getName();

            // Check if node already exists
            KnowledgeNode existingNode = graph.getNodeByAddress(address);
            KnowledgeNode node;
            boolean isExistingNode = (existingNode != null);

            if (existingNode == null) {
                node = KnowledgeNode.createFunction(binaryId, address, name);
            } else {
                node = existingNode;
                node.setName(name); // Update name in case of rename
            }

            // Decompile with retry logic (3 attempts with increasing timeout)
            String content = null;
            if (threadDecompiler != null) {
                content = decompileWithRetry(function, threadDecompiler);
            }

            // Fall back to disassembly if decompilation failed
            if (content == null || content.isEmpty()) {
                Msg.info(this, "Falling back to disassembly for: " + function.getName());
                try {
                    content = getDisassembly(function);
                } catch (Exception e) {
                    Msg.error(this, "Disassembly also failed for " + function.getName() +
                        ": " + e.getMessage());
                }
            }

            // Guarantee non-null content
            if (content == null || content.isEmpty()) {
                content = "// Unable to decompile or disassemble: " + function.getName();
                Msg.error(this, "All extraction methods failed for: " + function.getName() +
                    " at " + function.getEntryPoint());
            }

            // In incremental mode, check if content actually changed before marking stale
            if (incrementalMode && isExistingNode) {
                boolean contentChanged = shouldMarkStale(existingNode, name, content);
                if (contentChanged) {
                    node.setRawContent(content);
                    node.markStale();
                    Msg.debug(this, "Content changed for " + name + ", marking stale");
                } else {
                    // Content unchanged - keep existing content and clear stale flag
                    // (we marked all nodes stale at the start of reindex)
                    node.setStale(false);
                    Msg.debug(this, "Content unchanged for " + name + ", preserving semantic data");
                }
            } else {
                // Non-incremental mode or new node - always update content
                node.setRawContent(content);
                node.markStale();
            }

            // Extract security features (network APIs, file I/O, strings)
            // In incremental mode, only update if we don't already have flags
            if (!incrementalMode || !node.hasSecurityFlags()) {
                extractSecurityFeatures(function, node);
            }

            return node;
        } catch (Exception e) {
            Msg.warn(this, "Failed to create node for " + function.getName() + ": " + e.getMessage());
            return null;
        }
    }

    /**
     * Check if a node's content has changed significantly and needs re-summarization.
     *
     * In incremental mode, we only want to mark nodes stale if:
     * - The function name changed
     * - The decompiled content changed significantly (ignoring whitespace differences)
     *
     * This preserves existing LLM summaries for unchanged functions.
     *
     * @param existing   The existing node from the database
     * @param newName    The new function name from Ghidra
     * @param newContent The new decompiled content
     * @return true if the node should be marked stale for re-summarization
     */
    private boolean shouldMarkStale(KnowledgeNode existing, String newName, String newContent) {
        if (existing == null) {
            return true; // New node, needs summarization
        }

        // User-edited summaries are never overwritten
        if (existing.isUserEdited()) {
            return false;
        }

        // Name changed
        if (!java.util.Objects.equals(existing.getName(), newName)) {
            return true;
        }

        // Content changed (compare normalized, ignoring whitespace)
        String existingNorm = normalizeContent(existing.getRawContent());
        String newNorm = normalizeContent(newContent);
        return !java.util.Objects.equals(existingNorm, newNorm);
    }

    /**
     * Normalize content for comparison by removing excessive whitespace.
     */
    private String normalizeContent(String s) {
        if (s == null) {
            return "";
        }
        return s.replaceAll("\\s+", " ").trim();
    }

    private KnowledgeNode createFunctionNode(Function function) {
        try {
            long address = function.getEntryPoint().getOffset();
            String name = function.getName();

            // Check if node already exists
            KnowledgeNode existingNode = graph.getNodeByAddress(address);
            KnowledgeNode node;
            boolean isExistingNode = (existingNode != null);

            if (existingNode == null) {
                node = KnowledgeNode.createFunction(binaryId, address, name);
            } else {
                node = existingNode;
                node.setName(name); // Update name in case of rename
            }

            // Decompile and store raw content
            String content = null;
            DecompileResults results = decompiler.decompileFunction(function, 60, monitor);
            if (results != null && results.decompileCompleted()) {
                content = results.getDecompiledFunction().getC();
            } else {
                // Fall back to disassembly
                content = getDisassembly(function);
            }

            // In incremental mode, check if content actually changed before marking stale
            if (incrementalMode && isExistingNode) {
                boolean contentChanged = shouldMarkStale(existingNode, name, content);
                if (contentChanged) {
                    node.setRawContent(content);
                    node.markStale();
                } else {
                    // Content unchanged - preserve semantic data
                    node.setStale(false);
                }
            } else {
                node.setRawContent(content);
                node.markStale();
            }

            // Extract security features (network APIs, file I/O, strings)
            // In incremental mode, only update if we don't already have flags
            if (!incrementalMode || !node.hasSecurityFlags()) {
                extractSecurityFeatures(function, node);
            }

            return node;
        } catch (Exception e) {
            Msg.warn(this, "Failed to create node for " + function.getName() + ": " + e.getMessage());
            return null;
        }
    }

    /**
     * Extract security-relevant features from a function and apply to node.
     * Also generates and sets security flags for vulnerability tracking.
     * Uses both call graph analysis and decompiled code parsing for better coverage.
     */
    private void extractSecurityFeatures(Function function, KnowledgeNode node) {
        try {
            SecurityFeatureExtractor secExtractor = new SecurityFeatureExtractor(program, monitor);
            // Pass decompiled code for additional API call detection via regex
            String decompiledCode = node.getRawContent();
            SecurityFeatures features = secExtractor.extractFeatures(function, decompiledCode);

            if (!features.isEmpty()) {
                // Apply the raw security features to the node
                node.applySecurityFeatures(features);

                // Generate and set security flags for the graph_nodes.security_flags field
                java.util.List<String> securityFlags = features.generateSecurityFlags();
                if (!securityFlags.isEmpty()) {
                    node.setSecurityFlags(securityFlags);
                    Msg.debug(this, String.format("Security flags for %s: %s",
                            function.getName(), securityFlags));
                }

                Msg.debug(this, String.format("Extracted security features for %s: %s",
                        function.getName(), features.toString()));
            }
        } catch (Exception e) {
            Msg.debug(this, "Failed to extract security features for " + function.getName() + ": " + e.getMessage());
        }
    }

    private void extractCallGraph() {
        FunctionManager funcManager = program.getFunctionManager();
        FunctionIterator functions = funcManager.getFunctions(true);

        while (functions.hasNext() && !monitor.isCancelled()) {
            Function caller = functions.next();
            if (caller.isThunk() || caller.isExternal()) {
                continue;
            }

            KnowledgeNode callerNode = graph.getNodeByAddress(caller.getEntryPoint().getOffset());
            if (callerNode == null) {
                continue;
            }

            extractFunctionCalls(caller, callerNode.getId());
        }
    }

    /**
     * Extract outgoing calls from a function (what this function calls).
     * Uses ReferenceManager to get instruction-level CALL references, which matches
     * what Ghidra's Function Call Trees shows (unlike getCalledFunctions() which misses some).
     */
    private void extractFunctionCalls(Function caller, String callerNodeId) {
        ReferenceManager refMgr = program.getReferenceManager();
        FunctionManager funcMgr = program.getFunctionManager();
        SymbolTable symTable = program.getSymbolTable();
        Set<String> processedTargets = new HashSet<>(); // Avoid duplicate edges

        // Debug logging for specific functions
        boolean debugThis = caller.getName().contains("WorkerThread");

        // Iterate through all addresses in the function body
        AddressSetView body = caller.getBody();
        AddressIterator addrIter = body.getAddresses(true);
        while (addrIter.hasNext() && !monitor.isCancelled()) {
            Address addr = addrIter.next();

            // Get all references FROM this address
            Reference[] refs = refMgr.getReferencesFrom(addr);
            for (Reference ref : refs) {
                // Only process CALL references
                if (!ref.getReferenceType().isCall()) {
                    continue;
                }

                Address toAddr = ref.getToAddress();
                String targetKey = toAddr.toString();
                if (processedTargets.contains(targetKey)) {
                    continue; // Already processed this target
                }
                processedTargets.add(targetKey);

                // Try to resolve to a function
                Function callee = funcMgr.getFunctionAt(toAddr);
                if (callee == null) {
                    callee = funcMgr.getFunctionContaining(toAddr);
                }

                if (callee != null) {
                    // Follow thunks to real function
                    Function realCallee = callee;
                    while (realCallee.isThunk()) {
                        Function thunked = realCallee.getThunkedFunction(true);
                        if (thunked == null) break;
                        realCallee = thunked;
                    }

                    if (realCallee.isExternal()) {
                        if (debugThis) {
                            Msg.info(this, String.format("  [%s] CALL -> EXTERNAL: %s", caller.getName(), realCallee.getName()));
                        }
                        createExternalCallEdge(callerNodeId, realCallee.getName());
                    } else if (realCallee.isThunk()) {
                        // Unresolved thunk - extract name
                        String externalName = extractExternalNameFromThunk(realCallee);
                        if (debugThis) {
                            Msg.info(this, String.format("  [%s] CALL -> THUNK: %s (extracted: %s)",
                                caller.getName(), realCallee.getName(), externalName));
                        }
                        createExternalCallEdge(callerNodeId, externalName);
                    } else {
                        // Internal function
                        if (debugThis) {
                            Msg.info(this, String.format("  [%s] CALL -> INTERNAL: %s", caller.getName(), realCallee.getName()));
                        }
                        createInternalCallEdge(callerNodeId, realCallee);
                    }
                } else {
                    // No function at target - check if it's an external reference
                    Symbol sym = symTable.getPrimarySymbol(toAddr);
                    if (debugThis) {
                        Msg.info(this, String.format("  [%s] CALL -> NO_FUNC at %s, symbol=%s",
                            caller.getName(), toAddr, sym != null ? sym.getName() : "null"));
                    }
                    if (sym != null && sym.isExternalEntryPoint()) {
                        createExternalCallEdge(callerNodeId, sym.getName());
                    } else if (sym != null) {
                        // Has a symbol but not a function - could be IAT entry
                        String name = normalizeExternalName(sym.getName());
                        createExternalCallEdge(callerNodeId, name);
                    }
                    // Else: no symbol, no function - skip this call reference
                }
            }
        }

        if (debugThis) {
            Msg.info(this, String.format("[%s] Total call targets processed: %d", caller.getName(), processedTargets.size()));
        }
    }

    /**
     * Create an edge to an internal function, creating placeholder node if needed.
     */
    private void createInternalCallEdge(String callerNodeId, Function callee) {
        KnowledgeNode calleeNode = graph.getNodeByAddress(callee.getEntryPoint().getOffset());
        if (calleeNode == null) {
            // Create placeholder node for callee that hasn't been processed yet
            calleeNode = KnowledgeNode.createFunction(binaryId,
                    callee.getEntryPoint().getOffset(), callee.getName());
            calleeNode.markStale();
            // Use returned canonical node to ensure correct ID for edge
            calleeNode = graph.queueNodeForBatch(calleeNode);
        }
        graph.queueEdgeForBatch(callerNodeId, calleeNode.getId(), EdgeType.CALLS);
        callEdgesCreated.incrementAndGet();
    }

    /**
     * Normalize external function name by removing common decorations.
     */
    private String normalizeExternalName(String name) {
        if (name == null) return "unknown";

        // Remove __imp_ prefix (Windows import thunk)
        if (name.startsWith("__imp_")) {
            name = name.substring(6);
        }
        // Remove leading underscores (up to 2)
        int count = 0;
        while (name.startsWith("_") && name.length() > 1 && count < 2) {
            name = name.substring(1);
            count++;
        }
        // Remove @N suffix (stdcall decoration)
        int atIdx = name.lastIndexOf('@');
        if (atIdx > 0 && name.substring(atIdx + 1).matches("\\d+")) {
            name = name.substring(0, atIdx);
        }
        return name;
    }

    /**
     * Create an edge to an external function, creating the external node if needed.
     * External functions use null address to avoid unique index conflicts in the database.
     */
    private void createExternalCallEdge(String callerNodeId, String externalName) {
        KnowledgeNode extNode = graph.getNodeByName(externalName);
        boolean created = false;
        if (extNode == null) {
            // Use createExternalFunction which sets address=null (not 0)
            // This avoids unique index conflicts since all externals would have address=0
            extNode = KnowledgeNode.createExternalFunction(binaryId, externalName);
            extNode.setRawContent("// External function: " + externalName);
            // Use returned canonical node to ensure correct ID for edge
            extNode = graph.queueNodeForBatch(extNode);
            created = true;
        }
        // Debug: Log first few external node creations
        if (created && externalName.contains("WSA")) {
            Msg.info(this, String.format("  EXTERNAL NODE CREATED: %s (id=%s, addr=%s)",
                externalName, extNode.getId(), extNode.getAddress()));
        }
        graph.queueEdgeForBatch(callerNodeId, extNode.getId(), EdgeType.CALLS);
    }

    /**
     * Extract external function name from a thunk function name.
     * Handles common decorations:
     * - __imp_WSARecvFrom -> WSARecvFrom
     * - _WSARecvFrom@28 -> WSARecvFrom
     * - thunk_FUN_00401000 -> FUN_00401000
     * - Ordinal_123 -> Ordinal_123 (preserved)
     */
    private String extractExternalNameFromThunk(Function thunk) {
        String name = thunk.getName();
        if (name == null) {
            return "unknown_thunk";
        }

        // Remove __imp_ prefix (Windows import thunk)
        if (name.startsWith("__imp_")) {
            name = name.substring(6);
        }
        // Remove thunk_ prefix
        if (name.startsWith("thunk_")) {
            name = name.substring(6);
        }
        // Remove leading underscores (up to 2, common in Windows APIs)
        int underscoreCount = 0;
        while (name.startsWith("_") && name.length() > 1 && underscoreCount < 2) {
            name = name.substring(1);
            underscoreCount++;
        }
        // Remove @N suffix (stdcall parameter size decoration)
        int atIdx = name.lastIndexOf('@');
        if (atIdx > 0) {
            String suffix = name.substring(atIdx + 1);
            if (suffix.matches("\\d+")) {
                name = name.substring(0, atIdx);
            }
        }

        return name;
    }

    /**
     * Extract incoming calls to a function (what calls this function).
     * This ensures the callers list is populated for single-function extraction.
     */
    private void extractFunctionCallers(Function callee, String calleeNodeId) {
        Set<Function> callingFunctions = callee.getCallingFunctions(monitor);

        for (Function caller : callingFunctions) {
            if (monitor.isCancelled()) {
                break;
            }

            // Skip thunks - follow to real function
            Function realCaller = caller;
            while (realCaller.isThunk()) {
                Function thunked = realCaller.getThunkedFunction(true);
                if (thunked == null) break;
                realCaller = thunked;
            }

            // Skip external callers (shouldn't happen but be safe)
            if (realCaller.isExternal()) {
                continue;
            }

            KnowledgeNode callerNode = graph.getNodeByAddress(realCaller.getEntryPoint().getOffset());
            if (callerNode == null) {
                // Create placeholder node for caller that hasn't been processed yet
                callerNode = KnowledgeNode.createFunction(binaryId,
                        realCaller.getEntryPoint().getOffset(), realCaller.getName());
                callerNode.markStale();
                // Use returned canonical node to ensure correct ID for edge
                callerNode = graph.queueNodeForBatch(callerNode);
            }

            // Create edge: caller -> this function (callee)
            // Check if edge already exists to avoid duplicates
            if (!graph.hasEdgeBetween(callerNode.getId(), calleeNodeId, EdgeType.CALLS)) {
                graph.queueEdgeForBatch(callerNode.getId(), calleeNodeId, EdgeType.CALLS);
                callEdgesCreated.incrementAndGet();
            }
        }
    }

    /**
     * Extract cross-references from functions to data and other code.
     * Creates REFERENCES edges for non-call references.
     */
    private void extractReferences() {
        try {
            ReferenceManager refMgr = program.getReferenceManager();
            FunctionManager funcMgr = program.getFunctionManager();
            FunctionIterator functions = funcMgr.getFunctions(true);

            int total = funcMgr.getFunctionCount();
            int processed = 0;

            // Initialize progress for this phase
            monitor.initialize(total);

            while (functions.hasNext() && !monitor.isCancelled()) {
                Function func = functions.next();
                processed++;

                if (processed % 100 == 0) {
                    monitor.setProgress(processed);
                    monitor.setMessage(String.format("Extracting references... %d/%d", processed, total));
                }

                if (func.isThunk() || func.isExternal()) {
                    continue;
                }

                KnowledgeNode funcNode = graph.getNodeByAddress(func.getEntryPoint().getOffset());
                if (funcNode == null) {
                    continue;
                }

                // Get all references FROM this function's body
                AddressSetView body = func.getBody();
                Set<Long> referencedAddresses = new HashSet<>();

                for (Address addr : body.getAddresses(true)) {
                    if (monitor.isCancelled()) break;

                    Reference[] refs = refMgr.getReferencesFrom(addr);
                    for (Reference ref : refs) {
                        // Skip call references - already handled by CALLS edges
                        if (ref.getReferenceType().isCall()) {
                            continue;
                        }

                        Address toAddr = ref.getToAddress();
                        long toOffset = toAddr.getOffset();

                        // Avoid duplicate edges to same target
                        if (referencedAddresses.contains(toOffset)) {
                            continue;
                        }

                        if (ref.getReferenceType().isData()) {
                            // Code references data - check if it's in a data section
                            MemoryBlock block = program.getMemory().getBlock(toAddr);
                            if (block != null && !block.isExecute()) {
                                // This is a data reference - for now we just track it
                                // We could create DATA nodes if needed in the future
                                referencedAddresses.add(toOffset);
                                refEdgesCreated.incrementAndGet(); // Count it even without creating edge
                            }
                        } else {
                            // Other code references (jumps to other functions, etc.)
                            Function targetFunc = funcMgr.getFunctionContaining(toAddr);
                            if (targetFunc != null && !targetFunc.equals(func)) {
                                KnowledgeNode targetNode = graph.getNodeByAddress(
                                        targetFunc.getEntryPoint().getOffset());
                                if (targetNode != null) {
                                    graph.queueEdgeForBatch(funcNode.getId(), targetNode.getId(), EdgeType.REFERENCES);
                                    referencedAddresses.add(toOffset);
                                    refEdgesCreated.incrementAndGet();
                                }
                            }
                        }
                    }
                }
            }

            Msg.info(this, String.format("Extracted %d reference edges", refEdgesCreated.get()));
        } catch (Exception e) {
            Msg.error(this, "Failed to extract references: " + e.getMessage(), e);
        }
    }

    /**
     * Extract CALLS_VULNERABLE edges from callers to functions with vulnerability risks.
     * Also propagates the CALLS_VULNERABLE_FUNCTION flag to callers.
     */
    private void extractVulnerableCalls() {
        try {
            List<KnowledgeNode> functionNodes = graph.getNodesByType(NodeType.FUNCTION);
            Set<String> processedCallers = new HashSet<>();

            int total = functionNodes.size();
            int processed = 0;

            // Initialize progress for this phase
            monitor.initialize(total);
            monitor.setMessage("Extracting vulnerable call edges...");

            for (KnowledgeNode node : functionNodes) {
                if (monitor.isCancelled()) break;

                processed++;
                if (processed % 100 == 0) {
                    monitor.setProgress(processed);
                    monitor.setMessage(String.format("Extracting vulnerable calls... %d/%d", processed, total));
                }

                List<String> flags = node.getSecurityFlags();
                if (flags == null || flags.isEmpty()) {
                    continue;
                }

                // Check if this function has any vulnerability risk flags
                boolean hasVulnRisk = flags.stream().anyMatch(f -> f.endsWith("_RISK"));
                if (!hasVulnRisk) {
                    continue;
                }

                // This function has vulnerability risks - mark all callers
                List<KnowledgeNode> callers = graph.getCallers(node.getId());
                for (KnowledgeNode caller : callers) {
                    // Add CALLS_VULNERABLE edge
                    graph.queueEdgeForBatch(caller.getId(), node.getId(), EdgeType.CALLS_VULNERABLE);
                    vulnEdgesCreated.incrementAndGet();

                    // Add flag to caller if not already processed
                    if (!processedCallers.contains(caller.getId())) {
                        List<String> callerFlags = caller.getSecurityFlags();
                        if (callerFlags == null) {
                            callerFlags = new ArrayList<>();
                        }
                        if (!callerFlags.contains("CALLS_VULNERABLE_FUNCTION")) {
                            callerFlags = new ArrayList<>(callerFlags); // Make mutable copy
                            callerFlags.add("CALLS_VULNERABLE_FUNCTION");
                            caller.setSecurityFlags(callerFlags);
                            graph.queueNodeForBatch(caller);
                        }
                        processedCallers.add(caller.getId());
                    }
                }
            }

            Msg.info(this, String.format("Extracted %d vulnerable call edges", vulnEdgesCreated.get()));
        } catch (Exception e) {
            Msg.error(this, "Failed to extract vulnerable calls: " + e.getMessage(), e);
        }
    }

    // ========================================
    // Single-function edge extraction methods
    // (for on-demand/incremental indexing)
    // ========================================

    /**
     * Extract REFERENCES edges for a single function.
     * Called during on-demand function indexing.
     *
     * @param function The function to extract references from
     * @param funcNode The function's knowledge node
     */
    private void extractFunctionReferences(Function function, KnowledgeNode funcNode) {
        try {
            ReferenceManager refMgr = program.getReferenceManager();
            FunctionManager funcMgr = program.getFunctionManager();
            AddressSetView body = function.getBody();
            Set<Long> referencedAddresses = new HashSet<>();

            for (Address addr : body.getAddresses(true)) {
                if (monitor.isCancelled()) break;

                Reference[] refs = refMgr.getReferencesFrom(addr);
                for (Reference ref : refs) {
                    // Skip call references - already handled by CALLS edges
                    if (ref.getReferenceType().isCall()) {
                        continue;
                    }

                    Address toAddr = ref.getToAddress();
                    long toOffset = toAddr.getOffset();

                    // Avoid duplicate edges to same target
                    if (referencedAddresses.contains(toOffset)) {
                        continue;
                    }

                    if (!ref.getReferenceType().isData()) {
                        // Code references (jumps to other functions, etc.)
                        Function targetFunc = funcMgr.getFunctionContaining(toAddr);
                        if (targetFunc != null && !targetFunc.equals(function)) {
                            KnowledgeNode targetNode = graph.getNodeByAddress(
                                    targetFunc.getEntryPoint().getOffset());
                            if (targetNode != null) {
                                graph.queueEdgeForBatch(funcNode.getId(), targetNode.getId(), EdgeType.REFERENCES);
                                referencedAddresses.add(toOffset);
                                refEdgesCreated.incrementAndGet();
                            }
                        }
                    }
                }
            }
        } catch (Exception e) {
            Msg.debug(this, "Failed to extract references for " + function.getName() + ": " + e.getMessage());
        }
    }

    /**
     * Extract CALLS_VULNERABLE edges for a single function.
     * If this function has vulnerability risks, marks its callers.
     * Also checks if this function calls vulnerable functions.
     *
     * @param function The function to analyze
     * @param funcNode The function's knowledge node
     */
    private void extractFunctionVulnerableCalls(Function function, KnowledgeNode funcNode) {
        try {
            List<String> flags = funcNode.getSecurityFlags();

            // Check if THIS function has vulnerability risks
            boolean hasVulnRisk = flags != null && flags.stream().anyMatch(f -> f.endsWith("_RISK"));

            if (hasVulnRisk) {
                // Mark all callers with CALLS_VULNERABLE edge
                List<KnowledgeNode> callers = graph.getCallers(funcNode.getId());
                for (KnowledgeNode caller : callers) {
                    graph.queueEdgeForBatch(caller.getId(), funcNode.getId(), EdgeType.CALLS_VULNERABLE);
                    vulnEdgesCreated.incrementAndGet();

                    // Add flag to caller
                    List<String> callerFlags = caller.getSecurityFlags();
                    if (callerFlags == null) {
                        callerFlags = new ArrayList<>();
                    }
                    if (!callerFlags.contains("CALLS_VULNERABLE_FUNCTION")) {
                        callerFlags = new ArrayList<>(callerFlags);
                        callerFlags.add("CALLS_VULNERABLE_FUNCTION");
                        caller.setSecurityFlags(callerFlags);
                        graph.queueNodeForBatch(caller);
                    }
                }
            }

            // Also check if this function CALLS any vulnerable functions
            List<KnowledgeNode> callees = graph.getCallees(funcNode.getId());
            for (KnowledgeNode callee : callees) {
                List<String> calleeFlags = callee.getSecurityFlags();
                boolean calleeVuln = calleeFlags != null && calleeFlags.stream().anyMatch(f -> f.endsWith("_RISK"));

                if (calleeVuln) {
                    // This function calls a vulnerable function
                    graph.queueEdgeForBatch(funcNode.getId(), callee.getId(), EdgeType.CALLS_VULNERABLE);
                    vulnEdgesCreated.incrementAndGet();

                    // Add flag to this function
                    if (flags == null) {
                        flags = new ArrayList<>();
                    }
                    if (!flags.contains("CALLS_VULNERABLE_FUNCTION")) {
                        flags = new ArrayList<>(flags);
                        flags.add("CALLS_VULNERABLE_FUNCTION");
                        funcNode.setSecurityFlags(flags);
                        graph.queueNodeForBatch(funcNode);
                    }
                }
            }
        } catch (Exception e) {
            Msg.debug(this, "Failed to extract vulnerable calls for " + function.getName() + ": " + e.getMessage());
        }
    }

    private void createBinaryNode() {
        String programName = program.getName();

        KnowledgeNode binaryNode = KnowledgeNode.createBinary(binaryId, programName);

        // Build binary description
        StringBuilder desc = new StringBuilder();
        desc.append("Binary: ").append(programName).append("\n");
        desc.append("Format: ").append(program.getExecutableFormat()).append("\n");
        desc.append("Language: ").append(program.getLanguage().getLanguageID()).append("\n");
        desc.append("Compiler: ").append(program.getCompiler()).append("\n");
        desc.append("Functions: ").append(program.getFunctionManager().getFunctionCount()).append("\n");

        // Add entry points
        desc.append("\nEntry Points:\n");
        for (Address entry : program.getSymbolTable().getExternalEntryPointIterator()) {
            Function func = program.getFunctionManager().getFunctionAt(entry);
            if (func != null) {
                desc.append("  - ").append(func.getName()).append(" @ ").append(entry).append("\n");
            }
        }

        binaryNode.setRawContent(desc.toString());
        binaryNode.markStale(); // Needs LLM summary
        graph.queueNodeForBatch(binaryNode);

        // Create CONTAINS edges from binary to all functions
        for (KnowledgeNode funcNode : graph.getNodesByType(NodeType.FUNCTION)) {
            graph.queueEdgeForBatch(binaryNode.getId(), funcNode.getId(), EdgeType.CONTAINS);
        }

        // Flush any remaining batched items
        graph.flushAllBatches();
    }

    // ========================================
    // Helper methods
    // ========================================

    private String getDisassembly(Function function) {
        StringBuilder sb = new StringBuilder();
        InstructionIterator instructions = program.getListing().getInstructions(function.getBody(), true);

        while (instructions.hasNext()) {
            Instruction instr = instructions.next();
            sb.append(String.format("%s  %s\n",
                    instr.getAddressString(true, true),
                    instr.toString()));
        }

        return sb.toString();
    }

    private String getBlockDisassembly(CodeBlock block) {
        StringBuilder sb = new StringBuilder();
        InstructionIterator instructions = program.getListing().getInstructions(block, true);

        while (instructions.hasNext()) {
            Instruction instr = instructions.next();
            sb.append(String.format("%s  %s\n",
                    instr.getAddressString(true, true),
                    instr.toString()));
        }

        return sb.toString();
    }

    // ========================================
    // Community Detection
    // ========================================

    /**
     * Detect communities (clusters) of related functions using label propagation.
     */
    private void detectCommunities() {
        try {
            ghidrassist.graphrag.community.CommunityDetector detector =
                    new ghidrassist.graphrag.community.CommunityDetector(graph, monitor);
            int communityCount = detector.detectCommunities();
            Msg.info(this, String.format("Detected %d communities", communityCount));
        } catch (Exception e) {
            Msg.error(this, "Failed to detect communities: " + e.getMessage(), e);
        }
    }

    /**
     * Cleanup resources.
     */
    public void dispose() {
        if (decompiler != null) {
            decompiler.dispose();
            decompiler = null;
        }

        // Dispose thread-local decompilers
        for (DecompInterface decomp : threadDecompilers.values()) {
            try {
                decomp.dispose();
            } catch (Exception e) {
                // Ignore disposal errors
            }
        }
        threadDecompilers.clear();
    }

    // ========================================
    // Result class
    // ========================================

    /**
     * Results from structure extraction.
     */
    public static class ExtractionResult {
        public final int functionsExtracted;
        public final int callEdgesCreated;
        public final int refEdgesCreated;
        public final int vulnEdgesCreated;
        public final long elapsedMs;

        public ExtractionResult(int functions, int calls, int refs, int vulns, long elapsed) {
            this.functionsExtracted = functions;
            this.callEdgesCreated = calls;
            this.refEdgesCreated = refs;
            this.vulnEdgesCreated = vulns;
            this.elapsedMs = elapsed;
        }

        @Override
        public String toString() {
            return String.format("Extracted %d functions, %d call edges, %d ref edges, %d vuln edges in %dms",
                    functionsExtracted, callEdgesCreated, refEdgesCreated, vulnEdgesCreated, elapsedMs);
        }
    }
}

```

`src/main/java/ghidrassist/graphrag/nodes/EdgeType.java`:

```java
package ghidrassist.graphrag.nodes;

/**
 * Types of edges in the Binary Knowledge Graph.
 *
 * Edges are categorized into three groups:
 * <ul>
 *   <li>STRUCTURAL - Derived from Ghidra analysis (call graph, xrefs, hierarchy)</li>
 *   <li>SEMANTIC - Generated by LLM (similarity, logical dependencies)</li>
 *   <li>COMMUNITY - Computed by community detection algorithms</li>
 * </ul>
 */
public enum EdgeType {

    // ========================================
    // STRUCTURAL edges (from Ghidra)
    // ========================================

    /**
     * Hierarchical containment (binary → module → function → block → statement).
     * Directed from parent to child.
     */
    CONTAINS("structural", "Contains", true),

    /**
     * Function call relationship.
     * Directed from caller to callee.
     */
    CALLS("structural", "Calls", true),

    /**
     * Control flow between basic blocks.
     * Directed following execution flow.
     */
    FLOWS_TO("structural", "Flows to", true),

    /**
     * Cross-references (code referencing data or other code).
     * Directed from referencer to referenced.
     */
    REFERENCES("structural", "References", true),

    /**
     * Type/class inheritance relationships.
     * Directed from subtype to supertype.
     */
    INHERITS("structural", "Inherits from", true),

    // ========================================
    // SEMANTIC edges (LLM-generated)
    // ========================================

    /**
     * Functions with similar semantic purpose.
     * Undirected - mutual similarity.
     */
    SIMILAR_PURPOSE("semantic", "Similar purpose to", false),

    /**
     * Logical dependency between components.
     * Directed from dependent to dependency.
     */
    DEPENDS_ON("semantic", "Depends on", true),

    /**
     * Function implements a specific concept (e.g., "authentication", "encryption").
     * Directed from function to concept node.
     */
    IMPLEMENTS("semantic", "Implements", true),

    /**
     * Related functionality without direct call relationship.
     * Undirected - mutual relationship.
     */
    RELATED_TO("semantic", "Related to", false),

    // ========================================
    // SECURITY edges (LLM-generated + analysis)
    // ========================================

    /**
     * Security relationship - potential vulnerability path.
     * Directed from source to sink in taint analysis.
     */
    VULNERABLE_VIA("security", "Vulnerable via", true),

    /**
     * Taint propagation path.
     * Directed from taint source through intermediates to sink.
     */
    TAINT_FLOWS_TO("security", "Taint flows to", true),

    /**
     * One node calls or uses a vulnerable function.
     * Directed from caller to vulnerable callee.
     */
    CALLS_VULNERABLE("security", "Calls vulnerable", true),

    /**
     * Network send edge - connection from caller to network send API.
     * Represents data flow paths to network output (send, WSASend, etc.).
     */
    NETWORK_SEND("security", "Network send", true),

    /**
     * Network recv edge - connection from network recv API to caller.
     * Represents data flow paths from network input (recv, WSARecv, etc.).
     */
    NETWORK_RECV("security", "Network recv", true),

    // ========================================
    // COMMUNITY edges (computed)
    // ========================================

    /**
     * Node belongs to a community/module cluster.
     * Directed from node to community.
     */
    BELONGS_TO_COMMUNITY("community", "Belongs to", true),

    /**
     * Nodes that are siblings within the same community.
     * Undirected - mutual relationship.
     */
    SIBLING("community", "Sibling of", false);

    private final String category;
    private final String displayName;
    private final boolean directed;

    EdgeType(String category, String displayName, boolean directed) {
        this.category = category;
        this.displayName = displayName;
        this.directed = directed;
    }

    /**
     * Get the edge category (structural, semantic, security, community).
     */
    public String getCategory() {
        return category;
    }

    /**
     * Get the human-readable display name.
     */
    public String getDisplayName() {
        return displayName;
    }

    /**
     * Check if this edge type is directed.
     */
    public boolean isDirected() {
        return directed;
    }

    /**
     * Check if this is a structural edge derived from Ghidra.
     */
    public boolean isStructural() {
        return "structural".equals(category);
    }

    /**
     * Check if this is a semantic edge generated by LLM.
     */
    public boolean isSemantic() {
        return "semantic".equals(category);
    }

    /**
     * Check if this is a security-related edge.
     */
    public boolean isSecurity() {
        return "security".equals(category);
    }

    /**
     * Check if this is a community/clustering edge.
     */
    public boolean isCommunity() {
        return "community".equals(category);
    }

    /**
     * Parse an edge type from its string representation.
     */
    public static EdgeType fromString(String value) {
        if (value == null) {
            return null;
        }
        try {
            return valueOf(value.toUpperCase());
        } catch (IllegalArgumentException e) {
            return null;
        }
    }
}

```

`src/main/java/ghidrassist/graphrag/nodes/KnowledgeNode.java`:

```java
package ghidrassist.graphrag.nodes;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.nio.ByteBuffer;
import java.time.Instant;
import java.util.*;

/**
 * Represents a node in the Binary Knowledge Graph.
 *
 * Each node captures semantic information about a portion of a binary at one of
 * five granularity levels (STATEMENT, BLOCK, FUNCTION, MODULE, BINARY).
 *
 * Nodes contain:
 * - Identity: unique ID, type, address, binary reference
 * - Content: raw decompiled/disassembled content, LLM-generated summary
 * - Metadata: timestamps, analysis depth, staleness
 * - Embeddings: optional vector for semantic search
 * - Security: vulnerability annotations, taint information
 */
public class KnowledgeNode {

    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();

    // ========================================
    // Identity fields
    // ========================================

    private String id;                    // UUID for node
    private NodeType type;                // STATEMENT, BLOCK, FUNCTION, MODULE, BINARY
    private Long address;                 // Ghidra address (null for MODULE/BINARY)
    private String binaryId;              // Program hash
    private String name;                  // Function/symbol name if applicable

    // ========================================
    // Content fields
    // ========================================

    private String rawContent;            // Decompiled code / assembly / description
    private String llmSummary;            // Semantic explanation from LLM
    private float confidence;             // Summary confidence 0.0 - 1.0

    // ========================================
    // Embedding for vector search
    // ========================================

    private float[] embedding;            // Optional vector embedding

    // ========================================
    // Security annotations
    // ========================================

    private List<String> securityFlags;   // Vulnerability annotations

    // ========================================
    // Reverse Engineering Features
    // ========================================

    private List<String> networkAPIs;     // Network API calls (socket, send, recv, etc.)
    private List<String> fileIOAPIs;      // File I/O API calls (fopen, fread, fwrite, etc.)
    private List<String> ipAddresses;     // Detected IP addresses in strings
    private List<String> urls;            // Detected URLs in strings
    private List<String> filePaths;       // Detected file paths in strings
    private List<String> domains;         // Detected domain names in strings
    private List<String> registryKeys;    // Detected registry keys in strings
    private String activityProfile;       // Computed activity profile (NETWORK_CLIENT, FILE_WRITER, etc.)
    private String riskLevel;             // Computed risk level (LOW, MEDIUM, HIGH)

    // ========================================
    // Metadata
    // ========================================

    private int analysisDepth;            // How many times this node has been analyzed
    private Instant createdAt;
    private Instant updatedAt;
    private boolean isStale;              // Needs re-summarization
    private boolean userEdited;           // Set true when user manually edits llmSummary

    /**
     * Create a new KnowledgeNode with a generated UUID.
     */
    public KnowledgeNode(NodeType type, String binaryId) {
        this.id = UUID.randomUUID().toString();
        this.type = type;
        this.binaryId = binaryId;
        this.confidence = 0.0f;
        this.analysisDepth = 0;
        this.isStale = false;
        this.userEdited = false;
        this.securityFlags = new ArrayList<>();
        this.createdAt = Instant.now();
        this.updatedAt = Instant.now();
    }

    /**
     * Create a KnowledgeNode with a specific ID (for loading from DB).
     */
    public KnowledgeNode(String id, NodeType type, String binaryId) {
        this.id = id;
        this.type = type;
        this.binaryId = binaryId;
        this.confidence = 0.0f;
        this.analysisDepth = 0;
        this.isStale = false;
        this.userEdited = false;
        this.securityFlags = new ArrayList<>();
        this.createdAt = Instant.now();
        this.updatedAt = Instant.now();
    }

    // ========================================
    // Factory methods
    // ========================================

    /**
     * Create a function node with address and name.
     */
    public static KnowledgeNode createFunction(String binaryId, long address, String name) {
        KnowledgeNode node = new KnowledgeNode(NodeType.FUNCTION, binaryId);
        node.setAddress(address);
        node.setName(name);
        return node;
    }

    /**
     * Create an external function node (no address, identified by name only).
     * External functions use null address to avoid unique index conflicts.
     */
    public static KnowledgeNode createExternalFunction(String binaryId, String name) {
        KnowledgeNode node = new KnowledgeNode(NodeType.FUNCTION, binaryId);
        node.setAddress(null);  // External functions have no address
        node.setName(name);
        return node;
    }

    /**
     * Create a binary-level summary node.
     */
    public static KnowledgeNode createBinary(String binaryId, String name) {
        KnowledgeNode node = new KnowledgeNode(NodeType.BINARY, binaryId);
        node.setName(name);
        return node;
    }

    /**
     * Create a module/community node.
     */
    public static KnowledgeNode createModule(String binaryId, String name) {
        KnowledgeNode node = new KnowledgeNode(NodeType.MODULE, binaryId);
        node.setName(name);
        return node;
    }

    // ========================================
    // Embedding serialization
    // ========================================

    /**
     * Serialize embedding to byte array for SQLite storage.
     */
    public byte[] serializeEmbedding() {
        if (embedding == null || embedding.length == 0) {
            return null;
        }
        ByteBuffer buffer = ByteBuffer.allocate(embedding.length * 4);
        for (float f : embedding) {
            buffer.putFloat(f);
        }
        return buffer.array();
    }

    /**
     * Deserialize embedding from byte array.
     */
    public static float[] deserializeEmbedding(byte[] bytes) {
        if (bytes == null || bytes.length == 0) {
            return null;
        }
        ByteBuffer buffer = ByteBuffer.wrap(bytes);
        float[] result = new float[bytes.length / 4];
        for (int i = 0; i < result.length; i++) {
            result[i] = buffer.getFloat();
        }
        return result;
    }

    // ========================================
    // Security flags serialization
    // ========================================

    /**
     * Serialize security flags to JSON string for storage.
     */
    public String serializeSecurityFlags() {
        if (securityFlags == null || securityFlags.isEmpty()) {
            return "[]";
        }
        try {
            return OBJECT_MAPPER.writeValueAsString(securityFlags);
        } catch (JsonProcessingException e) {
            return "[]";
        }
    }

    /**
     * Deserialize security flags from JSON string.
     */
    public static List<String> deserializeSecurityFlags(String json) {
        if (json == null || json.isEmpty() || "[]".equals(json)) {
            return new ArrayList<>();
        }
        try {
            return OBJECT_MAPPER.readValue(json, new TypeReference<List<String>>() {});
        } catch (JsonProcessingException e) {
            return new ArrayList<>();
        }
    }

    /**
     * Add a security flag to this node.
     */
    public void addSecurityFlag(String flag) {
        if (securityFlags == null) {
            securityFlags = new ArrayList<>();
        }
        if (!securityFlags.contains(flag)) {
            securityFlags.add(flag);
            markUpdated();
        }
    }

    /**
     * Check if this node has any security flags.
     */
    public boolean hasSecurityFlags() {
        return securityFlags != null && !securityFlags.isEmpty();
    }

    // ========================================
    // State management
    // ========================================

    /**
     * Mark this node as updated and reset staleness.
     */
    public void markUpdated() {
        this.updatedAt = Instant.now();
        this.isStale = false;
    }

    /**
     * Mark this node as stale (needs re-summarization).
     */
    public void markStale() {
        this.isStale = true;
    }

    /**
     * Increment the analysis depth counter.
     */
    public void incrementAnalysisDepth() {
        this.analysisDepth++;
        markUpdated();
    }

    // ========================================
    // Getters and Setters
    // ========================================

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public NodeType getType() {
        return type;
    }

    public void setType(NodeType type) {
        this.type = type;
    }

    public Long getAddress() {
        return address;
    }

    public void setAddress(Long address) {
        this.address = address;
    }

    public String getBinaryId() {
        return binaryId;
    }

    public void setBinaryId(String binaryId) {
        this.binaryId = binaryId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getRawContent() {
        return rawContent;
    }

    public void setRawContent(String rawContent) {
        this.rawContent = rawContent;
    }

    public String getLlmSummary() {
        return llmSummary;
    }

    public void setLlmSummary(String llmSummary) {
        this.llmSummary = llmSummary;
        markUpdated();
    }

    public float getConfidence() {
        return confidence;
    }

    public void setConfidence(float confidence) {
        this.confidence = Math.max(0.0f, Math.min(1.0f, confidence));
    }

    public float[] getEmbedding() {
        return embedding;
    }

    public void setEmbedding(float[] embedding) {
        this.embedding = embedding;
    }

    public List<String> getSecurityFlags() {
        return securityFlags != null ? Collections.unmodifiableList(securityFlags) : Collections.emptyList();
    }

    public void setSecurityFlags(List<String> securityFlags) {
        this.securityFlags = securityFlags != null ? new ArrayList<>(securityFlags) : new ArrayList<>();
    }

    public int getAnalysisDepth() {
        return analysisDepth;
    }

    public void setAnalysisDepth(int analysisDepth) {
        this.analysisDepth = analysisDepth;
    }

    public Instant getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Instant createdAt) {
        this.createdAt = createdAt;
    }

    public Instant getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(Instant updatedAt) {
        this.updatedAt = updatedAt;
    }

    public boolean isStale() {
        return isStale;
    }

    public void setStale(boolean stale) {
        isStale = stale;
    }

    public boolean isUserEdited() {
        return userEdited;
    }

    public void setUserEdited(boolean userEdited) {
        this.userEdited = userEdited;
    }

    // ========================================
    // Reverse Engineering Feature Getters/Setters
    // ========================================

    public List<String> getNetworkAPIs() {
        return networkAPIs != null ? Collections.unmodifiableList(networkAPIs) : Collections.emptyList();
    }

    public void setNetworkAPIs(List<String> networkAPIs) {
        this.networkAPIs = networkAPIs != null ? new ArrayList<>(networkAPIs) : new ArrayList<>();
    }

    public List<String> getFileIOAPIs() {
        return fileIOAPIs != null ? Collections.unmodifiableList(fileIOAPIs) : Collections.emptyList();
    }

    public void setFileIOAPIs(List<String> fileIOAPIs) {
        this.fileIOAPIs = fileIOAPIs != null ? new ArrayList<>(fileIOAPIs) : new ArrayList<>();
    }

    public List<String> getIPAddresses() {
        return ipAddresses != null ? Collections.unmodifiableList(ipAddresses) : Collections.emptyList();
    }

    public void setIPAddresses(List<String> ipAddresses) {
        this.ipAddresses = ipAddresses != null ? new ArrayList<>(ipAddresses) : new ArrayList<>();
    }

    public List<String> getURLs() {
        return urls != null ? Collections.unmodifiableList(urls) : Collections.emptyList();
    }

    public void setURLs(List<String> urls) {
        this.urls = urls != null ? new ArrayList<>(urls) : new ArrayList<>();
    }

    public List<String> getFilePaths() {
        return filePaths != null ? Collections.unmodifiableList(filePaths) : Collections.emptyList();
    }

    public void setFilePaths(List<String> filePaths) {
        this.filePaths = filePaths != null ? new ArrayList<>(filePaths) : new ArrayList<>();
    }

    public List<String> getDomains() {
        return domains != null ? Collections.unmodifiableList(domains) : Collections.emptyList();
    }

    public void setDomains(List<String> domains) {
        this.domains = domains != null ? new ArrayList<>(domains) : new ArrayList<>();
    }

    public List<String> getRegistryKeys() {
        return registryKeys != null ? Collections.unmodifiableList(registryKeys) : Collections.emptyList();
    }

    public void setRegistryKeys(List<String> registryKeys) {
        this.registryKeys = registryKeys != null ? new ArrayList<>(registryKeys) : new ArrayList<>();
    }

    public String getActivityProfile() {
        return activityProfile;
    }

    public void setActivityProfile(String activityProfile) {
        this.activityProfile = activityProfile;
    }

    public String getRiskLevel() {
        return riskLevel;
    }

    public void setRiskLevel(String riskLevel) {
        this.riskLevel = riskLevel;
    }

    /**
     * Check if this node has any detected network activity.
     */
    public boolean hasNetworkActivity() {
        return (networkAPIs != null && !networkAPIs.isEmpty()) ||
               (ipAddresses != null && !ipAddresses.isEmpty()) ||
               (urls != null && !urls.isEmpty()) ||
               (domains != null && !domains.isEmpty());
    }

    /**
     * Check if this node has any detected file activity.
     */
    public boolean hasFileActivity() {
        return (fileIOAPIs != null && !fileIOAPIs.isEmpty()) ||
               (filePaths != null && !filePaths.isEmpty()) ||
               (registryKeys != null && !registryKeys.isEmpty());
    }

    /**
     * Apply security features from extraction to this node.
     */
    public void applySecurityFeatures(ghidrassist.graphrag.extraction.SecurityFeatures features) {
        if (features == null) {
            return;
        }

        this.networkAPIs = new ArrayList<>(features.getNetworkAPIs());
        this.fileIOAPIs = new ArrayList<>(features.getFileIOAPIs());
        this.ipAddresses = new ArrayList<>(features.getIPAddresses());
        this.urls = new ArrayList<>(features.getURLs());
        this.filePaths = new ArrayList<>(features.getFilePaths());
        this.domains = new ArrayList<>(features.getDomains());
        this.registryKeys = new ArrayList<>(features.getRegistryKeys());
        this.activityProfile = features.getActivityProfile();
        this.riskLevel = features.getRiskLevel();
    }

    // ========================================
    // RE Feature Serialization (for database storage)
    // ========================================

    public String serializeNetworkAPIs() {
        return serializeStringList(networkAPIs);
    }

    public String serializeFileIOAPIs() {
        return serializeStringList(fileIOAPIs);
    }

    public String serializeIPAddresses() {
        return serializeStringList(ipAddresses);
    }

    public String serializeURLs() {
        return serializeStringList(urls);
    }

    public String serializeFilePaths() {
        return serializeStringList(filePaths);
    }

    public String serializeDomains() {
        return serializeStringList(domains);
    }

    public String serializeRegistryKeys() {
        return serializeStringList(registryKeys);
    }

    private String serializeStringList(List<String> list) {
        if (list == null || list.isEmpty()) {
            return "[]";
        }
        try {
            return OBJECT_MAPPER.writeValueAsString(list);
        } catch (JsonProcessingException e) {
            return "[]";
        }
    }

    public static List<String> deserializeStringList(String json) {
        if (json == null || json.isEmpty() || "[]".equals(json)) {
            return new ArrayList<>();
        }
        try {
            return OBJECT_MAPPER.readValue(json, new TypeReference<List<String>>() {});
        } catch (JsonProcessingException e) {
            return new ArrayList<>();
        }
    }

    // ========================================
    // Display methods
    // ========================================

    /**
     * Get a display label for this node (for UI/logging).
     */
    public String getDisplayLabel() {
        if (name != null && !name.isEmpty()) {
            return String.format("%s: %s", type.getDisplayName(), name);
        } else if (address != null) {
            return String.format("%s @ 0x%x", type.getDisplayName(), address);
        } else {
            return String.format("%s [%s]", type.getDisplayName(), id.substring(0, 8));
        }
    }

    @Override
    public String toString() {
        return getDisplayLabel();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        KnowledgeNode that = (KnowledgeNode) o;
        return Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}

```

`src/main/java/ghidrassist/graphrag/nodes/NodeType.java`:

```java
package ghidrassist.graphrag.nodes;

/**
 * Types of nodes in the Binary Knowledge Graph.
 *
 * The graph uses a 4-level semantic hierarchy:
 * <pre>
 * Level 2: BINARY         - Overall binary summary
 * Level 1: MODULE         - Communities of related functions (Leiden-detected)
 * Level 1: COMMUNITY      - Detected community grouping
 * Level 0: FUNCTION       - Complete functions with decompiled code + summaries
 * </pre>
 */
public enum NodeType {
    /**
     * Complete function with decompiled code and summary.
     * Primary unit of analysis for most queries.
     */
    FUNCTION(0, "Function"),

    /**
     * Community/module of related functions detected via Leiden algorithm.
     * Represents subsystems and logical groupings.
     */
    MODULE(1, "Module"),

    /**
     * Detected community grouping of related functions.
     * Same level as MODULE - represents functional groupings.
     */
    COMMUNITY(1, "Community"),

    /**
     * Top-level binary summary.
     * Overall program semantics and attack surface.
     */
    BINARY(2, "Binary");

    private final int level;
    private final String displayName;

    NodeType(int level, String displayName) {
        this.level = level;
        this.displayName = displayName;
    }

    /**
     * Get the hierarchy level (0 = finest, 4 = coarsest).
     */
    public int getLevel() {
        return level;
    }

    /**
     * Get the human-readable display name.
     */
    public String getDisplayName() {
        return displayName;
    }

    /**
     * Check if this node type is at a finer granularity than another.
     */
    public boolean isFinerThan(NodeType other) {
        return this.level < other.level;
    }

    /**
     * Check if this node type is at a coarser granularity than another.
     */
    public boolean isCoarserThan(NodeType other) {
        return this.level > other.level;
    }

    /**
     * Parse a node type from its string representation.
     */
    public static NodeType fromString(String value) {
        if (value == null) {
            return null;
        }
        try {
            return valueOf(value.toUpperCase());
        } catch (IllegalArgumentException e) {
            return null;
        }
    }
}

```

`src/main/java/ghidrassist/graphrag/query/CallContext.java`:

```java
package ghidrassist.graphrag.query;

import java.util.List;

/**
 * Result type for get_call_context() tool.
 * Contains caller/callee relationships with their semantic summaries.
 */
public class CallContext {
    private final FunctionSummary center;
    private final List<ContextEntry> callers;
    private final List<ContextEntry> callees;

    public CallContext(FunctionSummary center, List<ContextEntry> callers, List<ContextEntry> callees) {
        this.center = center;
        this.callers = callers;
        this.callees = callees;
    }

    // Getters
    public FunctionSummary getCenter() { return center; }
    public List<ContextEntry> getCallers() { return callers; }
    public List<ContextEntry> getCallees() { return callees; }

    /**
     * Represents a brief function summary for context entries.
     */
    public static class FunctionSummary {
        private final String name;
        private final long address;
        private final String summary;
        private final List<String> securityFlags;

        public FunctionSummary(String name, long address, String summary, List<String> securityFlags) {
            this.name = name;
            this.address = address;
            this.summary = summary;
            this.securityFlags = securityFlags;
        }

        public String getName() { return name; }
        public long getAddress() { return address; }
        public String getSummary() { return summary; }
        public List<String> getSecurityFlags() { return securityFlags; }

        public String toToolOutput() {
            StringBuilder sb = new StringBuilder();
            sb.append("{\n");
            sb.append("    \"name\": \"").append(name).append("\",\n");
            sb.append("    \"address\": \"0x").append(Long.toHexString(address)).append("\",\n");
            sb.append("    \"summary\": \"").append(escapeJson(summary)).append("\"");
            if (securityFlags != null && !securityFlags.isEmpty()) {
                sb.append(",\n    \"security_flags\": [");
                for (int i = 0; i < securityFlags.size(); i++) {
                    if (i > 0) sb.append(", ");
                    sb.append("\"").append(securityFlags.get(i)).append("\"");
                }
                sb.append("]");
            }
            sb.append("\n  }");
            return sb.toString();
        }

        private String escapeJson(String s) {
            if (s == null) return "";
            return s.replace("\\", "\\\\")
                    .replace("\"", "\\\"")
                    .replace("\n", "\\n")
                    .replace("\r", "\\r")
                    .replace("\t", "\\t");
        }
    }

    /**
     * Represents a caller/callee entry with depth information.
     */
    public static class ContextEntry {
        private final int depth;
        private final FunctionSummary function;

        public ContextEntry(int depth, FunctionSummary function) {
            this.depth = depth;
            this.function = function;
        }

        public int getDepth() { return depth; }
        public FunctionSummary getFunction() { return function; }

        public String toToolOutput() {
            return "{ \"depth\": " + depth + ", \"function\": " + function.toToolOutput() + " }";
        }
    }

    /**
     * Direction for call context queries.
     */
    public enum Direction {
        CALLERS,
        CALLEES,
        BOTH
    }

    /**
     * Convert to JSON-like string for tool output.
     */
    public String toToolOutput() {
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        sb.append("  \"center\": ").append(center.toToolOutput()).append(",\n");

        sb.append("  \"callers\": [\n");
        for (int i = 0; i < callers.size(); i++) {
            if (i > 0) sb.append(",\n");
            sb.append("    ").append(callers.get(i).toToolOutput());
        }
        sb.append("\n  ],\n");

        sb.append("  \"callees\": [\n");
        for (int i = 0; i < callees.size(); i++) {
            if (i > 0) sb.append(",\n");
            sb.append("    ").append(callees.get(i).toToolOutput());
        }
        sb.append("\n  ]\n");

        sb.append("}");
        return sb.toString();
    }
}

```

`src/main/java/ghidrassist/graphrag/query/GlobalQueryResult.java`:

```java
package ghidrassist.graphrag.query;

import java.util.*;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

/**
 * Result of a global query across all communities in a binary.
 * Aggregates insights from all detected communities using map-reduce pattern.
 */
public class GlobalQueryResult {

    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    // Metadata
    private String binaryId;
    private int communityCount;
    private int totalFunctions;

    // Community results (ranked by security relevance, then size)
    private List<CommunityInsight> communities;

    // Aggregated findings
    private Map<String, Integer> securityFlagCounts;  // FLAG -> count across all communities
    private List<String> attackSurface;               // Entry points, dangerous functions
    private List<String> keyFindings;                 // Top insights

    public GlobalQueryResult(String binaryId) {
        this.binaryId = binaryId;
        this.communityCount = 0;
        this.totalFunctions = 0;
        this.communities = new ArrayList<>();
        this.securityFlagCounts = new HashMap<>();
        this.attackSurface = new ArrayList<>();
        this.keyFindings = new ArrayList<>();
    }

    // Nested class for per-community insights
    public static class CommunityInsight {
        private String communityId;
        private String communityName;
        private int memberCount;
        private List<String> keyFunctions;      // Top functions (named, security-relevant)
        private List<String> securityFlags;     // Aggregated from members
        private String summary;                 // Community summary if available
        private int securityScore;              // For ranking

        public CommunityInsight(String communityId, String communityName) {
            this.communityId = communityId;
            this.communityName = communityName;
            this.memberCount = 0;
            this.keyFunctions = new ArrayList<>();
            this.securityFlags = new ArrayList<>();
            this.summary = null;
            this.securityScore = 0;
        }

        // Getters and setters
        public String getCommunityId() { return communityId; }
        public void setCommunityId(String communityId) { this.communityId = communityId; }

        public String getCommunityName() { return communityName; }
        public void setCommunityName(String communityName) { this.communityName = communityName; }

        public int getMemberCount() { return memberCount; }
        public void setMemberCount(int memberCount) { this.memberCount = memberCount; }

        public List<String> getKeyFunctions() { return keyFunctions; }
        public void setKeyFunctions(List<String> keyFunctions) { this.keyFunctions = keyFunctions; }

        public List<String> getSecurityFlags() { return securityFlags; }
        public void setSecurityFlags(List<String> securityFlags) { this.securityFlags = securityFlags; }

        public String getSummary() { return summary; }
        public void setSummary(String summary) { this.summary = summary; }

        public int getSecurityScore() { return securityScore; }
        public void setSecurityScore(int securityScore) { this.securityScore = securityScore; }

        public void addKeyFunction(String function) {
            if (!keyFunctions.contains(function)) {
                keyFunctions.add(function);
            }
        }

        public void addSecurityFlag(String flag) {
            if (!securityFlags.contains(flag)) {
                securityFlags.add(flag);
            }
        }
    }

    // Getters and setters
    public String getBinaryId() { return binaryId; }
    public void setBinaryId(String binaryId) { this.binaryId = binaryId; }

    public int getCommunityCount() { return communityCount; }
    public void setCommunityCount(int communityCount) { this.communityCount = communityCount; }

    public int getTotalFunctions() { return totalFunctions; }
    public void setTotalFunctions(int totalFunctions) { this.totalFunctions = totalFunctions; }

    public List<CommunityInsight> getCommunities() { return communities; }
    public void setCommunities(List<CommunityInsight> communities) { this.communities = communities; }

    public Map<String, Integer> getSecurityFlagCounts() { return securityFlagCounts; }
    public void setSecurityFlagCounts(Map<String, Integer> securityFlagCounts) {
        this.securityFlagCounts = securityFlagCounts;
    }

    public List<String> getAttackSurface() { return attackSurface; }
    public void setAttackSurface(List<String> attackSurface) { this.attackSurface = attackSurface; }

    public List<String> getKeyFindings() { return keyFindings; }
    public void setKeyFindings(List<String> keyFindings) { this.keyFindings = keyFindings; }

    // Mutators
    public void addCommunity(CommunityInsight insight) {
        communities.add(insight);
        communityCount = communities.size();
    }

    public void incrementSecurityFlag(String flag) {
        securityFlagCounts.merge(flag, 1, Integer::sum);
    }

    public void addAttackSurfaceFunction(String function) {
        if (!attackSurface.contains(function)) {
            attackSurface.add(function);
        }
    }

    public void addKeyFinding(String finding) {
        keyFindings.add(finding);
    }

    /**
     * Generate formatted output for tool response.
     *
     * @param includeMembers If true, include full member lists for each community
     * @return JSON-formatted string
     */
    public String toToolOutput(boolean includeMembers) {
        Map<String, Object> output = new LinkedHashMap<>();

        // Metadata
        output.put("binary_id", binaryId);
        output.put("community_count", communityCount);
        output.put("total_functions", totalFunctions);

        // Security summary (sorted by count descending)
        if (!securityFlagCounts.isEmpty()) {
            Map<String, Integer> sortedFlags = new LinkedHashMap<>();
            securityFlagCounts.entrySet().stream()
                .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
                .forEach(e -> sortedFlags.put(e.getKey(), e.getValue()));
            output.put("security_summary", sortedFlags);
        }

        // Attack surface
        if (!attackSurface.isEmpty()) {
            output.put("attack_surface", attackSurface);
        }

        // Communities (limit details for large outputs)
        List<Map<String, Object>> communityList = new ArrayList<>();
        for (CommunityInsight insight : communities) {
            Map<String, Object> comm = new LinkedHashMap<>();
            comm.put("name", insight.getCommunityName());
            comm.put("member_count", insight.getMemberCount());

            if (!insight.getSecurityFlags().isEmpty()) {
                comm.put("security_flags", insight.getSecurityFlags());
            }

            // Only include key functions (top 5) unless includeMembers is true
            List<String> funcs = insight.getKeyFunctions();
            if (!funcs.isEmpty()) {
                if (includeMembers) {
                    comm.put("key_functions", funcs);
                } else {
                    comm.put("key_functions", funcs.subList(0, Math.min(5, funcs.size())));
                }
            }

            if (insight.getSummary() != null) {
                comm.put("summary", insight.getSummary());
            }

            communityList.add(comm);
        }
        output.put("communities", communityList);

        // Key findings
        if (!keyFindings.isEmpty()) {
            output.put("key_findings", keyFindings);
        }

        return GSON.toJson(output);
    }

    /**
     * Simple toString for logging.
     */
    @Override
    public String toString() {
        return String.format("GlobalQueryResult[binary=%s, communities=%d, functions=%d]",
                binaryId, communityCount, totalFunctions);
    }
}

```

`src/main/java/ghidrassist/graphrag/query/ModuleSummary.java`:

```java
package ghidrassist.graphrag.query;

import java.util.List;

/**
 * Result type for get_module_summary() tool.
 * Contains community/module summary for a group of related functions.
 */
public class ModuleSummary {
    private final String moduleId;
    private final String moduleName;
    private final String moduleSummary;         // Pre-computed community summary
    private final List<String> memberFunctions; // All functions in this module
    private final List<String> keyFunctions;    // Most important functions
    private final String securityRelevance;     // Security notes for this module
    private final int level;                    // Hierarchy level (0 = leaf, higher = more abstract)
    private final int memberCount;

    public ModuleSummary(String moduleId, String moduleName, String moduleSummary,
                         List<String> memberFunctions, List<String> keyFunctions,
                         String securityRelevance, int level) {
        this.moduleId = moduleId;
        this.moduleName = moduleName;
        this.moduleSummary = moduleSummary;
        this.memberFunctions = memberFunctions;
        this.keyFunctions = keyFunctions;
        this.securityRelevance = securityRelevance;
        this.level = level;
        this.memberCount = memberFunctions != null ? memberFunctions.size() : 0;
    }

    /**
     * Create a "not found" result when function isn't part of any community.
     */
    public static ModuleSummary notFound(String functionName) {
        return new ModuleSummary(
            null,
            null,
            "Function '" + functionName + "' is not part of any detected community. " +
            "Run community detection to cluster functions into modules.",
            List.of(),
            List.of(),
            null,
            -1
        );
    }

    // Getters
    public String getModuleId() { return moduleId; }
    public String getModuleName() { return moduleName; }
    public String getModuleSummary() { return moduleSummary; }
    public List<String> getMemberFunctions() { return memberFunctions; }
    public List<String> getKeyFunctions() { return keyFunctions; }
    public String getSecurityRelevance() { return securityRelevance; }
    public int getLevel() { return level; }
    public int getMemberCount() { return memberCount; }

    /**
     * Convert to JSON-like string for tool output.
     */
    public String toToolOutput() {
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");

        if (moduleId == null) {
            // Not found case
            sb.append("  \"found\": false,\n");
            sb.append("  \"message\": \"").append(escapeJson(moduleSummary)).append("\"\n");
        } else {
            sb.append("  \"found\": true,\n");
            sb.append("  \"module_id\": \"").append(moduleId).append("\",\n");
            if (moduleName != null) {
                sb.append("  \"module_name\": \"").append(escapeJson(moduleName)).append("\",\n");
            }
            sb.append("  \"level\": ").append(level).append(",\n");
            sb.append("  \"member_count\": ").append(memberCount).append(",\n");

            if (moduleSummary != null) {
                sb.append("  \"module_summary\": \"").append(escapeJson(moduleSummary)).append("\",\n");
            }

            // Key functions (limited to top 10)
            sb.append("  \"key_functions\": [");
            if (keyFunctions != null) {
                int limit = Math.min(keyFunctions.size(), 10);
                for (int i = 0; i < limit; i++) {
                    if (i > 0) sb.append(", ");
                    sb.append("\"").append(escapeJson(keyFunctions.get(i))).append("\"");
                }
            }
            sb.append("],\n");

            // Member functions (limited to top 20)
            sb.append("  \"member_functions\": [");
            if (memberFunctions != null) {
                int limit = Math.min(memberFunctions.size(), 20);
                for (int i = 0; i < limit; i++) {
                    if (i > 0) sb.append(", ");
                    sb.append("\"").append(escapeJson(memberFunctions.get(i))).append("\"");
                }
                if (memberFunctions.size() > 20) {
                    sb.append(", \"... and ").append(memberFunctions.size() - 20).append(" more\"");
                }
            }
            sb.append("]");

            if (securityRelevance != null && !securityRelevance.isEmpty()) {
                sb.append(",\n  \"security_relevance\": \"").append(escapeJson(securityRelevance)).append("\"");
            }
            sb.append("\n");
        }

        sb.append("}");
        return sb.toString();
    }

    private String escapeJson(String s) {
        if (s == null) return "";
        return s.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }
}

```

`src/main/java/ghidrassist/graphrag/query/SearchResult.java`:

```java
package ghidrassist.graphrag.query;

import java.util.List;

/**
 * Result type for search_semantic() tool.
 * Represents a search result from FTS5 on pre-computed summaries.
 */
public class SearchResult {
    private final String name;
    private final long address;
    private final String summary;
    private final float relevanceScore;
    private final String matchType;  // "fts_match", "embedding_match", etc.
    private final String matchedText;  // The portion of summary that matched

    public SearchResult(String name, long address, String summary,
                        float relevanceScore, String matchType, String matchedText) {
        this.name = name;
        this.address = address;
        this.summary = summary;
        this.relevanceScore = relevanceScore;
        this.matchType = matchType;
        this.matchedText = matchedText;
    }

    // Getters
    public String getName() { return name; }
    public long getAddress() { return address; }
    public String getSummary() { return summary; }
    public float getRelevanceScore() { return relevanceScore; }
    public String getMatchType() { return matchType; }
    public String getMatchedText() { return matchedText; }

    /**
     * Convert to JSON-like string for tool output.
     */
    public String toToolOutput() {
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        sb.append("  \"name\": \"").append(name).append("\",\n");
        sb.append("  \"address\": \"0x").append(Long.toHexString(address)).append("\",\n");
        sb.append("  \"summary\": \"").append(escapeJson(summary)).append("\",\n");
        sb.append("  \"relevance_score\": ").append(relevanceScore).append(",\n");
        sb.append("  \"match_type\": \"").append(matchType).append("\"");
        if (matchedText != null && !matchedText.isEmpty()) {
            sb.append(",\n  \"matched_text\": \"").append(escapeJson(matchedText)).append("\"");
        }
        sb.append("\n}");
        return sb.toString();
    }

    private String escapeJson(String s) {
        if (s == null) return "";
        return s.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }

    /**
     * Convert list of results to tool output.
     */
    public static String listToToolOutput(List<SearchResult> results) {
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        sb.append("  \"count\": ").append(results.size()).append(",\n");
        sb.append("  \"results\": [\n");
        for (int i = 0; i < results.size(); i++) {
            if (i > 0) sb.append(",\n");
            // Indent the result output
            String resultOutput = results.get(i).toToolOutput();
            String indented = resultOutput.replace("\n", "\n    ");
            sb.append("    ").append(indented);
        }
        sb.append("\n  ]\n");
        sb.append("}");
        return sb.toString();
    }
}

```

`src/main/java/ghidrassist/graphrag/query/SecurityAnalysis.java`:

```java
package ghidrassist.graphrag.query;

import java.util.List;

/**
 * Result type for get_security_analysis() tool.
 * Contains security flags, taint paths, and attack surface information.
 */
public class SecurityAnalysis {
    private final String scopeType;  // "function" or "binary"
    private final String scopeName;  // Function name or binary name
    private final List<String> securityFlags;
    private final List<TaintPath> taintPaths;
    private final List<String> attackSurface;      // Entry points, external interfaces
    private final List<String> vulnerableCallers;  // Functions that call vulnerable code

    public SecurityAnalysis(String scopeType, String scopeName, List<String> securityFlags,
                            List<TaintPath> taintPaths, List<String> attackSurface,
                            List<String> vulnerableCallers) {
        this.scopeType = scopeType;
        this.scopeName = scopeName;
        this.securityFlags = securityFlags;
        this.taintPaths = taintPaths;
        this.attackSurface = attackSurface;
        this.vulnerableCallers = vulnerableCallers;
    }

    // Getters
    public String getScopeType() { return scopeType; }
    public String getScopeName() { return scopeName; }
    public List<String> getSecurityFlags() { return securityFlags; }
    public List<TaintPath> getTaintPaths() { return taintPaths; }
    public List<String> getAttackSurface() { return attackSurface; }
    public List<String> getVulnerableCallers() { return vulnerableCallers; }

    /**
     * Check if any security issues were found.
     */
    public boolean hasSecurityIssues() {
        return (securityFlags != null && !securityFlags.isEmpty()) ||
               (taintPaths != null && !taintPaths.isEmpty());
    }

    /**
     * Represents a taint propagation path from source to sink.
     */
    public static class TaintPath {
        private final String source;      // Source function (user input, network read, etc.)
        private final String sink;        // Sink function (strcpy, system, etc.)
        private final List<String> path;  // Path of functions between source and sink

        public TaintPath(String source, String sink, List<String> path) {
            this.source = source;
            this.sink = sink;
            this.path = path;
        }

        public String getSource() { return source; }
        public String getSink() { return sink; }
        public List<String> getPath() { return path; }

        public String toToolOutput() {
            StringBuilder sb = new StringBuilder();
            sb.append("{\n");
            sb.append("      \"source\": \"").append(source).append("\",\n");
            sb.append("      \"sink\": \"").append(sink).append("\",\n");
            sb.append("      \"path\": [");
            for (int i = 0; i < path.size(); i++) {
                if (i > 0) sb.append(", ");
                sb.append("\"").append(path.get(i)).append("\"");
            }
            sb.append("]\n");
            sb.append("    }");
            return sb.toString();
        }
    }

    /**
     * Convert to JSON-like string for tool output.
     */
    public String toToolOutput() {
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        sb.append("  \"scope_type\": \"").append(scopeType).append("\",\n");
        sb.append("  \"scope_name\": \"").append(scopeName).append("\",\n");

        // Security flags
        sb.append("  \"security_flags\": [");
        if (securityFlags != null) {
            for (int i = 0; i < securityFlags.size(); i++) {
                if (i > 0) sb.append(", ");
                sb.append("\"").append(securityFlags.get(i)).append("\"");
            }
        }
        sb.append("],\n");

        // Taint paths
        sb.append("  \"taint_paths\": [\n");
        if (taintPaths != null) {
            for (int i = 0; i < taintPaths.size(); i++) {
                if (i > 0) sb.append(",\n");
                sb.append("    ").append(taintPaths.get(i).toToolOutput());
            }
        }
        sb.append("\n  ],\n");

        // Attack surface
        sb.append("  \"attack_surface\": [");
        if (attackSurface != null) {
            for (int i = 0; i < attackSurface.size(); i++) {
                if (i > 0) sb.append(", ");
                sb.append("\"").append(attackSurface.get(i)).append("\"");
            }
        }
        sb.append("],\n");

        // Vulnerable callers
        sb.append("  \"vulnerable_callers\": [");
        if (vulnerableCallers != null) {
            for (int i = 0; i < vulnerableCallers.size(); i++) {
                if (i > 0) sb.append(", ");
                sb.append("\"").append(vulnerableCallers.get(i)).append("\"");
            }
        }
        sb.append("]\n");

        sb.append("}");
        return sb.toString();
    }
}

```

`src/main/java/ghidrassist/graphrag/query/SemanticAnalysis.java`:

```java
package ghidrassist.graphrag.query;

import java.util.List;

/**
 * Result type for get_semantic_analysis() tool.
 * Contains pre-computed LLM analysis retrieved from the graph (NO LLM call at query time).
 */
public class SemanticAnalysis {
    private final String name;
    private final long address;
    private final String summary;           // Pre-computed by LLM during indexing
    private final List<String> securityFlags;
    private final String category;          // "crypto", "network", "auth", etc.
    private final float confidence;
    private final List<String> callers;
    private final List<String> callees;
    private final String community;         // Module/subsystem this belongs to
    private final String rawCode;           // Cached decompiled code
    private final boolean indexed;          // Whether this function has been indexed

    public SemanticAnalysis(String name, long address, String summary, List<String> securityFlags,
                            String category, float confidence, List<String> callers,
                            List<String> callees, String community, String rawCode, boolean indexed) {
        this.name = name;
        this.address = address;
        this.summary = summary;
        this.securityFlags = securityFlags;
        this.category = category;
        this.confidence = confidence;
        this.callers = callers;
        this.callees = callees;
        this.community = community;
        this.rawCode = rawCode;
        this.indexed = indexed;
    }

    /**
     * Create an "not indexed" result when function hasn't been analyzed yet.
     */
    public static SemanticAnalysis notIndexed(String name, long address) {
        return new SemanticAnalysis(name, address, null, List.of(), null, 0.0f,
                List.of(), List.of(), null, null, false);
    }

    // Getters
    public String getName() { return name; }
    public long getAddress() { return address; }
    public String getSummary() { return summary; }
    public List<String> getSecurityFlags() { return securityFlags; }
    public String getCategory() { return category; }
    public float getConfidence() { return confidence; }
    public List<String> getCallers() { return callers; }
    public List<String> getCallees() { return callees; }
    public String getCommunity() { return community; }
    public String getRawCode() { return rawCode; }
    public boolean isIndexed() { return indexed; }

    /**
     * Check if this function has security concerns flagged.
     */
    public boolean hasSecurityConcerns() {
        return securityFlags != null && !securityFlags.isEmpty();
    }

    /**
     * Check if we have any useful data (structure or semantic).
     */
    public boolean hasData() {
        return rawCode != null || (callers != null && !callers.isEmpty()) ||
               (callees != null && !callees.isEmpty());
    }

    /**
     * Check if we have LLM-generated semantic analysis.
     */
    public boolean hasSemanticAnalysis() {
        return summary != null && !summary.isEmpty();
    }

    /**
     * Convert to JSON-like string for tool output.
     * Shows all available data, even if LLM summary is not yet generated.
     */
    public String toToolOutput() {
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        sb.append("  \"name\": \"").append(name).append("\",\n");
        sb.append("  \"address\": \"0x").append(Long.toHexString(address)).append("\",\n");
        sb.append("  \"has_semantic_analysis\": ").append(hasSemanticAnalysis()).append(",\n");
        sb.append("  \"has_structure_data\": ").append(hasData()).append(",\n");

        // Always show available data
        if (hasData() || hasSemanticAnalysis()) {
            // Show LLM summary if available
            if (summary != null && !summary.isEmpty()) {
                sb.append("  \"summary\": \"").append(escapeJson(summary)).append("\",\n");
            } else {
                sb.append("  \"summary\": \"(LLM analysis pending - structure data available below)\",\n");
            }

            // Security flags
            sb.append("  \"security_flags\": ").append(listToJson(securityFlags)).append(",\n");

            // Category if available
            if (category != null) {
                sb.append("  \"category\": \"").append(category).append("\",\n");
            }

            // Confidence
            sb.append("  \"confidence\": ").append(confidence).append(",\n");

            // Callers and callees - always show
            sb.append("  \"callers\": ").append(listToJson(callers)).append(",\n");
            sb.append("  \"callees\": ").append(listToJson(callees)).append(",\n");

            // Community if available
            if (community != null) {
                sb.append("  \"community\": \"").append(community).append("\",\n");
            }

            // Raw code - always show if available
            if (rawCode != null) {
                // Truncate raw code for tool output
                String truncated = rawCode.length() > 2000
                    ? rawCode.substring(0, 2000) + "\n// ... (truncated)"
                    : rawCode;
                sb.append("  \"raw_code\": \"").append(escapeJson(truncated)).append("\"\n");
            } else {
                sb.append("  \"raw_code\": null\n");
            }
        } else {
            sb.append("  \"message\": \"Function not found in graph. Lazy indexing may have failed.\"\n");
        }

        sb.append("}");
        return sb.toString();
    }

    private String escapeJson(String s) {
        if (s == null) return "";
        return s.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }

    private String listToJson(List<String> list) {
        if (list == null || list.isEmpty()) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < list.size(); i++) {
            if (i > 0) sb.append(", ");
            sb.append("\"").append(escapeJson(list.get(i))).append("\"");
        }
        sb.append("]");
        return sb.toString();
    }
}

```

`src/main/java/ghidrassist/graphrag/query/SemanticQueryTools.java`:

```java
package ghidrassist.graphrag.query;

import com.google.gson.Gson;
import com.google.gson.JsonObject;

import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.FunctionManager;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import ghidra.util.task.TaskMonitor;

import ghidrassist.AnalysisDB;
import ghidrassist.graphrag.BinaryKnowledgeGraph;
import ghidrassist.graphrag.GraphRAGEngine;
import ghidrassist.graphrag.GraphRAGService;
import ghidrassist.graphrag.analysis.TaintAnalyzer;
import ghidrassist.graphrag.extraction.SecurityFeatureExtractor;
import ghidrassist.graphrag.extraction.SecurityFeatures;
import ghidrassist.graphrag.extraction.StructureExtractor;
import ghidrassist.graphrag.nodes.KnowledgeNode;
import ghidrassist.mcp2.tools.MCPTool;
import ghidrassist.mcp2.tools.MCPToolResult;
import ghidrassist.services.symgraph.SymGraphUtils;

import ghidra.program.model.symbol.Reference;
import ghidra.program.model.symbol.ReferenceIterator;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

/**
 * Provides built-in LLM-free semantic query tools for the Graph-RAG system.
 *
 * These tools are executed locally (no MCP server required) and return
 * pre-computed semantic analysis from the knowledge graph.
 *
 * All tool executions are LLM-free - they only perform graph traversal
 * and database lookups.
 */
public class SemanticQueryTools {

    private static final String SERVER_NAME = "GraphRAG-BuiltIn";
    private static final String TOOL_PREFIX = "ga_";
    @SuppressWarnings("unused")  // Reserved for future JSON serialization
    private static final Gson gson = new Gson();

    private final AnalysisDB analysisDB;
    private Program currentProgram;
    private BinaryKnowledgeGraph graph;
    private GraphRAGEngine engine;

    public SemanticQueryTools(AnalysisDB analysisDB) {
        this.analysisDB = analysisDB;
    }

    /**
     * Set the current program for tool execution.
     */
    public void setCurrentProgram(Program program) {
        this.currentProgram = program;
        if (program != null) {
            String programHash = program.getExecutableSHA256();
            this.graph = analysisDB.getKnowledgeGraph(programHash);
            this.engine = new GraphRAGEngine(graph);
        } else {
            this.graph = null;
            this.engine = null;
        }
    }

    /**
     * Check if tools are available (program must be set).
     */
    public boolean isAvailable() {
        return engine != null && currentProgram != null;
    }

    // ========================================
    // Tool Definitions
    // ========================================

    /**
     * Get all semantic query tools as MCPTool objects.
     * These can be registered with the tool manager.
     */
    public List<MCPTool> getToolDefinitions() {
        List<MCPTool> tools = new ArrayList<>();

        // 1. ga.get_semantic_analysis
        tools.add(createTool(
                TOOL_PREFIX + "get_semantic_analysis",
                "Get pre-computed semantic analysis for a function. Returns LLM-generated summary, " +
                "security flags, caller/callee relationships, and decompiled code. NO LLM call at query time.",
                createSchema(
                        Map.of(
                                "address", Map.of("type", "string", "description", "Function address (hex, e.g., '0x401000')"),
                                "function_name", Map.of("type", "string", "description", "Function name (alternative to address)")
                        ),
                        List.of() // Neither is strictly required, but one should be provided
                )
        ));

        // 2. ga.get_similar_functions
        tools.add(createTool(
                TOOL_PREFIX + "get_similar_functions",
                "Find functions similar to the specified function based on graph structure " +
                "(shared callers, shared callees, community membership, keyword matching). NO LLM call.",
                createSchema(
                        Map.of(
                                "address", Map.of("type", "string", "description", "Function address (hex)"),
                                "limit", Map.of("type", "integer", "description", "Maximum results (default: 10)")
                        ),
                        List.of("address")
                )
        ));

        // 3. ga.get_call_context
        tools.add(createTool(
                TOOL_PREFIX + "get_call_context",
                "Get caller and callee functions with their semantic summaries. " +
                "Useful for understanding function relationships. NO LLM call.",
                createSchema(
                        Map.of(
                                "address", Map.of("type", "string", "description", "Function address (hex)"),
                                "depth", Map.of("type", "integer", "description", "How many levels deep (default: 1)"),
                                "direction", Map.of("type", "string", "description", "callers, callees, or both (default: both)")
                        ),
                        List.of("address")
                )
        ));

        // 4. ga.get_security_analysis
        tools.add(createTool(
                TOOL_PREFIX + "get_security_analysis",
                "Get security analysis including vulnerability flags, taint paths, and attack surface. " +
                "Can analyze a single function or the entire binary. NO LLM call.",
                createSchema(
                        Map.of(
                                "address", Map.of("type", "string", "description", "Function address (hex, optional)"),
                                "scope", Map.of("type", "string", "description", "function or binary (default: function)")
                        ),
                        List.of()
                )
        ));

        // 5. ga.search_semantic
        tools.add(createTool(
                TOOL_PREFIX + "search_semantic",
                "Search for functions by semantic keywords in their pre-computed summaries. " +
                "Uses full-text search (FTS5) on cached LLM analysis. NO LLM call at query time.",
                createSchema(
                        Map.of(
                                "query", Map.of("type", "string", "description", "Search query (keywords, phrases)"),
                                "limit", Map.of("type", "integer", "description", "Maximum results (default: 20)")
                        ),
                        List.of("query")
                )
        ));

        // 6. ga.get_module_summary
        tools.add(createTool(
                TOOL_PREFIX + "get_module_summary",
                "Get the community/module summary for a function's containing subsystem. " +
                "Returns module-level semantic analysis. NO LLM call.",
                createSchema(
                        Map.of(
                                "address", Map.of("type", "string", "description", "Function address (hex)")
                        ),
                        List.of("address")
                )
        ));

        // 7. ga.get_activity_analysis
        tools.add(createTool(
                TOOL_PREFIX + "get_activity_analysis",
                "Get network and file I/O activity analysis for a function. " +
                "Returns detected API calls (socket, send, recv, fopen, etc.), " +
                "string references (IPs, URLs, file paths, domains), " +
                "activity profile (NETWORK_CLIENT, FILE_WRITER, etc.), and risk level. NO LLM call.",
                createSchema(
                        Map.of(
                                "address", Map.of("type", "string", "description", "Function address (hex)"),
                                "function_name", Map.of("type", "string", "description", "Function name (alternative to address)")
                        ),
                        List.of() // Neither required, but one should be provided
                )
        ));

        // 8. ga.update_security_flags
        tools.add(createTool(
                TOOL_PREFIX + "update_security_flags",
                "Update security vulnerability flags for functions. Analyzes functions to detect " +
                "dangerous function calls (strcpy, sprintf, system, etc.) and potential vulnerabilities " +
                "(buffer overflow, command injection, format string). Can update a single function or all functions. " +
                "NO LLM call - uses static analysis only.",
                createSchema(
                        Map.of(
                                "address", Map.of("type", "string", "description", "Function address (hex, optional - if omitted updates all)"),
                                "function_name", Map.of("type", "string", "description", "Function name (alternative to address)"),
                                "force", Map.of("type", "boolean", "description", "Force re-analysis even if flags exist (default: false)")
                        ),
                        List.of() // None required - omitting all updates entire binary
                )
        ));

        // 9. ga.index_binary - TEMPORARILY DISABLED (tool hidden from LLM but execution code preserved)
        // TODO: Re-enable when indexing stability is improved
        // tools.add(createTool(
        //         TOOL_PREFIX + "index_binary",
        //         "Trigger full binary indexing to populate the knowledge graph. Extracts all functions, " +
        //         "call graph, cross-references (REFERENCES edges), data dependencies (DATA_DEPENDS edges), " +
        //         "and vulnerable call edges (CALLS_VULNERABLE edges). This is required for comprehensive " +
        //         "graph queries. NO LLM call - uses Ghidra analysis only. May take time for large binaries.",
        //         createSchema(
        //                 Map.of(
        //                         "include_blocks", Map.of("type", "boolean", "description", "Include basic block extraction (increases graph size, default: false)"),
        //                         "force", Map.of("type", "boolean", "description", "Force re-indexing even if already indexed (default: false)")
        //                 ),
        //                 List.of() // None required
        //         )
        // ));

        // 10. ga.record_vulnerability
        tools.add(createTool(
                TOOL_PREFIX + "record_vulnerability",
                "Record a discovered vulnerability or security finding for a function. " +
                "Use this when you identify potential security issues like buffer overflows, " +
                "command injection, format string bugs, use-after-free, etc. during analysis. " +
                "This persists findings to the knowledge graph and propagates vulnerability markers to callers.",
                createSchema(
                        Map.of(
                                "address", Map.of("type", "string", "description", "Function address (hex)"),
                                "function_name", Map.of("type", "string", "description", "Function name (alternative to address)"),
                                "vulnerability_type", Map.of("type", "string", "description",
                                        "Type: BUFFER_OVERFLOW, COMMAND_INJECTION, FORMAT_STRING, USE_AFTER_FREE, " +
                                        "INTEGER_OVERFLOW, PATH_TRAVERSAL, SQL_INJECTION, RACE_CONDITION, " +
                                        "MEMORY_LEAK, NULL_DEREF, INFO_DISCLOSURE, AUTH_BYPASS, CRYPTO_WEAKNESS, OTHER"),
                                "severity", Map.of("type", "string", "description", "Severity: LOW, MEDIUM, HIGH, CRITICAL"),
                                "description", Map.of("type", "string", "description", "Brief description of the vulnerability"),
                                "evidence", Map.of("type", "string", "description", "Code snippet or reasoning that supports this finding")
                        ),
                        List.of("vulnerability_type", "severity", "description") // Required fields
                )
        ));

        // 11. ga.add_security_flag
        tools.add(createTool(
                TOOL_PREFIX + "add_security_flag",
                "Add a security-relevant flag to a function's node in the knowledge graph. " +
                "Use this to mark functions with security-relevant properties you discover during analysis. " +
                "Common flags: HANDLES_USER_INPUT, PARSES_NETWORK_DATA, CRYPTO_OPERATION, " +
                "PRIVILEGE_CHECK, AUTHENTICATION, SENSITIVE_DATA, MEMORY_ALLOCATOR, ERROR_HANDLER",
                createSchema(
                        Map.of(
                                "address", Map.of("type", "string", "description", "Function address (hex)"),
                                "function_name", Map.of("type", "string", "description", "Function name (alternative to address)"),
                                "flag", Map.of("type", "string", "description", "Security flag to add (e.g., HANDLES_USER_INPUT)")
                        ),
                        List.of("flag") // flag is required
                )
        ));

        // 12. ga.detect_communities
        tools.add(createTool(
                TOOL_PREFIX + "detect_communities",
                "Run community detection on the function call graph to cluster related functions into modules. " +
                "Uses Label Propagation algorithm to identify communities based on call relationships. " +
                "Results are stored in the knowledge graph for use by ga_get_module_summary. NO LLM call.",
                createSchema(
                        Map.of(
                                "min_size", Map.of("type", "integer", "description", "Minimum community size (default: 2). Smaller communities are merged."),
                                "force", Map.of("type", "boolean", "description", "Force re-detection even if communities exist (default: false)")
                        ),
                        List.of() // None required
                )
        ));

        // 13. ga.global_query
        tools.add(createTool(
                TOOL_PREFIX + "global_query",
                "Get binary-wide analysis by aggregating insights across all detected communities. " +
                "Returns attack surface summary, security flag distribution across communities, " +
                "key functions per community, and cross-community patterns. " +
                "Requires community detection to have run first (use ga_detect_communities). NO LLM call.",
                createSchema(
                        Map.of(
                                "community_level", Map.of("type", "integer", "description", "Community level to query (default: 0 = function communities)"),
                                "include_members", Map.of("type", "boolean", "description", "Include full member function lists for each community (default: false)")
                        ),
                        List.of() // None required
                )
        ));

        // 14. ga.find_taint_paths - TEMPORARILY DISABLED (tool hidden from LLM but execution code preserved)
        // TODO: Re-enable when taint analysis is stable
        // tools.add(createTool(
        //         TOOL_PREFIX + "find_taint_paths",
        //         "Find data flow paths from taint sources (network input, file reads, user input) " +
        //         "to taint sinks (dangerous functions like strcpy, system, sprintf). " +
        //         "Identifies potential vulnerability chains where untrusted data flows to dangerous operations. " +
        //         "Can optionally create TAINT_FLOWS_TO edges in the graph. NO LLM call.",
        //         createSchema(
        //                 Map.of(
        //                         "source_address", Map.of("type", "string", "description", "Optional: Find paths from this specific source function (hex address)"),
        //                         "sink_address", Map.of("type", "string", "description", "Optional: Find paths to this specific sink function (hex address)"),
        //                         "max_paths", Map.of("type", "integer", "description", "Maximum number of paths to return (default: 20)"),
        //                         "create_edges", Map.of("type", "boolean", "description", "Create TAINT_FLOWS_TO edges along found paths (default: false)")
        //                 ),
        //                 List.of() // None required
        //         )
        // ));

        // 15. ga.create_edge
        tools.add(createTool(
                TOOL_PREFIX + "create_edge",
                "Create a semantic relationship edge between two functions based on your analysis. " +
                "Use this to record relationships you discover during code review that aren't captured " +
                "by the structural call graph. Edge types: SIMILAR_PURPOSE (functions with similar behavior), " +
                "RELATED_TO (general semantic relationship), DEPENDS_ON (functional dependency), " +
                "IMPLEMENTS (implements a concept like 'authentication' or 'encryption'). " +
                "Edges are persisted to the knowledge graph. NO LLM call.",
                createSchema(
                        Map.of(
                                "source_address", Map.of("type", "string", "description", "Source function address (hex)"),
                                "source_name", Map.of("type", "string", "description", "Source function name (alternative to address)"),
                                "target_address", Map.of("type", "string", "description", "Target function address (hex)"),
                                "target_name", Map.of("type", "string", "description", "Target function name (alternative to address)"),
                                "edge_type", Map.of("type", "string", "description",
                                        "Edge type: SIMILAR_PURPOSE, RELATED_TO, DEPENDS_ON, IMPLEMENTS"),
                                "confidence", Map.of("type", "number", "description", "Confidence score 0.0-1.0 (default: 0.8)"),
                                "reason", Map.of("type", "string", "description", "Brief explanation of the relationship")
                        ),
                        List.of("edge_type") // edge_type is required
                )
        ));

        return tools;
    }

    // ========================================
    // Tool Execution
    // ========================================

    /**
     * Execute a semantic query tool.
     *
     * @param toolName Name of the tool
     * @param arguments Tool arguments as JSON object
     * @return Tool result
     */
    public CompletableFuture<MCPToolResult> executeTool(String toolName, JsonObject arguments) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                if (!isAvailable()) {
                    return MCPToolResult.error("No program loaded or Graph-RAG not initialized");
                }

                // Switch on the full prefixed name (case-insensitive)
                String lowerName = toolName.toLowerCase();
                switch (lowerName) {
                    case "ga_get_semantic_analysis":
                        return executeGetSemanticAnalysis(arguments);
                    case "ga_get_similar_functions":
                        return executeGetSimilarFunctions(arguments);
                    case "ga_get_call_context":
                        return executeGetCallContext(arguments);
                    case "ga_get_security_analysis":
                        return executeGetSecurityAnalysis(arguments);
                    case "ga_search_semantic":
                        return executeSearchSemantic(arguments);
                    case "ga_get_module_summary":
                        return executeGetModuleSummary(arguments);
                    case "ga_get_activity_analysis":
                        return executeGetActivityAnalysis(arguments);
                    case "ga_update_security_flags":
                        return executeUpdateSecurityFlags(arguments);
                    case "ga_index_binary":
                        return executeIndexBinary(arguments);
                    case "ga_record_vulnerability":
                        return executeRecordVulnerability(arguments);
                    case "ga_add_security_flag":
                        return executeAddSecurityFlag(arguments);
                    case "ga_detect_communities":
                        return executeDetectCommunities(arguments);
                    case "ga_global_query":
                        return executeGlobalQuery(arguments);
                    case "ga_find_taint_paths":
                        return executeFindTaintPaths(arguments);
                    case "ga_create_edge":
                        return executeCreateEdge(arguments);
                    case "ga_refresh_names":
                        return executeRefreshNames(arguments);
                    default:
                        return MCPToolResult.error("Unknown tool: " + toolName);
                }
            } catch (Exception e) {
                Msg.error(this, "Tool execution failed: " + e.getMessage(), e);
                return MCPToolResult.error("Tool execution failed: " + e.getMessage());
            }
        });
    }

    /**
     * Check if this class handles the given tool.
     */
    public boolean handlesTool(String toolName) {
        if (toolName == null) return false;
        String lowerName = toolName.toLowerCase();
        return lowerName.equals("ga_get_semantic_analysis") ||
               lowerName.equals("ga_get_similar_functions") ||
               lowerName.equals("ga_get_call_context") ||
               lowerName.equals("ga_get_security_analysis") ||
               lowerName.equals("ga_search_semantic") ||
               lowerName.equals("ga_get_module_summary") ||
               lowerName.equals("ga_get_activity_analysis") ||
               lowerName.equals("ga_update_security_flags") ||
               lowerName.equals("ga_index_binary") ||
               lowerName.equals("ga_record_vulnerability") ||
               lowerName.equals("ga_add_security_flag") ||
               lowerName.equals("ga_detect_communities") ||
               lowerName.equals("ga_global_query") ||
               lowerName.equals("ga_find_taint_paths") ||
               lowerName.equals("ga_create_edge") ||
               lowerName.equals("ga_refresh_names");
    }

    // ========================================
    // Individual Tool Implementations
    // ========================================

    private MCPToolResult executeGetSemanticAnalysis(JsonObject arguments) {
        SemanticAnalysis result;
        long address = 0;
        String functionName = null;

        if (arguments.has("address")) {
            address = parseAddress(arguments.get("address").getAsString());
            Msg.info(this, "get_semantic_analysis: Looking up address 0x" + Long.toHexString(address));
            result = engine.getSemanticAnalysis(address);
        } else if (arguments.has("function_name")) {
            functionName = arguments.get("function_name").getAsString();
            Msg.info(this, "get_semantic_analysis: Looking up function name: " + functionName);
            result = engine.getSemanticAnalysis(functionName);
        } else {
            return MCPToolResult.error("Either 'address' or 'function_name' is required");
        }

        Msg.info(this, "get_semantic_analysis: Initial result - indexed=" + result.isIndexed() +
                ", hasData=" + result.hasData() + ", hasSemantic=" + result.hasSemanticAnalysis() +
                ", name=" + result.getName());

        // Determine what actions are needed
        boolean needsStructureIndexing = !result.isIndexed();
        boolean needsSemanticAnalysis = !result.hasSemanticAnalysis();

        Function func = null;
        if (needsStructureIndexing || needsSemanticAnalysis) {
            func = lookupFunction(address, functionName);
        }

        // If not indexed at all, trigger structure extraction first
        if (needsStructureIndexing) {
            Msg.info(this, "Function not indexed, triggering lazy indexing...");
            if (func != null) {
                Msg.info(this, "Found function in Ghidra: " + func.getName() + " at 0x" +
                        Long.toHexString(func.getEntryPoint().getOffset()));
                boolean indexed = indexFunctionOnDemand(func);
                if (indexed) {
                    // Retry the query after indexing
                    long funcAddress = func.getEntryPoint().getOffset();
                    result = engine.getSemanticAnalysis(funcAddress);
                    Msg.info(this, "Lazy indexing complete for: " + func.getName() +
                            " - result indexed=" + result.isIndexed() +
                            ", hasData=" + result.hasData() +
                            ", rawCode=" + (result.getRawCode() != null ? "present" : "null"));
                }
            } else {
                Msg.warn(this, "Could not find function in Ghidra for address 0x" +
                        Long.toHexString(address) + " or name: " + functionName);
            }
        }
        // If indexed but missing semantic analysis, queue for background LLM processing
        else if (needsSemanticAnalysis && func != null) {
            Msg.info(this, "Function indexed but missing LLM summary, queueing for semantic analysis...");
            queueFunctionForSemanticAnalysis(func);
        }

        // Auto-detect and update missing security flags, edges, and stale names
        if (func == null) {
            func = lookupFunction(address, functionName);
        }
        if (func != null) {
            ensureNodeNameFresh(func);
            ensureSecurityFlags(func);
            ensureFunctionEdges(func);
        }

        String output = result.toToolOutput();
        Msg.debug(this, "get_semantic_analysis: Returning output length=" + output.length());
        return MCPToolResult.success(output);
    }

    /**
     * Look up a function by address or name.
     */
    private Function lookupFunction(long address, String functionName) {
        if (currentProgram == null) {
            return null;
        }

        FunctionManager funcMgr = currentProgram.getFunctionManager();

        // Try by address first
        if (address != 0) {
            Address addr = currentProgram.getAddressFactory().getDefaultAddressSpace().getAddress(address);
            Function func = funcMgr.getFunctionAt(addr);
            if (func == null) {
                func = funcMgr.getFunctionContaining(addr);
            }
            if (func != null) {
                return func;
            }
        }

        // Try by name
        if (functionName != null && !functionName.isEmpty()) {
            for (Function func : funcMgr.getFunctions(true)) {
                if (functionName.equals(func.getName())) {
                    return func;
                }
            }
        }

        return null;
    }

    /**
     * Index a single function on-demand (lazy indexing).
     * This performs structure extraction and queues the function for background LLM summarization.
     * Also queues neighbor functions (callers/callees) for background indexing (depth=1).
     *
     * @param function The function to index
     * @return true if indexing succeeded
     */
    private boolean indexFunctionOnDemand(Function function) {
        if (function == null || graph == null || currentProgram == null) {
            return false;
        }

        try {
            StructureExtractor extractor = new StructureExtractor(currentProgram, graph, TaskMonitor.DUMMY);
            try {
                // Extract just this one function - returns KnowledgeNode or null
                ghidrassist.graphrag.nodes.KnowledgeNode node = extractor.extractFunction(function);
                if (node != null) {
                    long address = function.getEntryPoint().getOffset();
                    String programHash = currentProgram.getExecutableSHA256();

                    Msg.info(this, String.format("On-demand indexed function %s at 0x%x",
                            function.getName(), address));

                    // Queue this function for background LLM summarization
                    GraphRAGService service = GraphRAGService.getInstance(analysisDB);
                    service.setCurrentProgram(currentProgram);
                    service.queueForSemanticAnalysis(address, programHash);

                    // Queue neighbors (callers/callees) for background indexing (depth=1)
                    queueNeighbors(function, programHash, service);

                    return true;
                }
                return false;
            } finally {
                extractor.dispose();
            }
        } catch (Exception e) {
            Msg.error(this, "Failed to index function on-demand: " + e.getMessage(), e);
            return false;
        }
    }

    /**
     * Queue neighbor functions (callers and callees) for background indexing.
     * This implements depth=1 neighbor propagation.
     *
     * @param function The function whose neighbors to queue
     * @param programHash SHA256 hash of the program
     * @param service The GraphRAGService instance
     */
    private void queueNeighbors(Function function, String programHash, GraphRAGService service) {
        if (function == null || currentProgram == null) {
            return;
        }

        int neighborsQueued = 0;

        // Queue callers (functions that call this one)
        try {
            if (function.getSymbol() != null) {
                ReferenceIterator refIter = currentProgram.getReferenceManager()
                        .getReferencesTo(function.getEntryPoint());
                while (refIter.hasNext()) {
                    Reference ref = refIter.next();
                    if (ref.getReferenceType().isCall()) {
                        Function caller = currentProgram.getFunctionManager()
                                .getFunctionContaining(ref.getFromAddress());
                        if (caller != null) {
                            long callerAddr = caller.getEntryPoint().getOffset();
                            if (!graph.hasFunctionCached(callerAddr)) {
                                service.queueForSemanticAnalysis(callerAddr, programHash);
                                neighborsQueued++;
                            }
                        }
                    }
                }
            }
        } catch (Exception e) {
            Msg.warn(this, "Error queueing callers: " + e.getMessage());
        }

        // Queue callees (functions this one calls)
        try {
            for (Function callee : function.getCalledFunctions(TaskMonitor.DUMMY)) {
                long calleeAddr = callee.getEntryPoint().getOffset();
                if (!graph.hasFunctionCached(calleeAddr)) {
                    service.queueForSemanticAnalysis(calleeAddr, programHash);
                    neighborsQueued++;
                }
            }
        } catch (Exception e) {
            Msg.warn(this, "Error queueing callees: " + e.getMessage());
        }

        if (neighborsQueued > 0) {
            Msg.info(this, String.format("Queued %d neighbor functions for background analysis", neighborsQueued));
        }
    }

    /**
     * Queue a function for background semantic (LLM) analysis.
     * Used when a function is already indexed structurally but missing LLM summary.
     * Also queues neighbors that are missing semantic analysis.
     *
     * @param function The function to queue for semantic analysis
     */
    private void queueFunctionForSemanticAnalysis(Function function) {
        if (function == null || currentProgram == null) {
            return;
        }

        try {
            String programHash = currentProgram.getExecutableSHA256();
            long address = function.getEntryPoint().getOffset();

            GraphRAGService service = GraphRAGService.getInstance(analysisDB);
            service.setCurrentProgram(currentProgram);

            // Queue this function for LLM semantic analysis
            service.queueForSemanticAnalysis(address, programHash);
            Msg.info(this, String.format("Queued function %s (0x%x) for semantic analysis",
                    function.getName(), address));

            // Also queue neighbors that are missing semantic analysis
            queueNeighborsForSemanticAnalysis(function, programHash, service);
        } catch (Exception e) {
            Msg.error(this, "Failed to queue function for semantic analysis: " + e.getMessage(), e);
        }
    }

    /**
     * Queue neighbor functions (callers and callees) for semantic analysis
     * if they exist in the graph but are missing LLM summaries.
     *
     * @param function The function whose neighbors to check
     * @param programHash SHA256 hash of the program
     * @param service The GraphRAGService instance
     */
    private void queueNeighborsForSemanticAnalysis(Function function, String programHash, GraphRAGService service) {
        if (function == null || currentProgram == null || graph == null) {
            return;
        }

        int neighborsQueued = 0;

        // Check callers (functions that call this one)
        try {
            if (function.getSymbol() != null) {
                ReferenceIterator refIter = currentProgram.getReferenceManager()
                        .getReferencesTo(function.getEntryPoint());
                while (refIter.hasNext()) {
                    Reference ref = refIter.next();
                    if (ref.getReferenceType().isCall()) {
                        Function caller = currentProgram.getFunctionManager()
                                .getFunctionContaining(ref.getFromAddress());
                        if (caller != null) {
                            long callerAddr = caller.getEntryPoint().getOffset();
                            // Check if node exists but lacks semantic analysis
                            KnowledgeNode node = graph.getNodeByAddress(callerAddr);
                            if (node != null && !hasSemanticAnalysis(node)) {
                                service.queueForSemanticAnalysis(callerAddr, programHash);
                                neighborsQueued++;
                            }
                        }
                    }
                }
            }
        } catch (Exception e) {
            Msg.warn(this, "Error checking callers for semantic analysis: " + e.getMessage());
        }

        // Check callees (functions this one calls)
        try {
            for (Function callee : function.getCalledFunctions(TaskMonitor.DUMMY)) {
                long calleeAddr = callee.getEntryPoint().getOffset();
                // Check if node exists but lacks semantic analysis
                KnowledgeNode node = graph.getNodeByAddress(calleeAddr);
                if (node != null && !hasSemanticAnalysis(node)) {
                    service.queueForSemanticAnalysis(calleeAddr, programHash);
                    neighborsQueued++;
                }
            }
        } catch (Exception e) {
            Msg.warn(this, "Error checking callees for semantic analysis: " + e.getMessage());
        }

        if (neighborsQueued > 0) {
            Msg.info(this, String.format("Queued %d neighbors for semantic analysis", neighborsQueued));
        }
    }

    /**
     * Check if a node has semantic (LLM) analysis completed.
     *
     * @param node The knowledge node to check
     * @return true if the node has semantic analysis
     */
    private boolean hasSemanticAnalysis(KnowledgeNode node) {
        if (node == null) {
            return false;
        }
        // Check if the node has an LLM-generated summary
        String summary = node.getLlmSummary();
        return summary != null && !summary.isEmpty() && !summary.equals("pending");
    }

    /**
     * Ensure security flags are populated for a function.
     * If the function node exists but has no security flags, triggers security analysis.
     *
     * @param function The function to check and update
     */
    private void ensureSecurityFlags(Function function) {
        if (function == null || graph == null || currentProgram == null) {
            return;
        }

        try {
            GraphRAGService service = GraphRAGService.getInstance(analysisDB);
            service.setCurrentProgram(currentProgram);

            if (service.needsSecurityFlagsUpdate(function)) {
                Msg.debug(this, "Auto-updating security flags for: " + function.getName());
                service.updateSecurityFlags(function, TaskMonitor.DUMMY);
            }
        } catch (Exception e) {
            Msg.debug(this, "Failed to auto-update security flags: " + e.getMessage());
        }
    }

    /**
     * Ensure all edge types are extracted for a function.
     * If the function node exists but is missing new edge types, triggers edge extraction.
     *
     * @param function The function to check and update
     */
    private void ensureFunctionEdges(Function function) {
        if (function == null || graph == null || currentProgram == null) {
            return;
        }

        try {
            KnowledgeNode node = graph.getNodeByAddress(function.getEntryPoint().getOffset());
            if (node == null) {
                return; // Node doesn't exist, will be created by indexFunctionOnDemand
            }

            // Check if any of the edge types are missing
            boolean needsUpdate = !graph.hasEdgesOfType(node.getId(), ghidrassist.graphrag.nodes.EdgeType.REFERENCES);

            // Also check for CALLS_VULNERABLE (either direction)
            if (!needsUpdate) {
                needsUpdate = !graph.hasEdgesOfType(node.getId(), ghidrassist.graphrag.nodes.EdgeType.CALLS_VULNERABLE) &&
                              !graph.hasIncomingEdgesOfType(node.getId(), ghidrassist.graphrag.nodes.EdgeType.CALLS_VULNERABLE);
            }

            if (needsUpdate) {
                Msg.debug(this, "Auto-updating edges for: " + function.getName());
                StructureExtractor extractor = new StructureExtractor(currentProgram, graph, TaskMonitor.DUMMY);
                try {
                    extractor.updateFunctionEdges(function, node);
                } finally {
                    extractor.dispose();
                }
            }
        } catch (Exception e) {
            Msg.debug(this, "Failed to auto-update edges: " + e.getMessage());
        }
    }

    /**
     * Ensure node name matches the current Ghidra function name.
     * If the user has renamed the function, update the node to reflect the new name.
     * The FTS index is automatically updated via database triggers.
     *
     * @param function The Ghidra function with the current name
     * @param node The knowledge node to check and update
     * @return true if the name was updated
     */
    private boolean ensureNodeNameFresh(Function function, KnowledgeNode node) {
        if (function == null || node == null || graph == null) {
            return false;
        }

        // Use qualified name to include namespace (e.g., "Class::method")
        String currentName = SymGraphUtils.getQualifiedFunctionName(function);
        String storedName = node.getName();

        if (currentName != null && !currentName.equals(storedName)) {
            Msg.info(this, "Updating stale function name: " + storedName + " -> " + currentName);
            node.setName(currentName);
            graph.upsertNode(node);  // FTS index auto-updates via trigger
            return true;
        }
        return false;
    }

    /**
     * Ensure node name is fresh for a function, looking up the node if needed.
     *
     * @param function The Ghidra function
     */
    private void ensureNodeNameFresh(Function function) {
        if (function == null || graph == null) {
            return;
        }

        try {
            KnowledgeNode node = graph.getNodeByAddress(function.getEntryPoint().getOffset());
            if (node != null) {
                ensureNodeNameFresh(function, node);
            }
        } catch (Exception e) {
            Msg.debug(this, "Failed to check node name freshness: " + e.getMessage());
        }
    }

    private MCPToolResult executeGetSimilarFunctions(JsonObject arguments) {
        if (!arguments.has("address")) {
            return MCPToolResult.error("'address' is required");
        }

        long address = parseAddress(arguments.get("address").getAsString());
        int limit = arguments.has("limit") ? arguments.get("limit").getAsInt() : 10;

        List<SimilarFunction> results = engine.getSimilarFunctions(address, limit);

        // Format output
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        sb.append("  \"count\": ").append(results.size()).append(",\n");
        sb.append("  \"similar_functions\": [\n");
        for (int i = 0; i < results.size(); i++) {
            if (i > 0) sb.append(",\n");
            String resultOutput = results.get(i).toToolOutput();
            String indented = resultOutput.replace("\n", "\n    ");
            sb.append("    ").append(indented);
        }
        sb.append("\n  ]\n");
        sb.append("}");

        return MCPToolResult.success(sb.toString());
    }

    private MCPToolResult executeGetCallContext(JsonObject arguments) {
        if (!arguments.has("address")) {
            return MCPToolResult.error("'address' is required");
        }

        long address = parseAddress(arguments.get("address").getAsString());
        int depth = arguments.has("depth") ? arguments.get("depth").getAsInt() : 1;

        CallContext.Direction direction = CallContext.Direction.BOTH;
        if (arguments.has("direction")) {
            String dir = arguments.get("direction").getAsString().toLowerCase();
            if (dir.equals("callers")) {
                direction = CallContext.Direction.CALLERS;
            } else if (dir.equals("callees")) {
                direction = CallContext.Direction.CALLEES;
            }
        }

        CallContext result = engine.getCallContext(address, depth, direction);
        return MCPToolResult.success(result.toToolOutput());
    }

    private MCPToolResult executeGetSecurityAnalysis(JsonObject arguments) {
        String scope = arguments.has("scope") ?
                arguments.get("scope").getAsString().toLowerCase() : "function";

        SecurityAnalysis result;
        if (scope.equals("binary")) {
            String binaryId = currentProgram.getExecutableSHA256();
            result = engine.getBinarySecurityAnalysis(binaryId);
        } else if (arguments.has("address")) {
            long address = parseAddress(arguments.get("address").getAsString());

            // Auto-detect and update stale names, missing security flags and edges before querying
            Function func = lookupFunction(address, null);
            if (func != null) {
                ensureNodeNameFresh(func);
                ensureSecurityFlags(func);
                ensureFunctionEdges(func);
            }

            result = engine.getSecurityAnalysis(address);
        } else {
            return MCPToolResult.error("'address' is required for function-level security analysis");
        }

        return MCPToolResult.success(result.toToolOutput());
    }

    private MCPToolResult executeSearchSemantic(JsonObject arguments) {
        if (!arguments.has("query")) {
            return MCPToolResult.error("'query' is required");
        }

        String query = arguments.get("query").getAsString();
        int limit = arguments.has("limit") ? arguments.get("limit").getAsInt() : 20;

        List<SearchResult> results = engine.searchSemantic(query, limit);
        return MCPToolResult.success(SearchResult.listToToolOutput(results));
    }

    private MCPToolResult executeGetModuleSummary(JsonObject arguments) {
        if (!arguments.has("address")) {
            return MCPToolResult.error("'address' is required");
        }

        long address = parseAddress(arguments.get("address").getAsString());
        ModuleSummary result = engine.getModuleSummary(address);
        return MCPToolResult.success(result.toToolOutput());
    }

    private MCPToolResult executeGetActivityAnalysis(JsonObject arguments) {
        long address = 0;
        String functionName = null;

        if (arguments.has("address")) {
            address = parseAddress(arguments.get("address").getAsString());
        } else if (arguments.has("function_name")) {
            functionName = arguments.get("function_name").getAsString();
        } else {
            return MCPToolResult.error("Either 'address' or 'function_name' is required");
        }

        // Look up function
        Function function = lookupFunction(address, functionName);
        if (function == null) {
            return MCPToolResult.error("Function not found for address 0x" +
                    Long.toHexString(address) + " or name: " + functionName);
        }

        // Ensure name is fresh, security flags and edges are populated
        ensureNodeNameFresh(function);
        ensureSecurityFlags(function);
        ensureFunctionEdges(function);

        // First, try to get cached activity analysis from the knowledge graph
        KnowledgeNode node = graph.getNodeByAddress(function.getEntryPoint().getOffset());

        SecurityFeatures features = null;

        if (node != null && node.getActivityProfile() != null) {
            // Use cached data from the graph
            features = buildFeaturesFromNode(node);
            Msg.info(this, "get_activity_analysis: Using cached features for " + function.getName());
        } else {
            // Extract fresh features
            Msg.info(this, "get_activity_analysis: Extracting fresh features for " + function.getName());
            SecurityFeatureExtractor extractor = new SecurityFeatureExtractor(currentProgram, TaskMonitor.DUMMY);
            // Pass decompiled code for additional API detection via regex parsing
            String decompiledCode = node != null ? node.getRawContent() : null;
            features = extractor.extractFeatures(function, decompiledCode);

            // Cache the features if we have a node
            if (node != null && !features.isEmpty()) {
                node.applySecurityFeatures(features);
                graph.upsertNode(node);
            }
        }

        // Build output JSON
        return MCPToolResult.success(buildActivityAnalysisOutput(function, features));
    }

    /**
     * Build SecurityFeatures from cached KnowledgeNode data.
     */
    private SecurityFeatures buildFeaturesFromNode(KnowledgeNode node) {
        SecurityFeatures features = new SecurityFeatures();

        // Add network APIs
        for (String api : node.getNetworkAPIs()) {
            features.addNetworkAPI(api);
        }

        // Add file I/O APIs
        for (String api : node.getFileIOAPIs()) {
            features.addFileIOAPI(api);
        }

        // Add IP addresses
        for (String ip : node.getIPAddresses()) {
            features.addIPAddress(ip);
        }

        // Add URLs
        for (String url : node.getURLs()) {
            features.addURL(url);
        }

        // Add file paths
        for (String path : node.getFilePaths()) {
            features.addFilePath(path);
        }

        // Add domains
        for (String domain : node.getDomains()) {
            features.addDomain(domain);
        }

        // Set computed fields if available
        features.calculateActivityProfile();
        features.calculateRiskLevel();

        return features;
    }

    /**
     * Build the JSON output for activity analysis.
     */
    private String buildActivityAnalysisOutput(Function function, SecurityFeatures features) {
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        sb.append("  \"function_name\": \"").append(escapeJson(function.getName())).append("\",\n");
        sb.append("  \"address\": \"0x").append(Long.toHexString(function.getEntryPoint().getOffset())).append("\",\n");

        if (features == null || features.isEmpty()) {
            sb.append("  \"has_activity\": false,\n");
            sb.append("  \"activity_profile\": \"NONE\",\n");
            sb.append("  \"risk_level\": \"LOW\"\n");
        } else {
            sb.append("  \"has_activity\": true,\n");
            sb.append("  \"activity_profile\": \"").append(escapeJson(features.getActivityProfile())).append("\",\n");
            sb.append("  \"risk_level\": \"").append(escapeJson(features.getRiskLevel())).append("\",\n");

            // Network APIs
            if (features.hasNetworkAPIs()) {
                sb.append("  \"network_apis\": ").append(toJsonArray(features.getNetworkAPIs())).append(",\n");
            }

            // File I/O APIs
            if (features.hasFileIOAPIs()) {
                sb.append("  \"file_io_apis\": ").append(toJsonArray(features.getFileIOAPIs())).append(",\n");
            }

            // Crypto APIs
            if (features.hasCryptoAPIs()) {
                sb.append("  \"crypto_apis\": ").append(toJsonArray(features.getCryptoAPIs())).append(",\n");
            }

            // Process APIs
            if (features.hasProcessAPIs()) {
                sb.append("  \"process_apis\": ").append(toJsonArray(features.getProcessAPIs())).append(",\n");
            }

            // String references
            if (features.hasIPAddresses()) {
                sb.append("  \"ip_addresses\": ").append(toJsonArray(features.getIPAddresses())).append(",\n");
            }

            if (features.hasURLs()) {
                sb.append("  \"urls\": ").append(toJsonArray(features.getURLs())).append(",\n");
            }

            if (features.hasFilePaths()) {
                sb.append("  \"file_paths\": ").append(toJsonArray(features.getFilePaths())).append(",\n");
            }

            if (features.hasDomains()) {
                sb.append("  \"domains\": ").append(toJsonArray(features.getDomains())).append(",\n");
            }

            if (features.hasRegistryKeys()) {
                sb.append("  \"registry_keys\": ").append(toJsonArray(features.getRegistryKeys())).append(",\n");
            }

            // Remove trailing comma if present
            String result = sb.toString();
            if (result.endsWith(",\n")) {
                result = result.substring(0, result.length() - 2) + "\n";
            }
            sb = new StringBuilder(result);
        }

        sb.append("}");
        return sb.toString();
    }

    /**
     * Execute the ga_update_security_flags tool.
     * Updates security vulnerability flags for functions by analyzing dangerous function calls.
     */
    private MCPToolResult executeUpdateSecurityFlags(JsonObject arguments) {
        long address = 0;
        String functionName = null;
        boolean force = arguments.has("force") && arguments.get("force").getAsBoolean();

        if (arguments.has("address")) {
            address = parseAddress(arguments.get("address").getAsString());
        } else if (arguments.has("function_name")) {
            functionName = arguments.get("function_name").getAsString();
        }

        GraphRAGService service = GraphRAGService.getInstance(analysisDB);
        service.setCurrentProgram(currentProgram);

        // Single function update
        if (address != 0 || functionName != null) {
            Function function = lookupFunction(address, functionName);
            if (function == null) {
                return MCPToolResult.error("Function not found for address 0x" +
                        Long.toHexString(address) + " or name: " + functionName);
            }

            // Check if already has flags (unless force)
            if (!force && !service.needsSecurityFlagsUpdate(function)) {
                KnowledgeNode node = graph.getNodeByAddress(function.getEntryPoint().getOffset());
                List<String> existingFlags = node != null ? node.getSecurityFlags() : List.of();
                return MCPToolResult.success(buildSecurityFlagsOutput(function.getName(),
                        function.getEntryPoint().getOffset(), existingFlags, false));
            }

            // Update security flags
            boolean success = service.updateSecurityFlags(function, TaskMonitor.DUMMY);
            if (success) {
                KnowledgeNode node = graph.getNodeByAddress(function.getEntryPoint().getOffset());
                List<String> flags = node != null ? node.getSecurityFlags() : List.of();
                return MCPToolResult.success(buildSecurityFlagsOutput(function.getName(),
                        function.getEntryPoint().getOffset(), flags, true));
            } else {
                return MCPToolResult.success(buildSecurityFlagsOutput(function.getName(),
                        function.getEntryPoint().getOffset(), List.of(), true));
            }
        }

        // Batch update all functions
        int updated = service.updateAllSecurityFlags(currentProgram, TaskMonitor.DUMMY);
        return MCPToolResult.success(buildBatchSecurityFlagsOutput(updated));
    }

    /**
     * Build JSON output for single function security flags update.
     */
    private String buildSecurityFlagsOutput(String functionName, long address, List<String> flags, boolean wasUpdated) {
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        sb.append("  \"function_name\": \"").append(escapeJson(functionName)).append("\",\n");
        sb.append("  \"address\": \"0x").append(Long.toHexString(address)).append("\",\n");
        sb.append("  \"updated\": ").append(wasUpdated).append(",\n");
        sb.append("  \"security_flags\": ").append(toJsonArray(flags)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Build JSON output for batch security flags update.
     */
    private String buildBatchSecurityFlagsOutput(int updatedCount) {
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        sb.append("  \"scope\": \"binary\",\n");
        sb.append("  \"functions_updated\": ").append(updatedCount).append(",\n");
        sb.append("  \"message\": \"Updated security flags for ").append(updatedCount).append(" functions\"\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Execute the ga_index_binary tool.
     * Triggers full binary indexing to populate the knowledge graph with all edge types.
     */
    private MCPToolResult executeIndexBinary(JsonObject arguments) {
        boolean includeBlocks = arguments.has("include_blocks") && arguments.get("include_blocks").getAsBoolean();
        boolean force = arguments.has("force") && arguments.get("force").getAsBoolean();

        if (currentProgram == null) {
            return MCPToolResult.error("No program loaded");
        }

        // Check if already indexed (unless force)
        if (!force && graph != null) {
            int existingFunctions = graph.getNodesByType(ghidrassist.graphrag.nodes.NodeType.FUNCTION).size();
            if (existingFunctions > 0) {
                return MCPToolResult.success(buildIndexSkippedOutput(existingFunctions));
            }
        }

        try {
            // Run synchronous structure extraction
            GraphRAGService service = GraphRAGService.getInstance(analysisDB);
            service.setCurrentProgram(currentProgram);

            StructureExtractor.ExtractionResult result = service.indexStructureSync(
                    currentProgram, TaskMonitor.DUMMY, includeBlocks);

            return MCPToolResult.success(buildIndexResultOutput(result));
        } catch (Exception e) {
            Msg.error(this, "Failed to index binary: " + e.getMessage(), e);
            return MCPToolResult.error("Failed to index binary: " + e.getMessage());
        }
    }

    /**
     * Build JSON output when indexing is skipped (already indexed).
     */
    private String buildIndexSkippedOutput(int existingFunctions) {
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        sb.append("  \"status\": \"skipped\",\n");
        sb.append("  \"reason\": \"Binary already indexed\",\n");
        sb.append("  \"existing_functions\": ").append(existingFunctions).append(",\n");
        sb.append("  \"hint\": \"Use force=true to re-index\"\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Build JSON output for indexing result.
     */
    private String buildIndexResultOutput(StructureExtractor.ExtractionResult result) {
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        sb.append("  \"status\": \"completed\",\n");
        sb.append("  \"functions_extracted\": ").append(result.functionsExtracted).append(",\n");
        sb.append("  \"call_edges\": ").append(result.callEdgesCreated).append(",\n");
        sb.append("  \"reference_edges\": ").append(result.refEdgesCreated).append(",\n");
        sb.append("  \"vulnerable_call_edges\": ").append(result.vulnEdgesCreated).append(",\n");
        sb.append("  \"elapsed_ms\": ").append(result.elapsedMs).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Execute the ga_record_vulnerability tool.
     * Records a vulnerability discovered by LLM analysis and propagates to callers.
     */
    private MCPToolResult executeRecordVulnerability(JsonObject arguments) {
        // Parse arguments
        long address = 0;
        String functionName = null;

        if (arguments.has("address")) {
            address = parseAddress(arguments.get("address").getAsString());
        }
        if (arguments.has("function_name")) {
            functionName = arguments.get("function_name").getAsString();
        }

        // Required fields
        if (!arguments.has("vulnerability_type")) {
            return MCPToolResult.error("'vulnerability_type' is required");
        }
        if (!arguments.has("severity")) {
            return MCPToolResult.error("'severity' is required");
        }
        if (!arguments.has("description")) {
            return MCPToolResult.error("'description' is required");
        }

        String vulnType = arguments.get("vulnerability_type").getAsString().toUpperCase();
        String severity = arguments.get("severity").getAsString().toUpperCase();
        String description = arguments.get("description").getAsString();
        String evidence = arguments.has("evidence") ? arguments.get("evidence").getAsString() : null;

        // Validate vulnerability type
        if (!isValidVulnerabilityType(vulnType)) {
            return MCPToolResult.error("Invalid vulnerability_type: " + vulnType +
                ". Valid types: BUFFER_OVERFLOW, COMMAND_INJECTION, FORMAT_STRING, USE_AFTER_FREE, " +
                "INTEGER_OVERFLOW, PATH_TRAVERSAL, SQL_INJECTION, RACE_CONDITION, " +
                "MEMORY_LEAK, NULL_DEREF, INFO_DISCLOSURE, AUTH_BYPASS, CRYPTO_WEAKNESS, OTHER");
        }

        // Validate severity
        if (!isValidSeverity(severity)) {
            return MCPToolResult.error("Invalid severity: " + severity +
                ". Valid values: LOW, MEDIUM, HIGH, CRITICAL");
        }

        // Look up function
        Function function = lookupFunction(address, functionName);
        if (function == null) {
            return MCPToolResult.error("Function not found. Provide valid 'address' or 'function_name'");
        }

        address = function.getEntryPoint().getOffset();

        // Get or create node
        KnowledgeNode node = graph.getNodeByAddress(address);
        if (node == null) {
            // Index the function first
            boolean indexed = indexFunctionOnDemand(function);
            if (!indexed) {
                return MCPToolResult.error("Failed to index function: " + function.getName());
            }
            node = graph.getNodeByAddress(address);
            if (node == null) {
                return MCPToolResult.error("Failed to create node for function: " + function.getName());
            }
        }

        // Add vulnerability as security flag (e.g., "VULN_BUFFER_OVERFLOW")
        String vulnFlag = "VULN_" + vulnType;
        node.addSecurityFlag(vulnFlag);

        // Add severity flag (e.g., "SEVERITY_HIGH")
        String severityFlag = "SEVERITY_" + severity;
        node.addSecurityFlag(severityFlag);

        // Mark as LLM-discovered vulnerability
        node.addSecurityFlag("LLM_DISCOVERED_VULN");

        // Store description in node metadata (append to existing llm_summary or create new)
        String existingSummary = node.getLlmSummary();
        String vulnNote = String.format("\n\n[VULNERABILITY] %s (%s): %s%s",
            vulnType, severity, description,
            evidence != null ? "\nEvidence: " + evidence : "");

        if (existingSummary != null && !existingSummary.isEmpty() && !existingSummary.equals("pending")) {
            node.setLlmSummary(existingSummary + vulnNote);
        } else {
            node.setLlmSummary(vulnNote.trim());
        }

        // Save the updated node
        graph.upsertNode(node);

        // Propagate vulnerability to callers (Phase B.2)
        int callersUpdated = propagateVulnerabilityToCallers(node, vulnType, severity);

        Msg.info(this, String.format("Recorded vulnerability %s (%s) for %s at 0x%x, propagated to %d callers",
            vulnType, severity, function.getName(), address, callersUpdated));

        return MCPToolResult.success(buildVulnerabilityRecordOutput(
            function.getName(), address, vulnType, severity, description, callersUpdated));
    }

    /**
     * Propagate vulnerability information to all functions that call the vulnerable function.
     * Creates CALLS_VULNERABLE edges and adds CALLS_VULNERABLE_FUNCTION flag to callers.
     *
     * @param vulnerableNode The node with the vulnerability
     * @param vulnType The type of vulnerability
     * @param severity The severity level
     * @return Number of callers updated
     */
    private int propagateVulnerabilityToCallers(KnowledgeNode vulnerableNode, String vulnType, String severity) {
        if (vulnerableNode == null || graph == null) {
            return 0;
        }

        int callersUpdated = 0;
        List<KnowledgeNode> callers = graph.getCallers(vulnerableNode.getId());

        for (KnowledgeNode caller : callers) {
            // Add CALLS_VULNERABLE edge from caller to vulnerable function
            // Check if edge already exists
            if (!graph.hasEdgesOfType(caller.getId(), ghidrassist.graphrag.nodes.EdgeType.CALLS_VULNERABLE)) {
                String metadata = String.format("{\"vuln_type\":\"%s\",\"severity\":\"%s\"}", vulnType, severity);
                graph.addEdge(caller.getId(), vulnerableNode.getId(),
                    ghidrassist.graphrag.nodes.EdgeType.CALLS_VULNERABLE, 1.0, metadata);
            }

            // Add flag to caller indicating it calls a vulnerable function
            String callerFlag = "CALLS_VULN_" + vulnType;
            if (!caller.getSecurityFlags().contains(callerFlag)) {
                caller.addSecurityFlag(callerFlag);
                caller.addSecurityFlag("CALLS_VULNERABLE_FUNCTION");
                graph.upsertNode(caller);
                callersUpdated++;
            }
        }

        return callersUpdated;
    }

    /**
     * Execute the ga_add_security_flag tool.
     * Adds a security-relevant flag to a function's knowledge graph node.
     */
    private MCPToolResult executeAddSecurityFlag(JsonObject arguments) {
        // Parse arguments
        long address = 0;
        String functionName = null;

        if (arguments.has("address")) {
            address = parseAddress(arguments.get("address").getAsString());
        }
        if (arguments.has("function_name")) {
            functionName = arguments.get("function_name").getAsString();
        }

        // Required field
        if (!arguments.has("flag")) {
            return MCPToolResult.error("'flag' is required");
        }

        String flag = arguments.get("flag").getAsString().toUpperCase().replace(" ", "_");

        // Look up function
        Function function = lookupFunction(address, functionName);
        if (function == null) {
            return MCPToolResult.error("Function not found. Provide valid 'address' or 'function_name'");
        }

        address = function.getEntryPoint().getOffset();

        // Get or create node
        KnowledgeNode node = graph.getNodeByAddress(address);
        if (node == null) {
            // Index the function first
            boolean indexed = indexFunctionOnDemand(function);
            if (!indexed) {
                return MCPToolResult.error("Failed to index function: " + function.getName());
            }
            node = graph.getNodeByAddress(address);
            if (node == null) {
                return MCPToolResult.error("Failed to create node for function: " + function.getName());
            }
        }

        // Check if flag already exists
        boolean alreadyExists = node.getSecurityFlags().contains(flag);

        if (!alreadyExists) {
            // Add the flag
            node.addSecurityFlag(flag);
            graph.upsertNode(node);
            Msg.info(this, String.format("Added security flag '%s' to %s at 0x%x",
                flag, function.getName(), address));
        }

        return MCPToolResult.success(buildSecurityFlagAddOutput(
            function.getName(), address, flag, !alreadyExists, node.getSecurityFlags()));
    }

    /**
     * Check if a vulnerability type is valid.
     */
    private boolean isValidVulnerabilityType(String type) {
        return type.equals("BUFFER_OVERFLOW") ||
               type.equals("COMMAND_INJECTION") ||
               type.equals("FORMAT_STRING") ||
               type.equals("USE_AFTER_FREE") ||
               type.equals("INTEGER_OVERFLOW") ||
               type.equals("PATH_TRAVERSAL") ||
               type.equals("SQL_INJECTION") ||
               type.equals("RACE_CONDITION") ||
               type.equals("MEMORY_LEAK") ||
               type.equals("NULL_DEREF") ||
               type.equals("INFO_DISCLOSURE") ||
               type.equals("AUTH_BYPASS") ||
               type.equals("CRYPTO_WEAKNESS") ||
               type.equals("OTHER");
    }

    /**
     * Check if a severity level is valid.
     */
    private boolean isValidSeverity(String severity) {
        return severity.equals("LOW") ||
               severity.equals("MEDIUM") ||
               severity.equals("HIGH") ||
               severity.equals("CRITICAL");
    }

    /**
     * Build JSON output for vulnerability record.
     */
    private String buildVulnerabilityRecordOutput(String functionName, long address,
            String vulnType, String severity, String description, int callersUpdated) {
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        sb.append("  \"status\": \"recorded\",\n");
        sb.append("  \"function_name\": \"").append(escapeJson(functionName)).append("\",\n");
        sb.append("  \"address\": \"0x").append(Long.toHexString(address)).append("\",\n");
        sb.append("  \"vulnerability_type\": \"").append(escapeJson(vulnType)).append("\",\n");
        sb.append("  \"severity\": \"").append(escapeJson(severity)).append("\",\n");
        sb.append("  \"description\": \"").append(escapeJson(description)).append("\",\n");
        sb.append("  \"callers_updated\": ").append(callersUpdated).append(",\n");
        sb.append("  \"message\": \"Vulnerability recorded and propagated to ").append(callersUpdated);
        sb.append(" caller(s)\"\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Build JSON output for security flag add.
     */
    private String buildSecurityFlagAddOutput(String functionName, long address,
            String flag, boolean wasAdded, List<String> allFlags) {
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        sb.append("  \"status\": \"").append(wasAdded ? "added" : "already_exists").append("\",\n");
        sb.append("  \"function_name\": \"").append(escapeJson(functionName)).append("\",\n");
        sb.append("  \"address\": \"0x").append(Long.toHexString(address)).append("\",\n");
        sb.append("  \"flag\": \"").append(escapeJson(flag)).append("\",\n");
        sb.append("  \"all_flags\": ").append(toJsonArray(allFlags)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Execute the ga_refresh_names tool.
     * Refreshes function names in the knowledge graph to match current Ghidra names.
     */
    private MCPToolResult executeRefreshNames(JsonObject arguments) {
        // Parse arguments
        long address = 0;
        String functionName = null;

        if (arguments.has("address")) {
            address = parseAddress(arguments.get("address").getAsString());
        }
        if (arguments.has("function_name")) {
            functionName = arguments.get("function_name").getAsString();
        }

        // Single function refresh
        if (address != 0 || functionName != null) {
            Function function = lookupFunction(address, functionName);
            if (function == null) {
                return MCPToolResult.error("Function not found. Provide valid 'address' or 'function_name'");
            }

            address = function.getEntryPoint().getOffset();
            KnowledgeNode node = graph.getNodeByAddress(address);
            if (node == null) {
                return MCPToolResult.error("Function not indexed in knowledge graph: " + function.getName());
            }

            String oldName = node.getName();
            boolean wasUpdated = ensureNodeNameFresh(function, node);

            return MCPToolResult.success(buildNameRefreshOutput(
                function.getName(), address, oldName, wasUpdated));
        }

        // Batch refresh all functions in binary
        int updated = refreshAllNames();
        return MCPToolResult.success(buildBatchNameRefreshOutput(updated));
    }

    /**
     * Refresh all function names in the knowledge graph.
     * Compares each indexed function's name with the current Ghidra name.
     *
     * @return Number of names updated
     */
    private int refreshAllNames() {
        if (graph == null || currentProgram == null) {
            return 0;
        }

        FunctionManager funcMgr = currentProgram.getFunctionManager();
        int updated = 0;

        // Get all function nodes from the graph
        List<KnowledgeNode> functionNodes = graph.getNodesByType(ghidrassist.graphrag.nodes.NodeType.FUNCTION);

        for (KnowledgeNode node : functionNodes) {
            try {
                // Look up the function in Ghidra by address
                Address addr = currentProgram.getAddressFactory()
                    .getDefaultAddressSpace().getAddress(node.getAddress());
                Function func = funcMgr.getFunctionAt(addr);

                if (func != null) {
                    if (ensureNodeNameFresh(func, node)) {
                        updated++;
                    }
                }
            } catch (Exception e) {
                Msg.debug(this, "Failed to refresh name for node " + node.getId() + ": " + e.getMessage());
            }
        }

        Msg.info(this, String.format("Refreshed %d function names out of %d total", updated, functionNodes.size()));
        return updated;
    }

    /**
     * Build JSON output for single function name refresh.
     */
    private String buildNameRefreshOutput(String currentName, long address, String oldName, boolean wasUpdated) {
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        sb.append("  \"status\": \"").append(wasUpdated ? "updated" : "unchanged").append("\",\n");
        sb.append("  \"address\": \"0x").append(Long.toHexString(address)).append("\",\n");
        sb.append("  \"current_name\": \"").append(escapeJson(currentName)).append("\",\n");
        if (wasUpdated) {
            sb.append("  \"old_name\": \"").append(escapeJson(oldName)).append("\",\n");
        }
        sb.append("  \"message\": \"");
        if (wasUpdated) {
            sb.append("Name updated from '").append(escapeJson(oldName)).append("' to '").append(escapeJson(currentName)).append("'");
        } else {
            sb.append("Name is already current");
        }
        sb.append("\"\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Build JSON output for batch name refresh.
     */
    private String buildBatchNameRefreshOutput(int updatedCount) {
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        sb.append("  \"status\": \"completed\",\n");
        sb.append("  \"scope\": \"binary\",\n");
        sb.append("  \"names_updated\": ").append(updatedCount).append(",\n");
        sb.append("  \"message\": \"Updated ").append(updatedCount).append(" stale function name(s)\"\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert a list of strings to JSON array.
     */
    private String toJsonArray(List<String> list) {
        if (list == null || list.isEmpty()) {
            return "[]";
        }
        StringBuilder sb = new StringBuilder("[");
        boolean first = true;
        for (String item : list) {
            if (!first) sb.append(", ");
            sb.append("\"").append(escapeJson(item)).append("\"");
            first = false;
        }
        sb.append("]");
        return sb.toString();
    }

    private String escapeJson(String str) {
        if (str == null) return "";
        return str.replace("\\", "\\\\")
                  .replace("\"", "\\\"")
                  .replace("\n", "\\n")
                  .replace("\r", "\\r")
                  .replace("\t", "\\t");
    }

    private String toJsonArray(java.util.Set<String> set) {
        if (set == null || set.isEmpty()) {
            return "[]";
        }
        StringBuilder sb = new StringBuilder("[");
        boolean first = true;
        for (String item : set) {
            if (!first) sb.append(", ");
            sb.append("\"").append(escapeJson(item)).append("\"");
            first = false;
        }
        sb.append("]");
        return sb.toString();
    }

    // ========================================
    // Helper Methods
    // ========================================

    private long parseAddress(String addressStr) {
        if (addressStr == null || addressStr.isEmpty()) {
            return 0;
        }

        String cleaned = addressStr.trim().toLowerCase();
        if (cleaned.startsWith("0x")) {
            cleaned = cleaned.substring(2);
        }

        try {
            return Long.parseLong(cleaned, 16);
        } catch (NumberFormatException e) {
            Msg.warn(this, "Invalid address format: " + addressStr);
            return 0;
        }
    }

    /**
     * Execute the ga_detect_communities tool.
     * Runs community detection on the function call graph.
     */
    private MCPToolResult executeDetectCommunities(JsonObject arguments) {
        // Parse arguments
        int minSize = 2;
        boolean force = false;

        if (arguments.has("min_size")) {
            minSize = arguments.get("min_size").getAsInt();
        }
        if (arguments.has("force")) {
            force = arguments.get("force").getAsBoolean();
        }

        // Check if communities already exist
        int existingCount = graph.getCommunityCount();
        if (existingCount > 0 && !force) {
            return MCPToolResult.success(String.format(
                    "{\n  \"status\": \"skipped\",\n  \"message\": \"Communities already exist (%d communities). Use force=true to re-detect.\",\n  \"existing_count\": %d\n}",
                    existingCount, existingCount));
        }

        // Run community detection
        ghidrassist.graphrag.community.CommunityDetector detector =
                new ghidrassist.graphrag.community.CommunityDetector(graph, null);
        int communityCount = detector.detectCommunities(100, minSize);

        // Get statistics
        Map<String, Object> stats = detector.getCommunityStats();

        // Build result
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        sb.append("  \"status\": \"success\",\n");
        sb.append("  \"communities_detected\": ").append(communityCount).append(",\n");
        sb.append("  \"min_size_used\": ").append(minSize).append(",\n");

        if (stats.containsKey("total_members")) {
            sb.append("  \"total_members\": ").append(stats.get("total_members")).append(",\n");
        }
        if (stats.containsKey("avg_size")) {
            sb.append("  \"avg_community_size\": ").append(stats.get("avg_size")).append(",\n");
        }
        if (stats.containsKey("max_size")) {
            sb.append("  \"max_community_size\": ").append(stats.get("max_size")).append(",\n");
        }
        if (stats.containsKey("min_size")) {
            sb.append("  \"min_community_size\": ").append(stats.get("min_size")).append(",\n");
        }

        sb.append("  \"message\": \"Community detection complete. Use ga_get_module_summary to view community details.\"\n");
        sb.append("}");

        Msg.info(this, String.format("Community detection complete: %d communities", communityCount));

        return MCPToolResult.success(sb.toString());
    }

    /**
     * Execute the ga_global_query tool.
     * Aggregates insights across all detected communities for binary-wide analysis.
     */
    private MCPToolResult executeGlobalQuery(JsonObject arguments) {
        // Parse arguments
        int communityLevel = 0;
        boolean includeMembers = false;

        if (arguments.has("community_level")) {
            communityLevel = arguments.get("community_level").getAsInt();
        }
        if (arguments.has("include_members")) {
            includeMembers = arguments.get("include_members").getAsBoolean();
        }

        // Check if communities exist
        int existingCount = graph.getCommunityCount();
        if (existingCount == 0) {
            return MCPToolResult.success(
                "{\n  \"status\": \"error\",\n  \"message\": \"No communities detected. " +
                "Run ga_detect_communities first to cluster functions into communities.\"\n}");
        }

        // Execute global query
        GlobalQueryResult result = engine.globalQuery(communityLevel);

        Msg.info(this, String.format("Global query complete: %d communities, %d functions",
                result.getCommunityCount(), result.getTotalFunctions()));

        return MCPToolResult.success(result.toToolOutput(includeMembers));
    }

    /**
     * Execute the ga_find_taint_paths tool.
     * Finds data flow paths from taint sources to sinks.
     */
    @SuppressWarnings("unchecked")  // Intentional cast from TaintAnalyzer stats map
    private MCPToolResult executeFindTaintPaths(JsonObject arguments) {
        // Parse arguments
        long sourceAddress = 0;
        long sinkAddress = 0;
        int maxPaths = 20;
        boolean createEdges = false;

        if (arguments.has("source_address")) {
            sourceAddress = parseAddress(arguments.get("source_address").getAsString());
        }
        if (arguments.has("sink_address")) {
            sinkAddress = parseAddress(arguments.get("sink_address").getAsString());
        }
        if (arguments.has("max_paths")) {
            maxPaths = arguments.get("max_paths").getAsInt();
        }
        if (arguments.has("create_edges")) {
            createEdges = arguments.get("create_edges").getAsBoolean();
        }

        // Create taint analyzer
        TaintAnalyzer analyzer = new TaintAnalyzer(graph);

        // Execute appropriate search
        java.util.List<TaintAnalyzer.TaintPath> paths;

        if (sourceAddress != 0 && sinkAddress != 0) {
            // Both specified - not directly supported, find from source
            paths = analyzer.findTaintPathsFrom(sourceAddress, maxPaths, createEdges);
        } else if (sourceAddress != 0) {
            // Find paths from specific source
            paths = analyzer.findTaintPathsFrom(sourceAddress, maxPaths, createEdges);
        } else if (sinkAddress != 0) {
            // Find paths to specific sink
            paths = analyzer.findTaintPathsTo(sinkAddress, maxPaths, createEdges);
        } else {
            // Find all taint paths
            paths = analyzer.findTaintPaths(maxPaths, createEdges);
        }

        // Build result output
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        sb.append("  \"paths_found\": ").append(paths.size()).append(",\n");

        if (paths.isEmpty()) {
            // Get taint stats for additional context
            java.util.Map<String, Object> stats = analyzer.getTaintStats();
            sb.append("  \"source_count\": ").append(stats.get("source_count")).append(",\n");
            sb.append("  \"sink_count\": ").append(stats.get("sink_count")).append(",\n");
            sb.append("  \"message\": \"No taint paths found. Ensure the binary is indexed and has source/sink functions.\",\n");
            sb.append("  \"sample_sources\": ").append(toJsonArray((java.util.List<String>)stats.get("sample_sources"))).append(",\n");
            sb.append("  \"sample_sinks\": ").append(toJsonArray((java.util.List<String>)stats.get("sample_sinks"))).append("\n");
        } else {
            sb.append("  \"edges_created\": ").append(createEdges).append(",\n");
            sb.append("  \"paths\": [\n");

            for (int i = 0; i < paths.size(); i++) {
                TaintAnalyzer.TaintPath path = paths.get(i);
                String pathOutput = path.toToolOutput();
                // Indent the path output
                String indented = pathOutput.replace("\n", "\n    ");
                sb.append("    ").append(indented);
                if (i < paths.size() - 1) sb.append(",");
                sb.append("\n");
            }

            sb.append("  ]\n");
        }

        sb.append("}");

        Msg.info(this, String.format("Taint path analysis complete: %d paths found", paths.size()));

        return MCPToolResult.success(sb.toString());
    }

    /**
     * Execute the ga_create_edge tool.
     * Creates a semantic relationship edge between two functions.
     */
    private MCPToolResult executeCreateEdge(JsonObject arguments) {
        // Parse source function
        long sourceAddress = 0;
        String sourceName = null;
        if (arguments.has("source_address")) {
            sourceAddress = parseAddress(arguments.get("source_address").getAsString());
        }
        if (arguments.has("source_name")) {
            sourceName = arguments.get("source_name").getAsString();
        }

        // Parse target function
        long targetAddress = 0;
        String targetName = null;
        if (arguments.has("target_address")) {
            targetAddress = parseAddress(arguments.get("target_address").getAsString());
        }
        if (arguments.has("target_name")) {
            targetName = arguments.get("target_name").getAsString();
        }

        // Required field: edge_type
        if (!arguments.has("edge_type")) {
            return MCPToolResult.error("'edge_type' is required");
        }
        String edgeTypeStr = arguments.get("edge_type").getAsString().toUpperCase();

        // Optional fields
        double confidence = 0.8; // Default confidence
        if (arguments.has("confidence")) {
            confidence = arguments.get("confidence").getAsDouble();
            confidence = Math.max(0.0, Math.min(1.0, confidence)); // Clamp to 0-1
        }
        String reason = arguments.has("reason") ? arguments.get("reason").getAsString() : null;

        // Validate edge type
        ghidrassist.graphrag.nodes.EdgeType edgeType;
        try {
            edgeType = ghidrassist.graphrag.nodes.EdgeType.valueOf(edgeTypeStr);
        } catch (IllegalArgumentException e) {
            return MCPToolResult.error("Invalid edge_type: " + edgeTypeStr +
                ". Valid types: SIMILAR_PURPOSE, RELATED_TO, DEPENDS_ON, IMPLEMENTS");
        }

        // Validate that this is a semantic edge type (not structural)
        if (!isSemanticEdgeType(edgeType)) {
            return MCPToolResult.error("Edge type " + edgeTypeStr + " is not a semantic edge type. " +
                "Use: SIMILAR_PURPOSE, RELATED_TO, DEPENDS_ON, IMPLEMENTS");
        }

        // Look up source function
        Function sourceFunc = lookupFunction(sourceAddress, sourceName);
        if (sourceFunc == null) {
            return MCPToolResult.error("Source function not found. Provide valid 'source_address' or 'source_name'");
        }

        // Look up target function
        Function targetFunc = lookupFunction(targetAddress, targetName);
        if (targetFunc == null) {
            return MCPToolResult.error("Target function not found. Provide valid 'target_address' or 'target_name'");
        }

        sourceAddress = sourceFunc.getEntryPoint().getOffset();
        targetAddress = targetFunc.getEntryPoint().getOffset();

        // Get or create source node
        KnowledgeNode sourceNode = graph.getNodeByAddress(sourceAddress);
        if (sourceNode == null) {
            boolean indexed = indexFunctionOnDemand(sourceFunc);
            if (!indexed) {
                return MCPToolResult.error("Failed to index source function: " + sourceFunc.getName());
            }
            sourceNode = graph.getNodeByAddress(sourceAddress);
        }

        // Get or create target node
        KnowledgeNode targetNode = graph.getNodeByAddress(targetAddress);
        if (targetNode == null) {
            boolean indexed = indexFunctionOnDemand(targetFunc);
            if (!indexed) {
                return MCPToolResult.error("Failed to index target function: " + targetFunc.getName());
            }
            targetNode = graph.getNodeByAddress(targetAddress);
        }

        if (sourceNode == null || targetNode == null) {
            return MCPToolResult.error("Failed to get nodes for source or target function");
        }

        // Check if edge already exists
        if (graph.hasEdgeBetween(sourceNode.getId(), targetNode.getId(), edgeType)) {
            return MCPToolResult.success(buildEdgeExistsOutput(
                sourceFunc.getName(), targetFunc.getName(), edgeTypeStr));
        }

        // Create the edge with metadata
        String metadata = reason != null ?
            String.format("{\"reason\":\"%s\",\"source\":\"llm_analysis\"}", escapeJson(reason)) :
            "{\"source\":\"llm_analysis\"}";

        graph.addEdge(sourceNode.getId(), targetNode.getId(), edgeType, confidence, metadata);

        Msg.info(this, String.format("Created %s edge from %s to %s (confidence: %.2f)",
            edgeTypeStr, sourceFunc.getName(), targetFunc.getName(), confidence));

        return MCPToolResult.success(buildEdgeCreatedOutput(
            sourceFunc.getName(), sourceAddress, targetFunc.getName(), targetAddress,
            edgeTypeStr, confidence, reason));
    }

    /**
     * Check if an edge type is a semantic (LLM-creatable) edge type.
     */
    private boolean isSemanticEdgeType(ghidrassist.graphrag.nodes.EdgeType edgeType) {
        return edgeType == ghidrassist.graphrag.nodes.EdgeType.SIMILAR_PURPOSE ||
               edgeType == ghidrassist.graphrag.nodes.EdgeType.RELATED_TO ||
               edgeType == ghidrassist.graphrag.nodes.EdgeType.DEPENDS_ON ||
               edgeType == ghidrassist.graphrag.nodes.EdgeType.IMPLEMENTS;
    }

    /**
     * Build output for edge already exists case.
     */
    private String buildEdgeExistsOutput(String sourceName, String targetName, String edgeType) {
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        sb.append("  \"status\": \"exists\",\n");
        sb.append("  \"message\": \"Edge already exists\",\n");
        sb.append("  \"source\": \"").append(escapeJson(sourceName)).append("\",\n");
        sb.append("  \"target\": \"").append(escapeJson(targetName)).append("\",\n");
        sb.append("  \"edge_type\": \"").append(edgeType).append("\"\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Build output for successfully created edge.
     */
    private String buildEdgeCreatedOutput(String sourceName, long sourceAddr,
                                           String targetName, long targetAddr,
                                           String edgeType, double confidence, String reason) {
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        sb.append("  \"status\": \"created\",\n");
        sb.append("  \"source\": \"").append(escapeJson(sourceName)).append("\",\n");
        sb.append("  \"source_address\": \"0x").append(Long.toHexString(sourceAddr)).append("\",\n");
        sb.append("  \"target\": \"").append(escapeJson(targetName)).append("\",\n");
        sb.append("  \"target_address\": \"0x").append(Long.toHexString(targetAddr)).append("\",\n");
        sb.append("  \"edge_type\": \"").append(edgeType).append("\",\n");
        sb.append("  \"confidence\": ").append(String.format("%.2f", confidence));
        if (reason != null) {
            sb.append(",\n  \"reason\": \"").append(escapeJson(reason)).append("\"");
        }
        sb.append("\n}");
        return sb.toString();
    }

    /**
     * Execute the ga_cleanup_graph tool.
     * Performs maintenance operations like removing duplicate edges.
     */
    private MCPToolResult executeCleanupGraph(JsonObject arguments) {
        boolean removeDuplicates = true; // Default to true

        if (arguments.has("remove_duplicates")) {
            removeDuplicates = arguments.get("remove_duplicates").getAsBoolean();
        }

        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        sb.append("  \"status\": \"success\",\n");

        int totalCleaned = 0;

        if (removeDuplicates) {
            int duplicatesRemoved = graph.removeDuplicateEdges();
            totalCleaned += duplicatesRemoved;
            sb.append("  \"duplicates_removed\": ").append(duplicatesRemoved).append(",\n");
        }

        // Get updated stats
        sb.append("  \"current_node_count\": ").append(graph.getNodeCount()).append(",\n");
        sb.append("  \"current_edge_count\": ").append(graph.getEdgeCount()).append(",\n");
        sb.append("  \"message\": \"Graph cleanup complete. ").append(totalCleaned).append(" issues fixed.\"\n");
        sb.append("}");

        Msg.info(this, String.format("Graph cleanup complete: %d issues fixed", totalCleaned));

        return MCPToolResult.success(sb.toString());
    }

    private MCPTool createTool(String name, String description, JsonObject inputSchema) {
        return new MCPTool(name, description, inputSchema, SERVER_NAME);
    }

    private JsonObject createSchema(Map<String, Map<String, String>> properties, List<String> required) {
        JsonObject schema = new JsonObject();
        schema.addProperty("type", "object");

        JsonObject propsJson = new JsonObject();
        for (Map.Entry<String, Map<String, String>> entry : properties.entrySet()) {
            JsonObject prop = new JsonObject();
            for (Map.Entry<String, String> propEntry : entry.getValue().entrySet()) {
                prop.addProperty(propEntry.getKey(), propEntry.getValue());
            }
            propsJson.add(entry.getKey(), prop);
        }
        schema.add("properties", propsJson);

        if (!required.isEmpty()) {
            com.google.gson.JsonArray requiredArray = new com.google.gson.JsonArray();
            for (String req : required) {
                requiredArray.add(req);
            }
            schema.add("required", requiredArray);
        }

        return schema;
    }
}

```

`src/main/java/ghidrassist/graphrag/query/SimilarFunction.java`:

```java
package ghidrassist.graphrag.query;

/**
 * Result type for get_similar_functions() tool.
 * Represents a function similar to the query function based on graph structure.
 */
public class SimilarFunction {
    private final String name;
    private final long address;
    private final String summary;
    private final float similarityScore;
    private final SimilarityType similarityType;

    public enum SimilarityType {
        SAME_COMMUNITY,      // Functions in the same module/community
        SHARED_CALLERS,      // Functions called by the same callers
        SHARED_CALLEES,      // Functions that call the same callees
        FTS_MATCH,           // Full-text search match on summaries
        EMBEDDING_SIMILARITY // Vector similarity (if embeddings available)
    }

    public SimilarFunction(String name, long address, String summary,
                           float similarityScore, SimilarityType similarityType) {
        this.name = name;
        this.address = address;
        this.summary = summary;
        this.similarityScore = similarityScore;
        this.similarityType = similarityType;
    }

    // Getters
    public String getName() { return name; }
    public long getAddress() { return address; }
    public String getSummary() { return summary; }
    public float getSimilarityScore() { return similarityScore; }
    public SimilarityType getSimilarityType() { return similarityType; }

    /**
     * Convert to JSON-like string for tool output.
     */
    public String toToolOutput() {
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        sb.append("  \"name\": \"").append(name).append("\",\n");
        sb.append("  \"address\": \"0x").append(Long.toHexString(address)).append("\",\n");
        sb.append("  \"summary\": \"").append(escapeJson(summary)).append("\",\n");
        sb.append("  \"similarity_score\": ").append(similarityScore).append(",\n");
        sb.append("  \"similarity_type\": \"").append(similarityType.name().toLowerCase()).append("\"\n");
        sb.append("}");
        return sb.toString();
    }

    private String escapeJson(String s) {
        if (s == null) return "";
        return s.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }
}

```

`src/main/java/ghidrassist/mcp2/prompts/MCPPrompt.java`:

```java
package ghidrassist.mcp2.prompts;

import java.util.ArrayList;
import java.util.List;

/**
 * Data class representing an MCP prompt.
 * Prompts are templated messages that can be sent to LLMs with arguments.
 */
public class MCPPrompt {
    private final String name;
    private final String description;
    private final List<MCPPromptArgument> arguments;

    public MCPPrompt(String name, String description, List<MCPPromptArgument> arguments) {
        this.name = name;
        this.description = description;
        this.arguments = arguments != null ? new ArrayList<>(arguments) : new ArrayList<>();
    }

    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }

    public List<MCPPromptArgument> getArguments() {
        return new ArrayList<>(arguments);
    }

    public boolean hasArguments() {
        return !arguments.isEmpty();
    }

    public List<MCPPromptArgument> getRequiredArguments() {
        List<MCPPromptArgument> required = new ArrayList<>();
        for (MCPPromptArgument arg : arguments) {
            if (arg.isRequired()) {
                required.add(arg);
            }
        }
        return required;
    }

    @Override
    public String toString() {
        return String.format("MCPPrompt{name='%s', args=%d}", name, arguments.size());
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        MCPPrompt that = (MCPPrompt) obj;
        return name != null ? name.equals(that.name) : that.name == null;
    }

    @Override
    public int hashCode() {
        return name != null ? name.hashCode() : 0;
    }
}

```

`src/main/java/ghidrassist/mcp2/prompts/MCPPromptArgument.java`:

```java
package ghidrassist.mcp2.prompts;

/**
 * Data class representing an argument for an MCP prompt.
 */
public class MCPPromptArgument {
    private final String name;
    private final String description;
    private final Boolean required;

    public MCPPromptArgument(String name, String description, Boolean required) {
        this.name = name;
        this.description = description;
        this.required = required;
    }

    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }

    public Boolean isRequired() {
        return required != null ? required : false;
    }

    @Override
    public String toString() {
        return String.format("MCPPromptArgument{name='%s', required=%s}", name, required);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        MCPPromptArgument that = (MCPPromptArgument) obj;
        return name != null ? name.equals(that.name) : that.name == null;
    }

    @Override
    public int hashCode() {
        return name != null ? name.hashCode() : 0;
    }
}

```

`src/main/java/ghidrassist/mcp2/protocol/MCPClientAdapter.java`:

```java
package ghidrassist.mcp2.protocol;

import ghidrassist.mcp2.prompts.MCPPrompt;
import ghidrassist.mcp2.prompts.MCPPromptArgument;
import ghidrassist.mcp2.resources.MCPResource;
import ghidrassist.mcp2.server.MCPServerConfig;
import ghidrassist.mcp2.server.MCPServerConfig.TransportType;
import ghidrassist.mcp2.tools.MCPTool;
import ghidra.util.Msg;

import com.google.gson.JsonObject;
import com.google.gson.JsonElement;
import com.google.gson.Gson;

import io.modelcontextprotocol.client.McpClient;
import io.modelcontextprotocol.client.McpAsyncClient;
import io.modelcontextprotocol.client.transport.HttpClientSseClientTransport;
import io.modelcontextprotocol.client.transport.HttpClientStreamableHttpTransport;
import io.modelcontextprotocol.spec.McpClientTransport;
import io.modelcontextprotocol.spec.McpSchema;

import java.time.Duration;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * Adapter that wraps the official MCP SDK client to provide compatibility
 * with our existing GhidrAssist MCP architecture.
 */
public class MCPClientAdapter {
    
    private final MCPServerConfig config;
    private volatile McpAsyncClient mcpClient;
    private MCPClientHandler handler;
    private volatile boolean initialized = false;
    private List<MCPTool> discoveredTools = new ArrayList<>();
    private List<MCPResource> discoveredResources = new ArrayList<>();
    private List<MCPPrompt> discoveredPrompts = new ArrayList<>();
    
    /**
     * Interface for handling client events (compatibility with existing code)
     */
    public interface MCPClientHandler {
        void onConnected(MCPClientAdapter client);
        void onDisconnected(MCPClientAdapter client);
        void onToolsDiscovered(MCPClientAdapter client, List<MCPTool> tools);
        void onResourcesDiscovered(MCPClientAdapter client, List<MCPResource> resources);
        void onPromptsDiscovered(MCPClientAdapter client, List<MCPPrompt> prompts);
        void onError(MCPClientAdapter client, Throwable error);
    }
    
    public MCPClientAdapter(MCPServerConfig config) {
        this.config = config;
    }
    
    /**
     * Set client event handler
     */
    public void setHandler(MCPClientHandler handler) {
        this.handler = handler;
    }
    
    /**
     * Connect and initialize the MCP client using the official SDK
     */
    public CompletableFuture<Void> connect() {
        return CompletableFuture.runAsync(() -> {
            try {
                // Create transport based on configuration
                McpClientTransport transport = createTransport();

                // Build client with our configuration
                McpSchema.ClientCapabilities capabilities = McpSchema.ClientCapabilities.builder()
                    .build();

                mcpClient = McpClient.async(transport)
                    .requestTimeout(Duration.ofSeconds(60))
                    .capabilities(capabilities)
                    .build();

                Msg.info(this, "MCP async client created with 60s timeout for: " + config.getName() +
                         " using " + config.getTransport().getDisplayName() + " transport");

                // Initialize connection (required by SDK)
                mcpClient.initialize().block();

                Msg.info(this, "Connected to MCP server using official SDK: " + config.getName());

                // Discover tools, resources, and prompts after initialization
                discoverTools().get();
                discoverResources().get();
                discoverPrompts().get();

                initialized = true;

                // Notify handler on EDT for UI updates
                if (handler != null) {
                    javax.swing.SwingUtilities.invokeLater(() -> handler.onConnected(this));
                }

            } catch (Exception e) {
                Msg.error(this, "Failed to connect to MCP server: " + e.getMessage());

                // Notify error on EDT for UI updates
                if (handler != null) {
                    javax.swing.SwingUtilities.invokeLater(() -> handler.onError(this, e));
                }

                throw new RuntimeException("MCP client connection failed", e);
            }
        });
    }

    /**
     * Create transport based on server configuration type.
     */
    private McpClientTransport createTransport() {
        String baseUrl = config.getBaseUrl();

        switch (config.getTransport()) {
            case STREAMABLE_HTTP:
                // Streamable HTTP uses /mcp endpoint
                String mcpUrl = baseUrl.endsWith("/") ? baseUrl + "mcp" : baseUrl + "/mcp";
                Msg.debug(this, "Creating Streamable HTTP transport for: " + mcpUrl);
                return HttpClientStreamableHttpTransport.builder(mcpUrl).build();
            case SSE:
            default:
                // SSE uses base URL (endpoints at /sse and /message)
                Msg.debug(this, "Creating SSE transport for: " + baseUrl);
                return HttpClientSseClientTransport.builder(baseUrl).build();
        }
    }
    
    /**
     * Disconnect from the MCP server
     */
    public CompletableFuture<Void> disconnect() {
        return CompletableFuture.runAsync(() -> {
            try {
                if (mcpClient != null) {
                    mcpClient.closeGracefully().block();
                    mcpClient = null;
                }

                initialized = false;
                discoveredTools.clear();
                discoveredResources.clear();
                discoveredPrompts.clear();

                // Notify handler on EDT for UI updates
                if (handler != null) {
                    javax.swing.SwingUtilities.invokeLater(() -> handler.onDisconnected(this));
                }

            } catch (Exception e) {
                Msg.error(this, "Error during disconnect: " + e.getMessage());
            }
        });
    }
    
    /**
     * Execute a tool call using the official SDK async client
     */
    public CompletableFuture<JsonElement> executeTool(String toolName, JsonObject arguments) {
        if (!initialized || mcpClient == null) {
            return CompletableFuture.failedFuture(
                new IllegalStateException("Client not initialized"));
        }
        
        // Convert JsonObject to the format expected by the SDK
        McpSchema.CallToolRequest toolCallRequest = new McpSchema.CallToolRequest(
            toolName, 
            convertJsonObjectToMap(arguments)
        );
        
        Msg.debug(this, "Executing tool: " + toolName + " on server: " + config.getName());
        
        // Use async client and convert Mono to CompletableFuture
        return mcpClient.callTool(toolCallRequest)
            .doOnSubscribe(subscription -> Msg.debug(this, "Starting tool execution: " + toolName + " on server: " + config.getName()))
            .doOnNext(result -> Msg.debug(this, "Received tool response: " + toolName))
            .map(result -> {
                Msg.debug(this, "Tool execution completed: " + toolName);
                // Convert result back to JsonElement for compatibility
                Gson gson = new Gson();
                return gson.fromJson(gson.toJson(result.content()), JsonElement.class);
            })
            .doOnError(e -> Msg.error(this, "Tool execution failed for " + toolName + ": " + e.getMessage()))
            .doOnCancel(() -> Msg.warn(this, "Tool execution cancelled: " + toolName))
            .onErrorMap(e -> new RuntimeException("Tool execution failed: " + e.getMessage(), e))
            .toFuture();
    }
    
    /**
     * Get all discovered tools
     */
    public List<MCPTool> getDiscoveredTools() {
        return new ArrayList<>(discoveredTools);
    }
    
    /**
     * Find tool by name
     */
    public MCPTool findTool(String toolName) {
        return discoveredTools.stream()
            .filter(tool -> tool.matchesName(toolName))
            .findFirst()
            .orElse(null);
    }
    
    /**
     * Check if client is connected and initialized
     */
    public boolean isReady() {
        return initialized && mcpClient != null;
    }
    
    /**
     * Get server configuration
     */
    public MCPServerConfig getServerConfig() {
        return config;
    }
    
    /**
     * Get connection status info
     */
    public String getStatusInfo() {
        if (!initialized) {
            return "Disconnected";
        } else {
            return String.format("Connected (%d tools, %d resources, %d prompts)",
                discoveredTools.size(), discoveredResources.size(), discoveredPrompts.size());
        }
    }

    /**
     * Get all discovered resources
     */
    public List<MCPResource> getDiscoveredResources() {
        return new ArrayList<>(discoveredResources);
    }

    /**
     * Get all discovered prompts
     */
    public List<MCPPrompt> getDiscoveredPrompts() {
        return new ArrayList<>(discoveredPrompts);
    }

    /**
     * List all resources from the MCP server.
     * @return CompletableFuture containing list of MCPResource objects
     */
    public CompletableFuture<List<MCPResource>> listResources() {
        if (!initialized || mcpClient == null) {
            return CompletableFuture.completedFuture(Collections.emptyList());
        }

        return mcpClient.listResources()
            .map(result -> result.resources().stream()
                .map(r -> new MCPResource(r.uri(), r.name(), r.description(), r.mimeType()))
                .collect(Collectors.toList()))
            .onErrorResume(e -> {
                Msg.debug(this, "Resources not supported by server: " + e.getMessage());
                return reactor.core.publisher.Mono.just(Collections.emptyList());
            })
            .toFuture();
    }

    /**
     * Read the content of a specific resource by URI.
     * @param uri The resource URI to read
     * @return CompletableFuture containing the resource content as a string
     */
    public CompletableFuture<String> readResource(String uri) {
        if (!initialized || mcpClient == null) {
            return CompletableFuture.failedFuture(
                new IllegalStateException("Client not initialized"));
        }

        McpSchema.ReadResourceRequest request = new McpSchema.ReadResourceRequest(uri);

        return mcpClient.readResource(request)
            .map(result -> {
                if (result.contents() != null && !result.contents().isEmpty()) {
                    McpSchema.ResourceContents content = result.contents().get(0);
                    if (content instanceof McpSchema.TextResourceContents) {
                        return ((McpSchema.TextResourceContents) content).text();
                    } else if (content instanceof McpSchema.BlobResourceContents) {
                        return ((McpSchema.BlobResourceContents) content).blob();
                    }
                }
                return "";
            })
            .onErrorMap(e -> new RuntimeException("Failed to read resource: " + e.getMessage(), e))
            .toFuture();
    }

    /**
     * List all prompts from the MCP server.
     * @return CompletableFuture containing list of MCPPrompt objects
     */
    public CompletableFuture<List<MCPPrompt>> listPrompts() {
        if (!initialized || mcpClient == null) {
            return CompletableFuture.completedFuture(Collections.emptyList());
        }

        return mcpClient.listPrompts()
            .map(result -> result.prompts().stream()
                .map(p -> {
                    List<MCPPromptArgument> args = null;
                    if (p.arguments() != null) {
                        args = p.arguments().stream()
                            .map(a -> new MCPPromptArgument(a.name(), a.description(), a.required()))
                            .collect(Collectors.toList());
                    }
                    return new MCPPrompt(p.name(), p.description(), args);
                })
                .collect(Collectors.toList()))
            .onErrorResume(e -> {
                Msg.debug(this, "Prompts not supported by server: " + e.getMessage());
                return reactor.core.publisher.Mono.just(Collections.emptyList());
            })
            .toFuture();
    }

    /**
     * Get a specific prompt with arguments.
     * @param name The prompt name
     * @param arguments Map of argument name to value
     * @return CompletableFuture containing the prompt result
     */
    public CompletableFuture<McpSchema.GetPromptResult> getPrompt(String name, Map<String, Object> arguments) {
        if (!initialized || mcpClient == null) {
            return CompletableFuture.failedFuture(
                new IllegalStateException("Client not initialized"));
        }

        McpSchema.GetPromptRequest request = new McpSchema.GetPromptRequest(name, arguments);

        return mcpClient.getPrompt(request)
            .onErrorMap(e -> new RuntimeException("Failed to get prompt: " + e.getMessage(), e))
            .toFuture();
    }
    
    /**
     * Discover available tools using the official SDK
     */
    private CompletableFuture<Void> discoverTools() {
        return CompletableFuture.runAsync(() -> {
            try {
                McpSchema.ListToolsResult toolsResult = mcpClient.listTools().block();
                List<MCPTool> tools = new ArrayList<>();
                
                for (McpSchema.Tool tool : toolsResult.tools()) {
                    // Convert SDK tool to our MCPTool format
                    MCPTool mcpTool = new MCPTool();
                    mcpTool.setName(tool.name());
                    mcpTool.setDescription(tool.description());
                    mcpTool.setServerName(config.getName());
                    
                    // Convert input schema if present
                    if (tool.inputSchema() != null) {
                        Gson gson = new Gson();
                        JsonObject schema = gson.fromJson(gson.toJson(tool.inputSchema()), JsonObject.class);
                        mcpTool.setInputSchema(schema);
                    }
                    
                    tools.add(mcpTool);
                }
                
                discoveredTools = tools;
                Msg.info(this, String.format("Successfully discovered %d tools from %s using official SDK", 
                                            tools.size(), config.getName()));
                
                // Notify handler on EDT for UI updates
                if (handler != null) {
                    javax.swing.SwingUtilities.invokeLater(() -> 
                        handler.onToolsDiscovered(this, tools));
                }
                
            } catch (Exception e) {
                Msg.error(this, "Tool discovery failed with exception: " + e.getMessage());
                throw new RuntimeException("Tool discovery failed", e);
            }
        });
    }

    /**
     * Discover available resources using the official SDK.
     * Resources are optional - servers may not support them.
     */
    private CompletableFuture<Void> discoverResources() {
        return CompletableFuture.runAsync(() -> {
            try {
                McpSchema.ListResourcesResult resourcesResult = mcpClient.listResources().block();
                List<MCPResource> resources = new ArrayList<>();

                if (resourcesResult != null && resourcesResult.resources() != null) {
                    for (McpSchema.Resource resource : resourcesResult.resources()) {
                        MCPResource mcpResource = new MCPResource(
                            resource.uri(),
                            resource.name(),
                            resource.description(),
                            resource.mimeType()
                        );
                        resources.add(mcpResource);
                    }
                }

                discoveredResources = resources;
                Msg.info(this, String.format("Discovered %d resources from %s",
                                            resources.size(), config.getName()));

                // Notify handler on EDT for UI updates
                if (handler != null && !resources.isEmpty()) {
                    javax.swing.SwingUtilities.invokeLater(() ->
                        handler.onResourcesDiscovered(this, resources));
                }

            } catch (Exception e) {
                // Resources are optional - don't fail connection if not supported
                Msg.debug(this, "Resource discovery not supported: " + e.getMessage());
                discoveredResources = new ArrayList<>();
            }
        });
    }

    /**
     * Discover available prompts using the official SDK.
     * Prompts are optional - servers may not support them.
     */
    private CompletableFuture<Void> discoverPrompts() {
        return CompletableFuture.runAsync(() -> {
            try {
                McpSchema.ListPromptsResult promptsResult = mcpClient.listPrompts().block();
                List<MCPPrompt> prompts = new ArrayList<>();

                if (promptsResult != null && promptsResult.prompts() != null) {
                    for (McpSchema.Prompt prompt : promptsResult.prompts()) {
                        List<MCPPromptArgument> args = null;
                        if (prompt.arguments() != null) {
                            args = prompt.arguments().stream()
                                .map(a -> new MCPPromptArgument(a.name(), a.description(), a.required()))
                                .collect(Collectors.toList());
                        }
                        MCPPrompt mcpPrompt = new MCPPrompt(
                            prompt.name(),
                            prompt.description(),
                            args
                        );
                        prompts.add(mcpPrompt);
                    }
                }

                discoveredPrompts = prompts;
                Msg.info(this, String.format("Discovered %d prompts from %s",
                                            prompts.size(), config.getName()));

                // Notify handler on EDT for UI updates
                if (handler != null && !prompts.isEmpty()) {
                    javax.swing.SwingUtilities.invokeLater(() ->
                        handler.onPromptsDiscovered(this, prompts));
                }

            } catch (Exception e) {
                // Prompts are optional - don't fail connection if not supported
                Msg.debug(this, "Prompt discovery not supported: " + e.getMessage());
                discoveredPrompts = new ArrayList<>();
            }
        });
    }

    /**
     * Convert JsonObject to Map for SDK compatibility
     */
    private java.util.Map<String, Object> convertJsonObjectToMap(JsonObject jsonObject) {
        Gson gson = new Gson();
        java.lang.reflect.Type type = new com.google.gson.reflect.TypeToken<java.util.Map<String, Object>>(){}.getType();
        return gson.fromJson(jsonObject, type);
    }
}
```

`src/main/java/ghidrassist/mcp2/resources/MCPResource.java`:

```java
package ghidrassist.mcp2.resources;

/**
 * Data class representing an MCP resource.
 * Resources are data that can be read by clients from MCP servers.
 */
public class MCPResource {
    private final String uri;
    private final String name;
    private final String description;
    private final String mimeType;

    public MCPResource(String uri, String name, String description, String mimeType) {
        this.uri = uri;
        this.name = name;
        this.description = description;
        this.mimeType = mimeType;
    }

    public String getUri() {
        return uri;
    }

    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }

    public String getMimeType() {
        return mimeType;
    }

    @Override
    public String toString() {
        return String.format("MCPResource{uri='%s', name='%s', mimeType='%s'}", uri, name, mimeType);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        MCPResource that = (MCPResource) obj;
        return uri != null ? uri.equals(that.uri) : that.uri == null;
    }

    @Override
    public int hashCode() {
        return uri != null ? uri.hashCode() : 0;
    }
}

```

`src/main/java/ghidrassist/mcp2/server/MCPServerConfig.java`:

```java
package ghidrassist.mcp2.server;

import com.google.gson.Gson;

/**
 * Configuration for an MCP server connection.
 * Stores all necessary information to connect to and manage an MCP server.
 */
public class MCPServerConfig {
    
    public enum TransportType {
        SSE("Server-Sent Events"),
        STREAMABLE_HTTP("Streamable HTTP");

        private final String displayName;

        TransportType(String displayName) {
            this.displayName = displayName;
        }

        public String getDisplayName() {
            return displayName;
        }
    }
    
    private String name;                    // Display name (e.g., "GhidraMCP Local")
    private String url;                     // Server URL (e.g., "http://localhost:8081")
    private TransportType transport;        // Transport mechanism
    private int connectionTimeout;          // Connection timeout in seconds
    private int requestTimeout;            // Request timeout in seconds
    private boolean enabled;               // Whether this server is active
    private String description;            // Optional description
    
    // Default constructor for JSON deserialization
    public MCPServerConfig() {
        this.transport = TransportType.SSE;
        this.connectionTimeout = 15;
        this.requestTimeout = 30;
        this.enabled = true;
    }
    
    public MCPServerConfig(String name, String url) {
        this();
        this.name = name;
        this.url = url;
    }
    
    public MCPServerConfig(String name, String url, TransportType transport) {
        this(name, url);
        this.transport = transport;
    }
    
    public MCPServerConfig(String name, String url, TransportType transport, boolean enabled) {
        this(name, url, transport);
        this.enabled = enabled;
    }
    
    // Getters and setters
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getUrl() {
        return url;
    }
    
    public void setUrl(String url) {
        this.url = url;
    }
    
    public TransportType getTransport() {
        return transport;
    }
    
    public void setTransport(TransportType transport) {
        this.transport = transport;
    }
    
    public int getConnectionTimeout() {
        return connectionTimeout;
    }
    
    public void setConnectionTimeout(int connectionTimeout) {
        this.connectionTimeout = connectionTimeout;
    }
    
    public int getRequestTimeout() {
        return requestTimeout;
    }
    
    public void setRequestTimeout(int requestTimeout) {
        this.requestTimeout = requestTimeout;
    }
    
    public boolean isEnabled() {
        return enabled;
    }
    
    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }
    
    public String getDescription() {
        return description;
    }
    
    public void setDescription(String description) {
        this.description = description;
    }
    
    /**
     * Get the base URL for HTTP connections
     */
    public String getBaseUrl() {
        if (url == null) return null;
        
        // Ensure URL has protocol
        if (!url.startsWith("http://") && !url.startsWith("https://")) {
            return "http://" + url;
        }
        return url;
    }
    
    /**
     * Get the host from the URL
     */
    public String getHost() {
        try {
            java.net.URI uri = java.net.URI.create(getBaseUrl());
            String host = uri.getHost();
            return host != null ? host : "localhost";
        } catch (Exception e) {
            return "localhost";
        }
    }

    /**
     * Get the port from the URL
     */
    public int getPort() {
        try {
            java.net.URI uri = java.net.URI.create(getBaseUrl());
            int port = uri.getPort();
            if (port != -1) return port;
            return "https".equals(uri.getScheme()) ? 443 : 80;
        } catch (Exception e) {
            return 8081; // Default MCP port
        }
    }
    
    /**
     * Validate configuration
     */
    public boolean isValid() {
        return name != null && !name.trim().isEmpty() &&
               url != null && !url.trim().isEmpty() &&
               transport != null &&
               connectionTimeout > 0 &&
               requestTimeout > 0;
    }
    
    /**
     * Create a copy of this configuration
     */
    public MCPServerConfig copy() {
        MCPServerConfig copy = new MCPServerConfig(name, url, transport);
        copy.setConnectionTimeout(connectionTimeout);
        copy.setRequestTimeout(requestTimeout);
        copy.setEnabled(enabled);
        copy.setDescription(description);
        return copy;
    }
    
    /**
     * Serialize to JSON
     */
    public String toJson() {
        return new Gson().toJson(this);
    }
    
    /**
     * Deserialize from JSON
     */
    public static MCPServerConfig fromJson(String json) {
        return new Gson().fromJson(json, MCPServerConfig.class);
    }
    
    @Override
    public String toString() {
        return String.format("%s (%s) - %s", name, transport.getDisplayName(), 
                           enabled ? "Enabled" : "Disabled");
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        
        MCPServerConfig that = (MCPServerConfig) obj;
        return name != null ? name.equals(that.name) : that.name == null;
    }
    
    @Override
    public int hashCode() {
        return name != null ? name.hashCode() : 0;
    }
    
    /**
     * Create default MCP configuration
     */
    public static MCPServerConfig createGhidrAssistMCPDefault() {
        MCPServerConfig config = new MCPServerConfig("GhidrAssistMCP", "http://localhost:8080");
        config.setDescription("Local GhidrAssistMCP server instance");
        config.setTransport(TransportType.SSE);
        return config;
    }
}
```

`src/main/java/ghidrassist/mcp2/server/MCPServerRegistry.java`:

```java
package ghidrassist.mcp2.server;

import ghidra.framework.preferences.Preferences;
import ghidra.util.Msg;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Registry for managing MCP server configurations.
 * Handles persistence, validation, and server lifecycle.
 */
public class MCPServerRegistry {
    
    private static MCPServerRegistry instance;
    private static final String PREFERENCE_KEY = "GhidrAssist.MCPServers";
    
    private List<MCPServerConfig> servers = new ArrayList<>();
    private MCPServerRegistryHandler handler;
    
    /**
     * Interface for handling registry events
     */
    public interface MCPServerRegistryHandler {
        void onServersChanged(List<MCPServerConfig> servers);
        void onServerAdded(MCPServerConfig server);
        void onServerRemoved(MCPServerConfig server);
        void onServerUpdated(MCPServerConfig server);
    }
    
    private MCPServerRegistry() {
        loadServers();
    }
    
    /**
     * Get singleton instance
     */
    public static synchronized MCPServerRegistry getInstance() {
        if (instance == null) {
            instance = new MCPServerRegistry();
        }
        return instance;
    }
    
    /**
     * Set event handler
     */
    public void setHandler(MCPServerRegistryHandler handler) {
        this.handler = handler;
    }
    
    /**
     * Add a new server configuration
     */
    public void addServer(MCPServerConfig server) {
        if (server == null || !server.isValid()) {
            throw new IllegalArgumentException("Invalid server configuration");
        }
        
        // Check for duplicate names
        if (servers.stream().anyMatch(s -> s.getName().equals(server.getName()))) {
            throw new IllegalArgumentException("Server with name '" + server.getName() + "' already exists");
        }
        
        servers.add(server);
        saveServers();
        
        if (handler != null) {
            handler.onServerAdded(server);
            handler.onServersChanged(new ArrayList<>(servers));
        }
        
        Msg.info(this, "Added MCP server: " + server.getName());
    }
    
    /**
     * Remove a server configuration
     */
    public boolean removeServer(String serverName) {
        MCPServerConfig toRemove = servers.stream()
            .filter(s -> s.getName().equals(serverName))
            .findFirst()
            .orElse(null);
        
        if (toRemove != null) {
            servers.remove(toRemove);
            saveServers();
            
            if (handler != null) {
                handler.onServerRemoved(toRemove);
                handler.onServersChanged(new ArrayList<>(servers));
            }
            
            Msg.info(this, "Removed MCP server: " + serverName);
            return true;
        }
        
        return false;
    }
    
    /**
     * Update an existing server configuration
     */
    public boolean updateServer(MCPServerConfig updatedServer) {
        if (updatedServer == null || !updatedServer.isValid()) {
            throw new IllegalArgumentException("Invalid server configuration");
        }
        
        for (int i = 0; i < servers.size(); i++) {
            if (servers.get(i).getName().equals(updatedServer.getName())) {
                servers.set(i, updatedServer);
                saveServers();
                
                if (handler != null) {
                    handler.onServerUpdated(updatedServer);
                    handler.onServersChanged(new ArrayList<>(servers));
                }
                
                Msg.info(this, "Updated MCP server: " + updatedServer.getName());
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Get all server configurations
     */
    public List<MCPServerConfig> getAllServers() {
        return new ArrayList<>(servers);
    }
    
    /**
     * Get only enabled server configurations
     */
    public List<MCPServerConfig> getEnabledServers() {
        return servers.stream()
            .filter(MCPServerConfig::isEnabled)
            .collect(Collectors.toList());
    }
    
    /**
     * Get server by name
     */
    public MCPServerConfig getServer(String name) {
        return servers.stream()
            .filter(s -> s.getName().equals(name))
            .findFirst()
            .orElse(null);
    }
    
    /**
     * Check if any servers are configured
     */
    public boolean hasServers() {
        return !servers.isEmpty();
    }
    
    /**
     * Check if any servers are enabled
     */
    public boolean hasEnabledServers() {
        return servers.stream().anyMatch(MCPServerConfig::isEnabled);
    }
    
    /**
     * Enable/disable a server
     */
    public boolean setServerEnabled(String serverName, boolean enabled) {
        MCPServerConfig server = getServer(serverName);
        if (server != null) {
            server.setEnabled(enabled);
            saveServers();
            
            if (handler != null) {
                handler.onServerUpdated(server);
                handler.onServersChanged(new ArrayList<>(servers));
            }
            
            Msg.info(this, (enabled ? "Enabled" : "Disabled") + " MCP server: " + serverName);
            return true;
        }
        return false;
    }
    
    /**
     * Initialize with default servers if none exist
     */
    public void initializeDefaults() {
        if (servers.isEmpty()) {
            // Add default GhidrAssistMCP server (disabled by default)
            MCPServerConfig defaultServer = MCPServerConfig.createGhidrAssistMCPDefault();
            defaultServer.setEnabled(false); // Disabled by default until user enables
            try {
                servers.add(defaultServer); // Add directly to avoid validation during initialization
                saveServers();
            } catch (Exception e) {
                Msg.warn(this, "Failed to create default MCP server: " + e.getMessage());
            }
            
            Msg.info(this, "Initialized default MCP server configurations");
        }
    }
    
    /**
     * Load servers from preferences
     */
    private void loadServers() {
        String serversJson = Preferences.getProperty(PREFERENCE_KEY, "[]");

        try {
            Gson gson = new Gson();
            Type listType = new TypeToken<List<MCPServerConfig>>(){}.getType();
            List<MCPServerConfig> loadedServers = gson.fromJson(serversJson, listType);

            if (loadedServers != null) {
                // Validate and migrate loaded servers
                servers = loadedServers.stream()
                    .filter(MCPServerConfig::isValid)
                    .map(this::migrateServerConfig)  // Apply migration
                    .collect(Collectors.toList());

                Msg.info(this, "Loaded " + servers.size() + " MCP server configurations");

                // Save migrated configurations
                saveServers();
            }
        } catch (Exception e) {
            Msg.error(this, "Failed to load MCP server configurations: " + e.getMessage());
            servers = new ArrayList<>();

            // Try to recover by parsing and migrating old format
            try {
                servers = migrateOldFormat(serversJson);
                if (!servers.isEmpty()) {
                    saveServers();
                }
            } catch (Exception e2) {
                Msg.debug(this, "Migration also failed: " + e2.getMessage());
            }
        }

        // Initialize defaults if no servers loaded
        if (servers.isEmpty()) {
            initializeDefaults();
        }
    }

    /**
     * Attempt to migrate servers from old format that might have STDIO transport.
     */
    private List<MCPServerConfig> migrateOldFormat(String serversJson) {
        List<MCPServerConfig> migrated = new ArrayList<>();

        try {
            // Parse as generic JSON array
            com.google.gson.JsonArray array = new Gson().fromJson(serversJson, com.google.gson.JsonArray.class);
            if (array == null) return migrated;

            for (com.google.gson.JsonElement element : array) {
                if (!element.isJsonObject()) continue;
                com.google.gson.JsonObject obj = element.getAsJsonObject();

                String name = obj.has("name") ? obj.get("name").getAsString() : null;
                String url = obj.has("url") ? obj.get("url").getAsString() : null;

                if (name == null || url == null) continue;

                MCPServerConfig config = new MCPServerConfig(name, url);

                // Check transport type - migrate STDIO to SSE
                if (obj.has("transport")) {
                    String transportStr = obj.get("transport").getAsString();
                    if ("STDIO".equals(transportStr)) {
                        config.setTransport(MCPServerConfig.TransportType.SSE);
                        Msg.info(this, "Migrated server '" + name + "' from STDIO to SSE transport");
                    } else if ("STREAMABLE_HTTP".equals(transportStr)) {
                        config.setTransport(MCPServerConfig.TransportType.STREAMABLE_HTTP);
                    } else {
                        config.setTransport(MCPServerConfig.TransportType.SSE);
                    }
                }

                if (obj.has("enabled")) {
                    config.setEnabled(obj.get("enabled").getAsBoolean());
                }
                if (obj.has("description")) {
                    config.setDescription(obj.get("description").getAsString());
                }

                if (config.isValid()) {
                    migrated.add(migrateServerConfig(config));
                }
            }
        } catch (Exception e) {
            Msg.debug(this, "Old format migration failed: " + e.getMessage());
        }

        return migrated;
    }
    
    /**
     * Migrate server configuration to apply new timeout defaults and handle transport migration.
     */
    private MCPServerConfig migrateServerConfig(MCPServerConfig server) {
        boolean needsMigration = false;

        // Handle null transport (fallback to SSE)
        if (server.getTransport() == null) {
            server.setTransport(MCPServerConfig.TransportType.SSE);
            Msg.info(this, "Migrated server '" + server.getName() + "' with null transport to SSE");
            needsMigration = true;
        }

        // Update old timeout values to new optimized defaults
        if (server.getConnectionTimeout() >= 10) {  // Old default was 10 seconds
            server.setConnectionTimeout(5);  // New optimized default
            needsMigration = true;
        }

        if (server.getRequestTimeout() >= 30) {  // Old default was 30 seconds
            server.setRequestTimeout(15);  // New optimized default
            needsMigration = true;
        }

        if (needsMigration) {
            Msg.info(this, "Migrated settings for MCP server: " + server.getName() +
                     " (transport: " + server.getTransport() + ", connection: " + server.getConnectionTimeout() +
                     "s, request: " + server.getRequestTimeout() + "s)");
        }

        return server;
    }
    
    /**
     * Save servers to preferences
     */
    private void saveServers() {
        try {
            Gson gson = new Gson();
            String serversJson = gson.toJson(servers);
            Preferences.setProperty(PREFERENCE_KEY, serversJson);
            Preferences.store();
        } catch (Exception e) {
            Msg.error(this, "Failed to save MCP server configurations: " + e.getMessage());
        }
    }
    
    /**
     * Clear all servers (for testing/reset)
     */
    public void clearAllServers() {
        servers.clear();
        saveServers();
        
        if (handler != null) {
            handler.onServersChanged(new ArrayList<>(servers));
        }
        
        Msg.info(this, "Cleared all MCP server configurations");
    }
    
    /**
     * Get status summary
     */
    public String getStatusSummary() {
        long enabledCount = servers.stream().filter(MCPServerConfig::isEnabled).count();
        return String.format("%d servers (%d enabled)", servers.size(), enabledCount);
    }
}
```

`src/main/java/ghidrassist/mcp2/tools/BinaryContextInjector.java`:

```java
package ghidrassist.mcp2.tools;

import ghidra.program.model.listing.Program;
import ghidra.program.model.address.Address;
import ghidra.util.Msg;
import com.google.gson.JsonObject;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

/**
 * Automatically injects binary context (filename, address) into tool arguments
 * when they're missing but likely needed.
 *
 * This reduces friction in the ReAct loop - the LLM doesn't need to explicitly
 * provide the current program or location for every tool call.
 */
public class BinaryContextInjector {

    private final Program currentProgram;
    private final Address currentAddress;

    // Tools that commonly need filename
    private static final Set<String> FILENAME_TOOLS = new HashSet<>(Arrays.asList(
        "get_function_at",
        "get_function_by_name",
        "get_functions",
        "get_function_signature",
        "decompile_function",
        "get_xrefs_to",
        "get_xrefs_from",
        "get_strings",
        "get_imports",
        "get_exports",
        "get_sections",
        "analyze_function",
        "find_pattern",
        "search_bytes"
    ));

    // Tools that commonly need address
    private static final Set<String> ADDRESS_TOOLS = new HashSet<>(Arrays.asList(
        "get_function_at",
        "get_instruction_at",
        "get_data_at",
        "get_xrefs_to",
        "get_xrefs_from",
        "decompile_at",
        "disassemble_at",
        "analyze_at"
    ));

    /**
     * Create injector with current Ghidra context.
     *
     * @param currentProgram Current program (can be null if no program open)
     * @param currentAddress Current address/location (can be null if no location)
     */
    public BinaryContextInjector(Program currentProgram, Address currentAddress) {
        this.currentProgram = currentProgram;
        this.currentAddress = currentAddress;
    }

    /**
     * Enhance tool arguments by injecting missing context.
     *
     * @param toolName Name of the tool being called
     * @param arguments Original arguments from LLM
     * @return Enhanced arguments with injected context
     */
    public JsonObject enhanceArguments(String toolName, JsonObject arguments) {
        if (arguments == null) {
            arguments = new JsonObject();
        }

        // Make a copy to avoid modifying original
        JsonObject enhanced = arguments.deepCopy();

        // Inject filename if missing and tool needs it
        if (shouldInjectFilename(toolName, enhanced)) {
            String filename = getFilename();
            if (filename != null) {
                enhanced.addProperty("filename", filename);
                Msg.debug(this, String.format("Auto-injected filename '%s' for tool '%s'", filename, toolName));
            }
        }

        // Inject address if missing and tool needs it
        if (shouldInjectAddress(toolName, enhanced)) {
            String address = getAddressString();
            if (address != null) {
                enhanced.addProperty("address", address);
                Msg.debug(this, String.format("Auto-injected address '%s' for tool '%s'", address, toolName));
            }
        }

        return enhanced;
    }

    /**
     * Check if we should inject filename for this tool call.
     */
    private boolean shouldInjectFilename(String toolName, JsonObject arguments) {
        // Don't inject if already present
        if (arguments.has("filename") || arguments.has("file") || arguments.has("binary")) {
            return false;
        }

        // Check if tool commonly needs filename
        if (!FILENAME_TOOLS.contains(toolName.toLowerCase())) {
            return false;
        }

        // Don't inject if no program available
        if (currentProgram == null) {
            return false;
        }

        return true;
    }

    /**
     * Check if we should inject address for this tool call.
     */
    private boolean shouldInjectAddress(String toolName, JsonObject arguments) {
        // Don't inject if already present
        if (arguments.has("address") || arguments.has("addr") || arguments.has("location")) {
            return false;
        }

        // Check if tool commonly needs address
        if (!ADDRESS_TOOLS.contains(toolName.toLowerCase())) {
            return false;
        }

        // Don't inject if no address available
        if (currentAddress == null) {
            return false;
        }

        return true;
    }

    /**
     * Get filename from current program.
     */
    private String getFilename() {
        if (currentProgram == null) {
            return null;
        }

        return currentProgram.getName();
    }

    /**
     * Get address string from current location.
     */
    private String getAddressString() {
        if (currentAddress == null) {
            return null;
        }

        return currentAddress.toString();
    }

    /**
     * Update the current program context (e.g., if program changed).
     */
    public static BinaryContextInjector fromProgram(Program program, Address address) {
        return new BinaryContextInjector(program, address);
    }

    /**
     * Check if context is available (has program or address).
     */
    public boolean hasContext() {
        return currentProgram != null || currentAddress != null;
    }

    /**
     * Get description of available context for logging/debugging.
     */
    public String getContextDescription() {
        StringBuilder desc = new StringBuilder();

        if (currentProgram != null) {
            desc.append("Program: ").append(currentProgram.getName());
        }

        if (currentAddress != null) {
            if (desc.length() > 0) {
                desc.append(", ");
            }
            desc.append("Address: ").append(currentAddress);
        }

        if (desc.length() == 0) {
            desc.append("No context available");
        }

        return desc.toString();
    }
}

```

`src/main/java/ghidrassist/mcp2/tools/MCPTool.java`:

```java
package ghidrassist.mcp2.tools;

import com.google.gson.JsonObject;
import com.google.gson.JsonElement;
import java.util.Map;
import java.util.HashMap;

/**
 * Represents an MCP tool discovered from a server.
 * This is server-agnostic and follows the MCP specification.
 */
public class MCPTool {
    
    private String name;
    private String description;
    private JsonObject inputSchema;
    private String serverName;      // Which server provides this tool
    
    // Default constructor for adapter
    public MCPTool() {
    }
    
    public MCPTool(String name, String description, JsonObject inputSchema, String serverName) {
        this.name = name;
        this.description = description;
        this.inputSchema = inputSchema;
        this.serverName = serverName;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getDescription() {
        return description;
    }
    
    public void setDescription(String description) {
        this.description = description;
    }
    
    public JsonObject getInputSchema() {
        return inputSchema;
    }
    
    public void setInputSchema(JsonObject inputSchema) {
        this.inputSchema = inputSchema;
    }
    
    public String getServerName() {
        return serverName;
    }
    
    public void setServerName(String serverName) {
        this.serverName = serverName;
    }
    
    /**
     * Check if this tool has input parameters
     */
    public boolean hasInputSchema() {
        return inputSchema != null && inputSchema.size() > 0;
    }
    
    /**
     * Convert to function schema for LLM function calling
     * This follows the OpenAI function calling format
     */
    public Map<String, Object> toFunctionSchema() {
        Map<String, Object> function = new HashMap<>();
        function.put("type", "function");
        
        Map<String, Object> functionDef = new HashMap<>();
        functionDef.put("name", name);
        functionDef.put("description", description);
        
        if (inputSchema != null) {
            // Convert JsonObject to Map for compatibility
            functionDef.put("parameters", jsonObjectToMap(inputSchema));
        } else {
            // Empty parameters schema
            Map<String, Object> emptyParams = new HashMap<>();
            emptyParams.put("type", "object");
            emptyParams.put("properties", new HashMap<>());
            functionDef.put("parameters", emptyParams);
        }
        
        function.put("function", functionDef);
        return function;
    }
    
    /**
     * Create MCPTool from MCP tools/list response
     */
    public static MCPTool fromToolsListEntry(JsonObject toolEntry, String serverName) {
        String name = toolEntry.has("name") ? toolEntry.get("name").getAsString() : null;
        String description = toolEntry.has("description") ? toolEntry.get("description").getAsString() : "";
        JsonObject inputSchema = toolEntry.has("inputSchema") ? 
            toolEntry.getAsJsonObject("inputSchema") : null;
        
        return new MCPTool(name, description, inputSchema, serverName);
    }
    
    /**
     * Helper method to convert JsonObject to Map recursively
     */
    private Map<String, Object> jsonObjectToMap(JsonObject jsonObject) {
        Map<String, Object> map = new HashMap<>();
        
        for (String key : jsonObject.keySet()) {
            Object value = jsonElementToObject(jsonObject.get(key));
            map.put(key, value);
        }
        
        return map;
    }
    
    /**
     * Helper method to convert JsonElement to Java object
     */
    private Object jsonElementToObject(JsonElement element) {
        if (element.isJsonPrimitive()) {
            if (element.getAsJsonPrimitive().isString()) {
                return element.getAsString();
            } else if (element.getAsJsonPrimitive().isNumber()) {
                return element.getAsNumber();
            } else if (element.getAsJsonPrimitive().isBoolean()) {
                return element.getAsBoolean();
            }
        } else if (element.isJsonObject()) {
            return jsonObjectToMap(element.getAsJsonObject());
        } else if (element.isJsonArray()) {
            com.google.gson.JsonArray array = element.getAsJsonArray();
            java.util.List<Object> list = new java.util.ArrayList<>();
            for (int i = 0; i < array.size(); i++) {
                list.add(jsonElementToObject(array.get(i)));
            }
            return list;
        }
        return null;
    }
    
    @Override
    public String toString() {
        return String.format("MCPTool{name='%s', server='%s', description='%s'}", 
                           name, serverName, description);
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        
        MCPTool mcpTool = (MCPTool) obj;
        return name != null && name.equals(mcpTool.name) && 
               serverName != null && serverName.equals(mcpTool.serverName);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(name, serverName);
    }
    
    /**
     * Get a display name that includes the server
     */
    public String getDisplayName() {
        return String.format("%s (%s)", name, serverName);
    }
    
    /**
     * Check if tool name matches (case-insensitive)
     */
    public boolean matchesName(String toolName) {
        return name != null && name.equalsIgnoreCase(toolName);
    }
}
```

`src/main/java/ghidrassist/mcp2/tools/MCPToolAdapter.java`:

```java
package ghidrassist.mcp2.tools;

import com.google.gson.JsonObject;
import ghidrassist.tools.api.Tool;

/**
 * Adapter that wraps MCPTool to implement the unified Tool interface.
 * This allows MCP tools to be used alongside native tools in the ToolRegistry.
 *
 * Tool names are prefixed with the server name (e.g., "servername.toolname")
 * to avoid conflicts between different MCP servers and native tools.
 */
public class MCPToolAdapter implements Tool {

    private final MCPTool mcpTool;
    private final String prefixedName;

    /**
     * Create an adapter with the server-prefixed name.
     *
     * @param mcpTool The underlying MCP tool
     * @param prefixedName The full prefixed name (e.g., "servername.toolname")
     */
    public MCPToolAdapter(MCPTool mcpTool, String prefixedName) {
        this.mcpTool = mcpTool;
        this.prefixedName = prefixedName;
    }

    @Override
    public String getName() {
        return prefixedName;
    }

    /**
     * Get the original (non-prefixed) tool name.
     */
    public String getOriginalName() {
        return mcpTool.getName();
    }

    @Override
    public String getDescription() {
        return mcpTool.getDescription();
    }

    @Override
    public JsonObject getInputSchema() {
        return mcpTool.getInputSchema();
    }

    @Override
    public String getSource() {
        return "mcp:" + mcpTool.getServerName();
    }

    /**
     * Get the underlying MCPTool.
     */
    public MCPTool getMCPTool() {
        return mcpTool;
    }

    @Override
    public String toString() {
        return String.format("MCPToolAdapter{prefixedName='%s', originalName='%s', server='%s'}",
                            prefixedName, mcpTool.getName(), mcpTool.getServerName());
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        MCPToolAdapter that = (MCPToolAdapter) obj;
        return mcpTool != null && mcpTool.equals(that.mcpTool);
    }

    @Override
    public int hashCode() {
        return mcpTool != null ? mcpTool.hashCode() : 0;
    }
}

```

`src/main/java/ghidrassist/mcp2/tools/MCPToolManager.java`:

```java
package ghidrassist.mcp2.tools;

import ghidrassist.mcp2.protocol.MCPClientAdapter;
import ghidrassist.mcp2.server.MCPServerConfig;
import ghidrassist.mcp2.server.MCPServerRegistry;
import ghidrassist.tools.api.Tool;
import ghidrassist.tools.api.ToolProvider;
import ghidrassist.tools.api.ToolResult;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;

import com.google.gson.JsonObject;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * Manages MCP tools from multiple servers.
 * Handles tool discovery, aggregation, and execution routing.
 *
 * NOTE: This class now implements ToolProvider and handles ONLY MCP server tools.
 * Native/internal tools (semantic, actions) are now handled by NativeToolManager.
 */
public class MCPToolManager implements ToolProvider {

    private static final String PROVIDER_NAME = "MCP";
    private static MCPToolManager instance;

    private final Map<String, MCPClientAdapter> clients = new ConcurrentHashMap<>();
    private final Map<String, MCPTool> allTools = new ConcurrentHashMap<>();
    private MCPToolManagerHandler handler;
    private volatile boolean initialized = false;
    
    /**
     * Interface for handling tool manager events
     */
    public interface MCPToolManagerHandler {
        void onToolsUpdated(List<MCPTool> allTools);
        void onServerConnected(String serverName);
        void onServerDisconnected(String serverName);
        void onServerError(String serverName, Throwable error);
    }

    private MCPToolManager() {
        // Private constructor for singleton
    }

    /**
     * Get singleton instance
     */
    public static synchronized MCPToolManager getInstance() {
        if (instance == null) {
            instance = new MCPToolManager();
        }
        return instance;
    }

    /**
     * Set event handler
     */
    public void setHandler(MCPToolManagerHandler handler) {
        this.handler = handler;
    }

    // ==================== ToolProvider Interface Implementation ====================

    @Override
    public String getProviderName() {
        return PROVIDER_NAME;
    }

    @Override
    public List<Tool> getTools() {
        // Create adapters with the prefixed names (keys from allTools map)
        return allTools.entrySet().stream()
                .map(entry -> new MCPToolAdapter(entry.getValue(), entry.getKey()))
                .collect(Collectors.toList());
    }

    @Override
    public CompletableFuture<ToolResult> executeTool(String name, JsonObject args) {
        MCPTool tool = findTool(name);
        if (tool == null) {
            return CompletableFuture.completedFuture(
                    ToolResult.error("MCP tool not found: " + name));
        }

        MCPClientAdapter client = clients.get(tool.getServerName());
        if (client == null || !client.isReady()) {
            return CompletableFuture.completedFuture(
                    ToolResult.error("MCP server not available: " + tool.getServerName()));
        }

        // Use the original tool name (without server prefix) when calling the MCP server
        String originalToolName = tool.getName();
        Msg.debug(this, "Executing MCP tool: " + name + " (original: " + originalToolName + ") via server: " + tool.getServerName());
        return client.executeTool(originalToolName, args)
                .thenApply(result -> {
                    String content = result != null ? result.toString() : "";
                    return ToolResult.success(content);
                })
                .exceptionally(throwable -> {
                    Msg.error(this, "MCP tool execution failed: " + throwable.getMessage());
                    return ToolResult.error(throwable.getMessage());
                });
    }

    @Override
    public boolean handlesTool(String name) {
        return findTool(name) != null;
    }

    @Override
    public void setContext(Program program) {
        // MCP tools don't need Ghidra program context
        // This is a no-op for MCPToolManager
    }

    // ==================== Internal MCP Tool Execution ====================

    /**
     * Execute an MCP tool and return MCPToolResult.
     * Internal method used by parallel execution. External callers should use
     * executeTool(String, JsonObject) from the ToolProvider interface.
     */
    private CompletableFuture<MCPToolResult> executeToolMCP(String toolName, JsonObject arguments) {
        MCPTool tool = findTool(toolName);
        if (tool == null) {
            return CompletableFuture.completedFuture(
                MCPToolResult.error("Tool not found: " + toolName));
        }

        MCPClientAdapter client = clients.get(tool.getServerName());
        if (client == null || !client.isReady()) {
            return CompletableFuture.completedFuture(
                MCPToolResult.error("Server not available: " + tool.getServerName()));
        }

        // Use the original tool name (without server prefix) when calling the MCP server
        String originalToolName = tool.getName();
        Msg.debug(this, "MCPToolManager delegating to client: " + tool.getServerName() + " for tool: " + originalToolName);
        return client.executeTool(originalToolName, arguments)
            .thenApply(result -> {
                Msg.debug(this, "MCPToolManager received result for tool: " + toolName);
                String content = result != null ? result.toString() : "";
                return MCPToolResult.success(content);
            })
            .exceptionally(throwable -> {
                Msg.error(this, "MCPToolManager caught exception for tool " + toolName + ": " + throwable.getMessage());
                return MCPToolResult.error(throwable.getMessage());
            });
    }
    
    // ==================== MCP Server Connection Management ====================

    /**
     * Initialize connections to all enabled servers
     * This method is safe to call from any thread including the EDT
     */
    public CompletableFuture<Void> initializeServers() {
        return CompletableFuture.runAsync(() -> {
            // Ensure all work happens off the EDT
            List<MCPServerConfig> enabledServers = MCPServerRegistry.getInstance().getEnabledServers();
            Msg.info(this, String.format("Starting initialization of %d enabled MCP servers", enabledServers.size()));

            List<CompletableFuture<Void>> connectionFutures = new ArrayList<>();

            for (MCPServerConfig config : enabledServers) {
                Msg.info(this, "Starting connection to server: " + config.getName());
                CompletableFuture<Void> connectionFuture = connectToServer(config);
                connectionFutures.add(connectionFuture);
            }

            try {
                // Wait for all connections to complete
                CompletableFuture.allOf(connectionFutures.toArray(new CompletableFuture[0])).get();

                initialized = true;
                Msg.info(this, String.format("Initialized %d MCP servers", clients.size()));

                // Notify on EDT for UI updates
                javax.swing.SwingUtilities.invokeLater(() -> notifyToolsUpdated());

            } catch (Exception e) {
                Msg.error(this, "Failed to initialize MCP servers: " + e.getMessage());
                throw new RuntimeException("MCP server initialization failed", e);
            }
        });
    }
    
    /**
     * Connect to a specific server
     * This method runs all network operations on background threads
     */
    public CompletableFuture<Void> connectToServer(MCPServerConfig config) {
        if (!config.isEnabled()) {
            return CompletableFuture.completedFuture(null);
        }
        
        return CompletableFuture.runAsync(() -> {
            MCPClientAdapter client = new MCPClientAdapter(config);
            client.setHandler(new ClientHandler(config.getName()));
            
            try {
                // Connect and wait for completion off the EDT
                client.connect().get();
                clients.put(config.getName(), client);
                Msg.info(this, "Connected to MCP server: " + config.getName());
            } catch (Exception e) {
                Msg.error(this, "Failed to connect to " + config.getName() + ": " + e.getMessage());
                throw new RuntimeException("Failed to connect to " + config.getName(), e);
            }
        });
    }
    
    /**
     * Disconnect from a specific server
     */
    public CompletableFuture<Void> disconnectFromServer(String serverName) {
        return CompletableFuture.runAsync(() -> {
            MCPClientAdapter client = clients.remove(serverName);
            if (client != null) {
                try {
                    // Disconnect and wait for completion
                    client.disconnect().get();
                    
                    // Remove tools from this server
                    allTools.entrySet().removeIf(entry -> 
                        entry.getValue().getServerName().equals(serverName));
                    
                    // Notify on EDT for UI updates
                    javax.swing.SwingUtilities.invokeLater(() -> notifyToolsUpdated());
                    
                } catch (Exception e) {
                    Msg.error(this, "Error disconnecting from " + serverName + ": " + e.getMessage());
                }
            }
        });
    }
    
    /**
     * Disconnect from all servers
     */
    public CompletableFuture<Void> disconnectAll() {
        return CompletableFuture.runAsync(() -> {
            List<CompletableFuture<Void>> disconnectFutures = new ArrayList<>();
            
            for (String serverName : new ArrayList<>(clients.keySet())) {
                disconnectFutures.add(disconnectFromServer(serverName));
            }
            
            try {
                // Wait for all disconnections to complete
                CompletableFuture.allOf(disconnectFutures.toArray(new CompletableFuture[0])).get();
                
                clients.clear();
                allTools.clear();
                
                // Notify on EDT for UI updates
                javax.swing.SwingUtilities.invokeLater(() -> notifyToolsUpdated());
                
                Msg.info(this, "Disconnected from all MCP servers");
                
            } catch (Exception e) {
                Msg.error(this, "Error disconnecting from servers: " + e.getMessage());
            }
        });
    }
    
    // ==================== Parallel Tool Execution ====================

    /**
     * Execute multiple tools in parallel for better performance.
     * Implements BinAssist parity with max 3 concurrent tool executions.
     *
     * @param toolCalls List of tool calls to execute
     * @param maxConcurrent Maximum number of concurrent executions (default: 3)
     * @return CompletableFuture with list of results in original order
     */
    public CompletableFuture<List<MCPToolResult>> executeToolsParallel(
        List<ToolCallRequest> toolCalls,
        int maxConcurrent
    ) {
        if (toolCalls == null || toolCalls.isEmpty()) {
            return CompletableFuture.completedFuture(new ArrayList<>());
        }

        // Track original order
        Map<String, Integer> originalOrder = new HashMap<>();
        for (int i = 0; i < toolCalls.size(); i++) {
            originalOrder.put(toolCalls.get(i).getCallId(), i);
        }

        ExecutorService executor = Executors.newFixedThreadPool(Math.min(maxConcurrent, toolCalls.size()));
        List<CompletableFuture<ToolCallResult>> futures = new ArrayList<>();

        try {
            // Submit all tool calls
            for (ToolCallRequest toolCall : toolCalls) {
                CompletableFuture<ToolCallResult> future = CompletableFuture.supplyAsync(() -> {
                    try {
                        // Execute tool and get MCPToolResult
                        MCPToolResult result = executeToolMCP(toolCall.getToolName(), toolCall.getArguments())
                            .orTimeout(30, TimeUnit.SECONDS)
                            .get();

                        return new ToolCallResult(toolCall.getCallId(), result);

                    } catch (java.util.concurrent.ExecutionException e) {
                        // Check if it's a timeout
                        if (e.getCause() instanceof java.util.concurrent.TimeoutException) {
                            Msg.warn(this, String.format("Tool '%s' timed out after 30 seconds", toolCall.getToolName()));
                            return new ToolCallResult(
                                toolCall.getCallId(),
                                MCPToolResult.error("Tool execution timeout after 30 seconds")
                            );
                        } else {
                            Msg.error(this, String.format("Tool '%s' failed: %s", toolCall.getToolName(), e.getCause().getMessage()));
                            return new ToolCallResult(
                                toolCall.getCallId(),
                                MCPToolResult.error(e.getCause().getMessage())
                            );
                        }
                    } catch (Exception e) {
                        Msg.error(this, String.format("Tool '%s' failed: %s", toolCall.getToolName(), e.getMessage()));
                        return new ToolCallResult(
                            toolCall.getCallId(),
                            MCPToolResult.error(e.getMessage())
                        );
                    }
                }, executor);

                futures.add(future);
            }

            // Wait for all to complete
            return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenApply(v -> {
                    // Collect results
                    List<ToolCallResult> results = futures.stream()
                        .map(CompletableFuture::join)
                        .collect(Collectors.toList());

                    // Reorder to match original sequence
                    results.sort((a, b) -> {
                        int orderA = originalOrder.getOrDefault(a.getCallId(), Integer.MAX_VALUE);
                        int orderB = originalOrder.getOrDefault(b.getCallId(), Integer.MAX_VALUE);
                        return Integer.compare(orderA, orderB);
                    });

                    Msg.debug(this, String.format("Parallel execution complete: %d tools", results.size()));

                    // Extract MCPToolResults in correct order
                    return results.stream()
                        .map(ToolCallResult::getResult)
                        .collect(Collectors.toList());
                })
                .whenComplete((results, throwable) -> {
                    executor.shutdown();
                });

        } catch (Exception e) {
            executor.shutdown();
            return CompletableFuture.failedFuture(e);
        }
    }

    /**
     * Execute multiple tools in parallel with default concurrency (3).
     */
    public CompletableFuture<List<MCPToolResult>> executeToolsParallel(List<ToolCallRequest> toolCalls) {
        return executeToolsParallel(toolCalls, 3);
    }

    // ========== Helper Classes for Parallel Execution ==========

    /**
     * Represents a tool call request with tracking ID.
     */
    public static class ToolCallRequest {
        private final String callId;
        private final String toolName;
        private final JsonObject arguments;

        public ToolCallRequest(String callId, String toolName, JsonObject arguments) {
            this.callId = callId;
            this.toolName = toolName;
            this.arguments = arguments;
        }

        public String getCallId() {
            return callId;
        }

        public String getToolName() {
            return toolName;
        }

        public JsonObject getArguments() {
            return arguments;
        }
    }

    /**
     * Represents a completed tool call with result.
     */
    private static class ToolCallResult {
        private final String callId;
        private final MCPToolResult result;

        public ToolCallResult(String callId, MCPToolResult result) {
            this.callId = callId;
            this.result = result;
        }

        public String getCallId() {
            return callId;
        }

        public MCPToolResult getResult() {
            return result;
        }
    }

    // ==================== Tool Access Methods ====================

    /**
     * Get all available MCP tools from all connected servers.
     * NOTE: Native tools are now accessed via NativeToolManager.
     */
    public List<MCPTool> getAllMCPTools() {
        return new ArrayList<>(allTools.values());
    }

    /**
     * Get MCP tools as function schemas for LLM function calling.
     * Tool names in the schema are prefixed with server name.
     * NOTE: Native tools should be obtained from NativeToolManager via ToolRegistry.
     */
    public List<Map<String, Object>> getToolsAsFunction() {
        return allTools.entrySet().stream()
            .map(entry -> {
                // Create schema with prefixed name
                Map<String, Object> schema = entry.getValue().toFunctionSchema();
                schema.put("name", entry.getKey()); // Override with prefixed name
                return schema;
            })
            .collect(Collectors.toList());
    }
    
    /**
     * Find tool by name
     */
    public MCPTool findTool(String toolName) {
        return allTools.get(toolName.toLowerCase());
    }
    
    /**
     * Check if the tool manager has been initialized
     */
    public boolean isInitialized() {
        return initialized;
    }
    
    /**
     * Check if any servers are connected
     */
    public boolean hasConnectedServers() {
        return clients.values().stream().anyMatch(MCPClientAdapter::isReady);
    }
    
    /**
     * Get status info for all servers
     */
    public String getStatusInfo() {
        if (clients.isEmpty()) {
            return "No MCP servers configured";
        }
        
        long connectedCount = clients.values().stream()
            .filter(MCPClientAdapter::isReady)
            .count();
        
        return String.format("%d/%d servers connected (%d tools)", 
                           connectedCount, clients.size(), allTools.size());
    }
    
    /**
     * Get connected servers info
     */
    public List<String> getConnectedServers() {
        return clients.entrySet().stream()
            .filter(entry -> entry.getValue().isReady())
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());
    }
    
    /**
     * Refresh connections to all servers
     */
    public CompletableFuture<Void> refreshConnections() {
        return CompletableFuture.runAsync(() -> {
            try {
                // Disconnect all servers first
                disconnectAll().get();
                
                // Then reinitialize
                initializeServers().get();
                
            } catch (Exception e) {
                Msg.error(this, "Error refreshing MCP connections: " + e.getMessage());
                throw new RuntimeException("Failed to refresh MCP connections", e);
            }
        });
    }
    
    /**
     * Notify handler of tools update
     */
    private void notifyToolsUpdated() {
        if (handler != null) {
            handler.onToolsUpdated(getAllMCPTools());
        }
    }
    
    /**
     * Client event handler
     */
    private class ClientHandler implements MCPClientAdapter.MCPClientHandler {
        private final String serverName;
        
        public ClientHandler(String serverName) {
            this.serverName = serverName;
        }
        
        @Override
        public void onConnected(MCPClientAdapter client) {
            if (handler != null) {
                handler.onServerConnected(serverName);
            }
        }
        
        @Override
        public void onDisconnected(MCPClientAdapter client) {
            // Remove tools from this server (keys are prefixed with serverName.toLowerCase()_)
            String prefix = serverName.toLowerCase() + "_";
            allTools.entrySet().removeIf(entry -> entry.getKey().startsWith(prefix));

            // Notify on EDT for UI updates
            javax.swing.SwingUtilities.invokeLater(() -> {
                notifyToolsUpdated();

                if (handler != null) {
                    handler.onServerDisconnected(serverName);
                }
            });
        }
        
        @Override
        public void onToolsDiscovered(MCPClientAdapter client, List<MCPTool> tools) {
            // Add tools from this server with server name prefix
            String prefix = serverName.toLowerCase() + "_";
            for (MCPTool tool : tools) {
                // Create prefixed name for storage and lookup
                String prefixedName = prefix + tool.getName().toLowerCase();
                // Store with prefixed name, but keep original tool reference
                allTools.put(prefixedName, tool);
                Msg.debug(MCPToolManager.this, "Registered MCP tool: " + prefixedName);
            }

            // Notify on EDT for UI updates
            javax.swing.SwingUtilities.invokeLater(() -> notifyToolsUpdated());
        }

        @Override
        public void onResourcesDiscovered(MCPClientAdapter client, java.util.List<ghidrassist.mcp2.resources.MCPResource> resources) {
            // Resources are discovered but not actively managed yet
            // Future enhancement: could add resource management similar to tools
            Msg.debug(MCPToolManager.this, "Discovered " + resources.size() + " resources from " + serverName);
        }

        @Override
        public void onPromptsDiscovered(MCPClientAdapter client, java.util.List<ghidrassist.mcp2.prompts.MCPPrompt> prompts) {
            // Prompts are discovered but not actively managed yet
            // Future enhancement: could add prompt management similar to tools
            Msg.debug(MCPToolManager.this, "Discovered " + prompts.size() + " prompts from " + serverName);
        }

        @Override
        public void onError(MCPClientAdapter client, Throwable error) {
            if (handler != null) {
                handler.onServerError(serverName, error);
            }
        }
    }
}
```

`src/main/java/ghidrassist/mcp2/tools/MCPToolResult.java`:

```java
package ghidrassist.mcp2.tools;

/**
 * Result of an MCP tool execution.
 * Similar to the original MCPToolResult but for MCP 2.0.
 */
public class MCPToolResult {
    
    private final boolean success;
    private final String content;
    private final String error;
    
    public MCPToolResult(boolean success, String content, String error) {
        this.success = success;
        this.content = content;
        this.error = error;
    }
    
    /**
     * Create successful result
     */
    public static MCPToolResult success(String content) {
        return new MCPToolResult(true, content, null);
    }
    
    /**
     * Create error result
     */
    public static MCPToolResult error(String error) {
        return new MCPToolResult(false, null, error);
    }
    
    public boolean isSuccess() {
        return success;
    }
    
    public String getContent() {
        return content;
    }
    
    public String getError() {
        return error;
    }
    
    /**
     * Get result as string for display
     */
    public String getResultText() {
        if (success) {
            return content != null ? content : "";
        } else {
            return "Error: " + (error != null ? error : "Unknown error");
        }
    }
    
    @Override
    public String toString() {
        return String.format("MCPToolResult{success=%s, content='%s', error='%s'}", 
            success, content, error);
    }
}
```

`src/main/java/ghidrassist/resources/GhidrAssistIcons.java`:

```java
package ghidrassist.resources;

import javax.swing.ImageIcon;
import resources.ResourceManager;

public class GhidrAssistIcons {
    public static final ImageIcon ROBOT_ICON = ResourceManager.loadImage("images/robot32.png");
}

```

`src/main/java/ghidrassist/services/ActionAnalysisService.java`:

```java
package ghidrassist.services;

import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.util.task.TaskMonitor;
import ghidrassist.GhidrAssistPlugin;
import ghidrassist.LlmApi;
import ghidrassist.apiprovider.APIProviderConfig;
import ghidrassist.core.ActionExecutor;
import ghidrassist.core.ActionParser;
import ghidrassist.core.CodeUtils;
import ghidrassist.core.ActionConstants;

import javax.swing.table.DefaultTableModel;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Service for handling automated function analysis with actions.
 * Responsible for analyzing functions with AI tools and managing action execution.
 */
public class ActionAnalysisService {
    
    private final GhidrAssistPlugin plugin;
    private final AtomicInteger activeRequests;
    
    public ActionAnalysisService(GhidrAssistPlugin plugin) {
        this.plugin = plugin;
        this.activeRequests = new AtomicInteger(0);
    }
    
    /**
     * Create an action analysis request for a function
     */
    public ActionAnalysisRequest createAnalysisRequest(Function function, List<String> selectedActions) throws Exception {
        if (function == null) {
            throw new IllegalArgumentException("No function at current location.");
        }
        
        if (selectedActions.isEmpty()) {
            throw new IllegalArgumentException("No actions selected for analysis.");
        }
        
        String code = CodeUtils.getFunctionCode(function, TaskMonitor.DUMMY);
        if (code == null) {
            throw new Exception("Failed to get code from the current function.");
        }
        
        return new ActionAnalysisRequest(function, code, selectedActions);
    }
    
    /**
     * Execute action analysis requests
     */
    public void executeActionAnalysis(ActionAnalysisRequest request, ActionAnalysisHandler handler) throws Exception {
        APIProviderConfig config = GhidrAssistPlugin.getCurrentProviderConfig();
        if (config == null) {
            throw new Exception("No API provider configured.");
        }

        LlmApi llmApi = new LlmApi(config, plugin);

        // Apply saved reasoning config
        ghidra.program.model.listing.Program currentProgram = plugin.getCurrentProgram();
        if (currentProgram != null) {
            try {
                ghidrassist.AnalysisDB analysisDB = new ghidrassist.AnalysisDB();
                String programHash = currentProgram.getExecutableSHA256();
                String savedEffort = analysisDB.getReasoningEffort(programHash);
                if (savedEffort != null && !savedEffort.equalsIgnoreCase("none")) {
                    ghidrassist.apiprovider.ReasoningConfig reasoningConfig =
                            ghidrassist.apiprovider.ReasoningConfig.fromString(savedEffort);
                    llmApi.setReasoningConfig(reasoningConfig);
                }
            } catch (Exception e) {
                // Continue without reasoning config if loading fails
            }
        }

        // Reset and set the active request counter
        activeRequests.set(request.getSelectedActions().size());
        
        for (String action : request.getSelectedActions()) {
            if (!handler.shouldContinue()) {
                break;
            }
            
            String actionPrompt = ActionConstants.ACTION_PROMPTS.get(action);
            if (actionPrompt != null) {
                String prompt = actionPrompt.replace("{code}", request.getCode());
                List<Map<String, Object>> functions = new ArrayList<>();
                functions.add(getActionFunction(action));
                
                llmApi.sendRequestAsyncWithFunctions(prompt, functions, 
                    createActionResponseHandler(action, handler));
            }
        }
    }
    
    /**
     * Apply selected actions from the analysis results
     */
    public void applyActions(DefaultTableModel model, Program program, Address address) {
        for (int row = 0; row < model.getRowCount(); row++) {
            Boolean isSelected = (Boolean) model.getValueAt(row, 0);
            if (isSelected) {
                applyAction(model, row, program, address);
            }
        }
    }
    
    /**
     * Apply a single action
     */
    private void applyAction(DefaultTableModel model, int row, Program program, Address address) {
        String action = model.getValueAt(row, 1).toString().replace(" ", "_");
        String argumentsJson = model.getValueAt(row, 4).toString();
        
        try {
            ActionExecutor.executeAction(action, argumentsJson, program, address);
            model.setValueAt("Applied", row, 3);
            model.setValueAt(Boolean.FALSE, row, 0);
        } catch (Exception e) {
            model.setValueAt("Failed: " + e.getMessage(), row, 3);
        }
    }
    
    /**
     * Get the function template for a specific action
     */
    private Map<String, Object> getActionFunction(String actionName) {
        for (Map<String, Object> fnTemplate : ActionConstants.FN_TEMPLATES) {
            @SuppressWarnings("unchecked")
            Map<String, Object> functionMap = (Map<String, Object>) fnTemplate.get("function");
            if (functionMap.get("name").equals(actionName)) {
                return fnTemplate;
            }
        }
        return null;
    }
    
    /**
     * Create response handler for action analysis
     */
    private LlmApi.LlmResponseHandler createActionResponseHandler(String action, ActionAnalysisHandler handler) {
        return new LlmApi.LlmResponseHandler() {
            @Override
            public void onStart() {
                handler.onActionStart(action);
            }
            
            @Override
            public void onUpdate(String partialResponse) {
                // Function calls don't have partial updates
            }
            
            @Override
            public void onComplete(String fullResponse) {
                handler.onActionComplete(action, fullResponse);
                
                int remaining = activeRequests.decrementAndGet();
                if (remaining <= 0) {
                    activeRequests.set(0);
                    handler.onAllActionsComplete();
                }
            }
            
            @Override
            public void onError(Throwable error) {
                handler.onActionError(action, error);
                
                int remaining = activeRequests.decrementAndGet();
                if (remaining <= 0) {
                    activeRequests.set(0);
                    handler.onAllActionsComplete();
                }
            }
            
            @Override
            public boolean shouldContinue() {
                return handler.shouldContinue();
            }
        };
    }
    
    /**
     * Parse and display action results
     */
    public void parseAndDisplayActions(String response, DefaultTableModel tableModel) throws Exception {
        ActionParser.parseAndDisplay(response, tableModel);
    }
    
    /**
     * Check if analysis is currently running
     */
    public boolean isAnalysisRunning() {
        return activeRequests.get() > 0;
    }
    
    /**
     * Cancel all running analysis
     */
    public void cancelAnalysis() {
        activeRequests.set(0);
    }
    
    /**
     * Request object for action analysis operations
     */
    public static class ActionAnalysisRequest {
        private final Function function;
        private final String code;
        private final List<String> selectedActions;
        
        public ActionAnalysisRequest(Function function, String code, List<String> selectedActions) {
            this.function = function;
            this.code = code;
            this.selectedActions = new ArrayList<>(selectedActions);
        }
        
        public Function getFunction() { return function; }
        public String getCode() { return code; }
        public List<String> getSelectedActions() { return selectedActions; }
    }
    
    /**
     * Handler interface for action analysis callbacks
     */
    public interface ActionAnalysisHandler {
        void onActionStart(String action);
        void onActionComplete(String action, String response);
        void onActionError(String action, Throwable error);
        void onAllActionsComplete();
        boolean shouldContinue();
    }
}
```

`src/main/java/ghidrassist/services/AnalysisDataService.java`:

```java
package ghidrassist.services;

import ghidrassist.AnalysisDB;
import ghidrassist.GhidrAssistPlugin;
import ghidrassist.LlmApi;
import ghidrassist.apiprovider.APIProviderConfig;

/**
 * Service for managing analysis context and program-specific data.
 * Responsible for context storage, retrieval, and management operations.
 */
public class AnalysisDataService {
    
    private final GhidrAssistPlugin plugin;
    private final AnalysisDB analysisDB;
    
    public AnalysisDataService(GhidrAssistPlugin plugin) {
        this.plugin = plugin;
        this.analysisDB = new AnalysisDB();
    }
    
    /**
     * Save context for the current program
     */
    public void saveContext(String context) {
        if (plugin.getCurrentProgram() == null) {
            throw new IllegalStateException("No active program to save context for.");
        }
        
        String programHash = plugin.getCurrentProgram().getExecutableSHA256();
        analysisDB.upsertContext(programHash, context);
    }
    
    /**
     * Get context for the current program.
     * If no context is stored (or stored as empty), populates with the default and saves it.
     */
    public String getContext() {
        if (plugin.getCurrentProgram() == null) {
            return getDefaultContext();
        }

        String programHash = plugin.getCurrentProgram().getExecutableSHA256();
        String context = analysisDB.getContext(programHash);

        if (context == null || context.trim().isEmpty()) {
            String defaultContext = getDefaultContext();
            analysisDB.upsertContext(programHash, defaultContext);
            return defaultContext;
        }

        return context;
    }
    
    /**
     * Revert context to default for the current program.
     * Saves the default to the database so it persists.
     */
    public String revertToDefaultContext() {
        String defaultContext = getDefaultContext();

        if (plugin.getCurrentProgram() != null) {
            String programHash = plugin.getCurrentProgram().getExecutableSHA256();
            analysisDB.upsertContext(programHash, defaultContext);
        }

        return defaultContext;
    }
    
    /**
     * Check if current program has custom context
     */
    public boolean hasCustomContext() {
        if (plugin.getCurrentProgram() == null) {
            return false;
        }
        
        String programHash = plugin.getCurrentProgram().getExecutableSHA256();
        String context = analysisDB.getContext(programHash);
        return context != null && !context.equals(getDefaultContext());
    }
    
    /**
     * Get default system context
     */
    private String getDefaultContext() {
        APIProviderConfig config = GhidrAssistPlugin.getCurrentProviderConfig();
        if (config == null) {
            return "You are a professional software reverse engineer."; // Fallback
        }
        
        LlmApi llmApi = new LlmApi(config, plugin);
        return llmApi.getSystemPrompt();
    }
    
    /**
     * Save reasoning effort for the current program
     */
    public void saveReasoningEffort(String reasoningEffort) {
        if (plugin.getCurrentProgram() == null) {
            throw new IllegalStateException("No active program to save reasoning effort for.");
        }

        String programHash = plugin.getCurrentProgram().getExecutableSHA256();
        analysisDB.upsertReasoningEffort(programHash, reasoningEffort);
    }

    /**
     * Get reasoning effort for the current program
     */
    public String getReasoningEffort() {
        if (plugin.getCurrentProgram() == null) {
            return "none"; // Default when no program loaded
        }

        String programHash = plugin.getCurrentProgram().getExecutableSHA256();
        String effort = analysisDB.getReasoningEffort(programHash);
        return effort != null ? effort : "none";
    }

    /**
     * Save max tool calls per iteration for the current program
     */
    public void saveMaxToolCalls(int maxToolCalls) {
        if (plugin.getCurrentProgram() == null) {
            throw new IllegalStateException("No active program to save max tool calls for.");
        }

        String programHash = plugin.getCurrentProgram().getExecutableSHA256();
        analysisDB.upsertMaxToolCalls(programHash, maxToolCalls);
    }

    /**
     * Get max tool calls per iteration for the current program
     */
    public int getMaxToolCalls() {
        if (plugin.getCurrentProgram() == null) {
            return 10; // Default when no program loaded
        }

        String programHash = plugin.getCurrentProgram().getExecutableSHA256();
        return analysisDB.getMaxToolCalls(programHash);
    }

    /**
     * Get context statistics
     */
    public ContextStats getContextStats() {
        String currentContext = getContext();
        boolean isCustom = hasCustomContext();
        String programName = plugin.getCurrentProgram() != null ?
            plugin.getCurrentProgram().getName() : "No Program";

        return new ContextStats(programName, currentContext.length(), isCustom);
    }

    /**
     * Close database resources
     */
    public void close() {
        if (analysisDB != null) {
            analysisDB.close();
        }
    }
    
    /**
     * Statistics about the current context
     */
    public static class ContextStats {
        private final String programName;
        private final int contextLength;
        private final boolean isCustom;
        
        public ContextStats(String programName, int contextLength, boolean isCustom) {
            this.programName = programName;
            this.contextLength = contextLength;
            this.isCustom = isCustom;
        }
        
        public String getProgramName() { return programName; }
        public int getContextLength() { return contextLength; }
        public boolean isCustom() { return isCustom; }
        
        @Override
        public String toString() {
            return String.format("Program: %s, Context: %d chars (%s)", 
                programName, contextLength, isCustom ? "Custom" : "Default");
        }
    }
}
```

`src/main/java/ghidrassist/services/CodeAnalysisService.java`:

```java
package ghidrassist.services;

import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import ghidra.util.task.TaskMonitor;
import ghidrassist.AnalysisDB;
import ghidrassist.GhidrAssistPlugin;
import ghidrassist.LlmApi;
import ghidrassist.apiprovider.APIProviderConfig;
import ghidrassist.apiprovider.ReasoningConfig;
import ghidrassist.core.CodeUtils;

/**
 * Service for handling code analysis operations.
 * Responsible for explaining functions and lines of code.
 */
public class CodeAnalysisService {

    private final GhidrAssistPlugin plugin;
    private final AnalysisDB analysisDB;
    private final AnalysisDataService analysisDataService;

    public CodeAnalysisService(GhidrAssistPlugin plugin) {
        this.plugin = plugin;
        this.analysisDB = new AnalysisDB();
        this.analysisDataService = new AnalysisDataService(plugin);
    }
    
    /**
     * Analyze and explain a function
     */
    public AnalysisRequest createFunctionAnalysisRequest(Function function) throws Exception {
        if (function == null) {
            throw new IllegalArgumentException("No function at current location.");
        }
        
        String functionCode = null;
        String codeType = null;
        
        GhidrAssistPlugin.CodeViewType viewType = plugin.checkLastActiveCodeView();
        if (viewType == GhidrAssistPlugin.CodeViewType.IS_DECOMPILER) {
            functionCode = CodeUtils.getFunctionCode(function, TaskMonitor.DUMMY);
            codeType = "pseudo-C";
        } else if (viewType == GhidrAssistPlugin.CodeViewType.IS_DISASSEMBLER) {
            functionCode = CodeUtils.getFunctionDisassembly(function);
            codeType = "assembly";
        } else {
            throw new Exception("Unknown code view type.");
        }
        
        String prompt = "Explain the following " + codeType + " code:\n```\n" + functionCode + "\n```";
        return new AnalysisRequest(AnalysisRequest.Type.FUNCTION, prompt, function);
    }
    
    /**
     * Analyze and explain a line of code
     */
    public AnalysisRequest createLineAnalysisRequest(Address address) throws Exception {
        if (address == null) {
            throw new IllegalArgumentException("No address at current location.");
        }
        
        String codeLine = null;
        String codeType = null;
        
        GhidrAssistPlugin.CodeViewType viewType = plugin.checkLastActiveCodeView();
        if (viewType == GhidrAssistPlugin.CodeViewType.IS_DECOMPILER) {
            codeLine = CodeUtils.getLineCode(address, TaskMonitor.DUMMY, plugin.getCurrentProgram());
            codeType = "pseudo-C";
        } else if (viewType == GhidrAssistPlugin.CodeViewType.IS_DISASSEMBLER) {
            codeLine = CodeUtils.getLineDisassembly(address, plugin.getCurrentProgram());
            codeType = "assembly";
        } else {
            throw new Exception("Unknown code view type.");
        }
        
        String prompt = "Explain the following " + codeType + " line:\n```\n" + codeLine + "\n```";
        return new AnalysisRequest(AnalysisRequest.Type.LINE, prompt, address);
    }
    
    /**
     * Execute an analysis request
     */
    public void executeAnalysis(AnalysisRequest request, LlmApi.LlmResponseHandler handler) throws Exception {
        APIProviderConfig config = GhidrAssistPlugin.getCurrentProviderConfig();
        if (config == null) {
            throw new Exception("No API provider configured.");
        }

        LlmApi llmApi = new LlmApi(config, plugin);

        // Load and apply reasoning configuration from database
        try {
            String savedEffort = analysisDataService.getReasoningEffort();
            Msg.info(this, "DEBUG [CodeAnalysisService]: Loaded reasoning effort from DB: " + savedEffort);
            if (savedEffort != null && !savedEffort.equalsIgnoreCase("none")) {
                ReasoningConfig reasoningConfig = ReasoningConfig.fromString(savedEffort);
                Msg.info(this, "DEBUG [CodeAnalysisService]: Applying reasoning config: " +
                    reasoningConfig.getEffort() + ", enabled=" + reasoningConfig.isEnabled());
                llmApi.setReasoningConfig(reasoningConfig);
            } else {
                Msg.info(this, "DEBUG [CodeAnalysisService]: No reasoning config to apply (savedEffort=" + savedEffort + ")");
            }
        } catch (Exception e) {
            Msg.warn(this, "DEBUG [CodeAnalysisService]: Failed to load reasoning config: " + e.getMessage());
        }

        llmApi.sendRequestAsync(request.getPrompt(), handler);
    }
    
    /**
     * Store analysis result in database
     */
    public void storeAnalysisResult(Function function, String prompt, String response) {
        if (function != null && plugin.getCurrentProgram() != null) {
            analysisDB.upsertAnalysis(
                plugin.getCurrentProgram().getExecutableSHA256(),
                function.getEntryPoint(),
                prompt,
                response
            );
        }
    }
    
    /**
     * Get existing analysis for a function
     */
    public AnalysisDB.Analysis getExistingAnalysis(Function function) {
        if (function == null || plugin.getCurrentProgram() == null) {
            return null;
        }
        
        return analysisDB.getAnalysis(
            plugin.getCurrentProgram().getExecutableSHA256(),
            function.getEntryPoint()
        );
    }
    
    /**
     * Update existing analysis
     */
    public void updateAnalysis(Function function, String updatedContent) {
        if (function == null || plugin.getCurrentProgram() == null) {
            throw new IllegalArgumentException("No active program or function");
        }
        
        String programHash = plugin.getCurrentProgram().getExecutableSHA256();
        Address functionAddress = function.getEntryPoint();
        
        // Get existing analysis to preserve the query
        AnalysisDB.Analysis existingAnalysis = analysisDB.getAnalysis(programHash, functionAddress);
        
        if (existingAnalysis == null) {
            // Create new entry with generic query
            analysisDB.upsertAnalysis(programHash, functionAddress, "Edited explanation", updatedContent);
        } else {
            // Update existing entry, preserving original query
            analysisDB.upsertAnalysis(programHash, functionAddress, existingAnalysis.getQuery(), updatedContent);
        }
    }
    
    /**
     * Clear analysis data for a function
     */
    public boolean clearAnalysis(Function function) {
        if (function == null || plugin.getCurrentProgram() == null) {
            return false;
        }
        
        String programHash = plugin.getCurrentProgram().getExecutableSHA256();
        Address functionAddress = function.getEntryPoint();
        
        return analysisDB.deleteAnalysis(programHash, functionAddress);
    }
    
    /**
     * Close database resources
     */
    public void close() {
        if (analysisDB != null) {
            analysisDB.close();
        }
    }
    
    /**
     * Request object for analysis operations
     */
    public static class AnalysisRequest {
        public enum Type {
            FUNCTION, LINE
        }
        
        private final Type type;
        private final String prompt;
        private final Object context; // Function or Address
        
        public AnalysisRequest(Type type, String prompt, Object context) {
            this.type = type;
            this.prompt = prompt;
            this.context = context;
        }
        
        public Type getType() { return type; }
        public String getPrompt() { return prompt; }
        public Object getContext() { return context; }
        
        public Function getFunction() {
            return context instanceof Function ? (Function) context : null;
        }
        
        public Address getAddress() {
            return context instanceof Address ? (Address) context : null;
        }
    }
}
```

`src/main/java/ghidrassist/services/FeedbackService.java`:

```java
package ghidrassist.services;

import ghidrassist.GhidrAssistPlugin;
import ghidrassist.LlmApi;
import ghidrassist.RLHFDatabase;
import ghidrassist.apiprovider.APIProviderConfig;

/**
 * Service for handling RLHF (Reinforcement Learning from Human Feedback) operations.
 * Responsible for storing user feedback and managing feedback data.
 */
public class FeedbackService {
    
    private final GhidrAssistPlugin plugin;
    private final RLHFDatabase rlhfDB;
    
    // Cache for last interaction
    private String lastPrompt;
    private String lastResponse;
    
    public FeedbackService(GhidrAssistPlugin plugin) {
        this.plugin = plugin;
        this.rlhfDB = new RLHFDatabase();
    }
    
    /**
     * Cache the last prompt and response for feedback
     */
    public void cacheLastInteraction(String prompt, String response) {
        this.lastPrompt = prompt;
        this.lastResponse = response;
    }
    
    /**
     * Store positive feedback (thumbs up)
     */
    public void storePositiveFeedback() {
        storeFeedback(1);
    }
    
    /**
     * Store negative feedback (thumbs down)
     */
    public void storeNegativeFeedback() {
        storeFeedback(0);
    }
    
    /**
     * Store feedback with specified rating
     */
    public void storeFeedback(int feedback) {
        if (lastPrompt == null || lastResponse == null) {
            throw new IllegalStateException("No recent interaction to provide feedback for.");
        }
        
        APIProviderConfig config = GhidrAssistPlugin.getCurrentProviderConfig();
        if (config == null) {
            throw new IllegalStateException("No API provider configured.");
        }
        
        LlmApi llmApi = new LlmApi(config, plugin);
        String modelName = config.getModel();
        String systemContext = llmApi.getSystemPrompt();
        
        rlhfDB.storeFeedback(modelName, lastPrompt, systemContext, lastResponse, feedback);
    }
    
    /**
     * Check if there's a recent interaction available for feedback
     */
    public boolean hasPendingFeedback() {
        return lastPrompt != null && lastResponse != null;
    }
    
    /**
     * Clear cached interaction (e.g., after feedback is provided)
     */
    public void clearCachedInteraction() {
        lastPrompt = null;
        lastResponse = null;
    }
    
    /**
     * Get feedback statistics
     */
    public FeedbackStats getFeedbackStats() {
        // Note: This would require extending RLHFDatabase with stats methods
        // For now, return basic info
        return new FeedbackStats(hasPendingFeedback());
    }
    
    /**
     * Get the last cached prompt (for debugging/info)
     */
    public String getLastPrompt() {
        return lastPrompt;
    }
    
    /**
     * Get the last cached response (for debugging/info)
     */
    public String getLastResponse() {
        return lastResponse;
    }
    
    /**
     * Close database resources
     */
    public void close() {
        if (rlhfDB != null) {
            rlhfDB.close();
        }
    }
    
    /**
     * Statistics about feedback state
     */
    public static class FeedbackStats {
        private final boolean hasPendingFeedback;
        
        public FeedbackStats(boolean hasPendingFeedback) {
            this.hasPendingFeedback = hasPendingFeedback;
        }
        
        public boolean hasPendingFeedback() { return hasPendingFeedback; }
        
        @Override
        public String toString() {
            return String.format("Feedback: %s", 
                hasPendingFeedback ? "Available" : "No pending feedback");
        }
    }
}
```

`src/main/java/ghidrassist/services/QueryService.java`:

```java
package ghidrassist.services;

import ghidrassist.AnalysisDB;
import ghidrassist.GhidrAssistPlugin;
import ghidrassist.LlmApi;
import ghidrassist.apiprovider.APIProviderConfig;
import ghidrassist.apiprovider.ChatMessage;
import ghidrassist.chat.PersistedChatMessage;
import ghidrassist.chat.message.MessageRepository;
import ghidrassist.chat.message.MessageStore;
import ghidrassist.chat.message.ThreadSafeMessageStore;
import ghidrassist.chat.persistence.ChatHistoryDAO;
import ghidrassist.chat.persistence.SqliteTransactionManager;
import ghidrassist.chat.persistence.TransactionManager;
import ghidrassist.chat.session.ChatSession;
import ghidrassist.chat.session.ChatSessionManager;
import ghidrassist.chat.session.ChatSessionRepository;
import ghidrassist.chat.util.RoleNormalizer;
import ghidrassist.core.QueryProcessor;
import ghidrassist.mcp2.tools.MCPToolManager;
import ghidrassist.tools.native_.NativeToolManager;
import ghidrassist.tools.registry.ToolRegistry;
import ghidrassist.graphrag.GraphRAGService;

import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Service for handling custom queries and conversations.
 * Responsible for processing user queries, RAG integration, and conversation management.
 *
 * Refactored to use:
 * - MessageStore for thread-safe in-memory message storage (eliminates dual storage)
 * - ChatSessionManager for thread-safe session lifecycle
 * - ChatHistoryDAO for database operations
 * - RoleNormalizer for consistent role handling
 */
public class QueryService {

    private final GhidrAssistPlugin plugin;
    private final AnalysisDB analysisDB;  // Keep for ReAct and backward compatibility
    private final AnalysisDataService analysisDataService;
    private final ToolRegistry toolRegistry;

    // New architecture components
    private final MessageStore messageStore;
    private final ChatSessionManager sessionManager;
    private final MessageRepository messageRepository;
    private final ChatSessionRepository sessionRepository;

    public QueryService(GhidrAssistPlugin plugin) {
        this.plugin = plugin;
        this.analysisDB = new AnalysisDB();
        this.analysisDataService = new AnalysisDataService(plugin);

        // Initialize tool registry with native tools
        this.toolRegistry = new ToolRegistry();
        try {
            NativeToolManager nativeManager = new NativeToolManager(analysisDB);
            toolRegistry.registerProvider(nativeManager);
        } catch (Exception e) {
            ghidra.util.Msg.warn(this, "Failed to initialize native tools: " + e.getMessage());
        }

        // Initialize new architecture components
        TransactionManager transactionManager = new SqliteTransactionManager(analysisDB.getConnection());
        ChatHistoryDAO dao = new ChatHistoryDAO(transactionManager);

        this.messageStore = new ThreadSafeMessageStore();
        this.messageRepository = dao;
        this.sessionRepository = dao;
        this.sessionManager = new ChatSessionManager(sessionRepository, messageRepository, messageStore);
    }

    // ==================== Query Request Creation ====================

    /**
     * Process a user query with optional RAG context (backwards compatibility)
     */
    public QueryRequest createQueryRequest(String query, boolean useRAG) throws Exception {
        return createQueryRequest(query, useRAG, false);
    }

    /**
     * Process a user query with optional RAG context and MCP integration
     */
    public QueryRequest createQueryRequest(String query, boolean useRAG, boolean useMCP) throws Exception {
        String processedQuery = QueryProcessor.processMacrosInQuery(query, plugin);

        if (useRAG) {
            try {
                processedQuery = QueryProcessor.appendRAGContext(processedQuery);
            } catch (Exception e) {
                throw new Exception("Failed to perform RAG search: " + e.getMessage(), e);
            }
        }

        // Add user message to message store and database
        addUserMessage(processedQuery, messageStore.getCurrentProviderType(), null);

        return new QueryRequest(processedQuery, messageStore.getFormattedConversation(), useMCP);
    }

    // ==================== Query Execution ====================

    /**
     * Execute a query request
     */
    public void executeQuery(QueryRequest request, LlmApi.LlmResponseHandler handler) throws Exception {
        APIProviderConfig config = GhidrAssistPlugin.getCurrentProviderConfig();
        if (config == null) {
            throw new Exception("No API provider configured.");
        }

        LlmApi llmApi = new LlmApi(config, plugin);

        // Apply saved reasoning config to the LlmApi
        ghidra.program.model.listing.Program currentProgram = plugin.getCurrentProgram();
        if (currentProgram != null) {
            String programHash = currentProgram.getExecutableSHA256();
            String savedEffort = analysisDB.getReasoningEffort(programHash);
            if (savedEffort != null && !savedEffort.equalsIgnoreCase("none")) {
                ghidrassist.apiprovider.ReasoningConfig reasoningConfig =
                        ghidrassist.apiprovider.ReasoningConfig.fromString(savedEffort);
                llmApi.setReasoningConfig(reasoningConfig);
            }
        }

        // Initialize GraphRAGService with LLM provider for background semantic analysis
        initializeGraphRAGService(config);

        executeQuery(request, llmApi, handler);
    }

    /**
     * Initialize GraphRAGService with LLM provider and current program context.
     * This enables background semantic analysis when queries trigger on-demand indexing.
     */
    private void initializeGraphRAGService(APIProviderConfig config) {
        try {
            GraphRAGService graphRAG = GraphRAGService.getInstance(analysisDB);

            // Set LLM provider for background semantic analysis
            if (config != null) {
                ghidrassist.apiprovider.APIProvider provider = config.createProvider();

                // Apply saved reasoning config to the new provider
                ghidra.program.model.listing.Program currentProgram = plugin.getCurrentProgram();
                if (currentProgram != null) {
                    String programHash = currentProgram.getExecutableSHA256();
                    String savedEffort = analysisDB.getReasoningEffort(programHash);
                    if (savedEffort != null && !savedEffort.equalsIgnoreCase("none")) {
                        ghidrassist.apiprovider.ReasoningConfig reasoningConfig =
                                ghidrassist.apiprovider.ReasoningConfig.fromString(savedEffort);
                        provider.setReasoningConfig(reasoningConfig);
                    }
                }

                graphRAG.setLLMProvider(provider);
            }

            // Set current program context
            ghidra.program.model.listing.Program currentProgram = plugin.getCurrentProgram();
            if (currentProgram != null) {
                graphRAG.setCurrentProgram(currentProgram);
            }
        } catch (Exception e) {
            ghidra.util.Msg.warn(this, "Failed to initialize GraphRAGService: " + e.getMessage());
        }
    }

    /**
     * Execute a query request with provided LlmApi instance
     */
    public void executeQuery(QueryRequest request, LlmApi llmApi, LlmApi.LlmResponseHandler handler) throws Exception {
        if (request.shouldUseMCP()) {
            try {
                MCPToolManager toolManager = MCPToolManager.getInstance();

                if (!toolManager.isInitialized()) {
                    toolManager.initializeServers()
                        .thenRun(() -> {
                            try {
                                executeMCPQuery(request, llmApi, toolManager, handler);
                            } catch (Exception e) {
                                ghidra.util.Msg.warn(this, "MCP query execution failed: " + e.getMessage());
                                try {
                                    executeRegularQuery(request, llmApi, handler);
                                } catch (Exception e2) {
                                    ghidra.util.Msg.error(this, "Failed to execute regular query: " + e2.getMessage());
                                    handler.onError(e2);
                                }
                            }
                        })
                        .exceptionally(throwable -> {
                            ghidra.util.Msg.warn(this, "MCP initialization failed: " + throwable.getMessage());
                            try {
                                executeRegularQuery(request, llmApi, handler);
                            } catch (Exception e) {
                                handler.onError(e);
                            }
                            return null;
                        });
                    return;
                } else {
                    try {
                        executeMCPQuery(request, llmApi, toolManager, handler);
                        return;
                    } catch (Exception e) {
                        ghidra.util.Msg.warn(this, "MCP query failed, falling back: " + e.getMessage());
                    }
                }
            } catch (Exception e) {
                ghidra.util.Msg.warn(this, "MCP initialization failed: " + e.getMessage());
            }
        }

        // MCP is disabled, but native tools (semantics, etc.) should still be available
        executeNativeToolQuery(request, llmApi, handler);
    }

    /**
     * Execute a query with native tools only (no MCP tools).
     * Native tools include semantics analysis, knowledge graph queries, etc.
     */
    private void executeNativeToolQuery(QueryRequest request, LlmApi llmApi,
                                         LlmApi.LlmResponseHandler handler) throws Exception {
        // Set full context (program + address) for native tool providers
        ghidra.program.model.listing.Program currentProgram = plugin.getCurrentProgram();
        ghidra.program.model.address.Address currentAddress = plugin.getCurrentAddress();
        if (currentProgram != null) {
            toolRegistry.setFullContext(currentProgram, currentAddress);
        } else {
            // No active binary context: fall back to plain chat mode.
            // Native tools depend on program/address and can cause incomplete
            // tool-calling loops when no program is loaded.
            ghidra.util.Msg.info(this, "No program context - using regular query mode (native tools disabled)");
            executeRegularQuery(request, llmApi, handler);
            return;
        }

        // Get native tools only (MCP tools won't be registered since MCP is disabled)
        java.util.List<java.util.Map<String, Object>> nativeFunctions = toolRegistry.getToolsAsFunction();

        ghidra.util.Msg.info(this, "Native tool registry has " + nativeFunctions.size() + " tools available");

        if (!nativeFunctions.isEmpty()) {
            int maxToolRounds = analysisDataService.getMaxToolCalls();

            // Get existing history with thinking data preserved for multi-turn conversations
            List<ChatMessage> fullHistory = messageStore.getMessagesForApi();
            List<ChatMessage> existingHistory;

            if (fullHistory == null || fullHistory.size() <= 1) {
                existingHistory = new ArrayList<>();
            } else {
                existingHistory = new ArrayList<>(fullHistory.subList(0, fullHistory.size() - 1));
            }

            // Use history-aware method to preserve thinking data across turns
            llmApi.sendConversationalToolRequestWithHistory(
                existingHistory,
                request.getProcessedQuery(),
                nativeFunctions,
                handler,
                maxToolRounds,
                toolRegistry
            );
        } else {
            // No native tools available, fall back to regular query
            executeRegularQuery(request, llmApi, handler);
        }
    }

    private void executeMCPQuery(QueryRequest request, LlmApi llmApi, MCPToolManager toolManager,
                                  LlmApi.LlmResponseHandler handler) throws Exception {
        // Register MCP tool manager with the tool registry (if not already registered)
        // This ensures both native and MCP tools are available
        if (!toolRegistry.hasProvider(toolManager.getProviderName())) {
            toolRegistry.registerProvider(toolManager);
        }

        // Set full context (program + address) for all tool providers
        ghidra.program.model.listing.Program currentProgram = plugin.getCurrentProgram();
        ghidra.program.model.address.Address currentAddress = plugin.getCurrentAddress();
        if (currentProgram != null) {
            toolRegistry.setFullContext(currentProgram, currentAddress);
        }

        // Get ALL tools from registry (includes native tools + MCP tools)
        java.util.List<java.util.Map<String, Object>> allFunctions = toolRegistry.getToolsAsFunction();

        ghidra.util.Msg.info(this, "Tool registry has " + allFunctions.size() + " tools available");

        if (!allFunctions.isEmpty()) {
            int maxToolRounds = analysisDataService.getMaxToolCalls();

            // Get existing history with thinking data preserved for multi-turn conversations
            // The current user message is already in the store, so get all PREVIOUS messages
            List<ChatMessage> fullHistory = messageStore.getMessagesForApi();
            List<ChatMessage> existingHistory;

            if (fullHistory == null || fullHistory.size() <= 1) {
                // No previous history or only the current user message - start fresh
                existingHistory = new ArrayList<>();
            } else {
                // Get all messages except the last one (current user message)
                // This preserves thinking data from previous assistant responses
                existingHistory = new ArrayList<>(fullHistory.subList(0, fullHistory.size() - 1));
            }

            // Use history-aware method to preserve thinking data across turns
            llmApi.sendConversationalToolRequestWithHistory(
                existingHistory,
                request.getProcessedQuery(),
                allFunctions,
                handler,
                maxToolRounds,
                toolRegistry
            );
        } else {
            executeRegularQuery(request, llmApi, handler);
        }
    }

    private void executeRegularQuery(QueryRequest request, LlmApi llmApi,
                                      LlmApi.LlmResponseHandler handler) throws Exception {
        llmApi.sendRequestAsync(request.getFullConversation(), handler);
    }

    // ==================== Message Management ====================

    /**
     * Add user query to conversation (legacy method)
     */
    public void addUserQuery(String query) {
        addUserMessage(query, messageStore.getCurrentProviderType(), null);
    }

    /**
     * Add user message with provider info
     */
    public void addUserMessage(String query, String providerType, ChatMessage apiMessage) {
        messageStore.addUserMessage(query, providerType, apiMessage);

        // Ensure session exists and save to database
        String programHash = getProgramHash();
        if (programHash != null) {
            int sessionId = sessionManager.ensureSession(programHash);
            if (sessionId != ChatSessionManager.NO_SESSION) {
                PersistedChatMessage msg = getLastMessage();
                if (msg != null) {
                    messageRepository.saveMessage(programHash, sessionId, msg);
                }
            }
        }
    }

    /**
     * Add assistant response (legacy method)
     */
    public void addAssistantResponse(String response) {
        addAssistantMessage(response, messageStore.getCurrentProviderType(), null);
    }

    /**
     * Add assistant message with provider info
     */
    public void addAssistantMessage(String response, String providerType, ChatMessage apiMessage) {
        messageStore.addAssistantMessage(response, providerType, apiMessage);

        // Save to database
        String programHash = getProgramHash();
        int sessionId = sessionManager.getCurrentSessionId();
        if (programHash != null && sessionId != ChatSessionManager.NO_SESSION) {
            PersistedChatMessage msg = getLastMessage();
            if (msg != null) {
                messageRepository.saveMessage(programHash, sessionId, msg);
            }
        }
    }

    /**
     * Add tool call message
     */
    public void addToolCallMessage(String toolName, String args, String result) {
        messageStore.addToolCallMessage(toolName, args, result);

        // Save to database
        String programHash = getProgramHash();
        int sessionId = sessionManager.getCurrentSessionId();
        if (programHash != null && sessionId != ChatSessionManager.NO_SESSION) {
            PersistedChatMessage msg = getLastMessage();
            if (msg != null) {
                messageRepository.saveMessage(programHash, sessionId, msg);
            }
        }
    }

    /**
     * Add error message
     */
    public void addError(String errorMessage) {
        messageStore.addErrorMessage(errorMessage);

        // Save to database
        String programHash = getProgramHash();
        int sessionId = sessionManager.getCurrentSessionId();
        if (programHash != null && sessionId != ChatSessionManager.NO_SESSION) {
            PersistedChatMessage msg = getLastMessage();
            if (msg != null) {
                messageRepository.saveMessage(programHash, sessionId, msg);
            }
        }
    }

    // ==================== Conversation Access ====================

    /**
     * Get current conversation history
     */
    public String getConversationHistory() {
        return messageStore.getFormattedConversation();
    }

    /**
     * Clear conversation history
     */
    public void clearConversationHistory() {
        messageStore.clear();
    }

    /**
     * Get the list of persisted messages
     */
    public List<PersistedChatMessage> getMessages() {
        return messageStore.getMessages();
    }

    /**
     * Set the message list (used when loading or after editing)
     */
    public void setMessages(List<PersistedChatMessage> messages) {
        messageStore.setMessages(messages);
    }

    /**
     * Replace all messages in both memory and database.
     * Used for edit operations where the entire conversation is rebuilt.
     *
     * @param messages The new message list
     * @return true if successful
     */
    public boolean replaceAllMessages(List<PersistedChatMessage> messages) {
        String programHash = getProgramHash();
        int sessionId = sessionManager.getCurrentSessionId();

        if (programHash == null || sessionId == ChatSessionManager.NO_SESSION) {
            return false;
        }

        // Update in-memory state
        messageStore.setMessages(messages);

        // Persist to database atomically
        return messageRepository.replaceAllMessages(programHash, sessionId, messages);
    }

    /**
     * Get current provider type
     */
    public String getCurrentProviderType() {
        return messageStore.getCurrentProviderType();
    }

    /**
     * Set current provider type
     */
    public void setCurrentProviderType(String providerType) {
        messageStore.setCurrentProviderType(providerType);
    }

    // ==================== Session Management ====================

    /**
     * Create a new chat session
     */
    public int createNewChatSession() {
        String programHash = getProgramHash();
        if (programHash == null) {
            return -1;
        }
        return sessionManager.createNewSession(programHash);
    }

    /**
     * Get all chat sessions for current program
     */
    public java.util.List<AnalysisDB.ChatSession> getChatSessions() {
        String programHash = getProgramHash();
        if (programHash == null) {
            return new java.util.ArrayList<>();
        }

        // Convert new ChatSession to legacy format for backward compatibility
        List<ChatSession> sessions = sessionManager.getSessions(programHash);
        java.util.List<AnalysisDB.ChatSession> legacySessions = new java.util.ArrayList<>();
        for (ChatSession session : sessions) {
            legacySessions.add(new AnalysisDB.ChatSession(
                session.getId(),
                session.getDescription(),
                session.getLastUpdate()
            ));
        }
        return legacySessions;
    }

    /**
     * Switch to a specific chat session
     */
    public boolean switchToChatSession(int sessionId) {
        String programHash = getProgramHash();
        if (programHash == null) {
            return false;
        }

        // Check if this is a ReAct session (needs special handling)
        if (analysisDB.isReActSession(sessionId)) {
            return switchToReActSession(programHash, sessionId);
        }

        return sessionManager.switchToSession(programHash, sessionId);
    }

    private boolean switchToReActSession(String programHash, int sessionId) {
        java.util.List<ghidrassist.apiprovider.ChatMessage> messages =
            analysisDB.getReActMessages(programHash, sessionId);

        if (messages != null && !messages.isEmpty()) {
            messageStore.clear();

            // Format and set as single message for display
            String formattedConversation = formatReActConversation(messages, sessionId);
            PersistedChatMessage displayMsg = new PersistedChatMessage(
                null, "assistant", formattedConversation,
                new Timestamp(System.currentTimeMillis()), 0
            );
            List<PersistedChatMessage> displayList = new ArrayList<>();
            displayList.add(displayMsg);
            messageStore.setMessages(displayList);

            // Update session manager's current session
            // (ReAct sessions bypass normal session switching)
            return true;
        }
        return false;
    }

    /**
     * Delete current chat session
     */
    public boolean deleteCurrentSession() {
        return sessionManager.deleteCurrentSession();
    }

    /**
     * Delete a specific chat session by ID
     */
    public boolean deleteSession(int sessionId) {
        return sessionManager.deleteSession(sessionId);
    }

    /**
     * Update chat session description
     */
    public void updateChatDescription(int sessionId, String description) {
        sessionManager.updateSessionDescription(sessionId, description);
    }

    /**
     * Get current session ID
     */
    public int getCurrentSessionId() {
        return sessionManager.getCurrentSessionId();
    }

    /**
     * Ensure session exists
     */
    public void ensureSession() {
        String programHash = getProgramHash();
        if (programHash != null && !messageStore.isEmpty()) {
            sessionManager.ensureSession(programHash);
        }
    }

    // ==================== Migration Support ====================

    /**
     * Check if current session has been migrated to per-message storage
     */
    public boolean isMigrated() {
        int sessionId = sessionManager.getCurrentSessionId();
        if (sessionId == ChatSessionManager.NO_SESSION) {
            return false;
        }
        String programHash = getProgramHash();
        return programHash != null && messageRepository.hasMessages(programHash, sessionId);
    }

    /**
     * Migrate legacy conversation blob to per-message storage
     */
    public List<PersistedChatMessage> migrateFromLegacyBlob(String conversation) {
        List<PersistedChatMessage> messages = new ArrayList<>();
        if (conversation == null || conversation.isEmpty()) {
            return messages;
        }

        Pattern pattern = Pattern.compile(
            "\\*\\*(User|Assistant|Error|Tool Call)\\*\\*:\\s*\\n(.*?)(?=\\*\\*(User|Assistant|Error|Tool Call)\\*\\*:|$)",
            Pattern.DOTALL
        );

        Matcher matcher = pattern.matcher(conversation);
        int order = 0;
        while (matcher.find()) {
            String role = RoleNormalizer.normalize(matcher.group(1));
            String content = matcher.group(2).trim();

            PersistedChatMessage msg = new PersistedChatMessage(
                null, role, content,
                new Timestamp(System.currentTimeMillis()),
                order++
            );
            msg.setProviderType("migrated");
            msg.setMessageType("standard");
            msg.setNativeMessageData("{}");
            messages.add(msg);
        }

        return messages;
    }

    /**
     * Load messages from database for current session
     */
    public void loadMessagesFromDatabase() {
        int sessionId = sessionManager.getCurrentSessionId();
        if (sessionId == ChatSessionManager.NO_SESSION) {
            return;
        }
        String programHash = getProgramHash();
        if (programHash == null) {
            return;
        }

        List<PersistedChatMessage> dbMessages = messageRepository.loadMessages(programHash, sessionId);
        if (!dbMessages.isEmpty()) {
            messageStore.setMessages(dbMessages);
        } else {
            // Fall back to legacy blob and migrate
            String conversation = sessionRepository.getLegacyConversation(sessionId);
            if (conversation != null && !conversation.isEmpty()) {
                List<PersistedChatMessage> migrated = migrateFromLegacyBlob(conversation);
                messageStore.setMessages(migrated);

                // Save migrated messages
                for (PersistedChatMessage msg : migrated) {
                    messageRepository.saveMessage(programHash, sessionId, msg);
                }
            }
        }
    }

    // ==================== ReAct Support ====================

    /**
     * Save ReAct analysis to database with full investigation history.
     */
    public void saveReActAnalysis(String userQuery, String investigationHistory, String finalResult) {
        ensureSession();

        int sessionId = sessionManager.getCurrentSessionId();
        if (sessionId == ChatSessionManager.NO_SESSION || plugin.getCurrentProgram() == null) {
            return;
        }

        String programHash = plugin.getCurrentProgram().getExecutableSHA256();

        int existingMessageCount = analysisDB.getReActMessages(programHash, sessionId).size();
        int messageOrder = existingMessageCount;
        int iterationNumber = analysisDB.getMaxReActIteration(programHash, sessionId) + 1;

        // Save user query
        ghidrassist.apiprovider.ChatMessage userMsg =
            new ghidrassist.apiprovider.ChatMessage("user", userQuery);
        analysisDB.saveReActMessage(programHash, sessionId, messageOrder++,
            "planning", null, userMsg);

        // Save investigation history
        if (investigationHistory != null && !investigationHistory.isEmpty()) {
            ghidrassist.apiprovider.ChatMessage investigationMsg =
                new ghidrassist.apiprovider.ChatMessage("assistant", investigationHistory);
            analysisDB.saveReActMessage(programHash, sessionId, messageOrder++,
                "investigation", iterationNumber, investigationMsg);

            analysisDB.saveReActIterationChunk(programHash, sessionId, iterationNumber,
                investigationHistory, messageOrder - 1, messageOrder - 1);
        }

        // Save final synthesis
        ghidrassist.apiprovider.ChatMessage finalMsg =
            new ghidrassist.apiprovider.ChatMessage("assistant", finalResult);
        analysisDB.saveReActMessage(programHash, sessionId, messageOrder++,
            "synthesis", null, finalMsg);
    }

    private String formatReActConversation(java.util.List<ghidrassist.apiprovider.ChatMessage> messages,
                                            int sessionId) {
        StringBuilder conversation = new StringBuilder();
        String userQuery = null;
        String investigationHistory = null;
        String finalSynthesis = null;

        for (ghidrassist.apiprovider.ChatMessage msg : messages) {
            if ("user".equals(msg.getRole())) {
                userQuery = msg.getContent();
            } else if ("assistant".equals(msg.getRole())) {
                if (msg.getContent() != null) {
                    if (investigationHistory == null ||
                        msg.getContent().length() > investigationHistory.length()) {
                        if (investigationHistory != null) {
                            finalSynthesis = investigationHistory;
                        }
                        investigationHistory = msg.getContent();
                    } else {
                        finalSynthesis = msg.getContent();
                    }
                }
            }
        }

        if (userQuery != null) {
            conversation.append("**User**: ").append(userQuery).append("\n\n");
        }
        if (investigationHistory != null) {
            conversation.append(investigationHistory);
            if (finalSynthesis != null && !investigationHistory.contains("# Final")) {
                conversation.append("\n\n---\n\n");
            }
        }
        if (finalSynthesis != null) {
            if (!finalSynthesis.trim().startsWith("#")) {
                conversation.append("# Final Analysis\n\n");
            }
            conversation.append(finalSynthesis).append("\n\n");
        }

        return conversation.toString();
    }

    // ==================== Utility Methods ====================

    private String getProgramHash() {
        if (plugin.getCurrentProgram() != null) {
            return plugin.getCurrentProgram().getExecutableSHA256();
        }
        return null;
    }

    private PersistedChatMessage getLastMessage() {
        List<PersistedChatMessage> messages = messageStore.getMessages();
        if (!messages.isEmpty()) {
            return messages.get(messages.size() - 1);
        }
        return null;
    }

    /**
     * Get the AnalysisDB instance (for backward compatibility)
     */
    public AnalysisDB getAnalysisDB() {
        return analysisDB;
    }

    // ==================== Query Request ====================

    /**
     * Request object for query operations
     */
    public static class QueryRequest {
        private final String processedQuery;
        private final String fullConversation;
        private final boolean useMCP;

        public QueryRequest(String processedQuery, String fullConversation, boolean useMCP) {
            this.processedQuery = processedQuery;
            this.fullConversation = fullConversation;
            this.useMCP = useMCP;
        }

        public String getProcessedQuery() { return processedQuery; }
        public String getFullConversation() { return fullConversation; }
        public boolean shouldUseMCP() { return useMCP; }
    }
}

```

`src/main/java/ghidrassist/services/RAGManagementService.java`:

```java
package ghidrassist.services;

import ghidrassist.core.RAGDocumentInfo;
import ghidrassist.core.RAGEngine;
import ghidrassist.core.SearchResult;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Service for managing RAG (Retrieval Augmented Generation) documents.
 * Responsible for document ingestion, deletion, and listing operations.
 */
public class RAGManagementService {
    
    /**
     * Add documents to the RAG index
     */
    public void addDocuments(File[] files) throws IOException {
        if (files == null || files.length == 0) {
            throw new IllegalArgumentException("No files provided for ingestion.");
        }
        
        RAGEngine.ingestDocuments(Arrays.asList(files));
    }
    
    /**
     * Delete selected documents from the RAG index
     */
    public void deleteDocuments(List<String> fileNames) throws IOException {
        if (fileNames == null || fileNames.isEmpty()) {
            throw new IllegalArgumentException("No documents selected for deletion.");
        }
        
        for (String fileName : fileNames) {
            RAGEngine.deleteDocument(fileName);
        }
    }
    
    /**
     * Get list of indexed files
     */
    public List<String> getIndexedFiles() throws IOException {
        return RAGEngine.listIndexedFiles();
    }
    
    /**
     * Check if the RAG index is available and working
     */
    public boolean isRAGAvailable() {
        try {
            RAGEngine.listIndexedFiles();
            return true;
        } catch (IOException e) {
            return false;
        }
    }
    
    /**
     * Get RAG index statistics
     */
    public RAGIndexStats getIndexStats() throws IOException {
        List<String> files = getIndexedFiles();
        int chunkCount = RAGEngine.getTotalChunkCount();
        int embeddingCount = RAGEngine.getEmbeddingCount();
        return new RAGIndexStats(files.size(), chunkCount, embeddingCount, files);
    }

    /**
     * Get detailed document list with metadata (filename, size, chunk count).
     */
    public List<RAGDocumentInfo> getIndexedDocumentsWithInfo() throws IOException {
        List<RAGDocumentInfo> docs = new ArrayList<>();
        List<String> files = getIndexedFiles();

        for (String filename : files) {
            long size = RAGEngine.getDocumentSize(filename);
            int chunks = RAGEngine.getChunkCount(filename);
            docs.add(new RAGDocumentInfo(filename, size, chunks));
        }

        return docs;
    }

    /**
     * Perform hybrid search (combines vector and keyword search).
     */
    public List<SearchResult> searchHybrid(String query, int maxResults) throws Exception {
        return RAGEngine.hybridSearch(query, maxResults);
    }

    /**
     * Perform semantic (vector-based) search.
     */
    public List<SearchResult> searchSemantic(String query, int maxResults) throws Exception {
        return RAGEngine.semanticSearch(query, maxResults);
    }

    /**
     * Perform keyword (BM25) search.
     */
    public List<SearchResult> searchKeyword(String query, int maxResults) throws Exception {
        return RAGEngine.search(query, maxResults);
    }

    /**
     * Clear all documents from the RAG index
     */
    public void clearAllDocuments() throws IOException {
        RAGEngine.clearIndex();
    }

    /**
     * Statistics about the RAG index
     */
    public static class RAGIndexStats {
        private final int totalFiles;
        private final int totalChunks;
        private final int totalEmbeddings;
        private final List<String> fileNames;

        public RAGIndexStats(int totalFiles, int totalChunks, int totalEmbeddings, List<String> fileNames) {
            this.totalFiles = totalFiles;
            this.totalChunks = totalChunks;
            this.totalEmbeddings = totalEmbeddings;
            this.fileNames = fileNames;
        }

        public int getTotalFiles() { return totalFiles; }
        public int getTotalChunks() { return totalChunks; }
        public int getTotalEmbeddings() { return totalEmbeddings; }
        public List<String> getFileNames() { return fileNames; }

        @Override
        public String toString() {
            return String.format("RAG Index: %d files, %d chunks, %d embeddings",
                    totalFiles, totalChunks, totalEmbeddings);
        }
    }
}
```

`src/main/java/ghidrassist/services/symgraph/SymGraphModels.java`:

```java
package ghidrassist.services.symgraph;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Data models for SymGraph API integration.
 */
public class SymGraphModels {

    /**
     * Action type for conflict resolution during pull.
     */
    public enum ConflictAction {
        NEW("new"),           // Remote only, doesn't exist locally
        CONFLICT("conflict"), // Different values locally and remotely
        SAME("same");         // Identical values locally and remotely

        private final String value;

        ConflictAction(String value) {
            this.value = value;
        }

        public String getValue() {
            return value;
        }
    }

    /**
     * Scope for push operations.
     */
    public enum PushScope {
        FULL_BINARY("full"),
        CURRENT_FUNCTION("function");

        private final String value;

        PushScope(String value) {
            this.value = value;
        }

        public String getValue() {
            return value;
        }
    }

    /**
     * Statistics for a binary in SymGraph.
     */
    public static class BinaryStats {
        private int symbolCount;
        private int functionCount;
        private int graphNodeCount;
        private int queryCount;
        private String lastQueriedAt;

        public BinaryStats() {}

        public BinaryStats(int symbolCount, int functionCount, int graphNodeCount,
                          int queryCount, String lastQueriedAt) {
            this.symbolCount = symbolCount;
            this.functionCount = functionCount;
            this.graphNodeCount = graphNodeCount;
            this.queryCount = queryCount;
            this.lastQueriedAt = lastQueriedAt;
        }

        public int getSymbolCount() { return symbolCount; }
        public void setSymbolCount(int symbolCount) { this.symbolCount = symbolCount; }
        public int getFunctionCount() { return functionCount; }
        public void setFunctionCount(int functionCount) { this.functionCount = functionCount; }
        public int getGraphNodeCount() { return graphNodeCount; }
        public void setGraphNodeCount(int graphNodeCount) { this.graphNodeCount = graphNodeCount; }
        public int getQueryCount() { return queryCount; }
        public void setQueryCount(int queryCount) { this.queryCount = queryCount; }
        public String getLastQueriedAt() { return lastQueriedAt; }
        public void setLastQueriedAt(String lastQueriedAt) { this.lastQueriedAt = lastQueriedAt; }
    }

    /**
     * A symbol from SymGraph.
     */
    public static class Symbol {
        private long address;
        private String symbolType;
        private String name;
        private String dataType;
        private double confidence;
        private String provenance;
        private String source;
        private String content;  // For comments - stores the comment text
        private Map<String, Object> metadata;

        public Symbol() {}

        public Symbol(long address, String symbolType, String name,
                     double confidence, String provenance) {
            this.address = address;
            this.symbolType = symbolType;
            this.name = name;
            this.confidence = confidence;
            this.provenance = provenance;
        }

        public long getAddress() { return address; }
        public void setAddress(long address) { this.address = address; }
        public String getSymbolType() { return symbolType; }
        public void setSymbolType(String symbolType) { this.symbolType = symbolType; }
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        public String getDataType() { return dataType; }
        public void setDataType(String dataType) { this.dataType = dataType; }
        public double getConfidence() { return confidence; }
        public void setConfidence(double confidence) { this.confidence = confidence; }
        public String getProvenance() { return provenance; }
        public void setProvenance(String provenance) { this.provenance = provenance; }
        public String getSource() { return source; }
        public void setSource(String source) { this.source = source; }
        public String getContent() { return content; }
        public void setContent(String content) { this.content = content; }

        /**
         * Get the display name for this symbol.
         * For comments (which have no name), returns the content field.
         * For other symbols, returns the name.
         */
        public String getDisplayName() {
            if (name != null && !name.isEmpty()) {
                return name;
            }
            if (content != null && !content.isEmpty()) {
                return content;
            }
            return null;
        }
        public Map<String, Object> getMetadata() { return metadata; }
        public void setMetadata(Map<String, Object> metadata) { this.metadata = metadata; }
    }

    /**
     * A graph node from SymGraph.
     */
    public static class GraphNode {
        private String id;
        private long address;
        private String nodeType;
        private String name;
        private String summary;
        private Map<String, Object> properties;

        public GraphNode() {}

        public String getId() { return id; }
        public void setId(String id) { this.id = id; }
        public long getAddress() { return address; }
        public void setAddress(long address) { this.address = address; }
        public String getNodeType() { return nodeType; }
        public void setNodeType(String nodeType) { this.nodeType = nodeType; }
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        public String getSummary() { return summary; }
        public void setSummary(String summary) { this.summary = summary; }
        public Map<String, Object> getProperties() { return properties; }
        public void setProperties(Map<String, Object> properties) { this.properties = properties; }
    }

    /**
     * A graph edge from SymGraph.
     */
    public static class GraphEdge {
        private long sourceAddress;
        private long targetAddress;
        private String edgeType;
        private Map<String, Object> properties;

        public GraphEdge() {}

        public GraphEdge(long sourceAddress, long targetAddress, String edgeType) {
            this.sourceAddress = sourceAddress;
            this.targetAddress = targetAddress;
            this.edgeType = edgeType;
        }

        public long getSourceAddress() { return sourceAddress; }
        public void setSourceAddress(long sourceAddress) { this.sourceAddress = sourceAddress; }
        public long getTargetAddress() { return targetAddress; }
        public void setTargetAddress(long targetAddress) { this.targetAddress = targetAddress; }
        public String getEdgeType() { return edgeType; }
        public void setEdgeType(String edgeType) { this.edgeType = edgeType; }
        public Map<String, Object> getProperties() { return properties; }
        public void setProperties(Map<String, Object> properties) { this.properties = properties; }
    }

    /**
     * Exported graph data from SymGraph.
     */
    public static class GraphExport {
        private String binarySha256;
        private List<GraphNode> nodes;
        private List<GraphEdge> edges;
        private String exportVersion;
        private Map<String, Object> metadata;

        public String getBinarySha256() { return binarySha256; }
        public void setBinarySha256(String binarySha256) { this.binarySha256 = binarySha256; }
        public List<GraphNode> getNodes() { return nodes != null ? nodes : new ArrayList<>(); }
        public void setNodes(List<GraphNode> nodes) { this.nodes = nodes; }
        public List<GraphEdge> getEdges() { return edges != null ? edges : new ArrayList<>(); }
        public void setEdges(List<GraphEdge> edges) { this.edges = edges; }
        public String getExportVersion() { return exportVersion; }
        public void setExportVersion(String exportVersion) { this.exportVersion = exportVersion; }
        public Map<String, Object> getMetadata() { return metadata; }
        public void setMetadata(Map<String, Object> metadata) { this.metadata = metadata; }
    }

    /**
     * An entry in the conflict resolution table.
     */
    public static class ConflictEntry {
        private long address;
        private String localName;
        private String remoteName;
        private ConflictAction action;
        private boolean selected;
        private Symbol remoteSymbol;

        public ConflictEntry() {}

        public ConflictEntry(long address, String localName, String remoteName,
                            ConflictAction action, boolean selected, Symbol remoteSymbol) {
            this.address = address;
            this.localName = localName;
            this.remoteName = remoteName;
            this.action = action;
            this.selected = selected;
            this.remoteSymbol = remoteSymbol;
        }

        public static ConflictEntry createNew(long address, Symbol remoteSymbol) {
            return new ConflictEntry(address, null, remoteSymbol.getDisplayName(),
                    ConflictAction.NEW, true, remoteSymbol);
        }

        public static ConflictEntry createConflict(long address, String localName, Symbol remoteSymbol) {
            return new ConflictEntry(address, localName, remoteSymbol.getDisplayName(),
                    ConflictAction.CONFLICT, false, remoteSymbol);
        }

        public static ConflictEntry createSame(long address, String name, Symbol remoteSymbol) {
            return new ConflictEntry(address, name, name,
                    ConflictAction.SAME, true, remoteSymbol);
        }

        public long getAddress() { return address; }
        public void setAddress(long address) { this.address = address; }
        public String getLocalName() { return localName; }
        public void setLocalName(String localName) { this.localName = localName; }
        public String getRemoteName() { return remoteName; }
        public void setRemoteName(String remoteName) { this.remoteName = remoteName; }
        public ConflictAction getAction() { return action; }
        public void setAction(ConflictAction action) { this.action = action; }
        public boolean isSelected() { return selected; }
        public void setSelected(boolean selected) { this.selected = selected; }
        public Symbol getRemoteSymbol() { return remoteSymbol; }
        public void setRemoteSymbol(Symbol remoteSymbol) { this.remoteSymbol = remoteSymbol; }

        public String getAddressHex() {
            return String.format("0x%x", address);
        }

        public String getLocalNameDisplay() {
            return localName != null ? localName : "<none>";
        }

        public String getRemoteNameDisplay() {
            return remoteName != null ? remoteName : "<none>";
        }
    }

    /**
     * Result of a SymGraph query operation.
     */
    public static class QueryResult {
        private boolean exists;
        private BinaryStats stats;
        private String error;

        public QueryResult() {}

        public static QueryResult found(BinaryStats stats) {
            QueryResult result = new QueryResult();
            result.exists = true;
            result.stats = stats;
            return result;
        }

        public static QueryResult notFound() {
            QueryResult result = new QueryResult();
            result.exists = false;
            return result;
        }

        public static QueryResult error(String errorMsg) {
            QueryResult result = new QueryResult();
            result.exists = false;
            result.error = errorMsg;
            return result;
        }

        public boolean isExists() { return exists; }
        public void setExists(boolean exists) { this.exists = exists; }
        public BinaryStats getStats() { return stats; }
        public void setStats(BinaryStats stats) { this.stats = stats; }
        public String getError() { return error; }
        public void setError(String error) { this.error = error; }
    }

    /**
     * Result of a SymGraph push operation.
     */
    public static class PushResult {
        private boolean success;
        private int symbolsPushed;
        private int nodesPushed;
        private int edgesPushed;
        private String error;

        public PushResult() {}

        public static PushResult success(int symbols, int nodes, int edges) {
            PushResult result = new PushResult();
            result.success = true;
            result.symbolsPushed = symbols;
            result.nodesPushed = nodes;
            result.edgesPushed = edges;
            return result;
        }

        public static PushResult failure(String errorMsg) {
            PushResult result = new PushResult();
            result.success = false;
            result.error = errorMsg;
            return result;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }
        public int getSymbolsPushed() { return symbolsPushed; }
        public void setSymbolsPushed(int symbolsPushed) { this.symbolsPushed = symbolsPushed; }
        public int getNodesPushed() { return nodesPushed; }
        public void setNodesPushed(int nodesPushed) { this.nodesPushed = nodesPushed; }
        public int getEdgesPushed() { return edgesPushed; }
        public void setEdgesPushed(int edgesPushed) { this.edgesPushed = edgesPushed; }
        public String getError() { return error; }
        public void setError(String error) { this.error = error; }
    }

    /**
     * Result of a pull preview operation.
     */
    public static class PullPreviewResult {
        private boolean success;
        private List<ConflictEntry> conflicts;
        private String error;

        public PullPreviewResult() {
            this.conflicts = new ArrayList<>();
        }

        public static PullPreviewResult success(List<ConflictEntry> conflicts) {
            PullPreviewResult result = new PullPreviewResult();
            result.success = true;
            result.conflicts = conflicts;
            return result;
        }

        public static PullPreviewResult failure(String errorMsg) {
            PullPreviewResult result = new PullPreviewResult();
            result.success = false;
            result.error = errorMsg;
            return result;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }
        public List<ConflictEntry> getConflicts() { return conflicts; }
        public void setConflicts(List<ConflictEntry> conflicts) { this.conflicts = conflicts; }
        public String getError() { return error; }
        public void setError(String error) { this.error = error; }
    }
}

```

`src/main/java/ghidrassist/services/symgraph/SymGraphService.java`:

```java
package ghidrassist.services.symgraph;

import java.io.IOException;
import java.time.Duration;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.reflect.TypeToken;

import ghidra.framework.preferences.Preferences;
import ghidra.util.Msg;
import ghidrassist.services.symgraph.SymGraphModels.*;
import okhttp3.*;

/**
 * Service for interacting with the SymGraph API.
 * Provides methods for querying, pushing, and pulling symbols and graph data.
 */
public class SymGraphService {
    private static final String TAG = "SymGraphService";
    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
    private static final int TIMEOUT_SECONDS = 120;  // Increased for large uploads
    private static final int CHUNK_SIZE = 500;  // Symbols/nodes per chunk

    // Retry settings for rate limiting (429 responses)
    private static final int MAX_RETRIES = 5;
    private static final long INITIAL_BACKOFF_MS = 1000;  // 1 second
    private static final long MAX_BACKOFF_MS = 30000;     // 30 seconds

    private final Gson gson;
    private OkHttpClient client;

    /**
     * Progress callback interface for chunked operations.
     */
    public interface ProgressCallback {
        void onProgress(int current, int total, String message);
        boolean isCancelled();
    }

    public SymGraphService() {
        // serializeNulls ensures ALL fields are sent, even if null
        this.gson = new GsonBuilder().serializeNulls().create();
        this.client = buildClient();
    }

    /**
     * Rebuild the HTTP client if settings change (e.g., API URL changed).
     */
    public void rebuildClient() {
        this.client = buildClient();
    }

    private OkHttpClient buildClient() {
        OkHttpClient.Builder builder = new OkHttpClient.Builder()
                .connectTimeout(Duration.ofSeconds(30))
                .readTimeout(Duration.ofSeconds(TIMEOUT_SECONDS))
                .writeTimeout(Duration.ofSeconds(TIMEOUT_SECONDS));

        // Allow insecure connections for localhost and private/internal networks
        String apiUrl = getApiUrl();
        if (apiUrl.contains("localhost") || apiUrl.contains("127.0.0.1")
                || apiUrl.matches(".*://10\\..*") || apiUrl.matches(".*://172\\.(1[6-9]|2[0-9]|3[01])\\..*")
                || apiUrl.matches(".*://192\\.168\\..*")) {
            try {
                // Create a trust manager that does not validate certificate chains
                final javax.net.ssl.TrustManager[] trustAllCerts = new javax.net.ssl.TrustManager[]{
                    new javax.net.ssl.X509TrustManager() {
                        @Override
                        public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) {}
                        @Override
                        public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) {}
                        @Override
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() { return new java.security.cert.X509Certificate[]{}; }
                    }
                };

                // Install the all-trusting trust manager
                final javax.net.ssl.SSLContext sslContext = javax.net.ssl.SSLContext.getInstance("SSL");
                sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
                final javax.net.ssl.SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();

                builder.sslSocketFactory(sslSocketFactory, (javax.net.ssl.X509TrustManager) trustAllCerts[0]);
                builder.hostnameVerifier((hostname, session) -> true);

                Msg.debug(this, TAG + ": Using insecure SSL for internal network: " + apiUrl);
            } catch (Exception e) {
                Msg.warn(this, TAG + ": Failed to configure insecure SSL: " + e.getMessage());
            }
        }

        return builder.build();
    }

    // === Settings helpers ===

    public String getApiUrl() {
        String url = Preferences.getProperty("GhidrAssist.SymGraphAPIUrl", "https://api.symgraph.com");
        return url.endsWith("/") ? url.substring(0, url.length() - 1) : url;
    }

    public String getApiKey() {
        return Preferences.getProperty("GhidrAssist.SymGraphAPIKey", "");
    }

    public boolean hasApiKey() {
        String key = getApiKey();
        return key != null && !key.trim().isEmpty();
    }

    // === Unauthenticated Operations ===

    /**
     * Check if a binary exists in SymGraph (unauthenticated).
     */
    public boolean checkBinaryExists(String sha256) throws IOException {
        String url = getApiUrl() + "/api/v1/binaries/" + sha256;
        Msg.debug(this, TAG + ": Checking binary existence: " + url);

        Request request = new Request.Builder()
                .url(url)
                .head()
                .addHeader("Accept", "application/json")
                .addHeader("User-Agent", "GhidrAssist-SymGraph/1.0")
                .build();

        try (Response response = client.newCall(request).execute()) {
            return response.isSuccessful();
        }
    }

    /**
     * Get binary statistics from SymGraph (unauthenticated).
     */
    public BinaryStats getBinaryStats(String sha256) throws IOException {
        String url = getApiUrl() + "/api/v1/binaries/" + sha256 + "/stats";
        Msg.debug(this, TAG + ": Getting binary stats: " + url);

        Request request = new Request.Builder()
                .url(url)
                .get()
                .addHeader("Accept", "application/json")
                .addHeader("User-Agent", "GhidrAssist-SymGraph/1.0")
                .build();

        try (Response response = client.newCall(request).execute()) {
            if (!response.isSuccessful()) {
                if (response.code() == 404) {
                    return null;
                }
                throw new IOException("Unexpected response: " + response.code());
            }

            String body = response.body().string();
            JsonObject json = JsonParser.parseString(body).getAsJsonObject();

            // Stats may be nested inside a "stats" object
            JsonObject statsJson = json.has("stats") && json.get("stats").isJsonObject()
                    ? json.getAsJsonObject("stats")
                    : json;

            BinaryStats stats = new BinaryStats();
            stats.setSymbolCount(getIntOrDefault(statsJson, "symbol_count", 0));
            stats.setFunctionCount(getIntOrDefault(statsJson, "function_count", 0));
            stats.setGraphNodeCount(getIntOrDefault(statsJson, "graph_node_count", 0));
            stats.setQueryCount(getIntOrDefault(statsJson, "query_count", 0));
            // last_queried_at might be at top level even when stats are nested
            String lastQueried = getStringOrNull(json, "last_queried_at");
            if (lastQueried == null) {
                lastQueried = getStringOrNull(statsJson, "last_queried_at");
            }
            stats.setLastQueriedAt(lastQueried);

            return stats;
        }
    }

    /**
     * Query SymGraph for binary info (unauthenticated).
     */
    public QueryResult queryBinary(String sha256) {
        try {
            boolean exists = checkBinaryExists(sha256);
            if (!exists) {
                return QueryResult.notFound();
            }

            BinaryStats stats = getBinaryStats(sha256);
            if (stats != null) {
                return QueryResult.found(stats);
            } else {
                QueryResult result = new QueryResult();
                result.setExists(true);
                return result;
            }
        } catch (Exception e) {
            Msg.error(this, TAG + ": Query error: " + e.getMessage());
            return QueryResult.error(e.getMessage());
        }
    }

    /**
     * Query SymGraph asynchronously.
     */
    public CompletableFuture<QueryResult> queryBinaryAsync(String sha256) {
        return CompletableFuture.supplyAsync(() -> queryBinary(sha256));
    }

    // === Authenticated Operations ===

    /**
     * Get symbols for a binary (authenticated).
     * @param sha256 SHA256 hash of the binary
     * @param symbolType Optional symbol type filter (e.g., "function", "data", "type"). Pass null for all symbols.
     */
    public List<Symbol> getSymbols(String sha256, String symbolType) throws IOException, SymGraphAuthException {
        checkAuthRequired();

        String url = getApiUrl() + "/api/v1/binaries/" + sha256 + "/symbols";
        if (symbolType != null && !symbolType.isEmpty()) {
            url += "?type=" + symbolType;
        }
        Msg.debug(this, TAG + ": Getting symbols: " + url);

        Request request = new Request.Builder()
                .url(url)
                .get()
                .addHeader("Accept", "application/json")
                .addHeader("X-API-Key", getApiKey())
                .addHeader("User-Agent", "GhidrAssist-SymGraph/1.0")
                .build();

        try (Response response = client.newCall(request).execute()) {
            if (response.code() == 401) {
                throw new SymGraphAuthException("Invalid API key");
            }
            if (response.code() == 404) {
                return new ArrayList<>();
            }
            if (!response.isSuccessful()) {
                throw new IOException("Error getting symbols: " + response.code());
            }

            String body = response.body().string();
            JsonObject json = JsonParser.parseString(body).getAsJsonObject();

            // Handle null or missing symbols safely
            JsonArray symbolsArray = null;
            if (json.has("symbols") && !json.get("symbols").isJsonNull()) {
                symbolsArray = json.getAsJsonArray("symbols");
            } else {
                // Try parsing body as array directly
                JsonElement bodyElement = JsonParser.parseString(body);
                if (bodyElement.isJsonArray()) {
                    symbolsArray = bodyElement.getAsJsonArray();
                }
            }

            // Return empty list if no valid symbols array
            if (symbolsArray == null) {
                return new ArrayList<>();
            }

            List<Symbol> symbols = new ArrayList<>();
            for (JsonElement elem : symbolsArray) {
                JsonObject symObj = elem.getAsJsonObject();
                Symbol symbol = new Symbol();
                symbol.setAddress(getLongOrDefault(symObj, "address", 0));
                symbol.setSymbolType(getStringOrDefault(symObj, "symbol_type", "function"));
                symbol.setName(getStringOrNull(symObj, "name"));
                symbol.setDataType(getStringOrNull(symObj, "data_type"));
                symbol.setConfidence(getDoubleOrDefault(symObj, "confidence", 0.0));
                symbol.setProvenance(getStringOrDefault(symObj, "provenance", "unknown"));
                symbol.setContent(getStringOrNull(symObj, "content"));

                // Parse metadata if present (for variables, comments, structs, enums)
                if (symObj.has("metadata") && !symObj.get("metadata").isJsonNull()) {
                    Map<String, Object> metadata = gson.fromJson(
                            symObj.get("metadata"), new TypeToken<Map<String, Object>>() {}.getType());
                    symbol.setMetadata(metadata);
                }

                symbols.add(symbol);
            }

            return symbols;
        }
    }

    /**
     * Export graph data for a binary (authenticated).
     */
    public GraphExport exportGraph(String sha256) throws IOException, SymGraphAuthException {
        checkAuthRequired();

        String url = getApiUrl() + "/api/v1/binaries/" + sha256 + "/graph/export";
        Msg.debug(this, TAG + ": Exporting graph: " + url);

        Request request = new Request.Builder()
                .url(url)
                .get()
                .addHeader("Accept", "application/json")
                .addHeader("X-API-Key", getApiKey())
                .addHeader("User-Agent", "GhidrAssist-SymGraph/1.0")
                .build();

        try (Response response = client.newCall(request).execute()) {
            if (response.code() == 401) {
                throw new SymGraphAuthException("Invalid API key");
            }
            if (response.code() == 404) {
                return null;
            }
            if (!response.isSuccessful()) {
                throw new IOException("Error exporting graph: " + response.code());
            }

            String body = response.body().string();
            JsonObject json = JsonParser.parseString(body).getAsJsonObject();

            GraphExport export = new GraphExport();
            export.setBinarySha256(getStringOrDefault(json, "binary_sha256", sha256));
            export.setExportVersion(getStringOrDefault(json, "export_version", "1.0"));

            if (json.has("metadata") && json.get("metadata").isJsonObject()) {
                Map<String, Object> metadata = gson.fromJson(
                        json.get("metadata"), new TypeToken<Map<String, Object>>() {}.getType());
                export.setMetadata(metadata);
            }

            List<GraphNode> nodes = new ArrayList<>();
            if (json.has("nodes") && json.get("nodes").isJsonArray()) {
                JsonArray nodesArray = json.getAsJsonArray("nodes");
                for (JsonElement elem : nodesArray) {
                    JsonObject nodeObj = elem.getAsJsonObject();
                    GraphNode node = new GraphNode();
                    node.setId(getStringOrNull(nodeObj, "id"));
                    node.setAddress(getLongOrDefault(nodeObj, "address", 0));
                    node.setNodeType(getStringOrDefault(nodeObj, "node_type", "function"));
                    node.setName(getStringOrNull(nodeObj, "name"));
                    node.setSummary(getStringOrNull(nodeObj, "llm_summary"));

                    // Build properties map from top-level fields AND nested properties
                    // Backend sends RE analysis fields at the top level, not nested in "properties"
                    Map<String, Object> props = new HashMap<>();

                    // First, copy any nested properties object
                    if (nodeObj.has("properties") && nodeObj.get("properties").isJsonObject()) {
                        Map<String, Object> nestedProps = gson.fromJson(
                                nodeObj.get("properties"), new TypeToken<Map<String, Object>>() {}.getType());
                        props.putAll(nestedProps);
                    }

                    // Then parse top-level RE analysis fields (these override nested if present)
                    if (nodeObj.has("raw_content") && !nodeObj.get("raw_content").isJsonNull()) {
                        props.put("raw_content", nodeObj.get("raw_content").getAsString());
                    }
                    if (nodeObj.has("confidence") && !nodeObj.get("confidence").isJsonNull()) {
                        props.put("confidence", nodeObj.get("confidence").getAsDouble());
                    }
                    if (nodeObj.has("security_flags") && !nodeObj.get("security_flags").isJsonNull()) {
                        props.put("security_flags", gson.fromJson(nodeObj.get("security_flags"),
                                new TypeToken<List<String>>() {}.getType()));
                    }
                    if (nodeObj.has("network_apis") && !nodeObj.get("network_apis").isJsonNull()) {
                        props.put("network_apis", gson.fromJson(nodeObj.get("network_apis"),
                                new TypeToken<List<String>>() {}.getType()));
                    }
                    if (nodeObj.has("file_io_apis") && !nodeObj.get("file_io_apis").isJsonNull()) {
                        props.put("file_io_apis", gson.fromJson(nodeObj.get("file_io_apis"),
                                new TypeToken<List<String>>() {}.getType()));
                    }
                    if (nodeObj.has("ip_addresses") && !nodeObj.get("ip_addresses").isJsonNull()) {
                        props.put("ip_addresses", gson.fromJson(nodeObj.get("ip_addresses"),
                                new TypeToken<List<String>>() {}.getType()));
                    }
                    if (nodeObj.has("urls") && !nodeObj.get("urls").isJsonNull()) {
                        props.put("urls", gson.fromJson(nodeObj.get("urls"),
                                new TypeToken<List<String>>() {}.getType()));
                    }
                    if (nodeObj.has("file_paths") && !nodeObj.get("file_paths").isJsonNull()) {
                        props.put("file_paths", gson.fromJson(nodeObj.get("file_paths"),
                                new TypeToken<List<String>>() {}.getType()));
                    }
                    if (nodeObj.has("domains") && !nodeObj.get("domains").isJsonNull()) {
                        props.put("domains", gson.fromJson(nodeObj.get("domains"),
                                new TypeToken<List<String>>() {}.getType()));
                    }
                    if (nodeObj.has("registry_keys") && !nodeObj.get("registry_keys").isJsonNull()) {
                        props.put("registry_keys", gson.fromJson(nodeObj.get("registry_keys"),
                                new TypeToken<List<String>>() {}.getType()));
                    }
                    if (nodeObj.has("risk_level") && !nodeObj.get("risk_level").isJsonNull()) {
                        props.put("risk_level", nodeObj.get("risk_level").getAsString());
                    }
                    if (nodeObj.has("activity_profile") && !nodeObj.get("activity_profile").isJsonNull()) {
                        props.put("activity_profile", nodeObj.get("activity_profile").getAsString());
                    }
                    if (nodeObj.has("analysis_depth") && !nodeObj.get("analysis_depth").isJsonNull()) {
                        props.put("analysis_depth", nodeObj.get("analysis_depth").getAsInt());
                    }

                    node.setProperties(props);
                    nodes.add(node);
                }
            }
            export.setNodes(nodes);

            List<GraphEdge> edges = new ArrayList<>();
            if (json.has("edges") && json.get("edges").isJsonArray()) {
                JsonArray edgesArray = json.getAsJsonArray("edges");
                for (JsonElement elem : edgesArray) {
                    JsonObject edgeObj = elem.getAsJsonObject();
                    GraphEdge edge = new GraphEdge();
                    edge.setSourceAddress(getLongOrDefault(edgeObj, "source_address", 0));
                    edge.setTargetAddress(getLongOrDefault(edgeObj, "target_address", 0));
                    edge.setEdgeType(getStringOrDefault(edgeObj, "edge_type", "calls"));
                    if (edgeObj.has("properties") && edgeObj.get("properties").isJsonObject()) {
                        Map<String, Object> props = gson.fromJson(
                                edgeObj.get("properties"), new TypeToken<Map<String, Object>>() {}.getType());
                        edge.setProperties(props);
                    }
                    edges.add(edge);
                }
            }
            export.setEdges(edges);

            return export;
        }
    }

    /**
     * Push symbols to SymGraph in bulk (authenticated).
     */
    public PushResult pushSymbolsBulk(String sha256, List<Map<String, Object>> symbols) throws IOException, SymGraphAuthException {
        return pushSymbolsBulk(sha256, symbols, null);
    }

    /**
     * Push symbols to SymGraph in bulk with retry support (authenticated).
     */
    public PushResult pushSymbolsBulk(String sha256, List<Map<String, Object>> symbols, ProgressCallback progress) throws IOException, SymGraphAuthException {
        checkAuthRequired();

        String url = getApiUrl() + "/api/v1/binaries/" + sha256 + "/symbols/bulk";
        Msg.debug(this, TAG + ": Pushing " + symbols.size() + " symbols to: " + url);

        Map<String, Object> payload = new HashMap<>();
        payload.put("symbols", symbols);

        RequestBody body = RequestBody.create(gson.toJson(payload), JSON);

        Request request = new Request.Builder()
                .url(url)
                .post(body)
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .addHeader("X-API-Key", getApiKey())
                .addHeader("User-Agent", "GhidrAssist-SymGraph/1.0")
                .build();

        try (Response response = executeWithRetry(request, progress)) {
            if (response.code() == 401) {
                throw new SymGraphAuthException("Invalid API key");
            }
            if (!response.isSuccessful()) {
                String errorBody = response.body() != null ? response.body().string() : "Unknown error";
                return PushResult.failure("Error pushing symbols: " + response.code() + " - " + errorBody);
            }

            String responseBody = response.body().string();
            JsonObject json = JsonParser.parseString(responseBody).getAsJsonObject();
            int symbolsCreated = getIntOrDefault(json, "symbols_created", symbols.size());

            return PushResult.success(symbolsCreated, 0, 0);
        }
    }

    /**
     * Push symbols in chunks with progress reporting (authenticated).
     * Breaks large symbol sets into smaller chunks to avoid timeouts.
     */
    public PushResult pushSymbolsChunked(String sha256, List<Map<String, Object>> symbols, ProgressCallback progress)
            throws IOException, SymGraphAuthException {
        checkAuthRequired();

        if (symbols.isEmpty()) {
            return PushResult.success(0, 0, 0);
        }

        int totalSymbols = symbols.size();
        int totalPushed = 0;
        int chunkIndex = 0;

        Msg.info(this, TAG + ": Pushing " + totalSymbols + " symbols in chunks of " + CHUNK_SIZE);

        for (int i = 0; i < totalSymbols; i += CHUNK_SIZE) {
            // Check for cancellation
            if (progress != null && progress.isCancelled()) {
                Msg.info(this, TAG + ": Push cancelled by user");
                return PushResult.success(totalPushed, 0, 0);
            }

            int end = Math.min(i + CHUNK_SIZE, totalSymbols);
            List<Map<String, Object>> chunk = symbols.subList(i, end);
            chunkIndex++;

            // Report progress
            if (progress != null) {
                progress.onProgress(i, totalSymbols,
                        String.format("Pushing symbols... %d/%d (chunk %d)", i, totalSymbols, chunkIndex));
            }

            // Push this chunk (with retry support)
            PushResult chunkResult = pushSymbolsBulk(sha256, chunk, progress);
            if (!chunkResult.isSuccess()) {
                return PushResult.failure("Chunk " + chunkIndex + " failed: " + chunkResult.getError());
            }

            totalPushed += chunkResult.getSymbolsPushed();
        }

        // Final progress update
        if (progress != null) {
            progress.onProgress(totalSymbols, totalSymbols, "Symbols complete");
        }

        Msg.info(this, TAG + ": Successfully pushed " + totalPushed + " symbols");
        return PushResult.success(totalPushed, 0, 0);
    }

    /**
     * Import graph data in chunks with progress reporting (authenticated).
     * Splits nodes and edges into manageable chunks.
     */
    @SuppressWarnings("unchecked")
    public PushResult importGraphChunked(String sha256, Map<String, Object> graphData, ProgressCallback progress)
            throws IOException, SymGraphAuthException {
        checkAuthRequired();

        List<Map<String, Object>> nodes = (List<Map<String, Object>>) graphData.get("nodes");
        List<Map<String, Object>> edges = (List<Map<String, Object>>) graphData.get("edges");

        if ((nodes == null || nodes.isEmpty()) && (edges == null || edges.isEmpty())) {
            return PushResult.success(0, 0, 0);
        }

        int totalNodes = nodes != null ? nodes.size() : 0;
        int totalEdges = edges != null ? edges.size() : 0;
        int totalItems = totalNodes + totalEdges;
        int processedItems = 0;
        int totalNodesPushed = 0;
        int totalEdgesPushed = 0;

        Msg.info(this, TAG + ": Pushing " + totalNodes + " nodes and " + totalEdges + " edges");

        // Push nodes in chunks
        if (nodes != null && !nodes.isEmpty()) {
            for (int i = 0; i < totalNodes; i += CHUNK_SIZE) {
                if (progress != null && progress.isCancelled()) {
                    Msg.info(this, TAG + ": Push cancelled by user");
                    return PushResult.success(0, totalNodesPushed, totalEdgesPushed);
                }

                int end = Math.min(i + CHUNK_SIZE, totalNodes);
                List<Map<String, Object>> nodeChunk = nodes.subList(i, end);

                if (progress != null) {
                    progress.onProgress(processedItems, totalItems,
                            String.format("Pushing nodes... %d/%d", i, totalNodes));
                }

                Map<String, Object> chunkData = new HashMap<>();
                chunkData.put("nodes", nodeChunk);
                chunkData.put("edges", new ArrayList<>());

                PushResult result = importGraph(sha256, chunkData, progress);
                if (!result.isSuccess()) {
                    return PushResult.failure("Node chunk failed: " + result.getError());
                }

                totalNodesPushed += result.getNodesPushed();
                processedItems += nodeChunk.size();
            }
        }

        // Push edges in chunks
        if (edges != null && !edges.isEmpty()) {
            for (int i = 0; i < totalEdges; i += CHUNK_SIZE) {
                if (progress != null && progress.isCancelled()) {
                    Msg.info(this, TAG + ": Push cancelled by user");
                    return PushResult.success(0, totalNodesPushed, totalEdgesPushed);
                }

                int end = Math.min(i + CHUNK_SIZE, totalEdges);
                List<Map<String, Object>> edgeChunk = edges.subList(i, end);

                if (progress != null) {
                    progress.onProgress(processedItems, totalItems,
                            String.format("Pushing edges... %d/%d", i, totalEdges));
                }

                Map<String, Object> chunkData = new HashMap<>();
                chunkData.put("nodes", new ArrayList<>());
                chunkData.put("edges", edgeChunk);

                PushResult result = importGraph(sha256, chunkData, progress);
                if (!result.isSuccess()) {
                    return PushResult.failure("Edge chunk failed: " + result.getError());
                }

                totalEdgesPushed += result.getEdgesPushed();
                processedItems += edgeChunk.size();
            }
        }

        // Final progress update
        if (progress != null) {
            progress.onProgress(totalItems, totalItems, "Graph complete");
        }

        Msg.info(this, TAG + ": Successfully pushed " + totalNodesPushed + " nodes, " + totalEdgesPushed + " edges");
        return PushResult.success(0, totalNodesPushed, totalEdgesPushed);
    }

    /**
     * Import graph data to SymGraph (authenticated).
     */
    public PushResult importGraph(String sha256, Map<String, Object> graphData) throws IOException, SymGraphAuthException {
        return importGraph(sha256, graphData, null);
    }

    /**
     * Import graph data to SymGraph with retry support (authenticated).
     */
    public PushResult importGraph(String sha256, Map<String, Object> graphData, ProgressCallback progress) throws IOException, SymGraphAuthException {
        checkAuthRequired();

        String url = getApiUrl() + "/api/v1/binaries/" + sha256 + "/graph/import";
        Msg.debug(this, TAG + ": Importing graph to: " + url);

        RequestBody body = RequestBody.create(gson.toJson(graphData), JSON);

        Request request = new Request.Builder()
                .url(url)
                .post(body)
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .addHeader("X-API-Key", getApiKey())
                .addHeader("User-Agent", "GhidrAssist-SymGraph/1.0")
                .build();

        try (Response response = executeWithRetry(request, progress)) {
            if (response.code() == 401) {
                throw new SymGraphAuthException("Invalid API key");
            }
            if (!response.isSuccessful()) {
                String errorBody = response.body() != null ? response.body().string() : "Unknown error";
                return PushResult.failure("Error importing graph: " + response.code() + " - " + errorBody);
            }

            String responseBody = response.body().string();
            JsonObject json = JsonParser.parseString(responseBody).getAsJsonObject();
            int nodesImported = getIntOrDefault(json, "nodes_imported", 0);
            int edgesImported = getIntOrDefault(json, "edges_imported", 0);

            return PushResult.success(0, nodesImported, edgesImported);
        }
    }

    /**
     * Add a fingerprint to a binary (authenticated).
     * Used for debug symbol matching (BuildID for ELF, PDB GUID for PE).
     */
    public boolean addFingerprint(String sha256, String fpType, String fpValue) throws IOException, SymGraphAuthException {
        checkAuthRequired();

        String url = getApiUrl() + "/api/v1/binaries/" + sha256 + "/fingerprints";
        Msg.debug(this, TAG + ": Adding fingerprint " + fpType + "=" + fpValue);

        JsonObject payload = new JsonObject();
        payload.addProperty("type", fpType);
        payload.addProperty("value", fpValue);

        RequestBody body = RequestBody.create(
                payload.toString(),
                MediaType.parse("application/json")
        );

        Request request = new Request.Builder()
                .url(url)
                .post(body)
                .addHeader("Accept", "application/json")
                .addHeader("X-API-Key", getApiKey())
                .addHeader("User-Agent", "GhidrAssist-SymGraph/1.0")
                .build();

        try (Response response = client.newCall(request).execute()) {
            if (response.code() == 401) {
                throw new SymGraphAuthException("Invalid API key");
            }
            if (response.code() == 409) {
                // Fingerprint already exists - not an error
                Msg.debug(this, TAG + ": Fingerprint already exists");
                return true;
            }
            if (!response.isSuccessful()) {
                Msg.warn(this, TAG + ": Failed to add fingerprint: " + response.code());
                return false;
            }
            Msg.info(this, TAG + ": Added fingerprint: " + fpType + "=" + fpValue);
            return true;
        }
    }

    /**
     * Get all symbols for a binary (authenticated).
     * Convenience overload that fetches all symbol types.
     */
    public List<Symbol> getSymbols(String sha256) throws IOException, SymGraphAuthException {
        return getSymbols(sha256, null);
    }

    /**
     * Get symbols asynchronously.
     */
    public CompletableFuture<List<Symbol>> getSymbolsAsync(String sha256) {
        return getSymbolsAsync(sha256, null);
    }

    /**
     * Get symbols asynchronously with optional type filter.
     * @param sha256 SHA256 hash of the binary
     * @param symbolType Optional symbol type filter (e.g., "function"). Pass null for all symbols.
     */
    public CompletableFuture<List<Symbol>> getSymbolsAsync(String sha256, String symbolType) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                return getSymbols(sha256, symbolType);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
    }

    /**
     * Push symbols asynchronously.
     */
    public CompletableFuture<PushResult> pushSymbolsBulkAsync(String sha256, List<Map<String, Object>> symbols) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                return pushSymbolsBulk(sha256, symbols);
            } catch (Exception e) {
                return PushResult.failure(e.getMessage());
            }
        });
    }

    // === Helper Methods ===

    /**
     * Build conflict entries by comparing local and remote symbols.
     * Filters out remote symbols with default/auto-generated names and applies confidence threshold.
     *
     * @param localSymbols Map of address to local symbol name
     * @param remoteSymbols List of remote symbols from the server
     * @param minConfidence Minimum confidence threshold (0.0-1.0) for remote symbols
     * @return List of conflict entries for the merge UI
     */
    public List<ConflictEntry> buildConflictEntries(Map<Long, String> localSymbols, List<Symbol> remoteSymbols, double minConfidence) {
        List<ConflictEntry> conflicts = new ArrayList<>();
        int skippedDefault = 0;
        int skippedConfidence = 0;
        int skippedDuplicate = 0;

        // Deduplicate by address: keep the best symbol per address.
        // Prefer named symbols (function/variable) over comments,
        // and higher confidence over lower.
        Map<Long, Symbol> bestByAddress = new java.util.LinkedHashMap<>();
        for (Symbol remoteSym : remoteSymbols) {
            String displayName = remoteSym.getDisplayName();
            boolean isComment = "comment".equals(remoteSym.getSymbolType());

            // Skip symbols with no useful display name (null name AND null content)
            if (displayName == null || displayName.isEmpty()) {
                skippedDefault++;
                continue;
            }

            // Skip non-comment symbols with default/auto-generated names
            if (!isComment && SymGraphUtils.isDefaultName(remoteSym.getName())) {
                skippedDefault++;
                continue;
            }

            // Skip remote symbols below minimum confidence threshold
            if (remoteSym.getConfidence() < minConfidence) {
                skippedConfidence++;
                continue;
            }

            long addr = remoteSym.getAddress();
            Symbol existing = bestByAddress.get(addr);
            if (existing == null) {
                bestByAddress.put(addr, remoteSym);
            } else {
                // Prefer non-comment over comment, then higher confidence
                boolean existingIsComment = "comment".equals(existing.getSymbolType());
                if (existingIsComment && !isComment) {
                    bestByAddress.put(addr, remoteSym);
                    skippedDuplicate++;
                } else if (!existingIsComment && isComment) {
                    skippedDuplicate++;
                } else if (remoteSym.getConfidence() > existing.getConfidence()) {
                    bestByAddress.put(addr, remoteSym);
                    skippedDuplicate++;
                } else {
                    skippedDuplicate++;
                }
            }
        }

        for (Symbol remoteSym : bestByAddress.values()) {
            long addr = remoteSym.getAddress();
            String localName = localSymbols.get(addr);
            boolean localIsDefault = SymGraphUtils.isDefaultName(localName);

            if (localName == null || localIsDefault) {
                // Remote only OR local has default name - NEW (safe to apply)
                conflicts.add(ConflictEntry.createNew(addr, remoteSym));
            } else if (localName.equals(remoteSym.getDisplayName())) {
                // Same value - SAME
                conflicts.add(ConflictEntry.createSame(addr, localName, remoteSym));
            } else {
                // Different values (both user-defined) - CONFLICT
                conflicts.add(ConflictEntry.createConflict(addr, localName, remoteSym));
            }
        }

        if (skippedDefault > 0 || skippedConfidence > 0 || skippedDuplicate > 0) {
            Msg.info(this, String.format("Filtered out %d default names, %d low confidence, %d duplicates",
                    skippedDefault, skippedConfidence, skippedDuplicate));
        }

        return conflicts;
    }

    /**
     * Build conflict entries with default minimum confidence of 0.0.
     */
    public List<ConflictEntry> buildConflictEntries(Map<Long, String> localSymbols, List<Symbol> remoteSymbols) {
        return buildConflictEntries(localSymbols, remoteSymbols, 0.0);
    }

    private void checkAuthRequired() throws SymGraphAuthException {
        if (!hasApiKey()) {
            throw new SymGraphAuthException("SymGraph.ai API key not configured. Add your API key in Settings > General > SymGraph");
        }
    }

    /**
     * Execute an HTTP request with retry logic for rate limiting (429) responses.
     * Uses exponential backoff with jitter.
     *
     * @param request The request to execute
     * @param progress Optional progress callback to report retry status
     * @return The successful response
     * @throws IOException If the request fails after all retries
     */
    @SuppressWarnings("unused")  // lastException preserved for debugging/future use
    private Response executeWithRetry(Request request, ProgressCallback progress) throws IOException {
        int attempt = 0;
        long backoffMs = INITIAL_BACKOFF_MS;
        IOException lastException = null;

        while (attempt < MAX_RETRIES) {
            attempt++;

            Response response;
            try {
                response = client.newCall(request).execute();
            } catch (IOException e) {
                // Network error - log and retry
                Msg.warn(this, TAG + ": Network error on attempt " + attempt + ": " + e.getMessage());
                lastException = e;
                if (attempt >= MAX_RETRIES) {
                    throw new IOException("Network error after " + MAX_RETRIES + " retries: " + e.getMessage(), e);
                }
                // Use backoff for network errors too
                sleepWithBackoff(backoffMs, attempt, progress, "Network error");
                backoffMs = Math.min(backoffMs * 2, MAX_BACKOFF_MS);
                continue;
            }

            if (response.code() != 429) {
                // Not rate limited, return the response
                return response;
            }

            // Read Retry-After header BEFORE closing the response
            String retryAfter = response.header("Retry-After");

            // Close the 429 response body
            response.close();

            if (attempt >= MAX_RETRIES) {
                throw new IOException("Rate limited (429) after " + MAX_RETRIES + " retries. Please try again later.");
            }

            // Check for cancellation before sleeping
            if (progress != null && progress.isCancelled()) {
                throw new IOException("Cancelled during rate limit backoff");
            }

            // Calculate wait time from Retry-After header or use exponential backoff
            long waitMs = backoffMs;
            if (retryAfter != null) {
                try {
                    waitMs = Long.parseLong(retryAfter) * 1000;
                } catch (NumberFormatException e) {
                    // Use default backoff
                }
            }

            // Add jitter (±20%)
            long jitter = (long) (waitMs * 0.2 * (Math.random() - 0.5));
            waitMs = Math.min(waitMs + jitter, MAX_BACKOFF_MS);

            Msg.info(this, TAG + ": Rate limited (429), waiting " + waitMs + "ms before retry " + attempt + "/" + MAX_RETRIES);

            // Update progress to show we're waiting
            if (progress != null) {
                final long finalWaitMs = waitMs;
                final int finalAttempt = attempt;
                progress.onProgress(-1, -1, String.format("Rate limited, retrying in %.1fs (%d/%d)...",
                        finalWaitMs / 1000.0, finalAttempt, MAX_RETRIES));
            }

            try {
                Thread.sleep(waitMs);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new IOException("Interrupted during rate limit backoff");
            }

            // Exponential backoff for next attempt
            backoffMs = Math.min(backoffMs * 2, MAX_BACKOFF_MS);
        }

        // Should never reach here due to throws in loop, but just in case
        throw new IOException("Failed after " + MAX_RETRIES + " attempts");
    }

    /**
     * Sleep with backoff, updating progress and checking for cancellation.
     */
    private void sleepWithBackoff(long backoffMs, int attempt, ProgressCallback progress, String reason) throws IOException {
        // Add jitter (±20%)
        long jitter = (long) (backoffMs * 0.2 * (Math.random() - 0.5));
        long waitMs = Math.min(backoffMs + jitter, MAX_BACKOFF_MS);

        Msg.info(this, TAG + ": " + reason + ", waiting " + waitMs + "ms before retry " + attempt + "/" + MAX_RETRIES);

        // Update progress to show we're waiting
        if (progress != null) {
            progress.onProgress(-1, -1, String.format("%s, retrying in %.1fs (%d/%d)...",
                    reason, waitMs / 1000.0, attempt, MAX_RETRIES));
        }

        // Check for cancellation before sleeping
        if (progress != null && progress.isCancelled()) {
            throw new IOException("Cancelled during backoff");
        }

        try {
            Thread.sleep(waitMs);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new IOException("Interrupted during backoff");
        }
    }

    // JSON helper methods
    private int getIntOrDefault(JsonObject obj, String key, int defaultValue) {
        return obj.has(key) && !obj.get(key).isJsonNull() ? obj.get(key).getAsInt() : defaultValue;
    }

    private long getLongOrDefault(JsonObject obj, String key, long defaultValue) {
        if (!obj.has(key) || obj.get(key).isJsonNull()) {
            return defaultValue;
        }
        try {
            return obj.get(key).getAsLong();
        } catch (NumberFormatException e) {
            try {
                String value = obj.get(key).getAsString();
                if (value != null && value.startsWith("0x")) {
                    return Long.parseLong(value.substring(2), 16);
                }
                return Long.parseLong(value);
            } catch (Exception ignored) {
                return defaultValue;
            }
        }
    }

    private double getDoubleOrDefault(JsonObject obj, String key, double defaultValue) {
        return obj.has(key) && !obj.get(key).isJsonNull() ? obj.get(key).getAsDouble() : defaultValue;
    }

    private String getStringOrNull(JsonObject obj, String key) {
        return obj.has(key) && !obj.get(key).isJsonNull() ? obj.get(key).getAsString() : null;
    }

    private String getStringOrDefault(JsonObject obj, String key, String defaultValue) {
        return obj.has(key) && !obj.get(key).isJsonNull() ? obj.get(key).getAsString() : defaultValue;
    }

    /**
     * Exception for authentication errors.
     */
    public static class SymGraphAuthException extends Exception {
        private static final long serialVersionUID = 1L;

        public SymGraphAuthException(String message) {
            super(message);
        }
    }
}

```

`src/main/java/ghidrassist/services/symgraph/SymGraphUtils.java`:

```java
package ghidrassist.services.symgraph;

import ghidra.program.model.listing.Function;
import ghidra.program.model.symbol.Namespace;
import ghidra.program.model.symbol.Symbol;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

/**
 * Utility methods for SymGraph operations.
 * Includes cross-tool default name detection for symbol filtering.
 */
public class SymGraphUtils {

    /**
     * Unified default name patterns for cross-tool compatibility.
     * These patterns identify auto-generated names from various disassemblers:
     * - Binary Ninja: sub_*, data_*, byte_*, arg*, var_*
     * - Ghidra: FUN_*, DAT_*, param_*, local_*, uVar*, etc.
     * - radare2: fcn.*, func_*
     * - IDA: sub_*, a1-a9
     */
    private static final Pattern[] DEFAULT_NAME_PATTERNS = {
        // Functions
        Pattern.compile("^sub_[0-9a-fA-F]+$"),          // Binary Ninja, IDA
        Pattern.compile("^FUN_[0-9a-fA-F]+$"),          // Ghidra
        Pattern.compile("^fcn\\.[0-9a-fA-F]+$"),        // radare2
        Pattern.compile("^func_[0-9a-fA-F]+$"),         // Generic
        Pattern.compile("^j_.*$"),                       // Thunks
        // Data
        Pattern.compile("^(data|DAT|byte|BYTE|dword|DWORD|qword|QWORD)_[0-9a-fA-F]+$", Pattern.CASE_INSENSITIVE),
        // Variables (Ghidra decompiler patterns)
        Pattern.compile("^(var|local|uVar|iVar|lVar|pVar|cVar|bVar|sVar|auVar|puVar)_?\\d*$"),
        // Parameters
        Pattern.compile("^(arg|param)_?\\d+$"),
        Pattern.compile("^a[1-9]$"),                     // IDA-style numbered args
    };

    /**
     * Check if a symbol name matches auto-generated patterns from any disassembler.
     * Handles qualified names by extracting the simple name part before matching.
     * For example, "Class::FUN_12345" will extract "FUN_12345" and match it against patterns.
     *
     * @param name The symbol name to check (may include namespace qualifiers like "Namespace::Name")
     * @return true if the name is auto-generated (default), false if user-defined
     */
    public static boolean isDefaultName(String name) {
        if (name == null || name.isEmpty()) {
            return true;
        }

        // Extract simple name from qualified name (e.g., "Class::method" -> "method")
        String simpleName = name;
        int lastSeparator = name.lastIndexOf("::");
        if (lastSeparator >= 0 && lastSeparator < name.length() - 2) {
            simpleName = name.substring(lastSeparator + 2);
        }

        for (Pattern pattern : DEFAULT_NAME_PATTERNS) {
            if (pattern.matcher(simpleName).matches()) {
                return true;
            }
        }
        return false;
    }

    /**
     * Check if a symbol name is user-defined (not auto-generated).
     *
     * @param name The symbol name to check
     * @return true if the name is user-defined, false if auto-generated
     */
    public static boolean isUserDefinedName(String name) {
        return !isDefaultName(name);
    }

    /**
     * Get the fully qualified name of a function including its namespace.
     * Returns "Namespace::FunctionName" for namespaced functions, or just the name for global functions.
     * Skips Ghidra internal namespaces like &lt;EXTERNAL&gt;.
     *
     * @param func The function to get the qualified name for
     * @return The fully qualified function name
     */
    public static String getQualifiedFunctionName(Function func) {
        if (func == null) {
            return null;
        }

        Symbol symbol = func.getSymbol();
        if (symbol == null) {
            return func.getName();
        }

        Namespace parentNs = symbol.getParentNamespace();
        if (parentNs == null || parentNs.isGlobal()) {
            return func.getName();
        }

        // Build qualified name: Namespace::FunctionName
        // Handle nested namespaces by walking up the chain
        List<String> namespaces = new ArrayList<>();

        Namespace ns = parentNs;
        while (ns != null && !ns.isGlobal()) {
            String nsName = ns.getName();
            // Skip Ghidra internal namespaces like <EXTERNAL>
            if (nsName != null && !(nsName.startsWith("<") && nsName.endsWith(">"))) {
                namespaces.add(0, nsName);  // prepend
            }
            ns = ns.getParentNamespace();
        }

        if (namespaces.isEmpty()) {
            return func.getName();
        }

        StringBuilder qualifiedName = new StringBuilder();
        for (String nsName : namespaces) {
            if (qualifiedName.length() > 0) {
                qualifiedName.append("::");
            }
            qualifiedName.append(nsName);
        }
        qualifiedName.append("::");
        qualifiedName.append(func.getName());

        return qualifiedName.toString();
    }
}

```

`src/main/java/ghidrassist/tools/api/Tool.java`:

```java
package ghidrassist.tools.api;

import com.google.gson.JsonObject;

/**
 * Core interface for all tools in the GhidrAssist system.
 * Tools can come from different sources (native, MCP servers, etc.)
 * but all implement this common interface.
 */
public interface Tool {

    /**
     * Get the unique name of this tool.
     * @return Tool name (e.g., "get_semantic_analysis", "rename_function")
     */
    String getName();

    /**
     * Get a human-readable description of what this tool does.
     * @return Tool description
     */
    String getDescription();

    /**
     * Get the JSON schema describing this tool's input parameters.
     * @return JSON schema object
     */
    JsonObject getInputSchema();

    /**
     * Get the source/provider of this tool.
     * @return Source identifier (e.g., "native", "mcp:server-name")
     */
    String getSource();
}

```

`src/main/java/ghidrassist/tools/api/ToolExecutor.java`:

```java
package ghidrassist.tools.api;

import com.google.gson.JsonObject;

import java.util.List;
import java.util.concurrent.CompletableFuture;

/**
 * Interface for executing tools by name.
 * The ToolRegistry implements this interface to provide
 * unified tool execution across all providers.
 */
public interface ToolExecutor {

    /**
     * Execute a tool by name with the given arguments.
     * @param toolName Name of the tool to execute
     * @param args Arguments as JSON object
     * @return Future containing the tool result
     */
    CompletableFuture<ToolResult> execute(String toolName, JsonObject args);

    /**
     * Get all available tools from all providers.
     * @return List of all tools
     */
    List<Tool> getAllTools();
}

```

`src/main/java/ghidrassist/tools/api/ToolProvider.java`:

```java
package ghidrassist.tools.api;

import com.google.gson.JsonObject;
import ghidra.program.model.listing.Program;

import java.util.List;
import java.util.concurrent.CompletableFuture;

/**
 * Interface for tool sources/providers.
 * Each provider manages a set of tools and handles their execution.
 *
 * Examples of providers:
 * - NativeToolManager: Internal tools (semantic, actions)
 * - MCPToolManager: Tools from MCP servers
 */
public interface ToolProvider {

    /**
     * Get the name of this provider.
     * @return Provider name (e.g., "native", "MCP")
     */
    String getProviderName();

    /**
     * Get all tools provided by this provider.
     * @return List of available tools
     */
    List<Tool> getTools();

    /**
     * Execute a tool by name with the given arguments.
     * @param name Tool name
     * @param args Tool arguments as JSON
     * @return Future containing the tool result
     */
    CompletableFuture<ToolResult> executeTool(String name, JsonObject args);

    /**
     * Check if this provider handles the given tool.
     * @param name Tool name
     * @return true if this provider can execute the tool
     */
    boolean handlesTool(String name);

    /**
     * Set the Ghidra program context for tools that need it.
     * @param program Current Ghidra program (may be null)
     */
    void setContext(Program program);
}

```

`src/main/java/ghidrassist/tools/api/ToolResult.java`:

```java
package ghidrassist.tools.api;

/**
 * Unified result type for tool execution.
 * Encapsulates success/error state and content.
 */
public class ToolResult {

    private final boolean success;
    private final String content;
    private final String errorMessage;

    private ToolResult(boolean success, String content, String errorMessage) {
        this.success = success;
        this.content = content;
        this.errorMessage = errorMessage;
    }

    /**
     * Create a successful result with content.
     */
    public static ToolResult success(String content) {
        return new ToolResult(true, content, null);
    }

    /**
     * Create an error result with a message.
     */
    public static ToolResult error(String errorMessage) {
        return new ToolResult(false, null, errorMessage);
    }

    /**
     * Check if this result represents success.
     */
    public boolean isSuccess() {
        return success;
    }

    /**
     * Check if this result represents an error.
     */
    public boolean isError() {
        return !success;
    }

    /**
     * Get the content (for successful results).
     */
    public String getContent() {
        return content;
    }

    /**
     * Get the error message (for error results).
     */
    public String getErrorMessage() {
        return errorMessage;
    }

    /**
     * Get the content or error message, whichever is applicable.
     */
    public String getContentOrError() {
        return success ? content : errorMessage;
    }

    @Override
    public String toString() {
        if (success) {
            return "ToolResult[success, content=" +
                   (content != null ? content.substring(0, Math.min(100, content.length())) + "..." : "null") + "]";
        } else {
            return "ToolResult[error, message=" + errorMessage + "]";
        }
    }
}

```

`src/main/java/ghidrassist/tools/native_/ActionToolProvider.java`:

```java
package ghidrassist.tools.native_;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import ghidrassist.core.ActionExecutor;
import ghidrassist.tools.api.Tool;
import ghidrassist.tools.api.ToolProvider;
import ghidrassist.tools.api.ToolResult;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

/**
 * Tool provider for Ghidra action tools.
 * These tools modify the program (rename, retype, etc.).
 *
 * Tools provided:
 * - rename_function: Rename a function
 * - rename_variable: Rename a variable
 * - retype_variable: Change variable data type
 * - auto_create_struct: Automatically create a structure from variable usage
 */
public class ActionToolProvider implements ToolProvider {

    private static final String PROVIDER_NAME = "Actions";
    private static final String TOOL_PREFIX = "ga_";
    private static final Gson gson = new Gson();

    private Program currentProgram;
    private Address currentAddress;

    // Tool definitions - keys are the base names (without prefix)
    private static final Map<String, ActionToolDef> ACTION_TOOLS = new HashMap<>();

    static {
        // rename_function
        ACTION_TOOLS.put("rename_function", new ActionToolDef(
                "rename_function",
                "Rename a function at the current address",
                createSchema(
                        Map.of("new_name", prop("string", "The new name for the function")),
                        List.of("new_name")
                )
        ));

        // rename_variable
        ACTION_TOOLS.put("rename_variable", new ActionToolDef(
                "rename_variable",
                "Rename a local variable or parameter in the current function",
                createSchema(
                        Map.of(
                                "var_name", prop("string", "Current variable name"),
                                "new_name", prop("string", "New name for the variable")
                        ),
                        List.of("var_name", "new_name")
                )
        ));

        // retype_variable
        ACTION_TOOLS.put("retype_variable", new ActionToolDef(
                "retype_variable",
                "Change the data type of a local variable or parameter",
                createSchema(
                        Map.of(
                                "var_name", prop("string", "Variable name to retype"),
                                "new_type", prop("string", "New data type (e.g., 'int', 'char *', 'struct MyStruct *')")
                        ),
                        List.of("var_name", "new_type")
                )
        ));

        // auto_create_struct
        ACTION_TOOLS.put("auto_create_struct", new ActionToolDef(
                "auto_create_struct",
                "Automatically create a structure based on how a pointer variable is used in the function",
                createSchema(
                        Map.of("var_name", prop("string", "Pointer variable to analyze for structure creation")),
                        List.of("var_name")
                )
        ));
    }

    @Override
    public String getProviderName() {
        return PROVIDER_NAME;
    }

    @Override
    public List<Tool> getTools() {
        if (currentProgram == null || currentAddress == null) {
            return java.util.Collections.emptyList();
        }

        List<Tool> tools = new ArrayList<>();
        for (ActionToolDef def : ACTION_TOOLS.values()) {
            // Add prefix to tool name
            tools.add(new NativeTool(TOOL_PREFIX + def.name, def.description, def.inputSchema, PROVIDER_NAME));
        }
        return tools;
    }

    @Override
    public CompletableFuture<ToolResult> executeTool(String name, JsonObject args) {
        return CompletableFuture.supplyAsync(() -> {
            // Strip prefix to get base name
            String baseName = name.startsWith(TOOL_PREFIX) ? name.substring(TOOL_PREFIX.length()) : name;

            if (!ACTION_TOOLS.containsKey(baseName)) {
                return ToolResult.error("Unknown action tool: " + name);
            }

            if (currentProgram == null) {
                return ToolResult.error("No program context set");
            }

            if (currentAddress == null) {
                return ToolResult.error("No address context set");
            }

            try {
                Msg.info(this, "Executing action tool: " + name + " with args: " + args);

                // Convert JsonObject to JSON string for ActionExecutor
                String argsJson = gson.toJson(args);

                // Execute the action using base name (ActionExecutor doesn't know about prefix)
                ActionExecutor.executeAction(baseName, argsJson, currentProgram, currentAddress);

                return ToolResult.success("Action '" + name + "' executed successfully");

            } catch (Exception e) {
                Msg.error(this, "Action tool execution failed: " + e.getMessage(), e);
                return ToolResult.error("Action failed: " + e.getMessage());
            }
        });
    }

    @Override
    public boolean handlesTool(String name) {
        // Check with prefix
        if (name.startsWith(TOOL_PREFIX)) {
            String baseName = name.substring(TOOL_PREFIX.length());
            return ACTION_TOOLS.containsKey(baseName);
        }
        return false;
    }

    @Override
    public void setContext(Program program) {
        this.currentProgram = program;
        Msg.debug(this, "Set program context: " + (program != null ? program.getName() : "null"));
    }

    /**
     * Set the current address context for actions.
     * @param address Current address in Ghidra
     */
    public void setAddress(Address address) {
        this.currentAddress = address;
    }

    /**
     * Set both program and address context.
     */
    public void setContext(Program program, Address address) {
        this.currentProgram = program;
        this.currentAddress = address;
    }

    // Helper methods for creating JSON schemas

    private static JsonObject createSchema(Map<String, JsonObject> properties, List<String> required) {
        JsonObject schema = new JsonObject();
        schema.addProperty("type", "object");

        JsonObject propsObj = new JsonObject();
        for (Map.Entry<String, JsonObject> entry : properties.entrySet()) {
            propsObj.add(entry.getKey(), entry.getValue());
        }
        schema.add("properties", propsObj);

        if (!required.isEmpty()) {
            JsonArray reqArray = new JsonArray();
            for (String req : required) {
                reqArray.add(req);
            }
            schema.add("required", reqArray);
        }

        return schema;
    }

    private static JsonObject prop(String type, String description) {
        JsonObject prop = new JsonObject();
        prop.addProperty("type", type);
        prop.addProperty("description", description);
        return prop;
    }

    // Inner class for tool definitions
    private static class ActionToolDef {
        final String name;
        final String description;
        final JsonObject inputSchema;

        ActionToolDef(String name, String description, JsonObject inputSchema) {
            this.name = name;
            this.description = description;
            this.inputSchema = inputSchema;
        }
    }
}

```

`src/main/java/ghidrassist/tools/native_/GhidraToolProvider.java`:

```java
package ghidrassist.tools.native_;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.FunctionManager;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.SourceType;
import ghidra.util.Msg;
import ghidrassist.tools.api.Tool;
import ghidrassist.tools.api.ToolProvider;
import ghidrassist.tools.api.ToolResult;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

/**
 * Tool provider for Ghidra context query tools.
 * These are read-only tools that query the current Ghidra state.
 *
 * Tools provided:
 * - get_current_function: Get information about the function at the current cursor location
 * - get_current_address: Get the current cursor address
 */
public class GhidraToolProvider implements ToolProvider {

    private static final String PROVIDER_NAME = "Ghidra";
    private static final String TOOL_PREFIX = "ga_";

    private Program currentProgram;
    private Address currentAddress;

    @Override
    public String getProviderName() {
        return PROVIDER_NAME;
    }

    @Override
    public List<Tool> getTools() {
        if (currentProgram == null || currentAddress == null) {
            return java.util.Collections.emptyList();
        }

        List<Tool> tools = new ArrayList<>();

        // ga.get_current_function
        tools.add(new NativeTool(
                TOOL_PREFIX + "get_current_function",
                "Get information about the function at the current cursor location. " +
                "Returns the function name, address, signature, and basic metadata.",
                createEmptySchema(),
                PROVIDER_NAME
        ));

        // ga.get_current_address
        tools.add(new NativeTool(
                TOOL_PREFIX + "get_current_address",
                "Get the current cursor address in hexadecimal format.",
                createEmptySchema(),
                PROVIDER_NAME
        ));

        return tools;
    }

    @Override
    public CompletableFuture<ToolResult> executeTool(String name, JsonObject args) {
        return CompletableFuture.supplyAsync(() -> {
            if (currentProgram == null) {
                return ToolResult.error("No program context set");
            }

            try {
                switch (name) {
                    case TOOL_PREFIX + "get_current_function":
                        return executeGetCurrentFunction();
                    case TOOL_PREFIX + "get_current_address":
                        return executeGetCurrentAddress();
                    default:
                        return ToolResult.error("Unknown tool: " + name);
                }
            } catch (Exception e) {
                Msg.error(this, "Tool execution failed: " + e.getMessage(), e);
                return ToolResult.error("Tool failed: " + e.getMessage());
            }
        });
    }

    private ToolResult executeGetCurrentFunction() {
        if (currentAddress == null) {
            return ToolResult.error("No current address set");
        }

        FunctionManager funcManager = currentProgram.getFunctionManager();
        Function function = funcManager.getFunctionContaining(currentAddress);

        if (function == null) {
            return ToolResult.error("No function found at current address: " + currentAddress);
        }

        JsonObject result = new JsonObject();
        result.addProperty("name", function.getName());
        result.addProperty("address", function.getEntryPoint().toString());
        result.addProperty("signature", function.getSignature().getPrototypeString());
        result.addProperty("calling_convention", function.getCallingConventionName());
        result.addProperty("is_thunk", function.isThunk());
        result.addProperty("parameter_count", function.getParameterCount());
        result.addProperty("stack_frame_size", function.getStackFrame().getFrameSize());

        // Source type indicates if user-defined, imported, analysis, etc.
        SourceType sourceType = function.getSymbol().getSource();
        result.addProperty("source_type", sourceType.toString());

        // Get comment if present
        String comment = function.getComment();
        if (comment != null && !comment.isEmpty()) {
            result.addProperty("comment", comment);
        }

        // Body address range
        result.addProperty("body_start", function.getBody().getMinAddress().toString());
        result.addProperty("body_end", function.getBody().getMaxAddress().toString());

        return ToolResult.success(result.toString());
    }

    private ToolResult executeGetCurrentAddress() {
        if (currentAddress == null) {
            return ToolResult.error("No current address set");
        }

        JsonObject result = new JsonObject();
        result.addProperty("address", currentAddress.toString());
        result.addProperty("offset", "0x" + Long.toHexString(currentAddress.getOffset()));

        return ToolResult.success(result.toString());
    }

    @Override
    public boolean handlesTool(String name) {
        return (TOOL_PREFIX + "get_current_function").equals(name) ||
               (TOOL_PREFIX + "get_current_address").equals(name);
    }

    @Override
    public void setContext(Program program) {
        this.currentProgram = program;
    }

    /**
     * Set the current address context.
     * @param address Current address in Ghidra
     */
    public void setAddress(Address address) {
        this.currentAddress = address;
    }

    /**
     * Set both program and address context.
     */
    public void setContext(Program program, Address address) {
        this.currentProgram = program;
        this.currentAddress = address;
    }

    // Helper to create empty parameter schema
    private JsonObject createEmptySchema() {
        JsonObject schema = new JsonObject();
        schema.addProperty("type", "object");
        schema.add("properties", new JsonObject());
        return schema;
    }
}

```

`src/main/java/ghidrassist/tools/native_/NativeTool.java`:

```java
package ghidrassist.tools.native_;

import com.google.gson.JsonObject;
import ghidrassist.mcp2.tools.MCPTool;
import ghidrassist.tools.api.Tool;

/**
 * Adapter that wraps different tool sources to implement the Tool interface.
 * Can wrap MCPTool objects or be constructed directly for action tools.
 */
public class NativeTool implements Tool {

    private final String name;
    private final String description;
    private final JsonObject inputSchema;
    private final String source;

    /**
     * Create a NativeTool from an MCPTool.
     * Used for wrapping semantic query tools.
     */
    public NativeTool(MCPTool mcpTool, String source) {
        this.name = mcpTool.getName();
        this.description = mcpTool.getDescription();
        this.inputSchema = mcpTool.getInputSchema();
        this.source = source;
    }

    /**
     * Create a NativeTool directly.
     * Used for action tools and other native tools.
     */
    public NativeTool(String name, String description, JsonObject inputSchema, String source) {
        this.name = name;
        this.description = description;
        this.inputSchema = inputSchema;
        this.source = source;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public String getDescription() {
        return description;
    }

    @Override
    public JsonObject getInputSchema() {
        return inputSchema;
    }

    @Override
    public String getSource() {
        return source;
    }

    @Override
    public String toString() {
        return String.format("NativeTool{name='%s', source='%s'}", name, source);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        NativeTool that = (NativeTool) obj;
        return name != null && name.equals(that.name) &&
               source != null && source.equals(that.source);
    }

    @Override
    public int hashCode() {
        return java.util.Objects.hash(name, source);
    }
}

```

`src/main/java/ghidrassist/tools/native_/NativeToolManager.java`:

```java
package ghidrassist.tools.native_;

import com.google.gson.JsonObject;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import ghidrassist.AnalysisDB;
import ghidrassist.tools.api.Tool;
import ghidrassist.tools.api.ToolProvider;
import ghidrassist.tools.api.ToolResult;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * Manager for all native (internal) tool providers.
 * This is the central point for tools that are built into GhidrAssist,
 * as opposed to tools from external MCP servers.
 *
 * Native tools include:
 * - Ghidra context tools (get_current_function, get_current_address)
 * - Semantic query tools (Graph-RAG)
 * - Action tools (rename, retype, etc.)
 */
public class NativeToolManager implements ToolProvider {

    private static final String PROVIDER_NAME = "native";

    private final List<ToolProvider> nativeProviders = new ArrayList<>();
    private final GhidraToolProvider ghidraToolProvider;
    private final ActionToolProvider actionToolProvider;
    private Program currentProgram;
    private Address currentAddress;

    /**
     * Create a NativeToolManager with the given AnalysisDB.
     * @param analysisDB Database for semantic tools
     */
    public NativeToolManager(AnalysisDB analysisDB) {
        // Create providers that need address context
        this.ghidraToolProvider = new GhidraToolProvider();
        this.actionToolProvider = new ActionToolProvider();

        // Register native tool providers
        nativeProviders.add(ghidraToolProvider);
        nativeProviders.add(new SemanticToolProvider(analysisDB));
        nativeProviders.add(actionToolProvider);

        Msg.info(this, "NativeToolManager initialized with " + nativeProviders.size() + " providers");
    }

    @Override
    public String getProviderName() {
        return PROVIDER_NAME;
    }

    @Override
    public List<Tool> getTools() {
        return nativeProviders.stream()
                .flatMap(p -> p.getTools().stream())
                .collect(Collectors.toList());
    }

    @Override
    public CompletableFuture<ToolResult> executeTool(String name, JsonObject args) {
        for (ToolProvider provider : nativeProviders) {
            if (provider.handlesTool(name)) {
                Msg.debug(this, "Executing native tool '" + name + "' via " + provider.getProviderName());
                return provider.executeTool(name, args);
            }
        }
        return CompletableFuture.completedFuture(
                ToolResult.error("Native tool not found: " + name));
    }

    @Override
    public boolean handlesTool(String name) {
        return nativeProviders.stream().anyMatch(p -> p.handlesTool(name));
    }

    @Override
    public void setContext(Program program) {
        this.currentProgram = program;
        for (ToolProvider provider : nativeProviders) {
            provider.setContext(program);
        }
        // Also propagate address context to providers that need it
        if (currentAddress != null) {
            ghidraToolProvider.setAddress(currentAddress);
            actionToolProvider.setAddress(currentAddress);
        }
        Msg.debug(this, "Updated program context for " + nativeProviders.size() + " native providers");
    }

    /**
     * Set the current address context for tools that need it.
     * @param address Current cursor address in Ghidra
     */
    public void setAddress(Address address) {
        this.currentAddress = address;
        ghidraToolProvider.setAddress(address);
        actionToolProvider.setAddress(address);
        Msg.debug(this, "Updated address context: " + (address != null ? address.toString() : "null"));
    }

    /**
     * Set both program and address context.
     * @param program Current program
     * @param address Current cursor address
     */
    public void setFullContext(Program program, Address address) {
        this.currentProgram = program;
        this.currentAddress = address;
        for (ToolProvider provider : nativeProviders) {
            provider.setContext(program);
        }
        ghidraToolProvider.setContext(program, address);
        actionToolProvider.setContext(program, address);
        Msg.debug(this, "Updated full context: program=" +
                (program != null ? program.getName() : "null") +
                ", address=" + (address != null ? address.toString() : "null"));
    }

    /**
     * Get the current program context.
     */
    public Program getCurrentProgram() {
        return currentProgram;
    }

    /**
     * Get the current address context.
     */
    public Address getCurrentAddress() {
        return currentAddress;
    }

    /**
     * Get all registered native providers.
     */
    public List<ToolProvider> getNativeProviders() {
        return new ArrayList<>(nativeProviders);
    }

    /**
     * Get tool count by provider.
     */
    public String getSummary() {
        StringBuilder sb = new StringBuilder();
        sb.append("NativeToolManager: ").append(getTools().size()).append(" total tools\n");
        for (ToolProvider provider : nativeProviders) {
            sb.append("  - ").append(provider.getProviderName())
              .append(": ").append(provider.getTools().size()).append(" tools\n");
        }
        return sb.toString();
    }
}

```

`src/main/java/ghidrassist/tools/native_/SemanticToolProvider.java`:

```java
package ghidrassist.tools.native_;

import com.google.gson.JsonObject;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import ghidrassist.AnalysisDB;
import ghidrassist.graphrag.query.SemanticQueryTools;
import ghidrassist.mcp2.tools.MCPTool;
import ghidrassist.mcp2.tools.MCPToolResult;
import ghidrassist.tools.api.Tool;
import ghidrassist.tools.api.ToolProvider;
import ghidrassist.tools.api.ToolResult;

import java.util.Collections;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * Tool provider for Graph-RAG semantic query tools.
 * Wraps SemanticQueryTools to provide LLM-free semantic analysis capabilities.
 *
 * Tools provided:
 * - get_semantic_analysis: Get pre-computed semantic analysis for a function
 * - get_similar_functions: Find similar functions based on graph structure
 * - get_call_context: Get caller/callee context with semantic summaries
 * - get_security_analysis: Get security analysis for function or binary
 * - search_semantic: Search for functions by semantic keywords
 * - get_module_summary: Get community/module summary
 */
public class SemanticToolProvider implements ToolProvider {

    private static final String PROVIDER_NAME = "GraphRAG-Semantic";

    private final SemanticQueryTools queryTools;

    /**
     * Create a SemanticToolProvider with the given AnalysisDB.
     * @param analysisDB Database containing the knowledge graph
     */
    public SemanticToolProvider(AnalysisDB analysisDB) {
        this.queryTools = new SemanticQueryTools(analysisDB);
        Msg.info(this, "SemanticToolProvider initialized");
    }

    @Override
    public String getProviderName() {
        return PROVIDER_NAME;
    }

    @Override
    public List<Tool> getTools() {
        if (!queryTools.isAvailable()) {
            Msg.debug(this, "Semantic tools not available (no program context)");
            return Collections.emptyList();
        }

        List<MCPTool> mcpTools = queryTools.getToolDefinitions();
        Msg.debug(this, "Returning " + mcpTools.size() + " semantic tools");

        return mcpTools.stream()
                .map(mcp -> new NativeTool(mcp, PROVIDER_NAME))
                .collect(Collectors.toList());
    }

    @Override
    public CompletableFuture<ToolResult> executeTool(String name, JsonObject args) {
        Msg.info(this, "Executing semantic tool: " + name);

        return queryTools.executeTool(name, args)
                .thenApply(mcpResult -> {
                    if (!mcpResult.isSuccess()) {
                        Msg.debug(this, "Tool " + name + " returned error: " + mcpResult.getError());
                        return ToolResult.error(mcpResult.getError());
                    } else {
                        Msg.debug(this, "Tool " + name + " succeeded");
                        return ToolResult.success(mcpResult.getContent());
                    }
                });
    }

    @Override
    public boolean handlesTool(String name) {
        return queryTools.handlesTool(name);
    }

    @Override
    public void setContext(Program program) {
        queryTools.setCurrentProgram(program);
        if (program != null) {
            Msg.debug(this, "Set program context: " + program.getName());
        } else {
            Msg.debug(this, "Cleared program context");
        }
    }

    /**
     * Check if tools are available (requires program context).
     */
    public boolean isAvailable() {
        return queryTools.isAvailable();
    }
}

```

`src/main/java/ghidrassist/tools/registry/ToolRegistry.java`:

```java
package ghidrassist.tools.registry;

import com.google.gson.JsonObject;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import ghidrassist.tools.api.Tool;
import ghidrassist.tools.api.ToolExecutor;
import ghidrassist.tools.api.ToolProvider;
import ghidrassist.tools.api.ToolResult;
import ghidrassist.tools.native_.NativeToolManager;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * Central registry that aggregates tools from all providers.
 * Provides unified access to tools regardless of their source.
 *
 * Usage:
 *   ToolRegistry registry = new ToolRegistry();
 *   registry.registerProvider(new NativeToolManager(db));
 *   registry.registerProvider(new MCPToolManager(mcpRegistry));
 *
 *   List<Tool> allTools = registry.getAllTools();
 *   ToolResult result = registry.execute("get_semantic_analysis", args).join();
 */
public class ToolRegistry implements ToolExecutor {

    private final List<ToolProvider> providers = new ArrayList<>();
    private Program currentProgram;
    private Address currentAddress;

    /**
     * Register a tool provider.
     * @param provider The provider to register
     */
    public void registerProvider(ToolProvider provider) {
        if (provider != null) {
            providers.add(provider);
            // Set current program context if we have one
            if (currentProgram != null) {
                provider.setContext(currentProgram);
            }
            Msg.info(this, "Registered tool provider: " + provider.getProviderName() +
                    " with " + provider.getTools().size() + " tools");
        }
    }

    /**
     * Unregister a tool provider.
     * @param provider The provider to unregister
     */
    public void unregisterProvider(ToolProvider provider) {
        providers.remove(provider);
    }

    /**
     * Check if a provider with the given name is already registered.
     * @param providerName Name of the provider
     * @return true if a provider with this name is registered
     */
    public boolean hasProvider(String providerName) {
        return providers.stream().anyMatch(p -> p.getProviderName().equals(providerName));
    }

    /**
     * Get all registered providers.
     * @return List of providers
     */
    public List<ToolProvider> getProviders() {
        return new ArrayList<>(providers);
    }

    @Override
    public List<Tool> getAllTools() {
        return providers.stream()
                .flatMap(p -> p.getTools().stream())
                .collect(Collectors.toList());
    }

    /**
     * Get tools from a specific provider.
     * @param providerName Name of the provider
     * @return List of tools from that provider
     */
    public List<Tool> getToolsByProvider(String providerName) {
        return providers.stream()
                .filter(p -> p.getProviderName().equals(providerName))
                .flatMap(p -> p.getTools().stream())
                .collect(Collectors.toList());
    }

    /**
     * Find a tool by name across all providers.
     * @param toolName Tool name
     * @return The tool, or null if not found
     */
    public Tool getTool(String toolName) {
        for (ToolProvider provider : providers) {
            for (Tool tool : provider.getTools()) {
                if (tool.getName().equals(toolName)) {
                    return tool;
                }
            }
        }
        return null;
    }

    /**
     * Check if any provider handles the given tool.
     * @param toolName Tool name
     * @return true if a provider can handle the tool
     */
    public boolean handlesTool(String toolName) {
        return providers.stream().anyMatch(p -> p.handlesTool(toolName));
    }

    @Override
    public CompletableFuture<ToolResult> execute(String toolName, JsonObject args) {
        for (ToolProvider provider : providers) {
            if (provider.handlesTool(toolName)) {
                Msg.debug(this, "Routing tool '" + toolName + "' to provider: " + provider.getProviderName());
                return provider.executeTool(toolName, args);
            }
        }

        Msg.warn(this, "No provider found for tool: " + toolName);
        return CompletableFuture.completedFuture(
                ToolResult.error("Unknown tool: " + toolName));
    }

    /**
     * Set the Ghidra program context for all providers.
     * @param program Current Ghidra program
     */
    public void setContext(Program program) {
        this.currentProgram = program;
        for (ToolProvider provider : providers) {
            provider.setContext(program);
            // Also set address if we have one
            if (currentAddress != null && provider instanceof NativeToolManager) {
                ((NativeToolManager) provider).setAddress(currentAddress);
            }
        }
        Msg.debug(this, "Updated program context for " + providers.size() + " providers");
    }

    /**
     * Set the current address context for tools that need it.
     * @param address Current cursor address in Ghidra
     */
    public void setAddress(Address address) {
        this.currentAddress = address;
        for (ToolProvider provider : providers) {
            if (provider instanceof NativeToolManager) {
                ((NativeToolManager) provider).setAddress(address);
            }
        }
        Msg.debug(this, "Updated address context: " + (address != null ? address.toString() : "null"));
    }

    /**
     * Set both program and address context.
     * @param program Current Ghidra program
     * @param address Current cursor address
     */
    public void setFullContext(Program program, Address address) {
        this.currentProgram = program;
        this.currentAddress = address;
        for (ToolProvider provider : providers) {
            provider.setContext(program);
            if (provider instanceof NativeToolManager) {
                ((NativeToolManager) provider).setFullContext(program, address);
            }
        }
        Msg.debug(this, "Updated full context for " + providers.size() + " providers");
    }

    /**
     * Get the current program context.
     * @return Current program or null
     */
    public Program getCurrentProgram() {
        return currentProgram;
    }

    /**
     * Get the current address context.
     * @return Current address or null
     */
    public Address getCurrentAddress() {
        return currentAddress;
    }

    /**
     * Get tool count summary.
     * @return Summary string
     */
    public String getSummary() {
        StringBuilder sb = new StringBuilder();
        sb.append("ToolRegistry: ").append(getAllTools().size()).append(" total tools\n");
        for (ToolProvider provider : providers) {
            sb.append("  - ").append(provider.getProviderName())
              .append(": ").append(provider.getTools().size()).append(" tools\n");
        }
        return sb.toString();
    }

    /**
     * Get all tools as function definitions for LLM function calling.
     * This converts Tool objects to the Map format expected by LLM providers.
     * Deduplicates tools by name (first registration wins).
     * @return List of function definitions
     */
    public List<Map<String, Object>> getToolsAsFunction() {
        // Deduplicate by tool name - first registration wins
        Map<String, Tool> uniqueTools = new java.util.LinkedHashMap<>();
        for (Tool tool : getAllTools()) {
            if (!uniqueTools.containsKey(tool.getName())) {
                uniqueTools.put(tool.getName(), tool);
            } else {
                Msg.debug(this, "Skipping duplicate tool: " + tool.getName() +
                        " (already registered from another provider)");
            }
        }

        return uniqueTools.values().stream()
                .map(this::toolToFunctionSchema)
                .collect(Collectors.toList());
    }

    /**
     * Convert a Tool to function calling schema format.
     */
    private Map<String, Object> toolToFunctionSchema(Tool tool) {
        Map<String, Object> function = new HashMap<>();
        function.put("type", "function");

        Map<String, Object> functionDef = new HashMap<>();
        functionDef.put("name", tool.getName());
        functionDef.put("description", tool.getDescription());

        // Convert JsonObject to Map for parameters
        JsonObject inputSchema = tool.getInputSchema();
        if (inputSchema != null) {
            functionDef.put("parameters", jsonObjectToMap(inputSchema));
        } else {
            // Default empty parameters
            Map<String, Object> emptyParams = new HashMap<>();
            emptyParams.put("type", "object");
            emptyParams.put("properties", new HashMap<>());
            functionDef.put("parameters", emptyParams);
        }

        function.put("function", functionDef);
        return function;
    }

    /**
     * Convert JsonObject to Map for function schema.
     */
    private Map<String, Object> jsonObjectToMap(JsonObject json) {
        Map<String, Object> map = new HashMap<>();
        for (String key : json.keySet()) {
            map.put(key, jsonElementToObject(json.get(key)));
        }
        return map;
    }

    /**
     * Convert JsonElement to appropriate Java object.
     */
    private Object jsonElementToObject(com.google.gson.JsonElement element) {
        if (element == null || element.isJsonNull()) {
            return null;
        } else if (element.isJsonPrimitive()) {
            com.google.gson.JsonPrimitive primitive = element.getAsJsonPrimitive();
            if (primitive.isBoolean()) {
                return primitive.getAsBoolean();
            } else if (primitive.isNumber()) {
                return primitive.getAsNumber();
            } else {
                return primitive.getAsString();
            }
        } else if (element.isJsonArray()) {
            List<Object> list = new ArrayList<>();
            for (com.google.gson.JsonElement e : element.getAsJsonArray()) {
                list.add(jsonElementToObject(e));
            }
            return list;
        } else if (element.isJsonObject()) {
            return jsonObjectToMap(element.getAsJsonObject());
        }
        return element.toString();
    }
}

```

`src/main/java/ghidrassist/ui/EnhancedErrorDialog.java`:

```java
package ghidrassist.ui;

import ghidrassist.apiprovider.ErrorAction;
import ghidrassist.apiprovider.ErrorMessageBuilder;
import ghidrassist.apiprovider.exceptions.APIProviderException;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.List;

/**
 * Enhanced error dialog that provides better error reporting and action options
 */
public class EnhancedErrorDialog extends JDialog {
    private static final long serialVersionUID = 1L;

    private final APIProviderException exception;
    private final List<ErrorAction> actions;
    private boolean detailsVisible = false;
    
    public EnhancedErrorDialog(Window parent, APIProviderException exception, List<ErrorAction> actions) {
        super(parent, "Error", ModalityType.APPLICATION_MODAL);
        this.exception = exception;
        this.actions = actions;
        
        initializeDialog();
        buildComponents();
        pack();
        setLocationRelativeTo(parent);
    }
    
    private void initializeDialog() {
        setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
        setResizable(true);
        
        // Set appropriate icon based on error category
        ImageIcon icon = getErrorIcon();
        if (icon != null) {
            setIconImage(icon.getImage());
        }
    }
    
    private void buildComponents() {
        setLayout(new BorderLayout());
        
        // Main content panel
        JPanel contentPanel = new JPanel(new BorderLayout());
        contentPanel.setBorder(new EmptyBorder(16, 16, 16, 16));
        
        // Header with icon and title
        JPanel headerPanel = createHeaderPanel();
        contentPanel.add(headerPanel, BorderLayout.NORTH);
        
        // Message panel
        JPanel messagePanel = createMessagePanel();
        contentPanel.add(messagePanel, BorderLayout.CENTER);
        
        // Details panel (initially hidden)
        JPanel detailsPanel = createDetailsPanel();
        contentPanel.add(detailsPanel, BorderLayout.SOUTH);
        
        add(contentPanel, BorderLayout.CENTER);
        
        // Button panel
        JPanel buttonPanel = createButtonPanel();
        add(buttonPanel, BorderLayout.SOUTH);
    }
    
    private JPanel createHeaderPanel() {
        JPanel panel = new JPanel(new BorderLayout());
        panel.setBorder(new EmptyBorder(0, 0, 16, 0));
        
        // Error icon
        JLabel iconLabel = new JLabel(getErrorIcon());
        iconLabel.setBorder(new EmptyBorder(0, 0, 0, 16));
        panel.add(iconLabel, BorderLayout.WEST);
        
        // Title and category
        JPanel titlePanel = new JPanel(new BorderLayout());
        
        JLabel titleLabel = new JLabel(exception.getCategory().getDisplayName());
        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD, 16f));
        titlePanel.add(titleLabel, BorderLayout.NORTH);
        
        JLabel categoryLabel = new JLabel(exception.getCategory().getDescription());
        categoryLabel.setFont(categoryLabel.getFont().deriveFont(Font.ITALIC, 12f));
        categoryLabel.setForeground(Color.GRAY);
        titlePanel.add(categoryLabel, BorderLayout.SOUTH);
        
        panel.add(titlePanel, BorderLayout.CENTER);
        
        return panel;
    }
    
    private JPanel createMessagePanel() {
        JPanel panel = new JPanel(new BorderLayout());
        
        // User-friendly message
        String userMessage = ErrorMessageBuilder.buildUserMessage(exception);
        JTextArea messageArea = new JTextArea(userMessage);
        messageArea.setEditable(false);
        messageArea.setOpaque(false);
        messageArea.setWrapStyleWord(true);
        messageArea.setLineWrap(true);
        messageArea.setFont(messageArea.getFont().deriveFont(13f));
        
        // Set preferred size based on content
        messageArea.setColumns(50);
        messageArea.setRows(Math.min(6, userMessage.split("\n").length + 1));
        
        panel.add(messageArea, BorderLayout.CENTER);
        
        return panel;
    }
    
    private JPanel createDetailsPanel() {
        JPanel panel = new JPanel(new BorderLayout());
        panel.setBorder(new EmptyBorder(16, 0, 0, 0));
        
        // Details toggle button
        JButton toggleButton = new JButton("Show Details");
        toggleButton.addActionListener(e -> toggleDetails(toggleButton, panel));
        
        JPanel togglePanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        togglePanel.add(toggleButton);
        panel.add(togglePanel, BorderLayout.NORTH);
        
        return panel;
    }
    
    private void toggleDetails(JButton toggleButton, JPanel detailsPanel) {
        detailsVisible = !detailsVisible;
        
        if (detailsVisible) {
            // Show details
            toggleButton.setText("Hide Details");
            
            JTextArea detailsArea = new JTextArea(exception.getTechnicalDetails());
            detailsArea.setEditable(false);
            detailsArea.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 11));
            detailsArea.setBackground(getBackground());
            detailsArea.setBorder(new EmptyBorder(8, 0, 0, 0));
            
            JScrollPane scrollPane = new JScrollPane(detailsArea);
            scrollPane.setPreferredSize(new Dimension(500, 150));
            scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
            scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
            
            detailsPanel.add(scrollPane, BorderLayout.CENTER);
        } else {
            // Hide details
            toggleButton.setText("Show Details");
            
            // Remove details component
            Component[] components = detailsPanel.getComponents();
            for (Component comp : components) {
                if (comp instanceof JScrollPane) {
                    detailsPanel.remove(comp);
                }
            }
        }
        
        pack();
        repaint();
    }
    
    private JPanel createButtonPanel() {
        JPanel panel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        panel.setBorder(new EmptyBorder(16, 16, 16, 16));
        
        // Add action buttons
        if (actions != null && !actions.isEmpty()) {
            // Add primary actions first
            for (ErrorAction action : actions) {
                if (action.isPrimary()) {
                    JButton button = action.createButton();
                    button.addActionListener(e -> dispose()); // Close dialog after action
                    panel.add(button);
                }
            }
            
            // Add secondary actions
            for (ErrorAction action : actions) {
                if (!action.isPrimary()) {
                    JButton button = action.createButton();
                    if (!action.getActionText().equals("Dismiss")) {
                        button.addActionListener(e -> dispose()); // Close dialog after action
                    } else {
                        button.addActionListener(e -> dispose()); // Just close for dismiss
                    }
                    panel.add(button);
                }
            }
        } else {
            // Default close button
            JButton closeButton = new JButton("Close");
            closeButton.addActionListener(e -> dispose());
            panel.add(closeButton);
        }
        
        return panel;
    }
    
    private ImageIcon getErrorIcon() {
        switch (exception.getCategory()) {
            case AUTHENTICATION:
                return createColoredIcon(Color.RED);
            case NETWORK:
                return createColoredIcon(Color.ORANGE);
            case RATE_LIMIT:
                return createColoredIcon(Color.YELLOW);
            case MODEL_ERROR:
                return createColoredIcon(Color.MAGENTA);
            case CONFIGURATION:
                return createColoredIcon(Color.BLUE);
            case RESPONSE_ERROR:
                return createColoredIcon(Color.CYAN);
            case SERVICE_ERROR:
                return createColoredIcon(Color.RED);
            case TIMEOUT:
                return createColoredIcon(Color.ORANGE);
            case CANCELLED:
                return createColoredIcon(Color.GRAY);
            default:
                return createColoredIcon(Color.RED);
        }
    }
    
    private ImageIcon createColoredIcon(Color color) {
        // Create a simple colored circle icon
        int size = 32;
        java.awt.image.BufferedImage image = new java.awt.image.BufferedImage(
            size, size, java.awt.image.BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2 = image.createGraphics();
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g2.setColor(color);
        g2.fillOval(2, 2, size - 4, size - 4);
        g2.setColor(Color.WHITE);
        g2.setFont(new Font(Font.SANS_SERIF, Font.BOLD, 18));
        FontMetrics fm = g2.getFontMetrics();
        String text = "!";
        int x = (size - fm.stringWidth(text)) / 2;
        int y = (size - fm.getHeight()) / 2 + fm.getAscent();
        g2.drawString(text, x, y);
        g2.dispose();
        
        return new ImageIcon(image);
    }
    
    /**
     * Show an enhanced error dialog for an API provider exception
     */
    public static void showError(Window parent, APIProviderException exception, List<ErrorAction> actions) {
        SwingUtilities.invokeLater(() -> {
            EnhancedErrorDialog dialog = new EnhancedErrorDialog(parent, exception, actions);
            dialog.setVisible(true);
        });
    }
}
```

`src/main/java/ghidrassist/ui/GhidrAssistUI.java`:

```java
package ghidrassist.ui;

import javax.swing.*;

import ghidra.framework.preferences.Preferences;
import ghidra.program.util.ProgramLocation;

import java.awt.*;
import ghidrassist.GhidrAssistPlugin;
import ghidrassist.ui.tabs.*;
import ghidrassist.core.TabController;
import ghidrassist.ui.common.UIConstants;

public class GhidrAssistUI extends JPanel {
    private static final long serialVersionUID = 1L;

    public static boolean isSymGraphEnabled() {
        return Boolean.parseBoolean(Preferences.getProperty("GhidrAssist.SymGraph", "false"));
    }

	private final GhidrAssistPlugin plugin;
    private final TabController controller;
    private final JTabbedPane tabbedPane;
    private final ExplainTab explainTab;
    private final QueryTab queryTab;
    private final ActionsTab actionsTab;
    private final RAGManagementTab ragManagementTab;
    private final SettingsTab settingsTab;
    private final SemanticGraphTab semanticGraphTab;
    private SymGraphTab symGraphTab;

    public GhidrAssistUI(GhidrAssistPlugin plugin) {
        super(new BorderLayout());
        this.plugin = plugin;
        this.controller = new TabController(plugin);

        // Initialize components
        this.tabbedPane = new JTabbedPane();

        // Create tabs
        this.explainTab = new ExplainTab(controller);
        this.queryTab = new QueryTab(controller);
        this.actionsTab = new ActionsTab(controller);
        this.ragManagementTab = new RAGManagementTab(controller);
        this.settingsTab = new SettingsTab(controller);
        this.semanticGraphTab = new SemanticGraphTab(controller);
        if (isSymGraphEnabled()) {
            this.symGraphTab = new SymGraphTab(controller);
        }

        // Set tab references in controller
        controller.setExplainTab(explainTab);
        controller.setQueryTab(queryTab);
        controller.setActionsTab(actionsTab);
        controller.setRAGManagementTab(ragManagementTab);
        controller.setSettingsTab(settingsTab);
        controller.setSemanticGraphTab(semanticGraphTab);
        if (symGraphTab != null) {
            controller.setSymGraphTab(symGraphTab);
        }

        initializeUI();
    }

    private void initializeUI() {
        setBorder(UIConstants.PANEL_BORDER);

        // Add tabs
        tabbedPane.addTab("Explain", explainTab);
        tabbedPane.addTab("Query", queryTab);
        tabbedPane.addTab("Actions", actionsTab);
        tabbedPane.addTab("Semantic Graph", semanticGraphTab);
        if (symGraphTab != null) {
            tabbedPane.addTab("SymGraph", symGraphTab);
        }
        tabbedPane.addTab("RAG", ragManagementTab);
        tabbedPane.addTab("Settings", settingsTab);

        add(tabbedPane, BorderLayout.CENTER);

        // Initialize tabs that need startup data
        SwingUtilities.invokeLater(() -> {
            // Load initial context
            controller.handleContextLoad();

            // Load RAG file list
            controller.refreshRAGDocuments();
        });

        tabbedPane.addChangeListener(e -> {
            if (tabbedPane.getSelectedComponent() == settingsTab) {
                // Load current context when Settings tab is selected
                controller.handleContextLoad();
            } else if (symGraphTab != null && tabbedPane.getSelectedComponent() == symGraphTab) {
                // Update binary info when SymGraph tab is selected
                controller.updateSymGraphBinaryInfo();
            }
        });
    }

    public void updateLocation(ProgramLocation loc) {
        if (loc != null && loc.getAddress() != null) {
            explainTab.updateOffset(loc.getAddress().toString());
            controller.updateAnalysis(loc);
            controller.updateSemanticGraphLocation(loc);
            controller.handleLocationUpdate(loc);  // Update line explanation display
        }
    }

    public JComponent getComponent() {
        return this;
    }

    public GhidrAssistPlugin getPlugin() {
        return plugin;
    }
}
```

`src/main/java/ghidrassist/ui/common/PlaceholderTextField.java`:

```java
package ghidrassist.ui.common;

import javax.swing.JTextField;
import java.awt.Color;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;

public class PlaceholderTextField extends JTextField {
    private boolean showingPlaceholder;
    private final String placeholder;
    private final Color placeholderColor;
    private final Color textColor;

    public PlaceholderTextField(String placeholder, int columns) {
        super(columns);
        this.placeholder = placeholder;
        this.showingPlaceholder = true;
        this.placeholderColor = UIConstants.PLACEHOLDER_COLOR;
        this.textColor = getForeground();
        
        setupPlaceholder();
    }

    private void setupPlaceholder() {
        setText(placeholder);
        setForeground(placeholderColor);

        addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                if (showingPlaceholder) {
                    showingPlaceholder = false;
                    setText("");
                    setForeground(textColor);
                }
            }

            @Override
            public void focusLost(FocusEvent e) {
                if (getText().isEmpty()) {
                    showingPlaceholder = true;
                    setText(placeholder);
                    setForeground(placeholderColor);
                }
            }
        });
    }

    @Override
    public String getText() {
        return showingPlaceholder ? "" : super.getText();
    }
}

```

`src/main/java/ghidrassist/ui/common/UIConstants.java`:

```java
package ghidrassist.ui.common;

import java.awt.Color;
import java.awt.Dimension;
import javax.swing.BorderFactory;
import javax.swing.border.Border;

public class UIConstants {
    public static final int PADDING = 5;
    public static final int BUTTON_SPACING = 5;
    public static final int TEXT_FIELD_COLUMNS = 20;
    public static final Dimension PREFERRED_BUTTON_SIZE = new Dimension(120, 30);
    public static final Border PANEL_BORDER = BorderFactory.createEmptyBorder(PADDING, PADDING, PADDING, PADDING);
    public static final Color PLACEHOLDER_COLOR = Color.GRAY;
}

```

`src/main/java/ghidrassist/ui/tabs/ActionsTab.java`:

```java
package ghidrassist.ui.tabs;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.JTableHeader;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Map;
import java.util.HashMap;
import ghidrassist.core.TabController;
import ghidrassist.core.ActionConstants;

public class ActionsTab extends JPanel {
    private static final long serialVersionUID = 1L;
	private final TabController controller;
    private JTable actionsTable;
    private Map<String, JCheckBox> filterCheckBoxes;
    private JButton analyzeFunctionButton;
    private JButton analyzeClearButton;
    private JButton applyActionsButton;
    private JCheckBox selectAllCheckBox;

    public ActionsTab(TabController controller) {
        super(new BorderLayout());
        this.controller = controller;
        initializeComponents();
        layoutComponents();
        setupListeners();
    }

    private void initializeComponents() {
        // Initialize select all checkbox
        selectAllCheckBox = new JCheckBox();

        // Initialize table
        actionsTable = createActionsTable();

        // Initialize filter checkboxes
        filterCheckBoxes = createFilterCheckboxes();

        // Initialize buttons
        analyzeFunctionButton = new JButton("Analyze Function");
        analyzeClearButton = new JButton("Clear");
        applyActionsButton = new JButton("Apply Actions");
    }

    private JTable createActionsTable() {
        DefaultTableModel model = new DefaultTableModel(
            new Object[]{"Select", "Action", "Description", "Status", "Arguments"}, 0) {
            private static final long serialVersionUID = 1L;

			@Override
            public Class<?> getColumnClass(int column) {
                return column == 0 ? Boolean.class : String.class;
            }
        };
        
        JTable table = new JTable(model);
        // Set a reasonable preferred width for the Select column while allowing it to be resizable
        table.getColumnModel().getColumn(0).setPreferredWidth(60);

        // Set up custom header renderer for the Select column
        setupSelectAllHeader(table);

        // Add table model listener to update header checkbox state when individual selections change
        model.addTableModelListener(e -> {
            // Only update for changes to the Select column (column 0)
            if (e.getColumn() == 0 || e.getColumn() == javax.swing.event.TableModelEvent.ALL_COLUMNS) {
                SwingUtilities.invokeLater(this::updateSelectAllCheckboxState);
            }
        });

        return table;
    }

    private Map<String, JCheckBox> createFilterCheckboxes() {
        Map<String, JCheckBox> checkboxes = new HashMap<>();
        for (Map<String, Object> fnTemplate : ActionConstants.FN_TEMPLATES) {
            if (fnTemplate.get("type").equals("function")) {
                @SuppressWarnings("unchecked")
                Map<String, Object> functionMap = (Map<String, Object>) fnTemplate.get("function");
                String fnName = functionMap.get("name").toString();
                String fnDescription = functionMap.get("description").toString();
                String checkboxLabel = fnName.replace("_", " ") + ": " + fnDescription;
                checkboxes.put(fnName, new JCheckBox(checkboxLabel, true));
            }
        }
        return checkboxes;
    }

    private void setupSelectAllHeader(JTable table) {
        // Create custom header renderer for the Select column
        TableCellRenderer headerRenderer = new TableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value,
                    boolean isSelected, boolean hasFocus, int row, int column) {
                if (column == 0) {
                    // Return checkbox for Select column header
                    selectAllCheckBox.setText("Select");
                    selectAllCheckBox.setHorizontalAlignment(SwingConstants.CENTER);
                    return selectAllCheckBox;
                } else {
                    // Use default renderer for other columns
                    return table.getTableHeader().getDefaultRenderer()
                        .getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
                }
            }
        };

        // Set the custom renderer for the Select column
        table.getColumnModel().getColumn(0).setHeaderRenderer(headerRenderer);

        // Add mouse listener to handle header checkbox clicks
        table.getTableHeader().addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                JTableHeader header = (JTableHeader) e.getSource();
                int columnIndex = header.columnAtPoint(e.getPoint());

                // Only handle clicks on the Select column
                if (columnIndex == 0) {
                    boolean currentState = selectAllCheckBox.isSelected();
                    selectAllCheckBox.setSelected(!currentState);
                    toggleAllRowSelections(!currentState);
                    header.repaint();
                }
            }
        });
    }

    private void toggleAllRowSelections(boolean selectAll) {
        DefaultTableModel model = (DefaultTableModel) actionsTable.getModel();
        for (int row = 0; row < model.getRowCount(); row++) {
            model.setValueAt(selectAll, row, 0);
        }
        actionsTable.repaint();
    }

    public void updateSelectAllCheckboxState() {
        DefaultTableModel model = (DefaultTableModel) actionsTable.getModel();
        if (model.getRowCount() == 0) {
            selectAllCheckBox.setSelected(false);
            return;
        }

        boolean allSelected = true;
        boolean noneSelected = true;

        for (int row = 0; row < model.getRowCount(); row++) {
            Boolean value = (Boolean) model.getValueAt(row, 0);
            boolean isSelected = value != null && value;

            if (!isSelected) {
                allSelected = false;
            } else {
                noneSelected = false;
            }
        }

        if (allSelected) {
            selectAllCheckBox.setSelected(true);
        } else if (noneSelected) {
            selectAllCheckBox.setSelected(false);
        } else {
            // Mixed state - we'll show as unselected but could be enhanced to show indeterminate state
            selectAllCheckBox.setSelected(false);
        }

        actionsTable.getTableHeader().repaint();
    }

    private void layoutComponents() {
        // Filter panel
        JPanel filterPanel = new JPanel();
        filterPanel.setLayout(new BoxLayout(filterPanel, BoxLayout.Y_AXIS));
        filterPanel.setBorder(BorderFactory.createTitledBorder("Filters"));
        filterCheckBoxes.values().forEach(filterPanel::add);
        
        JScrollPane filterScrollPane = new JScrollPane(filterPanel);
        filterScrollPane.setPreferredSize(new Dimension(200, 150));
        add(filterScrollPane, BorderLayout.NORTH);

        // Table
        add(new JScrollPane(actionsTable), BorderLayout.CENTER);

        // Buttons
        JPanel buttonPanel = new JPanel();
        buttonPanel.add(analyzeFunctionButton);
        buttonPanel.add(analyzeClearButton);
        buttonPanel.add(applyActionsButton);
        add(buttonPanel, BorderLayout.SOUTH);
    }

    private void setupListeners() {
        analyzeFunctionButton.addActionListener(e ->
            controller.handleAnalyzeFunction(filterCheckBoxes));
        analyzeClearButton.addActionListener(e -> {
            ((DefaultTableModel)actionsTable.getModel()).setRowCount(0);
            updateSelectAllCheckboxState();
        });
        applyActionsButton.addActionListener(e ->
            controller.handleApplyActions(actionsTable));
    }

    public DefaultTableModel getTableModel() {
        return (DefaultTableModel)actionsTable.getModel();
    }

    public void setAnalyzeFunctionButtonText(String text) {
        analyzeFunctionButton.setText(text);
    }
}

```

`src/main/java/ghidrassist/ui/tabs/ExplainTab.java`:

```java
package ghidrassist.ui.tabs;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import javax.swing.text.Element;
import javax.swing.text.html.HTML;
import javax.swing.text.html.HTMLDocument;
import javax.swing.text.html.HTMLEditorKit;
import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.util.List;
import ghidra.util.Msg;
import ghidrassist.core.MarkdownHelper;
import ghidrassist.core.TabController;
import ghidrassist.core.streaming.RenderUpdate;
import ghidrassist.core.streaming.StreamingScrollManager;

public class ExplainTab extends JPanel {
    private static final long serialVersionUID = 1L;
    private final TabController controller;
    private final MarkdownHelper markdownHelper;
    private JLabel offsetLabel;
    private JTextField offsetField;
    private JEditorPane explainTextPane;
    private JTextArea markdownTextArea;
    private JButton explainFunctionButton;
    private JButton explainLineButton;
    private JButton clearExplainButton;
    private JButton editSaveButton;
    private JPanel contentPanel;
    private CardLayout contentLayout;
    private boolean isEditMode = false;
    private String currentMarkdown = "";

    // Security info panel components
    private JPanel securityInfoPanel;
    private JLabel riskLevelLabel;
    private JLabel activityProfileLabel;
    private JLabel securityFlagsLabel;
    private JTextArea networkAPIsTextArea;
    private JTextArea fileIOAPIsTextArea;

    // Line explanation panel components
    private JPanel lineExplanationPanel;
    private JEditorPane lineExplanationTextPane;
    private String lineExplanationMarkdown = "";
    private JSplitPane mainSplitPane;
    private JButton lineExplanationCloseButton;

    // Streaming markdown rendering CSS (same as QueryTab)
    private static final String STREAMING_CSS =
        "body { font-family: sans-serif; font-size: 14px; margin: 8px; }" +
        "pre { background-color: #f4f4f4; padding: 8px; border: 1px solid #ddd; overflow-x: auto; }" +
        "code { background-color: #f4f4f4; padding: 2px 4px; }" +
        "table { border-collapse: collapse; margin: 8px 0; }" +
        "th, td { border: 1px solid #ddd; padding: 4px 8px; }" +
        "th { background-color: #f0f0f0; }" +
        "blockquote { border-left: 3px solid #ccc; margin-left: 0; padding-left: 12px; color: #555; }";

    // Streaming state for function explanation pane
    private StringBuilder accumulatedCommittedHtml = new StringBuilder();
    private String lastPendingHtml = "<span></span>";
    private boolean documentCorrupted = false;
    private StreamingScrollManager scrollManager;
    private JScrollPane explainScrollPane;

    // Streaming state for line explanation pane
    private StringBuilder lineAccumulatedCommittedHtml = new StringBuilder();
    private String lineLastPendingHtml = "<span></span>";
    private boolean lineDocumentCorrupted = false;
    private StreamingScrollManager lineScrollManager;
    private JScrollPane lineExplanationScrollPane;

    public ExplainTab(TabController controller) {
        super(new BorderLayout());
        this.controller = controller;
        this.markdownHelper = new MarkdownHelper();
        initializeComponents();
        layoutComponents();
        setupListeners();
        setupContextMenu();
    }

    private void initializeComponents() {
        // Initialize offset field
        offsetLabel = new JLabel("Offset: ");
        offsetField = new JTextField(16);
        offsetField.setEditable(false);

        // Initialize text pane for HTML viewing
        explainTextPane = new JEditorPane();
        explainTextPane.setEditable(false);
        explainTextPane.setContentType("text/html");
        explainTextPane.addHyperlinkListener(controller::handleHyperlinkEvent);

        // Initialize text area for Markdown editing
        markdownTextArea = new JTextArea();
        markdownTextArea.setFont(new Font("Monospaced", Font.PLAIN, 12));
        markdownTextArea.setLineWrap(true);
        markdownTextArea.setWrapStyleWord(true);

        // Initialize buttons
        explainFunctionButton = new JButton("Explain Function");
        explainLineButton = new JButton("Explain Line");
        explainLineButton.setEnabled(true);
        explainLineButton.setToolTipText("Explain the current line at cursor position");
        clearExplainButton = new JButton("Clear");
        editSaveButton = new JButton("Edit");

        // Setup card layout for switching between view and edit modes
        contentLayout = new CardLayout();
        contentPanel = new JPanel(contentLayout);
        explainScrollPane = new JScrollPane(explainTextPane);
        explainScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
        scrollManager = new StreamingScrollManager(explainScrollPane);
        contentPanel.add(explainScrollPane, "view");
        contentPanel.add(new JScrollPane(markdownTextArea), "edit");

        // Initialize security info panel
        securityInfoPanel = new JPanel();
        securityInfoPanel.setLayout(new BoxLayout(securityInfoPanel, BoxLayout.Y_AXIS));
        securityInfoPanel.setBorder(BorderFactory.createTitledBorder(
                BorderFactory.createEtchedBorder(), "Security Analysis",
                TitledBorder.LEFT, TitledBorder.TOP));

        // Risk level and activity profile row
        JPanel topRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 2));
        riskLevelLabel = new JLabel("Risk: —");
        riskLevelLabel.setFont(riskLevelLabel.getFont().deriveFont(Font.BOLD));
        activityProfileLabel = new JLabel("Activity: —");
        topRow.add(riskLevelLabel);
        topRow.add(activityProfileLabel);
        securityInfoPanel.add(topRow);

        // Security flags row
        JPanel flagsRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 2));
        securityFlagsLabel = new JLabel("Flags: None");
        flagsRow.add(securityFlagsLabel);
        securityInfoPanel.add(flagsRow);

        // API lists in a horizontal panel
        JPanel apiPanel = new JPanel(new GridLayout(1, 2, 10, 0));

        // Network APIs
        JPanel networkPanel = new JPanel(new BorderLayout());
        networkPanel.setBorder(BorderFactory.createTitledBorder("Network APIs"));
        networkAPIsTextArea = new JTextArea(3, 20);
        networkAPIsTextArea.setEditable(false);
        networkAPIsTextArea.setFont(new Font("Monospaced", Font.PLAIN, 11));
        networkPanel.add(new JScrollPane(networkAPIsTextArea), BorderLayout.CENTER);
        apiPanel.add(networkPanel);

        // File I/O APIs
        JPanel filePanel = new JPanel(new BorderLayout());
        filePanel.setBorder(BorderFactory.createTitledBorder("File I/O APIs"));
        fileIOAPIsTextArea = new JTextArea(3, 20);
        fileIOAPIsTextArea.setEditable(false);
        fileIOAPIsTextArea.setFont(new Font("Monospaced", Font.PLAIN, 11));
        filePanel.add(new JScrollPane(fileIOAPIsTextArea), BorderLayout.CENTER);
        apiPanel.add(filePanel);

        securityInfoPanel.add(apiPanel);

        // Initially hide the security panel until we have data
        securityInfoPanel.setVisible(false);

        // Initialize line explanation panel with header containing close button
        lineExplanationPanel = new JPanel(new BorderLayout());
        lineExplanationPanel.setBorder(BorderFactory.createEtchedBorder());

        // Create header panel with title and close button
        JPanel lineHeaderPanel = new JPanel(new BorderLayout());
        lineHeaderPanel.setBorder(BorderFactory.createEmptyBorder(2, 5, 2, 2));
        JLabel lineHeaderLabel = new JLabel("Line Explanation");
        lineHeaderLabel.setFont(lineHeaderLabel.getFont().deriveFont(Font.BOLD));
        lineHeaderPanel.add(lineHeaderLabel, BorderLayout.WEST);

        // Close button (small X)
        lineExplanationCloseButton = new JButton("\u00D7"); // Unicode multiplication sign as X
        lineExplanationCloseButton.setMargin(new Insets(0, 4, 0, 4));
        lineExplanationCloseButton.setFont(lineExplanationCloseButton.getFont().deriveFont(Font.BOLD, 14f));
        lineExplanationCloseButton.setFocusPainted(false);
        lineExplanationCloseButton.setBorderPainted(false);
        lineExplanationCloseButton.setContentAreaFilled(false);
        lineExplanationCloseButton.setToolTipText("Hide line explanation");
        lineExplanationCloseButton.addActionListener(e -> clearLineExplanation());
        lineHeaderPanel.add(lineExplanationCloseButton, BorderLayout.EAST);

        lineExplanationPanel.add(lineHeaderPanel, BorderLayout.NORTH);

        lineExplanationTextPane = new JEditorPane();
        lineExplanationTextPane.setEditable(false);
        lineExplanationTextPane.setContentType("text/html");
        lineExplanationTextPane.addHyperlinkListener(controller::handleHyperlinkEvent);

        lineExplanationScrollPane = new JScrollPane(lineExplanationTextPane);
        lineExplanationScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
        lineExplanationScrollPane.setPreferredSize(new Dimension(0, 150));
        lineExplanationScrollPane.setMinimumSize(new Dimension(0, 80));
        lineScrollManager = new StreamingScrollManager(lineExplanationScrollPane);
        lineExplanationPanel.add(lineExplanationScrollPane, BorderLayout.CENTER);

        // Set preferred/minimum sizes for the panel
        lineExplanationPanel.setPreferredSize(new Dimension(0, 180));
        lineExplanationPanel.setMinimumSize(new Dimension(0, 100));

        // Initially hide the line explanation panel
        lineExplanationPanel.setVisible(false);
    }

    private void layoutComponents() {
        // Offset and Edit/Save panel
        JPanel topPanel = new JPanel(new BorderLayout());

        JPanel offsetPanel = new JPanel();
        offsetPanel.add(offsetLabel);
        offsetPanel.add(offsetField);
        topPanel.add(offsetPanel, BorderLayout.WEST);

        JPanel editPanel = new JPanel();
        editPanel.add(editSaveButton);
        topPanel.add(editPanel, BorderLayout.EAST);

        add(topPanel, BorderLayout.NORTH);

        // Create split pane with function explanation (top) and line explanation (bottom)
        mainSplitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
        mainSplitPane.setTopComponent(contentPanel);
        mainSplitPane.setBottomComponent(lineExplanationPanel);
        mainSplitPane.setResizeWeight(1.0); // Give all extra space to top component
        mainSplitPane.setOneTouchExpandable(true);
        mainSplitPane.setContinuousLayout(true);

        // Initially hide bottom component (line explanation)
        mainSplitPane.setDividerSize(0);
        mainSplitPane.setBottomComponent(null);

        add(mainSplitPane, BorderLayout.CENTER);

        // Bottom panel containing security info + buttons
        JPanel bottomPanel = new JPanel();
        bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.Y_AXIS));

        // Security info panel
        bottomPanel.add(securityInfoPanel);

        // Button panel
        JPanel buttonPanel = new JPanel();
        buttonPanel.add(explainFunctionButton);
        buttonPanel.add(explainLineButton);
        buttonPanel.add(clearExplainButton);
        bottomPanel.add(buttonPanel);

        add(bottomPanel, BorderLayout.SOUTH);
    }

    private void setupListeners() {
        explainFunctionButton.addActionListener(e -> controller.handleExplainFunction());
        explainLineButton.addActionListener(e -> controller.handleExplainLine());
        clearExplainButton.addActionListener(e -> {
            // Clear the UI
            explainTextPane.setText("");
            markdownTextArea.setText("");
            currentMarkdown = "";
            
            // Also clear from database
            controller.handleClearAnalysisData();
        });
        
        editSaveButton.addActionListener(e -> {
            if (isEditMode) {
                // Save mode - save the markdown and switch to view mode
                currentMarkdown = markdownTextArea.getText();
                String html = markdownHelper.markdownToHtml(currentMarkdown);
                explainTextPane.setText(html);
                
                // Save to database
                controller.handleUpdateAnalysis(currentMarkdown);
                
                // Switch to view mode
                contentLayout.show(contentPanel, "view");
                editSaveButton.setText("Edit");
                isEditMode = false;
            } else {
                // Edit mode - switch to the markdown editor
                markdownTextArea.setText(currentMarkdown);
                
                // Switch to edit mode
                contentLayout.show(contentPanel, "edit");
                editSaveButton.setText("Save");
                isEditMode = true;
            }
        });
    }

    public void updateOffset(String offset) {
        offsetField.setText(offset);
    }

    public void setExplanationText(String text) {
        explainTextPane.setText(text);
        explainTextPane.setCaretPosition(0);
        
        // Store the markdown equivalent
        currentMarkdown = markdownHelper.extractMarkdownFromLlmResponse(text);
        
        // If we're in edit mode, update the markdown text area too
        if (isEditMode) {
            markdownTextArea.setText(currentMarkdown);
        }
        
        // Switch to view mode if we're setting new content
        if (isEditMode) {
            contentLayout.show(contentPanel, "view");
            editSaveButton.setText("Edit");
            isEditMode = false;
        }
    }

    public void setFunctionButtonText(String text) {
        explainFunctionButton.setText(text);
    }

    public void setLineButtonText(String text) {
        explainLineButton.setText(text);
    }

    /**
     * Setup context menu for clipboard operations
     */
    private void setupContextMenu() {
        JPopupMenu contextMenu = new JPopupMenu();

        JMenuItem copyMarkdown = new JMenuItem("Copy as Markdown");
        copyMarkdown.addActionListener(e -> {
            String selectedText = isEditMode ?
                    markdownTextArea.getSelectedText() :
                    getSelectedMarkdownText();
            if (selectedText != null && !selectedText.isEmpty()) {
                copyToClipboard(selectedText);
            }
        });

        JMenuItem copyHtml = new JMenuItem("Copy as HTML");
        copyHtml.addActionListener(e -> {
            String selectedText = explainTextPane.getSelectedText();
            if (selectedText != null && !selectedText.isEmpty()) {
                copyToClipboard(selectedText);
            }
        });

        JMenuItem copyPlainText = new JMenuItem("Copy as Plain Text");
        copyPlainText.addActionListener(e -> {
            String selectedText = isEditMode ?
                    markdownTextArea.getSelectedText() :
                    explainTextPane.getSelectedText();
            if (selectedText != null && !selectedText.isEmpty()) {
                // Strip markdown formatting for plain text
                String plainText = selectedText.replaceAll("\\*\\*|__|`|#+ |\\[|\\]\\([^)]*\\)", "");
                copyToClipboard(plainText);
            }
        });

        JMenuItem copyAll = new JMenuItem("Copy All as Markdown");
        copyAll.addActionListener(e -> {
            copyToClipboard(currentMarkdown);
        });

        JMenuItem selectAll = new JMenuItem("Select All");
        selectAll.addActionListener(e -> {
            if (isEditMode) {
                markdownTextArea.selectAll();
            } else {
                explainTextPane.selectAll();
            }
        });

        JMenuItem paste = new JMenuItem("Paste");
        paste.addActionListener(e -> {
            if (isEditMode) {
                markdownTextArea.paste();
            }
        });

        contextMenu.add(copyMarkdown);
        contextMenu.add(copyHtml);
        contextMenu.add(copyPlainText);
        contextMenu.addSeparator();
        contextMenu.add(copyAll);
        contextMenu.add(selectAll);
        contextMenu.addSeparator();
        contextMenu.add(paste);

        // Show paste only in edit mode
        contextMenu.addPopupMenuListener(new javax.swing.event.PopupMenuListener() {
            @Override
            public void popupMenuWillBecomeVisible(javax.swing.event.PopupMenuEvent e) {
                paste.setEnabled(isEditMode);
            }
            @Override
            public void popupMenuWillBecomeInvisible(javax.swing.event.PopupMenuEvent e) {}
            @Override
            public void popupMenuCanceled(javax.swing.event.PopupMenuEvent e) {}
        });

        explainTextPane.setComponentPopupMenu(contextMenu);
        markdownTextArea.setComponentPopupMenu(contextMenu);
    }

    /**
     * Get selected markdown text based on selection in view mode
     */
    private String getSelectedMarkdownText() {
        String selectedText = explainTextPane.getSelectedText();
        if (selectedText != null && !selectedText.isEmpty()) {
            return selectedText;
        }
        return currentMarkdown;
    }

    /**
     * Copy text to system clipboard
     */
    private void copyToClipboard(String text) {
        if (text != null && !text.isEmpty()) {
            try {
                Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
                clipboard.setContents(new StringSelection(text), null);
            } catch (Exception e) {
                Msg.error(this, "Failed to copy to clipboard: " + e.getMessage());
            }
        }
    }

    /**
     * Get the current markdown content
     */
    public String getCurrentMarkdown() {
        return currentMarkdown;
    }

    /**
     * Set the markdown source directly (avoids lossy HTML-to-markdown conversion).
     *
     * @param markdown The original markdown content
     */
    public void setMarkdownSource(String markdown) {
        this.currentMarkdown = markdown != null ? markdown : "";
    }

    /**
     * Update the security info panel with analysis results.
     *
     * @param riskLevel Risk level (LOW, MEDIUM, HIGH) or null
     * @param activityProfile Activity profile string or null
     * @param securityFlags List of security flags or null
     * @param networkAPIs List of network API calls or null
     * @param fileIOAPIs List of file I/O API calls or null
     */
    public void updateSecurityInfo(String riskLevel, String activityProfile,
                                   List<String> securityFlags,
                                   List<String> networkAPIs, List<String> fileIOAPIs) {
        // Update risk level with color coding
        if (riskLevel != null && !riskLevel.isEmpty()) {
            riskLevelLabel.setText("Risk: " + riskLevel);
            switch (riskLevel.toUpperCase()) {
                case "HIGH":
                    riskLevelLabel.setForeground(new Color(180, 0, 0)); // Red
                    break;
                case "MEDIUM":
                    riskLevelLabel.setForeground(new Color(180, 120, 0)); // Orange
                    break;
                case "LOW":
                    riskLevelLabel.setForeground(new Color(0, 120, 0)); // Green
                    break;
                default:
                    riskLevelLabel.setForeground(UIManager.getColor("Label.foreground"));
            }
        } else {
            riskLevelLabel.setText("Risk: —");
            riskLevelLabel.setForeground(UIManager.getColor("Label.foreground"));
        }

        // Update activity profile
        if (activityProfile != null && !activityProfile.isEmpty()) {
            activityProfileLabel.setText("Activity: " + activityProfile);
        } else {
            activityProfileLabel.setText("Activity: —");
        }

        // Update security flags
        if (securityFlags != null && !securityFlags.isEmpty()) {
            securityFlagsLabel.setText("Flags: " + String.join(", ", securityFlags));
        } else {
            securityFlagsLabel.setText("Flags: None");
        }

        // Update network APIs
        if (networkAPIs != null && !networkAPIs.isEmpty()) {
            networkAPIsTextArea.setText(String.join("\n", networkAPIs));
        } else {
            networkAPIsTextArea.setText("(none detected)");
        }

        // Update file I/O APIs
        if (fileIOAPIs != null && !fileIOAPIs.isEmpty()) {
            fileIOAPIsTextArea.setText(String.join("\n", fileIOAPIs));
        } else {
            fileIOAPIsTextArea.setText("(none detected)");
        }

        // Show the panel if we have any data
        boolean hasData = (riskLevel != null && !riskLevel.isEmpty()) ||
                         (activityProfile != null && !activityProfile.isEmpty()) ||
                         (securityFlags != null && !securityFlags.isEmpty()) ||
                         (networkAPIs != null && !networkAPIs.isEmpty()) ||
                         (fileIOAPIs != null && !fileIOAPIs.isEmpty());
        securityInfoPanel.setVisible(hasData);
    }

    /**
     * Clear the security info panel.
     */
    public void clearSecurityInfo() {
        riskLevelLabel.setText("Risk: —");
        riskLevelLabel.setForeground(UIManager.getColor("Label.foreground"));
        activityProfileLabel.setText("Activity: —");
        securityFlagsLabel.setText("Flags: None");
        networkAPIsTextArea.setText("");
        fileIOAPIsTextArea.setText("");
        securityInfoPanel.setVisible(false);
    }

    /**
     * Set the line explanation text and make panel visible.
     *
     * @param text The explanation text (can be HTML or plain text)
     */
    public void setLineExplanationText(String text) {
        if (text == null || text.trim().isEmpty()) {
            clearLineExplanation();
            return;
        }

        lineExplanationMarkdown = text;
        lineExplanationTextPane.setText(text);
        lineExplanationTextPane.setCaretPosition(0);

        // Show the line explanation panel in the split pane
        if (mainSplitPane.getBottomComponent() == null) {
            lineExplanationPanel.setVisible(true);
            mainSplitPane.setBottomComponent(lineExplanationPanel);
            mainSplitPane.setDividerSize(8);

            // Set initial divider location to show ~180px for line explanation
            SwingUtilities.invokeLater(() -> {
                int totalHeight = mainSplitPane.getHeight();
                if (totalHeight > 250) {
                    mainSplitPane.setDividerLocation(totalHeight - 180);
                } else {
                    mainSplitPane.setDividerLocation(0.7);
                }
            });
        }

        // Revalidate layout
        revalidate();
        repaint();
    }

    /**
     * Clear the line explanation panel and hide it.
     */
    public void clearLineExplanation() {
        lineExplanationMarkdown = "";
        lineExplanationTextPane.setText("");

        // Hide the line explanation panel by removing from split pane
        mainSplitPane.setBottomComponent(null);
        mainSplitPane.setDividerSize(0);
        lineExplanationPanel.setVisible(false);

        // Revalidate layout
        revalidate();
        repaint();
    }

    /**
     * Set the Explain Line button enabled state.
     *
     * @param enabled true to enable, false to disable
     */
    public void setLineButtonEnabled(boolean enabled) {
        explainLineButton.setEnabled(enabled);
    }

    /**
     * Get the current line explanation markdown.
     *
     * @return The markdown text
     */
    public String getLineExplanationMarkdown() {
        return lineExplanationMarkdown;
    }

    /**
     * Check if the line explanation panel is currently visible.
     *
     * @return true if visible
     */
    public boolean isLineExplanationVisible() {
        return lineExplanationPanel.isVisible();
    }

    // ========================================
    // Streaming Methods for Function Explanation Pane
    // ========================================

    /**
     * Initialize the function explanation pane for streaming with a two-div DOM structure.
     *
     * @param prefixHtml Pre-rendered HTML for any prefix content (may be empty)
     */
    public void initializeForStreaming(String prefixHtml) {
        SwingUtilities.invokeLater(() -> {
            // Reset streaming state
            accumulatedCommittedHtml.setLength(0);
            lastPendingHtml = "<span></span>";
            documentCorrupted = false;

            // Switch to HTML mode
            explainTextPane.setContentType("text/html");
            HTMLEditorKit kit = new HTMLEditorKit();
            explainTextPane.setEditorKit(kit);

            // Build initial HTML with two-div structure
            String prefix = (prefixHtml != null && !prefixHtml.isEmpty()) ? prefixHtml : "";
            String initialHtml = String.format(
                "<html><head><style>%s</style></head><body>%s" +
                "<div id=\"committed\"></div>" +
                "<div id=\"pending\"><span></span></div>" +
                "</body></html>",
                STREAMING_CSS, prefix);

            explainTextPane.setText(initialHtml);

            // Switch to view mode if in edit mode
            if (isEditMode) {
                contentLayout.show(contentPanel, "view");
                editSaveButton.setText("Edit");
                isEditMode = false;
            }
        });
    }

    /**
     * Apply a render update to the function explanation streaming display.
     * Note: This method is called from EDT (via StreamingMarkdownRenderer's invokeLater).
     *
     * @param update The render update to apply
     */
    public void applyRenderUpdate(RenderUpdate update) {
        if (update == null) {
            return;
        }

        // Capture scroll state BEFORE any DOM modification
        boolean wasAtBottom = scrollManager.isAtBottom();
        int savedScrollValue = scrollManager.getScrollPane().getVerticalScrollBar().getValue();

        // Apply the update
        switch (update.getType()) {
            case INCREMENTAL -> applyIncrementalUpdate(update);
            case FULL_REPLACE -> applyFullReplaceUpdate(update);
        }

        // Restore scroll position or auto-scroll (matching reference implementation)
        if (wasAtBottom) {
            SwingUtilities.invokeLater(() -> scrollManager.scrollToBottom());
        } else {
            // Restore the user's scroll position exactly
            SwingUtilities.invokeLater(() ->
                    scrollManager.getScrollPane().getVerticalScrollBar().setValue(savedScrollValue));
        }
    }

    private void applyIncrementalUpdate(RenderUpdate update) {
        // Track content for fallback rebuilds
        String committedHtml = update.getCommittedHtmlToAppend();
        if (committedHtml != null && !committedHtml.isEmpty()) {
            accumulatedCommittedHtml.append(committedHtml);
        }
        String pendingHtml = update.getPendingHtml();
        if (pendingHtml != null) {
            lastPendingHtml = pendingHtml;
        }

        // If document was previously corrupted, use full rebuild strategy
        if (documentCorrupted) {
            rebuildDocument();
            return;
        }

        HTMLDocument doc = (HTMLDocument) explainTextPane.getDocument();

        try {
            // Append committed HTML
            if (committedHtml != null && !committedHtml.isEmpty()) {
                Element committedDiv = findElement(doc, "committed");
                if (committedDiv != null) {
                    doc.insertBeforeEnd(committedDiv, committedHtml);
                }
            }

            // Replace pending div atomically using setOuterHTML
            if (pendingHtml != null) {
                Element pendingDiv = findElement(doc, "pending");
                if (pendingDiv != null) {
                    String wrappedPending = "<div id=\"pending\">" + pendingHtml + "</div>";
                    doc.setOuterHTML(pendingDiv, wrappedPending);
                }
            }
        } catch (Exception e) {
            Msg.warn(this, "DOM update failed, switching to rebuild strategy: " + e.getMessage());
            documentCorrupted = true;
            rebuildDocument();
        }
    }

    private void applyFullReplaceUpdate(RenderUpdate update) {
        String fullHtml = update.getFullHtml();
        if (fullHtml != null) {
            String wrapped = "<html><head><style>" + STREAMING_CSS + "</style></head><body>" +
                    fullHtml + "</body></html>";
            explainTextPane.setText(wrapped);
            documentCorrupted = false;

            // Store the markdown equivalent for edit mode
            currentMarkdown = markdownHelper.extractMarkdownFromLlmResponse(fullHtml);
        }
    }

    private void rebuildDocument() {
        String html = "<html><head><style>" + STREAMING_CSS + "</style></head><body>" +
                accumulatedCommittedHtml.toString() +
                lastPendingHtml +
                "</body></html>";
        explainTextPane.setText(html);
    }

    private Element findElement(HTMLDocument doc, String id) {
        return findElementById(doc.getDefaultRootElement(), id);
    }

    private Element findElementById(Element element, String id) {
        // Check this element's attributes for an id
        Object idAttr = element.getAttributes().getAttribute(HTML.Attribute.ID);
        if (id.equals(idAttr)) {
            return element;
        }

        // Recursively search children
        for (int i = 0; i < element.getElementCount(); i++) {
            Element found = findElementById(element.getElement(i), id);
            if (found != null) {
                return found;
            }
        }
        return null;
    }

    // ========================================
    // Streaming Methods for Line Explanation Pane
    // ========================================

    /**
     * Initialize the line explanation pane for streaming with a two-div DOM structure.
     */
    public void initializeLineExplanationForStreaming() {
        SwingUtilities.invokeLater(() -> {
            // Reset streaming state
            lineAccumulatedCommittedHtml.setLength(0);
            lineLastPendingHtml = "<span></span>";
            lineDocumentCorrupted = false;

            // Switch to HTML mode
            lineExplanationTextPane.setContentType("text/html");
            HTMLEditorKit kit = new HTMLEditorKit();
            lineExplanationTextPane.setEditorKit(kit);

            // Build initial HTML with two-div structure
            String initialHtml = String.format(
                "<html><head><style>%s</style></head><body>" +
                "<div id=\"line-committed\"></div>" +
                "<div id=\"line-pending\"><span></span></div>" +
                "</body></html>",
                STREAMING_CSS);

            lineExplanationTextPane.setText(initialHtml);

            // Ensure the line explanation panel is visible
            if (mainSplitPane.getBottomComponent() == null) {
                lineExplanationPanel.setVisible(true);
                mainSplitPane.setBottomComponent(lineExplanationPanel);
                mainSplitPane.setDividerSize(8);

                // Set initial divider location
                SwingUtilities.invokeLater(() -> {
                    int totalHeight = mainSplitPane.getHeight();
                    if (totalHeight > 250) {
                        mainSplitPane.setDividerLocation(totalHeight - 180);
                    } else {
                        mainSplitPane.setDividerLocation(0.7);
                    }
                });
            }

            revalidate();
            repaint();
        });
    }

    /**
     * Apply a render update to the line explanation streaming display.
     * Note: This method is called from EDT (via StreamingMarkdownRenderer's invokeLater).
     *
     * @param update The render update to apply
     */
    public void applyLineRenderUpdate(RenderUpdate update) {
        if (update == null) {
            return;
        }

        // Capture scroll state BEFORE any DOM modification
        boolean wasAtBottom = lineScrollManager.isAtBottom();
        int savedScrollValue = lineScrollManager.getScrollPane().getVerticalScrollBar().getValue();

        // Apply the update
        switch (update.getType()) {
            case INCREMENTAL -> applyLineIncrementalUpdate(update);
            case FULL_REPLACE -> applyLineFullReplaceUpdate(update);
        }

        // Restore scroll position or auto-scroll (matching reference implementation)
        if (wasAtBottom) {
            SwingUtilities.invokeLater(() -> lineScrollManager.scrollToBottom());
        } else {
            // Restore the user's scroll position exactly
            SwingUtilities.invokeLater(() ->
                    lineScrollManager.getScrollPane().getVerticalScrollBar().setValue(savedScrollValue));
        }
    }

    private void applyLineIncrementalUpdate(RenderUpdate update) {
        // Track content for fallback rebuilds
        String committedHtml = update.getCommittedHtmlToAppend();
        if (committedHtml != null && !committedHtml.isEmpty()) {
            lineAccumulatedCommittedHtml.append(committedHtml);
        }
        String pendingHtml = update.getPendingHtml();
        if (pendingHtml != null) {
            lineLastPendingHtml = pendingHtml;
        }

        // If document was previously corrupted, use full rebuild strategy
        if (lineDocumentCorrupted) {
            rebuildLineDocument();
            return;
        }

        HTMLDocument doc = (HTMLDocument) lineExplanationTextPane.getDocument();

        try {
            // Append committed HTML
            if (committedHtml != null && !committedHtml.isEmpty()) {
                Element committedDiv = findElement(doc, "line-committed");
                if (committedDiv != null) {
                    doc.insertBeforeEnd(committedDiv, committedHtml);
                }
            }

            // Replace pending div atomically using setOuterHTML
            if (pendingHtml != null) {
                Element pendingDiv = findElement(doc, "line-pending");
                if (pendingDiv != null) {
                    String wrappedPending = "<div id=\"line-pending\">" + pendingHtml + "</div>";
                    doc.setOuterHTML(pendingDiv, wrappedPending);
                }
            }
        } catch (Exception e) {
            Msg.warn(this, "Line DOM update failed, switching to rebuild strategy: " + e.getMessage());
            lineDocumentCorrupted = true;
            rebuildLineDocument();
        }
    }

    private void applyLineFullReplaceUpdate(RenderUpdate update) {
        String fullHtml = update.getFullHtml();
        if (fullHtml != null) {
            String wrapped = "<html><head><style>" + STREAMING_CSS + "</style></head><body>" +
                    fullHtml + "</body></html>";
            lineExplanationTextPane.setText(wrapped);
            lineDocumentCorrupted = false;

            // Store the markdown equivalent
            lineExplanationMarkdown = markdownHelper.extractMarkdownFromLlmResponse(fullHtml);
        }
    }

    private void rebuildLineDocument() {
        String html = "<html><head><style>" + STREAMING_CSS + "</style></head><body>" +
                lineAccumulatedCommittedHtml.toString() +
                lineLastPendingHtml +
                "</body></html>";
        lineExplanationTextPane.setText(html);
    }
}
```

`src/main/java/ghidrassist/ui/tabs/MCPServerDialog.java`:

```java
package ghidrassist.ui.tabs;

import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.*;

import ghidrassist.mcp2.server.MCPServerConfig;

public class MCPServerDialog extends JDialog {
    private static final long serialVersionUID = 1L;
    
    private JTextField nameField;
    private JTextField urlField;
    private JComboBox<MCPServerConfig.TransportType> transportCombo;
    private JCheckBox enabledCheckBox;
    private JButton okButton;
    private JButton cancelButton;
    private boolean confirmed = false;
    
    public MCPServerDialog(Window parent, MCPServerConfig existingServer) {
        super(parent, existingServer == null ? "Add MCP Server" : "Edit MCP Server", 
              ModalityType.APPLICATION_MODAL);
        
        initializeComponents();
        layoutComponents();
        setupEventHandlers();
        
        if (existingServer != null) {
            populateFields(existingServer);
        } else {
            setDefaults();
        }
        
        pack();
        setLocationRelativeTo(parent);
        nameField.requestFocusInWindow();
    }
    
    private void initializeComponents() {
        nameField = new JTextField(20);
        urlField = new JTextField(30);
        transportCombo = new JComboBox<>(MCPServerConfig.TransportType.values());
        enabledCheckBox = new JCheckBox("Enabled", true);
        
        okButton = new JButton("OK");
        cancelButton = new JButton("Cancel");
        
        getRootPane().setDefaultButton(okButton);
    }
    
    private void layoutComponents() {
        setLayout(new BorderLayout());
        
        // Form panel
        JPanel formPanel = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 5);
        
        // Name
        gbc.gridx = 0; gbc.gridy = 0; gbc.anchor = GridBagConstraints.EAST;
        formPanel.add(new JLabel("Name:"), gbc);
        gbc.gridx = 1; gbc.anchor = GridBagConstraints.WEST; gbc.fill = GridBagConstraints.HORIZONTAL;
        formPanel.add(nameField, gbc);
        
        // URL
        gbc.gridx = 0; gbc.gridy = 1; gbc.anchor = GridBagConstraints.EAST; gbc.fill = GridBagConstraints.NONE;
        formPanel.add(new JLabel("URL:"), gbc);
        gbc.gridx = 1; gbc.anchor = GridBagConstraints.WEST; gbc.fill = GridBagConstraints.HORIZONTAL;
        formPanel.add(urlField, gbc);
        
        // Transport
        gbc.gridx = 0; gbc.gridy = 2; gbc.anchor = GridBagConstraints.EAST; gbc.fill = GridBagConstraints.NONE;
        formPanel.add(new JLabel("Transport:"), gbc);
        gbc.gridx = 1; gbc.anchor = GridBagConstraints.WEST; gbc.fill = GridBagConstraints.HORIZONTAL;
        formPanel.add(transportCombo, gbc);
        
        // Enabled
        gbc.gridx = 1; gbc.gridy = 3; gbc.anchor = GridBagConstraints.WEST;
        formPanel.add(enabledCheckBox, gbc);
        
        // Help text
        JPanel helpPanel = new JPanel(new BorderLayout());
        JTextArea helpText = new JTextArea(
            "Examples:\n" +
            "• Name: GhidraMCP, URL: http://localhost:8080\n" +
            "• Name: Local Tools, URL: http://127.0.0.1:3000\n\n" +
            "The server must implement the Model Context Protocol (MCP) specification."
        );
        helpText.setEditable(false);
        helpText.setOpaque(false);
        helpText.setFont(helpText.getFont().deriveFont(Font.ITALIC, 11f));
        helpPanel.add(helpText, BorderLayout.CENTER);
        helpPanel.setBorder(BorderFactory.createTitledBorder("Help"));
        
        // Button panel
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        buttonPanel.add(okButton);
        buttonPanel.add(cancelButton);
        
        // Layout
        add(formPanel, BorderLayout.CENTER);
        add(helpPanel, BorderLayout.NORTH);
        add(buttonPanel, BorderLayout.SOUTH);
        
        // Add border to content pane instead
        getRootPane().setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
    }
    
    private void setupEventHandlers() {
        okButton.addActionListener(e -> {
            if (validateInput()) {
                confirmed = true;
                dispose();
            }
        });
        
        cancelButton.addActionListener(e -> {
            confirmed = false;
            dispose();
        });
        
        // Transport selection updates URL placeholder
        transportCombo.addActionListener(e -> updateUrlPlaceholder());
    }
    
    private void setDefaults() {
        transportCombo.setSelectedItem(MCPServerConfig.TransportType.SSE);
        updateUrlPlaceholder();
    }
    
    private void populateFields(MCPServerConfig server) {
        nameField.setText(server.getName());
        urlField.setText(server.getBaseUrl());
        transportCombo.setSelectedItem(server.getTransport());
        enabledCheckBox.setSelected(server.isEnabled());
    }
    
    private void updateUrlPlaceholder() {
        MCPServerConfig.TransportType transport =
            (MCPServerConfig.TransportType) transportCombo.getSelectedItem();

        if (transport == MCPServerConfig.TransportType.SSE) {
            urlField.setToolTipText("HTTP(S) URL for Server-Sent Events transport (e.g., http://localhost:8080)");
        } else if (transport == MCPServerConfig.TransportType.STREAMABLE_HTTP) {
            urlField.setToolTipText("HTTP(S) URL for Streamable HTTP transport (e.g., http://localhost:8080) - uses /mcp endpoint");
        }
    }
    
    private boolean validateInput() {
        String name = nameField.getText().trim();
        String url = urlField.getText().trim();
        
        if (name.isEmpty()) {
            showError("Name cannot be empty.");
            nameField.requestFocus();
            return false;
        }

        if (!name.matches("^[a-zA-Z0-9_-]+$")) {
            showError("Name can only contain letters, numbers, underscores, and hyphens.\n" +
                      "Spaces and special characters are not allowed.");
            nameField.requestFocus();
            return false;
        }
        
        if (url.isEmpty()) {
            showError("URL cannot be empty.");
            urlField.requestFocus();
            return false;
        }
        
        // Both SSE and Streamable HTTP transports require HTTP(S) URLs
        MCPServerConfig.TransportType transport =
            (MCPServerConfig.TransportType) transportCombo.getSelectedItem();

        if (transport == MCPServerConfig.TransportType.SSE ||
            transport == MCPServerConfig.TransportType.STREAMABLE_HTTP) {
            if (!url.startsWith("http://") && !url.startsWith("https://")) {
                showError("URL must start with http:// or https:// for " + transport.getDisplayName() + " transport.");
                urlField.requestFocus();
                return false;
            }
        }

        return true;
    }
    
    private void showError(String message) {
        JOptionPane.showMessageDialog(this, message, "Validation Error", JOptionPane.ERROR_MESSAGE);
    }
    
    public boolean isConfirmed() {
        return confirmed;
    }
    
    public MCPServerConfig getServerConfig() {
        if (!confirmed) return null;
        
        return new MCPServerConfig(
            nameField.getText().trim(),
            urlField.getText().trim(),
            (MCPServerConfig.TransportType) transportCombo.getSelectedItem(),
            enabledCheckBox.isSelected()
        );
    }
}
```

`src/main/java/ghidrassist/ui/tabs/MCPServersTab.java`:

```java
package ghidrassist.ui.tabs;

import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.List;
import javax.swing.*;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.DefaultTableCellRenderer;

import ghidrassist.mcp2.server.MCPServerConfig;
import ghidrassist.mcp2.server.MCPServerRegistry;

public class MCPServersTab extends JPanel {
    private static final long serialVersionUID = 1L;
    
    private MCPServerRegistry registry;
    private JTable serversTable;
    private MCPServersTableModel tableModel;
    private JButton addButton;
    private JButton editButton;
    private JButton removeButton;
    private JButton testButton;
    
    public MCPServersTab() {
        this.registry = MCPServerRegistry.getInstance();
        initializeComponents();
        layoutComponents();
        setupEventHandlers();
        refreshTable();
    }
    
    private void initializeComponents() {
        tableModel = new MCPServersTableModel();
        serversTable = new JTable(tableModel);
        serversTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        serversTable.getTableHeader().setReorderingAllowed(false);
        
        // Custom renderer for enabled column
        serversTable.getColumnModel().getColumn(2).setCellRenderer(new BooleanCellRenderer());
        
        // Column widths
        serversTable.getColumnModel().getColumn(0).setPreferredWidth(150);
        serversTable.getColumnModel().getColumn(1).setPreferredWidth(300);
        serversTable.getColumnModel().getColumn(2).setPreferredWidth(80);
        serversTable.getColumnModel().getColumn(3).setPreferredWidth(120);
        
        addButton = new JButton("Add Server");
        editButton = new JButton("Edit");
        removeButton = new JButton("Remove");
        testButton = new JButton("Test Connection");
        
        // Initially disable buttons that require selection
        editButton.setEnabled(false);
        removeButton.setEnabled(false);
        testButton.setEnabled(false);
    }
    
    private void layoutComponents() {
        setLayout(new BorderLayout());
        
        // Main panel with table
        JScrollPane scrollPane = new JScrollPane(serversTable);
        scrollPane.setPreferredSize(new Dimension(600, 300));
        
        // Button panel
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        buttonPanel.add(addButton);
        buttonPanel.add(editButton);
        buttonPanel.add(removeButton);
        buttonPanel.add(Box.createHorizontalStrut(20));
        buttonPanel.add(testButton);
        
        // Info panel
        JPanel infoPanel = new JPanel(new BorderLayout());
        JTextArea infoText = new JTextArea(
            "MCP (Model Context Protocol) servers provide additional tools and context to the LLM.\n" +
            "Configure servers here to enable their tools in queries. Servers must be MCP-compliant."
        );
        infoText.setEditable(false);
        infoText.setOpaque(false);
        infoText.setFont(infoText.getFont().deriveFont(Font.ITALIC));
        infoPanel.add(infoText, BorderLayout.CENTER);
        infoPanel.setBorder(BorderFactory.createEmptyBorder(5, 10, 10, 10));
        
        add(infoPanel, BorderLayout.NORTH);
        add(scrollPane, BorderLayout.CENTER);
        add(buttonPanel, BorderLayout.SOUTH);
    }
    
    private void setupEventHandlers() {
        // Table selection listener
        serversTable.getSelectionModel().addListSelectionListener(e -> {
            if (!e.getValueIsAdjusting()) {
                boolean hasSelection = serversTable.getSelectedRow() >= 0;
                editButton.setEnabled(hasSelection);
                removeButton.setEnabled(hasSelection);
                testButton.setEnabled(hasSelection);
            }
        });
        
        addButton.addActionListener(e -> showAddEditDialog(null));
        editButton.addActionListener(e -> {
            int selectedRow = serversTable.getSelectedRow();
            if (selectedRow >= 0) {
                MCPServerConfig server = tableModel.getServerAt(selectedRow);
                showAddEditDialog(server);
            }
        });
        
        removeButton.addActionListener(e -> {
            int selectedRow = serversTable.getSelectedRow();
            if (selectedRow >= 0) {
                MCPServerConfig server = tableModel.getServerAt(selectedRow);
                int result = JOptionPane.showConfirmDialog(
                    this,
                    "Remove server '" + server.getName() + "'?",
                    "Confirm Removal",
                    JOptionPane.YES_NO_OPTION
                );
                if (result == JOptionPane.YES_OPTION) {
                    registry.removeServer(server.getName());
                    refreshTable();
                }
            }
        });
        
        testButton.addActionListener(e -> testConnection());
    }
    
    private void showAddEditDialog(MCPServerConfig existingServer) {
        MCPServerDialog dialog = new MCPServerDialog(
            SwingUtilities.getWindowAncestor(this),
            existingServer
        );
        dialog.setVisible(true);
        
        if (dialog.isConfirmed()) {
            MCPServerConfig config = dialog.getServerConfig();
            if (existingServer != null) {
                registry.removeServer(existingServer.getName());
            }
            registry.addServer(config);
            refreshTable();
        }
    }
    
    private void testConnection() {
        int selectedRow = serversTable.getSelectedRow();
        if (selectedRow < 0) return;
        
        MCPServerConfig server = tableModel.getServerAt(selectedRow);
        testButton.setEnabled(false);
        testButton.setText("Testing...");
        
        SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {
            private String errorMessage = "";
            
            @Override
            protected Boolean doInBackground() throws Exception {
                try {
                    // Create client adapter for testing using official SDK
                    ghidrassist.mcp2.protocol.MCPClientAdapter client = 
                        new ghidrassist.mcp2.protocol.MCPClientAdapter(server);
                    
                    // Try to connect (this will test both connectivity and MCP protocol)
                    client.connect().get(); // Wait for connection
                    
                    // If we get here, both basic connectivity and MCP protocol tests passed
                    client.disconnect();
                    return true;
                    
                } catch (Exception e) {
                    // Extract the root cause message
                    Throwable cause = e.getCause() != null ? e.getCause() : e;
                    errorMessage = cause.getMessage();
                    return false;
                }
            }
            
            @Override
            protected void done() {
                try {
                    boolean success = get();
                    String message;
                    int messageType;
                    
                    if (success) {
                        message = "✅ Connection successful!\n\n" +
                                 "Server is responding and supports MCP protocol.";
                        messageType = JOptionPane.INFORMATION_MESSAGE;
                    } else {
                        message = "❌ Connection failed:\n\n" + 
                            (errorMessage.isEmpty() ? "Unknown error occurred" : errorMessage);
                        messageType = JOptionPane.ERROR_MESSAGE;
                    }
                    
                    JOptionPane.showMessageDialog(
                        MCPServersTab.this,
                        message,
                        "Connection Test Results",
                        messageType
                    );
                } catch (Exception e) {
                    JOptionPane.showMessageDialog(
                        MCPServersTab.this,
                        "❌ Test failed: " + e.getMessage(),
                        "Connection Test Error",
                        JOptionPane.ERROR_MESSAGE
                    );
                } finally {
                    testButton.setEnabled(true);
                    testButton.setText("Test Connection");
                }
            }
        };
        worker.execute();
    }
    
    private void refreshTable() {
        tableModel.refresh();
    }
    
    private static class MCPServersTableModel extends AbstractTableModel {
        private static final String[] COLUMN_NAMES = {"Name", "URL", "Enabled", "Transport"};
        private List<MCPServerConfig> servers;
        
        public MCPServersTableModel() {
            refresh();
        }
        
        public void refresh() {
            servers = MCPServerRegistry.getInstance().getAllServers();
            fireTableDataChanged();
        }
        
        @Override
        public int getRowCount() {
            return servers.size();
        }
        
        @Override
        public int getColumnCount() {
            return COLUMN_NAMES.length;
        }
        
        @Override
        public String getColumnName(int column) {
            return COLUMN_NAMES[column];
        }
        
        @Override
        public Class<?> getColumnClass(int column) {
            return column == 2 ? Boolean.class : String.class;
        }
        
        @Override
        public Object getValueAt(int row, int column) {
            MCPServerConfig server = servers.get(row);
            switch (column) {
                case 0: return server.getName();
                case 1: return server.getBaseUrl();
                case 2: return server.isEnabled();
                case 3: return server.getTransport().getDisplayName();
                default: return null;
            }
        }
        
        @Override
        public boolean isCellEditable(int row, int column) {
            return column == 2; // Only enabled column is editable
        }
        
        @Override
        public void setValueAt(Object value, int row, int column) {
            if (column == 2 && value instanceof Boolean) {
                MCPServerConfig server = servers.get(row);
                MCPServerConfig updated = new MCPServerConfig(
                    server.getName(),
                    server.getBaseUrl(),
                    server.getTransport(),
                    (Boolean) value
                );
                MCPServerRegistry.getInstance().updateServer(updated);
                fireTableCellUpdated(row, column);
            }
        }
        
        public MCPServerConfig getServerAt(int row) {
            return servers.get(row);
        }
    }
    
    private static class BooleanCellRenderer extends DefaultTableCellRenderer {
        private JCheckBox checkBox = new JCheckBox();
        
        @Override
        public Component getTableCellRendererComponent(JTable table, Object value,
                boolean isSelected, boolean hasFocus, int row, int column) {
            checkBox.setSelected(value != null && (Boolean) value);
            checkBox.setHorizontalAlignment(JLabel.CENTER);
            checkBox.setOpaque(true);
            
            if (isSelected) {
                checkBox.setBackground(table.getSelectionBackground());
                checkBox.setForeground(table.getSelectionForeground());
            } else {
                checkBox.setBackground(table.getBackground());
                checkBox.setForeground(table.getForeground());
            }
            
            return checkBox;
        }
    }
}
```

`src/main/java/ghidrassist/ui/tabs/QueryTab.java`:

```java
package ghidrassist.ui.tabs;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import javax.swing.text.*;
import javax.swing.text.html.HTML;
import javax.swing.text.html.HTMLDocument;
import javax.swing.text.html.HTMLEditorKit;
import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.text.SimpleDateFormat;
import java.util.TimeZone;
import java.util.Date;
import ghidra.util.Msg;
import ghidrassist.core.MarkdownHelper;
import ghidrassist.core.TabController;
import ghidrassist.core.streaming.RenderUpdate;
import ghidrassist.core.streaming.StreamingScrollManager;
import ghidrassist.mcp2.server.MCPServerRegistry;
import ghidrassist.AnalysisDB;

public class QueryTab extends JPanel {
    private static final long serialVersionUID = 1L;
    private final TabController controller;
    private final MarkdownHelper markdownHelper;
    private JTextPane responseTextPane;  // Changed from JEditorPane for better performance
    private StyledDocument responseDocument;
    private JTextArea queryTextArea;
    private JCheckBox useRAGCheckBox;
    private JCheckBox useMCPCheckBox;
    private JCheckBox useAgenticCheckBox;
    private JButton submitButton;
    private JButton newButton;
    private JButton deleteButton;
    private JTable chatHistoryTable;
    private DefaultTableModel chatHistoryModel;
    private SimpleDateFormat dateFormat;

    // Edit mode components
    private JButton editSaveButton;
    private JTextArea markdownEditArea;
    private JPanel contentPanel;
    private CardLayout contentLayout;
    private boolean isEditMode = false;
    private String currentMarkdownSource = "";
    private static final String QUERY_HINT_TEXT =
        "#line to include the current disassembly line.\n" +
        "#func to include current function disassembly.\n" +
        "#addr to include the current hex address.\n" +
        "#range(start, end) to include the view data in a given range.";

    // Use shared CSS from MarkdownHelper for consistency between streaming and final rendering
    private static final String STREAMING_CSS = MarkdownHelper.MARKDOWN_CSS;

    // Streaming state fields
    private StringBuilder accumulatedCommittedHtml = new StringBuilder();
    private String lastPendingHtml = "<span></span>";
    private boolean documentCorrupted = false;
    private StreamingScrollManager scrollManager;
    private JScrollPane responseScrollPane;

    public QueryTab(TabController controller) {
        super(new BorderLayout());
        this.controller = controller;
        this.markdownHelper = new MarkdownHelper();
        this.dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        this.dateFormat.setTimeZone(TimeZone.getDefault()); // Use local timezone

        // Initialize JTextPane with StyledDocument for incremental updates
        responseTextPane = new JTextPane();
        responseTextPane.setEditable(false);
        responseDocument = responseTextPane.getStyledDocument();

        // Enable double buffering for smoother updates
        responseTextPane.setDoubleBuffered(true);

        initializeComponents();
        layoutComponents();
        setupListeners();
        setupMCPDetection();
        setupChatHistoryRefresh();
        setupContextMenu();
    }

    private void initializeComponents() {
        useRAGCheckBox = new JCheckBox("Use RAG");
        useRAGCheckBox.setSelected(false);

        useMCPCheckBox = new JCheckBox("Use MCP Tools");
        useMCPCheckBox.setSelected(false);
        useMCPCheckBox.setEnabled(false); // Disabled by default, enabled when MCP is detected

        useAgenticCheckBox = new JCheckBox("Agentic Mode (ReAct)");
        useAgenticCheckBox.setSelected(false);
        useAgenticCheckBox.setEnabled(false); // Enabled only when MCP is available
        useAgenticCheckBox.setToolTipText("Enable autonomous ReAct-style analysis with systematic tool use");

        // responseTextPane already initialized in constructor

        queryTextArea = new JTextArea();
        queryTextArea.setRows(4);
        queryTextArea.setFont(new Font("Monospaced", Font.PLAIN, 12));
        queryTextArea.setLineWrap(true);
        queryTextArea.setWrapStyleWord(true);
        addHintTextToQueryTextArea();

        submitButton = new JButton("Submit");
        newButton = new JButton("New");
        deleteButton = new JButton("Delete");
        editSaveButton = new JButton("Edit");

        // Initialize markdown edit area for edit mode
        markdownEditArea = new JTextArea();
        markdownEditArea.setFont(new Font("Monospaced", Font.PLAIN, 12));
        markdownEditArea.setLineWrap(true);
        markdownEditArea.setWrapStyleWord(true);

        // Setup card layout for switching between view and edit modes
        contentLayout = new CardLayout();
        contentPanel = new JPanel(contentLayout);

        // Initialize chat history table
        chatHistoryModel = new DefaultTableModel(new Object[]{"Description", "Date"}, 0) {
            private static final long serialVersionUID = 1L;
            @Override
            public boolean isCellEditable(int row, int column) {
                return column == 0; // Only description column is editable
            }
        };
        
        chatHistoryTable = new JTable(chatHistoryModel);
        chatHistoryTable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
        chatHistoryTable.setRowHeight(20);
        chatHistoryTable.setTableHeader(null); // Completely remove header row
        
        // Set column widths
        chatHistoryTable.getColumnModel().getColumn(0).setPreferredWidth(150); // Description
        chatHistoryTable.getColumnModel().getColumn(1).setPreferredWidth(150); // Date
    }

    private void layoutComponents() {
        // Create top panel with checkboxes and edit button
        JPanel topPanel = new JPanel(new BorderLayout());

        JPanel checkboxPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        checkboxPanel.add(useRAGCheckBox);
        checkboxPanel.add(useMCPCheckBox);
        checkboxPanel.add(useAgenticCheckBox);
        topPanel.add(checkboxPanel, BorderLayout.CENTER);

        JPanel editPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        editPanel.add(editSaveButton);
        topPanel.add(editPanel, BorderLayout.EAST);

        add(topPanel, BorderLayout.NORTH);

        // Setup content panel with CardLayout (view mode + edit mode)
        responseScrollPane = new JScrollPane(responseTextPane);
        responseScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
        scrollManager = new StreamingScrollManager(responseScrollPane);
        JScrollPane editScrollPane = new JScrollPane(markdownEditArea);
        contentPanel.add(responseScrollPane, "view");
        contentPanel.add(editScrollPane, "edit");

        JScrollPane queryScrollPane = new JScrollPane(queryTextArea);

        // Create chat history scroll pane with default height of 2 rows
        JScrollPane chatHistoryScrollPane = new JScrollPane(chatHistoryTable);
        chatHistoryScrollPane.setPreferredSize(new Dimension(0, 50)); // About 2 rows height
        chatHistoryScrollPane.setMinimumSize(new Dimension(0, 40));

        // Create a panel for chat history and query area
        JPanel bottomPanel = new JPanel(new BorderLayout());
        bottomPanel.add(chatHistoryScrollPane, BorderLayout.NORTH);
        bottomPanel.add(queryScrollPane, BorderLayout.CENTER);

        // Create main split pane between response and (chat history + query)
        JSplitPane mainSplitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT,
            contentPanel, bottomPanel);
        mainSplitPane.setResizeWeight(0.7); // Give more space to response area

        // Create inner split pane for chat history and query area
        JSplitPane bottomSplitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT,
            chatHistoryScrollPane, queryScrollPane);
        bottomSplitPane.setResizeWeight(0.3); // Chat history takes less space than query

        // Replace the bottom panel with the split pane
        bottomPanel.removeAll();
        bottomPanel.add(bottomSplitPane, BorderLayout.CENTER);

        add(mainSplitPane, BorderLayout.CENTER);

        JPanel buttonPanel = new JPanel();
        buttonPanel.add(submitButton);
        buttonPanel.add(newButton);
        buttonPanel.add(deleteButton);
        add(buttonPanel, BorderLayout.SOUTH);
    }

    private void setupListeners() {
        // Add hyperlink listener for RLHF feedback buttons
        responseTextPane.addHyperlinkListener(controller::handleHyperlinkEvent);

        submitButton.addActionListener(e -> controller.handleQuerySubmit(
            queryTextArea.getText(),
            useRAGCheckBox.isSelected(),
            useMCPCheckBox.isSelected(),
            useAgenticCheckBox.isSelected()
        ));

        newButton.addActionListener(e -> controller.handleNewChatSession());

        deleteButton.addActionListener(e -> controller.handleDeleteCurrentSession());

        // Edit/Save button handler
        editSaveButton.addActionListener(e -> {
            if (isEditMode) {
                // Save mode - capture content and notify controller
                currentMarkdownSource = markdownEditArea.getText();
                controller.handleChatEditSave(currentMarkdownSource);

                // Switch to view mode
                contentLayout.show(contentPanel, "view");
                editSaveButton.setText("Edit");
                isEditMode = false;
            } else {
                // Edit mode - notify controller to prepare content
                controller.handleChatEditStart();

                // Switch to edit mode
                contentLayout.show(contentPanel, "edit");
                editSaveButton.setText("Save");
                isEditMode = true;
            }
        });
        
        // Chat history table selection listener
        chatHistoryTable.getSelectionModel().addListSelectionListener(e -> {
            if (!e.getValueIsAdjusting()) {
                int selectedRow = chatHistoryTable.getSelectedRow();
                if (selectedRow >= 0) {
                    controller.handleChatSessionSelection(selectedRow);
                }
            }
        });
        
        // Chat history table double-click for inline editing
        chatHistoryTable.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (e.getClickCount() == 2) {
                    int row = chatHistoryTable.rowAtPoint(e.getPoint());
                    int col = chatHistoryTable.columnAtPoint(e.getPoint());
                    if (row >= 0 && col == 0) { // Only description column is editable
                        chatHistoryTable.editCellAt(row, col);
                    }
                }
            }
        });
        
        // Auto-save when focus changes from description field
        chatHistoryModel.addTableModelListener(e -> {
            if (e.getColumn() == 0) { // Description column changed
                int row = e.getFirstRow();
                if (row >= 0) {
                    String newDescription = (String) chatHistoryModel.getValueAt(row, 0);
                    controller.handleChatDescriptionUpdate(row, newDescription);
                }
            }
        });
    }

    private void addHintTextToQueryTextArea() {
        Color fgColor = queryTextArea.getForeground();
        queryTextArea.setText(QUERY_HINT_TEXT);
        queryTextArea.setForeground(Color.GRAY);
        
        queryTextArea.addFocusListener(new java.awt.event.FocusAdapter() {
            @Override
            public void focusGained(java.awt.event.FocusEvent e) {
                if (queryTextArea.getText().equals(QUERY_HINT_TEXT)) {
                    queryTextArea.setText("");
                    queryTextArea.setForeground(fgColor);
                }
            }

            @Override
            public void focusLost(java.awt.event.FocusEvent e) {
                if (queryTextArea.getText().isEmpty()) {
                    queryTextArea.setForeground(Color.GRAY);
                    queryTextArea.setText(QUERY_HINT_TEXT);
                }
            }
        });
    }

    /**
     * Set response text - switches to HTML mode and renders full content.
     * PERFORMANCE: This is used at completion for full markdown rendering.
     * Preserves scroll position if user has scrolled up from bottom.
     */
    public void setResponseText(String htmlText) {
        Runnable updateUi = () -> {
            try {
                // Capture scroll state BEFORE any modifications
                boolean wasAtBottom = scrollManager.isAtBottom();
                int savedScrollValue = scrollManager.getScrollPane().getVerticalScrollBar().getValue();

                // Switch to HTML mode for final markdown rendering
                responseTextPane.setContentType("text/html");
                responseTextPane.setEditorKit(new HTMLEditorKit());
                responseTextPane.setText(htmlText);

                // Restore scroll position - only auto-scroll if user was at bottom
                SwingUtilities.invokeLater(() -> {
                    if (wasAtBottom) {
                        scrollManager.scrollToBottom();
                    } else {
                        scrollManager.getScrollPane().getVerticalScrollBar().setValue(savedScrollValue);
                    }
                });
            } catch (Exception e) {
                Msg.error(this, "Error setting response text", e);
            }
        };

        if (SwingUtilities.isEventDispatchThread()) {
            updateUi.run();
        } else {
            SwingUtilities.invokeLater(updateUi);
        }
    }

    /**
     * Initialize the response pane for streaming with a two-div DOM structure.
     * Optionally includes conversation history as a prefix.
     *
     * @param prefixHtml Pre-rendered HTML for conversation history (may be empty)
     */
    public void initializeForStreaming(String prefixHtml) {
        Runnable initializeUi = () -> {
            // Capture scroll state BEFORE any modifications
            boolean wasAtBottom = scrollManager.isAtBottom();
            int savedScrollValue = scrollManager.getScrollPane().getVerticalScrollBar().getValue();

            // Reset streaming state
            accumulatedCommittedHtml.setLength(0);
            lastPendingHtml = "<span></span>";
            documentCorrupted = false;

            // Switch to HTML mode
            responseTextPane.setContentType("text/html");
            HTMLEditorKit kit = new HTMLEditorKit();
            responseTextPane.setEditorKit(kit);

            // Build initial HTML with two-div structure
            String prefix = (prefixHtml != null && !prefixHtml.isEmpty()) ? prefixHtml : "";
            String initialHtml = String.format(
                "<html><head><style>%s</style></head><body>%s" +
                "<div id=\"committed\"></div>" +
                "<div id=\"pending\"><span></span></div>" +
                "</body></html>",
                STREAMING_CSS, prefix);

            responseTextPane.setText(initialHtml);
            responseDocument = responseTextPane.getStyledDocument();

            // Restore scroll position
            if (wasAtBottom) {
                SwingUtilities.invokeLater(() -> scrollManager.scrollToBottom());
            } else {
                SwingUtilities.invokeLater(() ->
                        scrollManager.getScrollPane().getVerticalScrollBar().setValue(savedScrollValue));
            }
        };

        if (SwingUtilities.isEventDispatchThread()) {
            initializeUi.run();
        } else {
            SwingUtilities.invokeLater(initializeUi);
        }
    }

    /**
     * Apply a render update to the streaming display.
     * Handles both incremental (append/replace) and full document replacement.
     * Note: This method is called from EDT (via StreamingMarkdownRenderer's invokeLater).
     *
     * @param update The render update to apply
     */
    public void applyRenderUpdate(RenderUpdate update) {
        if (update == null) {
            return;
        }

        // Capture scroll state BEFORE any DOM modification
        boolean wasAtBottom = scrollManager.isAtBottom();
        int savedScrollValue = scrollManager.getScrollPane().getVerticalScrollBar().getValue();

        // Apply the update
        switch (update.getType()) {
            case INCREMENTAL -> applyIncrementalUpdate(update);
            case FULL_REPLACE -> applyFullReplaceUpdate(update);
        }

        // Restore scroll position or auto-scroll (matching reference implementation)
        if (wasAtBottom) {
            SwingUtilities.invokeLater(() -> scrollManager.scrollToBottom());
        } else {
            // Restore the user's scroll position exactly
            SwingUtilities.invokeLater(() ->
                    scrollManager.getScrollPane().getVerticalScrollBar().setValue(savedScrollValue));
        }
    }

    private void applyIncrementalUpdate(RenderUpdate update) {
        // Track content for fallback rebuilds
        String committedHtml = update.getCommittedHtmlToAppend();
        if (committedHtml != null && !committedHtml.isEmpty()) {
            accumulatedCommittedHtml.append(committedHtml);
        }
        String pendingHtml = update.getPendingHtml();
        if (pendingHtml != null) {
            lastPendingHtml = pendingHtml;
        }

        // If document was previously corrupted, use full rebuild strategy
        if (documentCorrupted) {
            rebuildDocument();
            return;
        }

        HTMLDocument doc = ensureHtmlDocument();
        if (doc == null) {
            documentCorrupted = true;
            rebuildDocument();
            return;
        }

        try {
            // Append committed HTML
            if (committedHtml != null && !committedHtml.isEmpty()) {
                Element committedDiv = findElement(doc, "committed");
                if (committedDiv != null) {
                    doc.insertBeforeEnd(committedDiv, committedHtml);
                }
            }

            // Replace pending div atomically using setOuterHTML
            // (avoids the BiDi corruption bug in setInnerHTML)
            if (pendingHtml != null) {
                Element pendingDiv = findElement(doc, "pending");
                if (pendingDiv != null) {
                    String wrappedPending = "<div id=\"pending\">" + pendingHtml + "</div>";
                    doc.setOuterHTML(pendingDiv, wrappedPending);
                }
            }
        } catch (Exception e) {
            Msg.warn(this, "DOM update failed, switching to rebuild strategy: " + e.getMessage());
            documentCorrupted = true;
            rebuildDocument();
        }
    }

    private void applyFullReplaceUpdate(RenderUpdate update) {
        String fullHtml = update.getFullHtml();
        if (fullHtml != null) {
            String wrapped = "<html><head><style>" + STREAMING_CSS + "</style></head><body>" +
                    fullHtml + "</body></html>";
            responseTextPane.setContentType("text/html");
            responseTextPane.setEditorKit(new HTMLEditorKit());
            responseTextPane.setText(wrapped);
            documentCorrupted = false;
        }
    }

    private void rebuildDocument() {
        String html = "<html><head><style>" + STREAMING_CSS + "</style></head><body>" +
                accumulatedCommittedHtml.toString() +
                lastPendingHtml +
                "</body></html>";
        responseTextPane.setContentType("text/html");
        responseTextPane.setEditorKit(new HTMLEditorKit());
        responseTextPane.setText(html);
    }

    /**
     * Ensure the response pane has an HTMLDocument.
     * When streaming starts before HTML initialization finishes, Swing may still
     * expose a DefaultStyledDocument. Recover by rebuilding the HTML document.
     */
    private HTMLDocument ensureHtmlDocument() {
        Document currentDoc = responseTextPane.getDocument();
        if (currentDoc instanceof HTMLDocument) {
            return (HTMLDocument) currentDoc;
        }

        Msg.warn(this, "Query response document is not HTMLDocument (" +
                currentDoc.getClass().getName() + "); rebuilding HTML view.");

        responseTextPane.setContentType("text/html");
        responseTextPane.setEditorKit(new HTMLEditorKit());
        String repairedHtml = "<html><head><style>" + STREAMING_CSS + "</style></head><body>" +
                "<div id=\"committed\">" + accumulatedCommittedHtml + "</div>" +
                "<div id=\"pending\">" + lastPendingHtml + "</div>" +
                "</body></html>";
        responseTextPane.setText(repairedHtml);

        Document repairedDoc = responseTextPane.getDocument();
        if (repairedDoc instanceof HTMLDocument) {
            return (HTMLDocument) repairedDoc;
        }

        Msg.error(this, "Failed to recover HTMLDocument for query streaming", null);
        return null;
    }

    private Element findElement(HTMLDocument doc, String id) {
        return findElementById(doc.getDefaultRootElement(), id);
    }

    private Element findElementById(Element element, String id) {
        // Check this element's attributes for an id
        Object idAttr = element.getAttributes().getAttribute(HTML.Attribute.ID);
        if (id.equals(idAttr)) {
            return element;
        }

        // Recursively search children
        for (int i = 0; i < element.getElementCount(); i++) {
            Element found = findElementById(element.getElement(i), id);
            if (found != null) {
                return found;
            }
        }
        return null;
    }

    /**
     * Clear the response and prepare for streaming.
     */
    public void clearResponse() {
        initializeForStreaming("");
    }

    public void appendToResponse(String html) {
        // For backward compatibility - now just sets text
        setResponseText(html);
    }
    
    public void setSubmitButtonText(String text) {
        submitButton.setText(text);
    }
    
    public void setMCPEnabled(boolean enabled) {
        useMCPCheckBox.setEnabled(enabled);
        // Agentic mode requires MCP tools, so enable/disable together
        useAgenticCheckBox.setEnabled(enabled);
    }

    public boolean isMCPEnabled() {
        return useMCPCheckBox.isEnabled();
    }

    public boolean isMCPSelected() {
        return useMCPCheckBox.isSelected();
    }

    public boolean isAgenticSelected() {
        return useAgenticCheckBox.isSelected();
    }
    
    /**
     * Setup chat history refresh when tab receives focus
     */
    private void setupChatHistoryRefresh() {
        // Refresh chat history when tab receives focus
        this.addFocusListener(new java.awt.event.FocusAdapter() {
            @Override
            public void focusGained(java.awt.event.FocusEvent e) {
                controller.refreshChatHistory();
            }
        });
        
        // Also refresh when component becomes visible
        this.addComponentListener(new ComponentAdapter() {
            @Override
            public void componentShown(ComponentEvent e) {
                controller.refreshChatHistory();
            }
        });
    }
    
    /**
     * Setup MCP detection that checks for availability when tab becomes visible
     */
    private void setupMCPDetection() {
        // Check MCP availability when component becomes visible
        this.addComponentListener(new ComponentAdapter() {
            @Override
            public void componentShown(ComponentEvent e) {
                updateMCPCheckboxState();
            }
        });
        
        // Also check when gaining focus
        this.addFocusListener(new java.awt.event.FocusAdapter() {
            @Override
            public void focusGained(java.awt.event.FocusEvent e) {
                updateMCPCheckboxState();
            }
        });
        
        // Initial check
        SwingUtilities.invokeLater(this::updateMCPCheckboxState);
    }
    
    /**
     * Update MCP checkbox state based on enabled server configuration
     * Checks if any MCP servers are configured and enabled
     */
    private void updateMCPCheckboxState() {
        if (!SwingUtilities.isEventDispatchThread()) {
            SwingUtilities.invokeLater(this::updateMCPCheckboxState);
            return;
        }

        // Check if any MCP servers are enabled in configuration
        MCPServerRegistry registry = MCPServerRegistry.getInstance();
        boolean hasEnabledServers = !registry.getEnabledServers().isEmpty();

        boolean wasEnabled = useMCPCheckBox.isEnabled();
        useMCPCheckBox.setEnabled(hasEnabledServers);

        // Agentic mode requires MCP, so enable/disable together
        useAgenticCheckBox.setEnabled(hasEnabledServers);

        // If no servers enabled, also uncheck both boxes
        if (!hasEnabledServers) {
            useMCPCheckBox.setSelected(false);
            useAgenticCheckBox.setSelected(false);
        }
        
        // Log state change for debugging
        if (wasEnabled != hasEnabledServers) {
            String state = hasEnabledServers ? "enabled" : "disabled";
            int enabledCount = registry.getEnabledServers().size();
            Msg.info(this, "MCP Tools checkbox " + state + " - enabled servers: " + enabledCount);
        }
    }
    
    /**
     * Public method to update MCP checkbox state
     * Called by controller when actions are triggered
     */
    public void refreshMCPState() {
        updateMCPCheckboxState();
    }
    
    /**
     * Update the chat history table with sessions
     */
    public void updateChatHistory(java.util.List<AnalysisDB.ChatSession> sessions) {
        chatHistoryModel.setRowCount(0); // Clear existing rows
        
        for (AnalysisDB.ChatSession session : sessions) {
            // Convert SQL Timestamp to Date and format in local timezone
            Date localDate = new Date(session.getLastUpdate().getTime());
            String formattedDate = dateFormat.format(localDate);
            chatHistoryModel.addRow(new Object[]{session.getDescription(), formattedDate});
        }
    }
    
    /**
     * Select a specific chat session row
     */
    public void selectChatSession(int rowIndex) {
        if (rowIndex >= 0 && rowIndex < chatHistoryTable.getRowCount()) {
            chatHistoryTable.setRowSelectionInterval(rowIndex, rowIndex);
        }
    }
    
    /**
     * Clear chat history selection
     */
    public void clearChatSelection() {
        chatHistoryTable.clearSelection();
    }
    
    /**
     * Get the currently selected chat session row (first selected if multiple)
     */
    public int getSelectedChatSession() {
        return chatHistoryTable.getSelectedRow();
    }

    /**
     * Get all selected chat session rows (for bulk operations like delete)
     */
    public int[] getSelectedChatSessions() {
        return chatHistoryTable.getSelectedRows();
    }

    /**
     * Setup context menu for clipboard operations
     */
    private void setupContextMenu() {
        JPopupMenu contextMenu = new JPopupMenu();

        JMenuItem copyMarkdown = new JMenuItem("Copy as Markdown");
        copyMarkdown.addActionListener(e -> {
            String selectedText = isEditMode ?
                    markdownEditArea.getSelectedText() :
                    getSelectedMarkdownText();
            if (selectedText != null && !selectedText.isEmpty()) {
                copyToClipboard(selectedText);
            }
        });

        JMenuItem copyHtml = new JMenuItem("Copy as HTML");
        copyHtml.addActionListener(e -> {
            String selectedText = responseTextPane.getSelectedText();
            if (selectedText != null && !selectedText.isEmpty()) {
                // For HTML, get from the rendered content
                copyToClipboard(selectedText);
            }
        });

        JMenuItem copyPlainText = new JMenuItem("Copy as Plain Text");
        copyPlainText.addActionListener(e -> {
            String selectedText = isEditMode ?
                    markdownEditArea.getSelectedText() :
                    responseTextPane.getSelectedText();
            if (selectedText != null && !selectedText.isEmpty()) {
                // Strip markdown formatting for plain text
                String plainText = selectedText.replaceAll("\\*\\*|__|`|#+ |\\[|\\]\\([^)]*\\)", "");
                copyToClipboard(plainText);
            }
        });

        JMenuItem copyAll = new JMenuItem("Copy All as Markdown");
        copyAll.addActionListener(e -> {
            copyToClipboard(currentMarkdownSource);
        });

        JMenuItem selectAll = new JMenuItem("Select All");
        selectAll.addActionListener(e -> {
            if (isEditMode) {
                markdownEditArea.selectAll();
            } else {
                responseTextPane.selectAll();
            }
        });

        JMenuItem paste = new JMenuItem("Paste");
        paste.addActionListener(e -> {
            if (isEditMode) {
                markdownEditArea.paste();
            }
        });

        contextMenu.add(copyMarkdown);
        contextMenu.add(copyHtml);
        contextMenu.add(copyPlainText);
        contextMenu.addSeparator();
        contextMenu.add(copyAll);
        contextMenu.add(selectAll);
        contextMenu.addSeparator();
        contextMenu.add(paste);

        // Show paste only in edit mode
        contextMenu.addPopupMenuListener(new javax.swing.event.PopupMenuListener() {
            @Override
            public void popupMenuWillBecomeVisible(javax.swing.event.PopupMenuEvent e) {
                paste.setEnabled(isEditMode);
            }
            @Override
            public void popupMenuWillBecomeInvisible(javax.swing.event.PopupMenuEvent e) {}
            @Override
            public void popupMenuCanceled(javax.swing.event.PopupMenuEvent e) {}
        });

        responseTextPane.setComponentPopupMenu(contextMenu);
        markdownEditArea.setComponentPopupMenu(contextMenu);
    }

    /**
     * Get selected markdown text based on selection in view mode
     */
    private String getSelectedMarkdownText() {
        // If there's selected text in the response pane, try to map to markdown
        String selectedText = responseTextPane.getSelectedText();
        if (selectedText != null && !selectedText.isEmpty()) {
            // For now, return the selected text - could be enhanced to map to actual markdown
            return selectedText;
        }
        return currentMarkdownSource;
    }

    /**
     * Copy text to system clipboard
     */
    private void copyToClipboard(String text) {
        if (text != null && !text.isEmpty()) {
            try {
                Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
                clipboard.setContents(new StringSelection(text), null);
            } catch (Exception e) {
                Msg.error(this, "Failed to copy to clipboard: " + e.getMessage());
            }
        }
    }

    // Edit mode public methods

    /**
     * Set editable content for edit mode
     */
    public void setEditableContent(String markdown) {
        currentMarkdownSource = markdown;
        markdownEditArea.setText(markdown);
    }

    /**
     * Get the current editable content
     */
    public String getEditableContent() {
        return isEditMode ? markdownEditArea.getText() : currentMarkdownSource;
    }

    /**
     * Set the markdown source (for view mode)
     */
    public void setMarkdownSource(String markdown) {
        currentMarkdownSource = markdown;
    }

    /**
     * Get the current markdown source
     */
    public String getMarkdownSource() {
        return currentMarkdownSource;
    }

    /**
     * Check if currently in edit mode
     */
    public boolean isInEditMode() {
        return isEditMode;
    }

    /**
     * Exit edit mode without saving
     */
    public void exitEditMode() {
        if (isEditMode) {
            contentLayout.show(contentPanel, "view");
            editSaveButton.setText("Edit");
            isEditMode = false;
        }
    }

    /**
     * Get the MarkdownHelper instance
     */
    public MarkdownHelper getMarkdownHelper() {
        return markdownHelper;
    }

}

```

`src/main/java/ghidrassist/ui/tabs/RAGManagementTab.java`:

```java
package ghidrassist.ui.tabs;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import ghidrassist.core.RAGDocumentInfo;
import ghidrassist.core.SearchResult;
import ghidrassist.core.TabController;

import java.util.List;

public class RAGManagementTab extends JPanel {
    private static final long serialVersionUID = 1L;
    private final TabController controller;

    // Document Management section
    private JTable documentTable;
    private DefaultTableModel documentTableModel;
    private JLabel statsLabel;
    private JButton addButton;
    private JButton refreshButton;
    private JButton deleteButton;
    private JButton clearIndexButton;

    // Search Documents section
    private JTextField queryField;
    private JComboBox<String> searchTypeCombo;
    private JButton searchButton;
    private JLabel resultsHeaderLabel;
    private JPanel resultsPanel;

    // Split pane
    private JSplitPane mainSplitPane;

    public RAGManagementTab(TabController controller) {
        super(new BorderLayout());
        this.controller = controller;
        initializeComponents();
        layoutComponents();
        setupListeners();
    }

    private void initializeComponents() {
        // Document Management components
        addButton = new JButton("Add Documents");
        refreshButton = new JButton("Refresh");
        deleteButton = new JButton("Delete");
        clearIndexButton = new JButton("Clear Index");
        statsLabel = new JLabel("Documents: 0 | Chunks: 0 | Embeddings: 0");

        // Document table
        documentTableModel = new DefaultTableModel(new Object[]{"Name", "Size", "Chunks"}, 0) {
            private static final long serialVersionUID = 1L;
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };
        documentTable = new JTable(documentTableModel);
        documentTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        documentTable.setRowHeight(20);
        documentTable.getColumnModel().getColumn(0).setPreferredWidth(200);
        documentTable.getColumnModel().getColumn(1).setPreferredWidth(80);
        documentTable.getColumnModel().getColumn(2).setPreferredWidth(60);

        // Search components
        queryField = new JTextField(20);
        searchTypeCombo = new JComboBox<>(new String[]{"Hybrid", "Semantic", "Keyword"});
        searchButton = new JButton("Search");
        resultsHeaderLabel = new JLabel(" ");
        resultsPanel = new JPanel();
        resultsPanel.setLayout(new BoxLayout(resultsPanel, BoxLayout.Y_AXIS));
    }

    private void layoutComponents() {
        // === TOP SECTION: Document Management ===
        JPanel documentManagementPanel = new JPanel(new BorderLayout());

        // Section header
        JLabel docHeader = new JLabel("Document Management");
        docHeader.setFont(docHeader.getFont().deriveFont(Font.BOLD));
        docHeader.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        // Toolbar row: Add button + stats
        JPanel toolbarPanel = new JPanel(new BorderLayout());
        toolbarPanel.setBorder(BorderFactory.createEmptyBorder(2, 5, 2, 5));
        toolbarPanel.add(addButton, BorderLayout.WEST);
        toolbarPanel.add(statsLabel, BorderLayout.EAST);

        // Top section (header + toolbar)
        JPanel docTopPanel = new JPanel(new BorderLayout());
        docTopPanel.add(docHeader, BorderLayout.NORTH);
        docTopPanel.add(toolbarPanel, BorderLayout.SOUTH);

        // Bottom buttons
        JPanel docButtonPanel = new JPanel(new BorderLayout());
        docButtonPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
        JPanel leftButtons = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        leftButtons.add(refreshButton);
        leftButtons.add(deleteButton);
        JPanel rightButtons = new JPanel(new FlowLayout(FlowLayout.RIGHT, 5, 0));
        rightButtons.add(clearIndexButton);
        docButtonPanel.add(leftButtons, BorderLayout.WEST);
        docButtonPanel.add(rightButtons, BorderLayout.EAST);

        // Assemble document management panel
        documentManagementPanel.add(docTopPanel, BorderLayout.NORTH);
        documentManagementPanel.add(new JScrollPane(documentTable), BorderLayout.CENTER);
        documentManagementPanel.add(docButtonPanel, BorderLayout.SOUTH);

        // === BOTTOM SECTION: Search Documents ===
        JPanel searchPanel = new JPanel(new BorderLayout());

        // Section header
        JLabel searchHeader = new JLabel("Search Documents");
        searchHeader.setFont(searchHeader.getFont().deriveFont(Font.BOLD));
        searchHeader.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        // Search controls row
        JPanel searchControlsPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 5));
        searchControlsPanel.add(new JLabel("Query:"));
        searchControlsPanel.add(queryField);
        searchControlsPanel.add(new JLabel("Type:"));
        searchControlsPanel.add(searchTypeCombo);
        searchControlsPanel.add(searchButton);

        // Top section (header + controls)
        JPanel searchTopPanel = new JPanel(new BorderLayout());
        searchTopPanel.add(searchHeader, BorderLayout.NORTH);
        searchTopPanel.add(searchControlsPanel, BorderLayout.SOUTH);

        // Results container
        resultsHeaderLabel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
        resultsHeaderLabel.setFont(resultsHeaderLabel.getFont().deriveFont(Font.BOLD));

        JPanel resultsContainer = new JPanel(new BorderLayout());
        resultsContainer.add(resultsHeaderLabel, BorderLayout.NORTH);
        JScrollPane resultsScrollPane = new JScrollPane(resultsPanel);
        resultsScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        resultsContainer.add(resultsScrollPane, BorderLayout.CENTER);

        // Assemble search panel
        searchPanel.add(searchTopPanel, BorderLayout.NORTH);
        searchPanel.add(resultsContainer, BorderLayout.CENTER);

        // === MAIN SPLIT ===
        mainSplitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT,
                documentManagementPanel, searchPanel);
        mainSplitPane.setResizeWeight(0.6);

        // Set divider location to 60% after component is shown
        addHierarchyListener(e -> {
            if ((e.getChangeFlags() & java.awt.event.HierarchyEvent.SHOWING_CHANGED) != 0 && isShowing()) {
                SwingUtilities.invokeLater(() -> {
                    mainSplitPane.setDividerLocation(0.6);
                });
            }
        });

        add(mainSplitPane, BorderLayout.CENTER);
    }

    private void setupListeners() {
        addButton.addActionListener(e -> controller.handleAddDocuments());
        deleteButton.addActionListener(e -> {
            int selectedRow = documentTable.getSelectedRow();
            if (selectedRow >= 0) {
                String filename = (String) documentTableModel.getValueAt(selectedRow, 0);
                controller.handleDeleteDocument(filename);
            }
        });
        refreshButton.addActionListener(e -> controller.refreshRAGDocuments());
        clearIndexButton.addActionListener(e -> controller.handleClearIndex());
        searchButton.addActionListener(e -> {
            String query = queryField.getText().trim();
            String searchType = (String) searchTypeCombo.getSelectedItem();
            if (!query.isEmpty()) {
                controller.handleRAGSearch(query, searchType, this);
            }
        });

        // Allow Enter key to trigger search
        queryField.addActionListener(e -> searchButton.doClick());
    }

    /**
     * Update the document table with document info.
     */
    public void updateDocumentTable(List<RAGDocumentInfo> docs) {
        documentTableModel.setRowCount(0);
        for (RAGDocumentInfo doc : docs) {
            documentTableModel.addRow(new Object[]{
                    doc.getFilename(),
                    doc.getFormattedSize(),
                    doc.getChunkCount()
            });
        }
    }

    /**
     * Update the statistics label.
     */
    public void updateStats(int docCount, int chunkCount, int embeddingCount) {
        statsLabel.setText(String.format("Documents: %d | Chunks: %d | Embeddings: %d",
                docCount, chunkCount, embeddingCount));
    }

    /**
     * Display search results.
     */
    public void displaySearchResults(String query, List<SearchResult> results, String searchType) {
        resultsPanel.removeAll();

        if (results.isEmpty()) {
            resultsHeaderLabel.setText(String.format("Search Results for '%s' (0 found)", query));
            JLabel noResults = new JLabel("No results found.");
            noResults.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
            resultsPanel.add(noResults);
        } else {
            resultsHeaderLabel.setText(String.format("Search Results for '%s' (%d found)", query, results.size()));

            for (int i = 0; i < results.size(); i++) {
                SearchResult result = results.get(i);
                JPanel resultPanel = createResultPanel(i + 1, result, searchType);
                resultsPanel.add(resultPanel);
            }
        }

        resultsPanel.revalidate();
        resultsPanel.repaint();
    }

    /**
     * Create a panel for a single search result.
     */
    private JPanel createResultPanel(int index, SearchResult result, String searchType) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        panel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createMatteBorder(0, 0, 1, 0, Color.LIGHT_GRAY),
                BorderFactory.createEmptyBorder(5, 5, 5, 5)
        ));
        panel.setAlignmentX(Component.LEFT_ALIGNMENT);

        // Title: "1. filename.c"
        JLabel titleLabel = new JLabel(index + ". " + result.getFilename());
        titleLabel.setForeground(new Color(0, 102, 204)); // Blue color
        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD));
        titleLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        // Metadata: "Score: 60% | Type: hybrid | Chunk: 7"
        String meta = String.format("Score: %.0f%% | Type: %s | Chunk: %d",
                result.getScore() * 100, searchType.toLowerCase(), result.getChunkId());
        JLabel metaLabel = new JLabel(meta);
        metaLabel.setFont(metaLabel.getFont().deriveFont(Font.PLAIN, 10f));
        metaLabel.setForeground(Color.GRAY);
        metaLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        // Content preview (truncated)
        String snippet = result.getSnippet();
        if (snippet != null && snippet.length() > 150) {
            snippet = snippet.substring(0, 150) + "...";
        }
        // Replace newlines with spaces for display
        if (snippet != null) {
            snippet = snippet.replace("\n", " ").replace("\r", "");
        }
        JLabel contentLabel = new JLabel("<html>" + escapeHtml(snippet != null ? snippet : "") + "</html>");
        contentLabel.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 11));
        contentLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        panel.add(titleLabel);
        panel.add(Box.createVerticalStrut(2));
        panel.add(metaLabel);
        panel.add(Box.createVerticalStrut(2));
        panel.add(contentLabel);

        // Set max width
        panel.setMaximumSize(new Dimension(Integer.MAX_VALUE, panel.getPreferredSize().height + 20));

        return panel;
    }

    /**
     * Escape HTML special characters.
     */
    private String escapeHtml(String text) {
        return text.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace("\"", "&quot;");
    }

    /**
     * Clear search results.
     */
    public void clearSearchResults() {
        resultsHeaderLabel.setText(" ");
        resultsPanel.removeAll();
        resultsPanel.revalidate();
        resultsPanel.repaint();
    }

    /**
     * Get the document table for external access.
     */
    public JTable getDocumentTable() {
        return documentTable;
    }

    /**
     * Get selected document filename.
     */
    public String getSelectedDocument() {
        int selectedRow = documentTable.getSelectedRow();
        if (selectedRow >= 0) {
            return (String) documentTableModel.getValueAt(selectedRow, 0);
        }
        return null;
    }
}

```

`src/main/java/ghidrassist/ui/tabs/SemanticGraphTab.java`:

```java
package ghidrassist.ui.tabs;

import javax.swing.*;
import java.awt.*;
import ghidrassist.core.TabController;
import ghidrassist.ui.tabs.semanticgraph.ListViewPanel;
import ghidrassist.ui.tabs.semanticgraph.GraphViewPanel;
import ghidrassist.ui.tabs.semanticgraph.SearchViewPanel;
import ghidrassist.ui.tabs.semanticgraph.ManualAnalysisPanel;

/**
 * Semantic Graph tab for viewing and editing knowledge graph data.
 * Provides three sub-views:
 * - List View: Table/list-based display of callers, callees, edges, and security flags
 * - Visual Graph: Interactive node-edge diagram with configurable N-hop depth
 * - Search: Query interface for testing semantic search and graph queries
 */
public class SemanticGraphTab extends JPanel {
    private static final long serialVersionUID = 1L;

    private final TabController controller;

    // Header components
    private JTextField currentFunctionField;
    private JButton goButton;
    private JLabel statusLabel;

    // Sub-tab pane
    private JTabbedPane subTabbedPane;
    private ListViewPanel listViewPanel;
    private GraphViewPanel graphViewPanel;
    private SearchViewPanel searchViewPanel;
    private ManualAnalysisPanel manualAnalysisPanel;

    // Bottom panel components
    private JButton resetGraphButton;
    private JButton reindexButton;
    private JButton semanticAnalysisButton;
    private JLabel statsLabel;
    private JProgressBar progressBar;

    // State
    private String currentNodeId;
    private long currentAddress;

    public SemanticGraphTab(TabController controller) {
        super(new BorderLayout());
        this.controller = controller;
        initializeComponents();
        layoutComponents();
        setupListeners();
    }

    private void initializeComponents() {
        // Header components
        currentFunctionField = new JTextField(40);
        currentFunctionField.setEditable(true);
        currentFunctionField.setToolTipText("Current function or address (editable for navigation)");

        goButton = new JButton("Go");
        goButton.setToolTipText("Navigate to the entered function or address");

        statusLabel = new JLabel("Status: No program loaded");

        // Sub-tab pane for List View and Visual Graph
        subTabbedPane = new JTabbedPane();

        // Create sub-panels
        listViewPanel = new ListViewPanel(controller, this);
        graphViewPanel = new GraphViewPanel(controller, this);
        searchViewPanel = new SearchViewPanel(controller, this);
        manualAnalysisPanel = new ManualAnalysisPanel(this);

        // Bottom action buttons
        resetGraphButton = new JButton("Reset Graph");
        resetGraphButton.setToolTipText("Clear all graph data for this binary (requires confirmation)");

        reindexButton = new JButton("ReIndex Binary");
        reindexButton.setToolTipText("Rebuild the knowledge graph: Structure + Semantic + Security + Network analysis");

        semanticAnalysisButton = new JButton("Semantic Analysis");
        semanticAnalysisButton.setToolTipText("Use LLM to generate summaries for all stale/unsummarized nodes");

        statsLabel = new JLabel("Graph Stats: Not loaded");

        progressBar = new JProgressBar(0, 100);
        progressBar.setStringPainted(true);
        progressBar.setVisible(false);
    }

    private void layoutComponents() {
        // ===== Header Panel =====
        JPanel headerPanel = new JPanel(new BorderLayout(5, 5));
        headerPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        // Current function row
        JPanel functionRow = new JPanel(new BorderLayout(5, 0));
        JLabel currentLabel = new JLabel("Current:");
        functionRow.add(currentLabel, BorderLayout.WEST);
        functionRow.add(currentFunctionField, BorderLayout.CENTER);
        functionRow.add(goButton, BorderLayout.EAST);

        headerPanel.add(functionRow, BorderLayout.NORTH);
        headerPanel.add(statusLabel, BorderLayout.SOUTH);

        add(headerPanel, BorderLayout.NORTH);

        // ===== Sub-tabbed pane (List View / Visual Graph / Search / Manual Analysis) =====
        subTabbedPane.addTab("List View", listViewPanel);
        subTabbedPane.addTab("Visual Graph", graphViewPanel);
        subTabbedPane.addTab("Search", searchViewPanel);
        subTabbedPane.addTab("Manual Analysis", manualAnalysisPanel);

        add(subTabbedPane, BorderLayout.CENTER);

        // ===== Bottom Panel =====
        JPanel bottomPanel = new JPanel(new BorderLayout(5, 5));
        bottomPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        // Button row - main operations only
        JPanel buttonRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        buttonRow.add(resetGraphButton);
        buttonRow.add(reindexButton);
        buttonRow.add(semanticAnalysisButton);

        // Stats and progress row
        JPanel statusRow = new JPanel(new BorderLayout(5, 0));
        statusRow.add(statsLabel, BorderLayout.WEST);
        statusRow.add(progressBar, BorderLayout.CENTER);

        bottomPanel.add(buttonRow, BorderLayout.NORTH);
        bottomPanel.add(statusRow, BorderLayout.SOUTH);

        add(bottomPanel, BorderLayout.SOUTH);
    }

    private void setupListeners() {
        // Go button - navigate to function
        goButton.addActionListener(e -> handleGoButton());

        // Enter key in function field
        currentFunctionField.addActionListener(e -> handleGoButton());

        // Reset graph button
        resetGraphButton.addActionListener(e -> handleResetGraph());

        // ReIndex button
        reindexButton.addActionListener(e -> handleReindex());

        // Semantic Analysis button
        semanticAnalysisButton.addActionListener(e -> handleSemanticAnalysis());

        // Sub-tab change listener
        subTabbedPane.addChangeListener(e -> {
            // Refresh the selected view when switching tabs
            Component selected = subTabbedPane.getSelectedComponent();
            if (selected == graphViewPanel) {
                graphViewPanel.refresh();
            } else if (selected == searchViewPanel) {
                searchViewPanel.refresh();
            } else if (selected == manualAnalysisPanel) {
                manualAnalysisPanel.refresh();
            }
        });
    }

    // ===== Public Methods for External Updates =====

    /**
     * Update the displayed function/address when Ghidra cursor changes.
     * Called from TabController when location changes.
     *
     * @param address The new address
     * @param functionName The function name at that address (may be null)
     */
    public void updateLocation(long address, String functionName) {
        this.currentAddress = address;

        // Update the header field
        String displayText = functionName != null ?
                String.format("%s @ 0x%x", functionName, address) :
                String.format("0x%x", address);
        currentFunctionField.setText(displayText);

        // Refresh the current view
        refreshCurrentView();
    }

    /**
     * Update the status line with node information.
     *
     * @param indexed Whether the node is indexed
     * @param callerCount Number of callers
     * @param calleeCount Number of callees
     * @param flagCount Number of security flags
     */
    public void updateStatus(boolean indexed, int callerCount, int calleeCount, int flagCount) {
        if (indexed) {
            statusLabel.setText(String.format("Status: Indexed | %d callers | %d callees | %d security flags",
                    callerCount, calleeCount, flagCount));
        } else {
            statusLabel.setText("Status: Not Indexed");
        }
    }

    /**
     * Update the graph statistics display.
     *
     * @param nodeCount Total nodes in graph
     * @param edgeCount Total edges in graph
     * @param staleCount Number of stale nodes
     * @param lastIndexed Last indexing timestamp (may be null)
     */
    public void updateStats(int nodeCount, int edgeCount, int staleCount, String lastIndexed) {
        if (nodeCount == 0) {
            statsLabel.setText("Graph Stats: Not indexed");
        } else {
            String timestamp = lastIndexed != null ? lastIndexed : "unknown";
            statsLabel.setText(String.format("Graph Stats: %d nodes | %d edges | %d stale | Last indexed: %s",
                    nodeCount, edgeCount, staleCount, timestamp));
        }
    }

    /**
     * Get the current address being displayed.
     */
    public long getCurrentAddress() {
        return currentAddress;
    }

    /**
     * Get the current node ID (may be null if not indexed).
     */
    public String getCurrentNodeId() {
        return currentNodeId;
    }

    /**
     * Set the current node ID.
     */
    public void setCurrentNodeId(String nodeId) {
        this.currentNodeId = nodeId;
    }

    /**
     * Navigate to a different function (called from sub-panels).
     */
    public void navigateToFunction(long address) {
        controller.handleSemanticGraphNavigate(address);
    }

    /**
     * Refresh the currently visible sub-view.
     */
    public void refreshCurrentView() {
        if (subTabbedPane.getSelectedComponent() == listViewPanel) {
            listViewPanel.refresh();
        } else {
            graphViewPanel.refresh();
        }
    }

    // ===== Private Handler Methods =====

    private void handleGoButton() {
        String text = currentFunctionField.getText().trim();
        if (text.isEmpty()) {
            return;
        }

        // Try to parse as address or function name
        controller.handleSemanticGraphGo(text);
    }

    private void handleResetGraph() {
        int result = JOptionPane.showConfirmDialog(this,
                "Are you sure you want to reset the knowledge graph?\n" +
                "This will delete all indexed data for this binary.",
                "Reset Graph",
                JOptionPane.YES_NO_OPTION,
                JOptionPane.WARNING_MESSAGE);

        if (result == JOptionPane.YES_OPTION) {
            controller.handleSemanticGraphReset();
        }
    }

    private void handleReindex() {
        // If running, just stop (no confirmation needed)
        if (isReindexRunning()) {
            controller.handleSemanticGraphReindex();
            return;
        }

        // Otherwise confirm before starting
        int result = JOptionPane.showConfirmDialog(this,
                "ReIndex the entire binary?\n" +
                "This may take a while for large binaries.",
                "ReIndex Binary",
                JOptionPane.YES_NO_OPTION,
                JOptionPane.QUESTION_MESSAGE);

        if (result == JOptionPane.YES_OPTION) {
            controller.handleSemanticGraphReindex();
        }
    }

    private void handleSemanticAnalysis() {
        // If running, just stop (no confirmation needed)
        if (isSemanticAnalysisRunning()) {
            controller.handleSemanticGraphSemanticAnalysis();
            return;
        }

        // Otherwise confirm before starting
        int result = JOptionPane.showConfirmDialog(this,
                "Run Semantic Analysis on all stale nodes?\n" +
                "This will use the LLM to generate summaries for unsummarized functions.\n" +
                "This may take a while and consume API credits.",
                "Semantic Analysis",
                JOptionPane.YES_NO_OPTION,
                JOptionPane.QUESTION_MESSAGE);

        if (result == JOptionPane.YES_OPTION) {
            controller.handleSemanticGraphSemanticAnalysis();
        }
    }

    // ===== Manual Analysis Panel Handlers =====

    /**
     * Handle ReIndex from Manual Analysis panel.
     */
    public void handleReindexFromManual() {
        // If running, just stop (no confirmation needed)
        if (manualAnalysisPanel.isReindexRunning()) {
            controller.handleSemanticGraphReindex();
            return;
        }

        // Otherwise confirm before starting
        int result = JOptionPane.showConfirmDialog(this,
                "ReIndex the entire binary?\n" +
                "This will:\n" +
                "• Extract structure from Ghidra analysis\n" +
                "• Run Security Analysis (taint paths)\n" +
                "• Run Network Flow Analysis (send/recv tracing)\n\n" +
                "This may take a while for large binaries.",
                "ReIndex Binary",
                JOptionPane.YES_NO_OPTION,
                JOptionPane.QUESTION_MESSAGE);

        if (result == JOptionPane.YES_OPTION) {
            controller.handleSemanticGraphReindex();
        }
    }

    /**
     * Handle Semantic Analysis from Manual Analysis panel.
     */
    public void handleSemanticAnalysisFromManual() {
        // If running, just stop (no confirmation needed)
        if (manualAnalysisPanel.isSemanticAnalysisRunning()) {
            controller.handleSemanticGraphSemanticAnalysis();
            return;
        }

        // Otherwise confirm before starting
        int result = JOptionPane.showConfirmDialog(this,
                "Run Semantic Analysis on all stale nodes?\n" +
                "This will use the LLM to generate summaries for unsummarized functions.\n" +
                "This may take a while and consume API credits.",
                "Semantic Analysis",
                JOptionPane.YES_NO_OPTION,
                JOptionPane.QUESTION_MESSAGE);

        if (result == JOptionPane.YES_OPTION) {
            controller.handleSemanticGraphSemanticAnalysis();
        }
    }

    /**
     * Handle Security Analysis from Manual Analysis panel.
     */
    public void handleSecurityAnalysisFromManual() {
        // If running, just stop (no confirmation needed)
        if (manualAnalysisPanel.isSecurityAnalysisRunning()) {
            controller.handleSemanticGraphSecurityAnalysis();
            return;
        }

        // Otherwise confirm before starting
        int result = JOptionPane.showConfirmDialog(this,
                "Run Security Analysis?\n" +
                "This will:\n" +
                "• Find taint paths from sources (input) to sinks (dangerous functions)\n" +
                "• Create TAINT_FLOWS_TO edges along discovered paths\n" +
                "• Create VULNERABLE_VIA edges from entry points to vulnerable sinks\n\n" +
                "This requires an indexed binary.",
                "Security Analysis",
                JOptionPane.YES_NO_OPTION,
                JOptionPane.QUESTION_MESSAGE);

        if (result == JOptionPane.YES_OPTION) {
            controller.handleSemanticGraphSecurityAnalysis();
        }
    }

    /**
     * Handle Network Flow Analysis from Manual Analysis panel.
     */
    public void handleNetworkFlowFromManual() {
        // If running, just stop (no confirmation needed)
        if (manualAnalysisPanel.isNetworkFlowRunning()) {
            controller.handleSemanticGraphNetworkFlowAnalysis();
            return;
        }

        // Otherwise confirm before starting
        int result = JOptionPane.showConfirmDialog(this,
                "Run Network Flow Analysis?\n" +
                "This will:\n" +
                "• Find functions that call send/recv APIs (WSASend, recv, etc.)\n" +
                "• Create NETWORK_SEND edges from entry points to send functions\n" +
                "• Create NETWORK_RECV edges from recv functions to their callers\n\n" +
                "This requires an indexed binary.",
                "Network Flow Analysis",
                JOptionPane.YES_NO_OPTION,
                JOptionPane.QUESTION_MESSAGE);

        if (result == JOptionPane.YES_OPTION) {
            controller.handleSemanticGraphNetworkFlowAnalysis();
        }
    }

    /**
     * Handle Community Detection from Manual Analysis panel.
     */
    public void handleCommunityDetectionFromManual() {
        // If running, just stop (no confirmation needed)
        if (manualAnalysisPanel.isCommunityDetectionRunning()) {
            controller.handleSemanticGraphCommunityDetection();
            return;
        }

        // Otherwise confirm before starting
        int result = JOptionPane.showConfirmDialog(this,
                "Run Community Detection?\n" +
                "This will:\n" +
                "• Group related functions into communities using Label Propagation\n" +
                "• Create BELONGS_TO_COMMUNITY edges\n" +
                "• Generate summaries for each detected community\n\n" +
                "This requires an indexed binary.",
                "Community Detection",
                JOptionPane.YES_NO_OPTION,
                JOptionPane.QUESTION_MESSAGE);

        if (result == JOptionPane.YES_OPTION) {
            controller.handleSemanticGraphCommunityDetection();
        }
    }

    /**
     * Handle Refresh Names from Manual Analysis panel.
     */
    public void handleRefreshNamesFromManual() {
        controller.handleSemanticGraphRefreshNames();
    }

    /**
     * Show a "not indexed" placeholder in the content area.
     */
    public void showNotIndexedPlaceholder() {
        // This is handled by the sub-panels themselves
        listViewPanel.showNotIndexed();
        graphViewPanel.showNotIndexed();
    }

    /**
     * Get the TabController for sub-panels to use.
     */
    public TabController getController() {
        return controller;
    }

    // ===== Progress and Button State Management =====

    /**
     * Show progress bar with given percentage and message.
     */
    public void showProgress(int percent, String message) {
        progressBar.setVisible(true);
        progressBar.setValue(percent);
        progressBar.setString(message);
        progressBar.setIndeterminate(false);
    }

    /**
     * Show indeterminate progress bar with message.
     */
    public void showIndeterminateProgress(String message) {
        progressBar.setVisible(true);
        progressBar.setIndeterminate(true);
        progressBar.setString(message);
    }

    /**
     * Hide the progress bar.
     */
    public void hideProgress() {
        progressBar.setVisible(false);
        progressBar.setValue(0);
        progressBar.setString("");
        progressBar.setIndeterminate(false);
    }

    /**
     * Set reindex button to running state (shows "Stop" text).
     * Updates both bottom panel button and ManualAnalysisPanel button.
     */
    public void setReindexRunning(boolean running) {
        reindexButton.setText(running ? "Stop" : "ReIndex Binary");
        manualAnalysisPanel.setReindexRunning(running);
    }

    /**
     * Set semantic analysis button to running state (shows "Stop" text).
     * Updates both bottom panel button and ManualAnalysisPanel button.
     */
    public void setSemanticAnalysisRunning(boolean running) {
        semanticAnalysisButton.setText(running ? "Stop" : "Semantic Analysis");
        manualAnalysisPanel.setSemanticAnalysisRunning(running);
    }

    /**
     * Set security analysis button to running state (shows "Stop" text).
     * Delegates to ManualAnalysisPanel.
     */
    public void setSecurityAnalysisRunning(boolean running) {
        manualAnalysisPanel.setSecurityAnalysisRunning(running);
    }

    /**
     * Set refresh names button to running state (shows "Stop" text).
     * Delegates to ManualAnalysisPanel.
     */
    public void setRefreshNamesRunning(boolean running) {
        manualAnalysisPanel.setRefreshNamesRunning(running);
    }

    /**
     * Check if reindex is currently running.
     */
    public boolean isReindexRunning() {
        return "Stop".equals(reindexButton.getText());
    }

    /**
     * Check if semantic analysis is currently running.
     */
    public boolean isSemanticAnalysisRunning() {
        return "Stop".equals(semanticAnalysisButton.getText());
    }

    /**
     * Check if security analysis is currently running.
     * Delegates to ManualAnalysisPanel.
     */
    public boolean isSecurityAnalysisRunning() {
        return manualAnalysisPanel.isSecurityAnalysisRunning();
    }

    /**
     * Check if refresh names is currently running.
     * Delegates to ManualAnalysisPanel.
     */
    public boolean isRefreshNamesRunning() {
        return manualAnalysisPanel.isRefreshNamesRunning();
    }

    /**
     * Set network flow analysis button to running state (shows "Stop" text).
     * Delegates to ManualAnalysisPanel.
     */
    public void setNetworkFlowRunning(boolean running) {
        manualAnalysisPanel.setNetworkFlowRunning(running);
    }

    /**
     * Check if network flow analysis is currently running.
     * Delegates to ManualAnalysisPanel.
     */
    public boolean isNetworkFlowRunning() {
        return manualAnalysisPanel.isNetworkFlowRunning();
    }

    /**
     * Set community detection button to running state (shows "Stop" text).
     * Delegates to ManualAnalysisPanel.
     */
    public void setCommunityDetectionRunning(boolean running) {
        manualAnalysisPanel.setCommunityDetectionRunning(running);
    }

    /**
     * Check if community detection is currently running.
     * Delegates to ManualAnalysisPanel.
     */
    public boolean isCommunityDetectionRunning() {
        return manualAnalysisPanel.isCommunityDetectionRunning();
    }
}

```

`src/main/java/ghidrassist/ui/tabs/SettingsTab.java`:

```java
package ghidrassist.ui.tabs;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.image.BufferedImage;
import java.io.File;
import java.lang.reflect.Type;
import java.util.List;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

import ghidra.framework.preferences.Preferences;
import ghidrassist.GhidrAssistPlugin;
import ghidrassist.LlmApi;
import ghidrassist.apiprovider.APIProvider;
import ghidrassist.apiprovider.APIProviderConfig;
import ghidrassist.core.TabController;
import ghidrassist.ui.GhidrAssistUI;
import ghidrassist.mcp2.server.MCPServerConfig;
import ghidrassist.mcp2.server.MCPServerRegistry;
import ghidrassist.services.symgraph.SymGraphService;
import ghidrassist.apiprovider.oauth.OAuthCallbackServer;
import ghidrassist.apiprovider.oauth.OAuthTokenManager;
import ghidrassist.apiprovider.oauth.OpenAIOAuthTokenManager;
import ghidrassist.apiprovider.oauth.GeminiOAuthTokenManager;

/**
 * Unified Settings tab matching BinAssist's layout.
 * Contains all settings in scrollable grouped sections:
 * - LLM Providers
 * - MCP Servers
 * - SymGraph
 * - System Prompt
 * - Database Paths
 * - Analysis Options
 */
public class SettingsTab extends JPanel {
    private static final long serialVersionUID = 1L;
    private static final String VERSION = "1.17.0";
    private static final String[] REASONING_EFFORT_OPTIONS = {"None", "Low", "Medium", "High"};

    private final TabController controller;
    private final GhidrAssistPlugin plugin;

    // LLM Providers section components
    private DefaultTableModel llmTableModel;
    private JTable llmTable;
    private JComboBox<String> activeProviderComboBox;
    private JComboBox<String> reasoningEffortCombo;
    private List<APIProviderConfig> apiProviders;
    private String selectedProviderName;

    // MCP Servers section components
    private JTable mcpServersTable;
    private MCPServersTableModel mcpTableModel;

    // SymGraph section components
    private JTextField symGraphUrlField;
    private JPasswordField symGraphKeyField;
    private JButton showKeyButton;
    private JButton symGraphTestButton;
    private JLabel symGraphTestStatusLabel;
    private boolean keyVisible = false;

    // System Prompt section components
    private JTextArea contextArea;
    private JButton saveButton;
    private JButton revertButton;

    // Database Paths section components
    private JTextField analysisDbPathField;
    private JTextField rlhfDbPathField;
    private JTextField luceneIndexPathField;

    // Analysis Options section components
    private JSpinner maxToolCallsSpinner;
    private JTextField apiTimeoutField;

    // Test status indicators
    private JButton llmTestButton;
    private JLabel llmTestStatusLabel;
    private JButton mcpTestButton;
    private JLabel mcpTestStatusLabel;
    private ImageIcon successIcon;
    private ImageIcon failureIcon;

    public SettingsTab(TabController controller) {
        super(new BorderLayout());
        this.controller = controller;
        this.plugin = controller.getPlugin();

        loadApiProviders();
        initializeComponents();
        layoutComponents();
        setupListeners();
        loadSettings();
    }

    private void loadApiProviders() {
        String providersJson = Preferences.getProperty("GhidrAssist.APIProviders", "[]");
        Gson gson = new Gson();
        Type listType = new TypeToken<List<APIProviderConfig>>() {}.getType();
        apiProviders = gson.fromJson(providersJson, listType);
        selectedProviderName = Preferences.getProperty("GhidrAssist.SelectedAPIProvider", "");
    }

    private void initializeComponents() {
        // Create test status icons
        successIcon = createSuccessIcon();
        failureIcon = createFailureIcon();

        // Test status labels
        llmTestStatusLabel = new JLabel();
        llmTestStatusLabel.setPreferredSize(new Dimension(20, 20));
        mcpTestStatusLabel = new JLabel();
        mcpTestStatusLabel.setPreferredSize(new Dimension(20, 20));

        // LLM Providers
        String[] llmColumnNames = {"Name", "Model", "Max Tokens", "URL", "Key", "Disable TLS"};
        llmTableModel = new DefaultTableModel(llmColumnNames, 0) {
            private static final long serialVersionUID = 1L;
            @Override
            public Class<?> getColumnClass(int column) {
                return column == 5 ? Boolean.class : String.class;
            }
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };
        llmTable = new JTable(llmTableModel);
        llmTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);

        activeProviderComboBox = new JComboBox<>();
        reasoningEffortCombo = new JComboBox<>(REASONING_EFFORT_OPTIONS);
        reasoningEffortCombo.setToolTipText(
            "Extended thinking for complex queries\n" +
            "None: Standard response (default)\n" +
            "Low: ~2K thinking tokens\n" +
            "Medium: ~10K thinking tokens\n" +
            "High: ~25K thinking tokens"
        );

        // Populate LLM table and combo
        for (APIProviderConfig provider : apiProviders) {
            llmTableModel.addRow(new Object[] {
                provider.getName(),
                provider.getModel(),
                provider.getMaxTokens(),
                provider.getUrl(),
                maskApiKey(provider.getKey()),
                provider.isDisableTlsVerification()
            });
            activeProviderComboBox.addItem(provider.getName());
        }
        activeProviderComboBox.setSelectedItem(selectedProviderName);

        // MCP Servers
        mcpTableModel = new MCPServersTableModel();
        mcpServersTable = new JTable(mcpTableModel);
        mcpServersTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        mcpServersTable.getColumnModel().getColumn(0).setPreferredWidth(150);
        mcpServersTable.getColumnModel().getColumn(1).setPreferredWidth(300);
        mcpServersTable.getColumnModel().getColumn(2).setPreferredWidth(80);
        mcpServersTable.getColumnModel().getColumn(3).setPreferredWidth(100);

        // SymGraph
        symGraphUrlField = new JTextField(30);
        symGraphKeyField = new JPasswordField(30);
        showKeyButton = new JButton("Show");
        symGraphTestButton = new JButton("Test");
        symGraphTestStatusLabel = new JLabel();
        symGraphTestStatusLabel.setPreferredSize(new Dimension(20, 20));

        // System Prompt
        contextArea = new JTextArea();
        contextArea.setFont(new Font("Monospaced", Font.PLAIN, 12));
        contextArea.setLineWrap(true);
        contextArea.setWrapStyleWord(true);
        saveButton = new JButton("Save");
        revertButton = new JButton("Revert");

        // Database Paths
        analysisDbPathField = new JTextField(30);
        rlhfDbPathField = new JTextField(30);
        luceneIndexPathField = new JTextField(30);

        // Analysis Options
        SpinnerNumberModel spinnerModel = new SpinnerNumberModel(10, 1, 50, 1);
        maxToolCallsSpinner = new JSpinner(spinnerModel);
        maxToolCallsSpinner.setPreferredSize(new Dimension(75, maxToolCallsSpinner.getPreferredSize().height));
        maxToolCallsSpinner.setToolTipText("Maximum tool calls per iteration (default: 10)");

        apiTimeoutField = new JTextField(5);
        apiTimeoutField.setToolTipText("API timeout in seconds");
    }

    private void layoutComponents() {
        // Create scroll area
        JPanel contentPanel = new JPanel();
        contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
        contentPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // Add sections
        contentPanel.add(createLLMProvidersSection());
        contentPanel.add(Box.createVerticalStrut(10));
        contentPanel.add(createMCPServersSection());
        if (GhidrAssistUI.isSymGraphEnabled()) {
            contentPanel.add(Box.createVerticalStrut(10));
            contentPanel.add(createSymGraphSection());
        }
        contentPanel.add(Box.createVerticalStrut(10));
        contentPanel.add(createSystemPromptSection());
        contentPanel.add(Box.createVerticalStrut(10));
        contentPanel.add(createDatabasePathsSection());
        contentPanel.add(Box.createVerticalStrut(10));
        contentPanel.add(createAnalysisOptionsSection());
        contentPanel.add(Box.createVerticalGlue());

        JScrollPane scrollPane = new JScrollPane(contentPanel);
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.getVerticalScrollBar().setUnitIncrement(16);

        add(scrollPane, BorderLayout.CENTER);

        // Bottom panel with version
        JPanel bottomPanel = new JPanel(new BorderLayout());
        JLabel versionLabel = new JLabel("GhidrAssist v" + VERSION);
        versionLabel.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 5));
        bottomPanel.add(versionLabel, BorderLayout.WEST);
        add(bottomPanel, BorderLayout.SOUTH);
    }

    private JPanel createLLMProvidersSection() {
        JPanel panel = new JPanel(new BorderLayout());
        panel.setBorder(BorderFactory.createTitledBorder("LLM Providers"));

        // Table
        llmTable.getColumnModel().getColumn(5).setCellRenderer(llmTable.getDefaultRenderer(Boolean.class));
        JScrollPane tableScrollPane = new JScrollPane(llmTable);
        tableScrollPane.setPreferredSize(new Dimension(600, 120));

        // Buttons
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        JButton addButton = new JButton("Add");
        JButton editButton = new JButton("Edit");
        JButton duplicateButton = new JButton("Duplicate");
        JButton deleteButton = new JButton("Delete");
        llmTestButton = new JButton("Test");

        addButton.addActionListener(e -> onAddProvider());
        editButton.addActionListener(e -> onEditProvider());
        duplicateButton.addActionListener(e -> onDuplicateProvider());
        deleteButton.addActionListener(e -> onDeleteProvider());
        llmTestButton.addActionListener(e -> onTestProvider());

        buttonPanel.add(addButton);
        buttonPanel.add(editButton);
        buttonPanel.add(duplicateButton);
        buttonPanel.add(deleteButton);
        buttonPanel.add(llmTestButton);
        buttonPanel.add(llmTestStatusLabel);

        // Active provider and reasoning effort
        JPanel selectionPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        selectionPanel.add(new JLabel("Active Provider:"));
        activeProviderComboBox.setMaximumSize(new Dimension(200, activeProviderComboBox.getPreferredSize().height));
        selectionPanel.add(activeProviderComboBox);
        selectionPanel.add(Box.createHorizontalStrut(20));
        selectionPanel.add(new JLabel("Reasoning Effort:"));
        selectionPanel.add(reasoningEffortCombo);

        JPanel southPanel = new JPanel();
        southPanel.setLayout(new BoxLayout(southPanel, BoxLayout.Y_AXIS));
        southPanel.add(buttonPanel);
        southPanel.add(selectionPanel);

        panel.add(tableScrollPane, BorderLayout.CENTER);
        panel.add(southPanel, BorderLayout.SOUTH);

        return panel;
    }

    private JPanel createMCPServersSection() {
        JPanel panel = new JPanel(new BorderLayout());
        panel.setBorder(BorderFactory.createTitledBorder("MCP Servers"));

        JScrollPane tableScrollPane = new JScrollPane(mcpServersTable);
        tableScrollPane.setPreferredSize(new Dimension(600, 100));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        JButton addButton = new JButton("Add Server");
        JButton editButton = new JButton("Edit");
        JButton duplicateButton = new JButton("Duplicate");
        JButton removeButton = new JButton("Remove");
        mcpTestButton = new JButton("Test Connection");

        addButton.addActionListener(e -> showMCPAddEditDialog(null));
        editButton.addActionListener(e -> {
            int row = mcpServersTable.getSelectedRow();
            if (row >= 0) showMCPAddEditDialog(mcpTableModel.getServerAt(row));
        });
        duplicateButton.addActionListener(e -> onDuplicateMCPServer());
        removeButton.addActionListener(e -> onRemoveMCPServer());
        mcpTestButton.addActionListener(e -> onTestMCPServer());

        buttonPanel.add(addButton);
        buttonPanel.add(editButton);
        buttonPanel.add(duplicateButton);
        buttonPanel.add(removeButton);
        buttonPanel.add(mcpTestButton);
        buttonPanel.add(mcpTestStatusLabel);

        panel.add(tableScrollPane, BorderLayout.CENTER);
        panel.add(buttonPanel, BorderLayout.SOUTH);

        return panel;
    }

    private JPanel createSymGraphSection() {
        JPanel panel = new JPanel();
        panel.setBorder(BorderFactory.createTitledBorder("SymGraph"));
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));

        // API URL row
        JPanel urlRow = new JPanel(new FlowLayout(FlowLayout.LEFT));
        urlRow.add(new JLabel("API URL:"));
        symGraphUrlField.setText(Preferences.getProperty("GhidrAssist.SymGraphAPIUrl", "https://api.symgraph.com"));
        symGraphUrlField.setToolTipText("SymGraph API URL (for self-hosted instances)");
        urlRow.add(symGraphUrlField);

        // API Key row
        JPanel keyRow = new JPanel(new FlowLayout(FlowLayout.LEFT));
        keyRow.add(new JLabel("API Key:"));
        symGraphKeyField.setText(Preferences.getProperty("GhidrAssist.SymGraphAPIKey", ""));
        symGraphKeyField.setToolTipText("Your SymGraph API key (required for push/pull operations)");
        keyRow.add(symGraphKeyField);
        keyRow.add(showKeyButton);
        keyRow.add(symGraphTestButton);
        keyRow.add(symGraphTestStatusLabel);

        // Info label
        JLabel infoLabel = new JLabel("<html><i>SymGraph provides cloud-based symbol and graph data sharing. " +
                                      "Query operations are free; push/pull require an API key.</i></html>");
        infoLabel.setForeground(Color.GRAY);
        JPanel infoRow = new JPanel(new FlowLayout(FlowLayout.LEFT));
        infoRow.add(infoLabel);

        panel.add(urlRow);
        panel.add(keyRow);
        panel.add(infoRow);

        return panel;
    }

    private JPanel createSystemPromptSection() {
        JPanel panel = new JPanel(new BorderLayout());
        panel.setBorder(BorderFactory.createTitledBorder("System Prompt"));

        JScrollPane scrollPane = new JScrollPane(contextArea);
        scrollPane.setPreferredSize(new Dimension(600, 100));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        buttonPanel.add(revertButton);
        buttonPanel.add(saveButton);

        panel.add(scrollPane, BorderLayout.CENTER);
        panel.add(buttonPanel, BorderLayout.SOUTH);

        return panel;
    }

    private JPanel createDatabasePathsSection() {
        JPanel panel = new JPanel();
        panel.setBorder(BorderFactory.createTitledBorder("Database Paths"));
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));

        // Analysis DB
        JPanel analysisRow = new JPanel(new FlowLayout(FlowLayout.LEFT));
        analysisRow.add(new JLabel("Analysis DB:"));
        analysisDbPathField.setText(Preferences.getProperty("GhidrAssist.AnalysisDBPath", "ghidrassist_analysis.db"));
        analysisRow.add(analysisDbPathField);
        JButton analysisDbBrowse = new JButton("Browse...");
        analysisDbBrowse.addActionListener(e -> browseFile(analysisDbPathField, "Select Analysis Database", false));
        analysisRow.add(analysisDbBrowse);

        // RLHF DB
        JPanel rlhfRow = new JPanel(new FlowLayout(FlowLayout.LEFT));
        rlhfRow.add(new JLabel("RLHF DB:"));
        rlhfDbPathField.setText(Preferences.getProperty("GhidrAssist.RLHFDatabasePath", "ghidrassist_rlhf.db"));
        rlhfRow.add(rlhfDbPathField);
        JButton rlhfDbBrowse = new JButton("Browse...");
        rlhfDbBrowse.addActionListener(e -> browseFile(rlhfDbPathField, "Select RLHF Database", false));
        rlhfRow.add(rlhfDbBrowse);

        // Lucene Index
        JPanel luceneRow = new JPanel(new FlowLayout(FlowLayout.LEFT));
        luceneRow.add(new JLabel("RAG Index:"));
        luceneIndexPathField.setText(Preferences.getProperty("GhidrAssist.LuceneIndexPath", "ghidrassist_lucene"));
        luceneRow.add(luceneIndexPathField);
        JButton luceneBrowse = new JButton("Browse...");
        luceneBrowse.addActionListener(e -> browseFile(luceneIndexPathField, "Select RAG Index Directory", true));
        luceneRow.add(luceneBrowse);

        panel.add(analysisRow);
        panel.add(rlhfRow);
        panel.add(luceneRow);

        return panel;
    }

    private JPanel createAnalysisOptionsSection() {
        JPanel panel = new JPanel();
        panel.setBorder(BorderFactory.createTitledBorder("Analysis Options"));
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));

        // Max Tool Calls
        JPanel toolCallsRow = new JPanel(new FlowLayout(FlowLayout.LEFT));
        toolCallsRow.add(new JLabel("Max Tool Calls/Iteration:"));
        toolCallsRow.add(maxToolCallsSpinner);

        // API Timeout
        JPanel timeoutRow = new JPanel(new FlowLayout(FlowLayout.LEFT));
        timeoutRow.add(new JLabel("API Timeout (seconds):"));
        apiTimeoutField.setText(Preferences.getProperty("GhidrAssist.APITimeout", "120"));
        timeoutRow.add(apiTimeoutField);

        panel.add(toolCallsRow);
        panel.add(timeoutRow);

        return panel;
    }

    private void setupListeners() {
        // Active provider change
        activeProviderComboBox.addActionListener(e -> {
            String item = (String) activeProviderComboBox.getSelectedItem();
            selectedProviderName = (item != null) ? item : "";
            Preferences.setProperty("GhidrAssist.SelectedAPIProvider", selectedProviderName);
            Preferences.store();
        });

        // Reasoning effort change
        reasoningEffortCombo.addActionListener(e -> {
            String selectedEffort = (String) reasoningEffortCombo.getSelectedItem();
            controller.setReasoningEffort(selectedEffort);
        });

        // Max tool calls change
        maxToolCallsSpinner.addChangeListener(e -> {
            int maxToolCalls = (Integer) maxToolCallsSpinner.getValue();
            controller.setMaxToolCalls(maxToolCalls);
        });

        // SymGraph key visibility toggle
        showKeyButton.addActionListener(e -> {
            keyVisible = !keyVisible;
            if (keyVisible) {
                symGraphKeyField.setEchoChar((char) 0);
                showKeyButton.setText("Hide");
            } else {
                symGraphKeyField.setEchoChar('*');
                showKeyButton.setText("Show");
            }
        });

        // SymGraph URL/Key save on focus lost
        symGraphUrlField.addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {}
            @Override
            public void focusLost(FocusEvent e) {
                Preferences.setProperty("GhidrAssist.SymGraphAPIUrl", symGraphUrlField.getText().trim());
                Preferences.store();
            }
        });
        symGraphKeyField.addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {}
            @Override
            public void focusLost(FocusEvent e) {
                Preferences.setProperty("GhidrAssist.SymGraphAPIKey", new String(symGraphKeyField.getPassword()));
                Preferences.store();
            }
        });

        // SymGraph Test button
        symGraphTestButton.addActionListener(e -> onTestSymGraph());

        // Database paths save on focus lost
        analysisDbPathField.addFocusListener(createPathFocusListener("GhidrAssist.AnalysisDBPath"));
        rlhfDbPathField.addFocusListener(createPathFocusListener("GhidrAssist.RLHFDatabasePath"));
        luceneIndexPathField.addFocusListener(createPathFocusListener("GhidrAssist.LuceneIndexPath"));

        // API timeout save on focus lost
        apiTimeoutField.addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {}
            @Override
            public void focusLost(FocusEvent e) {
                Preferences.setProperty("GhidrAssist.APITimeout", apiTimeoutField.getText().trim());
                Preferences.store();
            }
        });

        // System prompt buttons
        saveButton.addActionListener(e -> controller.handleContextSave(contextArea.getText()));
        revertButton.addActionListener(e -> controller.handleContextRevert());
    }

    private FocusListener createPathFocusListener(String preferenceKey) {
        return new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {}
            @Override
            public void focusLost(FocusEvent e) {
                JTextField field = (JTextField) e.getSource();
                Preferences.setProperty(preferenceKey, field.getText().trim());
                Preferences.store();
            }
        };
    }

    private void loadSettings() {
        // Load reasoning effort
        String savedEffort = controller.getReasoningEffort();
        if (savedEffort != null) {
            reasoningEffortCombo.setSelectedItem(savedEffort);
        }

        // Load max tool calls
        int savedMaxToolCalls = controller.getMaxToolCalls();
        maxToolCallsSpinner.setValue(savedMaxToolCalls);
    }

    public void setContextText(String text) {
        contextArea.setText(text);
    }

    public void loadReasoningEffort() {
        String savedEffort = controller.getReasoningEffort();
        if (savedEffort != null) {
            reasoningEffortCombo.setSelectedItem(savedEffort);
        }
    }

    public void loadMaxToolCalls() {
        int savedMaxToolCalls = controller.getMaxToolCalls();
        maxToolCallsSpinner.setValue(savedMaxToolCalls);
    }

    // ==== LLM Provider Operations ====

    private void onAddProvider() {
        APIProviderConfig newProvider = new APIProviderConfig(
            "", APIProvider.ProviderType.OPENAI_PLATFORM_API, "", 16384, "", "", false
        );
        if (openProviderDialog(newProvider)) {
            apiProviders.add(newProvider);
            llmTableModel.addRow(new Object[] {
                newProvider.getName(),
                newProvider.getModel(),
                newProvider.getMaxTokens(),
                newProvider.getUrl(),
                maskApiKey(newProvider.getKey()),
                newProvider.isDisableTlsVerification()
            });
            activeProviderComboBox.addItem(newProvider.getName());
            saveProviders();
        }
    }

    private void onEditProvider() {
        int selectedRow = llmTable.getSelectedRow();
        if (selectedRow < 0) {
            JOptionPane.showMessageDialog(this, "Please select a provider to edit.", "No Selection", JOptionPane.WARNING_MESSAGE);
            return;
        }
        APIProviderConfig provider = apiProviders.get(selectedRow);
        APIProviderConfig editedProvider = new APIProviderConfig(
            provider.getName(), provider.getType(), provider.getModel(),
            provider.getMaxTokens(), provider.getUrl(), provider.getKey(),
            provider.isDisableTlsVerification()
        );
        if (openProviderDialog(editedProvider)) {
            provider.setName(editedProvider.getName());
            provider.setType(editedProvider.getType());
            provider.setModel(editedProvider.getModel());
            provider.setMaxTokens(editedProvider.getMaxTokens());
            provider.setUrl(editedProvider.getUrl());
            provider.setKey(editedProvider.getKey());
            provider.setDisableTlsVerification(editedProvider.isDisableTlsVerification());

            llmTableModel.setValueAt(provider.getName(), selectedRow, 0);
            llmTableModel.setValueAt(provider.getModel(), selectedRow, 1);
            llmTableModel.setValueAt(provider.getMaxTokens(), selectedRow, 2);
            llmTableModel.setValueAt(provider.getUrl(), selectedRow, 3);
            llmTableModel.setValueAt(maskApiKey(provider.getKey()), selectedRow, 4);
            llmTableModel.setValueAt(provider.isDisableTlsVerification(), selectedRow, 5);

            activeProviderComboBox.removeItemAt(selectedRow);
            activeProviderComboBox.insertItemAt(provider.getName(), selectedRow);
            saveProviders();
        }
    }

    private void onDuplicateProvider() {
        int row = llmTable.getSelectedRow();
        if (row < 0) {
            JOptionPane.showMessageDialog(this, "Please select a provider to duplicate.", "No Selection", JOptionPane.WARNING_MESSAGE);
        } else {
            APIProviderConfig provider = apiProviders.get(row).copy();
            provider.setName(provider.getName() + " - Copy");
            apiProviders.add(provider);
            llmTableModel.addRow(new Object[] {
                    provider.getName(),
                    provider.getModel(),
                    provider.getMaxTokens(),
                    provider.getUrl(),
                    maskApiKey(provider.getKey()),
                    provider.isDisableTlsVerification()
            });
            activeProviderComboBox.addItem(provider.getName());
            saveProviders();
        }
    }

    private void onDeleteProvider() {
        int selectedRow = llmTable.getSelectedRow();
        if (selectedRow < 0) {
            JOptionPane.showMessageDialog(this, "Please select a provider to delete.", "No Selection", JOptionPane.WARNING_MESSAGE);
            return;
        }
        int result = JOptionPane.showConfirmDialog(this, "Are you sure you want to delete the selected provider?", "Confirm Delete", JOptionPane.YES_NO_OPTION);
        if (result == JOptionPane.YES_OPTION) {
            APIProviderConfig provider = apiProviders.get(selectedRow);
            apiProviders.remove(selectedRow);
            llmTableModel.removeRow(selectedRow);
            activeProviderComboBox.removeItemAt(selectedRow);
            if (selectedProviderName.equals(provider.getName())) {
                selectedProviderName = "";
                activeProviderComboBox.setSelectedItem(selectedProviderName);
            }
            saveProviders();
        }
    }

    private void onTestProvider() {
        int selectedRow = llmTable.getSelectedRow();
        if (selectedRow < 0) {
            llmTestStatusLabel.setIcon(failureIcon);
            llmTestStatusLabel.setToolTipText("No provider selected in table");
            JOptionPane.showMessageDialog(this, "Please select a provider in the table to test.", "No Selection", JOptionPane.WARNING_MESSAGE);
            return;
        }

        final APIProviderConfig testProvider = apiProviders.get(selectedRow);

        // Show testing state
        llmTestButton.setEnabled(false);
        llmTestStatusLabel.setIcon(null);
        llmTestStatusLabel.setText("...");
        llmTestStatusLabel.setToolTipText("Testing connection...");

        SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {
            private String errorMessage = "";

            @Override
            protected Boolean doInBackground() {
                try {
                    LlmApi testApi = new LlmApi(testProvider, plugin);
                    String testPrompt = "Testing connection. Please respond with 'OK' and nothing else.";
                    final boolean[] success = {false};

                    testApi.sendRequestAsync(testPrompt, new LlmApi.LlmResponseHandler() {
                        @Override
                        public void onStart() {}
                        @Override
                        public void onUpdate(String partialResponse) {}
                        @Override
                        public void onComplete(String fullResponse) {
                            success[0] = true;
                        }
                        @Override
                        public void onError(Throwable error) {
                            errorMessage = error.getMessage();
                        }
                    });

                    // Wait briefly for async response
                    Thread.sleep(5000);
                    return success[0];
                } catch (Exception e) {
                    errorMessage = e.getMessage();
                    return false;
                }
            }

            @Override
            protected void done() {
                llmTestButton.setEnabled(true);
                llmTestStatusLabel.setText("");
                try {
                    if (get()) {
                        llmTestStatusLabel.setIcon(successIcon);
                        llmTestStatusLabel.setToolTipText("Connection successful");
                    } else {
                        llmTestStatusLabel.setIcon(failureIcon);
                        llmTestStatusLabel.setToolTipText("Connection failed: " + errorMessage);
                    }
                } catch (Exception e) {
                    llmTestStatusLabel.setIcon(failureIcon);
                    llmTestStatusLabel.setToolTipText("Test error: " + e.getMessage());
                }
            }
        };
        worker.execute();
    }

    private boolean openProviderDialog(APIProviderConfig provider) {
        JTextField nameField = new JTextField(provider.getName(), 20);
        JTextField modelField = new JTextField(provider.getModel(), 20);
        JTextField maxTokensField = new JTextField(String.valueOf(provider.getMaxTokens()), 20);
        JTextField urlField = new JTextField(provider.getUrl(), 20);
        JTextField keyField = new JTextField(provider.getKey(), 20);
        JComboBox<APIProvider.ProviderType> typeComboBox = new JComboBox<>(APIProvider.ProviderType.values());
        typeComboBox.setSelectedItem(provider.getType());
        JCheckBox disableTlsCheckbox = new JCheckBox("Disable TLS Verification", provider.isDisableTlsVerification());
        
        // OAuth-specific components
        JLabel urlLabel = new JLabel("URL:");
        JLabel keyLabel = new JLabel("Key:");
        JButton authenticateButton = new JButton("Authenticate");
        JLabel oauthNoteLabel = new JLabel("<html><i>Click 'Authenticate' to sign in with Claude Pro/Max subscription.</i></html>");
        oauthNoteLabel.setForeground(Color.GRAY);
        
        // Claude Code note
        JLabel claudeCodeNoteLabel = new JLabel("<html><i>Requires 'claude' CLI installed and authenticated.<br>Install: npm install -g @anthropic-ai/claude-code</i></html>");
        claudeCodeNoteLabel.setForeground(Color.GRAY);

        // Panel with GridBagLayout for more control
        JPanel panel = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(4, 4, 4, 4);
        gbc.anchor = GridBagConstraints.WEST;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        
        int row = 0;
        
        // Name
        gbc.gridx = 0; gbc.gridy = row; gbc.weightx = 0;
        panel.add(new JLabel("Name:"), gbc);
        gbc.gridx = 1; gbc.weightx = 1; gbc.gridwidth = 2;
        panel.add(nameField, gbc);
        gbc.gridwidth = 1;
        row++;
        
        // Type
        gbc.gridx = 0; gbc.gridy = row; gbc.weightx = 0;
        panel.add(new JLabel("Type:"), gbc);
        gbc.gridx = 1; gbc.weightx = 1; gbc.gridwidth = 2;
        panel.add(typeComboBox, gbc);
        gbc.gridwidth = 1;
        row++;
        
        // Model
        gbc.gridx = 0; gbc.gridy = row; gbc.weightx = 0;
        panel.add(new JLabel("Model:"), gbc);
        gbc.gridx = 1; gbc.weightx = 1; gbc.gridwidth = 2;
        panel.add(modelField, gbc);
        gbc.gridwidth = 1;
        row++;
        
        // Max Tokens
        gbc.gridx = 0; gbc.gridy = row; gbc.weightx = 0;
        panel.add(new JLabel("Max Tokens:"), gbc);
        gbc.gridx = 1; gbc.weightx = 1; gbc.gridwidth = 2;
        panel.add(maxTokensField, gbc);
        gbc.gridwidth = 1;
        row++;
        
        // URL (hidden for OAuth)
        gbc.gridx = 0; gbc.gridy = row; gbc.weightx = 0;
        panel.add(urlLabel, gbc);
        gbc.gridx = 1; gbc.weightx = 1; gbc.gridwidth = 2;
        panel.add(urlField, gbc);
        gbc.gridwidth = 1;
        row++;
        
        // Key with optional Authenticate button
        gbc.gridx = 0; gbc.gridy = row; gbc.weightx = 0;
        panel.add(keyLabel, gbc);
        gbc.gridx = 1; gbc.weightx = 1;
        panel.add(keyField, gbc);
        gbc.gridx = 2; gbc.weightx = 0;
        panel.add(authenticateButton, gbc);
        row++;
        
        // OAuth note (below key field)
        gbc.gridx = 1; gbc.gridy = row; gbc.gridwidth = 2;
        panel.add(oauthNoteLabel, gbc);
        gbc.gridwidth = 1;
        row++;
        
        // Claude Code note (below OAuth note, same row)
        gbc.gridx = 1; gbc.gridy = row; gbc.gridwidth = 2;
        panel.add(claudeCodeNoteLabel, gbc);
        gbc.gridwidth = 1;
        row++;
        
        // Disable TLS
        gbc.gridx = 1; gbc.gridy = row; gbc.gridwidth = 2;
        panel.add(disableTlsCheckbox, gbc);
        
        // Track whether the type change is user-initiated (vs initial load)
        boolean[] isUserChange = {false};

        // Function to update UI based on provider type
        Runnable updateUIForProviderType = () -> {
            APIProvider.ProviderType selectedType = (APIProvider.ProviderType) typeComboBox.getSelectedItem();
            if (selectedType == null) return;
            boolean isAnthropicOAuth = selectedType == APIProvider.ProviderType.ANTHROPIC_OAUTH;
            boolean isOpenAIOAuth = selectedType == APIProvider.ProviderType.OPENAI_OAUTH;
            boolean isGeminiOAuth = selectedType == APIProvider.ProviderType.GEMINI_OAUTH;
            boolean isOAuth = isAnthropicOAuth || isOpenAIOAuth || isGeminiOAuth;
            boolean isAnthropicClaudeCli = selectedType == APIProvider.ProviderType.ANTHROPIC_CLAUDE_CLI;
            
            // Hide URL for OAuth (uses fixed endpoints)
            urlLabel.setVisible(!isOAuth);
            urlField.setVisible(!isOAuth);
            
            // Show Authenticate button only for OAuth
            authenticateButton.setVisible(isOAuth);
            oauthNoteLabel.setVisible(isOAuth);
            
            // Update OAuth note text based on provider type
            if (isAnthropicOAuth) {
                oauthNoteLabel.setText("<html><i>Click 'Authenticate' to sign in with Claude Pro/Max subscription.</i></html>");
            } else if (isOpenAIOAuth) {
                oauthNoteLabel.setText("<html><i>Click 'Authenticate' to sign in with ChatGPT Pro/Plus subscription.</i></html>");
            } else if (isGeminiOAuth) {
                oauthNoteLabel.setText("<html><i>Click 'Authenticate' to sign in with Google Gemini CLI.</i></html>");
            }
            
            // Show Claude Code note only for Claude Code
            claudeCodeNoteLabel.setVisible(isAnthropicClaudeCli);
            
            // Update key label for OAuth
            if (isOAuth) {
                keyLabel.setText("Token:");
                keyField.setToolTipText("OAuth token JSON (populated by Authenticate button)");
            } else {
                keyLabel.setText("Key:");
                keyField.setToolTipText(null);
            }
            
            // Set provider-specific defaults for empty fields
            String defaultUrl = null;
            String defaultModel = null;
            switch (selectedType) {
                case ANTHROPIC_OAUTH:
                    defaultModel = "claude-sonnet-4-20250514";
                    break;
                case ANTHROPIC_PLATFORM_API:
                    defaultUrl = "https://api.anthropic.com/";
                    defaultModel = "claude-sonnet-4-5";
                    break;
                case GEMINI_OAUTH:
                    defaultModel = "gemini-2.5-flash";
                    break;
                case GEMINI_PLATFORM_API:
                    defaultUrl = "https://generativelanguage.googleapis.com/v1beta/openai/";
                    defaultModel = "gemini-2.5-flash";
                    break;
                case LMSTUDIO:
                    defaultUrl = "http://127.0.0.1:1234";
                    defaultModel = "openai/gpt-oss-20b";
                    break;
                case OLLAMA:
                    defaultUrl = "http://127.0.0.1:11434";
                    defaultModel = "gpt-oss:20b";
                    break;
                case OPENAI_OAUTH:
                    defaultModel = "gpt-5.1-codex";
                    break;
                case OPENAI_PLATFORM_API:
                    defaultUrl = "https://api.openai.com/v1/";
                    defaultModel = "gpt-5.2-codex";
                    break;
                case XAI_PLATFORM_API:
                    defaultUrl = "https://api.x.ai/v1";
                    defaultModel = "grok-3-mini";
                    break;
                default:
                    break;
            }
            if (isUserChange[0] || urlField.getText().trim().isEmpty()) {
                urlField.setText(defaultUrl != null ? defaultUrl : "");
            }
            if (isUserChange[0] || modelField.getText().trim().isEmpty()) {
                modelField.setText(defaultModel != null ? defaultModel : "");
            }
            if (isUserChange[0] || maxTokensField.getText().trim().isEmpty()) {
                maxTokensField.setText("16384");
            }
        };
        
        // Add listener to update UI when type changes
        typeComboBox.addActionListener(e -> {
            isUserChange[0] = true;
            updateUIForProviderType.run();
        });
        
        // Initial UI update
        updateUIForProviderType.run();
        
        // Authenticate button action - uses automatic callback capture with manual fallback
        authenticateButton.addActionListener(e -> {
            APIProvider.ProviderType selectedType = (APIProvider.ProviderType) typeComboBox.getSelectedItem();
            boolean isOpenAIOAuth = selectedType == APIProvider.ProviderType.OPENAI_OAUTH;
            boolean isGeminiOAuth = selectedType == APIProvider.ProviderType.GEMINI_OAUTH;

            if (isOpenAIOAuth) {
                authenticateOpenAIOAuth(panel, keyField);
            } else if (isGeminiOAuth) {
                authenticateGeminiOAuth(panel, keyField);
            } else {
                authenticateAnthropicOAuth(panel, keyField);
            }
        });

        int result = JOptionPane.showConfirmDialog(this, panel, "API Provider", JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);
        if (result == JOptionPane.OK_OPTION) {
            String name = nameField.getText().trim();
            String model = modelField.getText().trim();
            String url = urlField.getText().trim();
            String key = keyField.getText().trim();
            int maxTokens;
            try {
                maxTokens = Integer.parseInt(maxTokensField.getText().trim());
            } catch (NumberFormatException e) {
                maxTokens = 16384;
            }
            
            APIProvider.ProviderType selectedType = (APIProvider.ProviderType) typeComboBox.getSelectedItem();

            if (name.isEmpty() || model.isEmpty()) {
                JOptionPane.showMessageDialog(this, "Name and Model are required.", "Validation Error", JOptionPane.ERROR_MESSAGE);
                return false;
            }
            
            // For OAuth, key must contain valid JSON token
            if (selectedType == APIProvider.ProviderType.ANTHROPIC_OAUTH ||
                selectedType == APIProvider.ProviderType.OPENAI_OAUTH ||
                selectedType == APIProvider.ProviderType.GEMINI_OAUTH) {
                if (key.isEmpty() || !key.trim().startsWith("{")) {
                    JOptionPane.showMessageDialog(this, 
                        "OAuth token is required. Please click 'Authenticate' to sign in.",
                        "Validation Error", JOptionPane.ERROR_MESSAGE);
                    return false;
                }
            }

            provider.setName(name);
            provider.setType(selectedType);
            provider.setModel(model);
            provider.setMaxTokens(maxTokens);
            // For OAuth, URL is not used - set to fixed endpoint
            if (selectedType == APIProvider.ProviderType.ANTHROPIC_OAUTH) {
                provider.setUrl("https://api.anthropic.com/");
            } else if (selectedType == APIProvider.ProviderType.OPENAI_OAUTH) {
                provider.setUrl("https://chatgpt.com/");
            } else if (selectedType == APIProvider.ProviderType.GEMINI_OAUTH) {
                provider.setUrl("https://cloudcode-pa.googleapis.com/");
            } else {
                provider.setUrl(url.endsWith("/") ? url : url + "/");
            }
            provider.setKey(key);
            provider.setDisableTlsVerification(disableTlsCheckbox.isSelected());
            return true;
        }
        return false;
    }

    private void saveProviders() {
        Gson gson = new Gson();
        String providersJson = gson.toJson(apiProviders);
        Preferences.setProperty("GhidrAssist.APIProviders", providersJson);
        Preferences.setProperty("GhidrAssist.SelectedAPIProvider", selectedProviderName);
        Preferences.store();
    }

    private String maskApiKey(String key) {
        if (key == null || key.isEmpty()) return "";
        return "\u2022".repeat(Math.min(key.length(), 20));
    }

    // ==== MCP Server Operations ====

    private void showMCPAddEditDialog(MCPServerConfig existingServer) {
        MCPServerDialog dialog = new MCPServerDialog(
            SwingUtilities.getWindowAncestor(this),
            existingServer
        );
        dialog.setVisible(true);

        if (dialog.isConfirmed()) {
            MCPServerConfig config = dialog.getServerConfig();
            if (existingServer != null) {
                MCPServerRegistry.getInstance().removeServer(existingServer.getName());
            }
            MCPServerRegistry.getInstance().addServer(config);
            mcpTableModel.refresh();
        }
    }

    private void onDuplicateMCPServer() {
        int row = mcpServersTable.getSelectedRow();
        if (row < 0) {
            JOptionPane.showMessageDialog(this, "Please select a server to duplicate.", "No Selection", JOptionPane.WARNING_MESSAGE);
        } else {
            MCPServerConfig server = mcpTableModel.getServerAt(row).copy();
            server.setName(server.getName() + "-copy");
            MCPServerRegistry.getInstance().addServer(server);
            mcpTableModel.refresh();
        }
    }

    private void onRemoveMCPServer() {
        int selectedRow = mcpServersTable.getSelectedRow();
        if (selectedRow < 0) {
            JOptionPane.showMessageDialog(this, "Please select a server to remove.", "No Selection", JOptionPane.WARNING_MESSAGE);
            return;
        }
        MCPServerConfig server = mcpTableModel.getServerAt(selectedRow);
        int result = JOptionPane.showConfirmDialog(this, "Remove server '" + server.getName() + "'?", "Confirm Removal", JOptionPane.YES_NO_OPTION);
        if (result == JOptionPane.YES_OPTION) {
            MCPServerRegistry.getInstance().removeServer(server.getName());
            mcpTableModel.refresh();
        }
    }

    private void onTestMCPServer() {
        int selectedRow = mcpServersTable.getSelectedRow();
        if (selectedRow < 0) {
            mcpTestStatusLabel.setIcon(failureIcon);
            mcpTestStatusLabel.setToolTipText("No server selected");
            return;
        }

        MCPServerConfig server = mcpTableModel.getServerAt(selectedRow);

        // Show testing state
        mcpTestButton.setEnabled(false);
        mcpTestStatusLabel.setIcon(null);
        mcpTestStatusLabel.setText("...");
        mcpTestStatusLabel.setToolTipText("Testing connection to " + server.getName() + "...");

        SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {
            private String errorMessage = "";

            @Override
            protected Boolean doInBackground() {
                try {
                    ghidrassist.mcp2.protocol.MCPClientAdapter client =
                        new ghidrassist.mcp2.protocol.MCPClientAdapter(server);
                    client.connect().get();
                    client.disconnect();
                    return true;
                } catch (Exception e) {
                    Throwable cause = e.getCause() != null ? e.getCause() : e;
                    errorMessage = cause.getMessage();
                    return false;
                }
            }

            @Override
            protected void done() {
                mcpTestButton.setEnabled(true);
                mcpTestStatusLabel.setText("");
                try {
                    if (get()) {
                        mcpTestStatusLabel.setIcon(successIcon);
                        mcpTestStatusLabel.setToolTipText("Connection successful");
                    } else {
                        mcpTestStatusLabel.setIcon(failureIcon);
                        mcpTestStatusLabel.setToolTipText("Connection failed: " + errorMessage);
                    }
                } catch (Exception e) {
                    mcpTestStatusLabel.setIcon(failureIcon);
                    mcpTestStatusLabel.setToolTipText("Test error: " + e.getMessage());
                }
            }
        };
        worker.execute();
    }

    private void onTestSymGraph() {
        // Save current field values to preferences before testing
        Preferences.setProperty("GhidrAssist.SymGraphAPIUrl", symGraphUrlField.getText().trim());
        Preferences.setProperty("GhidrAssist.SymGraphAPIKey", new String(symGraphKeyField.getPassword()));
        Preferences.store();

        // Show testing state
        symGraphTestButton.setEnabled(false);
        symGraphTestStatusLabel.setIcon(null);
        symGraphTestStatusLabel.setText("...");
        symGraphTestStatusLabel.setToolTipText("Testing SymGraph API connection...");

        SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {
            private String errorMessage = "";
            private String successMessage = "";

            @Override
            protected Boolean doInBackground() {
                try {
                    SymGraphService service = new SymGraphService();

                    // Test basic connectivity by checking if a known test hash exists
                    // This tests the API URL is reachable without requiring authentication
                    String testHash = "0000000000000000000000000000000000000000000000000000000000000000";
                    service.checkBinaryExists(testHash);

                    // If we have an API key, test authentication by trying to get symbols
                    if (service.hasApiKey()) {
                        try {
                            service.getSymbols(testHash);
                            successMessage = "API reachable, authentication successful";
                        } catch (SymGraphService.SymGraphAuthException e) {
                            errorMessage = "API reachable but authentication failed: " + e.getMessage();
                            return false;
                        }
                    } else {
                        successMessage = "API reachable (no API key configured)";
                    }

                    return true;
                } catch (Exception e) {
                    errorMessage = e.getMessage();
                    return false;
                }
            }

            @Override
            protected void done() {
                symGraphTestButton.setEnabled(true);
                symGraphTestStatusLabel.setText("");
                try {
                    if (get()) {
                        symGraphTestStatusLabel.setIcon(successIcon);
                        symGraphTestStatusLabel.setToolTipText(successMessage);
                    } else {
                        symGraphTestStatusLabel.setIcon(failureIcon);
                        symGraphTestStatusLabel.setToolTipText("Connection failed: " + errorMessage);
                    }
                } catch (Exception e) {
                    symGraphTestStatusLabel.setIcon(failureIcon);
                    symGraphTestStatusLabel.setToolTipText("Test error: " + e.getMessage());
                }
            }
        };
        worker.execute();
    }

    // ==== Utility Methods ====

    private void browseFile(JTextField field, String title, boolean directoriesOnly) {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle(title);
        fileChooser.setFileSelectionMode(directoriesOnly ? JFileChooser.DIRECTORIES_ONLY : JFileChooser.FILES_ONLY);

        String currentPath = field.getText();
        if (!currentPath.isEmpty()) {
            File currentFile = new File(currentPath);
            fileChooser.setCurrentDirectory(currentFile.getParentFile());
            fileChooser.setSelectedFile(currentFile);
        }

        int result = fileChooser.showOpenDialog(this);
        if (result == JFileChooser.APPROVE_OPTION) {
            field.setText(fileChooser.getSelectedFile().getAbsolutePath());
        }
    }

    private ImageIcon createSuccessIcon() {
        int size = 16;
        BufferedImage image = new BufferedImage(size, size, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = image.createGraphics();
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g2d.setColor(new Color(0, 180, 0));  // Green
        g2d.setStroke(new BasicStroke(2.5f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
        g2d.drawLine(3, 8, 6, 12);
        g2d.drawLine(6, 12, 13, 4);
        g2d.dispose();
        return new ImageIcon(image);
    }

    private ImageIcon createFailureIcon() {
        int size = 16;
        BufferedImage image = new BufferedImage(size, size, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = image.createGraphics();
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g2d.setColor(new Color(220, 0, 0));  // Red
        g2d.setStroke(new BasicStroke(2.5f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
        g2d.drawLine(4, 4, 12, 12);
        g2d.drawLine(4, 12, 12, 4);
        g2d.dispose();
        return new ImageIcon(image);
    }

    // ==== OAuth Authentication Methods ====
    
    /**
     * Authenticates with OpenAI OAuth using automatic callback capture.
     * Falls back to manual code entry if automatic capture fails.
     */
    private void authenticateOpenAIOAuth(JPanel parentPanel, JTextField keyField) {
        OpenAIOAuthTokenManager tokenManager = new OpenAIOAuthTokenManager();
        
        // Create progress dialog with cancel option
        JDialog progressDialog = new JDialog(SwingUtilities.getWindowAncestor(parentPanel), 
            "OpenAI OAuth Authentication", Dialog.ModalityType.APPLICATION_MODAL);
        JPanel progressPanel = new JPanel(new BorderLayout(10, 10));
        progressPanel.setBorder(BorderFactory.createEmptyBorder(20, 20, 20, 20));
        
        JLabel statusLabel = new JLabel("Opening browser for authentication...");
        JProgressBar progressBar = new JProgressBar();
        progressBar.setIndeterminate(true);
        
        JButton cancelButton = new JButton("Cancel");
        JButton manualButton = new JButton("Use Manual Entry");
        
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 0));
        buttonPanel.add(manualButton);
        buttonPanel.add(cancelButton);
        
        progressPanel.add(statusLabel, BorderLayout.NORTH);
        progressPanel.add(progressBar, BorderLayout.CENTER);
        progressPanel.add(buttonPanel, BorderLayout.SOUTH);
        
        progressDialog.setContentPane(progressPanel);
        progressDialog.setSize(400, 150);
        progressDialog.setLocationRelativeTo(parentPanel);
        
        // Track authentication state
        final boolean[] authCompleted = {false};
        final boolean[] cancelled = {false};
        
        // Worker for automatic callback authentication
        SwingWorker<String, Void> authWorker = new SwingWorker<String, Void>() {
            private String errorMessage = null;
            private OAuthCallbackServer callbackServer = null;
            
            @Override
            protected String doInBackground() {
                try {
                    callbackServer = tokenManager.startAuthorizationFlowWithCallback();
                    publish(); // Update status
                    
                    // Wait for callback with 5 minute timeout
                    tokenManager.completeAuthorizationWithCallback(callbackServer, 5);
                    return tokenManager.toJson();
                } catch (Exception ex) {
                    if (!cancelled[0]) {
                        errorMessage = ex.getMessage();
                    }
                    return null;
                }
            }
            
            @Override
            protected void process(java.util.List<Void> chunks) {
                statusLabel.setText("Waiting for authentication in browser...");
            }
            
            @Override
            protected void done() {
                if (cancelled[0]) return;
                
                try {
                    String credentialsJson = get();
                    if (credentialsJson != null && !credentialsJson.isEmpty()) {
                        authCompleted[0] = true;
                        progressDialog.dispose();
                        keyField.setText(credentialsJson);
                        JOptionPane.showMessageDialog(parentPanel, 
                            "Successfully authenticated with ChatGPT Pro/Plus!\n\nThe OAuth token has been stored.",
                            "Authentication Successful", 
                            JOptionPane.INFORMATION_MESSAGE);
                    } else if (errorMessage != null && !cancelled[0]) {
                        progressDialog.dispose();
                        // Fall back to manual entry on error
                        authenticateOpenAIOAuthManual(parentPanel, keyField);
                    }
                } catch (Exception ex) {
                    if (!cancelled[0]) {
                        progressDialog.dispose();
                        authenticateOpenAIOAuthManual(parentPanel, keyField);
                    }
                }
            }
            
            public void cancel() {
                cancelled[0] = true;
                tokenManager.cancelAuthentication();
            }
        };
        
        // Cancel button action
        cancelButton.addActionListener(e -> {
            cancelled[0] = true;
            tokenManager.cancelAuthentication();
            authWorker.cancel(true);
            progressDialog.dispose();
        });
        
        // Manual entry button action
        manualButton.addActionListener(e -> {
            cancelled[0] = true;
            tokenManager.cancelAuthentication();
            authWorker.cancel(true);
            progressDialog.dispose();
            authenticateOpenAIOAuthManual(parentPanel, keyField);
        });
        
        // Start the worker
        authWorker.execute();
        
        // Show progress dialog (blocks until closed)
        progressDialog.setVisible(true);
    }
    
    /**
     * Manual OAuth code entry for OpenAI (fallback).
     */
    private void authenticateOpenAIOAuthManual(JPanel parentPanel, JTextField keyField) {
        OpenAIOAuthTokenManager tokenManager = new OpenAIOAuthTokenManager();
        tokenManager.startAuthorizationFlow();
        
        String code = (String) JOptionPane.showInputDialog(
            parentPanel,
            "<html>A browser window has been opened for ChatGPT Pro/Plus authentication.<br><br>" +
            "<b>Instructions:</b><br>" +
            "1. Sign in to your OpenAI/ChatGPT account in the browser<br>" +
            "2. Authorize GhidrAssist to access your account<br>" +
            "3. After authorization, you'll be redirected to localhost<br>" +
            "4. Copy the URL from the browser (or just the code value)<br>" +
            "5. Paste it below:<br><br>" +
            "<b>Paste URL or Code:</b></html>",
            "OpenAI OAuth Authentication",
            JOptionPane.PLAIN_MESSAGE,
            null,
            null,
            ""
        );
        
        if (code == null || code.trim().isEmpty()) {
            return;
        }
        
        SwingWorker<String, Void> exchangeWorker = new SwingWorker<String, Void>() {
            private String errorMessage = null;
            
            @Override
            protected String doInBackground() {
                try {
                    tokenManager.authenticateWithCode(code.trim());
                    return tokenManager.toJson();
                } catch (Exception ex) {
                    errorMessage = ex.getMessage();
                    return null;
                }
            }
            
            @Override
            protected void done() {
                try {
                    String credentialsJson = get();
                    if (credentialsJson != null && !credentialsJson.isEmpty()) {
                        keyField.setText(credentialsJson);
                        JOptionPane.showMessageDialog(parentPanel, 
                            "Successfully authenticated with ChatGPT Pro/Plus!\n\nThe OAuth token has been stored.",
                            "Authentication Successful", 
                            JOptionPane.INFORMATION_MESSAGE);
                    } else if (errorMessage != null) {
                        JOptionPane.showMessageDialog(parentPanel,
                            "Authentication failed: " + errorMessage,
                            "Authentication Error",
                            JOptionPane.ERROR_MESSAGE);
                    }
                } catch (Exception ex) {
                    JOptionPane.showMessageDialog(parentPanel,
                        "Authentication error: " + ex.getMessage(),
                        "Authentication Error",
                        JOptionPane.ERROR_MESSAGE);
                }
            }
        };
        
        exchangeWorker.execute();
    }
    
    /**
     * Authenticates with Anthropic OAuth using automatic callback capture.
     * Falls back to manual code entry if automatic capture fails.
     */
    private void authenticateAnthropicOAuth(JPanel parentPanel, JTextField keyField) {
        OAuthTokenManager tokenManager = new OAuthTokenManager();
        
        // Create progress dialog with cancel option
        JDialog progressDialog = new JDialog(SwingUtilities.getWindowAncestor(parentPanel), 
            "Claude OAuth Authentication", Dialog.ModalityType.APPLICATION_MODAL);
        JPanel progressPanel = new JPanel(new BorderLayout(10, 10));
        progressPanel.setBorder(BorderFactory.createEmptyBorder(20, 20, 20, 20));
        
        JLabel statusLabel = new JLabel("Opening browser for authentication...");
        JProgressBar progressBar = new JProgressBar();
        progressBar.setIndeterminate(true);
        
        JButton cancelButton = new JButton("Cancel");
        JButton manualButton = new JButton("Use Manual Entry");
        
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 0));
        buttonPanel.add(manualButton);
        buttonPanel.add(cancelButton);
        
        progressPanel.add(statusLabel, BorderLayout.NORTH);
        progressPanel.add(progressBar, BorderLayout.CENTER);
        progressPanel.add(buttonPanel, BorderLayout.SOUTH);
        
        progressDialog.setContentPane(progressPanel);
        progressDialog.setSize(400, 150);
        progressDialog.setLocationRelativeTo(parentPanel);
        
        // Track authentication state
        final boolean[] authCompleted = {false};
        final boolean[] cancelled = {false};
        
        // Worker for automatic callback authentication
        SwingWorker<String, Void> authWorker = new SwingWorker<String, Void>() {
            private String errorMessage = null;
            private OAuthCallbackServer callbackServer = null;
            
            @Override
            protected String doInBackground() {
                try {
                    callbackServer = tokenManager.startAuthorizationFlowWithCallback();
                    publish(); // Update status
                    
                    // Wait for callback with 5 minute timeout
                    tokenManager.completeAuthorizationWithCallback(callbackServer, 5);
                    return tokenManager.toJson();
                } catch (Exception ex) {
                    if (!cancelled[0]) {
                        errorMessage = ex.getMessage();
                    }
                    return null;
                }
            }
            
            @Override
            protected void process(java.util.List<Void> chunks) {
                statusLabel.setText("Waiting for authentication in browser...");
            }
            
            @Override
            protected void done() {
                if (cancelled[0]) return;
                
                try {
                    String credentialsJson = get();
                    if (credentialsJson != null && !credentialsJson.isEmpty()) {
                        authCompleted[0] = true;
                        progressDialog.dispose();
                        keyField.setText(credentialsJson);
                        JOptionPane.showMessageDialog(parentPanel, 
                            "Successfully authenticated with Claude Pro/Max!\n\nThe OAuth token has been stored.",
                            "Authentication Successful", 
                            JOptionPane.INFORMATION_MESSAGE);
                    } else if (errorMessage != null && !cancelled[0]) {
                        progressDialog.dispose();
                        // Fall back to manual entry on error
                        authenticateAnthropicOAuthManual(parentPanel, keyField);
                    }
                } catch (Exception ex) {
                    if (!cancelled[0]) {
                        progressDialog.dispose();
                        authenticateAnthropicOAuthManual(parentPanel, keyField);
                    }
                }
            }
            
            public void cancel() {
                cancelled[0] = true;
                tokenManager.cancelAuthentication();
            }
        };
        
        // Cancel button action
        cancelButton.addActionListener(e -> {
            cancelled[0] = true;
            tokenManager.cancelAuthentication();
            authWorker.cancel(true);
            progressDialog.dispose();
        });
        
        // Manual entry button action
        manualButton.addActionListener(e -> {
            cancelled[0] = true;
            tokenManager.cancelAuthentication();
            authWorker.cancel(true);
            progressDialog.dispose();
            authenticateAnthropicOAuthManual(parentPanel, keyField);
        });
        
        // Start the worker
        authWorker.execute();
        
        // Show progress dialog (blocks until closed)
        progressDialog.setVisible(true);
    }
    
    /**
     * Manual OAuth code entry for Anthropic (fallback).
     * Uses Anthropic's hosted callback page where user copies the code.
     */
    private void authenticateAnthropicOAuthManual(JPanel parentPanel, JTextField keyField) {
        OAuthTokenManager tokenManager = new OAuthTokenManager();
        tokenManager.startAuthorizationFlow();
        
        String code = (String) JOptionPane.showInputDialog(
            parentPanel,
            "<html>A browser window has been opened for Claude Pro/Max authentication.<br><br>" +
            "<b>Instructions:</b><br>" +
            "1. Sign in to your Anthropic account in the browser<br>" +
            "2. Authorize GhidrAssist to access your account<br>" +
            "3. Copy the authorization code shown on the page<br>" +
            "4. Paste it below:<br><br>" +
            "<b>Authorization Code:</b></html>",
            "Claude OAuth Authentication",
            JOptionPane.PLAIN_MESSAGE,
            null,
            null,
            ""
        );
        
        if (code == null || code.trim().isEmpty()) {
            return;
        }
        
        SwingWorker<String, Void> exchangeWorker = new SwingWorker<String, Void>() {
            private String errorMessage = null;
            
            @Override
            protected String doInBackground() {
                try {
                    tokenManager.authenticateWithCode(code.trim());
                    return tokenManager.toJson();
                } catch (Exception ex) {
                    errorMessage = ex.getMessage();
                    return null;
                }
            }
            
            @Override
            protected void done() {
                try {
                    String credentialsJson = get();
                    if (credentialsJson != null && !credentialsJson.isEmpty()) {
                        keyField.setText(credentialsJson);
                        JOptionPane.showMessageDialog(parentPanel, 
                            "Successfully authenticated with Claude Pro/Max!\n\nThe OAuth token has been stored.",
                            "Authentication Successful", 
                            JOptionPane.INFORMATION_MESSAGE);
                    } else if (errorMessage != null) {
                        JOptionPane.showMessageDialog(parentPanel,
                            "Authentication failed: " + errorMessage,
                            "Authentication Error",
                            JOptionPane.ERROR_MESSAGE);
                    }
                } catch (Exception ex) {
                    JOptionPane.showMessageDialog(parentPanel,
                        "Authentication error: " + ex.getMessage(),
                        "Authentication Error",
                        JOptionPane.ERROR_MESSAGE);
                }
            }
        };
        
        exchangeWorker.execute();
    }

    // ==== Gemini OAuth Authentication Methods ====

    /**
     * Authenticates with Google Gemini OAuth using automatic callback capture.
     * Falls back to manual code entry if automatic capture fails.
     */
    private void authenticateGeminiOAuth(JPanel parentPanel, JTextField keyField) {
        GeminiOAuthTokenManager tokenManager = new GeminiOAuthTokenManager();

        // Create progress dialog with cancel option
        JDialog progressDialog = new JDialog(SwingUtilities.getWindowAncestor(parentPanel),
            "Gemini OAuth Authentication", Dialog.ModalityType.APPLICATION_MODAL);
        JPanel progressPanel = new JPanel(new BorderLayout(10, 10));
        progressPanel.setBorder(BorderFactory.createEmptyBorder(20, 20, 20, 20));

        JLabel statusLabel = new JLabel("Opening browser for authentication...");
        JProgressBar progressBar = new JProgressBar();
        progressBar.setIndeterminate(true);

        JButton cancelButton = new JButton("Cancel");
        JButton manualButton = new JButton("Use Manual Entry");

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 0));
        buttonPanel.add(manualButton);
        buttonPanel.add(cancelButton);

        progressPanel.add(statusLabel, BorderLayout.NORTH);
        progressPanel.add(progressBar, BorderLayout.CENTER);
        progressPanel.add(buttonPanel, BorderLayout.SOUTH);

        progressDialog.setContentPane(progressPanel);
        progressDialog.setSize(400, 150);
        progressDialog.setLocationRelativeTo(parentPanel);

        // Track authentication state
        final boolean[] authCompleted = {false};
        final boolean[] cancelled = {false};

        // Worker for automatic callback authentication
        SwingWorker<String, Void> authWorker = new SwingWorker<String, Void>() {
            private String errorMessage = null;
            private OAuthCallbackServer callbackServer = null;

            @Override
            protected String doInBackground() {
                try {
                    callbackServer = tokenManager.startAuthorizationFlowWithCallback();
                    publish(); // Update status

                    // Wait for callback with 5 minute timeout
                    tokenManager.completeAuthorizationWithCallback(callbackServer, 5);
                    return tokenManager.toJson();
                } catch (Exception ex) {
                    if (!cancelled[0]) {
                        errorMessage = ex.getMessage();
                    }
                    return null;
                }
            }

            @Override
            protected void process(java.util.List<Void> chunks) {
                statusLabel.setText("Waiting for authentication in browser...");
            }

            @Override
            protected void done() {
                if (cancelled[0]) return;

                try {
                    String credentialsJson = get();
                    if (credentialsJson != null && !credentialsJson.isEmpty()) {
                        authCompleted[0] = true;
                        progressDialog.dispose();
                        keyField.setText(credentialsJson);
                        JOptionPane.showMessageDialog(parentPanel,
                            "Successfully authenticated with Google Gemini CLI!\n\nThe OAuth token has been stored.",
                            "Authentication Successful",
                            JOptionPane.INFORMATION_MESSAGE);
                    } else if (errorMessage != null && !cancelled[0]) {
                        progressDialog.dispose();
                        // Fall back to manual entry on error
                        authenticateGeminiOAuthManual(parentPanel, keyField);
                    }
                } catch (Exception ex) {
                    if (!cancelled[0]) {
                        progressDialog.dispose();
                        authenticateGeminiOAuthManual(parentPanel, keyField);
                    }
                }
            }

            public void cancel() {
                cancelled[0] = true;
                tokenManager.cancelAuthentication();
            }
        };

        // Cancel button action
        cancelButton.addActionListener(e -> {
            cancelled[0] = true;
            tokenManager.cancelAuthentication();
            authWorker.cancel(true);
            progressDialog.dispose();
        });

        // Manual entry button action
        manualButton.addActionListener(e -> {
            cancelled[0] = true;
            tokenManager.cancelAuthentication();
            authWorker.cancel(true);
            progressDialog.dispose();
            authenticateGeminiOAuthManual(parentPanel, keyField);
        });

        // Start the worker
        authWorker.execute();

        // Show progress dialog (blocks until closed)
        progressDialog.setVisible(true);
    }

    /**
     * Manual OAuth code entry for Google Gemini (fallback).
     * Uses headless mode with PKCE S256 and codeassist.google.com/authcode redirect.
     */
    private void authenticateGeminiOAuthManual(JPanel parentPanel, JTextField keyField) {
        GeminiOAuthTokenManager tokenManager = new GeminiOAuthTokenManager();
        tokenManager.startAuthorizationFlow();

        String code = (String) JOptionPane.showInputDialog(
            parentPanel,
            "<html>A browser window has been opened for Google Gemini authentication.<br><br>" +
            "<b>Instructions:</b><br>" +
            "1. Sign in to your Google account in the browser<br>" +
            "2. Authorize GhidrAssist to access your account<br>" +
            "3. Copy the authorization code shown on the page<br>" +
            "4. Paste it below:<br><br>" +
            "<b>Authorization Code:</b></html>",
            "Gemini OAuth Authentication",
            JOptionPane.PLAIN_MESSAGE,
            null,
            null,
            ""
        );

        if (code == null || code.trim().isEmpty()) {
            return;
        }

        SwingWorker<String, Void> exchangeWorker = new SwingWorker<String, Void>() {
            private String errorMessage = null;

            @Override
            protected String doInBackground() {
                try {
                    tokenManager.authenticateWithCode(code.trim());
                    return tokenManager.toJson();
                } catch (Exception ex) {
                    errorMessage = ex.getMessage();
                    return null;
                }
            }

            @Override
            protected void done() {
                try {
                    String credentialsJson = get();
                    if (credentialsJson != null && !credentialsJson.isEmpty()) {
                        keyField.setText(credentialsJson);
                        JOptionPane.showMessageDialog(parentPanel,
                            "Successfully authenticated with Google Gemini CLI!\n\nThe OAuth token has been stored.",
                            "Authentication Successful",
                            JOptionPane.INFORMATION_MESSAGE);
                    } else if (errorMessage != null) {
                        JOptionPane.showMessageDialog(parentPanel,
                            "Authentication failed: " + errorMessage,
                            "Authentication Error",
                            JOptionPane.ERROR_MESSAGE);
                    }
                } catch (Exception ex) {
                    JOptionPane.showMessageDialog(parentPanel,
                        "Authentication error: " + ex.getMessage(),
                        "Authentication Error",
                        JOptionPane.ERROR_MESSAGE);
                }
            }
        };

        exchangeWorker.execute();
    }

    // ==== Inner Classes ====

    private static class MCPServersTableModel extends javax.swing.table.AbstractTableModel {
        private static final long serialVersionUID = 1L;
        private static final String[] COLUMN_NAMES = {"Name", "URL", "Enabled", "Transport"};
        private List<MCPServerConfig> servers;

        public MCPServersTableModel() {
            refresh();
        }

        public void refresh() {
            servers = MCPServerRegistry.getInstance().getAllServers();
            fireTableDataChanged();
        }

        @Override
        public int getRowCount() {
            return servers.size();
        }

        @Override
        public int getColumnCount() {
            return COLUMN_NAMES.length;
        }

        @Override
        public String getColumnName(int column) {
            return COLUMN_NAMES[column];
        }

        @Override
        public Class<?> getColumnClass(int column) {
            return column == 2 ? Boolean.class : String.class;
        }

        @Override
        public Object getValueAt(int row, int column) {
            MCPServerConfig server = servers.get(row);
            switch (column) {
                case 0: return server.getName();
                case 1: return server.getBaseUrl();
                case 2: return server.isEnabled();
                case 3: return server.getTransport().getDisplayName();
                default: return null;
            }
        }

        @Override
        public boolean isCellEditable(int row, int column) {
            return column == 2;
        }

        @Override
        public void setValueAt(Object value, int row, int column) {
            if (column == 2 && value instanceof Boolean) {
                MCPServerConfig server = servers.get(row);
                MCPServerConfig updated = new MCPServerConfig(
                    server.getName(),
                    server.getBaseUrl(),
                    server.getTransport(),
                    (Boolean) value
                );
                MCPServerRegistry.getInstance().updateServer(updated);
                fireTableCellUpdated(row, column);
            }
        }

        public MCPServerConfig getServerAt(int row) {
            return servers.get(row);
        }
    }
}

```

`src/main/java/ghidrassist/ui/tabs/SymGraphTab.java`:

```java
package ghidrassist.ui.tabs;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellRenderer;
import java.awt.*;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.List;

import ghidrassist.core.TabController;
import ghidrassist.services.symgraph.SymGraphModels.*;

/**
 * Tab for SymGraph integration - query, push, and pull symbols/graph data.
 */
public class SymGraphTab extends JPanel {
    private static final long serialVersionUID = 1L;
    private final TabController controller;

    // Binary info section
    private JLabel binaryNameLabel;
    private JLabel sha256Label;

    // Query section
    private JButton queryButton;
    private JLabel statusLabel;
    private JPanel statsPanel;
    private JLabel symbolsStatLabel;
    private JLabel functionsStatLabel;
    private JLabel nodesStatLabel;
    private JLabel updatedStatLabel;

    // Push section
    private JRadioButton fullBinaryRadio;
    private JRadioButton currentFunctionRadio;
    private JCheckBox pushSymbolsCheck;
    private JCheckBox pushGraphCheck;
    private JButton pushButton;
    private JLabel pushStatusLabel;
    private JProgressBar pushProgressBar;
    private JButton cancelPushButton;

    // Pull section
    private JButton pullPreviewButton;
    private JTable conflictTable;
    private DefaultTableModel conflictTableModel;
    private JButton selectAllButton;
    private JButton deselectAllButton;
    private JButton invertSelectionButton;
    private JButton applyButton;
    private JButton cancelButton;
    private JLabel pullStatusLabel;
    private JProgressBar pullProgressBar;
    private JLabel pullProgressLabel;
    private JButton cancelPullButton;
    private JPanel pullProgressPanel;

    // Pull configuration
    private JCheckBox pullFunctionsCheck;
    private JCheckBox pullVariablesCheck;
    private JCheckBox pullTypesCheck;
    private JCheckBox pullCommentsCheck;
    private JCheckBox pullGraphCheck;
    private JSlider confidenceSlider;
    private JLabel confidenceValueLabel;

    // Wizard components
    private static final String PAGE_INITIAL = "initial";
    private static final String PAGE_SUMMARY = "summary";
    private static final String PAGE_DETAILS = "details";
    private static final String PAGE_APPLYING = "applying";
    private static final String PAGE_COMPLETE = "complete";

    private static final String MERGE_POLICY_UPSERT = "upsert";
    private static final String MERGE_POLICY_PREFER_LOCAL = "prefer_local";
    private static final String MERGE_POLICY_REPLACE = "replace";

    private CardLayout wizardLayout;
    private JPanel wizardPanel;

    // Summary page
    private JLabel summaryNewCount;
    private JLabel summaryConflictCount;
    private JLabel summarySameCount;
    private JLabel summaryGraphLabel;
    private JLabel summaryGraphNodesLabel;
    private JLabel summaryGraphEdgesLabel;
    private JLabel summaryGraphCommunitiesLabel;
    private ButtonGroup summaryMergeGroup;
    private JButton applyAllNewButton;
    private JButton reviewConflictsButton;
    private JButton showAllButton;
    private JButton summaryBackButton;

    // Details page
    private JTabbedPane detailsTabs;
    private JLabel detailsGraphLabel;
    private JLabel detailsGraphNodesLabel;
    private JLabel detailsGraphEdgesLabel;
    private JLabel detailsGraphCommunitiesLabel;
    private JLabel detailsGraphPolicyLabel;
    private ButtonGroup detailsMergeGroup;
    private JButton backToSummaryButton;

    // Applying page
    private JProgressBar applyProgressBar;
    private JLabel applyProgressLabel;
    private JButton applyCancelButton;

    // Complete page
    private JLabel completeIcon;
    private JLabel completeMessage;
    private JButton doneButton;

    // Stored conflict data
    private List<ConflictEntry> currentConflicts = new ArrayList<>();
    private List<ConflictEntry> displayedConflicts = new ArrayList<>();

    private GraphExport graphPreviewData;
    private int graphPreviewNodes;
    private int graphPreviewEdges;
    private int graphPreviewCommunities;
    private String graphMergePolicy = MERGE_POLICY_UPSERT;

    // Push cancellation callback
    private Runnable pushCancelCallback;

    public SymGraphTab(TabController controller) {
        super(new BorderLayout());
        this.controller = controller;
        initializeComponents();
        layoutComponents();
        setupListeners();
    }

    private void initializeComponents() {
        // Binary info
        binaryNameLabel = new JLabel("<no binary loaded>");
        binaryNameLabel.setFont(binaryNameLabel.getFont().deriveFont(Font.BOLD));
        sha256Label = new JLabel("<none>");
        sha256Label.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 11));

        // Query section
        queryButton = new JButton("Check SymGraph");
        statusLabel = new JLabel("Not checked");
        statusLabel.setForeground(Color.GRAY);

        symbolsStatLabel = new JLabel("Symbols: -");
        functionsStatLabel = new JLabel("Functions: -");
        nodesStatLabel = new JLabel("Graph Nodes: -");
        updatedStatLabel = new JLabel("Last Updated: -");

        statsPanel = new JPanel(new GridLayout(2, 2, 10, 5));
        statsPanel.add(symbolsStatLabel);
        statsPanel.add(functionsStatLabel);
        statsPanel.add(nodesStatLabel);
        statsPanel.add(updatedStatLabel);
        statsPanel.setVisible(false);

        // Push section
        fullBinaryRadio = new JRadioButton("Full Binary");
        currentFunctionRadio = new JRadioButton("Current Function", true);
        ButtonGroup scopeGroup = new ButtonGroup();
        scopeGroup.add(fullBinaryRadio);
        scopeGroup.add(currentFunctionRadio);

        pushSymbolsCheck = new JCheckBox("Symbols (function names, variables, types)", true);
        pushGraphCheck = new JCheckBox("Graph (nodes, edges, summaries)", true);

        pushButton = new JButton("Push to SymGraph");
        pushStatusLabel = new JLabel("Status: Ready");
        pushStatusLabel.setForeground(Color.GRAY);

        pushProgressBar = new JProgressBar(0, 100);
        pushProgressBar.setStringPainted(true);
        pushProgressBar.setVisible(false);

        cancelPushButton = new JButton("Cancel");
        cancelPushButton.setVisible(false);

        // Pull section
        pullPreviewButton = new JButton("Pull & Preview");

        // Pull configuration - Symbol type checkboxes
        pullFunctionsCheck = new JCheckBox("Functions", true);
        pullVariablesCheck = new JCheckBox("Variables", true);
        pullTypesCheck = new JCheckBox("Types", true);
        pullCommentsCheck = new JCheckBox("Comments", true);
        pullGraphCheck = new JCheckBox("Include Graph Data", true);
        pullGraphCheck.setToolTipText("Download graph nodes and edges for semantic analysis");

        // Confidence slider (0-100, displayed as 0.0-1.0)
        confidenceSlider = new JSlider(JSlider.HORIZONTAL, 0, 100, 0);
        confidenceSlider.setPreferredSize(new Dimension(100, 20));
        confidenceSlider.setToolTipText("Only show symbols with confidence >= this threshold");
        confidenceValueLabel = new JLabel("0.0");

        confidenceSlider.addChangeListener(e -> {
            double value = confidenceSlider.getValue() / 100.0;
            confidenceValueLabel.setText(String.format("%.1f", value));
        });

        conflictTableModel = new DefaultTableModel(
                new Object[]{"Select", "Address", "Type/Storage", "Local Name", "Remote Name", "Action"}, 0) {
            private static final long serialVersionUID = 1L;

            @Override
            public Class<?> getColumnClass(int column) {
                return column == 0 ? Boolean.class : String.class;
            }

            @Override
            public boolean isCellEditable(int row, int column) {
                return column == 0; // Only checkbox is editable
            }
        };
        conflictTable = new JTable(conflictTableModel);
        conflictTable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
        conflictTable.setAutoResizeMode(JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS);
        conflictTable.setFillsViewportHeight(true);

        // Set column widths - Select narrow, Type/Storage, Action narrow, others flexible
        conflictTable.getColumnModel().getColumn(0).setMinWidth(50);
        conflictTable.getColumnModel().getColumn(0).setMaxWidth(60);
        conflictTable.getColumnModel().getColumn(0).setPreferredWidth(50);

        conflictTable.getColumnModel().getColumn(1).setMinWidth(80);
        conflictTable.getColumnModel().getColumn(1).setPreferredWidth(100);

        conflictTable.getColumnModel().getColumn(2).setMinWidth(90);
        conflictTable.getColumnModel().getColumn(2).setPreferredWidth(120);

        conflictTable.getColumnModel().getColumn(3).setMinWidth(100);
        conflictTable.getColumnModel().getColumn(3).setPreferredWidth(150);

        conflictTable.getColumnModel().getColumn(4).setMinWidth(100);
        conflictTable.getColumnModel().getColumn(4).setPreferredWidth(150);

        conflictTable.getColumnModel().getColumn(5).setMinWidth(70);
        conflictTable.getColumnModel().getColumn(5).setMaxWidth(90);
        conflictTable.getColumnModel().getColumn(5).setPreferredWidth(80);

        // Custom renderer for action column (color-coded)
        conflictTable.getColumnModel().getColumn(5).setCellRenderer(new ActionCellRenderer());

        selectAllButton = new JButton("Select All");
        deselectAllButton = new JButton("Deselect All");
        invertSelectionButton = new JButton("Invert Selection");
        applyButton = new JButton("Apply Selected");
        cancelButton = new JButton("Cancel");
        pullStatusLabel = new JLabel("");

        // Pull progress components
        pullProgressBar = new JProgressBar(0, 100);
        pullProgressBar.setStringPainted(true);
        pullProgressLabel = new JLabel("Fetching...");
        pullProgressLabel.setForeground(Color.GRAY);
        cancelPullButton = new JButton("Cancel");
    }

    private void layoutComponents() {
        // Main container with padding
        JPanel mainPanel = new JPanel(new BorderLayout(5, 5));
        mainPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        // Binary Info Section at top
        JPanel binaryInfoPanel = createBinaryInfoPanel();
        mainPanel.add(binaryInfoPanel, BorderLayout.NORTH);

        // Create split pane for query/push and pull sections
        JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
        splitPane.setResizeWeight(0.35);
        splitPane.setContinuousLayout(true);

        // Top panel: Query + Push stacked vertically, full width
        JPanel topPanel = new JPanel(new BorderLayout(5, 5));

        JPanel queryPushPanel = new JPanel();
        queryPushPanel.setLayout(new BoxLayout(queryPushPanel, BoxLayout.Y_AXIS));

        JPanel querySection = createQuerySection();
        querySection.setAlignmentX(Component.LEFT_ALIGNMENT);
        queryPushPanel.add(querySection);
        queryPushPanel.add(Box.createVerticalStrut(5));

        JPanel pushSection = createPushSection();
        pushSection.setAlignmentX(Component.LEFT_ALIGNMENT);
        queryPushPanel.add(pushSection);

        topPanel.add(queryPushPanel, BorderLayout.CENTER);
        splitPane.setTopComponent(topPanel);

        // Bottom panel: Pull
        splitPane.setBottomComponent(createPullSection());

        mainPanel.add(splitPane, BorderLayout.CENTER);

        add(mainPanel, BorderLayout.CENTER);
        syncMergePolicySelections();
        updateGraphLabels();
    }

    private JPanel createBinaryInfoPanel() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createTitledBorder("Binary Information"),
                BorderFactory.createEmptyBorder(5, 5, 5, 5)));

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.anchor = GridBagConstraints.WEST;
        gbc.insets = new Insets(2, 5, 2, 5);

        // Binary name row
        gbc.gridx = 0; gbc.gridy = 0;
        panel.add(new JLabel("Binary:"), gbc);
        gbc.gridx = 1; gbc.weightx = 1.0; gbc.fill = GridBagConstraints.HORIZONTAL;
        panel.add(binaryNameLabel, gbc);

        // SHA256 row
        gbc.gridx = 0; gbc.gridy = 1; gbc.weightx = 0; gbc.fill = GridBagConstraints.NONE;
        panel.add(new JLabel("SHA256:"), gbc);
        gbc.gridx = 1; gbc.weightx = 1.0; gbc.fill = GridBagConstraints.HORIZONTAL;
        panel.add(sha256Label, gbc);

        return panel;
    }

    private JPanel createQuerySection() {
        JPanel panel = new JPanel(new BorderLayout(5, 5));
        panel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createTitledBorder("Query Status"),
                BorderFactory.createEmptyBorder(5, 5, 5, 5)));

        // Button row
        JPanel buttonRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        buttonRow.add(queryButton);

        // Status row
        JPanel statusRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        statusRow.add(new JLabel("Status:"));
        statusRow.add(statusLabel);

        JPanel topPanel = new JPanel();
        topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.Y_AXIS));
        topPanel.add(buttonRow);
        topPanel.add(statusRow);

        panel.add(topPanel, BorderLayout.NORTH);
        panel.add(statsPanel, BorderLayout.CENTER);

        return panel;
    }

    private JPanel createPushSection() {
        JPanel panel = new JPanel(new BorderLayout(5, 5));
        panel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createTitledBorder("Push to SymGraph"),
                BorderFactory.createEmptyBorder(5, 5, 5, 5)));

        JPanel contentPanel = new JPanel();
        contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));

        // Scope row
        JPanel scopeRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        scopeRow.add(new JLabel("Scope:"));
        scopeRow.add(fullBinaryRadio);
        scopeRow.add(currentFunctionRadio);
        contentPanel.add(scopeRow);

        // Data checkboxes row
        JPanel dataRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        dataRow.add(new JLabel("Data to Push:"));
        dataRow.add(pushSymbolsCheck);
        dataRow.add(pushGraphCheck);
        contentPanel.add(dataRow);

        // Button and status row
        JPanel buttonRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        buttonRow.add(pushButton);
        buttonRow.add(cancelPushButton);
        buttonRow.add(pushStatusLabel);
        contentPanel.add(buttonRow);

        // Progress bar row
        JPanel progressRow = new JPanel(new BorderLayout(5, 0));
        progressRow.add(pushProgressBar, BorderLayout.CENTER);
        contentPanel.add(progressRow);

        panel.add(contentPanel, BorderLayout.CENTER);
        return panel;
    }

    private JPanel createPullSection() {
        JPanel panel = new JPanel(new BorderLayout(5, 5));
        panel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createTitledBorder("Pull from SymGraph"),
                BorderFactory.createEmptyBorder(5, 5, 5, 5)));

        // Config panel at top (always visible, like BinAssist)
        JPanel configPanel = new JPanel();
        configPanel.setLayout(new BoxLayout(configPanel, BoxLayout.Y_AXIS));

        // Symbol Types label on its own row
        JPanel typeLabelRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        typeLabelRow.add(new JLabel("Symbol Types:"));
        configPanel.add(typeLabelRow);

        // Checkboxes on next row
        JPanel typeCheckRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        typeCheckRow.add(pullFunctionsCheck);
        typeCheckRow.add(pullVariablesCheck);
        typeCheckRow.add(pullTypesCheck);
        typeCheckRow.add(pullCommentsCheck);
        configPanel.add(typeCheckRow);

        // Options row: Graph checkbox and confidence slider
        JPanel optionsRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        optionsRow.add(pullGraphCheck);
        optionsRow.add(Box.createHorizontalStrut(15));
        optionsRow.add(new JLabel("Min Confidence:"));
        optionsRow.add(confidenceSlider);
        optionsRow.add(confidenceValueLabel);
        configPanel.add(optionsRow);

        // Button row
        JPanel buttonRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        buttonRow.add(pullPreviewButton);
        buttonRow.add(cancelPullButton);
        configPanel.add(buttonRow);

        // Pull progress panel (hidden by default)
        pullProgressPanel = new JPanel(new BorderLayout(5, 5));
        pullProgressPanel.add(pullProgressBar, BorderLayout.CENTER);
        pullProgressPanel.add(pullProgressLabel, BorderLayout.SOUTH);
        pullProgressPanel.setVisible(false);
        configPanel.add(pullProgressPanel);

        panel.add(configPanel, BorderLayout.NORTH);

        // Create wizard panel with CardLayout (below config)
        wizardLayout = new CardLayout();
        wizardPanel = new JPanel(wizardLayout);

        // Create and add wizard pages (no initial page needed - config is always visible)
        wizardPanel.add(createEmptyPage(), PAGE_INITIAL);
        wizardPanel.add(createSummaryPage(), PAGE_SUMMARY);
        wizardPanel.add(createDetailsPage(), PAGE_DETAILS);
        wizardPanel.add(createApplyingPage(), PAGE_APPLYING);
        wizardPanel.add(createCompletePage(), PAGE_COMPLETE);

        panel.add(wizardPanel, BorderLayout.CENTER);
        return panel;
    }

    private JPanel createEmptyPage() {
        // Empty placeholder for initial state (config is shown above)
        JPanel page = new JPanel(new BorderLayout());
        JLabel infoLabel = new JLabel("<html><i>Configure options above and click 'Pull & Preview' to fetch symbols from SymGraph.</i></html>");
        infoLabel.setForeground(Color.GRAY);
        JPanel infoPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        infoPanel.add(infoLabel);
        page.add(infoPanel, BorderLayout.NORTH);
        return page;
    }

    private JPanel createSummaryPage() {
        JPanel page = new JPanel(new BorderLayout(10, 10));
        page.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // Title
        JLabel titleLabel = new JLabel("Preview Summary");
        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD, 14f));
        page.add(titleLabel, BorderLayout.NORTH);

        // Summary cards panel
        JPanel cardsPanel = new JPanel(new GridLayout(1, 3, 15, 0));

        // NEW card (green)
        JPanel newCard = createSummaryCard("NEW", new Color(0, 128, 0), new Color(230, 255, 230));
        summaryNewCount = (JLabel) ((JPanel) newCard.getComponent(0)).getComponent(0);
        JLabel newSubLabel = new JLabel("(safe)");
        newSubLabel.setForeground(Color.GRAY);
        newSubLabel.setFont(newSubLabel.getFont().deriveFont(10f));
        JPanel newSubPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));
        newSubPanel.setOpaque(false);
        newSubPanel.add(newSubLabel);
        newCard.add(newSubPanel);
        cardsPanel.add(newCard);

        // CONFLICTS card (orange)
        JPanel conflictCard = createSummaryCard("CONFLICTS", new Color(255, 140, 0), new Color(255, 245, 230));
        summaryConflictCount = (JLabel) ((JPanel) conflictCard.getComponent(0)).getComponent(0);
        JLabel conflictSubLabel = new JLabel("(review)");
        conflictSubLabel.setForeground(Color.GRAY);
        conflictSubLabel.setFont(conflictSubLabel.getFont().deriveFont(10f));
        JPanel conflictSubPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));
        conflictSubPanel.setOpaque(false);
        conflictSubPanel.add(conflictSubLabel);
        conflictCard.add(conflictSubPanel);
        cardsPanel.add(conflictCard);

        // UNCHANGED card (gray)
        JPanel sameCard = createSummaryCard("UNCHANGED", Color.GRAY, new Color(245, 245, 245));
        summarySameCount = (JLabel) ((JPanel) sameCard.getComponent(0)).getComponent(0);
        JLabel sameSubLabel = new JLabel("(skip)");
        sameSubLabel.setForeground(Color.GRAY);
        sameSubLabel.setFont(sameSubLabel.getFont().deriveFont(10f));
        JPanel sameSubPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));
        sameSubPanel.setOpaque(false);
        sameSubPanel.add(sameSubLabel);
        sameCard.add(sameSubPanel);
        cardsPanel.add(sameCard);

        JPanel centerPanel = new JPanel(new BorderLayout(5, 15));
        centerPanel.add(cardsPanel, BorderLayout.NORTH);

        // Graph info panel
        summaryGraphLabel = new JLabel("No graph data selected");
        summaryGraphLabel.setForeground(Color.GRAY);

        summaryGraphNodesLabel = new JLabel("Nodes: 0");
        summaryGraphEdgesLabel = new JLabel("Edges: 0");
        summaryGraphCommunitiesLabel = new JLabel("Communities: 0");

        JPanel graphStatsRow = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 0));
        graphStatsRow.add(summaryGraphNodesLabel);
        graphStatsRow.add(summaryGraphEdgesLabel);
        graphStatsRow.add(summaryGraphCommunitiesLabel);

        summaryMergeGroup = new ButtonGroup();
        JPanel mergePanel = createMergePolicyPanel(summaryMergeGroup);

        JPanel graphPanel = new JPanel();
        graphPanel.setLayout(new BoxLayout(graphPanel, BoxLayout.Y_AXIS));
        graphPanel.add(summaryGraphLabel);
        graphPanel.add(graphStatsRow);
        graphPanel.add(mergePanel);
        centerPanel.add(graphPanel, BorderLayout.CENTER);

        page.add(centerPanel, BorderLayout.CENTER);

        // Button panel
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 5));

        applyAllNewButton = new JButton("Apply All New");
        applyAllNewButton.setToolTipText("Apply all NEW symbols without reviewing conflicts");

        reviewConflictsButton = new JButton("Review Conflicts");
        reviewConflictsButton.setToolTipText("Show only conflicting symbols for review");

        showAllButton = new JButton("Show All Details");
        showAllButton.setToolTipText("Show full details table with all symbols");

        summaryBackButton = new JButton("Back");
        summaryBackButton.setToolTipText("Return to configuration");

        buttonPanel.add(applyAllNewButton);
        buttonPanel.add(reviewConflictsButton);
        buttonPanel.add(showAllButton);
        buttonPanel.add(summaryBackButton);

        page.add(buttonPanel, BorderLayout.SOUTH);

        return page;
    }

    private JPanel createSummaryCard(String title, Color titleColor, Color bgColor) {
        JPanel card = new JPanel();
        card.setLayout(new BoxLayout(card, BoxLayout.Y_AXIS));
        card.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(titleColor, 2),
                BorderFactory.createEmptyBorder(15, 20, 15, 20)));
        card.setBackground(bgColor);

        // Count label (large) - centered in its own panel
        JLabel countLabel = new JLabel("0", SwingConstants.CENTER);
        countLabel.setFont(countLabel.getFont().deriveFont(Font.BOLD, 28f));
        countLabel.setForeground(titleColor);
        countLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        countLabel.setHorizontalAlignment(SwingConstants.CENTER);

        JPanel countPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));
        countPanel.setOpaque(false);
        countPanel.add(countLabel);

        // Title label - centered
        JLabel titleLabel = new JLabel(title, SwingConstants.CENTER);
        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD, 12f));
        titleLabel.setForeground(titleColor);
        titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        titleLabel.setHorizontalAlignment(SwingConstants.CENTER);

        JPanel titlePanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));
        titlePanel.setOpaque(false);
        titlePanel.add(titleLabel);

        card.add(countPanel);
        card.add(Box.createVerticalStrut(5));
        card.add(titlePanel);

        return card;
    }

    private JPanel createMergePolicyPanel(ButtonGroup group) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));

        JLabel label = new JLabel("Graph Merge Policy:");
        label.setFont(label.getFont().deriveFont(Font.BOLD));
        panel.add(label);

        JRadioButton upsert = new JRadioButton("Upsert (merge and overwrite)");
        upsert.setActionCommand(MERGE_POLICY_UPSERT);
        JRadioButton preferLocal = new JRadioButton("Prefer Local (skip existing)");
        preferLocal.setActionCommand(MERGE_POLICY_PREFER_LOCAL);
        JRadioButton replace = new JRadioButton("Replace (clear graph tables)");
        replace.setActionCommand(MERGE_POLICY_REPLACE);

        group.add(upsert);
        group.add(preferLocal);
        group.add(replace);

        ActionListener listener = e -> setGraphMergePolicy(e.getActionCommand());
        upsert.addActionListener(listener);
        preferLocal.addActionListener(listener);
        replace.addActionListener(listener);

        upsert.setSelected(true);

        panel.add(upsert);
        panel.add(preferLocal);
        panel.add(replace);

        return panel;
    }

    private void setGraphMergePolicy(String policy) {
        if (policy == null) {
            return;
        }
        graphMergePolicy = policy;
        syncMergePolicySelections();
        updateGraphLabels();
    }

    private void syncMergePolicySelections() {
        syncMergePolicyGroup(summaryMergeGroup);
        syncMergePolicyGroup(detailsMergeGroup);
    }

    private void syncMergePolicyGroup(ButtonGroup group) {
        if (group == null) {
            return;
        }
        for (java.util.Enumeration<AbstractButton> e = group.getElements(); e.hasMoreElements();) {
            AbstractButton button = e.nextElement();
            if (graphMergePolicy.equals(button.getActionCommand())) {
                button.setSelected(true);
            }
        }
    }

    private String getMergePolicyLabel() {
        switch (graphMergePolicy) {
            case MERGE_POLICY_PREFER_LOCAL:
                return "Prefer Local";
            case MERGE_POLICY_REPLACE:
                return "Replace";
            default:
                return "Upsert";
        }
    }

    private JPanel createDetailsPage() {
        JPanel page = new JPanel(new BorderLayout(5, 5));

        JPanel titleRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        JLabel titleLabel = new JLabel("Details");
        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD, 14f));
        titleRow.add(titleLabel);
        page.add(titleRow, BorderLayout.NORTH);

        detailsTabs = new JTabbedPane();

        // Symbols tab
        JPanel symbolsTab = new JPanel(new BorderLayout(5, 5));
        JScrollPane tableScrollPane = new JScrollPane(conflictTable);
        tableScrollPane.setMinimumSize(new Dimension(500, 150));
        tableScrollPane.setPreferredSize(new Dimension(600, 200));
        symbolsTab.add(tableScrollPane, BorderLayout.CENTER);

        JPanel selectionRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        selectionRow.add(selectAllButton);
        selectionRow.add(deselectAllButton);
        selectionRow.add(invertSelectionButton);
        symbolsTab.add(selectionRow, BorderLayout.SOUTH);

        // Graph tab
        JPanel graphTab = new JPanel();
        graphTab.setLayout(new BoxLayout(graphTab, BoxLayout.Y_AXIS));
        detailsGraphLabel = new JLabel("No graph data available");
        detailsGraphLabel.setForeground(Color.GRAY);
        detailsGraphNodesLabel = new JLabel("Nodes: 0");
        detailsGraphEdgesLabel = new JLabel("Edges: 0");
        detailsGraphCommunitiesLabel = new JLabel("Communities: 0");
        detailsGraphPolicyLabel = new JLabel("Selected policy: Upsert");
        detailsGraphPolicyLabel.setForeground(Color.DARK_GRAY);

        JPanel graphStatsRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 0));
        graphStatsRow.add(detailsGraphNodesLabel);
        graphStatsRow.add(detailsGraphEdgesLabel);
        graphStatsRow.add(detailsGraphCommunitiesLabel);

        detailsMergeGroup = new ButtonGroup();
        JPanel mergePanel = createMergePolicyPanel(detailsMergeGroup);

        graphTab.add(detailsGraphLabel);
        graphTab.add(Box.createVerticalStrut(5));
        graphTab.add(graphStatsRow);
        graphTab.add(Box.createVerticalStrut(10));
        graphTab.add(detailsGraphPolicyLabel);
        graphTab.add(Box.createVerticalStrut(5));
        graphTab.add(mergePanel);
        graphTab.add(Box.createVerticalGlue());

        detailsTabs.addTab("Symbols", symbolsTab);
        detailsTabs.addTab("Graph", graphTab);

        page.add(detailsTabs, BorderLayout.CENTER);

        // Bottom buttons (including Back to Summary)
        JPanel bottomPanel = new JPanel();
        bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.Y_AXIS));

        JPanel actionRow = new JPanel(new BorderLayout(5, 0));
        JPanel leftButtons = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        leftButtons.add(applyButton);
        actionRow.add(leftButtons, BorderLayout.WEST);

        backToSummaryButton = new JButton("Back to Summary");
        JPanel rightButtons = new JPanel(new FlowLayout(FlowLayout.RIGHT, 5, 0));
        rightButtons.add(backToSummaryButton);
        actionRow.add(rightButtons, BorderLayout.EAST);

        JPanel statusRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        statusRow.add(pullStatusLabel);

        bottomPanel.add(actionRow);
        bottomPanel.add(statusRow);

        page.add(bottomPanel, BorderLayout.SOUTH);
        return page;
    }

    private JPanel createApplyingPage() {
        JPanel page = new JPanel(new BorderLayout(10, 10));
        page.setBorder(BorderFactory.createEmptyBorder(30, 30, 30, 30));

        JPanel centerPanel = new JPanel();
        centerPanel.setLayout(new BoxLayout(centerPanel, BoxLayout.Y_AXIS));

        // Title
        JLabel titleLabel = new JLabel("Applying Changes");
        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD, 16f));
        titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        centerPanel.add(titleLabel);
        centerPanel.add(Box.createVerticalStrut(20));

        // Progress bar
        applyProgressBar = new JProgressBar(0, 100);
        applyProgressBar.setStringPainted(true);
        applyProgressBar.setPreferredSize(new Dimension(400, 25));
        applyProgressBar.setMaximumSize(new Dimension(400, 25));
        applyProgressBar.setAlignmentX(Component.CENTER_ALIGNMENT);
        centerPanel.add(applyProgressBar);
        centerPanel.add(Box.createVerticalStrut(10));

        // Progress label
        applyProgressLabel = new JLabel("Starting...");
        applyProgressLabel.setForeground(Color.GRAY);
        applyProgressLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        centerPanel.add(applyProgressLabel);
        centerPanel.add(Box.createVerticalStrut(20));

        // Cancel button
        applyCancelButton = new JButton("Cancel");
        applyCancelButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        centerPanel.add(applyCancelButton);

        page.add(centerPanel, BorderLayout.CENTER);
        return page;
    }

    private JPanel createCompletePage() {
        JPanel page = new JPanel(new BorderLayout(10, 10));
        page.setBorder(BorderFactory.createEmptyBorder(30, 30, 30, 30));

        JPanel centerPanel = new JPanel();
        centerPanel.setLayout(new BoxLayout(centerPanel, BoxLayout.Y_AXIS));

        // Success icon (checkmark)
        completeIcon = new JLabel("✓");
        completeIcon.setFont(completeIcon.getFont().deriveFont(Font.BOLD, 48f));
        completeIcon.setForeground(new Color(0, 128, 0));
        completeIcon.setAlignmentX(Component.CENTER_ALIGNMENT);
        centerPanel.add(completeIcon);
        centerPanel.add(Box.createVerticalStrut(15));

        // Complete message
        completeMessage = new JLabel("Operation Complete");
        completeMessage.setFont(completeMessage.getFont().deriveFont(Font.BOLD, 16f));
        completeMessage.setAlignmentX(Component.CENTER_ALIGNMENT);
        centerPanel.add(completeMessage);
        centerPanel.add(Box.createVerticalStrut(30));

        // Done button
        doneButton = new JButton("Done");
        doneButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        centerPanel.add(doneButton);

        page.add(centerPanel, BorderLayout.CENTER);
        return page;
    }

    private void setupListeners() {
        queryButton.addActionListener(e -> controller.handleSymGraphQuery());
        pushButton.addActionListener(e -> handlePushClicked());
        pullPreviewButton.addActionListener(e -> controller.handleSymGraphPullPreview());
        applyButton.addActionListener(e -> handleApplyClicked());
        cancelButton.addActionListener(e -> resetWizard());

        cancelPushButton.addActionListener(e -> {
            if (pushCancelCallback != null) {
                pushCancelCallback.run();
            }
        });

        // Initially hide the pull cancel button
        cancelPullButton.setVisible(false);
        cancelPullButton.addActionListener(e -> controller.cancelSymGraphPull());

        selectAllButton.addActionListener(e -> setAllSelected(true));
        deselectAllButton.addActionListener(e -> setAllSelected(false));
        invertSelectionButton.addActionListener(e -> invertSelection());

        // Wizard navigation listeners
        applyAllNewButton.addActionListener(e -> controller.handleSymGraphApplyAllNew());
        reviewConflictsButton.addActionListener(e -> showConflictsOnly());
        showAllButton.addActionListener(e -> showDetailsPage());
        summaryBackButton.addActionListener(e -> resetWizard());
        backToSummaryButton.addActionListener(e -> showSummaryPage());
        doneButton.addActionListener(e -> resetWizard());
        applyCancelButton.addActionListener(e -> {
            // Request cancellation from the controller
            controller.cancelSymGraphApply();
        });
    }

    private void handlePushClicked() {
        String scope = fullBinaryRadio.isSelected() ?
                PushScope.FULL_BINARY.getValue() : PushScope.CURRENT_FUNCTION.getValue();
        boolean pushSymbols = pushSymbolsCheck.isSelected();
        boolean pushGraph = pushGraphCheck.isSelected();

        if (!pushSymbols && !pushGraph) {
            setPushStatus("Select at least one data type", false);
            return;
        }

        controller.handleSymGraphPush(scope, pushSymbols, pushGraph);
    }

    private void handleApplyClicked() {
        List<Long> selectedAddresses = getSelectedAddresses();
        if (selectedAddresses.isEmpty() && graphPreviewData == null) {
            setPullStatus("No items selected", false);
            return;
        }
        controller.handleSymGraphApplySelected(getSelectedConflicts());
    }

    private void setAllSelected(boolean selected) {
        for (int i = 0; i < conflictTableModel.getRowCount(); i++) {
            conflictTableModel.setValueAt(selected, i, 0);
        }
    }

    private void invertSelection() {
        for (int i = 0; i < conflictTableModel.getRowCount(); i++) {
            Boolean current = (Boolean) conflictTableModel.getValueAt(i, 0);
            conflictTableModel.setValueAt(!current, i, 0);
        }
    }

    // === Public methods for controller ===

    public void setBinaryInfo(String name, String sha256) {
        binaryNameLabel.setText(name != null ? name : "<no binary loaded>");
        sha256Label.setText(sha256 != null ? sha256 : "<none>");
    }

    public void setQueryStatus(String status, boolean found) {
        statusLabel.setText(status);
        if (found) {
            statusLabel.setForeground(new Color(0, 128, 0)); // Green
        } else if (status.toLowerCase().contains("error") || status.toLowerCase().contains("not found")) {
            statusLabel.setForeground(Color.RED);
        } else {
            statusLabel.setForeground(Color.GRAY);
        }
    }

    public void setStats(int symbols, int functions, int nodes, String lastUpdated) {
        symbolsStatLabel.setText(String.format("Symbols: %,d", symbols));
        functionsStatLabel.setText(String.format("Functions: %,d", functions));
        nodesStatLabel.setText(String.format("Graph Nodes: %,d", nodes));
        updatedStatLabel.setText("Last Updated: " + (lastUpdated != null ? lastUpdated : "Unknown"));
        statsPanel.setVisible(true);
    }

    public void hideStats() {
        statsPanel.setVisible(false);
    }

    public void setPushStatus(String status, Boolean success) {
        pushStatusLabel.setText("Status: " + status);
        if (success == null) {
            pushStatusLabel.setForeground(Color.GRAY);
        } else if (success) {
            pushStatusLabel.setForeground(new Color(0, 128, 0));
        } else {
            pushStatusLabel.setForeground(Color.RED);
        }
    }

    /**
     * Show the push progress bar and set the cancel callback.
     */
    public void showPushProgress(Runnable cancelCallback) {
        this.pushCancelCallback = cancelCallback;
        pushProgressBar.setValue(0);
        pushProgressBar.setString("Starting...");
        pushProgressBar.setVisible(true);
        cancelPushButton.setVisible(true);
        pushButton.setEnabled(false);
    }

    /**
     * Update the push progress bar.
     */
    public void updatePushProgress(int current, int total, String message) {
        int percent = total > 0 ? (int) ((current * 100L) / total) : 0;
        pushProgressBar.setValue(percent);
        pushProgressBar.setString(message != null ? message : String.format("%d/%d (%d%%)", current, total, percent));
    }

    /**
     * Hide the push progress bar.
     */
    public void hidePushProgress() {
        pushProgressBar.setVisible(false);
        cancelPushButton.setVisible(false);
        pushButton.setEnabled(true);
        pushCancelCallback = null;
    }

    public void setPullStatus(String status, Boolean success) {
        pullStatusLabel.setText(status);
        if (success == null) {
            pullStatusLabel.setForeground(Color.GRAY);
        } else if (success) {
            pullStatusLabel.setForeground(new Color(0, 128, 0));
        } else {
            pullStatusLabel.setForeground(Color.RED);
        }
    }

    /**
     * Show the pull progress panel.
     */
    public void showPullProgress(String message) {
        SwingUtilities.invokeLater(() -> {
            pullProgressBar.setValue(0);
            pullProgressBar.setString(message != null ? message : "Fetching...");
            pullProgressLabel.setText(message != null ? message : "Fetching...");
            pullProgressPanel.setVisible(true);
            cancelPullButton.setVisible(true);
            pullPreviewButton.setEnabled(false);
        });
    }

    /**
     * Update the pull progress bar.
     */
    public void updatePullProgress(int current, int total, String message) {
        SwingUtilities.invokeLater(() -> {
            int percent = total > 0 ? (current * 100) / total : 0;
            pullProgressBar.setValue(percent);
            pullProgressBar.setString(String.format("%d%%", percent));
            if (message != null) {
                pullProgressLabel.setText(message);
            }
        });
    }

    /**
     * Hide the pull progress panel.
     */
    public void hidePullProgress() {
        SwingUtilities.invokeLater(() -> {
            pullProgressPanel.setVisible(false);
            cancelPullButton.setVisible(false);
            pullPreviewButton.setEnabled(true);
        });
    }

    public void populateConflicts(List<ConflictEntry> conflicts) {
        currentConflicts.clear();

        // Calculate counts for summary
        int newCount = 0;
        int conflictCount = 0;
        int sameCount = 0;

        for (ConflictEntry conflict : conflicts) {
            switch (conflict.getAction()) {
                case NEW:
                    newCount++;
                    break;
                case CONFLICT:
                    conflictCount++;
                    break;
                case SAME:
                    sameCount++;
                    break;
            }
        }

        // Update summary labels
        summaryNewCount.setText(String.valueOf(newCount));
        summaryConflictCount.setText(String.valueOf(conflictCount));
        summarySameCount.setText(String.valueOf(sameCount));

        // Enable/disable buttons based on counts
        applyAllNewButton.setEnabled(newCount > 0);
        reviewConflictsButton.setEnabled(conflictCount > 0);

        // Sort: CONFLICT first, then by address
        List<ConflictEntry> sortedConflicts = new ArrayList<>(conflicts);
        sortedConflicts.sort((a, b) -> {
            if (a.getAction() == ConflictAction.CONFLICT && b.getAction() != ConflictAction.CONFLICT) {
                return -1;
            }
            if (a.getAction() != ConflictAction.CONFLICT && b.getAction() == ConflictAction.CONFLICT) {
                return 1;
            }
            return Long.compare(a.getAddress(), b.getAddress());
        });

        currentConflicts.addAll(sortedConflicts);
        refreshConflictTable(currentConflicts);

        // Show summary page
        showSummaryPage();
    }

    private String formatStorageInfo(Symbol symbol) {
        if (symbol == null) {
            return "";
        }

        String symType = symbol.getSymbolType();
        if (!"variable".equals(symType)) {
            return "func";
        }

        java.util.Map<String, Object> metadata = symbol.getMetadata();
        if (metadata == null) {
            return "variable";
        }

        String storageClass = (String) metadata.get("storage_class");
        String scope = (String) metadata.get("scope");

        if ("parameter".equals(storageClass)) {
            Object idx = metadata.get("parameter_index");
            String reg = (String) metadata.get("register");
            String idxStr = idx != null ? idx.toString() : "?";
            if (reg != null) {
                return String.format("param[%s] (%s)", idxStr, reg);
            }
            return String.format("param[%s]", idxStr);
        } else if ("stack".equals(storageClass)) {
            Object offsetObj = metadata.get("stack_offset");
            if (offsetObj != null) {
                int offset = ((Number) offsetObj).intValue();
                String sign = offset >= 0 ? "+" : "";
                return String.format("local [%s0x%x]", sign, Math.abs(offset));
            }
            return "local [stack]";
        } else if ("register".equals(storageClass)) {
            String reg = (String) metadata.get("register");
            return reg != null ? String.format("local (%s)", reg) : "local (reg)";
        } else if ("local".equals(scope)) {
            return "local";
        }

        return "global";
    }

    private void refreshConflictTable(List<ConflictEntry> conflicts) {
        conflictTableModel.setRowCount(0);
        displayedConflicts = new ArrayList<>(conflicts);
        for (ConflictEntry conflict : displayedConflicts) {
            String storageInfo = formatStorageInfo(conflict.getRemoteSymbol());
            conflictTableModel.addRow(new Object[]{
                    conflict.isSelected(),
                    conflict.getAddressHex(),
                    storageInfo,
                    conflict.getLocalNameDisplay(),
                    conflict.getRemoteNameDisplay(),
                    conflict.getAction().getValue().toUpperCase()
            });
        }
    }

    public void setGraphPreviewData(GraphExport export, int nodes, int edges, int communities) {
        graphPreviewData = export;
        graphPreviewNodes = nodes;
        graphPreviewEdges = edges;
        graphPreviewCommunities = communities;
        updateGraphLabels();
    }

    public GraphExport getGraphPreviewData() {
        return graphPreviewData;
    }

    public boolean hasGraphPreviewData() {
        return graphPreviewData != null;
    }

    public String getGraphMergePolicy() {
        return graphMergePolicy;
    }

    private void updateGraphLabels() {
        boolean hasGraph = graphPreviewData != null;
        summaryGraphLabel.setText(hasGraph ? "Graph data available for merge" : "No graph data selected");
        summaryGraphNodesLabel.setText("Nodes: " + graphPreviewNodes);
        summaryGraphEdgesLabel.setText("Edges: " + graphPreviewEdges);
        summaryGraphCommunitiesLabel.setText("Communities: " + graphPreviewCommunities);

        if (detailsGraphLabel != null) {
            detailsGraphLabel.setText(hasGraph ? "Graph data available for merge" : "No graph data available");
            detailsGraphNodesLabel.setText("Nodes: " + graphPreviewNodes);
            detailsGraphEdgesLabel.setText("Edges: " + graphPreviewEdges);
            detailsGraphCommunitiesLabel.setText("Communities: " + graphPreviewCommunities);
            if (detailsGraphPolicyLabel != null) {
                detailsGraphPolicyLabel.setText("Selected policy: " + getMergePolicyLabel());
            }
        }
    }

    public void clearConflicts() {
        resetWizard();
    }

    // === Wizard navigation methods ===

    private void resetWizard() {
        conflictTableModel.setRowCount(0);
        currentConflicts.clear();
        displayedConflicts.clear();
        pullStatusLabel.setText("");
        summaryNewCount.setText("0");
        summaryConflictCount.setText("0");
        summarySameCount.setText("0");
        summaryGraphLabel.setText("No graph data selected");
        graphPreviewData = null;
        graphPreviewNodes = 0;
        graphPreviewEdges = 0;
        graphPreviewCommunities = 0;
        graphMergePolicy = MERGE_POLICY_UPSERT;
        syncMergePolicySelections();
        updateGraphLabels();
        if (detailsTabs != null) {
            detailsTabs.setSelectedIndex(0);
        }
        wizardLayout.show(wizardPanel, PAGE_INITIAL);
    }

    private void showSummaryPage() {
        wizardLayout.show(wizardPanel, PAGE_SUMMARY);
    }

    private void showDetailsPage() {
        refreshConflictTable(currentConflicts);
        // Show all conflicts in the table
        if (detailsTabs != null) {
            detailsTabs.setSelectedIndex(0);
        }
        wizardLayout.show(wizardPanel, PAGE_DETAILS);
    }

    private void showConflictsOnly() {
        List<ConflictEntry> conflictOnly = new ArrayList<>();
        for (ConflictEntry conflict : currentConflicts) {
            if (conflict.getAction() == ConflictAction.CONFLICT) {
                conflictOnly.add(conflict);
            }
        }
        refreshConflictTable(conflictOnly);
        if (detailsTabs != null) {
            detailsTabs.setSelectedIndex(0);
        }
        wizardLayout.show(wizardPanel, PAGE_DETAILS);
    }

    /**
     * Show the applying page with a status message.
     */
    public void showApplyingPage(String message) {
        SwingUtilities.invokeLater(() -> {
            applyProgressBar.setValue(0);
            applyProgressLabel.setText(message != null ? message : "Starting...");
            wizardLayout.show(wizardPanel, PAGE_APPLYING);
        });
    }

    /**
     * Update the apply progress bar.
     */
    public void updateApplyProgress(int current, int total, String message) {
        SwingUtilities.invokeLater(() -> {
            int percent = total > 0 ? (int) ((current * 100L) / total) : 0;
            applyProgressBar.setValue(percent);
            applyProgressBar.setString(String.format("%d/%d (%d%%)", current, total, percent));
            if (message != null) {
                applyProgressLabel.setText(message);
            }
        });
    }

    /**
     * Hide the apply progress (no-op since we show complete page instead).
     * Provided for API consistency with other progress patterns.
     */
    public void hideApplyProgress() {
        // The wizard navigates directly to the complete page,
        // so there's nothing to hide. This method exists for API consistency.
    }

    /**
     * Show the complete page with results.
     */
    public void showCompletePage(String message, boolean success) {
        SwingUtilities.invokeLater(() -> {
            if (success) {
                completeIcon.setText("✓");
                completeIcon.setForeground(new Color(0, 128, 0));
            } else {
                completeIcon.setText("✗");
                completeIcon.setForeground(Color.RED);
            }
            completeMessage.setText(message != null ? message : "Operation Complete");
            wizardLayout.show(wizardPanel, PAGE_COMPLETE);
        });
    }

    /**
     * Get all conflicts with NEW action (for "Apply All New" button).
     */
    public List<ConflictEntry> getAllNewConflicts() {
        List<ConflictEntry> newItems = new ArrayList<>();
        for (ConflictEntry conflict : currentConflicts) {
            if (conflict.getAction() == ConflictAction.NEW) {
                newItems.add(conflict);
            }
        }
        return newItems;
    }

    /**
     * Set graph info in the summary page.
     */
    public void setSummaryGraphInfo(int nodes, int edges, int communities) {
        graphPreviewNodes = nodes;
        graphPreviewEdges = edges;
        graphPreviewCommunities = communities;
        updateGraphLabels();
    }

    public List<Long> getSelectedAddresses() {
        List<Long> selected = new ArrayList<>();
        for (int i = 0; i < conflictTableModel.getRowCount(); i++) {
            Boolean isSelected = (Boolean) conflictTableModel.getValueAt(i, 0);
            if (isSelected != null && isSelected && i < displayedConflicts.size()) {
                selected.add(displayedConflicts.get(i).getAddress());
            }
        }
        return selected;
    }

    public List<ConflictEntry> getSelectedConflicts() {
        List<ConflictEntry> selected = new ArrayList<>();
        for (int i = 0; i < conflictTableModel.getRowCount(); i++) {
            Boolean isSelected = (Boolean) conflictTableModel.getValueAt(i, 0);
            if (isSelected != null && isSelected && i < displayedConflicts.size()) {
                selected.add(displayedConflicts.get(i));
            }
        }
        return selected;
    }

    /**
     * Get the current pull configuration settings.
     *
     * @return PullConfig with symbol types, min confidence, and graph option
     */
    public PullConfig getPullConfig() {
        List<String> types = new ArrayList<>();
        if (pullFunctionsCheck.isSelected()) types.add("function");
        if (pullVariablesCheck.isSelected()) types.add("variable");
        if (pullTypesCheck.isSelected()) types.add("type");
        if (pullCommentsCheck.isSelected()) types.add("comment");

        double minConfidence = confidenceSlider.getValue() / 100.0;
        boolean includeGraph = pullGraphCheck.isSelected();

        return new PullConfig(types, minConfidence, includeGraph);
    }

    /**
     * Configuration for pull preview operation.
     */
    public static class PullConfig {
        private final List<String> symbolTypes;
        private final double minConfidence;
        private final boolean includeGraph;

        public PullConfig(List<String> symbolTypes, double minConfidence, boolean includeGraph) {
            this.symbolTypes = symbolTypes;
            this.minConfidence = minConfidence;
            this.includeGraph = includeGraph;
        }

        public List<String> getSymbolTypes() { return symbolTypes; }
        public double getMinConfidence() { return minConfidence; }
        public boolean isIncludeGraph() { return includeGraph; }
    }

    public void setButtonsEnabled(boolean enabled) {
        queryButton.setEnabled(enabled);
        pushButton.setEnabled(enabled);
        pullPreviewButton.setEnabled(enabled);
        applyButton.setEnabled(enabled);
    }

    /**
     * Custom cell renderer for the Action column.
     */
    private static class ActionCellRenderer extends JLabel implements TableCellRenderer {
        private static final long serialVersionUID = 1L;

        public ActionCellRenderer() {
            setOpaque(true);
            setHorizontalAlignment(CENTER);
        }

        @Override
        public Component getTableCellRendererComponent(JTable table, Object value,
                boolean isSelected, boolean hasFocus, int row, int column) {

            String action = value != null ? value.toString() : "";
            setText(action);

            if (isSelected) {
                setBackground(table.getSelectionBackground());
                setForeground(table.getSelectionForeground());
            } else {
                setBackground(table.getBackground());
                switch (action) {
                    case "CONFLICT":
                        setForeground(Color.RED);
                        break;
                    case "NEW":
                        setForeground(new Color(0, 128, 0));
                        break;
                    case "SAME":
                        setForeground(Color.GRAY);
                        break;
                    default:
                        setForeground(table.getForeground());
                }
            }

            return this;
        }
    }
}

```

`src/main/java/ghidrassist/ui/tabs/semanticgraph/GraphViewPanel.java`:

```java
package ghidrassist.ui.tabs.semanticgraph;

import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;

import com.mxgraph.layout.hierarchical.mxHierarchicalLayout;
import com.mxgraph.layout.mxOrganicLayout;
import com.mxgraph.model.mxCell;
import com.mxgraph.swing.mxGraphComponent;
import com.mxgraph.util.mxConstants;
import com.mxgraph.view.mxGraph;
import com.mxgraph.view.mxStylesheet;

import ghidra.util.Msg;

import ghidrassist.core.MarkdownHelper;
import ghidrassist.core.TabController;
import ghidrassist.ui.tabs.SemanticGraphTab;
import ghidrassist.graphrag.nodes.KnowledgeNode;
import ghidrassist.graphrag.BinaryKnowledgeGraph.GraphEdge;
import ghidrassist.graphrag.nodes.EdgeType;

/**
 * Visual graph sub-panel for the Semantic Graph tab.
 * Uses JGraphX to render an interactive node-edge diagram.
 */
public class GraphViewPanel extends JPanel {
    private static final long serialVersionUID = 1L;

    private final TabController controller;
    private final SemanticGraphTab parentTab;

    // JGraphX components
    private mxGraph graph;
    private mxGraphComponent graphComponent;

    // Controls
    private JSpinner nHopsSpinner;
    private JCheckBox showCallsCheckbox;
    private JCheckBox showVulnCheckbox;
    private JCheckBox showNetworkCheckbox;

    // Zoom controls
    private JButton zoomInButton;
    private JButton zoomOutButton;
    private JButton zoomFitButton;
    private JLabel zoomLabel;

    // Selected node info panel
    private JLabel selectedNodeLabel;
    private JEditorPane summaryPane;
    private JScrollPane summaryScrollPane;
    private MarkdownHelper markdownHelper;

    // Not-indexed placeholder
    private JPanel notIndexedPanel;
    private JPanel contentPanel;
    private CardLayout cardLayout;

    // Node mapping for click handling
    private Map<Object, KnowledgeNode> cellToNodeMap = new HashMap<>();
    private KnowledgeNode selectedNode = null;

    // Styles
    private static final String STYLE_CENTER = "centerNode";
    private static final String STYLE_NORMAL = "normalNode";
    private static final String STYLE_VULN = "vulnNode";
    private static final String STYLE_EDGE_CALLS = "edgeCalls";
    private static final String STYLE_EDGE_REFS = "edgeRefs";
    private static final String STYLE_EDGE_VULN = "edgeVuln";
    private static final String STYLE_EDGE_NETWORK = "edgeNetwork";

    public GraphViewPanel(TabController controller, SemanticGraphTab parentTab) {
        super(new BorderLayout());
        this.controller = controller;
        this.parentTab = parentTab;
        initializeGraph();
        initializeComponents();
        layoutComponents();
        setupListeners();
    }

    private void initializeGraph() {
        graph = new mxGraph() {
            // Disable edge editing
            @Override
            public boolean isCellEditable(Object cell) {
                return false;
            }

            // Disable cell moving (optional - can enable for user arrangement)
            @Override
            public boolean isCellMovable(Object cell) {
                return true;
            }
        };

        // Configure graph
        graph.setAllowDanglingEdges(false);
        graph.setEdgeLabelsMovable(false);
        graph.setCellsResizable(false);

        // Setup styles with theme colors
        setupStyles();

        // Create graph component
        graphComponent = new mxGraphComponent(graph);
        graphComponent.setConnectable(false);
        graphComponent.getViewport().setOpaque(true);

        // Use theme-aware background color
        Color bgColor = UIManager.getColor("Panel.background");
        if (bgColor == null) {
            bgColor = getBackground();
        }
        graphComponent.getViewport().setBackground(bgColor);
        graphComponent.setBackground(bgColor);

        // Disable default wheel scrolling so we can use CTRL+Wheel for zoom
        graphComponent.setWheelScrollingEnabled(false);

        // Add CTRL+Wheel zoom support
        graphComponent.addMouseWheelListener(new MouseWheelListener() {
            @Override
            public void mouseWheelMoved(MouseWheelEvent e) {
                if (e.isControlDown()) {
                    // CTRL+Wheel = zoom
                    if (e.getWheelRotation() < 0) {
                        graphComponent.zoomIn();
                    } else {
                        graphComponent.zoomOut();
                    }
                    updateZoomLabel();
                } else {
                    // Normal wheel = scroll
                    JScrollBar vBar = graphComponent.getVerticalScrollBar();
                    if (vBar != null) {
                        int amount = e.getWheelRotation() * vBar.getUnitIncrement();
                        vBar.setValue(vBar.getValue() + amount);
                    }
                }
            }
        });
    }

    private void setupStyles() {
        mxStylesheet stylesheet = graph.getStylesheet();

        // Get theme colors from UIManager for light/dark mode support
        Color selectionBg = UIManager.getColor("List.selectionBackground");
        Color selectionFg = UIManager.getColor("List.selectionForeground");
        Color panelBg = UIManager.getColor("Panel.background");
        Color textColor = UIManager.getColor("Label.foreground");
        Color borderColor = UIManager.getColor("Component.borderColor");

        // Determine if we're in dark mode by checking text brightness
        boolean isDarkMode = isColorDark(panelBg);

        // Fallback colors if UIManager doesn't provide them
        if (selectionBg == null) selectionBg = new Color(74, 144, 217);
        if (selectionFg == null) selectionFg = Color.WHITE;
        if (textColor == null) textColor = isDarkMode ? Color.WHITE : Color.BLACK;
        if (borderColor == null) borderColor = isDarkMode ? new Color(100, 100, 100) : new Color(128, 128, 128);

        // Normal node colors based on theme
        Color normalNodeBg = isDarkMode ? new Color(60, 63, 65) : new Color(232, 232, 232);
        Color normalNodeBorder = borderColor;
        Color normalNodeText = textColor;

        // Vulnerable node colors - red tint that works in both modes
        Color vulnNodeBg = isDarkMode ? new Color(80, 40, 40) : new Color(255, 204, 204);
        Color vulnNodeBorder = isDarkMode ? new Color(200, 80, 80) : new Color(204, 0, 0);
        Color vulnNodeText = isDarkMode ? new Color(255, 120, 120) : new Color(204, 0, 0);

        // Edge colors
        Color callsEdgeColor = selectionBg;
        Color refsEdgeColor = borderColor;
        Color vulnEdgeColor = vulnNodeBorder;
        Color networkEdgeColor = new Color(6, 182, 212);  // cyan-500

        // Center node style (highlighted with selection color)
        Map<String, Object> centerStyle = new HashMap<>();
        centerStyle.put(mxConstants.STYLE_SHAPE, mxConstants.SHAPE_RECTANGLE);
        centerStyle.put(mxConstants.STYLE_ROUNDED, true);
        centerStyle.put(mxConstants.STYLE_FILLCOLOR, colorToHex(selectionBg));
        centerStyle.put(mxConstants.STYLE_STROKECOLOR, colorToHex(selectionBg.darker()));
        centerStyle.put(mxConstants.STYLE_STROKEWIDTH, 3);
        centerStyle.put(mxConstants.STYLE_FONTCOLOR, colorToHex(selectionFg));
        centerStyle.put(mxConstants.STYLE_FONTSIZE, 11);
        centerStyle.put(mxConstants.STYLE_FONTSTYLE, mxConstants.FONT_BOLD);
        centerStyle.put(mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE);
        stylesheet.putCellStyle(STYLE_CENTER, centerStyle);

        // Normal node style
        Map<String, Object> normalStyle = new HashMap<>();
        normalStyle.put(mxConstants.STYLE_SHAPE, mxConstants.SHAPE_RECTANGLE);
        normalStyle.put(mxConstants.STYLE_ROUNDED, true);
        normalStyle.put(mxConstants.STYLE_FILLCOLOR, colorToHex(normalNodeBg));
        normalStyle.put(mxConstants.STYLE_STROKECOLOR, colorToHex(normalNodeBorder));
        normalStyle.put(mxConstants.STYLE_STROKEWIDTH, 1);
        normalStyle.put(mxConstants.STYLE_FONTCOLOR, colorToHex(normalNodeText));
        normalStyle.put(mxConstants.STYLE_FONTSIZE, 10);
        normalStyle.put(mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE);
        stylesheet.putCellStyle(STYLE_NORMAL, normalStyle);

        // Vulnerable node style
        Map<String, Object> vulnStyle = new HashMap<>();
        vulnStyle.put(mxConstants.STYLE_SHAPE, mxConstants.SHAPE_RECTANGLE);
        vulnStyle.put(mxConstants.STYLE_ROUNDED, true);
        vulnStyle.put(mxConstants.STYLE_FILLCOLOR, colorToHex(vulnNodeBg));
        vulnStyle.put(mxConstants.STYLE_STROKECOLOR, colorToHex(vulnNodeBorder));
        vulnStyle.put(mxConstants.STYLE_STROKEWIDTH, 2);
        vulnStyle.put(mxConstants.STYLE_FONTCOLOR, colorToHex(vulnNodeText));
        vulnStyle.put(mxConstants.STYLE_FONTSIZE, 10);
        vulnStyle.put(mxConstants.STYLE_FONTSTYLE, mxConstants.FONT_BOLD);
        vulnStyle.put(mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE);
        stylesheet.putCellStyle(STYLE_VULN, vulnStyle);

        // Edge styles
        Map<String, Object> callsEdgeStyle = new HashMap<>();
        callsEdgeStyle.put(mxConstants.STYLE_STROKECOLOR, colorToHex(callsEdgeColor));
        callsEdgeStyle.put(mxConstants.STYLE_STROKEWIDTH, 2);
        callsEdgeStyle.put(mxConstants.STYLE_ENDARROW, mxConstants.ARROW_CLASSIC);
        callsEdgeStyle.put(mxConstants.STYLE_FONTSIZE, 9);
        callsEdgeStyle.put(mxConstants.STYLE_FONTCOLOR, colorToHex(textColor));
        stylesheet.putCellStyle(STYLE_EDGE_CALLS, callsEdgeStyle);

        Map<String, Object> refsEdgeStyle = new HashMap<>();
        refsEdgeStyle.put(mxConstants.STYLE_STROKECOLOR, colorToHex(refsEdgeColor));
        refsEdgeStyle.put(mxConstants.STYLE_STROKEWIDTH, 1);
        refsEdgeStyle.put(mxConstants.STYLE_DASHED, true);
        refsEdgeStyle.put(mxConstants.STYLE_ENDARROW, mxConstants.ARROW_CLASSIC);
        refsEdgeStyle.put(mxConstants.STYLE_FONTSIZE, 9);
        refsEdgeStyle.put(mxConstants.STYLE_FONTCOLOR, colorToHex(textColor));
        stylesheet.putCellStyle(STYLE_EDGE_REFS, refsEdgeStyle);

        Map<String, Object> vulnEdgeStyle = new HashMap<>();
        vulnEdgeStyle.put(mxConstants.STYLE_STROKECOLOR, colorToHex(vulnEdgeColor));
        vulnEdgeStyle.put(mxConstants.STYLE_STROKEWIDTH, 2);
        vulnEdgeStyle.put(mxConstants.STYLE_ENDARROW, mxConstants.ARROW_CLASSIC);
        vulnEdgeStyle.put(mxConstants.STYLE_FONTSIZE, 9);
        vulnEdgeStyle.put(mxConstants.STYLE_FONTCOLOR, colorToHex(textColor));
        stylesheet.putCellStyle(STYLE_EDGE_VULN, vulnEdgeStyle);

        Map<String, Object> networkEdgeStyle = new HashMap<>();
        networkEdgeStyle.put(mxConstants.STYLE_STROKECOLOR, colorToHex(networkEdgeColor));
        networkEdgeStyle.put(mxConstants.STYLE_STROKEWIDTH, 2);
        networkEdgeStyle.put(mxConstants.STYLE_ENDARROW, mxConstants.ARROW_CLASSIC);
        networkEdgeStyle.put(mxConstants.STYLE_FONTSIZE, 9);
        networkEdgeStyle.put(mxConstants.STYLE_FONTCOLOR, colorToHex(textColor));
        stylesheet.putCellStyle(STYLE_EDGE_NETWORK, networkEdgeStyle);
    }

    /**
     * Check if a color is dark (for determining light vs dark mode).
     */
    private boolean isColorDark(Color color) {
        if (color == null) return false;
        // Use perceived brightness formula
        double brightness = (color.getRed() * 299 + color.getGreen() * 587 + color.getBlue() * 114) / 1000.0;
        return brightness < 128;
    }

    /**
     * Convert Color to hex string for JGraphX styles.
     */
    private String colorToHex(Color color) {
        return String.format("#%02X%02X%02X", color.getRed(), color.getGreen(), color.getBlue());
    }

    private void initializeComponents() {
        // N-Hops spinner
        SpinnerNumberModel spinnerModel = new SpinnerNumberModel(2, 1, 5, 1);
        nHopsSpinner = new JSpinner(spinnerModel);
        nHopsSpinner.setPreferredSize(new Dimension(75, 25));

        // Edge type checkboxes
        showCallsCheckbox = new JCheckBox("CALLS", true);
        showVulnCheckbox = new JCheckBox("VULN", true);
        showNetworkCheckbox = new JCheckBox("NETWORK", true);

        // Zoom controls
        zoomInButton = new JButton("+");
        zoomInButton.setToolTipText("Zoom In");
        zoomInButton.setMargin(new Insets(2, 6, 2, 6));

        zoomOutButton = new JButton("-");
        zoomOutButton.setToolTipText("Zoom Out");
        zoomOutButton.setMargin(new Insets(2, 6, 2, 6));

        zoomFitButton = new JButton("Fit");
        zoomFitButton.setToolTipText("Fit to View (1:1)");
        zoomFitButton.setMargin(new Insets(2, 6, 2, 6));

        zoomLabel = new JLabel("100%");
        zoomLabel.setToolTipText("Current zoom level (CTRL+Wheel to zoom)");

        // Markdown helper for rendering summaries
        markdownHelper = new MarkdownHelper();

        // Selected node info
        selectedNodeLabel = new JLabel("Double-click a node to navigate");
        selectedNodeLabel.setForeground(UIManager.getColor("Label.disabledForeground"));

        // Summary pane for rendering markdown
        summaryPane = new JEditorPane();
        summaryPane.setContentType("text/html");
        summaryPane.setEditable(false);
        summaryPane.setOpaque(false);
        summaryPane.putClientProperty(JEditorPane.HONOR_DISPLAY_PROPERTIES, Boolean.TRUE);
        summaryPane.setFont(UIManager.getFont("Label.font"));

        summaryScrollPane = new JScrollPane(summaryPane);
        summaryScrollPane.setBorder(BorderFactory.createEmptyBorder());
        summaryScrollPane.setPreferredSize(new Dimension(400, 120));
        summaryScrollPane.getVerticalScrollBar().setUnitIncrement(16);

        // Not indexed placeholder
        notIndexedPanel = createNotIndexedPanel();

        // Card layout
        cardLayout = new CardLayout();
        contentPanel = new JPanel(cardLayout);
    }

    private JPanel createNotIndexedPanel() {
        JPanel panel = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.insets = new Insets(10, 10, 10, 10);

        JLabel messageLabel = new JLabel("<html><center>Function not yet indexed in<br>the knowledge graph.</center></html>");
        messageLabel.setHorizontalAlignment(SwingConstants.CENTER);
        panel.add(messageLabel, gbc);

        gbc.gridy = 1;
        JButton indexButton = new JButton("Index This Function");
        indexButton.addActionListener(e -> controller.handleSemanticGraphIndexFunction(parentTab.getCurrentAddress()));
        panel.add(indexButton, gbc);

        gbc.gridy = 2;
        JLabel orLabel = new JLabel("Or index the entire binary:");
        panel.add(orLabel, gbc);

        gbc.gridy = 3;
        JButton reindexButton = new JButton("ReIndex Binary");
        reindexButton.addActionListener(e -> controller.handleSemanticGraphReindex());
        panel.add(reindexButton, gbc);

        return panel;
    }

    private void layoutComponents() {
        // ===== Main content panel =====
        JPanel mainContent = new JPanel(new BorderLayout(5, 5));
        mainContent.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        // ===== Top controls =====
        JPanel controlsPanel = new JPanel(new BorderLayout());

        // Left side: N-Hops and Edge Types
        JPanel leftControls = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 5));
        leftControls.add(new JLabel("N-Hops:"));
        leftControls.add(nHopsSpinner);
        leftControls.add(Box.createHorizontalStrut(10));
        leftControls.add(new JLabel("Edge Types:"));
        leftControls.add(showCallsCheckbox);
        leftControls.add(showVulnCheckbox);
        leftControls.add(showNetworkCheckbox);

        // Right side: Zoom controls
        JPanel zoomControls = new JPanel(new FlowLayout(FlowLayout.RIGHT, 5, 5));
        zoomControls.add(new JLabel("Zoom:"));
        zoomControls.add(zoomOutButton);
        zoomControls.add(zoomLabel);
        zoomControls.add(zoomInButton);
        zoomControls.add(zoomFitButton);

        controlsPanel.add(leftControls, BorderLayout.WEST);
        controlsPanel.add(zoomControls, BorderLayout.EAST);

        mainContent.add(controlsPanel, BorderLayout.NORTH);

        // ===== Selected node info and summary (bottom) =====
        JPanel infoPanel = new JPanel(new BorderLayout(5, 5));
        infoPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        infoPanel.add(selectedNodeLabel, BorderLayout.NORTH);
        infoPanel.add(summaryScrollPane, BorderLayout.CENTER);

        // ===== Resizable split between graph and summary =====
        JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, graphComponent, infoPanel);
        splitPane.setResizeWeight(0.8);
        splitPane.setContinuousLayout(true);
        splitPane.setBorder(BorderFactory.createEmptyBorder());

        mainContent.add(splitPane, BorderLayout.CENTER);

        // ===== Card layout setup =====
        contentPanel.add(mainContent, "content");
        contentPanel.add(notIndexedPanel, "notIndexed");

        add(contentPanel, BorderLayout.CENTER);

        // Default to not indexed
        cardLayout.show(contentPanel, "notIndexed");
    }

    private void setupListeners() {
        // N-Hops change
        nHopsSpinner.addChangeListener(e -> refresh());

        // Edge type filters
        showCallsCheckbox.addActionListener(e -> refresh());
        showVulnCheckbox.addActionListener(e -> refresh());
        showNetworkCheckbox.addActionListener(e -> refresh());

        // Zoom button handlers
        zoomInButton.addActionListener(e -> {
            graphComponent.zoomIn();
            updateZoomLabel();
        });

        zoomOutButton.addActionListener(e -> {
            graphComponent.zoomOut();
            updateZoomLabel();
        });

        zoomFitButton.addActionListener(e -> {
            graphComponent.zoomActual();
            graphComponent.zoomAndCenter();
            updateZoomLabel();
        });

        // Graph click handler
        graphComponent.getGraphControl().addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                Object cell = graphComponent.getCellAt(e.getX(), e.getY());
                if (cell != null && cell instanceof mxCell) {
                    mxCell mxc = (mxCell) cell;
                    if (mxc.isVertex()) {
                        handleNodeClick(mxc);

                        // Double-click to navigate (skip external functions with null address)
                        if (e.getClickCount() == 2 && selectedNode != null && selectedNode.getAddress() != null) {
                            parentTab.navigateToFunction(selectedNode.getAddress());
                        }
                    }
                } else {
                    clearSelection();
                }
            }
        });
    }

    // ===== Public Methods =====

    /**
     * Refresh the graph view.
     */
    public void refresh() {
        int nHops = (Integer) nHopsSpinner.getValue();
        Set<EdgeType> edgeTypes = getSelectedEdgeTypes();
        controller.handleSemanticGraphVisualRefresh(this, parentTab.getCurrentAddress(), nHops, edgeTypes);
    }

    /**
     * Show the "not indexed" placeholder.
     */
    public void showNotIndexed() {
        cardLayout.show(contentPanel, "notIndexed");
    }

    /**
     * Show the main content.
     */
    public void showContent() {
        cardLayout.show(contentPanel, "content");
    }

    /**
     * Build and display the graph with the given nodes and edges.
     *
     * @param centerNode The center node (current function)
     * @param nodes All nodes to display
     * @param edges All edges to display
     */
    public void buildGraph(KnowledgeNode centerNode, List<KnowledgeNode> nodes, List<GraphEdge> edges) {
        Object centerCell = null;

        graph.getModel().beginUpdate();
        try {
            // Clear existing graph
            graph.removeCells(graph.getChildVertices(graph.getDefaultParent()));
            cellToNodeMap.clear();

            Object parent = graph.getDefaultParent();
            Map<String, Object> nodeIdToCellMap = new HashMap<>();

            // Create node cells
            for (KnowledgeNode node : nodes) {
                String label = formatNodeLabel(node);
                String style = getNodeStyle(node, centerNode);

                Object cell = graph.insertVertex(parent, node.getId(), label,
                        0, 0, 120, 50, style);

                nodeIdToCellMap.put(node.getId(), cell);
                cellToNodeMap.put(cell, node);

                // Track the center node's cell for centering later
                if (node.getId().equals(centerNode.getId())) {
                    centerCell = cell;
                }
            }

            // Find callers of the center node (nodes that have CALLS edges TO centerNode)
            // These should be at the top of the hierarchy (row 0)
            List<Object> callerCells = new java.util.ArrayList<>();
            for (GraphEdge edge : edges) {
                if (edge.getType() == EdgeType.CALLS &&
                    edge.getTargetId().equals(centerNode.getId())) {
                    Object callerCell = nodeIdToCellMap.get(edge.getSourceId());
                    if (callerCell != null && !callerCells.contains(callerCell)) {
                        callerCells.add(callerCell);
                    }
                }
            }

            // Create edge cells
            for (GraphEdge edge : edges) {
                Object sourceCell = nodeIdToCellMap.get(edge.getSourceId());
                Object targetCell = nodeIdToCellMap.get(edge.getTargetId());

                if (sourceCell != null && targetCell != null) {
                    String edgeStyle = getEdgeStyle(edge.getType());
                    String label = edge.getType().getDisplayName();
                    graph.insertEdge(parent, edge.getId(), label, sourceCell, targetCell, edgeStyle);
                }
            }

            // Apply layout - use hierarchical if possible, fall back to organic for cyclic graphs
            try {
                mxHierarchicalLayout layout = new mxHierarchicalLayout(graph);
                layout.setInterRankCellSpacing(80);
                layout.setIntraCellSpacing(40);

                // If we have callers, use them as roots so they appear at the top
                // Otherwise let the layout determine roots automatically
                if (!callerCells.isEmpty()) {
                    layout.execute(parent, callerCells);
                } else {
                    layout.execute(parent);
                }
            } catch (Exception e) {
                // Hierarchical layout fails on cyclic graphs - fall back to organic layout
                Msg.debug(this, "Hierarchical layout failed, using organic layout: " + e.getMessage());
                mxOrganicLayout organicLayout = new mxOrganicLayout(graph);
                // Increase node separation to reduce overlaps
                organicLayout.setMinMoveRadius(50.0);
                organicLayout.setMaxIterations(500);
                organicLayout.execute(parent);
            }

        } finally {
            graph.getModel().endUpdate();
        }

        // Center on the root node
        if (centerCell != null) {
            graph.getView().setScale(1.0);  // Reset zoom first
            graphComponent.scrollCellToVisible(centerCell, true);
            if (centerCell instanceof mxCell) {
                handleNodeClick((mxCell) centerCell);
            }
        } else {
            graphComponent.zoomAndCenter();
        }
    }

    // ===== Private Helper Methods =====

    private Set<EdgeType> getSelectedEdgeTypes() {
        Set<EdgeType> types = new HashSet<>();
        if (showCallsCheckbox.isSelected()) {
            types.add(EdgeType.CALLS);
        }
        if (showVulnCheckbox.isSelected()) {
            types.add(EdgeType.CALLS_VULNERABLE);
        }
        if (showNetworkCheckbox.isSelected()) {
            types.add(EdgeType.NETWORK_SEND);
            types.add(EdgeType.NETWORK_RECV);
        }
        return types;
    }

    /**
     * Update the zoom label to show current zoom percentage.
     */
    private void updateZoomLabel() {
        double scale = graphComponent.getGraph().getView().getScale();
        int percentage = (int) Math.round(scale * 100);
        zoomLabel.setText(percentage + "%");
    }

    private String formatNodeLabel(KnowledgeNode node) {
        String name = node.getName();
        boolean isExternal = node.getAddress() == null;

        if (name == null || name.isEmpty()) {
            if (isExternal) {
                name = "[Unknown External]";
            } else {
                name = "0x" + Long.toHexString(node.getAddress());
            }
        }
        if (name.length() > 20) {
            name = name.substring(0, 17) + "...";
        }

        String addr = isExternal ? "[EXTERNAL]" : "0x" + Long.toHexString(node.getAddress());

        StringBuilder label = new StringBuilder();
        label.append(name).append("\n").append(addr);

        if (node.hasSecurityFlags()) {
            label.append("\n[VULN]");
        }

        return label.toString();
    }

    private String getNodeStyle(KnowledgeNode node, KnowledgeNode centerNode) {
        if (node.getId().equals(centerNode.getId())) {
            return STYLE_CENTER;
        } else if (node.hasSecurityFlags()) {
            return STYLE_VULN;
        } else {
            return STYLE_NORMAL;
        }
    }

    private String getEdgeStyle(EdgeType type) {
        switch (type) {
            case CALLS:
                return STYLE_EDGE_CALLS;
            case REFERENCES:
                return STYLE_EDGE_REFS;
            case CALLS_VULNERABLE:
                return STYLE_EDGE_VULN;
            case NETWORK_SEND:
            case NETWORK_RECV:
                return STYLE_EDGE_NETWORK;
            default:
                return STYLE_EDGE_CALLS;
        }
    }

    private void handleNodeClick(mxCell cell) {
        KnowledgeNode node = cellToNodeMap.get(cell);
        if (node != null) {
            selectedNode = node;
            String addrStr = node.getAddress() != null
                ? "@ 0x" + Long.toHexString(node.getAddress())
                : "[EXTERNAL]";
            selectedNodeLabel.setText(node.getName() + " " + addrStr + "  (double-click to navigate)");
            selectedNodeLabel.setForeground(UIManager.getColor("Label.foreground"));

            String summary = node.getLlmSummary();
            if (summary != null && !summary.isEmpty()) {
                // Render markdown to HTML
                String html = markdownHelper.markdownToHtmlSimple(summary);
                summaryPane.setText(html);
                summaryPane.setCaretPosition(0);  // Scroll to top
            } else {
                summaryPane.setText("<html><body><i style='color:gray'>No summary available</i></body></html>");
            }

            // Highlight the selected cell
            graph.setSelectionCell(cell);
        }
    }

    private void clearSelection() {
        selectedNode = null;
        selectedNodeLabel.setText("Double-click a node to navigate");
        selectedNodeLabel.setForeground(UIManager.getColor("Label.disabledForeground"));
        summaryPane.setText("");
        graph.clearSelection();
    }
}

```

`src/main/java/ghidrassist/ui/tabs/semanticgraph/ListViewPanel.java`:

```java
package ghidrassist.ui.tabs.semanticgraph;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.List;
import java.util.ArrayList;

import ghidrassist.core.TabController;
import ghidrassist.ui.tabs.SemanticGraphTab;
import ghidrassist.graphrag.nodes.KnowledgeNode;
import ghidrassist.graphrag.BinaryKnowledgeGraph.GraphEdge;

/**
 * List/table view sub-panel for the Semantic Graph tab.
 * Displays callers, callees, edges, security flags, and LLM summary.
 */
public class ListViewPanel extends JPanel {
    private static final long serialVersionUID = 1L;

    private final TabController controller;
    private final SemanticGraphTab parentTab;

    // Left column - relationships
    private JList<FunctionEntry> callersList;
    private DefaultListModel<FunctionEntry> callersModel;
    private JList<FunctionEntry> calleesList;
    private DefaultListModel<FunctionEntry> calleesModel;
    private JTable edgesTable;
    private DefaultTableModel edgesTableModel;
    private JComboBox<String> edgeTypeFilter;

    // Right column - node details
    private JPanel securityFlagsPanel;
    private JTextArea summaryTextArea;
    private JButton editSummaryButton;
    private JButton addFlagButton;
    private boolean isEditingSummary = false;

    // Not-indexed placeholder
    private JPanel notIndexedPanel;
    private JPanel contentPanel;
    private CardLayout cardLayout;

    // Known security flags
    private static final String[] KNOWN_FLAGS = {
            "BUFFER_OVERFLOW_RISK",
            "COMMAND_INJECTION_RISK",
            "FORMAT_STRING_RISK",
            "USE_AFTER_FREE_RISK",
            "PATH_TRAVERSAL_RISK",
            "INTEGER_OVERFLOW_RISK",
            "NULL_DEREF_RISK",
            "MEMORY_LEAK_RISK",
            "RACE_CONDITION_RISK",
            "HANDLES_USER_INPUT",
            "PARSES_NETWORK_DATA",
            "CRYPTO_OPERATION",
            "AUTHENTICATION"
    };

    public ListViewPanel(TabController controller, SemanticGraphTab parentTab) {
        super(new BorderLayout());
        this.controller = controller;
        this.parentTab = parentTab;
        initializeComponents();
        layoutComponents();
        setupListeners();
    }

    private void initializeComponents() {
        // Callers list
        callersModel = new DefaultListModel<>();
        callersList = new JList<>(callersModel);
        callersList.setCellRenderer(new FunctionEntryCellRenderer());
        callersList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);

        // Callees list
        calleesModel = new DefaultListModel<>();
        calleesList = new JList<>(calleesModel);
        calleesList.setCellRenderer(new FunctionEntryCellRenderer());
        calleesList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);

        // Edges table
        String[] edgeColumns = {"Type", "Target", "Weight", "Actions"};
        edgesTableModel = new DefaultTableModel(edgeColumns, 0) {
            private static final long serialVersionUID = 1L;
            @Override
            public boolean isCellEditable(int row, int column) {
                return column == 3; // Only Actions column is "editable" (for button clicks)
            }
        };
        edgesTable = new JTable(edgesTableModel);
        edgesTable.getColumnModel().getColumn(0).setPreferredWidth(120);
        edgesTable.getColumnModel().getColumn(1).setPreferredWidth(150);
        edgesTable.getColumnModel().getColumn(2).setPreferredWidth(60);
        edgesTable.getColumnModel().getColumn(3).setPreferredWidth(100);

        // Edge type filter
        String[] filterOptions = {"All Types", "CALLS", "REFERENCES", "CALLS_VULNERABLE", "SIMILAR_PURPOSE",
                                  "TAINT_FLOWS_TO", "VULNERABLE_VIA", "NETWORK_SEND", "NETWORK_RECV"};
        edgeTypeFilter = new JComboBox<>(filterOptions);

        // Security flags panel (will be populated dynamically)
        securityFlagsPanel = new JPanel();
        securityFlagsPanel.setLayout(new BoxLayout(securityFlagsPanel, BoxLayout.Y_AXIS));

        // Summary text area
        summaryTextArea = new JTextArea();
        summaryTextArea.setLineWrap(true);
        summaryTextArea.setWrapStyleWord(true);
        summaryTextArea.setEditable(false);
        summaryTextArea.setFont(new Font("SansSerif", Font.PLAIN, 12));

        // Buttons
        editSummaryButton = new JButton("Edit");
        addFlagButton = new JButton("+ Add Custom Flag...");

        // Not indexed placeholder
        notIndexedPanel = createNotIndexedPanel();

        // Card layout to switch between content and placeholder
        cardLayout = new CardLayout();
        contentPanel = new JPanel(cardLayout);
    }

    private JPanel createNotIndexedPanel() {
        JPanel panel = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.insets = new Insets(10, 10, 10, 10);

        JLabel messageLabel = new JLabel("<html><center>Function not yet indexed in<br>the knowledge graph.</center></html>");
        messageLabel.setHorizontalAlignment(SwingConstants.CENTER);
        panel.add(messageLabel, gbc);

        gbc.gridy = 1;
        JButton indexButton = new JButton("Index This Function");
        indexButton.addActionListener(e -> controller.handleSemanticGraphIndexFunction(parentTab.getCurrentAddress()));
        panel.add(indexButton, gbc);

        gbc.gridy = 2;
        JLabel orLabel = new JLabel("Or index the entire binary:");
        panel.add(orLabel, gbc);

        gbc.gridy = 3;
        JButton reindexButton = new JButton("ReIndex Binary");
        reindexButton.addActionListener(e -> controller.handleSemanticGraphReindex());
        panel.add(reindexButton, gbc);

        return panel;
    }

    private void layoutComponents() {
        // ===== Main content panel =====
        JPanel mainContent = new JPanel(new BorderLayout(5, 5));
        mainContent.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        // Create split pane for left/right columns
        JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
        splitPane.setResizeWeight(0.6); // Left panel gets 60%

        // ===== Left Column (Relationships) =====
        JPanel leftColumn = new JPanel();
        leftColumn.setLayout(new BoxLayout(leftColumn, BoxLayout.Y_AXIS));

        // Callers panel
        JPanel callersPanel = new JPanel(new BorderLayout());
        callersPanel.setBorder(BorderFactory.createTitledBorder("CALLERS"));
        callersPanel.add(new JScrollPane(callersList), BorderLayout.CENTER);
        callersPanel.setPreferredSize(new Dimension(300, 150));
        leftColumn.add(callersPanel);

        leftColumn.add(Box.createVerticalStrut(5));

        // Callees panel
        JPanel calleesPanel = new JPanel(new BorderLayout());
        calleesPanel.setBorder(BorderFactory.createTitledBorder("CALLEES"));
        calleesPanel.add(new JScrollPane(calleesList), BorderLayout.CENTER);
        calleesPanel.setPreferredSize(new Dimension(300, 150));
        leftColumn.add(calleesPanel);

        leftColumn.add(Box.createVerticalStrut(5));

        // Edges panel
        JPanel edgesPanel = new JPanel(new BorderLayout(5, 5));
        edgesPanel.setBorder(BorderFactory.createTitledBorder("EDGES"));

        JPanel filterRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        filterRow.add(new JLabel("Filter:"));
        filterRow.add(edgeTypeFilter);
        edgesPanel.add(filterRow, BorderLayout.NORTH);
        edgesPanel.add(new JScrollPane(edgesTable), BorderLayout.CENTER);

        leftColumn.add(edgesPanel);

        splitPane.setLeftComponent(new JScrollPane(leftColumn));

        // ===== Right Column (Node Details) =====
        JPanel rightColumn = new JPanel();
        rightColumn.setLayout(new BoxLayout(rightColumn, BoxLayout.Y_AXIS));

        // Security flags panel
        JPanel flagsWrapper = new JPanel(new BorderLayout());
        flagsWrapper.setBorder(BorderFactory.createTitledBorder("SECURITY FLAGS"));

        JScrollPane flagsScroll = new JScrollPane(securityFlagsPanel);
        flagsScroll.setPreferredSize(new Dimension(200, 200));
        flagsWrapper.add(flagsScroll, BorderLayout.CENTER);

        JPanel addFlagRow = new JPanel(new FlowLayout(FlowLayout.LEFT));
        addFlagRow.add(addFlagButton);
        flagsWrapper.add(addFlagRow, BorderLayout.SOUTH);

        rightColumn.add(flagsWrapper);

        rightColumn.add(Box.createVerticalStrut(5));

        // LLM Summary panel
        JPanel summaryPanel = new JPanel(new BorderLayout());
        summaryPanel.setBorder(BorderFactory.createTitledBorder("LLM SUMMARY"));

        JScrollPane summaryScroll = new JScrollPane(summaryTextArea);
        summaryScroll.setPreferredSize(new Dimension(200, 150));
        summaryPanel.add(summaryScroll, BorderLayout.CENTER);

        JPanel editRow = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        editRow.add(editSummaryButton);
        summaryPanel.add(editRow, BorderLayout.SOUTH);

        rightColumn.add(summaryPanel);

        splitPane.setRightComponent(rightColumn);

        mainContent.add(splitPane, BorderLayout.CENTER);

        // ===== Card layout setup =====
        contentPanel.add(mainContent, "content");
        contentPanel.add(notIndexedPanel, "notIndexed");

        add(contentPanel, BorderLayout.CENTER);

        // Default to not indexed
        cardLayout.show(contentPanel, "notIndexed");
    }

    private void setupListeners() {
        // Double-click on callers list to navigate
        callersList.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (e.getClickCount() == 2) {
                    FunctionEntry selected = callersList.getSelectedValue();
                    if (selected != null && !selected.isExternal()) {
                        parentTab.navigateToFunction(selected.address);
                    }
                    // External functions have no address to navigate to
                }
            }
        });

        // Double-click on callees list to navigate
        calleesList.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (e.getClickCount() == 2) {
                    FunctionEntry selected = calleesList.getSelectedValue();
                    if (selected != null && !selected.isExternal()) {
                        parentTab.navigateToFunction(selected.address);
                    }
                    // External functions have no address to navigate to
                }
            }
        });

        // Edge type filter
        edgeTypeFilter.addActionListener(e -> refreshEdgesTable());

        // Edit summary button
        editSummaryButton.addActionListener(e -> toggleSummaryEdit());

        // Add custom flag button
        addFlagButton.addActionListener(e -> showAddFlagDialog());

        // Edges table click handler
        edgesTable.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                int row = edgesTable.rowAtPoint(e.getPoint());
                int col = edgesTable.columnAtPoint(e.getPoint());
                if (row >= 0 && col == 3) {
                    // Actions column clicked - could add View/Delete buttons here
                    handleEdgeAction(row);
                }
            }
        });
    }

    // ===== Public Methods =====

    /**
     * Refresh the panel with data for the current function.
     */
    public void refresh() {
        controller.handleSemanticGraphListViewRefresh(this, parentTab.getCurrentAddress());
    }

    /**
     * Show the "not indexed" placeholder.
     */
    public void showNotIndexed() {
        cardLayout.show(contentPanel, "notIndexed");
    }

    /**
     * Show the main content (when node is indexed).
     */
    public void showContent() {
        cardLayout.show(contentPanel, "content");
    }

    /**
     * Update the callers list.
     */
    public void setCallers(List<KnowledgeNode> callers) {
        callersModel.clear();
        for (KnowledgeNode node : callers) {
            boolean hasVuln = node.hasSecurityFlags();
            String summary = node.getLlmSummary();
            if (summary == null || summary.isEmpty()) {
                summary = "";
            } else if (summary.length() > 50) {
                summary = summary.substring(0, 47) + "...";
            }
            callersModel.addElement(new FunctionEntry(
                    node.getName(),
                    node.getAddress(),
                    summary,
                    hasVuln
            ));
        }
        updateCallersBorder(callers.size());
    }

    /**
     * Update the callees list.
     */
    public void setCallees(List<KnowledgeNode> callees) {
        calleesModel.clear();
        for (KnowledgeNode node : callees) {
            boolean hasVuln = node.hasSecurityFlags();
            String summary = node.getLlmSummary();
            if (summary == null || summary.isEmpty()) {
                summary = "";
            } else if (summary.length() > 50) {
                summary = summary.substring(0, 47) + "...";
            }
            calleesModel.addElement(new FunctionEntry(
                    node.getName(),
                    node.getAddress(),
                    summary,
                    hasVuln
            ));
        }
        updateCalleesBorder(callees.size());
    }

    /**
     * Update the edges table.
     */
    public void setEdges(List<GraphEdge> edges) {
        // Store all edges for filtering
        this.allEdges = edges;
        refreshEdgesTable();
    }

    private List<GraphEdge> allEdges = new ArrayList<>();

    private void refreshEdgesTable() {
        edgesTableModel.setRowCount(0);
        String filter = (String) edgeTypeFilter.getSelectedItem();

        for (GraphEdge edge : allEdges) {
            if (filter.equals("All Types") || edge.getType().name().equals(filter)) {
                edgesTableModel.addRow(new Object[]{
                        edge.getType().getDisplayName(),
                        edge.getTargetId(), // Should be resolved to name
                        String.format("%.2f", edge.getWeight()),
                        "[View]"
                });
            }
        }

        updateEdgesBorder(edgesTableModel.getRowCount());
    }

    /**
     * Update security flags panel.
     */
    public void setSecurityFlags(List<String> flags) {
        securityFlagsPanel.removeAll();

        for (String knownFlag : KNOWN_FLAGS) {
            JCheckBox checkbox = new JCheckBox(knownFlag);
            checkbox.setSelected(flags.contains(knownFlag));
            checkbox.addActionListener(e -> handleFlagChange(knownFlag, checkbox.isSelected()));
            securityFlagsPanel.add(checkbox);
        }

        // Add any custom flags not in the known list
        for (String flag : flags) {
            boolean isKnown = false;
            for (String known : KNOWN_FLAGS) {
                if (known.equals(flag)) {
                    isKnown = true;
                    break;
                }
            }
            if (!isKnown) {
                JCheckBox checkbox = new JCheckBox(flag);
                checkbox.setSelected(true);
                checkbox.addActionListener(e -> handleFlagChange(flag, checkbox.isSelected()));
                securityFlagsPanel.add(checkbox);
            }
        }

        securityFlagsPanel.revalidate();
        securityFlagsPanel.repaint();
    }

    /**
     * Update LLM summary.
     */
    public void setSummary(String summary) {
        summaryTextArea.setText(summary != null ? summary : "");
        summaryTextArea.setCaretPosition(0);
    }

    // ===== Private Helper Methods =====

    private void updateCallersBorder(int count) {
        JPanel panel = (JPanel) callersList.getParent().getParent().getParent();
        panel.setBorder(BorderFactory.createTitledBorder("CALLERS (" + count + ")"));
    }

    private void updateCalleesBorder(int count) {
        JPanel panel = (JPanel) calleesList.getParent().getParent().getParent();
        panel.setBorder(BorderFactory.createTitledBorder("CALLEES (" + count + ")"));
    }

    private void updateEdgesBorder(int count) {
        JPanel panel = (JPanel) edgesTable.getParent().getParent().getParent();
        panel.setBorder(BorderFactory.createTitledBorder("EDGES (" + count + ")"));
    }

    private void toggleSummaryEdit() {
        if (isEditingSummary) {
            // Save changes
            String newSummary = summaryTextArea.getText();
            controller.handleSemanticGraphSaveSummary(parentTab.getCurrentAddress(), newSummary);
            summaryTextArea.setEditable(false);
            editSummaryButton.setText("Edit");
            isEditingSummary = false;
        } else {
            // Enter edit mode
            summaryTextArea.setEditable(true);
            editSummaryButton.setText("Save");
            isEditingSummary = true;
        }
    }

    private void showAddFlagDialog() {
        String flag = JOptionPane.showInputDialog(this,
                "Enter custom security flag:",
                "Add Security Flag",
                JOptionPane.PLAIN_MESSAGE);

        if (flag != null && !flag.trim().isEmpty()) {
            flag = flag.trim().toUpperCase().replace(" ", "_");
            controller.handleSemanticGraphAddFlag(parentTab.getCurrentAddress(), flag);
            refresh(); // Refresh to show new flag
        }
    }

    private void handleFlagChange(String flag, boolean selected) {
        if (selected) {
            controller.handleSemanticGraphAddFlag(parentTab.getCurrentAddress(), flag);
        } else {
            controller.handleSemanticGraphRemoveFlag(parentTab.getCurrentAddress(), flag);
        }
    }

    private void handleEdgeAction(int row) {
        // For now, just navigate to the target
        String targetId = (String) edgesTableModel.getValueAt(row, 1);
        // The targetId should be resolved to an address - controller will handle this
        controller.handleSemanticGraphEdgeClick(targetId);
    }

    // ===== Inner Classes =====

    /**
     * Entry for function lists (callers/callees).
     * Address can be null for external functions.
     */
    static class FunctionEntry {
        final String name;
        final Long address;  // Nullable - null means external function
        final String summary;
        final boolean hasVulnerability;

        FunctionEntry(String name, Long address, String summary, boolean hasVulnerability) {
            this.name = name;
            this.address = address;
            this.summary = summary;
            this.hasVulnerability = hasVulnerability;
        }

        boolean isExternal() {
            return address == null;
        }

        @Override
        public String toString() {
            return name;
        }
    }

    /**
     * Cell renderer for function entries showing name, address, and vulnerability badge.
     */
    static class FunctionEntryCellRenderer extends DefaultListCellRenderer {
        private static final long serialVersionUID = 1L;
        @Override
        public Component getListCellRendererComponent(JList<?> list, Object value,
                int index, boolean isSelected, boolean cellHasFocus) {

            JPanel panel = new JPanel(new BorderLayout(5, 2));
            panel.setOpaque(true);

            if (isSelected) {
                panel.setBackground(list.getSelectionBackground());
                panel.setForeground(list.getSelectionForeground());
            } else {
                panel.setBackground(list.getBackground());
                panel.setForeground(list.getForeground());
            }

            if (value instanceof FunctionEntry) {
                FunctionEntry entry = (FunctionEntry) value;

                // Top row: name and address
                JPanel topRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 2, 0));
                topRow.setOpaque(false);

                JLabel nameLabel = new JLabel(entry.name);
                nameLabel.setFont(nameLabel.getFont().deriveFont(Font.BOLD));
                topRow.add(nameLabel);

                // Show address or [EXTERNAL] for external functions
                if (entry.isExternal()) {
                    JLabel extLabel = new JLabel("[EXTERNAL]");
                    extLabel.setForeground(new Color(0, 100, 180)); // Blue for external
                    extLabel.setFont(extLabel.getFont().deriveFont(Font.ITALIC));
                    topRow.add(extLabel);
                } else {
                    JLabel addrLabel = new JLabel("@ 0x" + Long.toHexString(entry.address));
                    addrLabel.setForeground(Color.GRAY);
                    topRow.add(addrLabel);
                }

                if (entry.hasVulnerability) {
                    JLabel vulnLabel = new JLabel("[VULN]");
                    vulnLabel.setForeground(Color.RED);
                    vulnLabel.setFont(vulnLabel.getFont().deriveFont(Font.BOLD));
                    topRow.add(vulnLabel);
                }

                panel.add(topRow, BorderLayout.NORTH);

                // Bottom row: summary (if present)
                if (entry.summary != null && !entry.summary.isEmpty()) {
                    JLabel summaryLabel = new JLabel("  " + entry.summary);
                    summaryLabel.setForeground(Color.DARK_GRAY);
                    summaryLabel.setFont(summaryLabel.getFont().deriveFont(Font.ITALIC, 11f));
                    panel.add(summaryLabel, BorderLayout.SOUTH);
                }
            }

            panel.setBorder(BorderFactory.createEmptyBorder(2, 5, 2, 5));
            return panel;
        }
    }
}

```

`src/main/java/ghidrassist/ui/tabs/semanticgraph/ManualAnalysisPanel.java`:

```java
package ghidrassist.ui.tabs.semanticgraph;

import javax.swing.*;
import java.awt.*;
import ghidrassist.ui.tabs.SemanticGraphTab;

/**
 * Panel for manual analysis operations on the knowledge graph.
 * Provides buttons with descriptions for various analysis tasks
 * that can be run independently or as part of the full ReIndex workflow.
 */
public class ManualAnalysisPanel extends JPanel {
    private static final long serialVersionUID = 1L;

    private static final int BUTTON_WIDTH = 240;
    private static final int BUTTON_HEIGHT = 28;

    private final SemanticGraphTab parentTab;

    // Primary operations
    private JButton reindexButton;
    private JButton semanticAnalysisButton;

    // Secondary operations
    private JButton securityAnalysisButton;
    private JButton networkFlowButton;
    private JButton communityDetectionButton;
    private JButton refreshNamesButton;

    public ManualAnalysisPanel(SemanticGraphTab parentTab) {
        super(new BorderLayout());
        this.parentTab = parentTab;
        initializeComponents();
        layoutComponents();
        setupListeners();
    }

    private void initializeComponents() {
        reindexButton = new JButton("ReIndex Binary");
        semanticAnalysisButton = new JButton("Semantic Analysis");
        securityAnalysisButton = new JButton("Security Analysis");
        networkFlowButton = new JButton("Network Flow Analysis");
        communityDetectionButton = new JButton("Community Detection");
        refreshNamesButton = new JButton("Refresh Names");
    }

    private void layoutComponents() {
        JPanel contentPanel = new JPanel();
        contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
        contentPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // ===== Primary Operations Section =====
        JLabel primaryHeader = new JLabel("Primary Operations");
        primaryHeader.setFont(primaryHeader.getFont().deriveFont(Font.BOLD, 14f));
        primaryHeader.setAlignmentX(Component.LEFT_ALIGNMENT);
        contentPanel.add(primaryHeader);
        contentPanel.add(Box.createVerticalStrut(5));

        JLabel primaryDesc = new JLabel("<html><i>Full analysis workflows for the binary.</i></html>");
        primaryDesc.setAlignmentX(Component.LEFT_ALIGNMENT);
        contentPanel.add(primaryDesc);
        contentPanel.add(Box.createVerticalStrut(10));

        // ReIndex Binary
        contentPanel.add(createAnalysisRow(
            reindexButton,
            "Full Pipeline",
            "Extract structure from Ghidra analysis, then automatically run Security " +
            "and Network Flow analysis. Creates function nodes and call edges."
        ));
        contentPanel.add(Box.createVerticalStrut(8));

        // Semantic Analysis
        contentPanel.add(createAnalysisRow(
            semanticAnalysisButton,
            "LLM Summarization",
            "Use the configured LLM to generate summaries for all functions that " +
            "don't have summaries yet. Requires API credits."
        ));
        contentPanel.add(Box.createVerticalStrut(20));

        // ===== Secondary Operations Section =====
        JLabel secondaryHeader = new JLabel("Individual Analysis Operations");
        secondaryHeader.setFont(secondaryHeader.getFont().deriveFont(Font.BOLD, 14f));
        secondaryHeader.setAlignmentX(Component.LEFT_ALIGNMENT);
        contentPanel.add(secondaryHeader);
        contentPanel.add(Box.createVerticalStrut(5));

        JLabel secondaryDesc = new JLabel("<html><i>Run these analyses independently after indexing.</i></html>");
        secondaryDesc.setAlignmentX(Component.LEFT_ALIGNMENT);
        contentPanel.add(secondaryDesc);
        contentPanel.add(Box.createVerticalStrut(10));

        // Security Analysis
        contentPanel.add(createAnalysisRow(
            securityAnalysisButton,
            "Taint Analysis",
            "Find paths from input sources (user input, network) to dangerous sinks " +
            "(strcpy, system, SQL). Creates TAINT_FLOWS_TO and VULNERABLE_VIA edges."
        ));
        contentPanel.add(Box.createVerticalStrut(8));

        // Network Flow Analysis
        contentPanel.add(createAnalysisRow(
            networkFlowButton,
            "Network API Tracing",
            "Trace data flow through network send/recv APIs (WSASend, recv, send). " +
            "Creates NETWORK_SEND and NETWORK_RECV edges from entry points."
        ));
        contentPanel.add(Box.createVerticalStrut(8));

        // Community Detection
        contentPanel.add(createAnalysisRow(
            communityDetectionButton,
            "Function Clustering",
            "Group related functions into communities using Label Propagation algorithm. " +
            "Helps identify modules and subsystems in the binary."
        ));
        contentPanel.add(Box.createVerticalStrut(8));

        // Refresh Names
        contentPanel.add(createAnalysisRow(
            refreshNamesButton,
            "Sync Names",
            "Update function names in the graph to match current Ghidra names. " +
            "Use after renaming functions in Ghidra."
        ));

        // Add glue to push content to top
        contentPanel.add(Box.createVerticalGlue());

        // Wrap in scroll pane
        JScrollPane scrollPane = new JScrollPane(contentPanel);
        scrollPane.setBorder(null);
        scrollPane.getVerticalScrollBar().setUnitIncrement(16);

        add(scrollPane, BorderLayout.CENTER);
    }

    /**
     * Create a row with a button and description panel.
     */
    private JPanel createAnalysisRow(JButton button, String title, String description) {
        JPanel row = new JPanel(new BorderLayout(10, 0));
        row.setAlignmentX(Component.LEFT_ALIGNMENT);
        row.setMaximumSize(new Dimension(Integer.MAX_VALUE, 70));

        // Button panel (fixed width)
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        button.setPreferredSize(new Dimension(BUTTON_WIDTH, BUTTON_HEIGHT));
        buttonPanel.add(button);
        buttonPanel.setPreferredSize(new Dimension(BUTTON_WIDTH + 10, 40));

        // Description panel
        JPanel descPanel = new JPanel();
        descPanel.setLayout(new BoxLayout(descPanel, BoxLayout.Y_AXIS));

        JLabel titleLabel = new JLabel(title);
        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD));
        titleLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        JLabel descLabel = new JLabel("<html><body style='width: 350px'>" + description + "</body></html>");
        descLabel.setForeground(Color.GRAY);
        descLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        descPanel.add(titleLabel);
        descPanel.add(descLabel);

        row.add(buttonPanel, BorderLayout.WEST);
        row.add(descPanel, BorderLayout.CENTER);

        return row;
    }

    private void setupListeners() {
        reindexButton.addActionListener(e -> parentTab.handleReindexFromManual());
        semanticAnalysisButton.addActionListener(e -> parentTab.handleSemanticAnalysisFromManual());
        securityAnalysisButton.addActionListener(e -> parentTab.handleSecurityAnalysisFromManual());
        networkFlowButton.addActionListener(e -> parentTab.handleNetworkFlowFromManual());
        communityDetectionButton.addActionListener(e -> parentTab.handleCommunityDetectionFromManual());
        refreshNamesButton.addActionListener(e -> parentTab.handleRefreshNamesFromManual());
    }

    // ===== Button State Management =====

    public void setReindexRunning(boolean running) {
        reindexButton.setText(running ? "Stop" : "ReIndex Binary");
    }

    public void setSemanticAnalysisRunning(boolean running) {
        semanticAnalysisButton.setText(running ? "Stop" : "Semantic Analysis");
    }

    public void setSecurityAnalysisRunning(boolean running) {
        securityAnalysisButton.setText(running ? "Stop" : "Security Analysis");
    }

    public void setNetworkFlowRunning(boolean running) {
        networkFlowButton.setText(running ? "Stop" : "Network Flow Analysis");
    }

    public void setCommunityDetectionRunning(boolean running) {
        communityDetectionButton.setText(running ? "Stop" : "Community Detection");
    }

    public void setRefreshNamesRunning(boolean running) {
        refreshNamesButton.setText(running ? "Stop" : "Refresh Names");
    }

    public boolean isReindexRunning() {
        return "Stop".equals(reindexButton.getText());
    }

    public boolean isSemanticAnalysisRunning() {
        return "Stop".equals(semanticAnalysisButton.getText());
    }

    public boolean isSecurityAnalysisRunning() {
        return "Stop".equals(securityAnalysisButton.getText());
    }

    public boolean isNetworkFlowRunning() {
        return "Stop".equals(networkFlowButton.getText());
    }

    public boolean isCommunityDetectionRunning() {
        return "Stop".equals(communityDetectionButton.getText());
    }

    public boolean isRefreshNamesRunning() {
        return "Stop".equals(refreshNamesButton.getText());
    }

    /**
     * Refresh the panel (placeholder for future use).
     */
    public void refresh() {
        // Nothing to refresh currently
    }
}

```

`src/main/java/ghidrassist/ui/tabs/semanticgraph/SearchViewPanel.java`:

```java
package ghidrassist.ui.tabs.semanticgraph;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableRowSorter;
import java.awt.*;
import java.awt.datatransfer.StringSelection;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.concurrent.CompletableFuture;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

import ghidrassist.core.TabController;
import ghidrassist.ui.tabs.SemanticGraphTab;

/**
 * Search sub-panel for the Semantic Graph tab.
 * Provides a UI for testing and exploring Graph-RAG semantic query tools.
 */
public class SearchViewPanel extends JPanel {
    private static final long serialVersionUID = 1L;

    private final TabController controller;
    private final SemanticGraphTab parentTab;

    // Query type constants
    private static final String QUERY_SEMANTIC_SEARCH = "ga_search_semantic";
    private static final String QUERY_GET_ANALYSIS = "ga_get_semantic_analysis";
    private static final String QUERY_SIMILAR_FUNCTIONS = "ga_get_similar_functions";
    private static final String QUERY_CALL_CONTEXT = "ga_get_call_context";
    private static final String QUERY_SECURITY_ANALYSIS = "ga_get_security_analysis";
    private static final String QUERY_MODULE_SUMMARY = "ga_get_module_summary";
    private static final String QUERY_ACTIVITY_ANALYSIS = "ga_get_activity_analysis";

    // Query type radio buttons
    private ButtonGroup queryTypeGroup;
    private JRadioButton semanticSearchRadio;
    private JRadioButton getAnalysisRadio;
    private JRadioButton similarFunctionsRadio;
    private JRadioButton callContextRadio;
    private JRadioButton securityAnalysisRadio;
    private JRadioButton moduleSummaryRadio;
    private JRadioButton activityAnalysisRadio;

    // Parameter panels
    private JPanel paramsCardPanel;
    private CardLayout paramsCardLayout;

    // Common parameter fields
    private JTextField queryField;
    @SuppressWarnings("unused")  // UI component initialized but value accessed via useCurrentAddressCheckbox
    private JTextField addressField;
    private JSpinner limitSpinner;
    private JSpinner depthSpinner;
    private JComboBox<String> directionCombo;
    private JComboBox<String> scopeCombo;
    private JCheckBox useCurrentAddressCheckbox;
    private JButton executeButton;

    // Results table
    private JTable resultsTable;
    private DefaultTableModel resultsTableModel;
    private TableRowSorter<DefaultTableModel> tableSorter;
    private JLabel resultsCountLabel;

    // Details panel
    private JLabel detailsFunctionLabel;
    private JLabel detailsFlagsLabel;
    private JLabel detailsCallersLabel;
    private JLabel detailsCalleesLabel;
    private JTextArea detailsSummaryArea;
    private JButton goToButton;
    private JButton copyButton;

    // State
    private String selectedAddress;
    private JsonArray lastResults;

    public SearchViewPanel(TabController controller, SemanticGraphTab parentTab) {
        super(new BorderLayout(5, 5));
        this.controller = controller;
        this.parentTab = parentTab;
        initializeComponents();
        layoutComponents();
        setupListeners();
    }

    private void initializeComponents() {
        // Query type radio buttons
        queryTypeGroup = new ButtonGroup();

        semanticSearchRadio = new JRadioButton("Semantic Search");
        semanticSearchRadio.setToolTipText("Full-text search of function summaries");
        semanticSearchRadio.setActionCommand(QUERY_SEMANTIC_SEARCH);
        semanticSearchRadio.setSelected(true);

        getAnalysisRadio = new JRadioButton("Get Analysis");
        getAnalysisRadio.setToolTipText("Detailed analysis of a specific function");
        getAnalysisRadio.setActionCommand(QUERY_GET_ANALYSIS);

        similarFunctionsRadio = new JRadioButton("Similar Functions");
        similarFunctionsRadio.setToolTipText("Find functions similar to a given one");
        similarFunctionsRadio.setActionCommand(QUERY_SIMILAR_FUNCTIONS);

        callContextRadio = new JRadioButton("Call Context");
        callContextRadio.setToolTipText("Get callers/callees with summaries");
        callContextRadio.setActionCommand(QUERY_CALL_CONTEXT);

        securityAnalysisRadio = new JRadioButton("Security Analysis");
        securityAnalysisRadio.setToolTipText("Security flags, taint paths, attack surface");
        securityAnalysisRadio.setActionCommand(QUERY_SECURITY_ANALYSIS);

        moduleSummaryRadio = new JRadioButton("Module Summary");
        moduleSummaryRadio.setToolTipText("Community/subsystem summary");
        moduleSummaryRadio.setActionCommand(QUERY_MODULE_SUMMARY);

        activityAnalysisRadio = new JRadioButton("Activity Analysis");
        activityAnalysisRadio.setToolTipText("Network/file I/O activity detection");
        activityAnalysisRadio.setActionCommand(QUERY_ACTIVITY_ANALYSIS);

        queryTypeGroup.add(semanticSearchRadio);
        queryTypeGroup.add(getAnalysisRadio);
        queryTypeGroup.add(similarFunctionsRadio);
        queryTypeGroup.add(callContextRadio);
        queryTypeGroup.add(securityAnalysisRadio);
        queryTypeGroup.add(moduleSummaryRadio);
        queryTypeGroup.add(activityAnalysisRadio);

        // Parameter fields
        queryField = new JTextField(30);
        addressField = new JTextField(20);
        limitSpinner = new JSpinner(new SpinnerNumberModel(20, 1, 100, 5));
        depthSpinner = new JSpinner(new SpinnerNumberModel(1, 1, 5, 1));
        directionCombo = new JComboBox<>(new String[]{"both", "callers", "callees"});
        scopeCombo = new JComboBox<>(new String[]{"function", "binary"});
        useCurrentAddressCheckbox = new JCheckBox("Use Current Address");
        executeButton = new JButton("Execute Query");

        // Parameter card layout
        paramsCardLayout = new CardLayout();
        paramsCardPanel = new JPanel(paramsCardLayout);

        // Results table
        String[] columns = {"#", "Function", "Address", "Score", "Summary"};
        resultsTableModel = new DefaultTableModel(columns, 0) {
            private static final long serialVersionUID = 1L;
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };
        resultsTable = new JTable(resultsTableModel);
        resultsTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        resultsTable.getColumnModel().getColumn(0).setPreferredWidth(30);
        resultsTable.getColumnModel().getColumn(1).setPreferredWidth(150);
        resultsTable.getColumnModel().getColumn(2).setPreferredWidth(100);
        resultsTable.getColumnModel().getColumn(3).setPreferredWidth(60);
        resultsTable.getColumnModel().getColumn(4).setPreferredWidth(300);

        tableSorter = new TableRowSorter<>(resultsTableModel);
        resultsTable.setRowSorter(tableSorter);

        resultsCountLabel = new JLabel("RESULTS (0 matches)");

        // Details panel components
        detailsFunctionLabel = new JLabel("Function: -");
        detailsFlagsLabel = new JLabel("Security Flags: -");
        detailsCallersLabel = new JLabel("Callers: -");
        detailsCalleesLabel = new JLabel("Callees: -");
        detailsSummaryArea = new JTextArea(4, 40);
        detailsSummaryArea.setEditable(false);
        detailsSummaryArea.setLineWrap(true);
        detailsSummaryArea.setWrapStyleWord(true);

        goToButton = new JButton("Go To");
        goToButton.setEnabled(false);
        copyButton = new JButton("Copy");
        copyButton.setEnabled(false);
    }

    private void layoutComponents() {
        setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        // ===== Top: Query Type Selection =====
        JPanel queryTypePanel = new JPanel(new GridLayout(2, 4, 10, 5));
        queryTypePanel.setBorder(BorderFactory.createTitledBorder("Query Type"));
        queryTypePanel.add(semanticSearchRadio);
        queryTypePanel.add(getAnalysisRadio);
        queryTypePanel.add(similarFunctionsRadio);
        queryTypePanel.add(callContextRadio);
        queryTypePanel.add(securityAnalysisRadio);
        queryTypePanel.add(moduleSummaryRadio);
        queryTypePanel.add(activityAnalysisRadio);
        queryTypePanel.add(new JLabel("")); // Spacer

        // ===== Parameters Panel with CardLayout =====
        createParameterPanels();
        JPanel paramsWrapper = new JPanel(new BorderLayout());
        paramsWrapper.setBorder(BorderFactory.createTitledBorder("Parameters"));
        paramsWrapper.add(paramsCardPanel, BorderLayout.CENTER);

        // Execute button row
        JPanel executeRow = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        executeRow.add(useCurrentAddressCheckbox);
        executeRow.add(executeButton);
        paramsWrapper.add(executeRow, BorderLayout.SOUTH);

        // Top combined panel
        JPanel topPanel = new JPanel(new BorderLayout(5, 5));
        topPanel.add(queryTypePanel, BorderLayout.NORTH);
        topPanel.add(paramsWrapper, BorderLayout.CENTER);

        // ===== Middle: Results Table =====
        JPanel resultsPanel = new JPanel(new BorderLayout(5, 5));
        resultsPanel.setBorder(BorderFactory.createTitledBorder("Results"));
        resultsPanel.add(resultsCountLabel, BorderLayout.NORTH);
        resultsPanel.add(new JScrollPane(resultsTable), BorderLayout.CENTER);

        // ===== Bottom: Details Panel =====
        JPanel detailsPanel = new JPanel(new BorderLayout(5, 5));
        detailsPanel.setBorder(BorderFactory.createTitledBorder("Details"));

        JPanel detailsLabelsPanel = new JPanel(new GridLayout(4, 1, 2, 2));
        detailsLabelsPanel.add(detailsFunctionLabel);
        detailsLabelsPanel.add(detailsFlagsLabel);
        detailsLabelsPanel.add(detailsCallersLabel);
        detailsLabelsPanel.add(detailsCalleesLabel);

        JPanel detailsButtonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        detailsButtonPanel.add(goToButton);
        detailsButtonPanel.add(copyButton);

        detailsPanel.add(detailsLabelsPanel, BorderLayout.NORTH);
        detailsPanel.add(new JScrollPane(detailsSummaryArea), BorderLayout.CENTER);
        detailsPanel.add(detailsButtonPanel, BorderLayout.SOUTH);

        // ===== Split pane for results and details =====
        JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT,
                resultsPanel, detailsPanel);
        splitPane.setResizeWeight(0.6);

        // Main layout
        add(topPanel, BorderLayout.NORTH);
        add(splitPane, BorderLayout.CENTER);
    }

    private void createParameterPanels() {
        // Semantic Search params
        JPanel semanticSearchParams = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 5));
        semanticSearchParams.add(new JLabel("Query:"));
        semanticSearchParams.add(queryField);
        semanticSearchParams.add(new JLabel("Limit:"));
        semanticSearchParams.add(limitSpinner);
        paramsCardPanel.add(semanticSearchParams, QUERY_SEMANTIC_SEARCH);

        // Get Analysis params
        JPanel getAnalysisParams = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 5));
        getAnalysisParams.add(new JLabel("Address:"));
        JTextField analysisAddrField = new JTextField(20);
        getAnalysisParams.add(analysisAddrField);
        paramsCardPanel.add(getAnalysisParams, QUERY_GET_ANALYSIS);

        // Similar Functions params
        JPanel similarParams = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 5));
        similarParams.add(new JLabel("Address:"));
        JTextField similarAddrField = new JTextField(20);
        similarParams.add(similarAddrField);
        similarParams.add(new JLabel("Limit:"));
        JSpinner similarLimitSpinner = new JSpinner(new SpinnerNumberModel(10, 1, 50, 5));
        similarParams.add(similarLimitSpinner);
        paramsCardPanel.add(similarParams, QUERY_SIMILAR_FUNCTIONS);

        // Call Context params
        JPanel callContextParams = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 5));
        callContextParams.add(new JLabel("Address:"));
        JTextField contextAddrField = new JTextField(20);
        callContextParams.add(contextAddrField);
        callContextParams.add(new JLabel("Depth:"));
        callContextParams.add(depthSpinner);
        callContextParams.add(new JLabel("Direction:"));
        callContextParams.add(directionCombo);
        paramsCardPanel.add(callContextParams, QUERY_CALL_CONTEXT);

        // Security Analysis params
        JPanel securityParams = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 5));
        securityParams.add(new JLabel("Address (optional):"));
        JTextField securityAddrField = new JTextField(20);
        securityParams.add(securityAddrField);
        securityParams.add(new JLabel("Scope:"));
        securityParams.add(scopeCombo);
        paramsCardPanel.add(securityParams, QUERY_SECURITY_ANALYSIS);

        // Module Summary params
        JPanel moduleParams = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 5));
        moduleParams.add(new JLabel("Address:"));
        JTextField moduleAddrField = new JTextField(20);
        moduleParams.add(moduleAddrField);
        paramsCardPanel.add(moduleParams, QUERY_MODULE_SUMMARY);

        // Activity Analysis params
        JPanel activityParams = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 5));
        activityParams.add(new JLabel("Address:"));
        JTextField activityAddrField = new JTextField(20);
        activityParams.add(activityAddrField);
        paramsCardPanel.add(activityParams, QUERY_ACTIVITY_ANALYSIS);

        // Store all address fields for "Use Current Address" feature
        // We'll use a shared addressField reference
    }

    private void setupListeners() {
        // Query type selection changes parameter panel
        semanticSearchRadio.addActionListener(e -> {
            paramsCardLayout.show(paramsCardPanel, QUERY_SEMANTIC_SEARCH);
            clearResults();
        });
        getAnalysisRadio.addActionListener(e -> {
            paramsCardLayout.show(paramsCardPanel, QUERY_GET_ANALYSIS);
            clearResults();
        });
        similarFunctionsRadio.addActionListener(e -> {
            paramsCardLayout.show(paramsCardPanel, QUERY_SIMILAR_FUNCTIONS);
            clearResults();
        });
        callContextRadio.addActionListener(e -> {
            paramsCardLayout.show(paramsCardPanel, QUERY_CALL_CONTEXT);
            clearResults();
        });
        securityAnalysisRadio.addActionListener(e -> {
            paramsCardLayout.show(paramsCardPanel, QUERY_SECURITY_ANALYSIS);
            clearResults();
        });
        moduleSummaryRadio.addActionListener(e -> {
            paramsCardLayout.show(paramsCardPanel, QUERY_MODULE_SUMMARY);
            clearResults();
        });
        activityAnalysisRadio.addActionListener(e -> {
            paramsCardLayout.show(paramsCardPanel, QUERY_ACTIVITY_ANALYSIS);
            clearResults();
        });

        // Execute button
        executeButton.addActionListener(e -> executeQuery());

        // Enter key in query field
        queryField.addActionListener(e -> executeQuery());

        // Use current address checkbox
        useCurrentAddressCheckbox.addActionListener(e -> {
            if (useCurrentAddressCheckbox.isSelected()) {
                long addr = parentTab.getCurrentAddress();
                String addrHex = "0x" + Long.toHexString(addr);
                updateAllAddressFields(addrHex);
            }
        });

        // Table row selection
        resultsTable.getSelectionModel().addListSelectionListener(e -> {
            if (!e.getValueIsAdjusting()) {
                int selectedRow = resultsTable.getSelectedRow();
                if (selectedRow >= 0) {
                    int modelRow = resultsTable.convertRowIndexToModel(selectedRow);
                    showResultDetails(modelRow);
                }
            }
        });

        // Table double-click to navigate
        resultsTable.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (e.getClickCount() == 2) {
                    int selectedRow = resultsTable.getSelectedRow();
                    if (selectedRow >= 0) {
                        navigateToSelectedResult();
                    }
                }
            }
        });

        // Go To button
        goToButton.addActionListener(e -> navigateToSelectedResult());

        // Copy button
        copyButton.addActionListener(e -> copyDetailsToClipboard());
    }

    private void updateAllAddressFields(String address) {
        // Update the shared address field for all panels
        // Since we're using CardLayout, update visible fields
        for (Component comp : paramsCardPanel.getComponents()) {
            if (comp instanceof JPanel) {
                for (Component inner : ((JPanel) comp).getComponents()) {
                    if (inner instanceof JTextField && inner != queryField) {
                        ((JTextField) inner).setText(address);
                    }
                }
            }
        }
    }

    private void executeQuery() {
        String queryType = queryTypeGroup.getSelection().getActionCommand();
        executeButton.setEnabled(false);
        executeButton.setText("Executing...");

        // Build arguments based on query type
        JsonObject args = buildQueryArguments(queryType);
        if (args == null) {
            executeButton.setEnabled(true);
            executeButton.setText("Execute Query");
            return;
        }

        // Execute in background
        CompletableFuture.runAsync(() -> {
            try {
                controller.handleSemanticGraphSearchQuery(queryType, args, this::handleQueryResult);
            } catch (Exception e) {
                SwingUtilities.invokeLater(() -> {
                    showError("Query failed: " + e.getMessage());
                    executeButton.setEnabled(true);
                    executeButton.setText("Execute Query");
                });
            }
        });
    }

    private JsonObject buildQueryArguments(String queryType) {
        JsonObject args = new JsonObject();

        // Get the visible parameter panel
        Component visiblePanel = null;
        for (Component comp : paramsCardPanel.getComponents()) {
            if (comp.isVisible()) {
                visiblePanel = comp;
                break;
            }
        }

        switch (queryType) {
            case QUERY_SEMANTIC_SEARCH:
                String query = queryField.getText().trim();
                if (query.isEmpty()) {
                    showError("Please enter a search query");
                    return null;
                }
                args.addProperty("query", query);
                args.addProperty("limit", (Integer) limitSpinner.getValue());
                break;

            case QUERY_GET_ANALYSIS:
            case QUERY_MODULE_SUMMARY:
            case QUERY_ACTIVITY_ANALYSIS:
                String addr = getAddressFromPanel(visiblePanel);
                if (addr == null || addr.isEmpty()) {
                    addr = getCurrentAddressHex();
                }
                if (addr == null || addr.isEmpty()) {
                    showError("Please enter an address or use current address");
                    return null;
                }
                args.addProperty("address", addr);
                break;

            case QUERY_SIMILAR_FUNCTIONS:
                String simAddr = getAddressFromPanel(visiblePanel);
                if (simAddr == null || simAddr.isEmpty()) {
                    simAddr = getCurrentAddressHex();
                }
                if (simAddr == null || simAddr.isEmpty()) {
                    showError("Please enter an address");
                    return null;
                }
                args.addProperty("address", simAddr);
                args.addProperty("limit", getLimitFromPanel(visiblePanel, 10));
                break;

            case QUERY_CALL_CONTEXT:
                String ctxAddr = getAddressFromPanel(visiblePanel);
                if (ctxAddr == null || ctxAddr.isEmpty()) {
                    ctxAddr = getCurrentAddressHex();
                }
                if (ctxAddr == null || ctxAddr.isEmpty()) {
                    showError("Please enter an address");
                    return null;
                }
                args.addProperty("address", ctxAddr);
                args.addProperty("depth", (Integer) depthSpinner.getValue());
                args.addProperty("direction", (String) directionCombo.getSelectedItem());
                break;

            case QUERY_SECURITY_ANALYSIS:
                String secAddr = getAddressFromPanel(visiblePanel);
                if (secAddr != null && !secAddr.isEmpty()) {
                    args.addProperty("address", secAddr);
                }
                args.addProperty("scope", (String) scopeCombo.getSelectedItem());
                break;
        }

        return args;
    }

    private String getAddressFromPanel(Component panel) {
        if (panel instanceof JPanel) {
            for (Component comp : ((JPanel) panel).getComponents()) {
                if (comp instanceof JTextField && comp != queryField) {
                    return ((JTextField) comp).getText().trim();
                }
            }
        }
        return null;
    }

    private int getLimitFromPanel(Component panel, int defaultValue) {
        if (panel instanceof JPanel) {
            for (Component comp : ((JPanel) panel).getComponents()) {
                if (comp instanceof JSpinner) {
                    Object val = ((JSpinner) comp).getValue();
                    if (val instanceof Integer) {
                        return (Integer) val;
                    }
                }
            }
        }
        return defaultValue;
    }

    private String getCurrentAddressHex() {
        long addr = parentTab.getCurrentAddress();
        if (addr != 0) {
            return "0x" + Long.toHexString(addr);
        }
        return null;
    }

    /**
     * Handle query result callback.
     */
    public void handleQueryResult(String jsonResult) {
        SwingUtilities.invokeLater(() -> {
            executeButton.setEnabled(true);
            executeButton.setText("Execute Query");

            if (jsonResult == null || jsonResult.isEmpty()) {
                showError("Empty result");
                return;
            }

            try {
                // Check for error in JSON response
                JsonElement parsed = JsonParser.parseString(jsonResult);
                if (parsed.isJsonObject()) {
                    JsonObject obj = parsed.getAsJsonObject();
                    if (obj.has("error")) {
                        showError(obj.get("error").getAsString());
                        return;
                    }
                }

                parseAndDisplayResults(jsonResult);
            } catch (Exception e) {
                showError("Failed to parse results: " + e.getMessage());
            }
        });
    }

    private void parseAndDisplayResults(String jsonResult) {
        // Clear previous results
        resultsTableModel.setRowCount(0);
        lastResults = null;

        if (jsonResult == null || jsonResult.isEmpty()) {
            resultsCountLabel.setText("RESULTS (0 matches)");
            return;
        }

        JsonElement parsed = JsonParser.parseString(jsonResult);

        if (parsed.isJsonObject()) {
            JsonObject obj = parsed.getAsJsonObject();

            // Check for results array
            if (obj.has("results") && obj.get("results").isJsonArray()) {
                lastResults = obj.getAsJsonArray("results");
                populateResultsTable(lastResults);
            } else if (obj.has("matches") && obj.get("matches").isJsonArray()) {
                lastResults = obj.getAsJsonArray("matches");
                populateResultsTable(lastResults);
            } else {
                // Single result - wrap in array for table
                lastResults = new JsonArray();
                lastResults.add(obj);
                populateResultsTable(lastResults);
            }
        } else if (parsed.isJsonArray()) {
            lastResults = parsed.getAsJsonArray();
            populateResultsTable(lastResults);
        }
    }

    private void populateResultsTable(JsonArray results) {
        resultsTableModel.setRowCount(0);
        int count = 0;

        for (JsonElement elem : results) {
            if (elem.isJsonObject()) {
                JsonObject obj = elem.getAsJsonObject();
                count++;

                // CallContext results have info nested in "center"
                JsonObject displayObj = obj;
                if (obj.has("center") && obj.get("center").isJsonObject()) {
                    displayObj = obj.getAsJsonObject("center");
                }

                String funcName = getJsonString(displayObj, "function_name",
                        getJsonString(displayObj, "name", "Unknown"));
                String address = getJsonString(displayObj, "address", "-");
                String score = displayObj.has("score") ?
                        String.format("%.2f", displayObj.get("score").getAsDouble()) : "-";
                String summary = getJsonString(displayObj, "summary",
                        getJsonString(displayObj, "description", ""));
                if (summary.length() > 80) {
                    summary = summary.substring(0, 77) + "...";
                }

                resultsTableModel.addRow(new Object[]{count, funcName, address, score, summary});
            }
        }

        resultsCountLabel.setText("RESULTS (" + count + " matches)");

        // Select first row if available
        if (count > 0) {
            resultsTable.setRowSelectionInterval(0, 0);
        }
    }

    private void showResultDetails(int modelRow) {
        if (lastResults == null || modelRow >= lastResults.size()) {
            clearDetails();
            return;
        }

        JsonObject result = lastResults.get(modelRow).getAsJsonObject();

        // CallContext results have info nested in "center"
        JsonObject infoObj = result;
        if (result.has("center") && result.get("center").isJsonObject()) {
            infoObj = result.getAsJsonObject("center");
        }

        String funcName = getJsonString(infoObj, "function_name",
                getJsonString(infoObj, "name", "Unknown"));
        String address = getJsonString(infoObj, "address", "-");
        selectedAddress = address;

        detailsFunctionLabel.setText("Function: " + funcName + " @ " + address);

        // Security flags
        if (infoObj.has("security_flags") && infoObj.get("security_flags").isJsonArray()) {
            JsonArray flags = infoObj.getAsJsonArray("security_flags");
            StringBuilder sb = new StringBuilder();
            for (JsonElement f : flags) {
                if (sb.length() > 0) sb.append(", ");
                sb.append(f.getAsString());
            }
            detailsFlagsLabel.setText("Security Flags: " + (sb.length() > 0 ? sb.toString() : "None"));
        } else {
            detailsFlagsLabel.setText("Security Flags: -");
        }

        // Callers
        if (result.has("callers")) {
            detailsCallersLabel.setText("Callers: " + formatFunctionList(result.get("callers")));
        } else {
            detailsCallersLabel.setText("Callers: -");
        }

        // Callees
        if (result.has("callees")) {
            detailsCalleesLabel.setText("Callees: " + formatFunctionList(result.get("callees")));
        } else {
            detailsCalleesLabel.setText("Callees: -");
        }

        // Summary
        String summary = getJsonString(infoObj, "summary",
                getJsonString(infoObj, "description", ""));
        detailsSummaryArea.setText(summary);
        detailsSummaryArea.setCaretPosition(0);

        goToButton.setEnabled(true);
        copyButton.setEnabled(true);
    }

    private String formatFunctionList(JsonElement element) {
        if (element.isJsonArray()) {
            JsonArray arr = element.getAsJsonArray();
            StringBuilder sb = new StringBuilder();
            int count = 0;
            for (JsonElement e : arr) {
                if (count > 0) sb.append(", ");
                if (count >= 5) {
                    sb.append("... (").append(arr.size() - 5).append(" more)");
                    break;
                }
                if (e.isJsonObject()) {
                    JsonObject entry = e.getAsJsonObject();
                    // CallContext entries nest name inside "function" object
                    if (entry.has("function") && entry.get("function").isJsonObject()) {
                        JsonObject func = entry.getAsJsonObject("function");
                        sb.append(getJsonString(func, "name",
                                getJsonString(func, "function_name", "?")));
                    } else {
                        sb.append(getJsonString(entry, "name",
                                getJsonString(entry, "function_name", "?")));
                    }
                } else {
                    sb.append(e.getAsString());
                }
                count++;
            }
            return sb.toString();
        } else if (element.isJsonPrimitive()) {
            return element.getAsString();
        }
        return "-";
    }

    private void clearDetails() {
        selectedAddress = null;
        detailsFunctionLabel.setText("Function: -");
        detailsFlagsLabel.setText("Security Flags: -");
        detailsCallersLabel.setText("Callers: -");
        detailsCalleesLabel.setText("Callees: -");
        detailsSummaryArea.setText("");
        goToButton.setEnabled(false);
        copyButton.setEnabled(false);
    }

    private void clearResults() {
        resultsTableModel.setRowCount(0);
        resultsCountLabel.setText("RESULTS (0 matches)");
        lastResults = null;
        clearDetails();
    }

    private void navigateToSelectedResult() {
        if (selectedAddress != null && !selectedAddress.isEmpty() && !selectedAddress.equals("-")) {
            try {
                long addr;
                if (selectedAddress.startsWith("0x") || selectedAddress.startsWith("0X")) {
                    addr = Long.parseLong(selectedAddress.substring(2), 16);
                } else {
                    addr = Long.parseLong(selectedAddress, 16);
                }
                parentTab.navigateToFunction(addr);
            } catch (NumberFormatException e) {
                showError("Invalid address format: " + selectedAddress);
            }
        }
    }

    private void copyDetailsToClipboard() {
        StringBuilder sb = new StringBuilder();
        sb.append(detailsFunctionLabel.getText()).append("\n");
        sb.append(detailsFlagsLabel.getText()).append("\n");
        sb.append(detailsCallersLabel.getText()).append("\n");
        sb.append(detailsCalleesLabel.getText()).append("\n\n");
        sb.append("Summary:\n").append(detailsSummaryArea.getText());

        StringSelection selection = new StringSelection(sb.toString());
        Toolkit.getDefaultToolkit().getSystemClipboard().setContents(selection, null);
    }

    private String getJsonString(JsonObject obj, String key, String defaultValue) {
        if (obj.has(key) && !obj.get(key).isJsonNull()) {
            return obj.get(key).getAsString();
        }
        return defaultValue;
    }

    private void showError(String message) {
        JOptionPane.showMessageDialog(this, message, "Error", JOptionPane.ERROR_MESSAGE);
    }

    /**
     * Refresh the panel when the tab becomes visible.
     */
    public void refresh() {
        // Update address field if "use current" is checked
        if (useCurrentAddressCheckbox.isSelected()) {
            long addr = parentTab.getCurrentAddress();
            String addrHex = "0x" + Long.toHexString(addr);
            updateAllAddressFields(addrHex);
        }
    }
}

```

`src/main/java/ghidrassist/workers/AnalysisWorker.java`:

```java
package ghidrassist.workers;

import javax.swing.SwingWorker;
import java.util.function.Consumer;

/**
 * Base class for background analysis workers.
 * Uses SwingWorker to run tasks in the background without blocking the UI.
 *
 * @param <R> Result type returned by doInBackground
 */
public abstract class AnalysisWorker<R> extends SwingWorker<R, ProgressUpdate> {

    protected volatile boolean cancelled = false;

    // Callbacks
    private Consumer<ProgressUpdate> progressCallback;
    private Consumer<R> completedCallback;
    private Runnable cancelledCallback;
    private Consumer<String> failedCallback;

    /**
     * Set progress callback - called on EDT with progress updates.
     */
    public void setProgressCallback(Consumer<ProgressUpdate> callback) {
        this.progressCallback = callback;
    }

    /**
     * Set completed callback - called on EDT when work completes successfully.
     */
    public void setCompletedCallback(Consumer<R> callback) {
        this.completedCallback = callback;
    }

    /**
     * Set cancelled callback - called on EDT when work is cancelled.
     */
    public void setCancelledCallback(Runnable callback) {
        this.cancelledCallback = callback;
    }

    /**
     * Set failed callback - called on EDT when work fails with an error.
     */
    public void setFailedCallback(Consumer<String> callback) {
        this.failedCallback = callback;
    }

    /**
     * Cancel the worker. Subclasses should check isCancelRequested() periodically.
     */
    public void requestCancel() {
        this.cancelled = true;
        cancel(false); // Don't interrupt - let worker check flag
    }

    /**
     * Check if cancellation has been requested.
     */
    public boolean isCancelRequested() {
        return cancelled || isCancelled();
    }

    /**
     * Publish a progress update to the EDT.
     */
    protected void publishProgress(int current, int total, String message) {
        publish(new ProgressUpdate(current, total, message));
    }

    @Override
    protected void process(java.util.List<ProgressUpdate> chunks) {
        // Get the latest progress update
        if (progressCallback != null && !chunks.isEmpty()) {
            progressCallback.accept(chunks.get(chunks.size() - 1));
        }
    }

    @Override
    protected void done() {
        if (cancelled || isCancelled()) {
            if (cancelledCallback != null) {
                cancelledCallback.run();
            }
            return;
        }

        try {
            R result = get();
            if (completedCallback != null) {
                completedCallback.accept(result);
            }
        } catch (Exception e) {
            String message = e.getCause() != null ? e.getCause().getMessage() : e.getMessage();
            if (failedCallback != null) {
                failedCallback.accept(message);
            }
        }
    }
}

```

`src/main/java/ghidrassist/workers/CommunityDetectionWorker.java`:

```java
package ghidrassist.workers;

import ghidra.program.model.listing.Program;
import ghidrassist.AnalysisDB;
import ghidrassist.graphrag.BinaryKnowledgeGraph;
import ghidrassist.graphrag.community.CommunityDetector;

/**
 * Background worker for community detection using Label Propagation.
 */
public class CommunityDetectionWorker extends AnalysisWorker<CommunityDetectionWorker.Result> {

    private final AnalysisDB analysisDB;
    private final Program program;

    public static class Result {
        public final int communityCount;

        public Result(int communityCount) {
            this.communityCount = communityCount;
        }
    }

    public CommunityDetectionWorker(AnalysisDB analysisDB, Program program) {
        this.analysisDB = analysisDB;
        this.program = program;
    }

    @Override
    protected Result doInBackground() throws Exception {
        String programHash = program.getExecutableSHA256();
        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);

        if (graph == null) {
            throw new Exception("Binary is not indexed. Please run ReIndex first.");
        }

        publishProgress(0, 100, "Detecting communities...");

        // Create task monitor that respects cancellation
        SwingWorkerTaskMonitor monitor = new SwingWorkerTaskMonitor(
            (current, total, msg) -> publishProgress(current, total, msg),
            this::isCancelRequested
        );

        // Create community detector
        CommunityDetector detector = new CommunityDetector(graph, monitor);

        if (isCancelRequested()) {
            return new Result(0);
        }

        publishProgress(10, 100, "Running Label Propagation algorithm...");

        // Run community detection
        int communityCount = detector.detectCommunities();

        if (isCancelRequested()) {
            return new Result(communityCount);
        }

        publishProgress(90, 100, "Finalizing...");

        // Invalidate cache
        analysisDB.invalidateKnowledgeGraphCache(programHash);

        publishProgress(100, 100, "Complete");
        return new Result(communityCount);
    }
}

```

`src/main/java/ghidrassist/workers/NetworkFlowAnalysisWorker.java`:

```java
package ghidrassist.workers;

import ghidra.program.model.listing.Program;
import ghidrassist.AnalysisDB;
import ghidrassist.graphrag.BinaryKnowledgeGraph;
import ghidrassist.graphrag.analysis.TaintAnalyzer;

/**
 * Background worker for network flow analysis.
 * Creates NETWORK_SEND and NETWORK_RECV edges to trace
 * network data flow through the call graph.
 */
public class NetworkFlowAnalysisWorker extends AnalysisWorker<NetworkFlowAnalysisWorker.Result> {

    private final AnalysisDB analysisDB;
    private final Program program;
    private volatile TaintAnalyzer taintAnalyzer;

    public static class Result {
        public final int sendPathEdges;
        public final int recvPathEdges;
        public final int sendFunctionsFound;
        public final int recvFunctionsFound;

        public Result(int sendPathEdges, int recvPathEdges, int sendFunctionsFound, int recvFunctionsFound) {
            this.sendPathEdges = sendPathEdges;
            this.recvPathEdges = recvPathEdges;
            this.sendFunctionsFound = sendFunctionsFound;
            this.recvFunctionsFound = recvFunctionsFound;
        }
    }

    public NetworkFlowAnalysisWorker(AnalysisDB analysisDB, Program program) {
        this.analysisDB = analysisDB;
        this.program = program;
    }

    @Override
    public void requestCancel() {
        super.requestCancel();
        // Propagate cancellation to the TaintAnalyzer
        TaintAnalyzer analyzer = taintAnalyzer;
        if (analyzer != null) {
            analyzer.requestCancel();
        }
    }

    @Override
    protected Result doInBackground() throws Exception {
        String programHash = program.getExecutableSHA256();
        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);

        if (graph == null) {
            throw new Exception("Binary is not indexed. Please run ReIndex first.");
        }

        publishProgress(0, 100, "Initializing network flow analysis...");

        // Create taint analyzer (reuses the same class for graph traversal)
        taintAnalyzer = new TaintAnalyzer(graph);

        // Set up progress callback to forward to worker progress
        taintAnalyzer.setProgressCallback((current, total, message) -> {
            // The message from TaintAnalyzer already contains percentage info
            // Parse the percentage from the message or use 0-100 scale
            // The TaintAnalyzer reports overall percentage in its messages
            publishProgress(current, total, message);
        });

        if (isCancelRequested()) {
            return new Result(0, 0, 0, 0);
        }

        // Run network flow analysis (progress is reported via callback)
        TaintAnalyzer.NetworkFlowResult flowResult = taintAnalyzer.analyzeNetworkFlow();

        if (isCancelRequested()) {
            return new Result(0, 0, 0, 0);
        }

        publishProgress(98, 100, "Finalizing...");

        // Reload memory graph to include newly created NETWORK_SEND/NETWORK_RECV edges
        graph.reloadFromDatabase();

        // Invalidate cache to ensure fresh instance on next access
        analysisDB.invalidateKnowledgeGraphCache(programHash);

        publishProgress(100, 100, "Complete");
        return new Result(
            flowResult.getSendPathEdges(),
            flowResult.getRecvPathEdges(),
            flowResult.getSendFunctions().size(),
            flowResult.getRecvFunctions().size()
        );
    }
}

```

`src/main/java/ghidrassist/workers/ProgressUpdate.java`:

```java
package ghidrassist.workers;

/**
 * Progress update data for background workers.
 */
public class ProgressUpdate {
    public final int current;
    public final int total;
    public final String message;

    public ProgressUpdate(int current, int total, String message) {
        this.current = current;
        this.total = total;
        this.message = message;
    }

    /**
     * Get progress as a percentage (0-100).
     */
    public int getPercentage() {
        if (total <= 0) return 0;
        return (int) ((current * 100L) / total);
    }
}

```

`src/main/java/ghidrassist/workers/RefreshNamesWorker.java`:

```java
package ghidrassist.workers;

import ghidra.program.model.listing.Program;
import ghidrassist.AnalysisDB;
import ghidrassist.graphrag.query.SemanticQueryTools;
import com.google.gson.JsonObject;

/**
 * Background worker for refreshing function names in the knowledge graph.
 */
public class RefreshNamesWorker extends AnalysisWorker<Boolean> {

    private final AnalysisDB analysisDB;
    private final Program program;

    public RefreshNamesWorker(AnalysisDB analysisDB, Program program) {
        this.analysisDB = analysisDB;
        this.program = program;
    }

    @Override
    protected Boolean doInBackground() throws Exception {
        publishProgress(0, 100, "Refreshing function names...");

        // Use the ga_refresh_names tool via SemanticQueryTools
        SemanticQueryTools tools = new SemanticQueryTools(analysisDB);
        tools.setCurrentProgram(program);

        JsonObject args = new JsonObject();
        tools.executeTool("ga_refresh_names", args).join();

        publishProgress(100, 100, "Complete");
        return true;
    }
}

```

`src/main/java/ghidrassist/workers/ReindexWorker.java`:

```java
package ghidrassist.workers;

import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import ghidrassist.AnalysisDB;
import ghidrassist.graphrag.BinaryKnowledgeGraph;
import ghidrassist.graphrag.GraphRAGService;
import ghidrassist.graphrag.extraction.StructureExtractor;

/**
 * Background worker for reindexing a binary's knowledge graph.
 *
 * This worker performs a NON-DESTRUCTIVE reindex that:
 * - Preserves existing LLM summaries, security flags, and embeddings
 * - Updates structural data (function names, addresses, call edges)
 * - Marks changed nodes as stale for re-summarization
 *
 * The upsertNode() method uses COALESCE to preserve semantic data fields
 * when they are null in the new node but exist in the database.
 */
public class ReindexWorker extends AnalysisWorker<ReindexWorker.Result> {

    private final AnalysisDB analysisDB;
    private final Program program;

    public static class Result {
        public final int functionsExtracted;
        public final int callEdgesCreated;
        public final int nodesMarkedStale;

        public Result(int functionsExtracted, int callEdgesCreated) {
            this(functionsExtracted, callEdgesCreated, 0);
        }

        public Result(int functionsExtracted, int callEdgesCreated, int nodesMarkedStale) {
            this.functionsExtracted = functionsExtracted;
            this.callEdgesCreated = callEdgesCreated;
            this.nodesMarkedStale = nodesMarkedStale;
        }
    }

    public ReindexWorker(AnalysisDB analysisDB, Program program) {
        this.analysisDB = analysisDB;
        this.program = program;
    }

    @Override
    protected Result doInBackground() throws Exception {
        GraphRAGService service = GraphRAGService.getInstance(analysisDB);
        service.setCurrentProgram(program);

        // NON-DESTRUCTIVE: Mark existing nodes as stale instead of deleting
        publishProgress(0, 100, "Marking nodes for update...");
        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(program.getExecutableSHA256());
        int markedStale = graph.markAllStale();
        Msg.info(this, "Marked " + markedStale + " nodes as stale for non-destructive reindex");

        if (isCancelRequested()) {
            return new Result(0, 0, markedStale);
        }

        // Create a TaskMonitor that bridges to our SwingWorker
        SwingWorkerTaskMonitor monitor = new SwingWorkerTaskMonitor(
                (current, total, message) -> {
                    // Scale progress to 10-95 range (0-10 is marking, 95-100 is finalizing)
                    int scaledProgress = total > 0 ? 10 + (int) ((current * 85L) / total) : 10;
                    publishProgress(scaledProgress, 100, message);
                },
                this::isCancelRequested
        );

        // Index structure with incremental mode enabled
        // Incremental mode preserves semantic data via COALESCE in upsertNode
        publishProgress(10, 100, "Updating binary structure...");
        StructureExtractor.ExtractionResult result = service.indexStructureSync(program, monitor, false, true);

        if (isCancelRequested()) {
            return new Result(result.functionsExtracted, result.callEdgesCreated, markedStale);
        }

        // Rebuild FTS index to reflect newly-indexed nodes
        publishProgress(95, 100, "Rebuilding search index...");
        analysisDB.rebuildFts();

        // Invalidate cache to ensure fresh data is loaded
        publishProgress(98, 100, "Finalizing...");
        analysisDB.invalidateKnowledgeGraphCache(program.getExecutableSHA256());

        publishProgress(100, 100, "Complete");
        Msg.info(this, String.format("ReIndex complete: %d functions, %d edges (non-destructive, %d nodes marked stale)",
                result.functionsExtracted, result.callEdgesCreated, markedStale));
        return new Result(result.functionsExtracted, result.callEdgesCreated, markedStale);
    }
}

```

`src/main/java/ghidrassist/workers/SecurityAnalysisWorker.java`:

```java
package ghidrassist.workers;

import ghidra.program.model.listing.Program;
import ghidrassist.AnalysisDB;
import ghidrassist.graphrag.BinaryKnowledgeGraph;
import ghidrassist.graphrag.analysis.TaintAnalyzer;

import java.util.List;

/**
 * Background worker for security/taint analysis.
 */
public class SecurityAnalysisWorker extends AnalysisWorker<SecurityAnalysisWorker.Result> {

    private final AnalysisDB analysisDB;
    private final Program program;
    private volatile TaintAnalyzer taintAnalyzer;

    public static class Result {
        public final int pathCount;
        public final int vulnerableViaEdges;

        public Result(int pathCount, int vulnerableViaEdges) {
            this.pathCount = pathCount;
            this.vulnerableViaEdges = vulnerableViaEdges;
        }
    }

    public SecurityAnalysisWorker(AnalysisDB analysisDB, Program program) {
        this.analysisDB = analysisDB;
        this.program = program;
    }

    @Override
    public void requestCancel() {
        super.requestCancel();
        // TaintAnalyzer will check isCancelRequested during analysis
    }

    @Override
    protected Result doInBackground() throws Exception {
        String programHash = program.getExecutableSHA256();
        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);

        if (graph == null) {
            throw new Exception("Binary is not indexed. Please run ReIndex first.");
        }

        publishProgress(0, 100, "Running taint analysis...");

        // Create taint analyzer
        taintAnalyzer = new TaintAnalyzer(graph);

        if (isCancelRequested()) {
            return new Result(0, 0);
        }

        // Find taint paths and create TAINT_FLOWS_TO edges
        List<TaintAnalyzer.TaintPath> taintPaths = taintAnalyzer.findTaintPaths(100, true);

        if (isCancelRequested()) {
            return new Result(taintPaths.size(), 0);
        }

        publishProgress(70, 100, "Creating VULNERABLE_VIA edges...");

        // Create VULNERABLE_VIA edges from entry points to vulnerable sinks
        int vulnerableViaEdges = taintAnalyzer.createVulnerableViaEdges();

        if (isCancelRequested()) {
            return new Result(taintPaths.size(), vulnerableViaEdges);
        }

        publishProgress(90, 100, "Finalizing...");

        // Invalidate cache
        analysisDB.invalidateKnowledgeGraphCache(programHash);

        publishProgress(100, 100, "Complete");
        return new Result(taintPaths.size(), vulnerableViaEdges);
    }
}

```

`src/main/java/ghidrassist/workers/SemanticAnalysisWorker.java`:

```java
package ghidrassist.workers;

import ghidra.program.model.listing.Program;
import ghidrassist.AnalysisDB;
import ghidrassist.graphrag.GraphRAGService;
import ghidrassist.graphrag.extraction.SemanticExtractor;

/**
 * Background worker for LLM semantic analysis (summarization of stale nodes).
 */
public class SemanticAnalysisWorker extends AnalysisWorker<SemanticAnalysisWorker.Result> {

    private final AnalysisDB analysisDB;
    private final Program program;

    public static class Result {
        public final int summarized;
        public final int errors;
        public final long elapsedMs;

        public Result(int summarized, int errors, long elapsedMs) {
            this.summarized = summarized;
            this.errors = errors;
            this.elapsedMs = elapsedMs;
        }
    }

    public SemanticAnalysisWorker(AnalysisDB analysisDB, Program program) {
        this.analysisDB = analysisDB;
        this.program = program;
    }

    @Override
    public void requestCancel() {
        super.requestCancel();
        // Cancel the extractor via the service
        try {
            GraphRAGService service = GraphRAGService.getInstance(analysisDB);
            service.cancelSemanticExtraction();
        } catch (Exception e) {
            // Ignore - service may not be initialized
        }
    }

    @Override
    protected Result doInBackground() throws Exception {
        GraphRAGService service = GraphRAGService.getInstance(analysisDB);
        service.setCurrentProgram(program);

        // Check if LLM provider is configured
        if (!service.hasLlmProvider()) {
            throw new Exception("No LLM provider configured. Please configure an API provider in Analysis Options.");
        }

        publishProgress(0, 100, "Running semantic analysis...");

        // Run semantic extraction with progress callback
        SemanticExtractor.ExtractionResult result = service.summarizeStaleNodes(
                program,
                0, // no limit
                (processed, total, summarized, errors) -> {
                    int pct = total > 0 ? (int) ((processed * 100L) / total) : 0;
                    publishProgress(pct, 100, String.format("Summarizing... %d/%d (%d errors)", processed, total, errors));

                    // Check for cancellation
                    if (isCancelRequested()) {
                        throw new RuntimeException("Cancelled");
                    }
                }
        );

        // Rebuild FTS index to reflect newly-populated summaries
        publishProgress(99, 100, "Rebuilding search index...");
        analysisDB.rebuildFts();

        if (isCancelRequested()) {
            return new Result(result.summarized, result.errors, result.elapsedMs);
        }

        // Invalidate cache
        analysisDB.invalidateKnowledgeGraphCache(program.getExecutableSHA256());

        return new Result(result.summarized, result.errors, result.elapsedMs);
    }
}

```

`src/main/java/ghidrassist/workers/SwingWorkerTaskMonitor.java`:

```java
package ghidrassist.workers;

import ghidra.util.task.TaskMonitor;
import java.util.function.Supplier;

/**
 * A TaskMonitor implementation that bridges to SwingWorker.
 * Delegates progress updates to a callback and checks a cancellation supplier.
 */
public class SwingWorkerTaskMonitor implements TaskMonitor {

    private final ProgressCallback progressCallback;
    private final Supplier<Boolean> cancelledSupplier;

    private String message = "";
    private long progress = 0;
    private long maximum = 100;
    private boolean indeterminate = false;

    /**
     * Callback for progress updates.
     */
    public interface ProgressCallback {
        void onProgress(int current, int total, String message);
    }

    /**
     * Create a TaskMonitor that bridges to SwingWorker.
     *
     * @param progressCallback  Called when progress changes
     * @param cancelledSupplier Returns true if cancellation requested
     */
    public SwingWorkerTaskMonitor(ProgressCallback progressCallback, Supplier<Boolean> cancelledSupplier) {
        this.progressCallback = progressCallback;
        this.cancelledSupplier = cancelledSupplier;
    }

    @Override
    public boolean isCancelled() {
        return cancelledSupplier != null && cancelledSupplier.get();
    }

    @Override
    public void setShowProgressValue(boolean showProgressValue) {
        // Not used in SwingWorker context
    }

    @Override
    public void setMessage(String message) {
        this.message = message;
        fireProgress();
    }

    @Override
    public String getMessage() {
        return message;
    }

    @Override
    public void setProgress(long value) {
        this.progress = value;
        fireProgress();
    }

    @Override
    public void initialize(long max) {
        this.maximum = max;
        this.progress = 0;
        fireProgress();
    }

    @Override
    public void setMaximum(long max) {
        this.maximum = max;
        fireProgress();
    }

    @Override
    public long getMaximum() {
        return maximum;
    }

    @Override
    public void setIndeterminate(boolean indeterminate) {
        this.indeterminate = indeterminate;
        fireProgress();
    }

    @Override
    public boolean isIndeterminate() {
        return indeterminate;
    }

    @Override
    public void checkCancelled() throws ghidra.util.exception.CancelledException {
        if (isCancelled()) {
            throw new ghidra.util.exception.CancelledException();
        }
    }

    @SuppressWarnings("deprecation")
    @Override
    public void checkCanceled() throws ghidra.util.exception.CancelledException {
        checkCancelled();
    }

    @Override
    public void incrementProgress(long incrementAmount) {
        this.progress += incrementAmount;
        fireProgress();
    }

    @Override
    public long getProgress() {
        return progress;
    }

    @Override
    public void cancel() {
        // Can't cancel from here - cancellation is controlled by SwingWorker
    }

    @Override
    public void addCancelledListener(ghidra.util.task.CancelledListener listener) {
        // Not implemented for SwingWorker context
    }

    @Override
    public void removeCancelledListener(ghidra.util.task.CancelledListener listener) {
        // Not implemented for SwingWorker context
    }

    @Override
    public void setCancelEnabled(boolean enable) {
        // Not used in SwingWorker context
    }

    @Override
    public boolean isCancelEnabled() {
        return true;
    }

    @Override
    public void clearCancelled() {
        // Not used in SwingWorker context
    }

    @SuppressWarnings("deprecation")
    @Override
    public void clearCanceled() {
        clearCancelled();
    }

    private void fireProgress() {
        if (progressCallback != null) {
            int current = (int) Math.min(progress, Integer.MAX_VALUE);
            int total = (int) Math.min(maximum, Integer.MAX_VALUE);
            progressCallback.onProgress(current, total, message);
        }
    }
}

```

`src/main/java/ghidrassist/workers/SymGraphApplyWorker.java`:

```java
package ghidrassist.workers;

import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeConflictHandler;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.EnumDataType;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.listing.CodeUnit;
import ghidra.program.model.listing.CommentType;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Listing;
import ghidra.program.model.listing.Parameter;
import ghidra.program.model.listing.Program;
import ghidra.program.model.listing.Variable;
import ghidra.program.model.lang.Register;
import ghidra.program.model.symbol.SourceType;
import ghidra.util.Msg;
import ghidrassist.AnalysisDB;
import ghidrassist.graphrag.BinaryKnowledgeGraph;
import ghidrassist.graphrag.nodes.EdgeType;
import ghidrassist.graphrag.nodes.KnowledgeNode;
import ghidrassist.graphrag.nodes.NodeType;
import ghidrassist.services.symgraph.SymGraphModels.*;

import com.google.gson.Gson;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Background worker for applying SymGraph symbols and graph data.
 * Uses SwingWorker to run in the background without blocking the UI.
 */
public class SymGraphApplyWorker extends AnalysisWorker<SymGraphApplyWorker.Result> {

    /**
     * Result of the apply operation.
     */
    public static class Result {
        public final int symbolsApplied;
        public final int nodesApplied;
        public final int edgesApplied;
        public final long elapsedMs;
        public final boolean cancelled;
        public final String error;

        public Result(int symbolsApplied, int nodesApplied, int edgesApplied, long elapsedMs, boolean cancelled) {
            this.symbolsApplied = symbolsApplied;
            this.nodesApplied = nodesApplied;
            this.edgesApplied = edgesApplied;
            this.elapsedMs = elapsedMs;
            this.cancelled = cancelled;
            this.error = null;
        }

        public Result(String error) {
            this.symbolsApplied = 0;
            this.nodesApplied = 0;
            this.edgesApplied = 0;
            this.elapsedMs = 0;
            this.cancelled = false;
            this.error = error;
        }
    }

    private final Program program;
    private final AnalysisDB analysisDB;
    private final List<ConflictEntry> conflicts;
    private final GraphExport graphExport;
    private final String programHash;
    private final String mergePolicy;

    private static final String MERGE_POLICY_UPSERT = "upsert";
    private static final String MERGE_POLICY_PREFER_LOCAL = "prefer_local";
    private static final String MERGE_POLICY_REPLACE = "replace";

    /**
     * Create a new SymGraphApplyWorker.
     *
     * @param program      The Ghidra program to modify
     * @param analysisDB   The analysis database for graph operations
     * @param conflicts    List of symbols to apply
     * @param graphExport  Optional graph data to merge
     * @param programHash  SHA256 hash of the program
     * @param mergePolicy  Graph merge policy (upsert, prefer_local, replace)
     */
    public SymGraphApplyWorker(Program program, AnalysisDB analysisDB,
                                List<ConflictEntry> conflicts, GraphExport graphExport,
                                String programHash, String mergePolicy) {
        this.program = program;
        this.analysisDB = analysisDB;
        this.conflicts = conflicts != null ? conflicts : new ArrayList<>();
        this.graphExport = graphExport;
        this.programHash = programHash;
        this.mergePolicy = mergePolicy != null ? mergePolicy : MERGE_POLICY_UPSERT;
    }

    @Override
    protected Result doInBackground() throws Exception {
        long startTime = System.currentTimeMillis();
        int symbolsApplied = 0;
        int nodesApplied = 0;
        int edgesApplied = 0;

        int transactionId = program.startTransaction("Apply SymGraph Symbols");
        try {
            // Phase 1: Merge graph data (0-30%)
            if (graphExport != null && analysisDB != null) {
                publishProgress(0, 100, "Merging graph data...");

                int[] graphResults = mergeGraphData();
                nodesApplied = graphResults[0];
                edgesApplied = graphResults[1];

                if (isCancelRequested()) {
                    program.endTransaction(transactionId, false);
                    long elapsed = System.currentTimeMillis() - startTime;
                    return new Result(0, nodesApplied, edgesApplied, elapsed, true);
                }
            }

            // Phase 2: Apply symbols (30-95%)
            int total = conflicts.size();
            for (int i = 0; i < total; i++) {
                if (isCancelRequested()) {
                    break;
                }

                int progress = total > 0 ? 30 + (int)((i * 65L) / total) : 30;
                publishProgress(progress, 100,
                    String.format("Applying symbol %d/%d...", i + 1, total));

                ConflictEntry conflict = conflicts.get(i);
                if (applySymbol(conflict)) {
                    symbolsApplied++;
                }
            }

            // Phase 3: Finalize (95-100%)
            publishProgress(95, 100, "Finalizing...");

            if (isCancelRequested()) {
                program.endTransaction(transactionId, false);
                long elapsed = System.currentTimeMillis() - startTime;
                return new Result(symbolsApplied, nodesApplied, edgesApplied, elapsed, true);
            }

            program.endTransaction(transactionId, true);

            publishProgress(100, 100, "Complete");
            long elapsed = System.currentTimeMillis() - startTime;
            return new Result(symbolsApplied, nodesApplied, edgesApplied, elapsed, false);

        } catch (Exception e) {
            program.endTransaction(transactionId, false);
            throw e;
        }
    }

    /**
     * Apply a single symbol to the program.
     *
     * @param conflict The conflict entry containing the symbol to apply
     * @return true if the symbol was successfully applied
     */
    private boolean applySymbol(ConflictEntry conflict) {
        if (conflict.getRemoteSymbol() == null) {
            return false;
        }

        Symbol remoteSymbol = conflict.getRemoteSymbol();
        String symbolType = remoteSymbol.getSymbolType();

        Msg.debug(this, "Applying symbol type=" + symbolType + " at 0x" +
                Long.toHexString(conflict.getAddress()) + ", name=" +
                (remoteSymbol.getName() != null ? remoteSymbol.getName() : "<null>") +
                ", content=" + (remoteSymbol.getContent() != null ?
                        remoteSymbol.getContent().substring(0, Math.min(50, remoteSymbol.getContent().length())) + "..." : "<null>"));

        // Comments don't require a name, but need content
        if ("comment".equals(symbolType)) {
            return applyComment(conflict.getAddress(), remoteSymbol);
        }

        // Struct/enum types are applied to DataTypeManager, not at an address
        if ("struct".equals(symbolType) || "enum".equals(symbolType)) {
            return applyStructOrEnum(remoteSymbol);
        }

        // All other symbol types require a name
        if (remoteSymbol.getName() == null) {
            return false;
        }

        try {
            long addr = conflict.getAddress();
            Address address = program.getAddressFactory()
                .getDefaultAddressSpace().getAddress(addr);

            if ("variable".equals(symbolType)) {
                // Variable - use storage-aware application
                Function func = program.getFunctionManager().getFunctionContaining(address);
                if (func != null && func.getEntryPoint().getOffset() == addr) {
                    return applyVariableSymbol(func, remoteSymbol);
                }
            } else {
                // Function or other symbol
                Function func = program.getFunctionManager().getFunctionAt(address);
                if (func != null) {
                    func.setName(remoteSymbol.getName(), SourceType.USER_DEFINED);
                    return true;
                }
            }
        } catch (Exception e) {
            Msg.error(this, "Error applying symbol at 0x" +
                Long.toHexString(conflict.getAddress()) + ": " + e.getMessage());
        }

        return false;
    }

    /**
     * Apply a variable symbol using storage-aware matching.
     */
    private boolean applyVariableSymbol(Function func, Symbol remoteSymbol) {
        if (remoteSymbol == null || remoteSymbol.getName() == null) {
            return false;
        }

        Map<String, Object> metadata = remoteSymbol.getMetadata();
        if (metadata == null) {
            return false;
        }

        String storageClass = (String) metadata.get("storage_class");
        String targetName = remoteSymbol.getName();

        try {
            if ("parameter".equals(storageClass)) {
                Object paramIdxObj = metadata.get("parameter_index");
                if (paramIdxObj != null) {
                    int paramIdx = ((Number) paramIdxObj).intValue();
                    Parameter[] params = func.getParameters();
                    if (paramIdx < params.length) {
                        params[paramIdx].setName(targetName, SourceType.USER_DEFINED);
                        return true;
                    }
                }
            } else if ("stack".equals(storageClass)) {
                Object stackOffsetObj = metadata.get("stack_offset");
                if (stackOffsetObj != null) {
                    int stackOffset = ((Number) stackOffsetObj).intValue();
                    for (Variable var : func.getLocalVariables()) {
                        if (var.isStackVariable()) {
                            try {
                                if (var.getStackOffset() == stackOffset) {
                                    var.setName(targetName, SourceType.USER_DEFINED);
                                    return true;
                                }
                            } catch (UnsupportedOperationException e) {
                                // Not a simple stack var
                            }
                        }
                    }
                }
            } else if ("register".equals(storageClass)) {
                String regName = (String) metadata.get("register");
                if (regName != null) {
                    for (Variable var : func.getLocalVariables()) {
                        if (var.isRegisterVariable()) {
                            Register reg = var.getRegister();
                            if (reg != null && regName.equals(reg.getName())) {
                                var.setName(targetName, SourceType.USER_DEFINED);
                                return true;
                            }
                        }
                    }
                }
            }
        } catch (Exception e) {
            Msg.error(this, "Error applying variable: " + e.getMessage());
        }

        return false;
    }

    /**
     * Apply a comment symbol at the given address.
     *
     * @param addr The address for the comment
     * @param remoteSymbol The symbol containing the comment content and metadata
     * @return true if the comment was successfully applied
     */
    private boolean applyComment(long addr, Symbol remoteSymbol) {
        String content = remoteSymbol.getContent();
        if (content == null || content.isEmpty()) {
            Msg.debug(this, "Skipping comment at 0x" + Long.toHexString(addr) + ": empty content");
            return false;
        }

        Map<String, Object> metadata = remoteSymbol.getMetadata();
        String commentType = "eol";
        if (metadata != null && metadata.get("type") != null) {
            commentType = (String) metadata.get("type");
        }
        Msg.debug(this, "Applying comment at 0x" + Long.toHexString(addr) +
                ", type=" + commentType + ", content length=" + content.length());

        try {
            Address address = program.getAddressFactory()
                .getDefaultAddressSpace().getAddress(addr);

            Listing listing = program.getListing();

            if ("function".equals(commentType)) {
                // Apply as function comment (plate comment on function)
                Function func = program.getFunctionManager().getFunctionAt(address);
                if (func != null) {
                    func.setComment(content);
                    return true;
                }
                // Fall back to plate comment if no function at address
                CodeUnit codeUnit = listing.getCodeUnitAt(address);
                if (codeUnit != null) {
                    codeUnit.setComment(CommentType.PLATE, content);
                    return true;
                }
                return false;
            }

            CodeUnit codeUnit = listing.getCodeUnitAt(address);
            if (codeUnit == null) {
                // Try to get code unit containing the address
                codeUnit = listing.getCodeUnitContaining(address);
            }

            if (codeUnit != null) {
                CommentType ghidraCommentType;
                switch (commentType) {
                    case "pre":
                        ghidraCommentType = CommentType.PRE;
                        break;
                    case "post":
                        ghidraCommentType = CommentType.POST;
                        break;
                    case "plate":
                        ghidraCommentType = CommentType.PLATE;
                        break;
                    case "repeatable":
                        ghidraCommentType = CommentType.REPEATABLE;
                        break;
                    case "eol":
                    default:
                        ghidraCommentType = CommentType.EOL;
                        break;
                }
                codeUnit.setComment(ghidraCommentType, content);
                return true;
            }
        } catch (Exception e) {
            Msg.error(this, "Error applying comment at 0x" + Long.toHexString(addr) + ": " + e.getMessage());
        }

        return false;
    }

    /**
     * Apply a struct or enum type from symbol metadata.
     *
     * @param remoteSymbol The symbol containing the type definition in metadata
     * @return true if the type was successfully created
     */
    @SuppressWarnings("unchecked")
    private boolean applyStructOrEnum(Symbol remoteSymbol) {
        Map<String, Object> metadata = remoteSymbol.getMetadata();
        if (metadata == null) {
            return false;
        }

        String name = remoteSymbol.getName();
        if (name == null || name.isEmpty()) {
            return false;
        }

        String symbolType = remoteSymbol.getSymbolType();
        DataTypeManager dtm = program.getDataTypeManager();

        try {
            if ("enum".equals(symbolType)) {
                // Create enum from metadata
                Object membersObj = metadata.get("members");
                if (membersObj instanceof Map) {
                    Map<String, Object> members = (Map<String, Object>) membersObj;
                    int size = 4;  // Default to 4-byte enum
                    if (metadata.get("size") instanceof Number) {
                        size = ((Number) metadata.get("size")).intValue();
                    }

                    EnumDataType enumType = new EnumDataType(name, size);
                    for (Map.Entry<String, Object> entry : members.entrySet()) {
                        long value = 0;
                        if (entry.getValue() instanceof Number) {
                            value = ((Number) entry.getValue()).longValue();
                        }
                        enumType.add(entry.getKey(), value);
                    }
                    dtm.addDataType(enumType, DataTypeConflictHandler.REPLACE_HANDLER);
                    Msg.info(this, "Created enum type: " + name + " with " + members.size() + " members");
                    return true;
                }
            } else if ("struct".equals(symbolType)) {
                // Create struct from metadata
                Object fieldsObj = metadata.get("fields");
                if (fieldsObj instanceof java.util.List) {
                    java.util.List<Map<String, Object>> fields = (java.util.List<Map<String, Object>>) fieldsObj;

                    int structSize = 0;
                    if (metadata.get("size") instanceof Number) {
                        structSize = ((Number) metadata.get("size")).intValue();
                    }

                    StructureDataType struct = new StructureDataType(name, structSize);

                    for (Map<String, Object> field : fields) {
                        String fieldName = (String) field.get("name");
                        String fieldTypeName = (String) field.get("type");
                        int offset = 0;
                        int fieldSize = 0;

                        if (field.get("offset") instanceof Number) {
                            offset = ((Number) field.get("offset")).intValue();
                        }
                        if (field.get("size") instanceof Number) {
                            fieldSize = ((Number) field.get("size")).intValue();
                        }

                        DataType fieldType = resolveDataType(dtm, fieldTypeName);
                        if (fieldType == null) {
                            fieldType = DataType.DEFAULT;
                        }

                        // Use insertAtOffset for explicit placement
                        int actualSize = fieldSize > 0 ? fieldSize : fieldType.getLength();
                        if (actualSize <= 0) {
                            actualSize = 1;  // Minimum size
                        }
                        struct.insertAtOffset(offset, fieldType, actualSize, fieldName, null);
                    }

                    dtm.addDataType(struct, DataTypeConflictHandler.REPLACE_HANDLER);
                    Msg.info(this, "Created struct type: " + name + " with " + fields.size() + " fields");
                    return true;
                }
            }
        } catch (Exception e) {
            Msg.error(this, "Error creating type " + name + ": " + e.getMessage());
        }

        return false;
    }

    /**
     * Resolve a data type by name from the DataTypeManager.
     *
     * @param dtm The data type manager
     * @param typeName The name of the type to resolve
     * @return The resolved DataType, or null if not found
     */
    private DataType resolveDataType(DataTypeManager dtm, String typeName) {
        if (typeName == null || typeName.isEmpty()) {
            return null;
        }

        // Try to find in root category
        DataType dt = dtm.getDataType("/" + typeName);
        if (dt != null) {
            return dt;
        }

        // Try without leading slash
        dt = dtm.getDataType(typeName);
        if (dt != null) {
            return dt;
        }

        // Try to find built-in types by common names
        String lowerName = typeName.toLowerCase();
        switch (lowerName) {
            case "int":
            case "int32":
            case "int32_t":
                return ghidra.program.model.data.IntegerDataType.dataType;
            case "uint":
            case "uint32":
            case "uint32_t":
            case "unsigned int":
                return ghidra.program.model.data.UnsignedIntegerDataType.dataType;
            case "long":
            case "int64":
            case "int64_t":
                return ghidra.program.model.data.LongDataType.dataType;
            case "ulong":
            case "uint64":
            case "uint64_t":
            case "unsigned long":
                return ghidra.program.model.data.UnsignedLongDataType.dataType;
            case "short":
            case "int16":
            case "int16_t":
                return ghidra.program.model.data.ShortDataType.dataType;
            case "ushort":
            case "uint16":
            case "uint16_t":
            case "unsigned short":
                return ghidra.program.model.data.UnsignedShortDataType.dataType;
            case "char":
            case "int8":
            case "int8_t":
                return ghidra.program.model.data.CharDataType.dataType;
            case "uchar":
            case "uint8":
            case "uint8_t":
            case "unsigned char":
            case "byte":
                return ghidra.program.model.data.ByteDataType.dataType;
            case "float":
                return ghidra.program.model.data.FloatDataType.dataType;
            case "double":
                return ghidra.program.model.data.DoubleDataType.dataType;
            case "void":
                return ghidra.program.model.data.VoidDataType.dataType;
            case "pointer":
            case "ptr":
            case "void*":
                return ghidra.program.model.data.PointerDataType.dataType;
            default:
                return null;
        }
    }

    /**
     * Merge graph data from the export into the local knowledge graph.
     *
     * @return Array of [nodesApplied, edgesApplied]
     */
    private int[] mergeGraphData() {
        int nodesApplied = 0;
        int edgesApplied = 0;

        if (graphExport == null || programHash == null) {
            return new int[] { 0, 0 };
        }

        BinaryKnowledgeGraph graph = analysisDB.getKnowledgeGraph(programHash);
        if (MERGE_POLICY_REPLACE.equals(mergePolicy)) {
            graph.clearGraph();
        }

        Map<Long, String> addressToId = new HashMap<>();
        List<GraphNode> nodes = graphExport.getNodes();
        int totalNodes = nodes.size();

        // Process nodes
        for (int i = 0; i < totalNodes; i++) {
            if (isCancelRequested()) {
                break;
            }

            // Progress within the graph merge phase (0-25%)
            int progress = totalNodes > 0 ? (int)((i * 25L) / totalNodes) : 0;
            publishProgress(progress, 100,
                String.format("Merging node %d/%d...", i + 1, totalNodes));

            GraphNode node = nodes.get(i);
            NodeType nodeType = NodeType.fromString(node.getNodeType());
            if (nodeType == null) {
                nodeType = NodeType.FUNCTION;
            }

            KnowledgeNode existing = graph.getNodeByAddress(node.getAddress());
            if (MERGE_POLICY_PREFER_LOCAL.equals(mergePolicy) && existing != null) {
                addressToId.put(node.getAddress(), existing.getId());
                continue;
            }

            KnowledgeNode localNode = node.getId() != null
                    ? new KnowledgeNode(node.getId(), nodeType, programHash)
                    : new KnowledgeNode(nodeType, programHash);
            if (existing != null) {
                localNode.setId(existing.getId());
            }

            localNode.setAddress(node.getAddress());
            localNode.setName(node.getName());

            Map<String, Object> props = node.getProperties();
            String rawContent = props != null ? (String) props.get("raw_content") : null;
            if (rawContent == null && props != null) {
                rawContent = (String) props.get("raw_code");
            }
            String summary = node.getSummary();
            if (summary == null && props != null) {
                summary = (String) props.get("llm_summary");
            }

            localNode.setRawContent(rawContent);
            localNode.setLlmSummary(summary);
            localNode.setConfidence((float) getDoubleProperty(props, "confidence", 0.0));
            localNode.setSecurityFlags(getListProperty(props, "security_flags"));
            localNode.setNetworkAPIs(getListProperty(props, "network_apis"));
            localNode.setFileIOAPIs(getListProperty(props, "file_io_apis"));
            localNode.setIPAddresses(getListProperty(props, "ip_addresses"));
            localNode.setURLs(getListProperty(props, "urls"));
            localNode.setFilePaths(getListProperty(props, "file_paths"));
            localNode.setDomains(getListProperty(props, "domains"));
            localNode.setRegistryKeys(getListProperty(props, "registry_keys"));
            if (props != null) {
                localNode.setRiskLevel((String) props.get("risk_level"));
                localNode.setActivityProfile((String) props.get("activity_profile"));
                Object depth = props.get("analysis_depth");
                if (depth instanceof Number) {
                    localNode.setAnalysisDepth(((Number) depth).intValue());
                }
                Object isStale = props.get("is_stale");
                if (isStale instanceof Boolean) {
                    localNode.setStale((Boolean) isStale);
                }
                Object userEdited = props.get("user_edited");
                if (userEdited instanceof Boolean) {
                    localNode.setUserEdited((Boolean) userEdited);
                }
            }

            // Debug logging for graph node properties
            Msg.debug(this, "Node at 0x" + Long.toHexString(node.getAddress()) +
                    " - security_flags: " + localNode.getSecurityFlags() +
                    ", risk_level: " + localNode.getRiskLevel() +
                    ", network_apis: " + localNode.getNetworkAPIs() +
                    ", file_io_apis: " + localNode.getFileIOAPIs() +
                    ", has_summary: " + (localNode.getLlmSummary() != null));

            graph.upsertNode(localNode);
            addressToId.put(node.getAddress(), localNode.getId());
            nodesApplied++;
        }

        // Process edges
        List<GraphEdge> edges = graphExport.getEdges();
        int totalEdges = edges.size();
        Gson gson = new Gson();

        for (int i = 0; i < totalEdges; i++) {
            if (isCancelRequested()) {
                break;
            }

            // Progress within the edge merge phase (25-30%)
            int progress = totalEdges > 0 ? 25 + (int)((i * 5L) / totalEdges) : 25;
            publishProgress(progress, 100,
                String.format("Merging edge %d/%d...", i + 1, totalEdges));

            GraphEdge edge = edges.get(i);
            String sourceId = addressToId.get(edge.getSourceAddress());
            String targetId = addressToId.get(edge.getTargetAddress());
            if (sourceId == null || targetId == null) {
                continue;
            }
            EdgeType edgeType = EdgeType.fromString(edge.getEdgeType());
            if (edgeType == null) {
                edgeType = EdgeType.CALLS;
            }
            Map<String, Object> props = edge.getProperties();
            double weight = getDoubleProperty(props, "weight", 1.0);
            String metadata = props != null ? gson.toJson(props) : null;
            graph.addEdge(sourceId, targetId, edgeType, weight, metadata);
            edgesApplied++;
        }

        return new int[] { nodesApplied, edgesApplied };
    }

    private List<String> getListProperty(Map<String, Object> props, String key) {
        if (props == null) {
            return new ArrayList<>();
        }
        Object value = props.get(key);
        if (value instanceof List) {
            List<String> list = new ArrayList<>();
            for (Object item : (List<?>) value) {
                if (item != null) {
                    list.add(item.toString());
                }
            }
            return list;
        }
        return new ArrayList<>();
    }

    private double getDoubleProperty(Map<String, Object> props, String key, double defaultValue) {
        if (props == null) {
            return defaultValue;
        }
        Object value = props.get(key);
        if (value instanceof Number) {
            return ((Number) value).doubleValue();
        }
        return defaultValue;
    }
}

```

`src/main/java/ghidrassist/workers/SymGraphPullWorker.java`:

```java
package ghidrassist.workers;

import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import ghidrassist.services.symgraph.SymGraphService;
import ghidrassist.services.symgraph.SymGraphModels.*;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Background worker for pulling symbols and graph data from SymGraph.
 * Uses SwingWorker to run in the background without blocking the UI.
 */
public class SymGraphPullWorker extends AnalysisWorker<SymGraphPullWorker.Result> {

    /**
     * Result of the pull operation.
     */
    public static class Result {
        public final List<ConflictEntry> conflicts;
        public final GraphExport graphExport;
        public final int graphNodes;
        public final int graphEdges;
        public final int graphCommunities;
        public final long elapsedMs;
        public final boolean cancelled;
        public final String error;

        public Result(List<ConflictEntry> conflicts, GraphExport graphExport,
                      int graphNodes, int graphEdges, int graphCommunities,
                      long elapsedMs, boolean cancelled) {
            this.conflicts = conflicts;
            this.graphExport = graphExport;
            this.graphNodes = graphNodes;
            this.graphEdges = graphEdges;
            this.graphCommunities = graphCommunities;
            this.elapsedMs = elapsedMs;
            this.cancelled = cancelled;
            this.error = null;
        }

        public Result(String error) {
            this.conflicts = new ArrayList<>();
            this.graphExport = null;
            this.graphNodes = 0;
            this.graphEdges = 0;
            this.graphCommunities = 0;
            this.elapsedMs = 0;
            this.cancelled = false;
            this.error = error;
        }

        public Result(long elapsedMs, boolean cancelled) {
            this.conflicts = new ArrayList<>();
            this.graphExport = null;
            this.graphNodes = 0;
            this.graphEdges = 0;
            this.graphCommunities = 0;
            this.elapsedMs = elapsedMs;
            this.cancelled = cancelled;
            this.error = null;
        }
    }

    private final Program program;
    private final SymGraphService symGraphService;
    private final String sha256;
    private final List<String> symbolTypes;
    private final double minConfidence;
    private final boolean includeGraph;

    /**
     * Create a new SymGraphPullWorker.
     *
     * @param program        The Ghidra program (for local symbol lookup)
     * @param symGraphService The SymGraph service for API calls
     * @param sha256         SHA256 hash of the binary
     * @param symbolTypes    List of symbol types to fetch (function, variable, etc.)
     * @param minConfidence  Minimum confidence threshold for symbols
     * @param includeGraph   Whether to fetch graph data
     */
    public SymGraphPullWorker(Program program, SymGraphService symGraphService,
                               String sha256, List<String> symbolTypes,
                               double minConfidence, boolean includeGraph) {
        this.program = program;
        this.symGraphService = symGraphService;
        this.sha256 = sha256;
        this.symbolTypes = symbolTypes != null ? symbolTypes : new ArrayList<>();
        this.minConfidence = minConfidence;
        this.includeGraph = includeGraph;
    }

    @Override
    protected Result doInBackground() throws Exception {
        long startTime = System.currentTimeMillis();

        try {
            // Phase 1: Fetch symbols (0-60%)
            List<Symbol> allRemoteSymbols = new ArrayList<>();
            int totalTypes = symbolTypes.size();

            for (int i = 0; i < totalTypes; i++) {
                if (isCancelRequested()) {
                    long elapsed = System.currentTimeMillis() - startTime;
                    return new Result(elapsed, true);
                }

                String symType = symbolTypes.get(i);
                int progress = (int) ((i * 60L) / Math.max(totalTypes, 1));
                publishProgress(progress, 100, "Fetching " + symType + " symbols...");

                List<Symbol> remoteSymbols = symGraphService.getSymbols(sha256, symType);
                allRemoteSymbols.addAll(remoteSymbols);
                Msg.info(this, "Fetched " + remoteSymbols.size() + " " + symType + " symbols from API");
            }

            if (isCancelRequested()) {
                long elapsed = System.currentTimeMillis() - startTime;
                return new Result(elapsed, true);
            }

            // Phase 2: Fetch graph data (60-80%)
            GraphExport graphExport = null;
            int graphNodes = 0;
            int graphEdges = 0;
            int graphCommunities = 0;

            if (includeGraph) {
                publishProgress(60, 100, "Fetching graph data...");
                graphExport = symGraphService.exportGraph(sha256);
                if (graphExport != null) {
                    graphNodes = graphExport.getNodes().size();
                    graphEdges = graphExport.getEdges().size();
                    graphCommunities = getGraphCommunityCount(graphExport);
                }
            }

            if (isCancelRequested()) {
                long elapsed = System.currentTimeMillis() - startTime;
                return new Result(elapsed, true);
            }

            // Phase 3: Build conflict list (80-100%)
            publishProgress(80, 100, "Building conflict list...");

            Map<Long, String> localSymbols = getLocalSymbolMap();
            List<ConflictEntry> conflicts = symGraphService.buildConflictEntries(
                localSymbols, allRemoteSymbols, minConfidence);

            publishProgress(100, 100, "Complete");

            long elapsed = System.currentTimeMillis() - startTime;
            return new Result(conflicts, graphExport, graphNodes, graphEdges, graphCommunities, elapsed, false);

        } catch (Exception e) {
            Msg.error(this, "Pull preview error: " + e.getMessage(), e);
            return new Result(e.getMessage());
        }
    }

    /**
     * Get local symbol map for conflict detection.
     */
    private Map<Long, String> getLocalSymbolMap() {
        Map<Long, String> symbolMap = new HashMap<>();

        if (program == null) {
            return symbolMap;
        }

        try {
            for (Function func : program.getFunctionManager().getFunctions(true)) {
                String qualifiedName = ghidrassist.services.symgraph.SymGraphUtils.getQualifiedFunctionName(func);
                // Use unified default name detection for cross-tool compatibility
                if (!ghidrassist.services.symgraph.SymGraphUtils.isDefaultName(qualifiedName)) {
                    symbolMap.put(func.getEntryPoint().getOffset(), qualifiedName);
                }
            }
        } catch (Exception e) {
            Msg.error(this, "Error getting local symbols: " + e.getMessage());
        }

        return symbolMap;
    }

    /**
     * Get the number of communities from graph export metadata.
     */
    private int getGraphCommunityCount(GraphExport export) {
        if (export == null || export.getMetadata() == null) {
            return 0;
        }
        Object countValue = export.getMetadata().get("community_count");
        if (countValue instanceof Number) {
            return ((Number) countValue).intValue();
        }
        Object communitiesValue = export.getMetadata().get("communities");
        if (communitiesValue instanceof java.util.List) {
            return ((java.util.List<?>) communitiesValue).size();
        }
        return 0;
    }
}

```

`src/main/resources/images/README.txt`:

```txt
The "src/resources/images" directory is intended to hold all image/icon files used by
this module.

```

`src/main/resources/images/robot.svg`:

```svg
<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
  <!-- Robot head outline -->
  <rect x="6" y="4" width="20" height="24" rx="2" fill="#4A90E2" stroke="#2171C7" stroke-width="1.5"/>
  
  <!-- Antenna -->
  <line x1="16" y1="1" x2="16" y2="4" stroke="#2171C7" stroke-width="1.5"/>
  <circle cx="16" cy="1" r="1" fill="#2171C7"/>
  
  <!-- Eyes -->
  <rect x="9" y="10" width="5" height="5" rx="1" fill="#2171C7"/>
  <rect x="18" y="10" width="5" height="5" rx="1" fill="#2171C7"/>
  
  <!-- Mouth -->
  <rect x="10" y="19" width="12" height="3" rx="1" fill="#2171C7"/>
  <line x1="11" y1="20.5" x2="21" y2="20.5" stroke="#4A90E2" stroke-width="1"/>
  
  <!-- Display lines -->
  <line x1="8" y1="24" x2="24" y2="24" stroke="#2171C7" stroke-width="1"/>
  <line x1="8" y1="26" x2="24" y2="26" stroke="#2171C7" stroke-width="1"/>
</svg>

```