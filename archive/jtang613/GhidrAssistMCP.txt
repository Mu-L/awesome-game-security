Project Path: arc_jtang613_GhidrAssistMCP_yaqkhh3k

Source Tree:

```txt
arc_jtang613_GhidrAssistMCP_yaqkhh3k
├── LICENSE
├── Module.manifest
├── README.md
├── build.gradle
├── extension.properties
├── res
│   ├── Screenshot1.png
│   └── Screenshot2.png
└── src
    └── main
        ├── help
        │   └── help
        │       ├── TOC_Source.xml
        │       └── topics
        │           └── ghidramcp
        │               └── help.html
        ├── java
        │   └── ghidrassistmcp
        │       ├── GhidrAssistMCPBackend.java
        │       ├── GhidrAssistMCPManager.java
        │       ├── GhidrAssistMCPPlugin.java
        │       ├── GhidrAssistMCPProvider.java
        │       ├── GhidrAssistMCPServer.java
        │       ├── McpBackend.java
        │       ├── McpEventListener.java
        │       ├── McpTool.java
        │       ├── cache
        │       │   ├── CacheEntry.java
        │       │   └── McpCache.java
        │       ├── prompts
        │       │   ├── AnalyzeFunctionPrompt.java
        │       │   ├── DocumentFunctionPrompt.java
        │       │   ├── IdentifyVulnerabilityPrompt.java
        │       │   ├── McpPrompt.java
        │       │   ├── McpPromptRegistry.java
        │       │   ├── TraceDataFlowPrompt.java
        │       │   └── TraceNetworkDataPrompt.java
        │       ├── resources
        │       │   ├── ExportsResource.java
        │       │   ├── FunctionListResource.java
        │       │   ├── ImportsResource.java
        │       │   ├── McpResource.java
        │       │   ├── McpResourceRegistry.java
        │       │   ├── ProgramInfoResource.java
        │       │   └── StringsResource.java
        │       ├── tasks
        │       │   ├── McpTask.java
        │       │   └── McpTaskManager.java
        │       └── tools
        │           ├── BookmarksTool.java
        │           ├── CancelTaskTool.java
        │           ├── ClassTool.java
        │           ├── DeleteDataTypeTool.java
        │           ├── GetBasicBlocksTool.java
        │           ├── GetCallGraphTool.java
        │           ├── GetCodeTool.java
        │           ├── GetCurrentAddressTool.java
        │           ├── GetCurrentFunctionTool.java
        │           ├── GetDataTypeTool.java
        │           ├── GetFunctionInfoTool.java
        │           ├── GetHexdumpTool.java
        │           ├── GetTaskStatusTool.java
        │           ├── ListDataTool.java
        │           ├── ListDataTypesTool.java
        │           ├── ListExportsTool.java
        │           ├── ListFunctionsTool.java
        │           ├── ListImportsTool.java
        │           ├── ListNamespacesTool.java
        │           ├── ListProgramsTool.java
        │           ├── ListRelocationsTool.java
        │           ├── ListSegmentsTool.java
        │           ├── ListStringsTool.java
        │           ├── ListTasksTool.java
        │           ├── ProgramInfoTool.java
        │           ├── RenameSymbolBatchTool.java
        │           ├── RenameSymbolTool.java
        │           ├── SearchBytesTool.java
        │           ├── SetCommentTool.java
        │           ├── SetDataTypeTool.java
        │           ├── SetFunctionPrototypeTool.java
        │           ├── SetLocalVariableTypeTool.java
        │           ├── StructTool.java
        │           └── XrefsTool.java
        └── resources
            └── images
                └── README.txt

```

`LICENSE`:

```
Copyright (c) 2025 Jason Tang

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

`README.md`:

```md
# GhidrAssistMCP

A powerful Ghidra extension that provides an MCP (Model Context Protocol) server, enabling AI assistants and other tools to interact with Ghidra's reverse engineering capabilities through a standardized API.

## Overview

GhidrAssistMCP bridges the gap between AI-powered analysis tools and Ghidra's comprehensive reverse engineering platform. By implementing the Model Context Protocol, this extension allows external AI assistants, automated analysis tools, and custom scripts to seamlessly interact with Ghidra's analysis capabilities.

### Key Features

- **MCP Server Integration**: Full Model Context Protocol server implementation using official SDK
- **Dual HTTP Transports**: Supports SSE and Streamable HTTP transports for maximum client compatibility
- **34 Built-in Tools**: Comprehensive set of analysis tools with action-based consolidation for cleaner APIs
- **5 MCP Resources**: Static data resources for program info, functions, strings, imports, and exports
- **5 MCP Prompts**: Pre-built analysis prompts for common reverse engineering tasks
- **Result Caching**: Intelligent caching system to improve performance for repeated queries
- **Async Task Support**: Long-running operations execute asynchronously with task management
- **Multi-Program Support**: Work with multiple open programs simultaneously using `program_name` parameter
- **Multi-Window Support**: Single MCP server shared across all CodeBrowser windows with intelligent focus tracking
- **Active Context Awareness**: Automatic detection of which binary window is in focus, with context hints in all tool responses
- **Configurable UI**: Easy-to-use interface for managing tools and monitoring activity
- **Real-time Logging**: Track all MCP requests and responses with detailed logging
- **Dynamic Tool Management**: Enable/disable tools individually with persistent settings

## Clients

Shameless self-promotion: [GhidrAssist](https://github.com/jtang613/GhidrAssist) supports GhidrAssistMCP right out of the box.

## Screenshots

![Screenshot](https://github.com/jtang613/GhidrAssistMCP/blob/master/res/Screenshot1.png)
![Screenshot](https://github.com/jtang613/GhidrAssistMCP/blob/master/res/Screenshot2.png)

## Installation

### Prerequisites

- **Ghidra 11.4+** (tested with Ghidra 12.0 Public)
- **An MCP Client (Like GhidrAssist)**

### Binary Release (Recommended)

1. **Download the latest release**:
   - Go to the [Releases page](https://github.com/jtang613/GhidrAssistMCP/releases)
   - Download the latest `.zip` file (e.g., `GhidrAssistMCP-v1.0.0.zip`)

2. **Install the extension**:
   - In Ghidra: **File → Install Extensions → Add Extension**
   - Select the downloaded ZIP file
   - Restart Ghidra when prompted

3. **Enable the plugin**:
   - **File → Configure → Configure Plugins**
   - Search for "GhidrAssistMCP"
   - Check the box to enable the plugin

### Building from Source

1. **Clone the repository**:

   ```bash
   git clone <repository-url>
   cd GhidrAssistMCP
   ```

2. **Point Gradle at your Ghidra install**:
   - Set `GHIDRA_INSTALL_DIR` (environment variable), or pass `-PGHIDRA_INSTALL_DIR=<path>` when you run Gradle.

3. **Build + install**:

   Ensure Ghidra isn't running and run:

   ```bash
   gradle installExtension
   ```

   This copies the built ZIP into your Ghidra install (`[GHIDRA_INSTALL_DIR]/Extensions/Ghidra`) and extracts it into your Ghidra **user** Extensions folder (replacing any existing extracted copy).

   If you need to override that location, pass `-PGHIDRA_USER_EXTENSIONS_DIR=<path>`.

4. **Restart / verify**:
   - Restart Ghidra.
   - If the plugin doesn't appear, enable it via **File → Configure → Configure Plugins** (search for "GhidrAssistMCP").

## Configuration

### Initial Setup

1. **Open the Control Panel**:
   - Window → GhidrAssistMCP (or use the toolbar icon)

2. **Configure Server Settings**:
   - **Host**: Default is `localhost`
   - **Port**: Default is `8080`
   - **Enable/Disable**: Toggle the MCP server on/off

### Tool Management

The Configuration tab allows you to:

- **View all available tools** (34 total)
- **Enable/disable individual tools** using checkboxes
- **Save configuration** to persist across sessions
- **Monitor tool status** in real-time

## Available Tools

GhidrAssistMCP provides 34 tools organized into categories. Several tools use an action-based API pattern where a single tool provides multiple related operations.

### Program & Data Listing

| Tool | Description |
| ---- | ----------- |
| `get_program_info` | Get basic program information (name, architecture, compiler, etc.) |
| `list_programs` | List all open programs across all CodeBrowser windows |
| `list_functions` | List functions with optional pattern filtering and pagination |
| `list_data` | List data definitions in the program |
| `list_data_types` | List all available data types |
| `list_strings` | List string references with optional filtering |
| `list_imports` | List imported functions/symbols |
| `list_exports` | List exported functions/symbols |
| `list_segments` | List memory segments |
| `list_namespaces` | List namespaces in the program |
| `list_relocations` | List relocation entries |

### Function & Code Analysis

| Tool | Description |
| ---- | ----------- |
| `get_function_info` | Get detailed function information (signature, variables, etc.) |
| `get_current_function` | Get function at current cursor position |
| `get_current_address` | Get current cursor address |
| `get_hexdump` | Get hexdump of memory at specific address |
| `get_call_graph` | Get call graph for a function (callers and callees) |
| `get_basic_blocks` | Get basic block information for a function |

### Consolidated Tools

These tools bundle related operations behind a discriminator parameter (e.g., `action`, `target`, `target_type`, or `format`).

#### `get_code` - Code Retrieval Tool

| Parameter | Values | Description |
| --------- | ------ | ----------- |
| `format` | `decompiler`, `disassembly`, `pcode` | Output format |
| `raw` | boolean | Only affects `format: "pcode"` (raw pcode ops vs grouped by basic blocks) |

#### `class` - Class Operations Tool

| Action | Description |
| ------ | ----------- |
| `list` | List classes with optional pattern filtering and pagination |
| `get_info` | Get detailed class information (methods, fields, vtables, virtual functions) |

#### `xrefs` - Cross-Reference Tool

| Parameter | Description |
| --------- | ----------- |
| `address` | Find all references to/from a specific address |
| `function` | Find all cross-references for a function |

#### `struct` - Structure Operations Tool

| Action | Description |
| ------ | ----------- |
| `create` | Create a new structure from C definition or empty |
| `modify` | Modify an existing structure with new C definition |
| `merge` | Merge (overlay) fields from a C definition onto an existing structure without deleting existing fields |
| `set_field` | Set/insert a single field at a specific offset without needing a full C struct (use `field_name` to name it) |
| `name_gap` | Convert undefined bytes at an offset/length into a named `byte[]`-like field (useful for “naming gaps”; uses `field_name`) |
| `auto_create` | Automatically create structure from variable usage patterns |
| `rename_field` | Rename a field within a structure |
| `field_xrefs` | Find cross-references to a specific struct field |

#### `rename_symbol` - Symbol Renaming Tool

| Parameter | Values | Description |
| --------- | ------ | ----------- |
| `target_type` | `function`, `data`, `variable` | What kind of symbol to rename |

#### `set_comment` - Comment Tool

| Parameter | Values | Description |
| --------- | ------ | ----------- |
| `target` | `function`, `address` | Where to set the comment |
| `comment_type` | `eol`, `pre`, `post`, `plate`, `repeatable` | Comment type for `target: "address"` (default `eol`) |

#### `bookmarks` - Bookmark Management Tool

| Action | Description |
| ------ | ----------- |
| `list` | List all bookmarks |
| `add` | Add a new bookmark |
| `delete` | Delete a bookmark |

### Type & Prototype Tools

| Tool | Description |
| ----- | ----------- |
| `get_data_type` | Get detailed data type information and structure definitions |
| `delete_data_type` | Delete a data type by name (optionally scoped by `category`) |
| `set_data_type` | Set data type at a specific address |
| `set_function_prototype` | Set function signature/prototype |
| `set_local_variable_type` | Set data type for local variables |

### Search Tools

| Tool | Description |
| ----- | ----------- |
| `search_bytes` | Search for byte patterns in memory |

### Async Task Management

Long-running operations (decompilation, structure analysis, field xrefs) execute asynchronously:

| Tool | Description |
| ---- | ----------- |
| `get_task_status` | Check status and retrieve results of async tasks |
| `cancel_task` | Cancel a running async task |
| `list_tasks` | List all pending/running/completed tasks |

## MCP Resources

GhidrAssistMCP exposes 5 static resources that can be read by MCP clients:

| Resource URI | Description |
| ------------ | ----------- |
| `ghidra://program/info` | Basic program information |
| `ghidra://program/functions` | List of all functions |
| `ghidra://program/strings` | String references |
| `ghidra://program/imports` | Imported symbols |
| `ghidra://program/exports` | Exported symbols |

## MCP Prompts

Pre-built prompts for common analysis tasks:

| Prompt | Description |
| ------ | ----------- |
| `analyze_function` | Comprehensive function analysis prompt |
| `identify_vulnerability` | Security vulnerability identification |
| `document_function` | Generate function documentation |
| `trace_data_flow` | Data flow analysis prompt |
| `trace_network_data` | Trace network send/recv call stacks for protocol analysis and network vulnerability identification |

## Usage Examples

### Basic Program Information

```json
{
  "method": "tools/call",
  "params": {
    "name": "get_program_info"
  }
}
```

### List Functions with Pattern Filtering

```json
{
  "method": "tools/call",
  "params": {
    "name": "list_functions",
    "arguments": {
      "pattern": "init",
      "case_sensitive": false,
      "limit": 50
    }
  }
}
```

### Decompile Function (`get_code`)

```json
{
  "method": "tools/call",
  "params": {
    "name": "get_code",
    "arguments": {
      "function": "main",
      "format": "decompiler"
    }
  }
}
```

### Get Class Information (Action-Based)

```json
{
  "method": "tools/call",
  "params": {
    "name": "class",
    "arguments": {
      "action": "get_info",
      "class_name": "MyClass"
    }
  }
}
```

### Search Classes (Action-Based)

```json
{
  "method": "tools/call",
  "params": {
    "name": "class",
    "arguments": {
      "action": "list",
      "pattern": "Socket",
      "case_sensitive": false
    }
  }
}
```

### Auto-Create Structure (Action-Based)

```json
{
  "method": "tools/call",
  "params": {
    "name": "struct",
    "arguments": {
      "action": "auto_create",
      "function_identifier": "0x00401000",
      "variable_name": "ctx"
    }
  }
}
```

### Find Struct Field Cross-References (Action-Based)

```json
{
  "method": "tools/call",
  "params": {
    "name": "struct",
    "arguments": {
      "action": "field_xrefs",
      "structure_name": "Host",
      "field_name": "port"
    }
  }
}
```

### Delete a Data Type

If multiple types share the same name across categories, pass `category` (or pass a full path in `name` starting with `/`).

```json
{
  "method": "tools/call",
  "params": {
    "name": "delete_data_type",
    "arguments": {
      "name": "MyStruct",
      "category": "/mytypes"
    }
  }
}
```

### Rename Function (Action-Based)

```json
{
  "method": "tools/call",
  "params": {
    "name": "rename_symbol",
    "arguments": {
      "action": "function",
      "address": "0x00401000",
      "new_name": "decrypt_buffer"
    }
  }
}
```

### Multi-Program Support

When working with multiple open programs, first list them:

```json
{
  "method": "tools/call",
  "params": {
    "name": "list_programs"
  }
}
```

Then specify which program to target using `program_name`:

```json
{
  "method": "tools/call",
  "params": {
    "name": "list_functions",
    "arguments": {
      "program_name": "target_binary.exe",
      "limit": 10
    }
  }
}
```

## Multi-Window Support & Active Context Awareness

GhidrAssistMCP uses a singleton architecture that enables seamless operation across multiple CodeBrowser windows:

### How It Works

1. **Single Shared Server**: One MCP server (port 8080) serves all CodeBrowser windows
2. **Focus Tracking**: Automatically detects which CodeBrowser window is currently active
3. **Context Hints**: All tool responses include context information to help AI understand which binary is in focus

### Context Information in Responses

Every tool response includes a context header:

```plaintext
[Context] Operating on: malware.exe | Active window: malware.exe

<tool response content>
```

or when targeting a different program:

```plaintext
[Context] Operating on: lib.so | Active window: main.exe | Total open programs: 3

<tool response content>
```

### Benefits for AI Assistants

- **Smart Defaults**: When no `program_name` is specified, tools automatically use the program from the active window
- **Context Awareness**: AI knows which binary the user is currently viewing
- **Prevents Confusion**: Clear indication when operating on a different binary than what's in the active window
- **Multi-tasking**: Work with multiple binaries without constantly specifying which one to target

## Architecture

### Core Components

```plaintext
GhidrAssistMCP/
├── GhidrAssistMCPManager     # Singleton coordinator for multi-window support
│   ├── Tracks all CodeBrowser windows
│   ├── Manages focus tracking
│   └── Owns shared server and backend
├── GhidrAssistMCPPlugin      # Plugin instance (one per CodeBrowser window)
│   └── Registers with singleton manager
├── GhidrAssistMCPServer      # HTTP MCP server (SSE + Streamable)
│   └── Single shared instance on port 8080
├── GhidrAssistMCPBackend     # Tool management and execution
│   ├── Tool registry with enable/disable states
│   ├── Result caching system
│   ├── Async task management
│   └── Resource and prompt registries
├── GhidrAssistMCPProvider    # UI component provider
│   └── First registered instance provides UI
├── cache/                    # Caching infrastructure
│   ├── McpCache.java
│   └── CacheEntry.java
├── tasks/                    # Async task management
│   ├── McpTaskManager.java
│   └── McpTask.java
├── resources/                # MCP Resources (5 total)
│   ├── ProgramInfoResource.java
│   ├── FunctionListResource.java
│   ├── StringsResource.java
│   ├── ImportsResource.java
│   └── ExportsResource.java
├── prompts/                  # MCP Prompts (5 total)
│   ├── AnalyzeFunctionPrompt.java
│   ├── IdentifyVulnerabilityPrompt.java
│   ├── DocumentFunctionPrompt.java
│   ├── TraceDataFlowPrompt.java
│   └── TraceNetworkDataPrompt.java
└── tools/                    # MCP Tools (34 total)
    ├── Consolidated action-based tools
    ├── Analysis tools
    ├── Modification tools
    └── Navigation tools
```

### Tool Design Patterns

**Consolidated Tools**: Related operations are consolidated into single tools with a discriminator parameter:

- `get_code`: `format: decompiler|disassembly|pcode`
- `class`: `action: list|get_info`
- `struct`: `action: create|modify|auto_create|rename_field|field_xrefs`
- `rename_symbol`: `target_type: function|data|variable`
- `set_comment`: `target: function|address`
- `bookmarks`: `action: list|add|delete`

**Tool Interface Methods**:

- `isReadOnly()`: Indicates if tool modifies program state
- `isLongRunning()`: Triggers async execution with task management
- `isCacheable()`: Enables result caching for repeated queries
- `isDestructive()`: Marks potentially dangerous operations
- `isIdempotent()`: Indicates if repeated calls produce same result

### MCP Protocol Implementation

- **Transports**:
  - HTTP with Server-Sent Events (SSE)
  - Streamable HTTP
- **Endpoints**:
  - `GET /sse` - SSE connection for bidirectional communication
  - `POST /message` - Message exchange endpoint
  - `GET /mcp` - Receive Streamable HTTP events
  - `POST /mcp` - Initialize Streamable HTTP session
  - `DELETE /mcp` - Terminate Streamable HTTP session
- **Capabilities**: Tools, Resources, Prompts

## Development

### Project Structure

```plaintext
src/main/java/ghidrassistmcp/
├── GhidrAssistMCPPlugin.java      # Main plugin class
├── GhidrAssistMCPManager.java     # Singleton coordinator
├── GhidrAssistMCPProvider.java    # UI provider with tabs
├── GhidrAssistMCPServer.java      # MCP server implementation
├── GhidrAssistMCPBackend.java     # Backend tool/resource/prompt management
├── McpBackend.java                # Backend interface
├── McpTool.java                   # Tool interface
├── McpEventListener.java          # Event notification interface
├── cache/                         # Caching system
├── tasks/                         # Async task system
├── resources/                     # MCP resources
├── prompts/                       # MCP prompts
└── tools/                         # Tool implementations (34 files)
```

### Adding New Tools

1. **Implement McpTool interface**:

   ```java
   public class MyCustomTool implements McpTool {
       @Override
       public String getName() { return "my_custom_tool"; }

       @Override
       public String getDescription() { return "Description"; }

       @Override
       public boolean isReadOnly() { return true; }

       @Override
       public boolean isLongRunning() { return false; }

       @Override
       public boolean isCacheable() { return true; }

       @Override
       public McpSchema.JsonSchema getInputSchema() { /* ... */ }

       @Override
       public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program program) {
           // Implementation
       }
   }
   ```

2. **Register in backend**:

   ```java
   // In GhidrAssistMCPBackend constructor
   registerTool(new MyCustomTool());
   ```

### Build Commands

```bash
# Clean build
gradle clean

# Build extension zip (written to dist/)
gradle buildExtension

# Install (extract) extension into the Ghidra user Extensions directory
gradle installExtension

# Uninstall (delete extracted directory from the Ghidra user Extensions directory)
gradle uninstallExtension

# Build/install with specific Ghidra path (required if GHIDRA_INSTALL_DIR isn't set)
gradle -PGHIDRA_INSTALL_DIR=/path/to/ghidra installExtension

# Debug build
gradle buildExtension --debug
```

### Dependencies

- **MCP SDK**: `io.modelcontextprotocol.sdk:mcp:0.17.1`
- **Jetty Server**: `11.0.20` (HTTP/SSE transport)
- **Jackson**: `2.18.3` (JSON processing)
- **Ghidra API**: Bundled with Ghidra installation

## Logging

### UI Logging

The **Log** tab provides real-time monitoring:

- **Session Events**: Server start/stop, program changes
- **Tool Requests**: `REQ: tool_name {parameters...}`
- **Tool Responses**: `RES: tool_name {response...}`
- **Error Messages**: Failed operations and diagnostics
- **Cache Hits**: When cached results are returned

### Console Logging

Detailed logging in Ghidra's console:

- Tool registration and initialization
- MCP server lifecycle events
- Async task execution and completion
- Cache statistics
- Database transaction operations
- Error stack traces and debugging information

## Troubleshooting

### Common Issues

#### Server Won't Start

- Check if port 8080 is available
- Verify Ghidra installation path
- Examine console logs for errors

#### Tools Not Appearing

- Ensure plugin is enabled
- Check Configuration tab for tool status
- Verify backend initialization in logs

#### MCP Client Connection Issues

- Confirm server is running (check GhidrAssistMCP window)
- Test connection: `curl http://localhost:8080/sse`
- Check firewall settings

#### Tool Execution Failures

- Verify program is loaded in Ghidra
- Check tool parameters are correct
- Review error messages in Log tab

#### Async Task Issues

- Use `get_task_status` to check task state
- Use `list_tasks` to see all tasks
- Use `cancel_task` if a task is stuck

### Debug Mode

Enable debug logging by adding to Ghidra startup:

```bash
-Dlog4j.logger.ghidrassistmcp=DEBUG
```

## Contributing

1. **Fork the repository**
2. **Create a feature branch**: `git checkout -b feature-name`
3. **Make your changes** with proper tests
4. **Follow code style**: Use existing patterns and conventions
5. **Submit a pull request** with detailed description

### Code Standards

- **Java 21+ features** where appropriate
- **Proper exception handling** with meaningful messages
- **Transaction safety** for all database operations
- **Thread safety** for UI operations
- **Comprehensive documentation** for public APIs
- **Action-based consolidation** for related tool operations

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- **NSA/Ghidra Team** for the excellent reverse engineering platform
- **Anthropic** for the Model Context Protocol specification

---

**Questions or Issues?**

Please open an issue on the project repository for bug reports, feature requests, or questions about usage and development.

```

`build.gradle`:

```gradle
/* 
 *
 */
// Builds a Ghidra Extension for a given Ghidra installation.
//
// An absolute path to the Ghidra installation directory must be supplied either by setting the 
// GHIDRA_INSTALL_DIR environment variable or Gradle project property:
//
//     > export GHIDRA_INSTALL_DIR=<Absolute path to Ghidra> 
//     > gradle
//
//         or
//
//     > gradle -PGHIDRA_INSTALL_DIR=<Absolute path to Ghidra>
//
// Gradle should be invoked from the directory of the project to build.  Please see the
// application.gradle.version property in <GHIDRA_INSTALL_DIR>/Ghidra/application.properties
// for the correction version of Gradle to use for the Ghidra installation you specify.

//----------------------START "DO NOT MODIFY" SECTION------------------------------
def ghidraInstallDir

if (System.env.GHIDRA_INSTALL_DIR) {
	ghidraInstallDir = System.env.GHIDRA_INSTALL_DIR
}
else if (project.hasProperty("GHIDRA_INSTALL_DIR")) {
	ghidraInstallDir = project.getProperty("GHIDRA_INSTALL_DIR")
}
else {
	ghidraInstallDir = "<REPLACE>"
}

task distributeExtension {
	group = "Ghidra"

	apply from: new File(ghidraInstallDir).getCanonicalPath() + "/support/buildExtension.gradle"
	dependsOn ':buildExtension'
}
//----------------------END "DO NOT MODIFY" SECTION-------------------------------

repositories {
	mavenCentral()
}

dependencies {
	// MCP SDK core dependency
	implementation 'io.modelcontextprotocol.sdk:mcp:0.17.1'
	
	// Jetty embedded server for servlet container
	implementation 'org.eclipse.jetty:jetty-server:11.0.20'
	implementation 'org.eclipse.jetty:jetty-servlet:11.0.20'
	
	// Jackson for JSON processing (required by MCP)
	implementation 'com.fasterxml.jackson.core:jackson-databind:2.18.3'
	implementation 'com.fasterxml.jackson.core:jackson-core:2.18.3'
	implementation 'com.fasterxml.jackson.core:jackson-annotations:2.18.3'
}

// Exclude additional files from the built extension
// Ex: buildExtension.exclude '.idea/**'

/**
 * Convenience tasks for local development:
 * - `gradle buildExtension` creates the extension zip in `dist/`
 * - `gradle installExtension` unzips that extension into your Ghidra *user* Extensions folder
 *
 * This mirrors the Ghidra UI "Install Extensions" flow, which ultimately extracts into:
 * - Windows: %APPDATA%\ghidra\ghidra_<version>_<release>\Extensions\<ExtensionName>
 * - Linux: ~/.config/ghidra/ghidra_<version>_<release>/Extensions/<ExtensionName>
 * - macOS: ~/Library/ghidra/ghidra_<version>_<release>/Extensions/<ExtensionName>
 *
 * You can override the destination Extensions folder via:
 * - Gradle property: -PGHIDRA_USER_EXTENSIONS_DIR="C:\path\to\... \Extensions"
 * - Env var: GHIDRA_USER_EXTENSIONS_DIR
 */
def extensionName = project.name

def ghidraUserExtensionsDir = {
	def overrideProp = project.findProperty("GHIDRA_USER_EXTENSIONS_DIR")
	if (overrideProp) {
		return file(overrideProp.toString())
	}
	def overrideEnv = System.getenv("GHIDRA_USER_EXTENSIONS_DIR")
	if (overrideEnv) {
		return file(overrideEnv)
	}

	def osName = (System.getProperty("os.name") ?: "").toLowerCase(Locale.ROOT)
	def ghidraUserProfileDirName = "${DISTRO_PREFIX}_${RELEASE_NAME}"

	if (osName.contains("windows")) {
		def appData = System.getenv("APPDATA")
		if (appData) {
			return file("${appData}/ghidra/${ghidraUserProfileDirName}/Extensions")
		}
	}

	if (osName.contains("mac") || osName.contains("darwin")) {
		return file("${System.getProperty('user.home')}/Library/ghidra/${ghidraUserProfileDirName}/Extensions")
	}

	def xdgConfigHome = System.getenv("XDG_CONFIG_HOME")
	def linuxConfigDir = xdgConfigHome ?: "${System.getProperty('user.home')}/.config"
	return file("${linuxConfigDir}/ghidra/${ghidraUserProfileDirName}/Extensions")
}.call()

/**
 * Where to copy the built extension zip for a given Ghidra install.
 *
 * Default:
 *   <GHIDRA_INSTALL_DIR>/Extensions/Ghidra
 *
 * Override via:
 *   - Gradle property: -PGHIDRA_EXTENSIONS_DROP_DIR="D:\path\to\Extensions\Ghidra"
 *   - Env var: GHIDRA_EXTENSIONS_DROP_DIR
 */
def ghidraInstallExtensionsZipDir = {
	def overrideProp = project.findProperty("GHIDRA_EXTENSIONS_DROP_DIR")
	if (overrideProp) {
		return file(overrideProp.toString())
	}
	def overrideEnv = System.getenv("GHIDRA_EXTENSIONS_DROP_DIR")
	if (overrideEnv) {
		return file(overrideEnv)
	}
	return file("${ghidraInstallDir}/Extensions/Ghidra")
}.call()

def buildZipProvider = tasks.named('buildExtension', Zip).flatMap { it.archiveFile }

def extensionZipGlob = "*_${extensionName}.zip"
def installZipDropFileTree = fileTree(ghidraInstallExtensionsZipDir) { include extensionZipGlob }

tasks.register('cleanExtractedExtension', Delete) {
	group = "Ghidra"
	description = "Delete the extracted extension from Ghidra's user Extensions folder"
	delete new File(ghidraUserExtensionsDir, extensionName)
}

tasks.register('cleanCopiedExtensionZips', Delete) {
	group = "Ghidra"
	description = "Delete copied extension zip(s) from the Ghidra install Extensions/Ghidra folder"
	delete installZipDropFileTree
}

tasks.register('copyExtensionZip', Copy) {
	group = "Ghidra"
	description = "Copy the built extension zip into the Ghidra install Extensions/Ghidra folder"

	dependsOn tasks.named('buildExtension'), tasks.named('cleanCopiedExtensionZips')

	from(buildZipProvider)
	into ghidraInstallExtensionsZipDir
}

tasks.register('extractExtension', Copy) {
	group = "Ghidra"
	description = "Extract the built extension into Ghidra's user Extensions folder"

	dependsOn tasks.named('buildExtension'), tasks.named('cleanExtractedExtension')

	from {
		zipTree(buildZipProvider.get().asFile)
	}
	into ghidraUserExtensionsDir
}

tasks.register('installExtension') {
	group = "Ghidra"
	description = "Copy the zip to the Ghidra install and extract into the user Extensions folder"
	dependsOn tasks.named('copyExtensionZip'), tasks.named('extractExtension')
}

tasks.register('uninstallExtension') {
	group = "Ghidra"
	description = "Delete the extracted extension and remove copied extension zip(s)"
	dependsOn tasks.named('cleanExtractedExtension'), tasks.named('cleanCopiedExtensionZips')
}

```

`extension.properties`:

```properties
name=@extname@
description=GhidrAssistMCP - MCP (Model Context Protocol) server for Ghidra analysis capabilities
author=
createdOn=
version=@extversion@

```

`src/main/help/help/TOC_Source.xml`:

```xml
<?xml version='1.0' encoding='ISO-8859-1' ?>
<!-- 

	This is an XML file intended to be parsed by the Ghidra help system.  It is loosely based 
	upon the JavaHelp table of contents document format.  The Ghidra help system uses a 
	TOC_Source.xml file to allow a module with help to define how its contents appear in the 
	Ghidra help viewer's table of contents.  The main document (in the Base module) 
	defines a basic structure for the 
	Ghidra table of contents system.  Other TOC_Source.xml files may use this structure to insert
	their files directly into this structure (and optionally define a substructure).
	
	
	In this document, a tag can be either a <tocdef> or a <tocref>.  The former is a definition
	of an XML item that may have a link and may contain other <tocdef> and <tocref> children.  
	<tocdef> items may be referred to in other documents by using a <tocref> tag with the 
	appropriate id attribute value.  Using these two tags allows any module to define a place 
	in the table of contents system (<tocdef>), which also provides a place for 
	other TOC_Source.xml files to insert content (<tocref>).  
	
	During the help build time, all TOC_Source.xml files will be parsed and	validated to ensure
	that all <tocref> tags point to valid <tocdef> tags.  From these files will be generated
	<module name>_TOC.xml files, which are table of contents files written in the format 
	desired by the JavaHelp system.   Additionally, the genated files will be merged together
	as they are loaded by the JavaHelp system.  In the end, when displaying help in the Ghidra
	help GUI, there will be on table of contents that has been created from the definitions in 
	all of the modules' TOC_Source.xml files.

	
	Tags and Attributes
	
	<tocdef>
	-id          - the name of the definition (this must be unique across all TOC_Source.xml files)	
	-text        - the display text of the node, as seen in the help GUI
	-target**    - the file to display when the node is clicked in the GUI
	-sortgroup   - this is a string that defines where a given node should appear under a given
	               parent.  The string values will be sorted by the JavaHelp system using
	               a javax.text.RulesBasedCollator.  If this attribute is not specified, then
	               the text of attribute will be used.

	<tocref>
	-id			 - The id of the <tocdef> that this reference points to 
	
	**The URL for the target is relative and should start with 'help/topics'.  This text is 
	used by the Ghidra help system to provide a universal starting point for all links so that
	they can be resolved at runtime, across modules.
	
	
-->


<tocroot>
	<!-- Uncomment and adjust fields to add help topic to help system's Table of Contents
	<tocref id="Ghidra Functionality">
		<tocdef id="HelpAnchor" text="My Feature" target="help/topics/my_topic/help.html" />
	</tocref>
	-->
</tocroot>

```

`src/main/help/help/topics/ghidramcp/help.html`:

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>
  <HEAD>
    <META name="generator" content=
    "HTML Tidy for Java (vers. 2009-12-01), see jtidy.sourceforge.net">
    <META http-equiv="Content-Language" content="en-us">
    <META http-equiv="Content-Type" content="text/html; charset=windows-1252">
    <META name="GENERATOR" content="Microsoft FrontPage 4.0">
    <META name="ProgId" content="FrontPage.Editor.Document">

    <TITLE>Skeleton Help File for a Module</TITLE>
    <LINK rel="stylesheet" type="text/css" href="help/shared/DefaultStyle.css">
  </HEAD>

  <BODY>
    <H1><a name="HelpAnchor"></a>Skeleton Help File for a Module</H1>

    <P>This is a simple skeleton help topic. For a better description of what should and should not
    go in here, see the "sample" Ghidra extension in the Extensions/Ghidra directory, or see your 
    favorite help topic. In general, language modules do not have their own help topics.</P>
  </BODY>
</HTML>

```

`src/main/java/ghidrassistmcp/GhidrAssistMCPBackend.java`:

```java
/* 
 * 
 */
package ghidrassistmcp;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import ghidrassistmcp.cache.McpCache;
import ghidrassistmcp.prompts.AnalyzeFunctionPrompt;
import ghidrassistmcp.prompts.DocumentFunctionPrompt;
import ghidrassistmcp.prompts.IdentifyVulnerabilityPrompt;
import ghidrassistmcp.prompts.McpPrompt;
import ghidrassistmcp.prompts.McpPromptRegistry;
import ghidrassistmcp.prompts.TraceDataFlowPrompt;
import ghidrassistmcp.prompts.TraceNetworkDataPrompt;
import ghidrassistmcp.resources.ExportsResource;
import ghidrassistmcp.resources.FunctionListResource;
import ghidrassistmcp.resources.ImportsResource;
import ghidrassistmcp.resources.McpResource;
import ghidrassistmcp.resources.McpResourceRegistry;
import ghidrassistmcp.resources.ProgramInfoResource;
import ghidrassistmcp.resources.StringsResource;
import ghidrassistmcp.tasks.McpTask;
import ghidrassistmcp.tasks.McpTaskManager;
import ghidrassistmcp.tools.BookmarksTool;
import ghidrassistmcp.tools.CancelTaskTool;
import ghidrassistmcp.tools.ClassTool;
import ghidrassistmcp.tools.DeleteDataTypeTool;
import ghidrassistmcp.tools.GetBasicBlocksTool;
import ghidrassistmcp.tools.GetCallGraphTool;
import ghidrassistmcp.tools.GetCodeTool;
import ghidrassistmcp.tools.GetCurrentAddressTool;
import ghidrassistmcp.tools.GetCurrentFunctionTool;
import ghidrassistmcp.tools.GetDataTypeTool;
import ghidrassistmcp.tools.GetFunctionInfoTool;
import ghidrassistmcp.tools.GetHexdumpTool;
import ghidrassistmcp.tools.GetTaskStatusTool;
import ghidrassistmcp.tools.ListDataTool;
import ghidrassistmcp.tools.ListDataTypesTool;
import ghidrassistmcp.tools.ListExportsTool;
import ghidrassistmcp.tools.ListProgramsTool;
import ghidrassistmcp.tools.ListFunctionsTool;
import ghidrassistmcp.tools.ListImportsTool;
import ghidrassistmcp.tools.ListNamespacesTool;
import ghidrassistmcp.tools.ListRelocationsTool;
import ghidrassistmcp.tools.ListSegmentsTool;
import ghidrassistmcp.tools.ListStringsTool;
import ghidrassistmcp.tools.ListTasksTool;
import ghidrassistmcp.tools.ProgramInfoTool;
import ghidrassistmcp.tools.RenameSymbolBatchTool;
import ghidrassistmcp.tools.RenameSymbolTool;
import ghidrassistmcp.tools.SearchBytesTool;
import ghidrassistmcp.tools.SetCommentTool;
import ghidrassistmcp.tools.SetDataTypeTool;
import ghidrassistmcp.tools.SetFunctionPrototypeTool;
import ghidrassistmcp.tools.SetLocalVariableTypeTool;
import ghidrassistmcp.tools.StructTool;
import ghidrassistmcp.tools.XrefsTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * Implementation of the MCP backend that manages tools and program state.
 * Works with the singleton GhidrAssistMCPManager to support multiple CodeBrowser windows.
 */
public class GhidrAssistMCPBackend implements McpBackend {

    private final Map<String, McpTool> tools = new ConcurrentHashMap<>();
    private final Map<String, Boolean> toolEnabledStates = new ConcurrentHashMap<>();
    private final List<McpEventListener> eventListeners = new CopyOnWriteArrayList<>();
    private volatile GhidrAssistMCPManager manager;
    private volatile boolean asyncExecutionEnabled = true;
    private final McpTaskManager taskManager;
    private final McpResourceRegistry resourceRegistry;
    private final McpPromptRegistry promptRegistry;
    private final McpCache cache;
    
    public GhidrAssistMCPBackend() {
        // Initialize task manager for async operations
        this.taskManager = new McpTaskManager();

        // Initialize resource registry
        this.resourceRegistry = new McpResourceRegistry();
        registerBuiltinResources();

        // Initialize prompt registry
        this.promptRegistry = new McpPromptRegistry();
        registerBuiltinPrompts();

        // Initialize result cache
        this.cache = new McpCache();

        // Register built-in tools
        registerTool(new ProgramInfoTool());
        registerTool(new ListFunctionsTool());
        registerTool(new GetFunctionInfoTool());
        registerTool(new ListSegmentsTool());
        registerTool(new ListImportsTool());
        registerTool(new ListExportsTool());
        registerTool(new ListStringsTool());
        registerTool(new GetCurrentAddressTool());
        registerTool(new GetHexdumpTool());
        registerTool(new GetCurrentFunctionTool());
        registerTool(new GetDataTypeTool());
        registerTool(new DeleteDataTypeTool());
        registerTool(new ListDataTool());
        registerTool(new ListDataTypesTool());
        registerTool(new ListNamespacesTool());
        registerTool(new ListProgramsTool());
        registerTool(new ClassTool());
        registerTool(new SetFunctionPrototypeTool());
        registerTool(new SetLocalVariableTypeTool());
        registerTool(new SetDataTypeTool());

        // Register async task management tools
        registerTool(new GetTaskStatusTool());
        registerTool(new CancelTaskTool());
        registerTool(new ListTasksTool());

        // Register consolidated and advanced tools
        registerTool(new GetCodeTool());
        registerTool(new SetCommentTool());
        registerTool(new RenameSymbolTool());
        registerTool(new RenameSymbolBatchTool());
        registerTool(new XrefsTool());
        registerTool(new StructTool());
        registerTool(new GetCallGraphTool());
        registerTool(new SearchBytesTool());
        registerTool(new BookmarksTool());
        registerTool(new GetBasicBlocksTool());
        registerTool(new ListRelocationsTool());

        Msg.info(this, "GhidrAssistMCP Backend initialized with " + tools.size() + " tools");
    }
    
    @Override
    public void registerTool(McpTool tool) {
        tools.put(tool.getName(), tool);
        // Tools are enabled by default when registered
        toolEnabledStates.put(tool.getName(), true);
        Msg.info(this, "Registered MCP tool: " + tool.getName());
    }
    
    @Override
    public void unregisterTool(String toolName) {
        McpTool removed = tools.remove(toolName);
        toolEnabledStates.remove(toolName);
        if (removed != null) {
            Msg.info(this, "Unregistered MCP tool: " + toolName);
        }
    }
    
    @Override
    public List<McpSchema.Tool> getAvailableTools() {
        List<McpSchema.Tool> toolList = new ArrayList<>();
        for (McpTool tool : tools.values()) {
            // Only include enabled tools in the available tools list
            if (toolEnabledStates.getOrDefault(tool.getName(), true)) {
                // Augment the schema with program_name parameter for multi-program support
                McpSchema.JsonSchema augmentedSchema = augmentSchemaWithProgramName(tool.getInputSchema());

                // Build tool annotations based on McpTool interface methods
                McpSchema.ToolAnnotations annotations = new McpSchema.ToolAnnotations(
                    null,  // title - will use tool name
                    tool.isReadOnly(),
                    tool.isDestructive(),
                    tool.isIdempotent(),
                    tool.isOpenWorld(),
                    null   // returnDirect
                );

                toolList.add(McpSchema.Tool.builder()
                    .name(tool.getName())
                    .title(tool.getName())
                    .description(tool.getDescription())
                    .inputSchema(augmentedSchema)
                    .annotations(annotations)
                    .build());
            }
        }
        // Sort tools alphabetically by name for consistent ordering
        toolList.sort((a, b) -> a.name().compareToIgnoreCase(b.name()));
        return toolList;
    }

    /**
     * Augment a tool's input schema with the universal 'program_name' parameter.
     * This allows all tools to optionally target a specific open program.
     */
    private McpSchema.JsonSchema augmentSchemaWithProgramName(McpSchema.JsonSchema originalSchema) {
        // Create the program_name property schema
        Map<String, Object> programNameSchema = new HashMap<>();
        programNameSchema.put("type", "string");
        programNameSchema.put("description", "Optional: Name of the program/binary to operate on. " +
            "Use list_programs to see available programs. " +
            "If not specified, uses the currently active program.");

        if (originalSchema == null) {
            // Create a schema with just program_name
            Map<String, Object> props = new HashMap<>();
            props.put("program_name", programNameSchema);
            return new McpSchema.JsonSchema("object", props, List.of(), null, null, null);
        }

        // Get original properties or empty map
        Map<String, Object> originalProps = originalSchema.properties();
        Map<String, Object> newProps;

        if (originalProps != null) {
            newProps = new HashMap<>(originalProps);
        } else {
            newProps = new HashMap<>();
        }

        // Add program_name parameter
        newProps.put("program_name", programNameSchema);

        // Return new schema with augmented properties
        return new McpSchema.JsonSchema(
            originalSchema.type(),
            newProps,
            originalSchema.required(),
            originalSchema.additionalProperties(),
            originalSchema.defs(),
            originalSchema.definitions()
        );
    }
    
    @Override
    public McpSchema.CallToolResult callTool(String toolName, Map<String, Object> arguments) {
        McpTool tool = tools.get(toolName);
        if (tool == null) {
            Msg.warn(this, "Tool not found: " + toolName);
            return McpSchema.CallToolResult.builder()
                .addTextContent("Tool not found: " + toolName)
                .build();
        }

        // Check if tool is enabled
        if (!toolEnabledStates.getOrDefault(toolName, true)) {
            Msg.warn(this, "Tool is disabled: " + toolName);
            return McpSchema.CallToolResult.builder()
                .addTextContent("Tool is disabled: " + toolName)
                .build();
        }

        try {
            // Notify listeners of the request
            notifyToolRequest(toolName, arguments);

            Msg.info(this, "Executing tool: " + toolName);

            // Resolve the target program - check if program_name is specified
            Program targetProgram = resolveTargetProgram(arguments);

            // Check cache for cacheable tools
            if (tool.isCacheable() && targetProgram != null) {
                String cacheKey = cache.generateKey(toolName, arguments, targetProgram.getName());
                McpSchema.CallToolResult cachedResult = cache.get(cacheKey, targetProgram);
                if (cachedResult != null) {
                    Msg.info(this, "Cache hit for tool: " + toolName);
                    notifyToolResponse(toolName, cachedResult);
                    return cachedResult;
                }
            }

            // Check if this is a long-running tool that should be executed asynchronously
            if (tool.isLongRunning() && asyncExecutionEnabled) {
                return executeToolAsync(tool, toolName, arguments, targetProgram);
            }

            // Execute synchronously for normal tools
            McpSchema.CallToolResult result = tool.execute(arguments, targetProgram, this);

            // Add active context information to help LLM understand which binary is in focus
            result = addActiveContextToResult(result, targetProgram);

            // Cache the result if tool is cacheable
            if (tool.isCacheable() && targetProgram != null) {
                String cacheKey = cache.generateKey(toolName, arguments, targetProgram.getName());
                cache.put(cacheKey, result, targetProgram);
                Msg.debug(this, "Cached result for tool: " + toolName);
            }

            // Notify listeners of the response
            notifyToolResponse(toolName, result);

            return result;
        } catch (Exception e) {
            Msg.error(this, "Error executing tool " + toolName, e);
            McpSchema.CallToolResult errorResult = McpSchema.CallToolResult.builder()
                .addTextContent("Error executing tool " + toolName + ": " + e.getMessage())
                .build();

            // Notify listeners of the error response
            notifyToolResponse(toolName, errorResult);

            return errorResult;
        }
    }

    /**
     * Execute a long-running tool asynchronously and return a task ID.
     */
    private McpSchema.CallToolResult executeToolAsync(McpTool tool, String toolName,
                                                       Map<String, Object> arguments, Program targetProgram) {
        // Create a reference to this backend for the async execution
        final GhidrAssistMCPBackend backend = this;

        McpTask task = taskManager.submitTask(toolName, arguments, () -> {
            try {
                McpSchema.CallToolResult result = tool.execute(arguments, targetProgram, backend);
                result = addActiveContextToResult(result, targetProgram);
                notifyToolResponse(toolName, result);
                return result;
            } catch (Exception e) {
                Msg.error(this, "Async tool execution failed: " + toolName, e);
                throw new RuntimeException(e);
            }
        });

        // Return task information immediately
        return McpSchema.CallToolResult.builder()
            .addTextContent("Task submitted for async execution.\n\n" +
                "Task ID: " + task.getTaskId() + "\n" +
                "Tool: " + toolName + "\n" +
                "Status: " + task.getStatus() + "\n\n" +
                "Use get_task_status with this task_id to check progress and retrieve results.\n" +
                "Use cancel_task to cancel if needed.")
            .build();
    }

    /**
     * Get the task manager for async operations.
     */
    public McpTaskManager getTaskManager() {
        return taskManager;
    }

    /**
     * Get the resource registry.
     */
    public McpResourceRegistry getResourceRegistry() {
        return resourceRegistry;
    }

    /**
     * Register built-in MCP resources.
     */
    private void registerBuiltinResources() {
        resourceRegistry.registerResource(new ProgramInfoResource());
        resourceRegistry.registerResource(new FunctionListResource());
        resourceRegistry.registerResource(new StringsResource());
        resourceRegistry.registerResource(new ImportsResource());
        resourceRegistry.registerResource(new ExportsResource());
        Msg.info(this, "Registered " + resourceRegistry.getResourceCount() + " MCP resources");
    }

    /**
     * Register built-in MCP prompts.
     */
    private void registerBuiltinPrompts() {
        promptRegistry.registerPrompt(new AnalyzeFunctionPrompt());
        promptRegistry.registerPrompt(new IdentifyVulnerabilityPrompt());
        promptRegistry.registerPrompt(new DocumentFunctionPrompt());
        promptRegistry.registerPrompt(new TraceDataFlowPrompt());
        promptRegistry.registerPrompt(new TraceNetworkDataPrompt());
        Msg.info(this, "Registered " + promptRegistry.getPromptCount() + " MCP prompts");
    }

    /**
     * Get the prompt registry.
     */
    public McpPromptRegistry getPromptRegistry() {
        return promptRegistry;
    }

    /**
     * Get available prompts for the MCP SDK.
     */
    public List<McpPrompt> getAvailablePrompts() {
        return promptRegistry.getAllPrompts();
    }

    /**
     * Get the result cache.
     */
    public McpCache getCache() {
        return cache;
    }

    /**
     * Get cache statistics summary.
     */
    public String getCacheStats() {
        return cache.getStats();
    }

    /**
     * Clear the cache (e.g., when program is significantly modified).
     */
    public void clearCache() {
        cache.clear();
    }

    /**
     * Read a resource by URI.
     *
     * @param uri The resource URI
     * @return The resource content
     */
    public String readResource(String uri) {
        Program program = getCurrentProgram();
        return resourceRegistry.readResource(uri, program);
    }

    /**
     * Get available resources for the MCP SDK.
     */
    public List<McpResource> getAvailableResources() {
        return resourceRegistry.getAllResources();
    }

    @Override
    public void onProgramActivated(Program program) {
        // Program activation is now handled dynamically - no caching needed
        if (program != null) {
            Msg.info(this, "Program activated: " + program.getName());
            // Notify listeners for logging purposes
            notifySessionEvent("Program activated: " + program.getName());
        }
    }

    @Override
    public void onProgramDeactivated(Program program) {
        // Program deactivation is now handled dynamically - no state clearing needed
        if (program != null) {
            Msg.info(this, "Program deactivated: " + program.getName());
        }
    }
    
    @Override
    public McpSchema.Implementation getServerInfo() {
        return new McpSchema.Implementation("ghidrassistmcp", "1.0.0");
    }
    
    @Override
    public McpSchema.ServerCapabilities getCapabilities() {
        return McpSchema.ServerCapabilities.builder()
            .tools(true)
            .resources(false, false)  // subscribe=false, listChanged=false
            .prompts(false)           // listChanged=false
            .build();
    }
    
    /**
     * Resolve the target program based on arguments.
     * If 'program_name' is specified, look up that program across ALL open tools.
     * Otherwise, return the currently active program.
     *
     * @param arguments The tool arguments that may contain 'program_name'
     * @return The resolved program to operate on
     */
    private Program resolveTargetProgram(Map<String, Object> arguments) {
        if (manager == null) {
            return null;
        }

        // Check if a specific program was requested
        Object programNameObj = arguments.get("program_name");
        if (programNameObj instanceof String) {
            String programName = (String) programNameObj;
            if (!programName.trim().isEmpty()) {
                Program found = manager.getProgramByName(programName);
                if (found != null) {
                    Msg.info(this, "Resolved program by name: " + found.getName());
                    return found;
                }
                Msg.warn(this, "Program not found: " + programName + ", using current program");
            }
        }

        // Default to current program
        return manager.getCurrentProgram();
    }

    /**
     * Get the currently active program from the manager.
     * This queries ALL registered tools for the currently active program.
     */
    public Program getCurrentProgram() {
        if (manager != null) {
            return manager.getCurrentProgram();
        }
        return null;
    }

    /**
     * Get all open programs from ALL registered tools.
     */
    public List<Program> getAllOpenPrograms() {
        if (manager != null) {
            return manager.getAllOpenPrograms();
        }
        return new ArrayList<>();
    }
    
    /**
     * Add an event listener for MCP operations.
     */
    public void addEventListener(McpEventListener listener) {
        if (listener != null) {
            eventListeners.add(listener);
            Msg.info(this, "Added MCP event listener: " + listener.getClass().getSimpleName() + " (total listeners: " + eventListeners.size() + ")");
        }
    }
    
    /**
     * Remove an event listener.
     */
    public void removeEventListener(McpEventListener listener) {
        if (listener != null) {
            eventListeners.remove(listener);
            Msg.info(this, "Removed MCP event listener: " + listener.getClass().getSimpleName());
        }
    }
    
    /**
     * Set the manager reference for multi-tool program discovery.
     */
    public void setManager(GhidrAssistMCPManager manager) {
        this.manager = manager;
        Msg.info(this, "Manager reference set for multi-tool support");
    }

    /**
     * Get the currently active plugin instance for UI context access.
     * This allows tools to access current address, current function, etc.
     *
     * @return The active plugin instance, or null if none is active
     */
    public GhidrAssistMCPPlugin getActivePlugin() {
        if (manager != null) {
            return manager.getActivePlugin();
        }
        return null;
    }
    
    /**
     * Notify listeners of a tool request.
     */
    private void notifyToolRequest(String toolName, Map<String, Object> arguments) {
        String params = arguments != null ? arguments.toString() : "{}";
        if (params.length() > 60) {
            params = params.substring(0, 57) + "...";
        }
        
        Msg.info(this, "Notifying " + eventListeners.size() + " listeners of tool request: " + toolName);
        
        for (McpEventListener listener : eventListeners) {
            try {
                listener.onToolRequest(toolName, params);
            } catch (Exception e) {
                Msg.error(this, "Error notifying listener of tool request", e);
            }
        }
    }
    
    /**
     * Notify listeners of a tool response.
     */
    private void notifyToolResponse(String toolName, McpSchema.CallToolResult result) {
        String response = "Empty response";
        if (result != null && !result.content().isEmpty()) {
            var firstContent = result.content().get(0);
            if (firstContent instanceof McpSchema.TextContent) {
                response = ((McpSchema.TextContent) firstContent).text();
                if (response.length() > 60) {
                    response = response.substring(0, 57) + "...";
                }
            }
        }
        
        for (McpEventListener listener : eventListeners) {
            try {
                listener.onToolResponse(toolName, response);
            } catch (Exception e) {
                Msg.error(this, "Error notifying listener of tool response", e);
            }
        }
    }
    
    /**
     * Notify listeners of a session event.
     */
    private void notifySessionEvent(String event) {
        for (McpEventListener listener : eventListeners) {
            try {
                listener.onSessionEvent(event);
            } catch (Exception e) {
                Msg.error(this, "Error notifying listener of session event", e);
            }
        }
    }
    
    /**
     * Notify listeners of a general log message.
     */
    @SuppressWarnings("unused")
    private void notifyLogMessage(String message) {
        for (McpEventListener listener : eventListeners) {
            try {
                listener.onLogMessage(message);
            } catch (Exception e) {
                Msg.error(this, "Error notifying listener of log message", e);
            }
        }
    }
    
    /**
     * Add active context information to tool results to help LLM understand which binary is in focus.
     * This prepends context metadata to the first text content in the result.
     */
    private McpSchema.CallToolResult addActiveContextToResult(McpSchema.CallToolResult result, Program targetProgram) {
        if (result == null || result.content() == null || result.content().isEmpty()) {
            return result;
        }

        // Build context information
        StringBuilder contextInfo = new StringBuilder();

        // Get the current active program from manager
        Program activeProgram = getCurrentProgram();

        // Add context header
        contextInfo.append("[Context] ");

        if (targetProgram != null) {
            contextInfo.append("Operating on: ").append(targetProgram.getName());

            // If active program is different, mention it
            if (activeProgram != null && !activeProgram.equals(targetProgram)) {
                contextInfo.append(" | Active window: ").append(activeProgram.getName());
            }
        } else if (activeProgram != null) {
            contextInfo.append("Active window: ").append(activeProgram.getName());
        } else {
            contextInfo.append("No program currently active");
        }

        // Add available programs count if multiple are open
        if (manager != null) {
            List<Program> allPrograms = manager.getAllOpenPrograms();
            if (allPrograms.size() > 1) {
                contextInfo.append(" | Total open programs: ").append(allPrograms.size());
            }
        }

        contextInfo.append("\n\n");

        // Prepend context to the first text content
        var firstContent = result.content().get(0);
        if (firstContent instanceof McpSchema.TextContent) {
            String originalText = ((McpSchema.TextContent) firstContent).text();
            String enhancedText = contextInfo.toString() + originalText;

            // Build new result with enhanced content
            McpSchema.CallToolResult.Builder builder = McpSchema.CallToolResult.builder()
                .addTextContent(enhancedText);

            // Add remaining content items if any
            for (int i = 1; i < result.content().size(); i++) {
                var content = result.content().get(i);
                if (content instanceof McpSchema.TextContent) {
                    builder.addTextContent(((McpSchema.TextContent) content).text());
                }
            }

            return builder.build();
        }

        return result;
    }

    /**
     * Set whether async execution is enabled for long-running tools.
     */
    public void setAsyncExecutionEnabled(boolean enabled) {
        this.asyncExecutionEnabled = enabled;
        Msg.info(this, "Async tool execution " + (enabled ? "enabled" : "disabled"));
    }

    /**
     * Check whether async execution is enabled for long-running tools.
     */
    public boolean isAsyncExecutionEnabled() {
        return asyncExecutionEnabled;
    }

    /**
     * Set the enabled state of a tool.
     */
    public void setToolEnabled(String toolName, boolean enabled) {
        if (tools.containsKey(toolName)) {
            toolEnabledStates.put(toolName, enabled);
            Msg.info(this, "Tool " + toolName + " " + (enabled ? "enabled" : "disabled"));
        }
    }
    
    /**
     * Get the enabled state of a tool.
     */
    public boolean isToolEnabled(String toolName) {
        return toolEnabledStates.getOrDefault(toolName, true);
    }
    
    /**
     * Get all tool enabled states.
     */
    public Map<String, Boolean> getToolEnabledStates() {
        return new HashMap<>(toolEnabledStates);
    }
    
    /**
     * Update multiple tool enabled states at once.
     */
    public void updateToolEnabledStates(Map<String, Boolean> newStates) {
        for (Map.Entry<String, Boolean> entry : newStates.entrySet()) {
            String toolName = entry.getKey();
            if (tools.containsKey(toolName)) {
                toolEnabledStates.put(toolName, entry.getValue());
            }
        }
        Msg.info(this, "Updated enabled states for " + newStates.size() + " tools");
    }
    
    /**
     * Get all tools (including disabled ones) for configuration purposes.
     */
    public List<McpSchema.Tool> getAllTools() {
        List<McpSchema.Tool> toolList = new ArrayList<>();
        for (McpTool tool : tools.values()) {
            toolList.add(McpSchema.Tool.builder()
                .name(tool.getName())
                .title(tool.getName())
                .description(tool.getDescription())
                .inputSchema(tool.getInputSchema())
                .build());
        }
        // Sort tools alphabetically by name for consistent ordering
        toolList.sort((a, b) -> a.name().compareToIgnoreCase(b.name()));
        return toolList;
    }
}

```

`src/main/java/ghidrassistmcp/GhidrAssistMCPManager.java`:

```java
/*
 * Singleton manager for GhidrAssistMCP that coordinates multiple CodeBrowser windows.
 */
package ghidrassistmcp;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

import ghidra.app.services.ProgramManager;
import ghidra.framework.plugintool.PluginTool;
import ghidra.framework.preferences.Preferences;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;

/**
 * Singleton manager that coordinates the MCP server across multiple CodeBrowser windows.
 *
 * This solves the problem of multiple plugin instances each trying to start their own
 * MCP server. Instead, we have:
 * - One shared MCP backend that tracks ALL open programs across ALL tools
 * - One shared MCP server (on port 8080) that serves all requests
 * - Multiple plugin instances that register/unregister their tools
 */
public class GhidrAssistMCPManager {

    private static GhidrAssistMCPManager instance;
    private static final Object lock = new Object();

    private final GhidrAssistMCPBackend backend;
    private GhidrAssistMCPServer server;
    private GhidrAssistMCPProvider provider;

    // Track all registered plugin tools
    private final List<PluginTool> registeredTools = new CopyOnWriteArrayList<>();

    // Track the most recently active tool (for context awareness)
    private volatile PluginTool activeTool;

    // Track the most recently active plugin instance (for UI context)
    private volatile GhidrAssistMCPPlugin activePlugin;

    // Server configuration
    private String currentHost = "localhost";
    private int currentPort = 8080;
    private boolean serverEnabled = true;

    /**
     * Private constructor for singleton pattern.
     */
    private GhidrAssistMCPManager() {
        Msg.info(this, "Initializing GhidrAssistMCP Manager (singleton)");
        backend = new GhidrAssistMCPBackend();
        backend.setManager(this);
    }

    /**
     * Get the singleton instance of the manager.
     */
    public static GhidrAssistMCPManager getInstance() {
        if (instance == null) {
            synchronized (lock) {
                if (instance == null) {
                    instance = new GhidrAssistMCPManager();
                }
            }
        }
        return instance;
    }

    /**
     * Register a plugin's tool with the manager.
     * The first tool to register will start the MCP server.
     *
     * @param tool The PluginTool to register
     * @param pluginProvider The UI provider (only used from first registration)
     * @return true if this is the first registration (server owner)
     */
    public synchronized boolean registerTool(PluginTool tool, GhidrAssistMCPProvider pluginProvider) {
        if (tool == null) {
            Msg.warn(this, "Attempted to register null tool");
            return false;
        }

        if (registeredTools.contains(tool)) {
            Msg.info(this, "Tool already registered: " + tool.getName());
            return false;
        }

        registeredTools.add(tool);
        Msg.info(this, "Registered tool: " + tool.getName() + " (total: " + registeredTools.size() + ")");

        // First registration starts the server
        if (registeredTools.size() == 1) {
            this.provider = pluginProvider;

            // Load saved configuration from Ghidra options before starting server
            loadSettings(tool);

            if (provider != null) {
                backend.addEventListener(provider);
                provider.onBackendReady();
            }
            startServer();
            return true;
        }

        // Notify about new tool registration
        if (provider != null) {
            provider.logSession("New CodeBrowser registered: " + tool.getName());
        }

        return false;
    }

    /**
     * Unregister a plugin's tool from the manager.
     * When all tools are unregistered, the server is stopped.
     *
     * @param tool The PluginTool to unregister
     */
    public synchronized void unregisterTool(PluginTool tool) {
        if (tool == null) {
            return;
        }

        boolean removed = registeredTools.remove(tool);
        if (removed) {
            Msg.info(this, "Unregistered tool: " + tool.getName() + " (remaining: " + registeredTools.size() + ")");

            if (provider != null) {
                provider.logSession("CodeBrowser unregistered: " + tool.getName());
            }
        }

        // Stop server when all tools are unregistered
        if (registeredTools.isEmpty()) {
            Msg.info(this, "All tools unregistered, stopping server");
            stopServer();

            // Clean up singleton for potential restart
            synchronized (lock) {
                if (provider != null) {
                    backend.removeEventListener(provider);
                    provider = null;
                }
                instance = null;
            }
        }
    }

    /**
     * Get all programs from all registered tools.
     * This is the key method that enables multi-window support.
     */
    public List<Program> getAllOpenPrograms() {
        List<Program> allPrograms = new ArrayList<>();

        for (PluginTool tool : registeredTools) {
            ProgramManager pm = tool.getService(ProgramManager.class);
            if (pm != null) {
                Program[] programs = pm.getAllOpenPrograms();
                if (programs != null) {
                    for (Program p : programs) {
                        if (!allPrograms.contains(p)) {
                            allPrograms.add(p);
                        }
                    }
                }
            }
        }

        return allPrograms;
    }

    /**
     * Set the active tool (called when a CodeBrowser window gains focus).
     * This helps determine which program context to use for incoming requests.
     */
    public synchronized void setActiveTool(PluginTool tool) {
        if (registeredTools.contains(tool)) {
            activeTool = tool;
            Msg.info(this, "Active tool changed: " + tool.getName());

            if (provider != null) {
                ProgramManager pm = tool.getService(ProgramManager.class);
                if (pm != null) {
                    Program current = pm.getCurrentProgram();
                    if (current != null) {
                        provider.logSession("Active context: " + current.getName() + " (from " + tool.getName() + ")");
                    }
                }
            }
        }
    }

    /**
     * Get the currently active tool (most recently focused CodeBrowser).
     */
    public PluginTool getActiveTool() {
        return activeTool;
    }

    /**
     * Set the active plugin instance (called when a plugin gains focus).
     * This provides access to UI context like current address and function.
     */
    public synchronized void setActivePlugin(GhidrAssistMCPPlugin plugin) {
        this.activePlugin = plugin;
    }

    /**
     * Get the currently active plugin instance (for UI context access).
     */
    public GhidrAssistMCPPlugin getActivePlugin() {
        return activePlugin;
    }

    /**
     * Get the currently active program across all tools.
     * Prioritizes the program from the most recently focused tool.
     */
    public Program getCurrentProgram() {
        // First, try the active tool if one is set
        if (activeTool != null) {
            ProgramManager pm = activeTool.getService(ProgramManager.class);
            if (pm != null) {
                Program current = pm.getCurrentProgram();
                if (current != null) {
                    return current;
                }
            }
        }

        // Fall back to any tool's current program
        for (PluginTool tool : registeredTools) {
            ProgramManager pm = tool.getService(ProgramManager.class);
            if (pm != null) {
                Program current = pm.getCurrentProgram();
                if (current != null) {
                    return current;
                }
            }
        }
        return null;
    }

    /**
     * Find a program by name across all registered tools.
     */
    public Program getProgramByName(String programName) {
        if (programName == null || programName.trim().isEmpty()) {
            return getCurrentProgram();
        }

        List<Program> programs = getAllOpenPrograms();

        // Exact match
        for (Program p : programs) {
            if (p.getName().equals(programName)) {
                return p;
            }
        }

        // Case-insensitive match
        for (Program p : programs) {
            if (p.getName().equalsIgnoreCase(programName)) {
                return p;
            }
        }

        // Partial match
        for (Program p : programs) {
            if (p.getName().toLowerCase().contains(programName.toLowerCase())) {
                return p;
            }
        }

        return null;
    }

    /**
     * Get the shared backend instance.
     */
    public GhidrAssistMCPBackend getBackend() {
        return backend;
    }

    /**
     * Get the UI provider (if available).
     */
    public GhidrAssistMCPProvider getProvider() {
        return provider;
    }

    /**
     * Get the number of registered tools.
     */
    public int getRegisteredToolCount() {
        return registeredTools.size();
    }

    /**
     * Check if the server is running.
     */
    public boolean isServerRunning() {
        return server != null;
    }

    /**
     * Apply configuration changes.
     */
    public void applyConfiguration(String host, int port, boolean enabled, boolean asyncEnabled,
                                   java.util.Map<String, Boolean> toolStates) {
        if (provider != null) {
            provider.logMessage("Applying configuration: " + host + ":" + port + " enabled=" + enabled + " async=" + asyncEnabled);
        }

        boolean needsRestart = false;

        if (!host.equals(currentHost) || port != currentPort) {
            currentHost = host;
            currentPort = port;
            needsRestart = true;
        }

        if (enabled != serverEnabled) {
            serverEnabled = enabled;
            needsRestart = true;
        }

        // Update async execution setting
        if (backend != null) {
            backend.setAsyncExecutionEnabled(asyncEnabled);
        }

        // Update tool states
        if (backend != null && toolStates != null) {
            backend.updateToolEnabledStates(toolStates);
        }

        if (needsRestart) {
            stopServer();
            if (serverEnabled) {
                startServer();
            }
        }

        if (provider != null) {
            provider.refreshToolsList();
        }
    }

    /**
     * Get current configuration.
     */
    public String getCurrentHost() {
        return currentHost;
    }

    public int getCurrentPort() {
        return currentPort;
    }

    public boolean isServerEnabled() {
        return serverEnabled;
    }

    /**
     * Load settings from Ghidra's global Preferences.
     * Called when the first tool registers to ensure saved configuration is used.
     */
    private void loadSettings(PluginTool tool) {
        // Load from Ghidra's global Preferences
        currentHost = Preferences.getProperty("GhidrAssistMCP.Server Host", "localhost");
        String portStr = Preferences.getProperty("GhidrAssistMCP.Server Port", "8080");
        String enabledStr = Preferences.getProperty("GhidrAssistMCP.Server Enabled", "true");
        String asyncEnabledStr = Preferences.getProperty("GhidrAssistMCP.Async Execution Enabled", "true");

        try {
            currentPort = Integer.parseInt(portStr);
            serverEnabled = Boolean.parseBoolean(enabledStr);
        } catch (NumberFormatException e) {
            Msg.warn(this, "Failed to parse preferences, using defaults: " + e.getMessage());
            currentPort = 8080;
            serverEnabled = true;
        }

        boolean asyncEnabled = Boolean.parseBoolean(asyncEnabledStr);
        if (backend != null) {
            backend.setAsyncExecutionEnabled(asyncEnabled);
        }

        Msg.info(this, "Loaded settings from Ghidra preferences: " + currentHost + ":" + currentPort + " enabled=" + serverEnabled + " async=" + asyncEnabled);

        if (provider != null) {
            provider.logMessage("Loaded configuration: " + currentHost + ":" + currentPort + " enabled=" + serverEnabled + " async=" + asyncEnabled);
        }
    }

    /**
     * Start the MCP server.
     */
    private void startServer() {
        if (!serverEnabled) {
            if (provider != null) {
                provider.logSession("Server disabled - not starting");
            }
            return;
        }

        if (server != null) {
            Msg.info(this, "Server already running");
            return;
        }

        try {
            server = new GhidrAssistMCPServer(currentHost, currentPort, backend, provider);
            server.start();
            if (provider != null) {
                provider.logSession("Server started on " + currentHost + ":" + currentPort);
            }
            Msg.info(this, "MCP Server started on port " + currentPort);
        } catch (Exception e) {
            if (provider != null) {
                provider.logSession("Failed to start server: " + e.getMessage());
            }
            Msg.error(this, "Failed to start MCP Server", e);
            server = null;
        }
    }

    /**
     * Stop the MCP server.
     */
    private void stopServer() {
        if (server != null) {
            try {
                server.stop();
                if (provider != null) {
                    provider.logSession("Server stopped");
                }
                Msg.info(this, "MCP Server stopped");
            } catch (Exception e) {
                if (provider != null) {
                    provider.logSession("Error stopping server: " + e.getMessage());
                }
                Msg.error(this, "Failed to stop MCP Server", e);
            }
            server = null;
        }
    }
}

```

`src/main/java/ghidrassistmcp/GhidrAssistMCPPlugin.java`:

```java
/* 
 * 
 */
package ghidrassistmcp;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import ghidra.MiscellaneousPluginPackage;
import ghidra.app.plugin.PluginCategoryNames;
import ghidra.app.plugin.ProgramPlugin;
import ghidra.app.services.ProgramManager;
import ghidra.framework.plugintool.*;
import ghidra.framework.plugintool.util.PluginStatus;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.FunctionManager;
import ghidra.program.model.listing.Program;
import ghidra.program.util.ProgramLocation;
import ghidra.util.Msg;

/**
 * GhidrAssistMCP Plugin - Provides an MCP (Model Context Protocol) server for Ghidra analysis capabilities.
 * Features a configurable UI with tool management and request logging.
 */
@PluginInfo(
	status = PluginStatus.STABLE,
	packageName = MiscellaneousPluginPackage.NAME,
	category = PluginCategoryNames.COMMON,
	shortDescription = "MCP Server for Ghidra",
	description = "Provides a configurable MCP (Model Context Protocol) server for Ghidra analysis capabilities with tool management and logging."
)
public class GhidrAssistMCPPlugin extends ProgramPlugin {

	private GhidrAssistMCPProvider provider;
	private GhidrAssistMCPManager manager;
	private boolean isServerOwner = false;

	// Current UI location tracking
	private volatile ProgramLocation currentLocation1;

	/**
	 * Plugin constructor.
	 * 
	 * @param tool The plugin tool that this plugin is added to.
	 */
	public GhidrAssistMCPPlugin(PluginTool tool) {
		super(tool);
		
		// Create the UI provider but don't register it yet
		provider = new GhidrAssistMCPProvider(tool, this);
	}

	@Override
	public void init() {
		super.init();

		// Get the singleton manager
		manager = GhidrAssistMCPManager.getInstance();

		// Register the UI provider with the tool first
		if (provider != null) {
			try {
				tool.addComponentProvider(provider, true);
				Msg.info(this, "Successfully registered UI provider");
			} catch (IllegalArgumentException e) {
				if (e.getMessage() != null && e.getMessage().contains("was already added")) {
					Msg.info(this, "UI provider already registered, continuing");
				} else {
					Msg.error(this, "Failed to register UI provider (non-fatal): " + e.getMessage());
				}
			} catch (Exception e) {
				Msg.error(this, "Failed to register UI provider (non-fatal): " + e.getMessage());
			}
		}

		// Register this tool with the singleton manager
		// The first tool to register becomes the server owner and gets its provider used
		isServerOwner = manager.registerTool(tool, provider);

		if (isServerOwner) {
			Msg.info(this, "This plugin instance is the MCP server owner");
		} else {
			Msg.info(this, "This plugin instance registered with existing MCP server");
		}

		if (provider != null) {
			provider.logSession("Plugin initialized" + (isServerOwner ? " (server owner)" : ""));
		}
	}
	
	/**
	 * Apply new configuration from the UI.
	 * Delegates to the singleton manager which handles server restart if needed.
	 */
	public void applyConfiguration(String host, int port, boolean enabled, boolean asyncEnabled, Map<String, Boolean> toolStates) {
		if (manager != null) {
			manager.applyConfiguration(host, port, enabled, asyncEnabled, toolStates);
		}
	}
	
	@Override
	protected void programActivated(Program program) {
		super.programActivated(program);

		// Notify manager that this tool is now active (focus tracking)
		if (manager != null) {
			manager.setActiveTool(tool);
		}

		GhidrAssistMCPBackend backend = getBackend();
		if (backend != null) {
			backend.onProgramActivated(program);
		}
		if (provider != null && program != null) {
			provider.logSession("Program activated: " + program.getName());
		}
	}
	
	@Override
	protected void locationChanged(ProgramLocation loc) {
		super.locationChanged(loc);
		this.currentLocation1 = loc;

		// Set this as the active plugin for UI context access
		if (manager != null) {
			manager.setActivePlugin(this);
		}

		if (provider != null && loc != null) {
			provider.logMessage("Location changed to: " + loc.getAddress());
		}
	}
	
	@Override
	protected void programDeactivated(Program program) {
		super.programDeactivated(program);
		GhidrAssistMCPBackend backend = getBackend();
		if (backend != null) {
			backend.onProgramDeactivated(program);
		}
		if (provider != null) {
			provider.logSession("Program deactivated: " + (program != null ? program.getName() : "null"));
		}
	}
	
	@Override
	protected void dispose() {
		if (provider != null) {
			provider.logSession("Plugin disposing");

			try {
				tool.removeComponentProvider(provider);
			} catch (Exception e) {
				Msg.error(this, "Error removing UI provider", e);
			}
			provider = null;
		}

		// Unregister this tool from the singleton manager
		// The manager will stop the server when all tools are unregistered
		if (manager != null) {
			manager.unregisterTool(tool);
		}

		super.dispose();
	}
	
	/**
	 * Get the MCP backend for tool management.
	 * Returns the shared backend from the singleton manager.
	 */
	public GhidrAssistMCPBackend getBackend() {
		return manager != null ? manager.getBackend() : null;
	}

	/**
	 * Get the singleton manager.
	 */
	public GhidrAssistMCPManager getManager() {
		return manager;
	}

	/**
	 * Get the current server configuration.
	 * Returns configuration from the singleton manager.
	 */
	public String getCurrentHost() {
		return manager != null ? manager.getCurrentHost() : "localhost";
	}

	public int getCurrentPort() {
		return manager != null ? manager.getCurrentPort() : 8080;
	}

	public boolean isServerEnabled() {
		return manager != null ? manager.isServerEnabled() : false;
	}
	
	/**
	 * Get the current program using ProgramManager service for accurate tracking.
	 * This method properly handles multi-program scenarios.
	 */
	@Override
	public Program getCurrentProgram() {
		ProgramManager pm = tool.getService(ProgramManager.class);
		if (pm != null) {
			Program current = pm.getCurrentProgram();
			if (current != null) {
				return current;
			}
		}
		// Fall back to parent implementation
		return super.getCurrentProgram();
	}

	/**
	 * Get all open programs in the current tool.
	 * This allows tools to list and select from multiple open programs.
	 */
	public List<Program> getAllOpenPrograms() {
		List<Program> programs = new ArrayList<>();
		ProgramManager pm = tool.getService(ProgramManager.class);
		if (pm != null) {
			Program[] openPrograms = pm.getAllOpenPrograms();
			if (openPrograms != null) {
				for (Program p : openPrograms) {
					programs.add(p);
				}
			}
		}
		return programs;
	}

	/**
	 * Find an open program by name.
	 * Supports partial matching if exact match not found.
	 *
	 * @param programName The name of the program to find
	 * @return The matching program, or null if not found
	 */
	public Program getProgramByName(String programName) {
		if (programName == null || programName.trim().isEmpty()) {
			return getCurrentProgram();
		}

		List<Program> programs = getAllOpenPrograms();

		// First try exact match
		for (Program p : programs) {
			if (p.getName().equals(programName)) {
				return p;
			}
		}

		// Try case-insensitive match
		for (Program p : programs) {
			if (p.getName().equalsIgnoreCase(programName)) {
				return p;
			}
		}

		// Try partial match (contains)
		for (Program p : programs) {
			if (p.getName().toLowerCase().contains(programName.toLowerCase())) {
				return p;
			}
		}

		return null;
	}

	/**
	 * Get the current UI address from the location tracker.
	 */
	public Address getCurrentAddress() {
		if (currentLocation1 != null) {
			return currentLocation1.getAddress();
		}
		return null;
	}

	/**
	 * Get the current function containing the UI cursor.
	 */
	public Function getCurrentFunction() {
		Program program = getCurrentProgram();
		Address address = getCurrentAddress();

		if (program != null && address != null) {
			FunctionManager functionManager = program.getFunctionManager();
			return functionManager.getFunctionContaining(address);
		}
		return null;
	}
}
```

`src/main/java/ghidrassistmcp/GhidrAssistMCPProvider.java`:

```java
/* 
 * 
 */
package ghidrassistmcp;

import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;

import docking.ActionContext;
import docking.ComponentProvider;
import docking.action.DockingAction;
import docking.action.ToolBarData;
import ghidra.framework.options.Options;
import ghidra.framework.plugintool.PluginTool;
import ghidra.framework.preferences.Preferences;
import ghidra.util.HelpLocation;
import resources.Icons;

/**
 * UI Provider for the GhidrAssistMCP plugin featuring configuration and logging tabs.
 */
public class GhidrAssistMCPProvider extends ComponentProvider implements McpEventListener {
    
    private static final String NAME = "GhidrAssistMCP";
    private static final String OWNER = "GhidrAssistMCPPlugin";
    
    // Settings constants
    private static final String SETTINGS_CATEGORY = "GhidrAssistMCP";
    private static final String HOST_SETTING = "Server Host";
    private static final String PORT_SETTING = "Server Port";
    private static final String ENABLED_SETTING = "Server Enabled";
    private static final String ASYNC_ENABLED_SETTING = "Async Execution Enabled";
    private static final String TOOL_PREFIX = "Tool.";
    
    // Default values
    private static final String DEFAULT_HOST = "localhost";
    private static final int DEFAULT_PORT = 8080;
    private static final boolean DEFAULT_ENABLED = true;
    private static final boolean DEFAULT_ASYNC_ENABLED = true;
    
    private final PluginTool tool;
    private final GhidrAssistMCPPlugin plugin;
    private JTabbedPane tabbedPane;
    
    // Configuration tab components
    private JTextField hostField;
    private JSpinner portSpinner;
    private JCheckBox enabledCheckBox;
    private JCheckBox asyncEnabledCheckBox;
    private JTable toolsTable;
    private DefaultTableModel toolsTableModel;
    private JButton saveButton;
    private Map<String, Boolean> toolEnabledStates;
    
    // Log tab components
    private JTextArea logTextArea;
    private JButton clearButton;
    private SimpleDateFormat dateFormat;
    
    public GhidrAssistMCPProvider(PluginTool tool, GhidrAssistMCPPlugin plugin) {
        super(tool, NAME, OWNER);
        this.tool = tool;
        this.plugin = plugin;
        this.toolEnabledStates = new HashMap<>();
        this.dateFormat = new SimpleDateFormat("HH:mm:ss");
        
        buildComponent();
        createActions();
        // Don't load settings yet - wait for backend to be ready
        
        setHelpLocation(new HelpLocation("GhidrAssistMCP", "GhidrAssistMCP_Provider"));
        setVisible(true);
        
        // Add focus listener to refresh tools when window receives focus
        addFocusListener();
    }
    
    private void buildComponent() {
        tabbedPane = new JTabbedPane();
        
        // Configuration tab
        JPanel configPanel = createConfigurationPanel();
        tabbedPane.addTab("Configuration", configPanel);
        
        // Log tab
        JPanel logPanel = createLogPanel();
        tabbedPane.addTab("Log", logPanel);
        
        // Component will be returned by getComponent() method
    }
    
    private JPanel createConfigurationPanel() {
        JPanel panel = new JPanel(new BorderLayout());
        
        // Server settings panel
        JPanel serverPanel = new JPanel(new GridBagLayout());
        serverPanel.setBorder(BorderFactory.createTitledBorder("Server Settings"));
        GridBagConstraints gbc = new GridBagConstraints();
        
        // Host setting
        gbc.gridx = 0; gbc.gridy = 0; gbc.anchor = GridBagConstraints.WEST;
        serverPanel.add(new JLabel("Host:"), gbc);
        gbc.gridx = 1; gbc.fill = GridBagConstraints.HORIZONTAL; gbc.weightx = 1.0;
        hostField = new JTextField(DEFAULT_HOST, 20);
        serverPanel.add(hostField, gbc);
        
        // Port setting
        gbc.gridx = 0; gbc.gridy = 1; gbc.fill = GridBagConstraints.NONE; gbc.weightx = 0;
        serverPanel.add(new JLabel("Port:"), gbc);
        gbc.gridx = 1; gbc.fill = GridBagConstraints.HORIZONTAL; gbc.weightx = 1.0;
        portSpinner = new JSpinner(new SpinnerNumberModel(DEFAULT_PORT, 1, 65535, 1));
        serverPanel.add(portSpinner, gbc);
        
        // Enabled setting
        gbc.gridx = 0; gbc.gridy = 2; gbc.gridwidth = 2; gbc.fill = GridBagConstraints.NONE;
        enabledCheckBox = new JCheckBox("Enable MCP Server", DEFAULT_ENABLED);
        serverPanel.add(enabledCheckBox, gbc);
        
        // Async execution setting
        gbc.gridy = 3;
        asyncEnabledCheckBox = new JCheckBox("Enable async tool execution", DEFAULT_ASYNC_ENABLED);
        asyncEnabledCheckBox.setToolTipText("When enabled, long-running tools execute asynchronously and return a task ID. When disabled, all tools execute synchronously.");
        serverPanel.add(asyncEnabledCheckBox, gbc);
        
        panel.add(serverPanel, BorderLayout.NORTH);
        
        // Tools panel
        JPanel toolsPanel = new JPanel(new BorderLayout());
        toolsPanel.setBorder(BorderFactory.createTitledBorder("MCP Tools"));
        
        // Tools table
        String[] columnNames = {"Enabled", "Tool Name", "Description"};
        toolsTableModel = new DefaultTableModel(columnNames, 0) {
            @Override
            public Class<?> getColumnClass(int column) {
                return column == 0 ? Boolean.class : String.class;
            }
            
            @Override
            public boolean isCellEditable(int row, int column) {
                return column == 0; // Only the checkbox column is editable
            }
        };
        
        toolsTable = new JTable(toolsTableModel);
        toolsTable.getColumnModel().getColumn(0).setMaxWidth(60);
        toolsTable.getColumnModel().getColumn(1).setPreferredWidth(150);
        toolsTable.getColumnModel().getColumn(2).setPreferredWidth(300);
        
        JScrollPane scrollPane = new JScrollPane(toolsTable);
        scrollPane.setPreferredSize(new Dimension(500, 200));
        toolsPanel.add(scrollPane, BorderLayout.CENTER);
        
        panel.add(toolsPanel, BorderLayout.CENTER);
        
        // Save button
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        saveButton = new JButton("Save Configuration");
        saveButton.addActionListener(new SaveConfigurationListener());
        buttonPanel.add(saveButton);
        
        panel.add(buttonPanel, BorderLayout.SOUTH);
        
        return panel;
    }
    
    private JPanel createLogPanel() {
        JPanel panel = new JPanel(new BorderLayout());
        
        // Log text area
        logTextArea = new JTextArea(20, 60);
        logTextArea.setEditable(false);
        logTextArea.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 12));
        logTextArea.setBackground(Color.BLACK);
        logTextArea.setForeground(Color.GREEN);
        JScrollPane scrollPane = new JScrollPane(logTextArea);
        scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        
        panel.add(scrollPane, BorderLayout.CENTER);
        
        // Clear button
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        clearButton = new JButton("Clear Log");
        clearButton.addActionListener(e -> clearLog());
        buttonPanel.add(clearButton);
        
        panel.add(buttonPanel, BorderLayout.SOUTH);
        
        return panel;
    }
    
    private void createActions() {
        DockingAction refreshAction = new DockingAction("Refresh", OWNER) {
            @Override
            public void actionPerformed(ActionContext context) {
                refreshToolsList();
            }
        };
        refreshAction.setToolBarData(new ToolBarData(Icons.REFRESH_ICON, null));
        refreshAction.setDescription("Refresh tools list");
        refreshAction.setHelpLocation(new HelpLocation("GhidrAssistMCP", "Refresh"));
        
        addLocalAction(refreshAction);
    }
    
    private void addFocusListener() {
        // Add focus listener to the main component to refresh tools when window receives focus
        tabbedPane.addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                // Notify manager that this tool's window gained focus
                if (plugin != null && plugin.getManager() != null) {
                    plugin.getManager().setActiveTool(tool);
                }
                // Refresh tools list when the window receives focus
                refreshToolsList();
            }

            @Override
            public void focusLost(FocusEvent e) {
                // No action needed when focus is lost
            }
        });
    }
    
    public void refreshToolsList() {
        // Clear existing rows
        toolsTableModel.setRowCount(0);
        
        // Get tools from backend
        if (plugin != null && plugin.getBackend() != null) {
            try {
                // Get all tools (including disabled ones) for configuration display
                var tools = plugin.getBackend().getAllTools();
                
                // Sync enabled states with backend
                var backendStates = plugin.getBackend().getToolEnabledStates();
                toolEnabledStates.putAll(backendStates);
                
                for (var tool1 : tools) {
                    String toolName = tool1.name();
                    boolean enabled = toolEnabledStates.getOrDefault(toolName, true);
                    String description = tool1.description();
                    
                    // Truncate long descriptions
                    if (description != null && description.length() > 80) {
                        description = description.substring(0, 77) + "...";
                    }
                    
                    toolsTableModel.addRow(new Object[]{enabled, toolName, description});
                }
                logMessage("Refreshed tools list: " + tools.size() + " tools available");
            } catch (Exception e) {
                logMessage("Error refreshing tools list: " + e.getMessage());
            }
        } else {
            logMessage("Backend not available yet - tools list empty");
        }
    }
    
    private void loadSettings() {
        // Load server settings from Ghidra's global preferences
        String host = Preferences.getProperty(SETTINGS_CATEGORY + "." + HOST_SETTING, DEFAULT_HOST);
        String portStr = Preferences.getProperty(SETTINGS_CATEGORY + "." + PORT_SETTING, String.valueOf(DEFAULT_PORT));
        String enabledStr = Preferences.getProperty(SETTINGS_CATEGORY + "." + ENABLED_SETTING, String.valueOf(DEFAULT_ENABLED));
        String asyncEnabledStr = Preferences.getProperty(SETTINGS_CATEGORY + "." + ASYNC_ENABLED_SETTING, String.valueOf(DEFAULT_ASYNC_ENABLED));

        int port = DEFAULT_PORT;
        boolean enabled = DEFAULT_ENABLED;
        boolean asyncEnabled = DEFAULT_ASYNC_ENABLED;
        try {
            port = Integer.parseInt(portStr);
            enabled = Boolean.parseBoolean(enabledStr);
            asyncEnabled = Boolean.parseBoolean(asyncEnabledStr);
        } catch (NumberFormatException e) {
            logMessage("Warning: Failed to parse preferences, using defaults");
        }

        hostField.setText(host);
        portSpinner.setValue(port);
        enabledCheckBox.setSelected(enabled);
        asyncEnabledCheckBox.setSelected(asyncEnabled);

        // Load tool enabled states from tool options
        Options options = tool.getOptions(SETTINGS_CATEGORY);

        toolEnabledStates.clear();
        if (plugin != null && plugin.getBackend() != null) {
            try {
                var tools = plugin.getBackend().getAllTools();
                int loadedCount = 0;
                for (var tool1 : tools) {
                    String toolName = tool1.name();
                    boolean toolEnabled = options.getBoolean(TOOL_PREFIX + toolName, true);
                    toolEnabledStates.put(toolName, toolEnabled);
                    loadedCount++;
                }
                // Update backend with loaded settings
                plugin.getBackend().updateToolEnabledStates(toolEnabledStates);
                logMessage("Loaded tool states from settings: " + loadedCount + " tools configured");
            } catch (Exception e) {
                logMessage("Error loading tool states: " + e.getMessage());
            }
        } else {
            logMessage("Backend not available - skipping tool state loading");
        }
    }
    
    private void saveSettings() {
        // Save server settings to Ghidra's global preferences
        Preferences.setProperty(SETTINGS_CATEGORY + "." + HOST_SETTING, hostField.getText());
        Preferences.setProperty(SETTINGS_CATEGORY + "." + PORT_SETTING, String.valueOf(portSpinner.getValue()));
        Preferences.setProperty(SETTINGS_CATEGORY + "." + ENABLED_SETTING, String.valueOf(enabledCheckBox.isSelected()));
        Preferences.setProperty(SETTINGS_CATEGORY + "." + ASYNC_ENABLED_SETTING, String.valueOf(asyncEnabledCheckBox.isSelected()));

        // Force preferences to be saved to disk
        Preferences.store();

        // Save tool enabled states to tool options
        Options options = tool.getOptions(SETTINGS_CATEGORY);
        int savedCount = 0;
        for (int i = 0; i < toolsTableModel.getRowCount(); i++) {
            String toolName = (String) toolsTableModel.getValueAt(i, 1);
            boolean enabled = (Boolean) toolsTableModel.getValueAt(i, 0);
            toolEnabledStates.put(toolName, enabled);
            options.setBoolean(TOOL_PREFIX + toolName, enabled);
            savedCount++;
        }
        
        logMessage("Saved configuration to Ghidra options: server + " + savedCount + " tools");

        // Apply changes to the plugin
        plugin.applyConfiguration(hostField.getText(), (Integer) portSpinner.getValue(),
                                enabledCheckBox.isSelected(), asyncEnabledCheckBox.isSelected(),
                                toolEnabledStates);
    }
    
    public void logMessage(String message) {
        SwingUtilities.invokeLater(() -> {
            String timestamp = dateFormat.format(new Date());
            String logEntry = "[" + timestamp + "] " + message + "\n";
            logTextArea.append(logEntry);
            logTextArea.setCaretPosition(logTextArea.getDocument().getLength());
        });
    }
    
    public void logRequest(String method, String params) {
        String truncatedParams = params.length() > 60 ? params.substring(0, 77) + "..." : params;
        logMessage("REQ: " + method + " " + truncatedParams.replace("\n", "\\n"));
    }
    
    public void logResponse(String method, String response) {
        String truncatedResponse = response.length() > 60 ? response.substring(0, 77) + "..." : response;
        logMessage("RES: " + method + " " + truncatedResponse.replace("\n", "\\n"));
    }
    
    public void logSession(String event) {
        logMessage("SESSION: " + event);
    }
    
    private void clearLog() {
        logTextArea.setText("");
    }
    
    // Add the required getComponent method
    @Override
    public JComponent getComponent() {
        return tabbedPane;
    }
    
    private class SaveConfigurationListener implements ActionListener {
        @Override
        public void actionPerformed(ActionEvent e) {
            saveSettings();
            logMessage("Configuration saved");
        }
    }
    
    // Getters for current configuration
    public String getHost() {
        return hostField.getText();
    }
    
    public int getPort() {
        return (Integer) portSpinner.getValue();
    }
    
    public boolean isServerEnabled() {
        return enabledCheckBox.isSelected();
    }
    
    public boolean isAsyncEnabled() {
        return asyncEnabledCheckBox.isSelected();
    }
    
    public Map<String, Boolean> getToolEnabledStates() {
        return new HashMap<>(toolEnabledStates);
    }
    
    /**
     * Public method to refresh tools list - can be called when backend becomes available
     */
    public void onBackendReady() {
        // Load settings now that backend is ready
        loadSettings();
        refreshToolsList();
        logMessage("Backend ready - settings loaded and tools list refreshed");
    }
    
    // McpEventListener implementation
    @Override
    public void onToolRequest(String toolName, String parameters) {
        logRequest(toolName, parameters);
    }
    
    @Override
    public void onToolResponse(String toolName, String response) {
        logResponse(toolName, response);
    }
    
    @Override
    public void onSessionEvent(String event) {
        logSession(event);
    }
    
    @Override
    public void onLogMessage(String message) {
        logMessage(message);
    }
}
```

`src/main/java/ghidrassistmcp/GhidrAssistMCPServer.java`:

```java
/* 
 * 
 */
package ghidrassistmcp;

import java.time.Duration;
import java.util.List;
import java.util.Map;
import java.util.function.BiFunction;

import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.server.ServerConnector;
import org.eclipse.jetty.servlet.ServletContextHandler;
import org.eclipse.jetty.servlet.ServletHolder;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.modelcontextprotocol.json.jackson.JacksonMcpJsonMapper;
import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpServerFeatures;
import io.modelcontextprotocol.server.McpSyncServerExchange;
import io.modelcontextprotocol.server.transport.HttpServletSseServerTransportProvider;
import io.modelcontextprotocol.server.transport.HttpServletStreamableServerTransportProvider;
import io.modelcontextprotocol.spec.McpSchema;

import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import ghidrassistmcp.prompts.McpPrompt;
import ghidrassistmcp.resources.McpResource;

/**
 * Refactored MCP Server implementation that uses the backend architecture.
 * This class handles HTTP transport and delegates business logic to McpBackend.
 */
public class GhidrAssistMCPServer {
    
    private final McpBackend backend;
    private final GhidrAssistMCPProvider provider;
    private Server jettyServer;
    private final String host;
    private final int port;
    
    public GhidrAssistMCPServer(String host, int port, McpBackend backend) {
        this(host, port, backend, null);
    }
    
    public GhidrAssistMCPServer(String host, int port, McpBackend backend, GhidrAssistMCPProvider provider) {
        this.host = host;
        this.port = port;
        this.backend = backend;
        this.provider = provider;
    }
    
    public void start() throws Exception {
        Msg.info(this, "Starting MCP Server initialization...");
        
        try {
            // Create Jetty server
            Msg.info(this, "Creating Jetty server on port " + port);
            jettyServer = new Server();
            
            ServerConnector connector = new ServerConnector(jettyServer);
            connector.setHost(host);
            connector.setPort(port);
            jettyServer.addConnector(connector);

            // Create servlet context
            Msg.info(this, "Setting up servlet context");
            ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
            context.setContextPath("/");
            jettyServer.setHandler(context);
            
            // Create MCP transport provider using custom ObjectMapper that ignores unknown properties
            Msg.info(this, "Creating MCP transport provider");
            ObjectMapper objectMapper = new ObjectMapper();
            objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
            JacksonMcpJsonMapper mapper = new JacksonMcpJsonMapper(objectMapper);
            String messageEndpoint = "/message";
            String mcpEndpoint = "/mcp";

            HttpServletSseServerTransportProvider sseTransportProvider =
                HttpServletSseServerTransportProvider.builder()
                    .jsonMapper(mapper)
                    .messageEndpoint(messageEndpoint)
                    .keepAliveInterval(Duration.ofSeconds(15))
                    .build();

            HttpServletStreamableServerTransportProvider streamableTransportProvider =
                HttpServletStreamableServerTransportProvider.builder()
                    .jsonMapper(mapper)
                    .mcpEndpoint(mcpEndpoint)
                    .keepAliveInterval(Duration.ofSeconds(15))
                    .build();

            // Build MCP server using backend for configuration
            Msg.info(this, "Building MCP server with backend tools");
            var sseServerBuilder = McpServer.sync(sseTransportProvider)
                .serverInfo(backend.getServerInfo())
                .capabilities(backend.getCapabilities());

            var streamableServerBuilder = McpServer.sync(streamableTransportProvider)
                .serverInfo(backend.getServerInfo())
                .capabilities(backend.getCapabilities());

            // Register each tool individually with its own handler
            for (McpSchema.Tool toolSchema : backend.getAvailableTools()) {
                String toolName = toolSchema.name();
                BiFunction<McpSyncServerExchange, McpSchema.CallToolRequest, McpSchema.CallToolResult> toolHandler =
                    (exchange, request) -> {
                        // The backend now handles all logging through event listeners
                        Map<String, Object> params = request.arguments();
                        return backend.callTool(toolName, params);
                    };

                sseServerBuilder.toolCall(toolSchema, toolHandler);
                streamableServerBuilder.toolCall(toolSchema, toolHandler);
                Msg.info(this, "Registered tool with MCP server: " + toolName);
            }

            // Register MCP resources and prompts if backend supports them
            if (backend instanceof GhidrAssistMCPBackend) {
                GhidrAssistMCPBackend ghidraBackend = (GhidrAssistMCPBackend) backend;
                registerResources(sseServerBuilder, streamableServerBuilder, ghidraBackend);
                registerPrompts(sseServerBuilder, streamableServerBuilder, ghidraBackend);
            }

            sseServerBuilder.build();
            streamableServerBuilder.build();
            
            // Register MCP servlet - use root path since transport provider handles routing internally
            Msg.info(this, "Registering MCP servlet");
            
            try {
                ServletHolder mcpSseServletHolder = new ServletHolder("mcp-sse-transport", sseTransportProvider);
                mcpSseServletHolder.setAsyncSupported(true);
                context.addServlet(mcpSseServletHolder, "/sse");
                context.addServlet(mcpSseServletHolder, messageEndpoint);

                ServletHolder mcpStreamableServletHolder = new ServletHolder("mcp-streamable-transport", streamableTransportProvider);
                mcpStreamableServletHolder.setAsyncSupported(true);
                context.addServlet(mcpStreamableServletHolder, "/mcp/*");
                Msg.info(this, "Registered MCP SSE servlet mapping: /*");
                Msg.info(this, "Registered MCP Streamable servlet mapping: /mcp/*");
                
                // Log configuration
                Msg.info(this, "Transport provider class: " + sseTransportProvider.getClass().getName());
                Msg.info(this, "Message endpoint configured as: " + messageEndpoint);
                Msg.info(this, "SSE endpoint will be: /sse (default)");
                Msg.info(this, "Expected client URLs:");
                Msg.info(this, "  SSE: http://" + host + ":" + port + "/sse");
                Msg.info(this, "  Messages: http://" + host + ":" + port + messageEndpoint);
                Msg.info(this, "Streamable HTTP transport provider class: " + streamableTransportProvider.getClass().getName());
                Msg.info(this, "Streamable MCP endpoint: http://" + host + ":" + port + mcpEndpoint);
                
            } catch (Exception e) {
                Msg.error(this, "Failed to register MCP servlet", e);
            }
            
            // Start Jetty server
            Msg.info(this, "Starting Jetty server...");
            jettyServer.start();
            
            // Verify server is listening
            if (jettyServer.isStarted()) {
                Msg.info(this, "GhidrAssistMCP Server successfully started on port " + port);
                Msg.info(this, "MCP SSE endpoint: http://" + host + ":" + port + "/sse");
                Msg.info(this, "MCP message endpoint: http://" + host + ":" + port + messageEndpoint);
                Msg.info(this, "MCP Streamable endpoint: http://" + host + ":" + port + mcpEndpoint);
                Msg.info(this, "Server state: " + jettyServer.getState());
                
                // Log all registered servlets
                var servletHandler = context.getServletHandler();
                var servletMappings = servletHandler.getServletMappings();
                Msg.info(this, "Registered servlet mappings:");
                for (var mapping : servletMappings) {
                    Msg.info(this, "  " + mapping.getServletName() + " -> " + String.join(", ", mapping.getPathSpecs()));
                }
                
                // Log server startup to UI
                if (provider != null) {
                    provider.logSession("Jetty server listening on port " + port);
                    provider.logSession("Registered " + backend.getAvailableTools().size() + " MCP tools");
                    provider.logSession("Ready for MCP client connections");
                }
            } else {
                Msg.error(this, "Failed to start Jetty server - server not in started state");
            }
            
        } catch (Exception e) {
            Msg.error(this, "Exception during MCP Server startup: " + e.getMessage(), e);
            throw e;
        }
    }
    
    public void stop() throws Exception {
        if (jettyServer != null) {
            jettyServer.stop();
            Msg.info(this, "GhidrAssistMCP Server stopped");
        }
    }
    
    public void setCurrentProgram(Program program) {
        backend.onProgramActivated(program);
    }

    /**
     * Register MCP prompts with the server builders.
     */
    @SuppressWarnings({ "unchecked", "rawtypes" })
    private void registerPrompts(McpServer.SyncSpecification sseServerBuilder,
                                  McpServer.SyncSpecification streamableServerBuilder,
                                  GhidrAssistMCPBackend ghidraBackend) {
        try {
            List<McpPrompt> prompts = ghidraBackend.getAvailablePrompts();
            java.util.List<McpServerFeatures.SyncPromptSpecification> promptSpecs = new java.util.ArrayList<>();

            for (McpPrompt prompt : prompts) {
                // Create McpSchema.Prompt for each prompt
                McpSchema.Prompt mcpPrompt = new McpSchema.Prompt(
                    prompt.getName(),
                    prompt.getDescription(),
                    prompt.getArguments()
                );

                // Create handler for getting the prompt
                BiFunction<McpSyncServerExchange, McpSchema.GetPromptRequest, McpSchema.GetPromptResult> promptHandler =
                    (exchange, request) -> {
                        Map<String, Object> rawArgs = request.arguments();
                        Map<String, String> args = new java.util.HashMap<>();
                        if (rawArgs != null) {
                            for (Map.Entry<String, Object> entry : rawArgs.entrySet()) {
                                args.put(entry.getKey(), entry.getValue() != null ? entry.getValue().toString() : null);
                            }
                        }
                        Program program = ghidraBackend.getCurrentProgram();
                        return prompt.generatePrompt(args, program);
                    };

                // Create specification
                McpServerFeatures.SyncPromptSpecification spec =
                    new McpServerFeatures.SyncPromptSpecification(mcpPrompt, promptHandler);
                promptSpecs.add(spec);
                Msg.info(this, "Prepared prompt for registration: " + prompt.getName());
            }

            // Register all prompts with both builders
            if (!promptSpecs.isEmpty()) {
                sseServerBuilder.prompts(promptSpecs);
                streamableServerBuilder.prompts(promptSpecs);
                Msg.info(this, "Registered " + promptSpecs.size() + " MCP prompts");
            }

        } catch (Exception e) {
            Msg.warn(this, "Failed to register MCP prompts: " + e.getMessage(), e);
        }
    }

    /**
     * Register MCP resources with the server builders.
     */
    @SuppressWarnings({ "unchecked", "rawtypes" })
    private void registerResources(McpServer.SyncSpecification sseServerBuilder,
                                   McpServer.SyncSpecification streamableServerBuilder,
                                   GhidrAssistMCPBackend ghidraBackend) {
        try {
            List<McpResource> resources = ghidraBackend.getAvailableResources();
            java.util.List<McpServerFeatures.SyncResourceSpecification> resourceSpecs = new java.util.ArrayList<>();

            for (McpResource resource : resources) {
                // Create McpSchema.Resource for each resource
                McpSchema.Resource mcpResource = McpSchema.Resource.builder()
                    .uri(resource.getUriPattern())
                    .name(resource.getName())
                    .description(resource.getDescription())
                    .mimeType(resource.getMimeType())
                    .build();

                // Create handler for reading the resource
                BiFunction<McpSyncServerExchange, McpSchema.ReadResourceRequest, McpSchema.ReadResourceResult> readHandler =
                    (exchange, request) -> {
                        String uri = request.uri();
                        String content = ghidraBackend.readResource(uri);

                        if (content == null) {
                            content = "{\"error\": \"Resource not found: " + uri + "\"}";
                        }

                        McpSchema.ResourceContents contents = new McpSchema.TextResourceContents(
                            uri,
                            resource.getMimeType(),
                            content
                        );

                        return new McpSchema.ReadResourceResult(List.of(contents));
                    };

                // Create specification
                McpServerFeatures.SyncResourceSpecification spec =
                    new McpServerFeatures.SyncResourceSpecification(mcpResource, readHandler);
                resourceSpecs.add(spec);
                Msg.info(this, "Prepared resource for registration: " + resource.getName());
            }

            // Register all resources with both builders
            if (!resourceSpecs.isEmpty()) {
                sseServerBuilder.resources(resourceSpecs);
                streamableServerBuilder.resources(resourceSpecs);
                Msg.info(this, "Registered " + resourceSpecs.size() + " MCP resources");
            }

        } catch (Exception e) {
            Msg.warn(this, "Failed to register MCP resources: " + e.getMessage(), e);
        }
    }
}
```

`src/main/java/ghidrassistmcp/McpBackend.java`:

```java
/* 
 * 
 */
package ghidrassistmcp;

import java.util.List;
import java.util.Map;

import ghidra.program.model.listing.Program;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * Interface for the MCP backend that handles tool management and execution.
 * This provides separation between the HTTP transport layer and business logic.
 */
public interface McpBackend {
    
    /**
     * Register a new MCP tool
     */
    void registerTool(McpTool tool);
    
    /**
     * Unregister an MCP tool by name
     */
    void unregisterTool(String toolName);
    
    /**
     * Get list of all available tools
     */
    List<McpSchema.Tool> getAvailableTools();
    
    /**
     * Execute a tool with given arguments
     */
    McpSchema.CallToolResult callTool(String toolName, Map<String, Object> arguments);
    
    /**
     * Notify backend when a program is activated
     */
    void onProgramActivated(Program program);
    
    /**
     * Notify backend when a program is deactivated
     */
    void onProgramDeactivated(Program program);
    
    /**
     * Get server implementation info
     */
    McpSchema.Implementation getServerInfo();
    
    /**
     * Get server capabilities
     */
    McpSchema.ServerCapabilities getCapabilities();
}
```

`src/main/java/ghidrassistmcp/McpEventListener.java`:

```java
/* 
 * 
 */
package ghidrassistmcp;

/**
 * Event listener interface for MCP operations.
 * This allows decoupling between the backend and UI components.
 */
public interface McpEventListener {
    
    /**
     * Called when a tool request is received.
     * @param toolName The name of the tool being called
     * @param parameters The request parameters (may be truncated for logging)
     */
    void onToolRequest(String toolName, String parameters);
    
    /**
     * Called when a tool response is generated.
     * @param toolName The name of the tool that was called
     * @param response The response content (may be truncated for logging)
     */
    void onToolResponse(String toolName, String response);
    
    /**
     * Called when a session event occurs.
     * @param event The session event description
     */
    void onSessionEvent(String event);
    
    /**
     * Called for general logging messages.
     * @param message The log message
     */
    void onLogMessage(String message);
}
```

`src/main/java/ghidrassistmcp/McpTool.java`:

```java
/* 
 * 
 */
package ghidrassistmcp;

import java.util.Map;

import ghidra.program.model.listing.Program;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * Interface for individual MCP tools that can be registered with the backend.
 */
public interface McpTool {

    /**
     * Get the tool name (used for MCP tool calls)
     */
    String getName();

    /**
     * Get the tool description
     */
    String getDescription();

    /**
     * Get the input schema for this tool
     */
    McpSchema.JsonSchema getInputSchema();

    /**
     * Execute the tool with given arguments and current program context
     */
    McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram);

    /**
     * Execute the tool with given arguments, program context, and backend reference for multi-program access.
     * Tools that need to access all open programs or query programs by name should override this method.
     * Tools that need UI context (current address, current function) can access the active plugin via
     * backend.getActivePlugin().
     */
    default McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram, GhidrAssistMCPBackend backend) {
        // Default implementation delegates to the original method for backward compatibility
        return execute(arguments, currentProgram);
    }

    // ==================== MCP 2025-11-25 Tool Annotations ====================

    /**
     * Indicates whether the tool performs read-only operations.
     * Read-only tools do not modify the program or any external state.
     * Default: true (most Ghidra analysis tools are read-only)
     */
    default boolean isReadOnly() {
        return true;
    }

    /**
     * Indicates whether the tool is destructive.
     * Destructive tools may delete data, remove functions, or cause irreversible changes.
     * Default: false
     */
    default boolean isDestructive() {
        return false;
    }

    /**
     * Indicates whether the tool is idempotent.
     * Idempotent tools produce the same result when called multiple times with the same arguments.
     * Default: false (conservative default for modification tools)
     */
    default boolean isIdempotent() {
        return false;
    }

    /**
     * Indicates whether the tool interacts with external systems (open-world).
     * Open-world tools may make network requests, access external databases, etc.
     * Default: false (Ghidra tools typically operate on local program data)
     */
    default boolean isOpenWorld() {
        return false;
    }

    // ==================== Async Task Support ====================

    /**
     * Indicates whether the tool is potentially long-running and should be executed asynchronously.
     * Long-running tools return a task ID immediately and execute in the background.
     * Default: false
     */
    default boolean isLongRunning() {
        return false;
    }

    // ==================== Caching Support ====================

    /**
     * Indicates whether the tool's results can be cached.
     * Cacheable tools should return consistent results for the same inputs
     * as long as the program hasn't been modified.
     * Default: false (conservative default)
     */
    default boolean isCacheable() {
        return false;
    }
}
```

`src/main/java/ghidrassistmcp/cache/CacheEntry.java`:

```java
/*
 * MCP Cache Entry with validation support.
 */
package ghidrassistmcp.cache;

import java.time.Instant;

import io.modelcontextprotocol.spec.McpSchema;

/**
 * Represents a cached tool result with metadata for validation.
 */
public class CacheEntry {

    private final McpSchema.CallToolResult result;
    private final Instant createdAt;
    private final long programModificationNumber;
    private final String programName;
    private final String cacheKey;
    private volatile int hitCount;

    /**
     * Create a new cache entry
     */
    public CacheEntry(String cacheKey, McpSchema.CallToolResult result,
                      String programName, long programModificationNumber) {
        this.cacheKey = cacheKey;
        this.result = result;
        this.programName = programName;
        this.programModificationNumber = programModificationNumber;
        this.createdAt = Instant.now();
        this.hitCount = 0;
    }

    /**
     * Get the cached result
     */
    public McpSchema.CallToolResult getResult() {
        hitCount++;
        return result;
    }

    /**
     * Get when this entry was created
     */
    public Instant getCreatedAt() {
        return createdAt;
    }

    /**
     * Get the program modification number at cache time
     */
    public long getProgramModificationNumber() {
        return programModificationNumber;
    }

    /**
     * Get the program name this entry is for
     */
    public String getProgramName() {
        return programName;
    }

    /**
     * Get the cache key
     */
    public String getCacheKey() {
        return cacheKey;
    }

    /**
     * Get the number of times this entry has been hit
     */
    public int getHitCount() {
        return hitCount;
    }

    /**
     * Check if this cache entry is still valid for the given program state
     *
     * @param currentProgramName Current program name
     * @param currentModificationNumber Current program modification number
     * @return true if the cache entry is still valid
     */
    public boolean isValid(String currentProgramName, long currentModificationNumber) {
        // Entry is invalid if:
        // 1. Program has changed
        if (!this.programName.equals(currentProgramName)) {
            return false;
        }

        // 2. Program has been modified since cache was created
        if (this.programModificationNumber != currentModificationNumber) {
            return false;
        }

        return true;
    }

    /**
     * Get the age of this cache entry in milliseconds
     */
    public long getAgeMillis() {
        return Instant.now().toEpochMilli() - createdAt.toEpochMilli();
    }

    @Override
    public String toString() {
        return String.format("CacheEntry[key=%s, program=%s, modNum=%d, hits=%d, age=%dms]",
            cacheKey, programName, programModificationNumber, hitCount, getAgeMillis());
    }
}

```

`src/main/java/ghidrassistmcp/cache/McpCache.java`:

```java
/*
 * MCP Tool Result Cache implementation.
 */
package ghidrassistmcp.cache;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * Cache for MCP tool results with program modification-based invalidation.
 */
public class McpCache {

    private static final int DEFAULT_MAX_ENTRIES = 1000;
    private static final long DEFAULT_MAX_AGE_MS = 5 * 60 * 1000; // 5 minutes

    private final Map<String, CacheEntry> cache = new ConcurrentHashMap<>();
    private final int maxEntries;
    private final long maxAgeMs;
    private final ObjectMapper objectMapper = new ObjectMapper();

    private final AtomicLong hitCount = new AtomicLong(0);
    private final AtomicLong missCount = new AtomicLong(0);
    private final AtomicLong evictionCount = new AtomicLong(0);

    /**
     * Create a cache with default settings
     */
    public McpCache() {
        this(DEFAULT_MAX_ENTRIES, DEFAULT_MAX_AGE_MS);
    }

    /**
     * Create a cache with specified settings
     */
    public McpCache(int maxEntries, long maxAgeMs) {
        this.maxEntries = maxEntries;
        this.maxAgeMs = maxAgeMs;
        Msg.info(this, "McpCache initialized with maxEntries=" + maxEntries + ", maxAgeMs=" + maxAgeMs);
    }

    /**
     * Generate a cache key for a tool call
     */
    public String generateKey(String toolName, Map<String, Object> arguments, String programName) {
        StringBuilder keyBuilder = new StringBuilder();
        keyBuilder.append(toolName).append(":");
        keyBuilder.append(programName).append(":");

        // Sort and serialize arguments for consistent key generation
        try {
            String argsJson = objectMapper.writeValueAsString(arguments);
            keyBuilder.append(argsJson.hashCode());
        } catch (JsonProcessingException e) {
            keyBuilder.append(arguments.hashCode());
        }

        return keyBuilder.toString();
    }

    /**
     * Get a cached result if valid
     *
     * @param key The cache key
     * @param program The current program (for validation)
     * @return The cached result or null if not found/invalid
     */
    public McpSchema.CallToolResult get(String key, Program program) {
        CacheEntry entry = cache.get(key);

        if (entry == null) {
            missCount.incrementAndGet();
            return null;
        }

        // Check if entry is still valid
        String programName = program != null ? program.getName() : "";
        long modNum = program != null ? program.getModificationNumber() : 0;

        if (!entry.isValid(programName, modNum)) {
            // Invalidate stale entry
            cache.remove(key);
            evictionCount.incrementAndGet();
            missCount.incrementAndGet();
            Msg.debug(this, "Cache entry invalidated (program modified): " + key);
            return null;
        }

        // Check age
        if (entry.getAgeMillis() > maxAgeMs) {
            cache.remove(key);
            evictionCount.incrementAndGet();
            missCount.incrementAndGet();
            Msg.debug(this, "Cache entry expired: " + key);
            return null;
        }

        hitCount.incrementAndGet();
        Msg.debug(this, "Cache hit: " + key);
        return entry.getResult();
    }

    /**
     * Store a result in the cache
     *
     * @param key The cache key
     * @param result The result to cache
     * @param program The current program
     */
    public void put(String key, McpSchema.CallToolResult result, Program program) {
        // Enforce size limit
        if (cache.size() >= maxEntries) {
            evictOldest();
        }

        String programName = program != null ? program.getName() : "";
        long modNum = program != null ? program.getModificationNumber() : 0;

        CacheEntry entry = new CacheEntry(key, result, programName, modNum);
        cache.put(key, entry);
        Msg.debug(this, "Cache put: " + key);
    }

    /**
     * Invalidate all entries for a specific program
     */
    public void invalidateProgram(String programName) {
        int removed = 0;
        var iterator = cache.entrySet().iterator();
        while (iterator.hasNext()) {
            var entry = iterator.next();
            if (entry.getValue().getProgramName().equals(programName)) {
                iterator.remove();
                removed++;
            }
        }
        if (removed > 0) {
            evictionCount.addAndGet(removed);
            Msg.info(this, "Invalidated " + removed + " cache entries for program: " + programName);
        }
    }

    /**
     * Clear the entire cache
     */
    public void clear() {
        int size = cache.size();
        cache.clear();
        evictionCount.addAndGet(size);
        Msg.info(this, "Cache cleared, removed " + size + " entries");
    }

    /**
     * Evict the oldest entries to make room
     */
    private void evictOldest() {
        // Find and remove the oldest 10% of entries
        int toEvict = Math.max(1, maxEntries / 10);
        int evicted = 0;

        // Simple eviction: remove entries with oldest creation time
        var entries = cache.entrySet().stream()
            .sorted((a, b) -> a.getValue().getCreatedAt().compareTo(b.getValue().getCreatedAt()))
            .limit(toEvict)
            .toList();

        for (var entry : entries) {
            cache.remove(entry.getKey());
            evicted++;
        }

        evictionCount.addAndGet(evicted);
        Msg.debug(this, "Evicted " + evicted + " oldest cache entries");
    }

    /**
     * Get cache statistics
     */
    public String getStats() {
        long hits = hitCount.get();
        long misses = missCount.get();
        long total = hits + misses;
        double hitRate = total > 0 ? (double) hits / total * 100 : 0;

        return String.format("Cache Stats: size=%d, hits=%d, misses=%d, hitRate=%.1f%%, evictions=%d",
            cache.size(), hits, misses, hitRate, evictionCount.get());
    }

    /**
     * Get the current cache size
     */
    public int size() {
        return cache.size();
    }

    /**
     * Check if cache contains a key
     */
    public boolean containsKey(String key) {
        return cache.containsKey(key);
    }
}

```

`src/main/java/ghidrassistmcp/prompts/AnalyzeFunctionPrompt.java`:

```java
/*
 * MCP Prompt for analyzing a function.
 */
package ghidrassistmcp.prompts;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import ghidra.app.decompiler.DecompInterface;
import ghidra.app.decompiler.DecompileResults;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.util.task.TaskMonitor;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * Prompt for comprehensive function analysis.
 */
public class AnalyzeFunctionPrompt implements McpPrompt {

    @Override
    public String getName() {
        return "analyze_function";
    }

    @Override
    public String getDescription() {
        return "Analyze a function comprehensively including decompilation, cross-references, and behavior";
    }

    @Override
    public List<McpSchema.PromptArgument> getArguments() {
        return List.of(
            new McpSchema.PromptArgument(
                "function_name",
                "Name or address of the function to analyze",
                true
            )
        );
    }

    @Override
    public McpSchema.GetPromptResult generatePrompt(Map<String, String> arguments, Program program) {
        String functionIdentifier = arguments.get("function_name");

        if (functionIdentifier == null || functionIdentifier.isEmpty()) {
            return new McpSchema.GetPromptResult(
                "Error: function_name argument is required",
                List.of(new McpSchema.PromptMessage(
                    McpSchema.Role.USER,
                    new McpSchema.TextContent("Error: function_name argument is required")
                ))
            );
        }

        StringBuilder context = new StringBuilder();
        context.append("# Function Analysis Request\n\n");
        context.append("Please provide a comprehensive analysis of the following function.\n\n");

        if (program != null) {
            // Find the function
            Function function = findFunction(program, functionIdentifier);

            if (function != null) {
                context.append("## Function Information\n");
                context.append("- **Name**: ").append(function.getName()).append("\n");
                context.append("- **Address**: ").append(function.getEntryPoint()).append("\n");
                context.append("- **Signature**: ").append(function.getPrototypeString(false, false)).append("\n");
                context.append("- **Calling Convention**: ").append(function.getCallingConventionName()).append("\n");
                context.append("- **Parameter Count**: ").append(function.getParameterCount()).append("\n");
                context.append("- **Is Thunk**: ").append(function.isThunk()).append("\n\n");

                // Get decompilation
                String decompiled = decompileFunction(program, function);
                if (decompiled != null) {
                    context.append("## Decompiled Code\n```c\n");
                    context.append(decompiled);
                    context.append("\n```\n\n");
                }

                // Get called functions
                context.append("## Called Functions\n");
                var calledFunctions = function.getCalledFunctions(TaskMonitor.DUMMY);
                if (calledFunctions.isEmpty()) {
                    context.append("No functions called.\n\n");
                } else {
                    for (Function called : calledFunctions) {
                        context.append("- ").append(called.getName()).append(" @ ").append(called.getEntryPoint()).append("\n");
                    }
                    context.append("\n");
                }

                // Get calling functions
                context.append("## Calling Functions\n");
                var callingFunctions = function.getCallingFunctions(TaskMonitor.DUMMY);
                if (callingFunctions.isEmpty()) {
                    context.append("No functions call this function.\n\n");
                } else {
                    for (Function caller : callingFunctions) {
                        context.append("- ").append(caller.getName()).append(" @ ").append(caller.getEntryPoint()).append("\n");
                    }
                    context.append("\n");
                }

            } else {
                context.append("**Error**: Function '").append(functionIdentifier).append("' not found.\n\n");
            }
        } else {
            context.append("**Note**: No program loaded. Please provide function details manually.\n\n");
        }

        context.append("## Analysis Tasks\n");
        context.append("Please analyze:\n");
        context.append("1. **Purpose**: What does this function do?\n");
        context.append("2. **Parameters**: What are the input parameters and their purposes?\n");
        context.append("3. **Return Value**: What does the function return?\n");
        context.append("4. **Side Effects**: Does it modify global state or have other side effects?\n");
        context.append("5. **Algorithm**: Describe the algorithm or logic used.\n");
        context.append("6. **Security**: Are there any potential security issues?\n");
        context.append("7. **Suggested Name**: If the current name is unclear, suggest a better name.\n");

        List<McpSchema.PromptMessage> messages = new ArrayList<>();
        messages.add(new McpSchema.PromptMessage(
            McpSchema.Role.USER,
            new McpSchema.TextContent(context.toString())
        ));

        return new McpSchema.GetPromptResult(
            "Analyze function: " + functionIdentifier,
            messages
        );
    }

    private Function findFunction(Program program, String identifier) {
        // Try as address first
        try {
            var addr = program.getAddressFactory().getAddress(identifier);
            if (addr != null) {
                return program.getFunctionManager().getFunctionAt(addr);
            }
        } catch (Exception e) {
            // Not an address, try as name
        }

        // Try as function name
        for (Function function : program.getFunctionManager().getFunctions(true)) {
            if (function.getName().equals(identifier)) {
                return function;
            }
        }

        return null;
    }

    private String decompileFunction(Program program, Function function) {
        DecompInterface decompiler = new DecompInterface();
        try {
            decompiler.openProgram(program);
            DecompileResults results = decompiler.decompileFunction(function, 30, TaskMonitor.DUMMY);
            if (results.decompileCompleted()) {
                return results.getDecompiledFunction().getC();
            }
        } finally {
            decompiler.dispose();
        }
        return null;
    }
}

```

`src/main/java/ghidrassistmcp/prompts/DocumentFunctionPrompt.java`:

```java
/*
 * MCP Prompt for documenting a function.
 */
package ghidrassistmcp.prompts;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import ghidra.app.decompiler.DecompInterface;
import ghidra.app.decompiler.DecompileResults;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.util.task.TaskMonitor;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * Prompt for generating documentation for a function.
 */
public class DocumentFunctionPrompt implements McpPrompt {

    @Override
    public String getName() {
        return "document_function";
    }

    @Override
    public String getDescription() {
        return "Generate comprehensive documentation for a function including description, parameters, and usage";
    }

    @Override
    public List<McpSchema.PromptArgument> getArguments() {
        return List.of(
            new McpSchema.PromptArgument(
                "function_name",
                "Name or address of the function to document",
                true
            ),
            new McpSchema.PromptArgument(
                "format",
                "Documentation format: doxygen, markdown, or plain (default: doxygen)",
                false
            )
        );
    }

    @Override
    public McpSchema.GetPromptResult generatePrompt(Map<String, String> arguments, Program program) {
        String functionIdentifier = arguments.get("function_name");
        String format = arguments.getOrDefault("format", "doxygen");

        if (functionIdentifier == null || functionIdentifier.isEmpty()) {
            return new McpSchema.GetPromptResult(
                "Error: function_name argument is required",
                List.of(new McpSchema.PromptMessage(
                    McpSchema.Role.USER,
                    new McpSchema.TextContent("Error: function_name argument is required")
                ))
            );
        }

        StringBuilder context = new StringBuilder();
        context.append("# Function Documentation Request\n\n");
        context.append("Please generate comprehensive documentation for the following function in **")
               .append(format).append("** format.\n\n");

        if (program != null) {
            Function function = findFunction(program, functionIdentifier);

            if (function != null) {
                context.append("## Function Information\n");
                context.append("- **Name**: ").append(function.getName()).append("\n");
                context.append("- **Address**: ").append(function.getEntryPoint()).append("\n");
                context.append("- **Signature**: ").append(function.getPrototypeString(false, false)).append("\n");
                context.append("- **Parameter Count**: ").append(function.getParameterCount()).append("\n\n");

                // Parameters
                context.append("## Parameters\n");
                var params = function.getParameters();
                if (params.length == 0) {
                    context.append("No parameters.\n\n");
                } else {
                    for (var param : params) {
                        context.append("- **").append(param.getName()).append("** (")
                               .append(param.getDataType().getName()).append(")\n");
                    }
                    context.append("\n");
                }

                // Return type
                context.append("## Return Type\n");
                context.append(function.getReturnType().getName()).append("\n\n");

                // Get decompilation
                String decompiled = decompileFunction(program, function);
                if (decompiled != null) {
                    context.append("## Decompiled Code\n```c\n");
                    context.append(decompiled);
                    context.append("\n```\n\n");
                }

            } else {
                context.append("**Error**: Function '").append(functionIdentifier).append("' not found.\n\n");
            }
        } else {
            context.append("**Note**: No program loaded. Please provide function details manually.\n\n");
        }

        context.append("## Documentation Requirements\n");
        context.append("Generate documentation that includes:\n\n");
        context.append("1. **Brief Description**: One-line summary of what the function does\n");
        context.append("2. **Detailed Description**: Full explanation of the function's purpose and behavior\n");
        context.append("3. **Parameters**: Description of each parameter, its purpose, valid values, and constraints\n");
        context.append("4. **Return Value**: What the function returns and when\n");
        context.append("5. **Side Effects**: Any global state modifications or I/O operations\n");
        context.append("6. **Preconditions**: Requirements that must be met before calling\n");
        context.append("7. **Postconditions**: Guarantees after the function completes\n");
        context.append("8. **Example Usage**: Code example showing how to use the function\n");
        context.append("9. **Related Functions**: Other functions that work with this one\n");

        if (format.equalsIgnoreCase("doxygen")) {
            context.append("\n## Output Format (Doxygen)\n");
            context.append("```c\n");
            context.append("/**\n");
            context.append(" * @brief Brief description\n");
            context.append(" * \n");
            context.append(" * Detailed description...\n");
            context.append(" * \n");
            context.append(" * @param param_name Description\n");
            context.append(" * @return Return description\n");
            context.append(" * @see related_function\n");
            context.append(" */\n");
            context.append("```\n");
        }

        List<McpSchema.PromptMessage> messages = new ArrayList<>();
        messages.add(new McpSchema.PromptMessage(
            McpSchema.Role.USER,
            new McpSchema.TextContent(context.toString())
        ));

        return new McpSchema.GetPromptResult(
            "Document function: " + functionIdentifier,
            messages
        );
    }

    private Function findFunction(Program program, String identifier) {
        try {
            var addr = program.getAddressFactory().getAddress(identifier);
            if (addr != null) {
                return program.getFunctionManager().getFunctionAt(addr);
            }
        } catch (Exception e) {
            // Not an address
        }

        for (Function function : program.getFunctionManager().getFunctions(true)) {
            if (function.getName().equals(identifier)) {
                return function;
            }
        }
        return null;
    }

    private String decompileFunction(Program program, Function function) {
        DecompInterface decompiler = new DecompInterface();
        try {
            decompiler.openProgram(program);
            DecompileResults results = decompiler.decompileFunction(function, 30, TaskMonitor.DUMMY);
            if (results.decompileCompleted()) {
                return results.getDecompiledFunction().getC();
            }
        } finally {
            decompiler.dispose();
        }
        return null;
    }
}

```

`src/main/java/ghidrassistmcp/prompts/IdentifyVulnerabilityPrompt.java`:

```java
/*
 * MCP Prompt for identifying vulnerabilities.
 */
package ghidrassistmcp.prompts;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import ghidra.app.decompiler.DecompInterface;
import ghidra.app.decompiler.DecompileResults;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.util.task.TaskMonitor;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * Prompt for identifying potential security vulnerabilities in a function.
 */
public class IdentifyVulnerabilityPrompt implements McpPrompt {

    @Override
    public String getName() {
        return "identify_vulnerability";
    }

    @Override
    public String getDescription() {
        return "Analyze a function for potential security vulnerabilities (buffer overflows, format strings, etc.)";
    }

    @Override
    public List<McpSchema.PromptArgument> getArguments() {
        return List.of(
            new McpSchema.PromptArgument(
                "function_name",
                "Name or address of the function to analyze for vulnerabilities",
                true
            )
        );
    }

    @Override
    public McpSchema.GetPromptResult generatePrompt(Map<String, String> arguments, Program program) {
        String functionIdentifier = arguments.get("function_name");

        if (functionIdentifier == null || functionIdentifier.isEmpty()) {
            return new McpSchema.GetPromptResult(
                "Error: function_name argument is required",
                List.of(new McpSchema.PromptMessage(
                    McpSchema.Role.USER,
                    new McpSchema.TextContent("Error: function_name argument is required")
                ))
            );
        }

        StringBuilder context = new StringBuilder();
        context.append("# Security Vulnerability Analysis Request\n\n");
        context.append("Please perform a security-focused analysis of the following function.\n\n");

        if (program != null) {
            Function function = findFunction(program, functionIdentifier);

            if (function != null) {
                context.append("## Function Information\n");
                context.append("- **Name**: ").append(function.getName()).append("\n");
                context.append("- **Address**: ").append(function.getEntryPoint()).append("\n");
                context.append("- **Signature**: ").append(function.getPrototypeString(false, false)).append("\n\n");

                // Get decompilation
                String decompiled = decompileFunction(program, function);
                if (decompiled != null) {
                    context.append("## Decompiled Code\n```c\n");
                    context.append(decompiled);
                    context.append("\n```\n\n");
                }

                // List dangerous functions called
                context.append("## Potentially Dangerous Functions Called\n");
                var calledFunctions = function.getCalledFunctions(TaskMonitor.DUMMY);
                boolean foundDangerous = false;
                for (Function called : calledFunctions) {
                    String name = called.getName().toLowerCase();
                    if (isDangerousFunction(name)) {
                        context.append("- **").append(called.getName()).append("** @ ").append(called.getEntryPoint()).append("\n");
                        foundDangerous = true;
                    }
                }
                if (!foundDangerous) {
                    context.append("No known dangerous functions detected.\n");
                }
                context.append("\n");

            } else {
                context.append("**Error**: Function '").append(functionIdentifier).append("' not found.\n\n");
            }
        } else {
            context.append("**Note**: No program loaded. Please provide function details manually.\n\n");
        }

        context.append("## Vulnerability Categories to Check\n");
        context.append("Please analyze for the following vulnerability types:\n\n");
        context.append("1. **Buffer Overflows**: Stack or heap buffer overflows, off-by-one errors\n");
        context.append("2. **Format String Bugs**: Improper use of printf-family functions\n");
        context.append("3. **Integer Overflows/Underflows**: Arithmetic issues leading to unexpected values\n");
        context.append("4. **Use After Free**: Accessing memory after deallocation\n");
        context.append("5. **Double Free**: Freeing memory multiple times\n");
        context.append("6. **Null Pointer Dereference**: Accessing null pointers\n");
        context.append("7. **Command Injection**: Unsafe execution of external commands\n");
        context.append("8. **Path Traversal**: Improper validation of file paths\n");
        context.append("9. **Information Disclosure**: Leaking sensitive data\n");
        context.append("10. **Race Conditions**: Time-of-check to time-of-use issues\n\n");

        context.append("## Output Format\n");
        context.append("For each potential vulnerability found, provide:\n");
        context.append("- **Type**: The category of vulnerability\n");
        context.append("- **Location**: Line or instruction address\n");
        context.append("- **Severity**: Critical/High/Medium/Low\n");
        context.append("- **Description**: Detailed explanation\n");
        context.append("- **Exploitation**: How it could be exploited\n");
        context.append("- **Mitigation**: Recommended fix\n");

        List<McpSchema.PromptMessage> messages = new ArrayList<>();
        messages.add(new McpSchema.PromptMessage(
            McpSchema.Role.USER,
            new McpSchema.TextContent(context.toString())
        ));

        return new McpSchema.GetPromptResult(
            "Identify vulnerabilities in: " + functionIdentifier,
            messages
        );
    }

    private boolean isDangerousFunction(String name) {
        String[] dangerous = {
            "strcpy", "strcat", "sprintf", "vsprintf", "gets", "scanf",
            "sscanf", "fscanf", "strncpy", "strncat", "memcpy", "memmove",
            "printf", "fprintf", "vprintf", "vfprintf", "syslog",
            "system", "popen", "execl", "execle", "execlp", "execv", "execve", "execvp",
            "alloca", "free", "realloc", "malloc"
        };

        for (String func : dangerous) {
            if (name.contains(func)) {
                return true;
            }
        }
        return false;
    }

    private Function findFunction(Program program, String identifier) {
        try {
            var addr = program.getAddressFactory().getAddress(identifier);
            if (addr != null) {
                return program.getFunctionManager().getFunctionAt(addr);
            }
        } catch (Exception e) {
            // Not an address
        }

        for (Function function : program.getFunctionManager().getFunctions(true)) {
            if (function.getName().equals(identifier)) {
                return function;
            }
        }
        return null;
    }

    private String decompileFunction(Program program, Function function) {
        DecompInterface decompiler = new DecompInterface();
        try {
            decompiler.openProgram(program);
            DecompileResults results = decompiler.decompileFunction(function, 30, TaskMonitor.DUMMY);
            if (results.decompileCompleted()) {
                return results.getDecompiledFunction().getC();
            }
        } finally {
            decompiler.dispose();
        }
        return null;
    }
}

```

`src/main/java/ghidrassistmcp/prompts/McpPrompt.java`:

```java
/*
 * MCP Prompt interface for pre-built analysis workflows.
 */
package ghidrassistmcp.prompts;

import java.util.List;
import java.util.Map;

import ghidra.program.model.listing.Program;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * Interface for MCP prompts that provide pre-built analysis workflows.
 */
public interface McpPrompt {

    /**
     * Get the prompt name
     */
    String getName();

    /**
     * Get the prompt description
     */
    String getDescription();

    /**
     * Get the arguments schema for this prompt
     */
    List<McpSchema.PromptArgument> getArguments();

    /**
     * Generate the prompt messages
     *
     * @param arguments The prompt arguments
     * @param program The current program context
     * @return The generated prompt messages
     */
    McpSchema.GetPromptResult generatePrompt(Map<String, String> arguments, Program program);
}

```

`src/main/java/ghidrassistmcp/prompts/McpPromptRegistry.java`:

```java
/*
 * MCP Prompt Registry for managing available prompts.
 */
package ghidrassistmcp.prompts;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * Registry for MCP prompts that can be queried by clients.
 */
public class McpPromptRegistry {

    private final Map<String, McpPrompt> prompts = new ConcurrentHashMap<>();

    /**
     * Register a prompt
     */
    public void registerPrompt(McpPrompt prompt) {
        prompts.put(prompt.getName(), prompt);
        Msg.info(this, "Registered MCP prompt: " + prompt.getName());
    }

    /**
     * Unregister a prompt
     */
    public void unregisterPrompt(String name) {
        McpPrompt removed = prompts.remove(name);
        if (removed != null) {
            Msg.info(this, "Unregistered MCP prompt: " + name);
        }
    }

    /**
     * Get a prompt by name
     */
    public McpPrompt getPrompt(String name) {
        return prompts.get(name);
    }

    /**
     * Get all registered prompts
     */
    public List<McpPrompt> getAllPrompts() {
        return new ArrayList<>(prompts.values());
    }

    /**
     * Execute a prompt and return the result
     */
    public McpSchema.GetPromptResult executePrompt(String name, Map<String, String> arguments, Program program) {
        McpPrompt prompt = prompts.get(name);
        if (prompt == null) {
            Msg.warn(this, "Prompt not found: " + name);
            return new McpSchema.GetPromptResult(
                "Error: Prompt not found: " + name,
                List.of(new McpSchema.PromptMessage(
                    McpSchema.Role.USER,
                    new McpSchema.TextContent("Error: Prompt not found: " + name)
                ))
            );
        }

        return prompt.generatePrompt(arguments, program);
    }

    /**
     * Get the number of registered prompts
     */
    public int getPromptCount() {
        return prompts.size();
    }
}

```

`src/main/java/ghidrassistmcp/prompts/TraceDataFlowPrompt.java`:

```java
/*
 * MCP Prompt for tracing data flow.
 */
package ghidrassistmcp.prompts;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import ghidra.app.decompiler.DecompInterface;
import ghidra.app.decompiler.DecompileResults;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.util.task.TaskMonitor;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * Prompt for tracing data flow through a function or variable.
 */
public class TraceDataFlowPrompt implements McpPrompt {

    @Override
    public String getName() {
        return "trace_data_flow";
    }

    @Override
    public String getDescription() {
        return "Trace data flow through a function, tracking how input data is transformed and used";
    }

    @Override
    public List<McpSchema.PromptArgument> getArguments() {
        return List.of(
            new McpSchema.PromptArgument(
                "function_name",
                "Name or address of the function to trace",
                true
            ),
            new McpSchema.PromptArgument(
                "variable",
                "Specific variable or parameter to trace (optional)",
                false
            )
        );
    }

    @Override
    public McpSchema.GetPromptResult generatePrompt(Map<String, String> arguments, Program program) {
        String functionIdentifier = arguments.get("function_name");
        String variable = arguments.get("variable");

        if (functionIdentifier == null || functionIdentifier.isEmpty()) {
            return new McpSchema.GetPromptResult(
                "Error: function_name argument is required",
                List.of(new McpSchema.PromptMessage(
                    McpSchema.Role.USER,
                    new McpSchema.TextContent("Error: function_name argument is required")
                ))
            );
        }

        StringBuilder context = new StringBuilder();
        context.append("# Data Flow Analysis Request\n\n");
        context.append("Please trace the data flow ");
        if (variable != null && !variable.isEmpty()) {
            context.append("for variable **").append(variable).append("** ");
        }
        context.append("through the following function.\n\n");

        if (program != null) {
            Function function = findFunction(program, functionIdentifier);

            if (function != null) {
                context.append("## Function Information\n");
                context.append("- **Name**: ").append(function.getName()).append("\n");
                context.append("- **Address**: ").append(function.getEntryPoint()).append("\n");
                context.append("- **Signature**: ").append(function.getPrototypeString(false, false)).append("\n\n");

                // Parameters as potential data sources
                context.append("## Input Parameters (Data Sources)\n");
                var params = function.getParameters();
                if (params.length == 0) {
                    context.append("No parameters.\n\n");
                } else {
                    for (var param : params) {
                        context.append("- **").append(param.getName()).append("**: ")
                               .append(param.getDataType().getName()).append("\n");
                    }
                    context.append("\n");
                }

                // Get decompilation
                String decompiled = decompileFunction(program, function);
                if (decompiled != null) {
                    context.append("## Decompiled Code\n```c\n");
                    context.append(decompiled);
                    context.append("\n```\n\n");
                }

                // Called functions as potential sinks
                context.append("## Called Functions (Potential Data Sinks)\n");
                var calledFunctions = function.getCalledFunctions(TaskMonitor.DUMMY);
                if (calledFunctions.isEmpty()) {
                    context.append("No functions called.\n\n");
                } else {
                    for (Function called : calledFunctions) {
                        context.append("- ").append(called.getName()).append("\n");
                    }
                    context.append("\n");
                }

            } else {
                context.append("**Error**: Function '").append(functionIdentifier).append("' not found.\n\n");
            }
        } else {
            context.append("**Note**: No program loaded. Please provide function details manually.\n\n");
        }

        context.append("## Data Flow Analysis Tasks\n");
        context.append("Please analyze and document:\n\n");
        context.append("1. **Data Sources**: Where does input data come from?\n");
        context.append("   - Parameters\n");
        context.append("   - Global variables\n");
        context.append("   - Return values from called functions\n");
        context.append("   - Memory reads\n\n");

        context.append("2. **Transformations**: How is the data modified?\n");
        context.append("   - Arithmetic operations\n");
        context.append("   - Type conversions\n");
        context.append("   - String manipulations\n");
        context.append("   - Encoding/decoding\n\n");

        context.append("3. **Data Sinks**: Where does the data go?\n");
        context.append("   - Function calls (which parameter?)\n");
        context.append("   - Memory writes\n");
        context.append("   - Return values\n");
        context.append("   - Global variable assignments\n\n");

        context.append("4. **Taint Analysis**: If user-controlled data enters, where can it flow?\n");
        context.append("   - Identify tainted variables\n");
        context.append("   - Track propagation through operations\n");
        context.append("   - Note any sanitization points\n\n");

        context.append("5. **Data Flow Graph**: Describe the flow as a graph of:\n");
        context.append("   - Nodes (variables, memory locations)\n");
        context.append("   - Edges (data dependencies)\n");

        if (variable != null && !variable.isEmpty()) {
            context.append("\n## Specific Variable: ").append(variable).append("\n");
            context.append("Focus specifically on tracing this variable through the function:\n");
            context.append("- Where is it defined/assigned?\n");
            context.append("- What operations are performed on it?\n");
            context.append("- Where is it used?\n");
            context.append("- What is its final state/destination?\n");
        }

        List<McpSchema.PromptMessage> messages = new ArrayList<>();
        messages.add(new McpSchema.PromptMessage(
            McpSchema.Role.USER,
            new McpSchema.TextContent(context.toString())
        ));

        return new McpSchema.GetPromptResult(
            "Trace data flow: " + functionIdentifier + (variable != null ? " (var: " + variable + ")" : ""),
            messages
        );
    }

    private Function findFunction(Program program, String identifier) {
        try {
            var addr = program.getAddressFactory().getAddress(identifier);
            if (addr != null) {
                return program.getFunctionManager().getFunctionAt(addr);
            }
        } catch (Exception e) {
            // Not an address
        }

        for (Function function : program.getFunctionManager().getFunctions(true)) {
            if (function.getName().equals(identifier)) {
                return function;
            }
        }
        return null;
    }

    private String decompileFunction(Program program, Function function) {
        DecompInterface decompiler = new DecompInterface();
        try {
            decompiler.openProgram(program);
            DecompileResults results = decompiler.decompileFunction(function, 30, TaskMonitor.DUMMY);
            if (results.decompileCompleted()) {
                return results.getDecompiledFunction().getC();
            }
        } finally {
            decompiler.dispose();
        }
        return null;
    }
}

```

`src/main/java/ghidrassistmcp/prompts/TraceNetworkDataPrompt.java`:

```java
/*
 * MCP Prompt for tracing network data flows.
 */
package ghidrassistmcp.prompts;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import ghidra.app.decompiler.DecompInterface;
import ghidra.app.decompiler.DecompileResults;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Reference;
import ghidra.program.model.symbol.ReferenceIterator;
import ghidra.program.model.symbol.Symbol;
import ghidra.program.model.symbol.SymbolIterator;
import ghidra.program.model.symbol.SymbolTable;
import ghidra.util.task.TaskMonitor;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * Prompt for tracing network send/recv call stacks to analyze protocol
 * payload data structures and identify network-related vulnerabilities.
 * Supports both POSIX and Winsock network APIs.
 */
public class TraceNetworkDataPrompt implements McpPrompt {

    // POSIX network functions
    private static final String[] POSIX_SEND_FUNCTIONS = {
        "send", "sendto", "sendmsg", "write", "writev", "sendfile",
        "SSL_write", "gnutls_record_send", "BIO_write"
    };

    private static final String[] POSIX_RECV_FUNCTIONS = {
        "recv", "recvfrom", "recvmsg", "read", "readv",
        "SSL_read", "gnutls_record_recv", "BIO_read"
    };

    private static final String[] POSIX_SOCKET_FUNCTIONS = {
        "socket", "connect", "bind", "listen", "accept", "accept4",
        "shutdown", "close", "getsockopt", "setsockopt",
        "getpeername", "getsockname", "socketpair"
    };

    // Winsock network functions
    private static final String[] WINSOCK_SEND_FUNCTIONS = {
        "send", "sendto", "WSASend", "WSASendTo", "WSASendMsg",
        "WSASendDisconnect", "TransmitFile", "TransmitPackets"
    };

    private static final String[] WINSOCK_RECV_FUNCTIONS = {
        "recv", "recvfrom", "WSARecv", "WSARecvFrom", "WSARecvMsg",
        "WSARecvDisconnect"
    };

    private static final String[] WINSOCK_SOCKET_FUNCTIONS = {
        "socket", "WSASocket", "WSASocketA", "WSASocketW",
        "connect", "WSAConnect", "WSAConnectByName", "WSAConnectByList",
        "bind", "listen", "accept", "WSAAccept",
        "shutdown", "closesocket", "WSACleanup", "WSAStartup",
        "getsockopt", "setsockopt", "ioctlsocket", "WSAIoctl",
        "getpeername", "getsockname", "select", "WSAPoll",
        "WSAAsyncSelect", "WSAEventSelect"
    };

    // Network-related dangerous patterns
    private static final String[] NETWORK_DANGEROUS_FUNCTIONS = {
        "strcpy", "strcat", "sprintf", "vsprintf", "gets",
        "memcpy", "memmove", "bcopy",
        "atoi", "atol", "strtol", "strtoul",  // Integer parsing from network data
        "ntohl", "ntohs", "htonl", "htons"     // Byte order conversion
    };

    @Override
    public String getName() {
        return "trace_network_data";
    }

    @Override
    public String getDescription() {
        return "Trace network send/recv call stacks for POSIX and Winsock APIs to analyze " +
               "protocol payload data structures and identify network-related vulnerabilities";
    }

    @Override
    public List<McpSchema.PromptArgument> getArguments() {
        return List.of(
            new McpSchema.PromptArgument(
                "function_name",
                "Name or address of a specific function to analyze (optional - if not provided, analyzes all network functions)",
                false
            ),
            new McpSchema.PromptArgument(
                "direction",
                "Filter by direction: 'send', 'recv', or 'both' (default: both)",
                false
            ),
            new McpSchema.PromptArgument(
                "api",
                "Filter by API: 'posix', 'winsock', or 'both' (default: both)",
                false
            )
        );
    }

    @Override
    public McpSchema.GetPromptResult generatePrompt(Map<String, String> arguments, Program program) {
        String functionIdentifier = arguments.get("function_name");
        String direction = arguments.getOrDefault("direction", "both").toLowerCase();
        String api = arguments.getOrDefault("api", "both").toLowerCase();

        StringBuilder context = new StringBuilder();
        context.append("# Network Data Flow Analysis Request\n\n");
        context.append("Analyze network send/recv operations to understand protocol payload ");
        context.append("data structures and identify potential network-related vulnerabilities.\n\n");

        if (program != null) {
            // Find network functions in the program
            Map<String, List<Function>> networkFunctions = findNetworkFunctions(program, direction, api);

            if (functionIdentifier != null && !functionIdentifier.isEmpty()) {
                // Analyze a specific function's relationship to network operations
                Function targetFunction = findFunction(program, functionIdentifier);
                if (targetFunction != null) {
                    context.append("## Target Function Analysis\n");
                    context.append("- **Name**: ").append(targetFunction.getName()).append("\n");
                    context.append("- **Address**: ").append(targetFunction.getEntryPoint()).append("\n");
                    context.append("- **Signature**: ").append(targetFunction.getPrototypeString(false, false)).append("\n\n");

                    // Decompile the target function
                    String decompiled = decompileFunction(program, targetFunction);
                    if (decompiled != null) {
                        context.append("### Decompiled Code\n```c\n");
                        context.append(decompiled);
                        context.append("\n```\n\n");
                    }

                    // Find network functions called by this function
                    context.append("### Network Functions Called\n");
                    appendCalledNetworkFunctions(context, targetFunction, networkFunctions, program);
                } else {
                    context.append("**Warning**: Function '").append(functionIdentifier).append("' not found.\n\n");
                }
            }

            // List discovered network functions
            context.append("## Discovered Network Functions in Binary\n\n");
            appendNetworkFunctionSummary(context, networkFunctions, program);

            // Find callers of network functions (call stack analysis)
            context.append("## Network Function Call Stacks\n\n");
            appendCallStackAnalysis(context, networkFunctions, program);

        } else {
            context.append("**Note**: No program loaded. Please provide function details manually.\n\n");
        }

        // Analysis guidance
        appendAnalysisGuidance(context);

        List<McpSchema.PromptMessage> messages = new ArrayList<>();
        messages.add(new McpSchema.PromptMessage(
            McpSchema.Role.USER,
            new McpSchema.TextContent(context.toString())
        ));

        String description = "Trace network data";
        if (functionIdentifier != null && !functionIdentifier.isEmpty()) {
            description += " for: " + functionIdentifier;
        }

        return new McpSchema.GetPromptResult(description, messages);
    }

    private Map<String, List<Function>> findNetworkFunctions(Program program, String direction, String api) {
        Map<String, List<Function>> result = new LinkedHashMap<>();
        result.put("send", new ArrayList<>());
        result.put("recv", new ArrayList<>());
        result.put("socket", new ArrayList<>());

        Set<String> sendFuncs = new HashSet<>();
        Set<String> recvFuncs = new HashSet<>();
        Set<String> socketFuncs = new HashSet<>();

        // Add functions based on API filter
        if (api.equals("posix") || api.equals("both")) {
            if (direction.equals("send") || direction.equals("both")) {
                for (String f : POSIX_SEND_FUNCTIONS) sendFuncs.add(f);
            }
            if (direction.equals("recv") || direction.equals("both")) {
                for (String f : POSIX_RECV_FUNCTIONS) recvFuncs.add(f);
            }
            for (String f : POSIX_SOCKET_FUNCTIONS) socketFuncs.add(f);
        }

        if (api.equals("winsock") || api.equals("both")) {
            if (direction.equals("send") || direction.equals("both")) {
                for (String f : WINSOCK_SEND_FUNCTIONS) sendFuncs.add(f);
            }
            if (direction.equals("recv") || direction.equals("both")) {
                for (String f : WINSOCK_RECV_FUNCTIONS) recvFuncs.add(f);
            }
            for (String f : WINSOCK_SOCKET_FUNCTIONS) socketFuncs.add(f);
        }

        // Search for functions in the program
        SymbolTable symbolTable = program.getSymbolTable();
        SymbolIterator symbols = symbolTable.getAllSymbols(true);

        while (symbols.hasNext()) {
            Symbol symbol = symbols.next();
            String name = symbol.getName();

            // Check if it's a function
            Function func = program.getFunctionManager().getFunctionAt(symbol.getAddress());
            if (func == null) {
                func = program.getFunctionManager().getReferencedFunction(symbol.getAddress());
            }

            if (func != null || symbol.isExternal()) {
                if (sendFuncs.contains(name)) {
                    result.get("send").add(func != null ? func : createPlaceholderFunction(name, symbol));
                } else if (recvFuncs.contains(name)) {
                    result.get("recv").add(func != null ? func : createPlaceholderFunction(name, symbol));
                } else if (socketFuncs.contains(name)) {
                    result.get("socket").add(func != null ? func : createPlaceholderFunction(name, symbol));
                }
            }
        }

        return result;
    }

    private Function createPlaceholderFunction(String name, Symbol symbol) {
        // For external functions, we return null but track via symbol
        return null;
    }

    private void appendNetworkFunctionSummary(StringBuilder context, Map<String, List<Function>> networkFunctions, Program program) {
        SymbolTable symbolTable = program.getSymbolTable();

        context.append("### Send Functions\n");
        if (networkFunctions.get("send").isEmpty()) {
            // Check for external symbols
            List<String> externalSend = findExternalNetworkSymbols(symbolTable, POSIX_SEND_FUNCTIONS, WINSOCK_SEND_FUNCTIONS);
            if (externalSend.isEmpty()) {
                context.append("No send functions found.\n\n");
            } else {
                for (String name : externalSend) {
                    context.append("- **").append(name).append("** (external/imported)\n");
                }
                context.append("\n");
            }
        } else {
            for (Function func : networkFunctions.get("send")) {
                if (func != null) {
                    context.append("- **").append(func.getName()).append("** @ ").append(func.getEntryPoint()).append("\n");
                }
            }
            context.append("\n");
        }

        context.append("### Recv Functions\n");
        if (networkFunctions.get("recv").isEmpty()) {
            List<String> externalRecv = findExternalNetworkSymbols(symbolTable, POSIX_RECV_FUNCTIONS, WINSOCK_RECV_FUNCTIONS);
            if (externalRecv.isEmpty()) {
                context.append("No recv functions found.\n\n");
            } else {
                for (String name : externalRecv) {
                    context.append("- **").append(name).append("** (external/imported)\n");
                }
                context.append("\n");
            }
        } else {
            for (Function func : networkFunctions.get("recv")) {
                if (func != null) {
                    context.append("- **").append(func.getName()).append("** @ ").append(func.getEntryPoint()).append("\n");
                }
            }
            context.append("\n");
        }

        context.append("### Socket Management Functions\n");
        if (networkFunctions.get("socket").isEmpty()) {
            List<String> externalSocket = findExternalNetworkSymbols(symbolTable, POSIX_SOCKET_FUNCTIONS, WINSOCK_SOCKET_FUNCTIONS);
            if (externalSocket.isEmpty()) {
                context.append("No socket functions found.\n\n");
            } else {
                for (String name : externalSocket) {
                    context.append("- **").append(name).append("** (external/imported)\n");
                }
                context.append("\n");
            }
        } else {
            for (Function func : networkFunctions.get("socket")) {
                if (func != null) {
                    context.append("- **").append(func.getName()).append("** @ ").append(func.getEntryPoint()).append("\n");
                }
            }
            context.append("\n");
        }
    }

    private List<String> findExternalNetworkSymbols(SymbolTable symbolTable, String[]... functionArrays) {
        List<String> found = new ArrayList<>();
        Set<String> targetNames = new HashSet<>();

        for (String[] arr : functionArrays) {
            for (String name : arr) {
                targetNames.add(name);
            }
        }

        SymbolIterator symbols = symbolTable.getAllSymbols(true);
        while (symbols.hasNext()) {
            Symbol symbol = symbols.next();
            if (targetNames.contains(symbol.getName())) {
                found.add(symbol.getName());
            }
        }

        return found;
    }

    private void appendCalledNetworkFunctions(StringBuilder context, Function targetFunction,
                                              Map<String, List<Function>> networkFunctions, Program program) {
        Set<String> allNetworkNames = new HashSet<>();

        for (String f : POSIX_SEND_FUNCTIONS) allNetworkNames.add(f);
        for (String f : POSIX_RECV_FUNCTIONS) allNetworkNames.add(f);
        for (String f : POSIX_SOCKET_FUNCTIONS) allNetworkNames.add(f);
        for (String f : WINSOCK_SEND_FUNCTIONS) allNetworkNames.add(f);
        for (String f : WINSOCK_RECV_FUNCTIONS) allNetworkNames.add(f);
        for (String f : WINSOCK_SOCKET_FUNCTIONS) allNetworkNames.add(f);

        var calledFunctions = targetFunction.getCalledFunctions(TaskMonitor.DUMMY);
        boolean foundNetwork = false;

        for (Function called : calledFunctions) {
            if (allNetworkNames.contains(called.getName())) {
                String category = categorizeNetworkFunction(called.getName());
                context.append("- **").append(called.getName()).append("** (").append(category).append(") @ ")
                       .append(called.getEntryPoint()).append("\n");
                foundNetwork = true;
            }
        }

        if (!foundNetwork) {
            context.append("No direct network function calls found. This function may be part of a call chain.\n");
        }
        context.append("\n");
    }

    private String categorizeNetworkFunction(String name) {
        for (String f : POSIX_SEND_FUNCTIONS) if (f.equals(name)) return "POSIX send";
        for (String f : POSIX_RECV_FUNCTIONS) if (f.equals(name)) return "POSIX recv";
        for (String f : POSIX_SOCKET_FUNCTIONS) if (f.equals(name)) return "POSIX socket";
        for (String f : WINSOCK_SEND_FUNCTIONS) if (f.equals(name)) return "Winsock send";
        for (String f : WINSOCK_RECV_FUNCTIONS) if (f.equals(name)) return "Winsock recv";
        for (String f : WINSOCK_SOCKET_FUNCTIONS) if (f.equals(name)) return "Winsock socket";
        return "network";
    }

    private void appendCallStackAnalysis(StringBuilder context, Map<String, List<Function>> networkFunctions, Program program) {
        SymbolTable symbolTable = program.getSymbolTable();

        // Find callers of send functions
        context.append("### Functions Calling Send Operations\n");
        appendCallersForCategory(context, "send", symbolTable, program, POSIX_SEND_FUNCTIONS, WINSOCK_SEND_FUNCTIONS);

        context.append("### Functions Calling Recv Operations\n");
        appendCallersForCategory(context, "recv", symbolTable, program, POSIX_RECV_FUNCTIONS, WINSOCK_RECV_FUNCTIONS);
    }

    private void appendCallersForCategory(StringBuilder context, String category, SymbolTable symbolTable,
                                          Program program, String[]... functionArrays) {
        Set<String> targetNames = new HashSet<>();
        for (String[] arr : functionArrays) {
            for (String name : arr) {
                targetNames.add(name);
            }
        }

        Set<String> callerNames = new HashSet<>();
        SymbolIterator symbols = symbolTable.getAllSymbols(true);

        while (symbols.hasNext()) {
            Symbol symbol = symbols.next();
            if (targetNames.contains(symbol.getName())) {
                // Find references to this symbol
                ReferenceIterator refs = program.getReferenceManager().getReferencesTo(symbol.getAddress());
                while (refs.hasNext()) {
                    Reference ref = refs.next();
                    Function callerFunc = program.getFunctionManager().getFunctionContaining(ref.getFromAddress());
                    if (callerFunc != null && !callerFunc.isThunk()) {
                        callerNames.add(callerFunc.getName() + " @ " + callerFunc.getEntryPoint());
                    }
                }
            }
        }

        if (callerNames.isEmpty()) {
            context.append("No direct callers found (may be dynamically resolved).\n\n");
        } else {
            for (String caller : callerNames) {
                context.append("- ").append(caller).append("\n");
            }
            context.append("\n");
        }
    }

    private void appendAnalysisGuidance(StringBuilder context) {
        context.append("## Protocol Payload Analysis Tasks\n\n");

        context.append("### 1. Data Structure Identification\n");
        context.append("Analyze the buffer parameters passed to send/recv functions:\n");
        context.append("- Identify the buffer type and size\n");
        context.append("- Look for structure definitions used as network payloads\n");
        context.append("- Track buffer allocations and their sizes\n");
        context.append("- Identify any serialization/deserialization routines\n\n");

        context.append("### 2. Protocol Format Analysis\n");
        context.append("Determine the network protocol structure:\n");
        context.append("- **Header Format**: Fixed-size headers, length fields, magic bytes\n");
        context.append("- **Payload Format**: TLV (Type-Length-Value), fixed structures, variable data\n");
        context.append("- **Encoding**: Binary, text-based (HTTP, JSON), encrypted, compressed\n");
        context.append("- **Byte Order**: Network byte order (big-endian) vs host byte order\n");
        context.append("- **Framing**: Message boundaries, delimiters, length-prefixed\n\n");

        context.append("### 3. Data Flow Tracing\n");
        context.append("Track how network data flows through the application:\n");
        context.append("- **Recv Path**: recv() -> parsing -> validation -> processing -> storage\n");
        context.append("- **Send Path**: data creation -> serialization -> send()\n");
        context.append("- Identify intermediate buffers and transformations\n");
        context.append("- Note any encryption/decryption or encoding/decoding steps\n\n");

        context.append("### 4. Network Security Vulnerability Analysis\n\n");

        context.append("#### Buffer Overflow Vulnerabilities\n");
        context.append("- Check if recv() length parameter is properly bounded\n");
        context.append("- Verify buffer size matches or exceeds received data\n");
        context.append("- Look for fixed-size buffers receiving variable-length network data\n");
        context.append("- Check for integer overflow in length calculations\n\n");

        context.append("#### Input Validation Issues\n");
        context.append("- Is received data validated before use?\n");
        context.append("- Are length fields from network data trusted without validation?\n");
        context.append("- Are there bounds checks on array indices from network data?\n");
        context.append("- Is there proper null-termination handling for strings?\n\n");

        context.append("#### Integer Handling Issues\n");
        context.append("- Check for integer overflow when parsing length fields\n");
        context.append("- Verify proper use of ntohl/ntohs for byte order conversion\n");
        context.append("- Look for signed/unsigned confusion in size calculations\n\n");

        context.append("#### Memory Safety Issues\n");
        context.append("- Double-free on connection errors\n");
        context.append("- Use-after-free in async network handlers\n");
        context.append("- Memory leaks on partial message handling\n");
        context.append("- Uninitialized memory sent over network\n\n");

        context.append("#### Protocol-Level Vulnerabilities\n");
        context.append("- Command injection in protocol handlers\n");
        context.append("- Path traversal in file transfer protocols\n");
        context.append("- Authentication/authorization bypass\n");
        context.append("- Session fixation or hijacking\n");
        context.append("- Replay attack susceptibility\n\n");

        context.append("### 5. Output Format\n");
        context.append("For network protocol analysis, provide:\n");
        context.append("- **Protocol Structure Diagram**: Visual representation of message format\n");
        context.append("- **Data Type Definitions**: C struct definitions for protocol messages\n");
        context.append("- **State Machine**: Connection/protocol state transitions\n");
        context.append("- **Vulnerability Report**: Any security issues found with severity ratings\n");
    }

    private Function findFunction(Program program, String identifier) {
        try {
            var addr = program.getAddressFactory().getAddress(identifier);
            if (addr != null) {
                return program.getFunctionManager().getFunctionAt(addr);
            }
        } catch (Exception e) {
            // Not an address
        }

        for (Function function : program.getFunctionManager().getFunctions(true)) {
            if (function.getName().equals(identifier)) {
                return function;
            }
        }
        return null;
    }

    private String decompileFunction(Program program, Function function) {
        DecompInterface decompiler = new DecompInterface();
        try {
            decompiler.openProgram(program);
            DecompileResults results = decompiler.decompileFunction(function, 30, TaskMonitor.DUMMY);
            if (results.decompileCompleted()) {
                return results.getDecompiledFunction().getC();
            }
        } finally {
            decompiler.dispose();
        }
        return null;
    }
}

```

`src/main/java/ghidrassistmcp/resources/ExportsResource.java`:

```java
/*
 * MCP Resource for exports table.
 */
package ghidrassistmcp.resources;

import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;

import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Symbol;

/**
 * Resource that provides the export table from the program.
 */
public class ExportsResource implements McpResource {

    private static final Pattern URI_PATTERN = Pattern.compile("ghidra://program/([^/]+)/exports");
    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public String getUriPattern() {
        return "ghidra://program/{name}/exports";
    }

    @Override
    public String getName() {
        return "exports";
    }

    @Override
    public String getDescription() {
        return "Export table from the program";
    }

    @Override
    public String getMimeType() {
        return "application/json";
    }

    @Override
    public boolean canHandle(String uri) {
        return URI_PATTERN.matcher(uri).matches();
    }

    @Override
    public Map<String, String> extractParams(String uri) {
        Map<String, String> params = new HashMap<>();
        Matcher matcher = URI_PATTERN.matcher(uri);
        if (matcher.matches()) {
            params.put("name", matcher.group(1));
        }
        return params;
    }

    @Override
    public String readContent(Program program, Map<String, String> uriParams) {
        if (program == null) {
            return "{\"error\": \"No program loaded\"}";
        }

        try {
            ObjectNode json = objectMapper.createObjectNode();
            json.put("program", program.getName());

            ArrayNode exportsArray = objectMapper.createArrayNode();
            int count = 0;

            // Get exported functions (entry points marked as global)
            for (Function function : program.getFunctionManager().getFunctions(true)) {
                Symbol symbol = function.getSymbol();
                if (symbol != null && symbol.isGlobal() && !symbol.isExternal()) {
                    // Check if it's an entry point or explicitly exported
                    boolean isEntryPoint = program.getSymbolTable().isExternalEntryPoint(function.getEntryPoint());

                    if (isEntryPoint || function.getEntryPoint().equals(program.getMinAddress())) {
                        ObjectNode exportNode = objectMapper.createObjectNode();
                        exportNode.put("name", function.getName());
                        exportNode.put("address", function.getEntryPoint().toString());
                        exportNode.put("signature", function.getPrototypeString(false, false));
                        exportNode.put("is_entry_point", isEntryPoint);

                        exportsArray.add(exportNode);
                        count++;
                    }
                }
            }

            json.put("count", count);
            json.set("exports", exportsArray);

            return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(json);

        } catch (Exception e) {
            return "{\"error\": \"" + e.getMessage() + "\"}";
        }
    }
}

```

`src/main/java/ghidrassistmcp/resources/FunctionListResource.java`:

```java
/*
 * MCP Resource for function list.
 */
package ghidrassistmcp.resources;

import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;

import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;

/**
 * Resource that provides a list of all functions in the program.
 */
public class FunctionListResource implements McpResource {

    private static final Pattern URI_PATTERN = Pattern.compile("ghidra://program/([^/]+)/functions");
    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public String getUriPattern() {
        return "ghidra://program/{name}/functions";
    }

    @Override
    public String getName() {
        return "function_list";
    }

    @Override
    public String getDescription() {
        return "List of all functions in the program with addresses and signatures";
    }

    @Override
    public String getMimeType() {
        return "application/json";
    }

    @Override
    public boolean canHandle(String uri) {
        return URI_PATTERN.matcher(uri).matches();
    }

    @Override
    public Map<String, String> extractParams(String uri) {
        Map<String, String> params = new HashMap<>();
        Matcher matcher = URI_PATTERN.matcher(uri);
        if (matcher.matches()) {
            params.put("name", matcher.group(1));
        }
        return params;
    }

    @Override
    public String readContent(Program program, Map<String, String> uriParams) {
        if (program == null) {
            return "{\"error\": \"No program loaded\"}";
        }

        try {
            ObjectNode json = objectMapper.createObjectNode();
            json.put("program", program.getName());

            ArrayNode functionsArray = objectMapper.createArrayNode();
            int count = 0;

            for (Function function : program.getFunctionManager().getFunctions(true)) {
                ObjectNode funcNode = objectMapper.createObjectNode();
                funcNode.put("name", function.getName());
                funcNode.put("address", function.getEntryPoint().toString());
                funcNode.put("signature", function.getPrototypeString(false, false));
                funcNode.put("is_thunk", function.isThunk());
                funcNode.put("is_external", function.isExternal());
                funcNode.put("param_count", function.getParameterCount());

                if (function.getComment() != null) {
                    funcNode.put("comment", function.getComment());
                }

                functionsArray.add(funcNode);
                count++;
            }

            json.put("count", count);
            json.set("functions", functionsArray);

            return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(json);

        } catch (Exception e) {
            return "{\"error\": \"" + e.getMessage() + "\"}";
        }
    }
}

```

`src/main/java/ghidrassistmcp/resources/ImportsResource.java`:

```java
/*
 * MCP Resource for imports table.
 */
package ghidrassistmcp.resources;

import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;

import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Symbol;
import ghidra.program.model.symbol.SymbolIterator;
import ghidra.program.model.symbol.SymbolType;

/**
 * Resource that provides the import table from the program.
 */
public class ImportsResource implements McpResource {

    private static final Pattern URI_PATTERN = Pattern.compile("ghidra://program/([^/]+)/imports");
    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public String getUriPattern() {
        return "ghidra://program/{name}/imports";
    }

    @Override
    public String getName() {
        return "imports";
    }

    @Override
    public String getDescription() {
        return "Import table from the program";
    }

    @Override
    public String getMimeType() {
        return "application/json";
    }

    @Override
    public boolean canHandle(String uri) {
        return URI_PATTERN.matcher(uri).matches();
    }

    @Override
    public Map<String, String> extractParams(String uri) {
        Map<String, String> params = new HashMap<>();
        Matcher matcher = URI_PATTERN.matcher(uri);
        if (matcher.matches()) {
            params.put("name", matcher.group(1));
        }
        return params;
    }

    @Override
    public String readContent(Program program, Map<String, String> uriParams) {
        if (program == null) {
            return "{\"error\": \"No program loaded\"}";
        }

        try {
            ObjectNode json = objectMapper.createObjectNode();
            json.put("program", program.getName());

            ArrayNode importsArray = objectMapper.createArrayNode();
            int count = 0;

            SymbolIterator symbolIter = program.getSymbolTable().getSymbolIterator();
            while (symbolIter.hasNext()) {
                Symbol symbol = symbolIter.next();

                if (symbol.isExternal() &&
                    (symbol.getSymbolType() == SymbolType.FUNCTION ||
                     symbol.getSymbolType() == SymbolType.LABEL)) {

                    ObjectNode importNode = objectMapper.createObjectNode();
                    importNode.put("name", symbol.getName());
                    importNode.put("address", symbol.getAddress().toString());
                    importNode.put("type", symbol.getSymbolType().toString());

                    if (symbol.getParentNamespace() != null) {
                        importNode.put("library", symbol.getParentNamespace().getName());
                    }

                    importsArray.add(importNode);
                    count++;
                }
            }

            json.put("count", count);
            json.set("imports", importsArray);

            return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(json);

        } catch (Exception e) {
            return "{\"error\": \"" + e.getMessage() + "\"}";
        }
    }
}

```

`src/main/java/ghidrassistmcp/resources/McpResource.java`:

```java
/*
 * MCP Resource interface for exposing Ghidra program data.
 */
package ghidrassistmcp.resources;

import ghidra.program.model.listing.Program;

/**
 * Interface for MCP resources that expose Ghidra program data.
 */
public interface McpResource {

    /**
     * Get the URI pattern for this resource (e.g., "ghidra://program/{name}/info")
     */
    String getUriPattern();

    /**
     * Get the resource name
     */
    String getName();

    /**
     * Get the resource description
     */
    String getDescription();

    /**
     * Get the MIME type of the resource content
     */
    String getMimeType();

    /**
     * Read the resource content for the given program
     *
     * @param program The Ghidra program to read data from
     * @param uriParams Parameters extracted from the URI (e.g., program name)
     * @return The resource content as a string
     */
    String readContent(Program program, java.util.Map<String, String> uriParams);

    /**
     * Check if this resource can handle the given URI
     *
     * @param uri The URI to check
     * @return true if this resource can handle the URI
     */
    boolean canHandle(String uri);

    /**
     * Extract parameters from a URI matching this resource's pattern
     *
     * @param uri The URI to parse
     * @return A map of parameter names to values
     */
    java.util.Map<String, String> extractParams(String uri);
}

```

`src/main/java/ghidrassistmcp/resources/McpResourceRegistry.java`:

```java
/*
 * MCP Resource Registry for managing available resources.
 */
package ghidrassistmcp.resources;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import ghidra.program.model.listing.Program;
import ghidra.util.Msg;

/**
 * Registry for MCP resources that can be queried by clients.
 */
public class McpResourceRegistry {

    private final Map<String, McpResource> resources = new ConcurrentHashMap<>();

    /**
     * Register a resource
     */
    public void registerResource(McpResource resource) {
        resources.put(resource.getName(), resource);
        Msg.info(this, "Registered MCP resource: " + resource.getName() + " (" + resource.getUriPattern() + ")");
    }

    /**
     * Unregister a resource
     */
    public void unregisterResource(String name) {
        McpResource removed = resources.remove(name);
        if (removed != null) {
            Msg.info(this, "Unregistered MCP resource: " + name);
        }
    }

    /**
     * Get all registered resources
     */
    public List<McpResource> getAllResources() {
        return new ArrayList<>(resources.values());
    }

    /**
     * Find a resource that can handle the given URI
     */
    public McpResource findResource(String uri) {
        for (McpResource resource : resources.values()) {
            if (resource.canHandle(uri)) {
                return resource;
            }
        }
        return null;
    }

    /**
     * Read content from a resource by URI
     *
     * @param uri The resource URI
     * @param program The current program
     * @return The resource content or null if not found
     */
    public String readResource(String uri, Program program) {
        McpResource resource = findResource(uri);
        if (resource == null) {
            Msg.warn(this, "No resource found for URI: " + uri);
            return null;
        }

        Map<String, String> params = resource.extractParams(uri);
        return resource.readContent(program, params);
    }

    /**
     * Get the number of registered resources
     */
    public int getResourceCount() {
        return resources.size();
    }
}

```

`src/main/java/ghidrassistmcp/resources/ProgramInfoResource.java`:

```java
/*
 * MCP Resource for program information.
 */
package ghidrassistmcp.resources;

import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;

import ghidra.program.model.listing.Program;

/**
 * Resource that provides program metadata and information.
 */
public class ProgramInfoResource implements McpResource {

    private static final Pattern URI_PATTERN = Pattern.compile("ghidra://program/([^/]+)/info");
    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public String getUriPattern() {
        return "ghidra://program/{name}/info";
    }

    @Override
    public String getName() {
        return "program_info";
    }

    @Override
    public String getDescription() {
        return "Program metadata including name, path, language, compiler, and memory information";
    }

    @Override
    public String getMimeType() {
        return "application/json";
    }

    @Override
    public boolean canHandle(String uri) {
        return URI_PATTERN.matcher(uri).matches();
    }

    @Override
    public Map<String, String> extractParams(String uri) {
        Map<String, String> params = new HashMap<>();
        Matcher matcher = URI_PATTERN.matcher(uri);
        if (matcher.matches()) {
            params.put("name", matcher.group(1));
        }
        return params;
    }

    @Override
    public String readContent(Program program, Map<String, String> uriParams) {
        if (program == null) {
            return "{\"error\": \"No program loaded\"}";
        }

        try {
            ObjectNode json = objectMapper.createObjectNode();
            json.put("name", program.getName());
            json.put("path", program.getExecutablePath());
            json.put("format", program.getExecutableFormat());

            // Language info
            var language = program.getLanguage();
            ObjectNode langNode = objectMapper.createObjectNode();
            langNode.put("id", language.getLanguageID().toString());
            langNode.put("processor", language.getProcessor().toString());
            langNode.put("endian", language.isBigEndian() ? "big" : "little");
            langNode.put("size", language.getLanguageDescription().getSize());
            json.set("language", langNode);

            // Compiler info
            var compilerSpec = program.getCompilerSpec();
            ObjectNode compilerNode = objectMapper.createObjectNode();
            compilerNode.put("id", compilerSpec.getCompilerSpecID().toString());
            json.set("compiler", compilerNode);

            // Memory info
            var memory = program.getMemory();
            ObjectNode memNode = objectMapper.createObjectNode();
            memNode.put("num_blocks", memory.getNumAddressRanges());
            memNode.put("min_address", memory.getMinAddress().toString());
            memNode.put("max_address", memory.getMaxAddress().toString());
            json.set("memory", memNode);

            // Analysis info
            ObjectNode analysisNode = objectMapper.createObjectNode();
            analysisNode.put("function_count", program.getFunctionManager().getFunctionCount());
            analysisNode.put("symbol_count", program.getSymbolTable().getNumSymbols());
            json.set("analysis", analysisNode);

            // Timestamps
            json.put("creation_date", program.getCreationDate().toString());
            json.put("modification_number", program.getModificationNumber());

            return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(json);

        } catch (Exception e) {
            return "{\"error\": \"" + e.getMessage() + "\"}";
        }
    }
}

```

`src/main/java/ghidrassistmcp/resources/StringsResource.java`:

```java
/*
 * MCP Resource for strings table.
 */
package ghidrassistmcp.resources;

import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;

import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.DataIterator;
import ghidra.program.model.listing.Program;

/**
 * Resource that provides the string table from the program.
 */
public class StringsResource implements McpResource {

    private static final Pattern URI_PATTERN = Pattern.compile("ghidra://program/([^/]+)/strings");
    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public String getUriPattern() {
        return "ghidra://program/{name}/strings";
    }

    @Override
    public String getName() {
        return "strings";
    }

    @Override
    public String getDescription() {
        return "String table from the program";
    }

    @Override
    public String getMimeType() {
        return "application/json";
    }

    @Override
    public boolean canHandle(String uri) {
        return URI_PATTERN.matcher(uri).matches();
    }

    @Override
    public Map<String, String> extractParams(String uri) {
        Map<String, String> params = new HashMap<>();
        Matcher matcher = URI_PATTERN.matcher(uri);
        if (matcher.matches()) {
            params.put("name", matcher.group(1));
        }
        return params;
    }

    @Override
    public String readContent(Program program, Map<String, String> uriParams) {
        if (program == null) {
            return "{\"error\": \"No program loaded\"}";
        }

        try {
            ObjectNode json = objectMapper.createObjectNode();
            json.put("program", program.getName());

            ArrayNode stringsArray = objectMapper.createArrayNode();
            int count = 0;

            DataIterator dataIter = program.getListing().getDefinedData(true);
            while (dataIter.hasNext()) {
                Data data = dataIter.next();

                if (data.hasStringValue()) {
                    String stringValue = data.getDefaultValueRepresentation();
                    String stringText = extractStringText(stringValue);

                    if (stringText != null && stringText.length() >= 4) {
                        ObjectNode stringNode = objectMapper.createObjectNode();
                        stringNode.put("address", data.getAddress().toString());
                        stringNode.put("value", stringText);
                        stringNode.put("length", stringText.length());
                        stringNode.put("type", data.getDataType().getName());

                        stringsArray.add(stringNode);
                        count++;
                    }
                }
            }

            json.put("count", count);
            json.set("strings", stringsArray);

            return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(json);

        } catch (Exception e) {
            return "{\"error\": \"" + e.getMessage() + "\"}";
        }
    }

    private static String extractStringText(String defaultValueRepresentation) {
        if (defaultValueRepresentation == null) {
            return null;
        }
        int firstQuote = defaultValueRepresentation.indexOf('"');
        int lastQuote = defaultValueRepresentation.lastIndexOf('"');
        if (firstQuote >= 0 && lastQuote > firstQuote) {
            return defaultValueRepresentation.substring(firstQuote + 1, lastQuote);
        }
        return defaultValueRepresentation;
    }
}

```

`src/main/java/ghidrassistmcp/tasks/McpTask.java`:

```java
/*
 * MCP Task state object for async task management.
 */
package ghidrassistmcp.tasks;

import java.time.Instant;
import java.util.Map;
import java.util.UUID;

import io.modelcontextprotocol.spec.McpSchema;

/**
 * Represents an asynchronous MCP task with its state and result.
 */
public class McpTask {

    /**
     * Task status enumeration
     */
    public enum Status {
        PENDING,    // Task is queued but not yet started
        RUNNING,    // Task is currently executing
        COMPLETED,  // Task completed successfully
        FAILED,     // Task failed with an error
        CANCELLED   // Task was cancelled
    }

    private final String taskId;
    private final String toolName;
    private final Map<String, Object> arguments;
    private final Instant createdAt;
    private volatile Status status;
    private volatile Instant startedAt;
    private volatile Instant completedAt;
    private volatile McpSchema.CallToolResult result;
    private volatile String errorMessage;
    private volatile int progressPercent;
    private volatile String progressMessage;

    /**
     * Create a new task
     */
    public McpTask(String toolName, Map<String, Object> arguments) {
        this.taskId = UUID.randomUUID().toString();
        this.toolName = toolName;
        this.arguments = arguments;
        this.createdAt = Instant.now();
        this.status = Status.PENDING;
        this.progressPercent = 0;
        this.progressMessage = "Waiting to start...";
    }

    // Getters

    public String getTaskId() {
        return taskId;
    }

    public String getToolName() {
        return toolName;
    }

    public Map<String, Object> getArguments() {
        return arguments;
    }

    public Instant getCreatedAt() {
        return createdAt;
    }

    public Status getStatus() {
        return status;
    }

    public Instant getStartedAt() {
        return startedAt;
    }

    public Instant getCompletedAt() {
        return completedAt;
    }

    public McpSchema.CallToolResult getResult() {
        return result;
    }

    public String getErrorMessage() {
        return errorMessage;
    }

    public int getProgressPercent() {
        return progressPercent;
    }

    public String getProgressMessage() {
        return progressMessage;
    }

    // State transition methods

    /**
     * Mark task as started
     */
    public synchronized void markStarted() {
        if (this.status == Status.PENDING) {
            this.status = Status.RUNNING;
            this.startedAt = Instant.now();
            this.progressMessage = "Running...";
        }
    }

    /**
     * Update task progress
     */
    public synchronized void updateProgress(int percent, String message) {
        if (this.status == Status.RUNNING) {
            this.progressPercent = Math.max(0, Math.min(100, percent));
            this.progressMessage = message;
        }
    }

    /**
     * Mark task as completed with result
     */
    public synchronized void markCompleted(McpSchema.CallToolResult taskResult) {
        if (this.status == Status.RUNNING || this.status == Status.PENDING) {
            this.status = Status.COMPLETED;
            this.completedAt = Instant.now();
            this.result = taskResult;
            this.progressPercent = 100;
            this.progressMessage = "Completed";
        }
    }

    /**
     * Mark task as failed with error
     */
    public synchronized void markFailed(String taskErrorMessage) {
        if (this.status == Status.RUNNING || this.status == Status.PENDING) {
            this.status = Status.FAILED;
            this.completedAt = Instant.now();
            this.errorMessage = taskErrorMessage;
            this.progressMessage = "Failed: " + taskErrorMessage;
        }
    }

    /**
     * Mark task as cancelled
     */
    public synchronized void markCancelled() {
        if (this.status == Status.PENDING || this.status == Status.RUNNING) {
            this.status = Status.CANCELLED;
            this.completedAt = Instant.now();
            this.progressMessage = "Cancelled";
        }
    }

    /**
     * Check if task is terminal (completed, failed, or cancelled)
     */
    public boolean isTerminal() {
        Status s = this.status;
        return s == Status.COMPLETED || s == Status.FAILED || s == Status.CANCELLED;
    }

    /**
     * Get duration in milliseconds (or elapsed time if still running)
     */
    public long getDurationMillis() {
        if (startedAt == null) {
            return 0;
        }
        Instant end = completedAt != null ? completedAt : Instant.now();
        return end.toEpochMilli() - startedAt.toEpochMilli();
    }

    /**
     * Generate a summary string for display
     */
    public String toSummary() {
        StringBuilder sb = new StringBuilder();
        sb.append("Task ID: ").append(taskId).append("\n");
        sb.append("Tool: ").append(toolName).append("\n");
        sb.append("Status: ").append(status).append("\n");
        sb.append("Progress: ").append(progressPercent).append("% - ").append(progressMessage).append("\n");
        sb.append("Created: ").append(createdAt).append("\n");

        if (startedAt != null) {
            sb.append("Started: ").append(startedAt).append("\n");
        }

        if (completedAt != null) {
            sb.append("Completed: ").append(completedAt).append("\n");
            sb.append("Duration: ").append(getDurationMillis()).append("ms\n");
        }

        if (errorMessage != null) {
            sb.append("Error: ").append(errorMessage).append("\n");
        }

        return sb.toString();
    }
}

```

`src/main/java/ghidrassistmcp/tasks/McpTaskManager.java`:

```java
/*
 * MCP Task Manager for async task execution and tracking.
 */
package ghidrassistmcp.tasks;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import ghidra.util.Msg;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * Manages asynchronous MCP task execution and tracking.
 * Provides task submission, status tracking, and cancellation capabilities.
 */
public class McpTaskManager {

    private static final int DEFAULT_THREAD_POOL_SIZE = 4;
    private static final int TASK_RETENTION_HOURS = 1;

    private final Map<String, McpTask> tasks = new ConcurrentHashMap<>();
    private final Map<String, Future<?>> taskFutures = new ConcurrentHashMap<>();
    private final ExecutorService executor;

    /**
     * Create a new task manager with default thread pool size
     */
    public McpTaskManager() {
        this(DEFAULT_THREAD_POOL_SIZE);
    }

    /**
     * Create a new task manager with specified thread pool size
     */
    public McpTaskManager(int threadPoolSize) {
        this.executor = Executors.newFixedThreadPool(threadPoolSize, r -> {
            Thread t = new Thread(r);
            t.setName("MCP-Task-" + t.threadId());
            t.setDaemon(true);
            return t;
        });
        Msg.info(this, "McpTaskManager initialized with " + threadPoolSize + " threads");
    }

    /**
     * Submit a new async task for execution
     *
     * @param toolName The name of the tool being executed
     * @param arguments The tool arguments
     * @param taskExecutor A supplier that executes the tool and returns the result
     * @return The created task
     */
    public McpTask submitTask(String toolName, Map<String, Object> arguments,
                               Supplier<McpSchema.CallToolResult> taskExecutor) {
        // Clean up old tasks before creating new ones
        cleanupOldTasks();

        McpTask task = new McpTask(toolName, arguments);
        tasks.put(task.getTaskId(), task);

        Future<?> future = executor.submit(() -> {
            try {
                task.markStarted();
                Msg.info(this, "Task started: " + task.getTaskId() + " for tool: " + toolName);

                McpSchema.CallToolResult result = taskExecutor.get();
                task.markCompleted(result);

                Msg.info(this, "Task completed: " + task.getTaskId() + " in " + task.getDurationMillis() + "ms");

            } catch (Exception e) {
                task.markFailed(e.getMessage());
                Msg.error(this, "Task failed: " + task.getTaskId() + " - " + e.getMessage(), e);
            }
        });

        taskFutures.put(task.getTaskId(), future);
        Msg.info(this, "Task submitted: " + task.getTaskId() + " for tool: " + toolName);

        return task;
    }

    /**
     * Get a task by ID
     */
    public McpTask getTask(String taskId) {
        return tasks.get(taskId);
    }

    /**
     * Get task status summary
     */
    public String getTaskStatus(String taskId) {
        McpTask task = tasks.get(taskId);
        if (task == null) {
            return "Task not found: " + taskId;
        }
        return task.toSummary();
    }

    /**
     * Get the result of a completed task
     */
    public McpSchema.CallToolResult getTaskResult(String taskId) {
        McpTask task = tasks.get(taskId);
        if (task == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Task not found: " + taskId)
                .build();
        }

        if (!task.isTerminal()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Task is still running.\n" + task.toSummary())
                .build();
        }

        if (task.getStatus() == McpTask.Status.COMPLETED && task.getResult() != null) {
            return task.getResult();
        }

        if (task.getStatus() == McpTask.Status.FAILED) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Task failed: " + task.getErrorMessage())
                .build();
        }

        if (task.getStatus() == McpTask.Status.CANCELLED) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Task was cancelled")
                .build();
        }

        return McpSchema.CallToolResult.builder()
            .addTextContent("Unknown task state: " + task.getStatus())
            .build();
    }

    /**
     * Cancel a running task
     */
    public boolean cancelTask(String taskId) {
        McpTask task = tasks.get(taskId);
        if (task == null) {
            return false;
        }

        if (task.isTerminal()) {
            return false; // Can't cancel a completed task
        }

        Future<?> future = taskFutures.get(taskId);
        if (future != null) {
            future.cancel(true);
        }

        task.markCancelled();
        Msg.info(this, "Task cancelled: " + taskId);
        return true;
    }

    /**
     * List all tasks with optional status filter
     */
    public List<McpTask> listTasks(McpTask.Status statusFilter) {
        if (statusFilter == null) {
            return new ArrayList<>(tasks.values());
        }

        return tasks.values().stream()
            .filter(t -> t.getStatus() == statusFilter)
            .collect(Collectors.toList());
    }

    /**
     * Get a summary of all active tasks
     */
    public String getTasksSummary() {
        StringBuilder sb = new StringBuilder();
        sb.append("MCP Tasks Summary:\n\n");

        long pending = tasks.values().stream().filter(t -> t.getStatus() == McpTask.Status.PENDING).count();
        long running = tasks.values().stream().filter(t -> t.getStatus() == McpTask.Status.RUNNING).count();
        long completed = tasks.values().stream().filter(t -> t.getStatus() == McpTask.Status.COMPLETED).count();
        long failed = tasks.values().stream().filter(t -> t.getStatus() == McpTask.Status.FAILED).count();
        long cancelled = tasks.values().stream().filter(t -> t.getStatus() == McpTask.Status.CANCELLED).count();

        sb.append("Total: ").append(tasks.size()).append("\n");
        sb.append("  Pending: ").append(pending).append("\n");
        sb.append("  Running: ").append(running).append("\n");
        sb.append("  Completed: ").append(completed).append("\n");
        sb.append("  Failed: ").append(failed).append("\n");
        sb.append("  Cancelled: ").append(cancelled).append("\n\n");

        if (!tasks.isEmpty()) {
            sb.append("Tasks:\n");
            tasks.values().stream()
                .sorted((a, b) -> b.getCreatedAt().compareTo(a.getCreatedAt())) // Most recent first
                .limit(20) // Limit to 20 most recent
                .forEach(task -> {
                    sb.append("  - ").append(task.getTaskId().substring(0, 8)).append("...")
                      .append(" | ").append(task.getToolName())
                      .append(" | ").append(task.getStatus())
                      .append(" | ").append(task.getProgressPercent()).append("%")
                      .append("\n");
                });
        }

        return sb.toString();
    }

    /**
     * Clean up old completed tasks
     */
    private void cleanupOldTasks() {
        Instant cutoff = Instant.now().minus(TASK_RETENTION_HOURS, ChronoUnit.HOURS);

        List<String> toRemove = tasks.entrySet().stream()
            .filter(e -> e.getValue().isTerminal())
            .filter(e -> e.getValue().getCompletedAt() != null && e.getValue().getCompletedAt().isBefore(cutoff))
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());

        for (String taskId : toRemove) {
            tasks.remove(taskId);
            taskFutures.remove(taskId);
        }

        if (!toRemove.isEmpty()) {
            Msg.info(this, "Cleaned up " + toRemove.size() + " old tasks");
        }
    }

    /**
     * Shutdown the task manager
     */
    public void shutdown() {
        Msg.info(this, "Shutting down McpTaskManager...");
        executor.shutdown();
        try {
            if (!executor.awaitTermination(10, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
        Msg.info(this, "McpTaskManager shut down");
    }
}

```

`src/main/java/ghidrassistmcp/tools/BookmarksTool.java`:

```java
/*
 * MCP tool for managing bookmarks.
 */
package ghidrassistmcp.tools;

import java.util.Iterator;
import java.util.List;
import java.util.Map;

import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Bookmark;
import ghidra.program.model.listing.BookmarkManager;
import ghidra.program.model.listing.BookmarkType;
import ghidra.program.model.listing.Program;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool for listing, adding, and deleting bookmarks.
 */
public class BookmarksTool implements McpTool {

    @Override
    public boolean isReadOnly() {
        // May modify program when adding/deleting bookmarks
        return false;
    }

    @Override
    public boolean isIdempotent() {
        return true;
    }

    @Override
    public String getName() {
        return "bookmarks";
    }

    @Override
    public String getDescription() {
        return "Manage bookmarks: list, add, or delete bookmarks at addresses";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object",
            Map.of(
                "action", Map.of(
                    "type", "string",
                    "description", "Bookmark operation to perform",
                    "enum", List.of("list", "add", "delete")
                ),
                "address", Map.of(
                    "type", "string",
                    "description", "Address string (required for add/delete)"
                ),
                "category", Map.of(
                    "type", "string",
                    "description", "Optional: category to filter by (list) or set (add)"
                ),
                "comment", Map.of(
                    "type", "string",
                    "description", "Optional: comment text (add)"
                ),
                "type", Map.of(
                    "type", "string",
                    "description", "Optional: bookmark type string (defaults to NOTE for add; for delete, if omitted deletes all bookmark types at address)"
                )
            ),
            List.of("action"), null, null, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        String action = (String) arguments.get("action");
        if (action == null || action.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Action is required: 'list', 'add', or 'delete'")
                .build();
        }

        action = action.toLowerCase();
        BookmarkManager bookmarkManager = currentProgram.getBookmarkManager();

        switch (action) {
            case "list":
                return listBookmarks(bookmarkManager, arguments);

            case "add":
                return addBookmark(currentProgram, bookmarkManager, arguments);

            case "delete":
                return deleteBookmark(currentProgram, bookmarkManager, arguments);

            default:
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Invalid action: " + action + ". Use 'list', 'add', or 'delete'")
                    .build();
        }
    }

    private McpSchema.CallToolResult listBookmarks(BookmarkManager bookmarkManager, Map<String, Object> arguments) {
        String filterCategory = (String) arguments.get("category");

        StringBuilder result = new StringBuilder();
        result.append("Bookmarks:\n\n");

        // Get all bookmark types
        BookmarkType[] types = bookmarkManager.getBookmarkTypes();
        int totalCount = 0;

        for (BookmarkType type : types) {
            Iterator<Bookmark> bookmarks = bookmarkManager.getBookmarksIterator(type.getTypeString());

            while (bookmarks.hasNext()) {
                Bookmark bookmark = bookmarks.next();

                // Apply category filter if specified
                if (filterCategory != null && !filterCategory.isEmpty()) {
                    if (!bookmark.getCategory().toLowerCase().contains(filterCategory.toLowerCase())) {
                        continue;
                    }
                }

                result.append("- ").append(bookmark.getAddress())
                      .append(" [").append(type.getTypeString()).append("]")
                      .append(" (").append(bookmark.getCategory()).append(")")
                      .append(": ").append(bookmark.getComment())
                      .append("\n");
                totalCount++;
            }
        }

        if (totalCount == 0) {
            result.append("No bookmarks found");
            if (filterCategory != null) {
                result.append(" matching category '").append(filterCategory).append("'");
            }
            result.append(".\n");
        } else {
            result.append("\nTotal: ").append(totalCount).append(" bookmarks\n");
        }

        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }

    private McpSchema.CallToolResult addBookmark(Program program, BookmarkManager bookmarkManager,
                                                  Map<String, Object> arguments) {
        String addressStr = (String) arguments.get("address");
        String category = (String) arguments.get("category");
        String comment = (String) arguments.get("comment");
        String type = (String) arguments.get("type");

        if (addressStr == null || addressStr.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Address is required to add a bookmark")
                .build();
        }

        if (category == null || category.isEmpty()) {
            category = "Analysis";
        }

        if (comment == null || comment.isEmpty()) {
            comment = "MCP Bookmark";
        }

        if (type == null || type.isEmpty()) {
            type = BookmarkType.NOTE;
        }

        Address address;
        try {
            address = program.getAddressFactory().getAddress(addressStr);
            if (address == null) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Invalid address: " + addressStr)
                    .build();
            }
        } catch (Exception e) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Error parsing address: " + e.getMessage())
                .build();
        }

        int txId = program.startTransaction("Add Bookmark");
        try {
            bookmarkManager.setBookmark(address, type, category, comment);
            program.endTransaction(txId, true);

            return McpSchema.CallToolResult.builder()
                .addTextContent("Added bookmark at " + addressStr + " [" + type + "] (" + category + "): " + comment)
                .build();

        } catch (Exception e) {
            program.endTransaction(txId, false);
            return McpSchema.CallToolResult.builder()
                .addTextContent("Error adding bookmark: " + e.getMessage())
                .build();
        }
    }

    private McpSchema.CallToolResult deleteBookmark(Program program, BookmarkManager bookmarkManager,
                                                     Map<String, Object> arguments) {
        String addressStr = (String) arguments.get("address");
        String type = (String) arguments.get("type");

        if (addressStr == null || addressStr.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Address is required to delete a bookmark")
                .build();
        }

        Address address;
        try {
            address = program.getAddressFactory().getAddress(addressStr);
            if (address == null) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Invalid address: " + addressStr)
                    .build();
            }
        } catch (Exception e) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Error parsing address: " + e.getMessage())
                .build();
        }

        int txId = program.startTransaction("Delete Bookmark");
        try {
            Bookmark[] bookmarks;
            if (type != null && !type.isEmpty()) {
                Bookmark bookmark = bookmarkManager.getBookmark(address, type, null);
                bookmarks = bookmark != null ? new Bookmark[]{bookmark} : new Bookmark[0];
            } else {
                bookmarks = bookmarkManager.getBookmarks(address);
            }

            if (bookmarks.length == 0) {
                program.endTransaction(txId, false);
                return McpSchema.CallToolResult.builder()
                    .addTextContent("No bookmarks found at " + addressStr)
                    .build();
            }

            for (Bookmark bookmark : bookmarks) {
                bookmarkManager.removeBookmark(bookmark);
            }

            program.endTransaction(txId, true);
            return McpSchema.CallToolResult.builder()
                .addTextContent("Deleted " + bookmarks.length + " bookmark(s) at " + addressStr)
                .build();

        } catch (Exception e) {
            program.endTransaction(txId, false);
            return McpSchema.CallToolResult.builder()
                .addTextContent("Error deleting bookmark: " + e.getMessage())
                .build();
        }
    }
}

```

`src/main/java/ghidrassistmcp/tools/CancelTaskTool.java`:

```java
/*
 * MCP tool for cancelling async tasks.
 */
package ghidrassistmcp.tools;

import java.util.List;
import java.util.Map;

import ghidra.program.model.listing.Program;
import ghidrassistmcp.GhidrAssistMCPBackend;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that cancels a running async task.
 */
public class CancelTaskTool implements McpTool {

    @Override
    public boolean isReadOnly() {
        return false;
    }

    @Override
    public String getName() {
        return "cancel_task";
    }

    @Override
    public String getDescription() {
        return "Cancel a running async task";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object",
            Map.of(
                "task_id", new McpSchema.JsonSchema("string", null, null, null, null, null)
            ),
            List.of("task_id"), null, null, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        return McpSchema.CallToolResult.builder()
            .addTextContent("Task cancellation requires backend reference. Use execute with backend parameter.")
            .build();
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram, GhidrAssistMCPBackend backend) {
        String taskId = (String) arguments.get("task_id");

        if (taskId == null || taskId.trim().isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("task_id parameter is required")
                .build();
        }

        var taskManager = backend.getTaskManager();
        if (taskManager == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Task manager not available")
                .build();
        }

        boolean cancelled = taskManager.cancelTask(taskId);

        if (cancelled) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Successfully cancelled task: " + taskId)
                .build();
        }
        return McpSchema.CallToolResult.builder()
            .addTextContent("Could not cancel task: " + taskId +
                ". Task may have already completed or does not exist.")
            .build();
    }
}

```

`src/main/java/ghidrassistmcp/tools/ClassTool.java`:

```java
/*
 * MCP tool for class operations.
 * Consolidates list_classes, search_classes, and get_class_info.
 */
package ghidrassistmcp.tools;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import ghidra.program.model.address.Address;
import ghidra.program.model.data.Array;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.Pointer;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Listing;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Namespace;
import ghidra.program.model.symbol.Symbol;
import ghidra.program.model.symbol.SymbolIterator;
import ghidra.program.model.symbol.SymbolTable;
import ghidra.program.model.symbol.SymbolType;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool for class operations.
 * Consolidates list_classes, search_classes, and get_class_info.
 *
 * Actions:
 * - list: List all classes with optional pattern filtering and pagination
 * - get_info: Get detailed class information including methods, fields, vtables
 */
public class ClassTool implements McpTool {

    /**
     * Inner class representing a class member with detailed information.
     */
    public static class ClassMemberInfo {
        public enum MemberType {
            METHOD, FIELD, VTABLE, VFUNCTION, TYPEINFO, STATIC_FIELD, CONSTRUCTOR, DESTRUCTOR, OPERATOR
        }

        private String name;
        private String type;
        private MemberType memberType;
        private boolean isStatic;
        private boolean isPublic;
        private Address address;
        private int vtableOffset;
        private List<String> vtableFunctions;

        public ClassMemberInfo(String name, String type, MemberType memberType,
                              boolean isStatic, boolean isPublic, Address address) {
            this.name = name;
            this.type = type;
            this.memberType = memberType;
            this.isStatic = isStatic;
            this.isPublic = isPublic;
            this.address = address;
            this.vtableOffset = -1;
            this.vtableFunctions = new ArrayList<>();
        }

        public ClassMemberInfo(String name, String type, MemberType memberType,
                              boolean isStatic, boolean isPublic, Address address, int vtableOffset) {
            this(name, type, memberType, isStatic, isPublic, address);
            this.vtableOffset = vtableOffset;
        }

        public ClassMemberInfo(String name, String type, MemberType memberType,
                              boolean isStatic, boolean isPublic, Address address, List<String> vtableFunctions) {
            this(name, type, memberType, isStatic, isPublic, address);
            this.vtableFunctions = new ArrayList<>(vtableFunctions);
        }

        public String getName() { return name; }
        public String getType() { return type; }
        public MemberType getMemberType() { return memberType; }
        public boolean isStatic() { return isStatic; }
        public boolean isPublic() { return isPublic; }
        public Address getAddress() { return address; }
        public int getVtableOffset() { return vtableOffset; }
        public List<String> getVtableFunctions() { return vtableFunctions; }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append(String.format("%s %s%s %s %s",
                isPublic ? "public" : "private",
                isStatic ? "static " : "",
                memberType.toString().toLowerCase(),
                type,
                name));

            if (address != null) {
                sb.append(" @ ").append(address);
            }

            if (vtableOffset >= 0) {
                sb.append(String.format(" [vtable+0x%x]", vtableOffset));
            }

            if (memberType == MemberType.VTABLE && vtableFunctions != null && !vtableFunctions.isEmpty()) {
                sb.append(" -> ");
                for (int i = 0; i < vtableFunctions.size(); i++) {
                    if (i > 0) {
                        sb.append(", ");
                    }
                    sb.append(String.format("vtable[%d]->%s", i, vtableFunctions.get(i)));
                }
            }

            return sb.toString();
        }
    }

    @Override
    public boolean isReadOnly() {
        return true;
    }

    @Override
    public boolean isLongRunning() {
        return true;  // get_info action uses decompiler
    }

    @Override
    public boolean isCacheable() {
        return true;
    }

    @Override
    public String getName() {
        return "class";
    }

    @Override
    public String getDescription() {
        return "Class operations: list (with optional pattern filtering) or get_info for detailed class information";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        Map<String, Object> props = new HashMap<>();
        props.put("action", Map.of(
            "type", "string",
            "description", "Class operation to perform",
            "enum", List.of("list", "get_info")
        ));
        props.put("class_name", new McpSchema.JsonSchema("string", null, null, null, null, null));
        props.put("pattern", new McpSchema.JsonSchema("string", null, null, null, null, null));
        props.put("case_sensitive", new McpSchema.JsonSchema("boolean", null, null, null, null, null));
        props.put("offset", new McpSchema.JsonSchema("integer", null, null, null, null, null));
        props.put("limit", new McpSchema.JsonSchema("integer", null, null, null, null, null));

        return new McpSchema.JsonSchema("object", props, List.of("action"), null, null, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        String action = (String) arguments.get("action");
        if (action == null || action.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("action parameter is required ('list' or 'get_info')")
                .build();
        }

        action = action.toLowerCase();

        switch (action) {
            case "list":
                return executeList(arguments, currentProgram);
            case "get_info":
                return executeGetInfo(arguments, currentProgram);
            default:
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Invalid action. Use 'list' or 'get_info'")
                    .build();
        }
    }

    // ========== LIST ACTION ==========

    private McpSchema.CallToolResult executeList(Map<String, Object> arguments, Program currentProgram) {
        String pattern = (String) arguments.get("pattern");
        boolean caseSensitive = true;
        if (arguments.get("case_sensitive") instanceof Boolean) {
            caseSensitive = (Boolean) arguments.get("case_sensitive");
        }

        int offset = 0;
        int limit = 100;
        if (arguments.get("offset") instanceof Number) {
            offset = ((Number) arguments.get("offset")).intValue();
        }
        if (arguments.get("limit") instanceof Number) {
            limit = ((Number) arguments.get("limit")).intValue();
        }

        Set<String> allClassNames = getAllClassNames(currentProgram);
        List<String> resultClasses;

        if (pattern != null && !pattern.trim().isEmpty()) {
            // Filter by pattern
            resultClasses = new ArrayList<>();
            String searchPattern = caseSensitive ? pattern : pattern.toLowerCase();

            for (String className : allClassNames) {
                String nameToSearch = caseSensitive ? className : className.toLowerCase();
                if (nameToSearch.contains(searchPattern)) {
                    resultClasses.add(className);
                }
            }
        } else {
            resultClasses = new ArrayList<>(allClassNames);
        }

        Collections.sort(resultClasses);

        StringBuilder result = new StringBuilder();
        if (pattern != null && !pattern.trim().isEmpty()) {
            result.append("Classes matching pattern: \"").append(pattern).append("\"");
            result.append(" (case ").append(caseSensitive ? "sensitive" : "insensitive").append(")\n\n");
        } else {
            result.append("Classes in program:\n\n");
        }

        int totalCount = resultClasses.size();
        int count = 0;

        for (int i = offset; i < resultClasses.size() && count < limit; i++) {
            result.append("- ").append(resultClasses.get(i)).append("\n");
            count++;
        }

        if (totalCount == 0) {
            if (pattern != null && !pattern.trim().isEmpty()) {
                result.append("No classes found matching pattern: \"").append(pattern).append("\"");
            } else {
                result.append("No classes found in the program.");
            }
        } else {
            result.append("\nShowing ").append(count).append(" of ").append(totalCount);
            result.append(pattern != null && !pattern.trim().isEmpty() ? " matching classes" : " classes");
            if (offset > 0) {
                result.append(" (offset: ").append(offset).append(")");
            }
        }

        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }

    // ========== GET_INFO ACTION ==========

    private McpSchema.CallToolResult executeGetInfo(Map<String, Object> arguments, Program currentProgram) {
        String className = (String) arguments.get("class_name");
        if (className == null || className.trim().isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("class_name parameter is required for get_info action")
                .build();
        }

        Map<String, List<ClassMemberInfo>> members = getClassMembers(className, currentProgram);
        String result = formatClassMembers(className, members);

        return McpSchema.CallToolResult.builder()
            .addTextContent(result)
            .build();
    }

    // ========== SHARED HELPER METHODS ==========

    private Set<String> getAllClassNames(Program program) {
        Set<String> classNames = new HashSet<>();
        SymbolTable symbolTable = program.getSymbolTable();

        // Method 1: Direct SymbolType.CLASS symbols
        try {
            SymbolIterator classSymbols = symbolTable.getAllSymbols(true);
            while (classSymbols.hasNext()) {
                Symbol symbol = classSymbols.next();
                if (symbol.getSymbolType() == SymbolType.CLASS) {
                    classNames.add(symbol.getName(true));
                }
            }
        } catch (Exception e) {
            // Continue with other methods
        }

        // Method 2: Parent namespaces of all symbols
        try {
            SymbolIterator allSymbols = symbolTable.getAllSymbols(true);
            while (allSymbols.hasNext()) {
                Symbol symbol = allSymbols.next();
                Namespace ns = symbol.getParentNamespace();
                if (ns != null && !ns.isGlobal()) {
                    if (isLikelyClass(ns)) {
                        classNames.add(ns.getName(true));
                    }
                }
            }
        } catch (Exception e) {
            // Continue with other methods
        }

        // Method 3: Recursive namespace traversal
        try {
            findClassesRecursively(program.getGlobalNamespace(), symbolTable, classNames);
        } catch (Exception e) {
            // Continue with other methods
        }

        // Method 4: C++ mangled name heuristics
        try {
            findCppClassesFromMangledNames(symbolTable, classNames);
        } catch (Exception e) {
            // Continue with other methods
        }

        // Method 5: Look for vtables
        try {
            findClassesFromVTables(symbolTable, classNames);
        } catch (Exception e) {
            // Continue with other methods
        }

        return classNames;
    }

    private boolean isLikelyClass(Namespace namespace) {
        SymbolType type = namespace.getSymbol().getSymbolType();
        return type == SymbolType.CLASS || type == SymbolType.NAMESPACE;
    }

    private void findClassesRecursively(Namespace namespace, SymbolTable symbolTable, Set<String> classNames) {
        try {
            SymbolIterator children = symbolTable.getSymbols(namespace);
            while (children.hasNext()) {
                Symbol symbol = children.next();
                if (symbol.getSymbolType() == SymbolType.CLASS) {
                    classNames.add(symbol.getName(true));
                }

                if (symbol.getSymbolType() == SymbolType.NAMESPACE) {
                    Object obj = symbol.getObject();
                    if (obj instanceof Namespace) {
                        Namespace childNamespace = (Namespace) obj;
                        findClassesRecursively(childNamespace, symbolTable, classNames);
                    }
                }
            }
        } catch (Exception e) {
            // Skip if we can't traverse this namespace
        }
    }

    private void findCppClassesFromMangledNames(SymbolTable symbolTable, Set<String> classNames) {
        try {
            SymbolIterator allSymbols = symbolTable.getAllSymbols(true);

            while (allSymbols.hasNext()) {
                Symbol symbol = allSymbols.next();
                String name = symbol.getName();

                if (name.contains("::")) {
                    if (name.contains("ctor") || name.contains("dtor") ||
                        name.matches(".*::[~]?\\w+\\(.*\\)")) {

                        String className = extractClassNameFromMethod(name);
                        if (className != null && !className.isEmpty()) {
                            classNames.add(className);
                        }
                    }
                }
            }
        } catch (Exception e) {
            // Skip if symbol iteration fails
        }
    }

    private void findClassesFromVTables(SymbolTable symbolTable, Set<String> classNames) {
        try {
            SymbolIterator allSymbols = symbolTable.getAllSymbols(true);
            while (allSymbols.hasNext()) {
                Symbol symbol = allSymbols.next();
                String name = symbol.getName();

                if (name.toLowerCase().contains("vtable") || name.toLowerCase().contains("vftable")) {
                    String className = extractClassNameFromVTable(name);
                    if (className != null && !className.isEmpty()) {
                        classNames.add(className);
                    }
                }
            }
        } catch (Exception e) {
            // Skip if symbol iteration fails
        }
    }

    private String extractClassNameFromMethod(String methodName) {
        int lastScope = methodName.lastIndexOf("::");
        if (lastScope > 0) {
            return methodName.substring(0, lastScope);
        }
        return null;
    }

    private String extractClassNameFromVTable(String vtableName) {
        if (vtableName.startsWith("vtable for ")) {
            return vtableName.substring("vtable for ".length());
        }
        if (vtableName.startsWith("vftable for ")) {
            return vtableName.substring("vftable for ".length());
        }
        if (vtableName.contains("::vtable")) {
            return vtableName.substring(0, vtableName.indexOf("::vtable"));
        }
        if (vtableName.contains("::vftable")) {
            return vtableName.substring(0, vtableName.indexOf("::vftable"));
        }
        return null;
    }

    // ========== GET_INFO METHODS ==========

    private Map<String, List<ClassMemberInfo>> getClassMembers(String className, Program program) {
        Map<String, List<ClassMemberInfo>> members = new HashMap<>();
        members.put("methods", new ArrayList<>());
        members.put("fields", new ArrayList<>());
        members.put("vtables", new ArrayList<>());
        members.put("virtual_functions", new ArrayList<>());
        members.put("typeinfo", new ArrayList<>());
        members.put("static_members", new ArrayList<>());

        SymbolTable symbolTable = program.getSymbolTable();
        Listing listing = program.getListing();

        Namespace classNamespace = findClassNamespace(className, program);
        if (classNamespace != null) {
            List<Symbol> classSymbols = getSymbolsInNamespace(classNamespace, symbolTable);

            for (Symbol symbol : classSymbols) {
                analyzeSymbol(symbol, className, members, listing, program);
            }
        }

        findVTablesAndTypeInfo(className, members, symbolTable, listing, program);
        extractVirtualFunctions(members, listing, program);

        for (List<ClassMemberInfo> memberList : members.values()) {
            memberList.sort(Comparator.comparing(ClassMemberInfo::getName));
        }

        return members;
    }

    private Namespace findClassNamespace(String className, Program program) {
        Set<String> allClassNames = getAllClassNames(program);

        String targetClassName = null;
        for (String foundClassName : allClassNames) {
            if (foundClassName.equals(className)) {
                targetClassName = foundClassName;
                break;
            }
            String[] parts = foundClassName.split("::");
            if (parts.length > 0 && parts[parts.length - 1].equals(className)) {
                targetClassName = foundClassName;
                break;
            }
        }

        if (targetClassName == null) {
            for (String foundClassName : allClassNames) {
                if (foundClassName.toLowerCase().equals(className.toLowerCase())) {
                    targetClassName = foundClassName;
                    break;
                }
                String[] parts = foundClassName.split("::");
                if (parts.length > 0 && parts[parts.length - 1].toLowerCase().equals(className.toLowerCase())) {
                    targetClassName = foundClassName;
                    break;
                }
            }
        }

        if (targetClassName == null) {
            return null;
        }

        return findNamespaceForClassName(targetClassName, program);
    }

    private Namespace findNamespaceForClassName(String className, Program program) {
        SymbolTable symbolTable = program.getSymbolTable();

        try {
            SymbolIterator symbolIter = symbolTable.getAllSymbols(true);
            while (symbolIter.hasNext()) {
                Symbol symbol = symbolIter.next();
                if (symbol.getSymbolType() == SymbolType.CLASS) {
                    if (symbol.getName().equals(className) || symbol.getName(true).equals(className)) {
                        Object obj = symbol.getObject();
                        if (obj instanceof Namespace) {
                            return (Namespace) obj;
                        }
                    }
                }
            }

            symbolIter = symbolTable.getAllSymbols(true);
            while (symbolIter.hasNext()) {
                Symbol symbol = symbolIter.next();
                Namespace ns = symbol.getParentNamespace();
                if (ns != null && !ns.isGlobal()) {
                    if (ns.getName().equals(className) || ns.getName(true).equals(className)) {
                        if (ns.getSymbol().getSymbolType() == SymbolType.CLASS) {
                            return ns;
                        }
                    }
                }
            }

            symbolIter = symbolTable.getAllSymbols(true);
            while (symbolIter.hasNext()) {
                Symbol symbol = symbolIter.next();
                String symbolName = symbol.getName();

                if (symbolName.contains("::") && symbolName.contains(className)) {
                    if (symbolName.contains("ctor") || symbolName.contains("dtor") ||
                        symbolName.matches(".*::" + className + "::.*")) {

                        Namespace ns = symbol.getParentNamespace();
                        if (ns != null && !ns.isGlobal() &&
                            (ns.getName().equals(className) || ns.getName(true).contains(className))) {
                            return ns;
                        }
                    }
                }
            }

        } catch (Exception e) {
            // Continue to return null
        }

        return null;
    }

    private List<Symbol> getSymbolsInNamespace(Namespace namespace, SymbolTable symbolTable) {
        List<Symbol> symbols = new ArrayList<>();

        try {
            SymbolIterator symbolIter = symbolTable.getSymbols(namespace);
            while (symbolIter.hasNext()) {
                symbols.add(symbolIter.next());
            }
        } catch (Exception e) {
            // Return empty list
        }

        return symbols;
    }

    private void analyzeSymbol(Symbol symbol, String className,
                              Map<String, List<ClassMemberInfo>> members,
                              Listing listing, Program program) {
        String symbolName = symbol.getName();
        SymbolType symbolType = symbol.getSymbolType();
        Address address = symbol.getAddress();

        if (isVTable(symbol, className)) {
            List<String> vtableFunctions = parseVTableFunctions(symbol, listing, program);
            ClassMemberInfo vtable = new ClassMemberInfo(
                symbolName, "vtable", ClassMemberInfo.MemberType.VTABLE,
                true, false, address, vtableFunctions);
            members.get("vtables").add(vtable);
            return;
        }

        if (isTypeInfo(symbol, className)) {
            ClassMemberInfo typeinfo = new ClassMemberInfo(
                symbolName, "typeinfo", ClassMemberInfo.MemberType.TYPEINFO,
                true, false, address);
            members.get("typeinfo").add(typeinfo);
            return;
        }

        if (symbolType == SymbolType.FUNCTION) {
            ClassMemberInfo method = createMethodInfo(symbol, listing);
            if (method != null) {
                members.get("methods").add(method);
            }
        } else if (symbolType == SymbolType.GLOBAL) {
            ClassMemberInfo staticMember = createStaticMemberInfo(symbol, listing);
            if (staticMember != null) {
                members.get("static_members").add(staticMember);
            }
        } else if (symbolType == SymbolType.LOCAL_VAR || symbolType == SymbolType.PARAMETER) {
            ClassMemberInfo field = createFieldInfo(symbol, listing);
            if (field != null) {
                members.get("fields").add(field);
            }
        } else if (symbolType == SymbolType.LABEL) {
            analyzeLabel(symbol, className, members, listing);
        } else {
            ClassMemberInfo generic = createGenericMemberInfo(symbol, listing);
            if (generic != null) {
                members.get("fields").add(generic);
            }
        }
    }

    private boolean isVTable(Symbol symbol, String className) {
        String name = symbol.getName().toLowerCase();
        String classLower = className.toLowerCase();

        return name.contains("vtable") ||
               name.contains("vftable") ||
               name.contains("_ztv") ||
               name.contains("_7" + classLower) ||
               (name.contains(classLower) && name.contains("vft")) ||
               name.matches(".*vtbl.*") ||
               name.matches(".*::" + classLower + "::.*vtable.*") ||
               name.matches(".*::" + classLower + "::.*vftable.*") ||
               name.equals(classLower + "::vftable") ||
               name.endsWith("::vftable") ||
               name.endsWith("::vtable");
    }

    private boolean isTypeInfo(Symbol symbol, String className) {
        String name = symbol.getName().toLowerCase();
        String classLower = className.toLowerCase();

        return name.contains("typeinfo") ||
               name.contains("_zti") ||
               name.contains("_rti") ||
               name.contains("class_type_info") ||
               (name.contains(classLower) && (name.contains("rtti") || name.contains("type")));
    }

    private ClassMemberInfo createMethodInfo(Symbol symbol, Listing listing) {
        String methodName = symbol.getName();
        String returnType = "unknown";
        ClassMemberInfo.MemberType memberType = ClassMemberInfo.MemberType.METHOD;

        Function function = listing.getFunctionAt(symbol.getAddress());
        if (function != null && function.getSignature() != null) {
            returnType = function.getSignature().getReturnType().getDisplayName();
        }

        if (methodName.contains("ctor") || methodName.contains("constructor")) {
            memberType = ClassMemberInfo.MemberType.CONSTRUCTOR;
        } else if (methodName.contains("dtor") || methodName.contains("destructor") || methodName.startsWith("~")) {
            memberType = ClassMemberInfo.MemberType.DESTRUCTOR;
        } else if (methodName.contains("operator")) {
            memberType = ClassMemberInfo.MemberType.OPERATOR;
        }

        return new ClassMemberInfo(methodName, returnType, memberType,
                                  false, true, symbol.getAddress());
    }

    private ClassMemberInfo createFieldInfo(Symbol symbol, Listing listing) {
        String fieldName = symbol.getName();
        String fieldType = "unknown";

        Data data = listing.getDataAt(symbol.getAddress());
        if (data != null && data.getDataType() != null) {
            fieldType = data.getDataType().getDisplayName();
        }

        return new ClassMemberInfo(fieldName, fieldType, ClassMemberInfo.MemberType.FIELD,
                                  false, true, symbol.getAddress());
    }

    private ClassMemberInfo createStaticMemberInfo(Symbol symbol, Listing listing) {
        String fieldName = symbol.getName();
        String fieldType = "unknown";

        Data data = listing.getDataAt(symbol.getAddress());
        if (data != null && data.getDataType() != null) {
            fieldType = data.getDataType().getDisplayName();
        }

        return new ClassMemberInfo(fieldName, fieldType, ClassMemberInfo.MemberType.STATIC_FIELD,
                                  true, true, symbol.getAddress());
    }

    private ClassMemberInfo createGenericMemberInfo(Symbol symbol, Listing listing) {
        String memberName = symbol.getName();
        String memberType = "unknown";

        Data data = listing.getDataAt(symbol.getAddress());
        if (data != null && data.getDataType() != null) {
            memberType = data.getDataType().getDisplayName();
        }

        return new ClassMemberInfo(memberName, memberType, ClassMemberInfo.MemberType.FIELD,
                                  false, true, symbol.getAddress());
    }

    private void analyzeLabel(Symbol symbol, String className,
                             Map<String, List<ClassMemberInfo>> members, Listing listing) {

        if (isVTable(symbol, className) || isTypeInfo(symbol, className)) {
            return;
        }

        ClassMemberInfo labelMember = createGenericMemberInfo(symbol, listing);
        if (labelMember != null) {
            if (isLikelyMethod(symbol, listing)) {
                labelMember = new ClassMemberInfo(labelMember.getName(), labelMember.getType(),
                                                 ClassMemberInfo.MemberType.METHOD,
                                                 labelMember.isStatic(), labelMember.isPublic(),
                                                 labelMember.getAddress());
                members.get("methods").add(labelMember);
            } else {
                members.get("fields").add(labelMember);
            }
        }
    }

    private boolean isLikelyMethod(Symbol symbol, Listing listing) {
        Function function = listing.getFunctionAt(symbol.getAddress());
        return function != null;
    }

    private void findVTablesAndTypeInfo(String className, Map<String, List<ClassMemberInfo>> members,
                                       SymbolTable symbolTable, Listing listing, Program program) {

        try {
            SymbolIterator allSymbols = symbolTable.getAllSymbols(true);
            String classNameLower = className.toLowerCase();
            while (allSymbols.hasNext()) {
                Symbol symbol = allSymbols.next();
                String symbolNameLower = symbol.getName().toLowerCase();
                if ((symbolNameLower.contains("vtable") || symbolNameLower.contains("vftable")) &&
                    symbolNameLower.contains(classNameLower)) {
                    if (isVTable(symbol, className)) {
                        List<String> vtableFunctions = parseVTableFunctions(symbol, listing, program);
                        ClassMemberInfo vtable = new ClassMemberInfo(
                            symbol.getName(), "vtable", ClassMemberInfo.MemberType.VTABLE,
                            true, false, symbol.getAddress(), vtableFunctions);
                        members.get("vtables").add(vtable);
                    }
                }
            }
        } catch (Exception e) {
            // Continue if symbol iteration fails
        }

        try {
            SymbolIterator allSymbols = symbolTable.getAllSymbols(true);
            while (allSymbols.hasNext()) {
                Symbol symbol = allSymbols.next();
                if (symbol.getName().toLowerCase().contains("typeinfo") &&
                    symbol.getName().toLowerCase().contains(className.toLowerCase())) {
                    if (isTypeInfo(symbol, className)) {
                        ClassMemberInfo typeinfo = new ClassMemberInfo(
                            symbol.getName(), "typeinfo", ClassMemberInfo.MemberType.TYPEINFO,
                            true, false, symbol.getAddress());
                        members.get("typeinfo").add(typeinfo);
                    }
                }
            }
        } catch (Exception e) {
            // Continue if search fails
        }
    }

    private List<String> parseVTableFunctions(Symbol vtableSymbol, Listing listing, Program program) {
        List<String> functions = new ArrayList<>();
        Address vtableAddr = vtableSymbol.getAddress();

        if (vtableAddr == null) {
            return functions;
        }

        try {
            Data vtableData = listing.getDataAt(vtableAddr);
            if (vtableData != null) {
                functions.addAll(parseVTableEntriesForDisplay(vtableData, listing, program));
            } else {
                functions.addAll(parseVTableManuallyForDisplay(vtableAddr, listing, program));
            }
        } catch (Exception e) {
            try {
                functions.addAll(parseVTableManuallyForDisplay(vtableAddr, listing, program));
            } catch (Exception e2) {
                // Return empty list
            }
        }

        return functions;
    }

    private List<String> parseVTableEntriesForDisplay(Data vtableData, Listing listing, Program program) {
        List<String> functions = new ArrayList<>();

        DataType dataType = vtableData.getDataType();
        if (dataType instanceof Array) {
            Array arrayType = (Array) dataType;
            int numElements = arrayType.getNumElements();

            for (int i = 0; i < numElements; i++) {
                Data elementData = vtableData.getComponent(i);
                if (elementData != null) {
                    Address functionAddr = getFunctionAddressFromPointer(elementData, program);
                    if (functionAddr != null) {
                        Function virtualFunction = listing.getFunctionAt(functionAddr);
                        if (virtualFunction != null) {
                            functions.add(virtualFunction.getName());
                        } else {
                            functions.add("FUN_" + functionAddr.toString().replace(":", ""));
                        }
                    }
                }
            }
        }

        return functions;
    }

    private List<String> parseVTableManuallyForDisplay(Address vtableAddr, Listing listing, Program program) {
        List<String> functions = new ArrayList<>();

        int pointerSize = program.getDefaultPointerSize();
        Address currentAddr = vtableAddr;

        for (int i = 0; i < 50; i++) {
            try {
                Data pointerData = listing.getDataAt(currentAddr);
                Address functionAddr = null;

                if (pointerData != null && pointerData.getDataType() instanceof Pointer) {
                    functionAddr = getFunctionAddressFromPointer(pointerData, program);
                } else {
                    long pointerValue = program.getMemory().getLong(currentAddr);
                    if (pointerValue != 0) {
                        try {
                            functionAddr = program.getAddressFactory().getDefaultAddressSpace().getAddress(pointerValue);
                        } catch (Exception e) {
                            break;
                        }
                    }
                }

                if (functionAddr != null) {
                    Function virtualFunction = listing.getFunctionAt(functionAddr);
                    if (virtualFunction != null) {
                        functions.add(virtualFunction.getName());
                    } else {
                        if (program.getMemory().contains(functionAddr)) {
                            functions.add("FUN_" + functionAddr.toString().replace(":", ""));
                        } else {
                            break;
                        }
                    }
                } else {
                    break;
                }

                currentAddr = currentAddr.add(pointerSize);

            } catch (Exception e) {
                break;
            }
        }

        return functions;
    }

    private void extractVirtualFunctions(Map<String, List<ClassMemberInfo>> members,
                                       Listing listing, Program program) {

        for (ClassMemberInfo vtable : members.get("vtables")) {
            Address vtableAddr = vtable.getAddress();

            Data vtableData = listing.getDataAt(vtableAddr);
            if (vtableData != null) {
                parseVTableEntries(vtableData, members.get("virtual_functions"), listing, program);
            } else {
                parseVTableManually(vtableAddr, members.get("virtual_functions"), listing, program);
            }
        }
    }

    private void parseVTableEntries(Data vtableData, List<ClassMemberInfo> virtualFunctions,
                                   Listing listing, Program program) {

        DataType dataType = vtableData.getDataType();
        if (dataType instanceof Array) {
            Array arrayType = (Array) dataType;
            int numElements = arrayType.getNumElements();

            for (int i = 0; i < numElements; i++) {
                Data elementData = vtableData.getComponent(i);
                if (elementData != null) {
                    Address functionAddr = getFunctionAddressFromPointer(elementData, program);
                    if (functionAddr != null) {
                        Function virtualFunction = listing.getFunctionAt(functionAddr);
                        if (virtualFunction != null) {
                            ClassMemberInfo vfunc = new ClassMemberInfo(
                                virtualFunction.getName(),
                                virtualFunction.getSignature() != null ?
                                    virtualFunction.getSignature().getReturnType().getDisplayName() : "unknown",
                                ClassMemberInfo.MemberType.VFUNCTION,
                                false, true, functionAddr, i * program.getDefaultPointerSize());
                            virtualFunctions.add(vfunc);
                        }
                    }
                }
            }
        }
    }

    private void parseVTableManually(Address vtableAddr, List<ClassMemberInfo> virtualFunctions,
                                    Listing listing, Program program) {

        int pointerSize = program.getDefaultPointerSize();
        Address currentAddr = vtableAddr;
        int offset = 0;

        for (int i = 0; i < 50; i++) {
            try {
                Data pointerData = listing.getDataAt(currentAddr);
                Address functionAddr = null;

                if (pointerData != null && pointerData.getDataType() instanceof Pointer) {
                    functionAddr = getFunctionAddressFromPointer(pointerData, program);
                } else {
                    long pointerValue = program.getMemory().getLong(currentAddr);
                    if (pointerValue != 0) {
                        functionAddr = program.getAddressFactory().getDefaultAddressSpace().getAddress(pointerValue);
                    }
                }

                if (functionAddr != null) {
                    Function virtualFunction = listing.getFunctionAt(functionAddr);
                    if (virtualFunction != null) {
                        ClassMemberInfo vfunc = new ClassMemberInfo(
                            virtualFunction.getName(),
                            virtualFunction.getSignature() != null ?
                                virtualFunction.getSignature().getReturnType().getDisplayName() : "unknown",
                            ClassMemberInfo.MemberType.VFUNCTION,
                            false, true, functionAddr, offset);
                        virtualFunctions.add(vfunc);
                    }
                } else {
                    break;
                }

                currentAddr = currentAddr.add(pointerSize);
                offset += pointerSize;

            } catch (Exception e) {
                break;
            }
        }
    }

    private Address getFunctionAddressFromPointer(Data pointerData, Program program) {
        if (pointerData.getDataType() instanceof Pointer) {
            Object value = pointerData.getValue();
            if (value instanceof Address) {
                return (Address) value;
            }
        }
        return null;
    }

    private String formatClassMembers(String className, Map<String, List<ClassMemberInfo>> members) {
        StringBuilder result = new StringBuilder();
        result.append("Class: ").append(className).append("\n\n");

        if (!members.get("methods").isEmpty()) {
            result.append("Methods (").append(members.get("methods").size()).append("):\n");
            for (ClassMemberInfo method : members.get("methods")) {
                result.append("  ").append(method.toString()).append("\n");
            }
            result.append("\n");
        }

        if (!members.get("fields").isEmpty()) {
            result.append("Fields (").append(members.get("fields").size()).append("):\n");
            for (ClassMemberInfo field : members.get("fields")) {
                result.append("  ").append(field.toString()).append("\n");
            }
            result.append("\n");
        }

        if (!members.get("vtables").isEmpty()) {
            result.append("VTables (").append(members.get("vtables").size()).append("):\n");
            for (ClassMemberInfo vtable : members.get("vtables")) {
                result.append("  ").append(vtable.toString()).append("\n");
            }
            result.append("\n");
        }

        if (!members.get("virtual_functions").isEmpty()) {
            result.append("Virtual Functions (").append(members.get("virtual_functions").size()).append("):\n");
            for (ClassMemberInfo vfunc : members.get("virtual_functions")) {
                result.append("  ").append(vfunc.toString()).append("\n");
            }
            result.append("\n");
        }

        if (!members.get("static_members").isEmpty()) {
            result.append("Static Members (").append(members.get("static_members").size()).append("):\n");
            for (ClassMemberInfo staticMember : members.get("static_members")) {
                result.append("  ").append(staticMember.toString()).append("\n");
            }
            result.append("\n");
        }

        if (!members.get("typeinfo").isEmpty()) {
            result.append("Type Info (").append(members.get("typeinfo").size()).append("):\n");
            for (ClassMemberInfo typeinfo : members.get("typeinfo")) {
                result.append("  ").append(typeinfo.toString()).append("\n");
            }
            result.append("\n");
        }

        int totalMembers = members.values().stream().mapToInt(List::size).sum();
        if (totalMembers == 0) {
            result.append("No class members found for class: ").append(className);
        } else {
            result.append("Total members found: ").append(totalMembers);
        }

        return result.toString();
    }
}

```

`src/main/java/ghidrassistmcp/tools/DeleteDataTypeTool.java`:

```java
/**
 * MCP tool that deletes a data type from the program's DataTypeManager.
 */
package ghidrassistmcp.tools;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import ghidrassistmcp.GhidrAssistMCPBackend;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that deletes a data type from the program's DataTypeManager.
 */
public class DeleteDataTypeTool implements McpTool {

    @Override
    public boolean isReadOnly() {
        return false;
    }

    @Override
    public boolean isDestructive() {
        return true;
    }

    @Override
    public String getName() {
        return "delete_data_type";
    }

    @Override
    public String getDescription() {
        return "Delete a data type by name (optionally scoped by category). " +
               "If multiple types share the same name in different categories, you must provide category or use a full path name.";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object",
            Map.of(
                "name", new McpSchema.JsonSchema("string", null, null, null, null, null),
                "category", new McpSchema.JsonSchema("string", null, null, null, null, null)
            ),
            List.of("name"), null, null, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        return execute(arguments, currentProgram, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram, GhidrAssistMCPBackend backend) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        String name = (String) arguments.get("name");
        if (name == null || name.trim().isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("name parameter is required")
                .build();
        }
        name = name.trim();

        String category = (String) arguments.get("category");
        if (category != null) {
            category = category.trim();
            if (category.isEmpty()) {
                category = null;
            }
        }

        DataTypeManager dtm = currentProgram.getDataTypeManager();

        ResolveResult resolved = resolveTargetDataType(dtm, name, category);
        if (!resolved.ok) {
            return McpSchema.CallToolResult.builder()
                .addTextContent(resolved.message)
                .build();
        }

        DataType target = resolved.dataType;
        if (target == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Data type not found: " + name + (category != null ? " in category: " + category : ""))
                .build();
        }

        // Some DataType instances may come from non-program managers (built-ins/archives).
        // Only attempt deletion if this type is owned by the program's DataTypeManager.
        try {
            if (target.getDataTypeManager() != dtm) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Refusing to delete data type '" + target.getName() + "' because it is not owned by this program's DataTypeManager " +
                                    "(likely a built-in or archived type). Resolved path: " + safePath(target))
                    .build();
            }
        } catch (Exception e) {
            // If ownership cannot be determined, proceed cautiously and rely on dtm.remove() return value.
        }

        int txId = currentProgram.startTransaction("Delete Data Type");
        boolean committed = false;
        try {
            boolean removed = dtm.remove(target);
            if (!removed) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Failed to delete data type '" + target.getName() + "' at " + safePath(target) + ". " +
                                    "It may be built-in, read-only, or still referenced by other types/uses.")
                    .build();
            }

            committed = true;
            if (backend != null) {
                backend.clearCache();
            }

            return McpSchema.CallToolResult.builder()
                .addTextContent("Successfully deleted data type '" + target.getName() + "' at " + safePath(target))
                .build();
        } catch (Exception e) {
            String msg = "Error deleting data type '" + name + "': " + e.getMessage();
            Msg.error(this, msg, e);
            return McpSchema.CallToolResult.builder()
                .addTextContent(msg)
                .build();
        } finally {
            currentProgram.endTransaction(txId, committed);
        }
    }

    private static class ResolveResult {
        final boolean ok;
        final DataType dataType;
        final String message;

        private ResolveResult(boolean ok, DataType dataType, String message) {
            this.ok = ok;
            this.dataType = dataType;
            this.message = message;
        }

        static ResolveResult ok(DataType dataType) {
            return new ResolveResult(true, dataType, null);
        }

        static ResolveResult error(String message) {
            return new ResolveResult(false, null, message);
        }
    }

    private ResolveResult resolveTargetDataType(DataTypeManager dtm, String name, String category) {
        // If category provided, require exact match.
        if (category != null) {
            try {
                DataType dt = dtm.getDataType(new CategoryPath(category), name);
                if (dt != null) {
                    return ResolveResult.ok(dt);
                }
                return ResolveResult.error("Data type not found: " + name + " in category: " + category);
            } catch (Exception e) {
                return ResolveResult.error("Invalid category path '" + category + "': " + e.getMessage());
            }
        }

        // If name looks like a full path, try direct path lookup.
        if (name.startsWith("/")) {
            DataType dt = dtm.getDataType(name);
            if (dt != null) {
                return ResolveResult.ok(dt);
            }
            return ResolveResult.error("Data type not found at path: " + name);
        }

        // Collect all exact-name matches and detect ambiguity by category.
        List<DataType> matches = new ArrayList<>();
        Iterator<DataType> iter = dtm.getAllDataTypes();
        while (iter.hasNext()) {
            DataType dt = iter.next();
            if (dt != null && name.equals(dt.getName())) {
                matches.add(dt);
            }
        }

        if (matches.isEmpty()) {
            // Fall back to dtm.getDataType(name) (may resolve built-ins or a single match)
            DataType dt = dtm.getDataType(name);
            if (dt != null) {
                return ResolveResult.ok(dt);
            }
            return ResolveResult.error("Data type not found: " + name);
        }

        if (matches.size() == 1) {
            return ResolveResult.ok(matches.get(0));
        }

        // Ambiguous: same name in multiple categories.
        Map<String, Integer> byCategory = new LinkedHashMap<>();
        for (DataType dt : matches) {
            String path = dt.getCategoryPath() != null ? dt.getCategoryPath().getPath() : "(unknown)";
            byCategory.put(path, byCategory.getOrDefault(path, 0) + 1);
        }

        StringBuilder msg = new StringBuilder();
        msg.append("Ambiguous data type name '").append(name).append("': found ")
           .append(matches.size()).append(" matches in ").append(byCategory.size()).append(" categories.\n")
           .append("Please provide 'category' to select the exact type, or pass a full path as 'name' (starting with '/').\n\n")
           .append("Candidate categories:\n");

        int shown = 0;
        for (Map.Entry<String, Integer> e : byCategory.entrySet()) {
            if (shown >= 20) {
                msg.append("- (more...)\n");
                break;
            }
            msg.append("- ").append(e.getKey());
            if (e.getValue() != 1) {
                msg.append(" (").append(e.getValue()).append(")");
            }
            msg.append("\n");
            shown++;
        }

        return ResolveResult.error(msg.toString());
    }

    private String safePath(DataType dt) {
        try {
            if (dt.getCategoryPath() != null) {
                return dt.getCategoryPath().getPath() + "/" + dt.getName();
            }
        } catch (Exception e) {
            // ignore
        }
        return dt.getName();
    }
}


```

`src/main/java/ghidrassistmcp/tools/GetBasicBlocksTool.java`:

```java
/*
 * MCP tool for getting basic blocks (control flow graph).
 */
package ghidrassistmcp.tools;

import java.util.List;
import java.util.Map;

import ghidra.program.model.address.Address;
import ghidra.program.model.block.BasicBlockModel;
import ghidra.program.model.block.CodeBlock;
import ghidra.program.model.block.CodeBlockIterator;
import ghidra.program.model.block.CodeBlockReference;
import ghidra.program.model.block.CodeBlockReferenceIterator;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.util.task.TaskMonitor;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that gets basic blocks and control flow graph for a function.
 */
public class GetBasicBlocksTool implements McpTool {

    @Override
    public boolean isCacheable() {
        return true;
    }

    @Override
    public String getName() {
        return "get_basic_blocks";
    }

    @Override
    public String getDescription() {
        return "Get basic blocks and control flow graph for a function";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object",
            Map.of(
                "function", new McpSchema.JsonSchema("string", null, null, null, null, null)
            ),
            List.of("function"), null, null, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        String functionIdentifier = (String) arguments.get("function");

        // Find the function
        Function function = findFunction(currentProgram, functionIdentifier);
        if (function == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Function not found: " + functionIdentifier)
                .build();
        }

        StringBuilder result = new StringBuilder();
        result.append("Basic Blocks for: ").append(function.getName())
              .append(" @ ").append(function.getEntryPoint()).append("\n\n");

        try {
            BasicBlockModel blockModel = new BasicBlockModel(currentProgram);
            CodeBlockIterator blocks = blockModel.getCodeBlocksContaining(
                function.getBody(), TaskMonitor.DUMMY);

            int blockCount = 0;

            while (blocks.hasNext()) {
                CodeBlock block = blocks.next();
                blockCount++;

                result.append("## Block ").append(blockCount).append("\n");
                result.append("- **Start**: ").append(block.getFirstStartAddress()).append("\n");
                result.append("- **End**: ").append(block.getMaxAddress()).append("\n");
                result.append("- **Size**: ").append(block.getNumAddresses()).append(" addresses\n");
                result.append("- **Name**: ").append(block.getName()).append("\n");

                // Get successors (where control can flow to)
                result.append("- **Successors**:\n");
                CodeBlockReferenceIterator destIter = block.getDestinations(TaskMonitor.DUMMY);
                boolean hasSucc = false;
                while (destIter.hasNext()) {
                    CodeBlockReference ref = destIter.next();
                    result.append("    - ").append(ref.getDestinationAddress())
                          .append(" (").append(ref.getFlowType()).append(")\n");
                    hasSucc = true;
                }
                if (!hasSucc) {
                    result.append("    - (none - exit block)\n");
                }

                // Get predecessors (where control can come from)
                result.append("- **Predecessors**:\n");
                CodeBlockReferenceIterator srcIter = block.getSources(TaskMonitor.DUMMY);
                boolean hasPred = false;
                while (srcIter.hasNext()) {
                    CodeBlockReference ref = srcIter.next();
                    result.append("    - ").append(ref.getSourceAddress())
                          .append(" (").append(ref.getFlowType()).append(")\n");
                    hasPred = true;
                }
                if (!hasPred) {
                    result.append("    - (none - entry block)\n");
                }

                result.append("\n");
            }

            result.append("## Summary\n");
            result.append("- Total Basic Blocks: ").append(blockCount).append("\n");
            result.append("- Function Size: ").append(function.getBody().getNumAddresses()).append(" addresses\n");

        } catch (Exception e) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Error getting basic blocks: " + e.getMessage())
                .build();
        }

        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }

    private Function findFunction(Program program, String identifier) {
        try {
            Address addr = program.getAddressFactory().getAddress(identifier);
            if (addr != null) {
                Function func = program.getFunctionManager().getFunctionAt(addr);
                if (func != null) return func;
            }
        } catch (Exception e) {
            // Not an address
        }

        for (Function function : program.getFunctionManager().getFunctions(true)) {
            if (function.getName().equals(identifier)) {
                return function;
            }
        }
        return null;
    }
}

```

`src/main/java/ghidrassistmcp/tools/GetCallGraphTool.java`:

```java
/*
 * MCP tool for getting function call graph.
 */
package ghidrassistmcp.tools;

import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.util.task.TaskMonitor;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that gets the function call graph (callers and callees).
 */
public class GetCallGraphTool implements McpTool {

    @Override
    public boolean isCacheable() {
        return true;
    }

    @Override
    public String getName() {
        return "get_call_graph";
    }

    @Override
    public String getDescription() {
        return "Get the function call graph showing callers and callees with specified depth";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object",
            Map.of(
                "function", Map.of(
                    "type", "string",
                    "description", "Function identifier (name or address)"
                ),
                "depth", Map.of(
                    "type", "integer",
                    "description", "Optional: max graph depth (default 2, capped at 5)",
                    "default", 2
                ),
                "direction", Map.of(
                    "type", "string",
                    "description", "Optional: which side of the call graph to return",
                    "enum", List.of("both", "callers", "callees"),
                    "default", "both"
                )
            ),
            List.of("function"), null, null, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        String functionIdentifier = (String) arguments.get("function");
        int depth = 2; // Default depth
        String direction = "both";

        if (arguments.get("depth") instanceof Number) {
            depth = ((Number) arguments.get("depth")).intValue();
            depth = Math.min(depth, 5); // Limit max depth to avoid excessive output
        }

        if (arguments.get("direction") instanceof String) {
            String dir = (String) arguments.get("direction");
            if (dir != null && !dir.trim().isEmpty()) {
                direction = dir.toLowerCase();
            }
        }

        if (!direction.equals("both") && !direction.equals("callers") && !direction.equals("callees")) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Invalid direction. Use 'both', 'callers', or 'callees'")
                .build();
        }

        // Find the function
        Function function = findFunction(currentProgram, functionIdentifier);
        if (function == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Function not found: " + functionIdentifier)
                .build();
        }

        StringBuilder result = new StringBuilder();
        result.append("Call Graph for: ").append(function.getName())
              .append(" @ ").append(function.getEntryPoint()).append("\n\n");

        Set<String> visited = new HashSet<>();

        // Get callers (functions that call this function)
        if (direction.equals("callers") || direction.equals("both")) {
            result.append("## Calling Functions (Who calls this):\n");
            buildCallerTree(currentProgram, function, depth, 0, visited, result);
            result.append("\n");
        }

        visited.clear();

        // Get callees (functions called by this function)
        if (direction.equals("callees") || direction.equals("both")) {
            result.append("## Called Functions (What this calls):\n");
            buildCalleeTree(currentProgram, function, depth, 0, visited, result);
        }

        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }

    private void buildCallerTree(Program program, Function function, int maxDepth, int currentDepth,
                                  Set<String> visited, StringBuilder result) {
        String indent = "  ".repeat(currentDepth);
        String key = function.getEntryPoint().toString();

        if (visited.contains(key)) {
            result.append(indent).append("- ").append(function.getName())
                  .append(" @ ").append(function.getEntryPoint())
                  .append(" (recursive/already visited)\n");
            return;
        }

        visited.add(key);
        result.append(indent).append("- ").append(function.getName())
              .append(" @ ").append(function.getEntryPoint()).append("\n");

        if (currentDepth < maxDepth) {
            Set<Function> callers = function.getCallingFunctions(TaskMonitor.DUMMY);
            for (Function caller : callers) {
                buildCallerTree(program, caller, maxDepth, currentDepth + 1, visited, result);
            }
        }
    }

    private void buildCalleeTree(Program program, Function function, int maxDepth, int currentDepth,
                                  Set<String> visited, StringBuilder result) {
        String indent = "  ".repeat(currentDepth);
        String key = function.getEntryPoint().toString();

        if (visited.contains(key)) {
            result.append(indent).append("- ").append(function.getName())
                  .append(" @ ").append(function.getEntryPoint())
                  .append(" (recursive/already visited)\n");
            return;
        }

        visited.add(key);
        result.append(indent).append("- ").append(function.getName())
              .append(" @ ").append(function.getEntryPoint()).append("\n");

        if (currentDepth < maxDepth) {
            Set<Function> callees = function.getCalledFunctions(TaskMonitor.DUMMY);
            for (Function callee : callees) {
                buildCalleeTree(program, callee, maxDepth, currentDepth + 1, visited, result);
            }
        }
    }

    private Function findFunction(Program program, String identifier) {
        // Try as address first
        try {
            Address addr = program.getAddressFactory().getAddress(identifier);
            if (addr != null) {
                Function func = program.getFunctionManager().getFunctionAt(addr);
                if (func != null) return func;
            }
        } catch (Exception e) {
            // Not an address
        }

        // Try as function name
        for (Function function : program.getFunctionManager().getFunctions(true)) {
            if (function.getName().equals(identifier)) {
                return function;
            }
        }

        return null;
    }
}

```

`src/main/java/ghidrassistmcp/tools/GetCodeTool.java`:

```java
/*
 * MCP tool for getting code representation of a function.
 * Consolidates decompile_function, disassemble_function, and get_pcode into a single tool.
 */
package ghidrassistmcp.tools;

import java.util.Iterator;
import java.util.List;
import java.util.Map;

import ghidra.app.decompiler.DecompInterface;
import ghidra.app.decompiler.DecompileResults;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.CommentType;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Instruction;
import ghidra.program.model.listing.InstructionIterator;
import ghidra.program.model.listing.Program;
import ghidra.program.model.pcode.HighFunction;
import ghidra.program.model.pcode.PcodeBlockBasic;
import ghidra.program.model.pcode.PcodeOp;
import ghidra.program.model.pcode.PcodeOpAST;
import ghidra.program.model.symbol.Namespace;
import ghidra.util.task.TaskMonitor;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that gets code representation of a function in various formats.
 * Replaces separate decompile_function, disassemble_function, and get_pcode tools.
 */
public class GetCodeTool implements McpTool {

    @Override
    public boolean isLongRunning() {
        // Decompiler and pcode formats require decompilation
        return true;
    }

    @Override
    public boolean isCacheable() {
        return true;
    }

    @Override
    public String getName() {
        return "get_code";
    }

    @Override
    public String getDescription() {
        return "Get code representation of a function in various formats (decompiler, disassembly, or pcode)";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object",
            Map.of(
                "function", Map.of(
                    "type", "string",
                    "description", "Function identifier (name, qualified name like Namespace::Func, or address like 0x401000)"
                ),
                "format", Map.of(
                    "type", "string",
                    "description", "Output format for the requested function",
                    "enum", List.of("decompiler", "disassembly", "pcode")
                ),
                "raw", Map.of(
                    "type", "boolean",
                    "description", "Optional: Only affects format 'pcode' (raw pcode ops vs grouped by basic blocks)",
                    "default", false
                )
            ),
            List.of("function", "format"), null, null, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        String functionIdentifier = (String) arguments.get("function");
        String format = (String) arguments.get("format");
        boolean raw = Boolean.TRUE.equals(arguments.get("raw"));

        if (functionIdentifier == null || functionIdentifier.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("function parameter is required")
                .build();
        }

        if (format == null || format.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("format parameter is required (decompiler, disassembly, or pcode)")
                .build();
        }

        format = format.toLowerCase();
        if (!format.equals("decompiler") && !format.equals("disassembly") && !format.equals("pcode")) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Invalid format. Use 'decompiler', 'disassembly', or 'pcode'")
                .build();
        }

        // Find the function
        Function function = findFunction(currentProgram, functionIdentifier);
        if (function == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Function not found: " + functionIdentifier)
                .build();
        }

        // Dispatch to appropriate handler based on format
        switch (format) {
            case "decompiler":
                return getDecompiledCode(currentProgram, function);
            case "disassembly":
                return getDisassemblyCode(currentProgram, function);
            case "pcode":
                return getPcodeRepresentation(currentProgram, function, raw);
            default:
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Unknown format: " + format)
                    .build();
        }
    }

    /**
     * Get decompiled C-like code for a function.
     */
    private McpSchema.CallToolResult getDecompiledCode(Program program, Function function) {
        DecompInterface decompiler = new DecompInterface();
        try {
            decompiler.openProgram(function.getProgram());

            DecompileResults results = decompiler.decompileFunction(function, 30, TaskMonitor.DUMMY);

            if (results.isTimedOut()) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Decompilation timed out for function: " + function.getName())
                    .build();
            }

            if (results.isValid() == false) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Decompilation error for function " + function.getName() + ": " + results.getErrorMessage())
                    .build();
            }

            String decompiledCode = results.getDecompiledFunction().getC();

            if (decompiledCode == null || decompiledCode.trim().isEmpty()) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("No decompiled code available for function: " + function.getName())
                    .build();
            }

            return McpSchema.CallToolResult.builder()
                .addTextContent("Decompiled function " + function.getName() + ":\n\n" + decompiledCode)
                .build();

        } catch (Exception e) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Error decompiling function " + function.getName() + ": " + e.getMessage())
                .build();
        } finally {
            decompiler.dispose();
        }
    }

    /**
     * Get disassembly for a function.
     */
    private McpSchema.CallToolResult getDisassemblyCode(Program program, Function function) {
        StringBuilder result = new StringBuilder();
        result.append("Disassembly of function: ").append(function.getName()).append("\n");
        result.append("Entry Point: ").append(function.getEntryPoint()).append("\n\n");

        // Iterate through instructions in the function
        InstructionIterator instrIter = program.getListing().getInstructions(function.getBody(), true);

        int instructionCount = 0;
        while (instrIter.hasNext()) {
            Instruction instruction = instrIter.next();

            result.append(instruction.getAddress()).append(": ");
            result.append(instruction.getMnemonicString());

            // Add operands
            for (int i = 0; i < instruction.getNumOperands(); i++) {
                if (i == 0) {
                    result.append(" ");
                } else {
                    result.append(", ");
                }
                result.append(instruction.getDefaultOperandRepresentation(i));
            }

            // Add any comments
            String comment = instruction.getComment(CommentType.EOL);
            if (comment != null && !comment.trim().isEmpty()) {
                result.append(" ; ").append(comment.trim());
            }

            result.append("\n");
            instructionCount++;
        }

        result.append("\nTotal instructions: ").append(instructionCount);

        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }

    /**
     * Get P-Code representation for a function.
     */
    private McpSchema.CallToolResult getPcodeRepresentation(Program program, Function function, boolean raw) {
        StringBuilder result = new StringBuilder();
        result.append("P-Code for: ").append(function.getName())
              .append(" @ ").append(function.getEntryPoint()).append("\n\n");

        DecompInterface decompiler = new DecompInterface();
        try {
            decompiler.openProgram(program);
            DecompileResults results = decompiler.decompileFunction(function, 30, TaskMonitor.DUMMY);

            if (!results.decompileCompleted()) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Decompilation failed for function: " + function.getName())
                    .build();
            }

            HighFunction highFunction = results.getHighFunction();
            if (highFunction == null) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Could not get high function for: " + function.getName())
                    .build();
            }

            // Get P-Code operations
            if (raw) {
                // Raw P-Code from high function
                result.append("## Raw P-Code Operations:\n```\n");
                Iterator<PcodeOpAST> ops = highFunction.getPcodeOps();
                while (ops.hasNext()) {
                    PcodeOpAST op = ops.next();
                    result.append(op.getSeqnum().getTarget()).append(": ")
                          .append(op.toString()).append("\n");
                }
                result.append("```\n");
            } else {
                // P-Code organized by basic blocks
                result.append("## P-Code by Basic Blocks:\n\n");
                var blocks = highFunction.getBasicBlocks();

                for (var block : blocks) {
                    if (block instanceof PcodeBlockBasic basicBlock) {
                        result.append("### Block ").append(basicBlock.getIndex())
                              .append(" @ ").append(basicBlock.getStart()).append("\n");
                        result.append("```\n");

                        Iterator<PcodeOp> blockOps = basicBlock.getIterator();
                        while (blockOps.hasNext()) {
                            PcodeOp op = blockOps.next();
                            result.append("  ").append(op.toString()).append("\n");
                        }
                        result.append("```\n\n");
                    }
                }
            }

            // Add summary
            result.append("## Summary:\n");
            result.append("- Function: ").append(function.getName()).append("\n");
            result.append("- Entry: ").append(function.getEntryPoint()).append("\n");

            var blocks = highFunction.getBasicBlocks();
            result.append("- Basic Blocks: ").append(blocks.size()).append("\n");

        } finally {
            decompiler.dispose();
        }

        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }

    /**
     * Find a function by name or address.
     * Supports C++ qualified names (e.g., "Class::method" or "Outer::Inner::method").
     */
    private Function findFunction(Program program, String identifier) {
        // Try to parse as address first
        try {
            Address addr = program.getAddressFactory().getAddress(identifier);
            if (addr != null) {
                // Try to get function at the address
                Function func = program.getFunctionManager().getFunctionAt(addr);
                if (func != null) return func;

                // If not found at address, try containing function
                func = program.getFunctionManager().getFunctionContaining(addr);
                if (func != null) return func;
            }
        } catch (Exception e) {
            // Not an address, try as function name
        }

        // Check if this is a qualified name (contains ::)
        if (identifier.contains("::")) {
            String[] parts = identifier.split("::");
            if (parts.length >= 2) {
                String simpleName = parts[parts.length - 1];
                String[] namespaceParts = new String[parts.length - 1];
                System.arraycopy(parts, 0, namespaceParts, 0, parts.length - 1);

                // Search for function with matching name AND namespace
                for (Function function : program.getFunctionManager().getFunctions(true)) {
                    if (function.getName().equals(simpleName) &&
                        matchesNamespaceHierarchy(function, namespaceParts)) {
                        return function;
                    }
                }
            }
        }

        // Fall back to simple name search
        for (Function function : program.getFunctionManager().getFunctions(true)) {
            if (function.getName().equals(identifier)) {
                return function;
            }
        }
        return null;
    }

    /**
     * Check if a function's namespace hierarchy matches the given qualified path.
     * For example, if qualifiedPath is ["Outer", "Inner"], checks if function is in Inner,
     * which is in Outer.
     */
    private boolean matchesNamespaceHierarchy(Function function, String[] namespaceParts) {
        Namespace ns = function.getParentNamespace();

        // Walk backwards through the namespace parts
        for (int i = namespaceParts.length - 1; i >= 0; i--) {
            if (ns == null || ns.isGlobal()) {
                return false; // Ran out of namespaces before matching all parts
            }
            if (!ns.getName().equals(namespaceParts[i])) {
                return false; // Namespace name doesn't match
            }
            ns = ns.getParentNamespace();
        }
        return true;
    }
}

```

`src/main/java/ghidrassistmcp/tools/GetCurrentAddressTool.java`:

```java
/*
 *
 */
package ghidrassistmcp.tools;

import java.util.List;
import java.util.Map;

import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidrassistmcp.GhidrAssistMCPBackend;
import ghidrassistmcp.GhidrAssistMCPPlugin;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that gets the current cursor address in Ghidra.
 */
public class GetCurrentAddressTool implements McpTool {

    @Override
    public String getName() {
        return "get_current_address";
    }

    @Override
    public String getDescription() {
        return "Get the current cursor address in Ghidra";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object",
            Map.of(),
            List.of(), null, null, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        // Fallback for when backend reference is not available
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        return McpSchema.CallToolResult.builder()
            .addTextContent("Current address functionality requires UI context. " +
                          "Program minimum address: " + currentProgram.getMinAddress())
            .build();
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram, GhidrAssistMCPBackend backend) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        // Get the active plugin for UI context
        GhidrAssistMCPPlugin plugin = backend.getActivePlugin();
        if (plugin == null) {
            return execute(arguments, currentProgram);
        }

        Address currentAddress = plugin.getCurrentAddress();
        if (currentAddress == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No current address available (cursor may not be positioned in the listing)")
                .build();
        }

        StringBuilder result = new StringBuilder();
        result.append("Current Address: ").append(currentAddress).append("\n");
        result.append("Program: ").append(currentProgram.getName()).append("\n");
        result.append("Address Space: ").append(currentAddress.getAddressSpace().getName());

        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }
}

```

`src/main/java/ghidrassistmcp/tools/GetCurrentFunctionTool.java`:

```java
/*
 *
 */
package ghidrassistmcp.tools;

import java.util.List;
import java.util.Map;

import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidrassistmcp.GhidrAssistMCPBackend;
import ghidrassistmcp.GhidrAssistMCPPlugin;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that gets the current function in Ghidra.
 */
public class GetCurrentFunctionTool implements McpTool {

    @Override
    public String getName() {
        return "get_current_function";
    }

    @Override
    public String getDescription() {
        return "Get the current function containing the cursor in Ghidra";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object",
            Map.of(),
            List.of(), null, null, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        // Fallback for when backend reference is not available
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        return McpSchema.CallToolResult.builder()
            .addTextContent("Current function functionality requires UI context. Use get_function_by_address with specific addresses instead.")
            .build();
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram, GhidrAssistMCPBackend backend) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        // Get the active plugin for UI context
        GhidrAssistMCPPlugin plugin = backend.getActivePlugin();
        if (plugin == null) {
            return execute(arguments, currentProgram);
        }

        Function currentFunction = plugin.getCurrentFunction();
        if (currentFunction == null) {
            Address currentAddress = plugin.getCurrentAddress();
            if (currentAddress == null) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("No current address available (cursor may not be positioned in the listing)")
                    .build();
            }
            return McpSchema.CallToolResult.builder()
                .addTextContent("No function contains the current address: " + currentAddress)
                .build();
        }

        StringBuilder result = new StringBuilder();
        result.append("Current Function Information:\n\n");
        result.append("Name: ").append(currentFunction.getName()).append("\n");
        result.append("Entry Point: ").append(currentFunction.getEntryPoint()).append("\n");
        result.append("Address Range: ").append(currentFunction.getBody().getMinAddress())
              .append(" - ").append(currentFunction.getBody().getMaxAddress()).append("\n");
        result.append("Parameter Count: ").append(currentFunction.getParameterCount()).append("\n");
        result.append("Calling Convention: ").append(currentFunction.getCallingConventionName()).append("\n");

        // Add signature if available
        String signature = currentFunction.getSignature().getPrototypeString();
        if (signature != null && !signature.isEmpty()) {
            result.append("Signature: ").append(signature).append("\n");
        }

        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }
}

```

`src/main/java/ghidrassistmcp/tools/GetDataTypeTool.java`:

```java
/*
 *
 */
package ghidrassistmcp.tools;

import java.util.List;
import java.util.Map;

import ghidra.program.model.data.Array;
import ghidra.program.model.data.BitFieldDataType;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeComponent;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.Enum;
import ghidra.program.model.data.FunctionDefinition;
import ghidra.program.model.data.Pointer;
import ghidra.program.model.data.Structure;
import ghidra.program.model.data.TypeDef;
import ghidra.program.model.data.Union;
import ghidra.program.model.listing.Program;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that retrieves detailed information about a specific data type,
 * including structure definitions with field layouts.
 */
public class GetDataTypeTool implements McpTool {

    @Override
    public String getName() {
        return "get_data_type";
    }

    @Override
    public String getDescription() {
        return "Get detailed information about a specific data type, including structure/union field layouts, " +
               "enum values, typedef definitions, and type properties. " +
               "Examples: " +
               "1) Get a structure: {\"name\": \"mystruct\"} " +
               "2) Get built-in type: {\"name\": \"int\"} " +
               "3) Get with category: {\"name\": \"IMAGE_DOS_HEADER\", \"category\": \"/winnt.h\"}";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object",
            Map.of(
                "name", new McpSchema.JsonSchema("string", null, null, null, null, null),
                "category", new McpSchema.JsonSchema("string", null, null, null, null, null)
            ),
            List.of("name"), null, null, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        String name = (String) arguments.get("name");
        if (name == null || name.trim().isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("name parameter is required")
                .build();
        }

        String category = (String) arguments.get("category");

        DataTypeManager dtm = currentProgram.getDataTypeManager();
        DataType dataType = null;

        // If category is specified, try to find exact match
        if (category != null && !category.trim().isEmpty()) {
            CategoryPath categoryPath = new CategoryPath(category);
            dataType = dtm.getDataType(categoryPath, name);
        }

        // If not found or no category specified, search all data types
        if (dataType == null) {
            dataType = dtm.getDataType(name);
        }

        // If still not found, try searching by name
        if (dataType == null) {
            java.util.Iterator<DataType> iter = dtm.getAllDataTypes();
            while (iter.hasNext()) {
                DataType dt = iter.next();
                if (dt.getName().equals(name)) {
                    dataType = dt;
                    break;
                }
            }
        }

        if (dataType == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Data type not found: " + name +
                    (category != null ? " in category: " + category : ""))
                .build();
        }

        StringBuilder result = new StringBuilder();
        result.append("Data Type: ").append(dataType.getName()).append("\n");
        result.append("Category: ").append(dataType.getCategoryPath().getPath()).append("\n");

        int size = dataType.getLength();
        if (size > 0) {
            result.append("Size: ").append(size).append(" bytes\n");
        } else if (size == -1) {
            result.append("Size: Variable\n");
        }

        String description = dataType.getDescription();
        if (description != null && !description.isEmpty()) {
            result.append("Description: ").append(description).append("\n");
        }

        result.append("\n");

        // Handle different data type kinds
        if (dataType instanceof Structure) {
            formatStructure((Structure) dataType, result);
        } else if (dataType instanceof Union) {
            formatUnion((Union) dataType, result);
        } else if (dataType instanceof Enum) {
            formatEnum((Enum) dataType, result);
        } else if (dataType instanceof TypeDef) {
            formatTypeDef((TypeDef) dataType, result);
        } else if (dataType instanceof Pointer) {
            formatPointer((Pointer) dataType, result);
        } else if (dataType instanceof Array) {
            formatArray((Array) dataType, result);
        } else if (dataType instanceof FunctionDefinition) {
            formatFunctionDefinition((FunctionDefinition) dataType, result);
        } else {
            result.append("Type Kind: ").append(dataType.getClass().getSimpleName()).append("\n");
            result.append("Display Name: ").append(dataType.getDisplayName()).append("\n");
        }

        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }

    private void formatStructure(Structure struct, StringBuilder result) {
        result.append("Type: Structure");
        if (struct.isPackingEnabled()) {
            result.append(" (packed)");
        }
        result.append("\n\n");

        DataTypeComponent[] components = struct.getComponents();
        if (components.length == 0) {
            result.append("(Empty structure)\n");
            return;
        }

        result.append("Fields:\n");
        
        // Track consecutive undefined bytes for consolidation
        Integer undefinedStartOffset = null;
        int undefinedByteCount = 0;
        
        for (DataTypeComponent comp : components) {
            String dataTypeName = comp.getDataType().getName();
            boolean isUndefined = dataTypeName.equalsIgnoreCase("undefined");
            
            if (isUndefined) {
                // Accumulate undefined bytes
                if (undefinedStartOffset == null) {
                    undefinedStartOffset = comp.getOffset();
                }
                undefinedByteCount += comp.getLength();
            } else {
                // Flush any accumulated undefined bytes before processing this component
                if (undefinedStartOffset != null) {
                    result.append(String.format("  -- %d undefined bytes at 0x%04x --\n",
                        undefinedByteCount, undefinedStartOffset));
                    undefinedStartOffset = null;
                    undefinedByteCount = 0;
                }
                
                // Output the non-undefined component
                result.append(String.format("  +0x%04x [%3d] %-20s %s",
                    comp.getOffset(),
                    comp.getLength(),
                    dataTypeName,
                    comp.getFieldName() != null ? comp.getFieldName() : "(unnamed)"));

                if (comp instanceof BitFieldDataType) {
                    BitFieldDataType bf = (BitFieldDataType) comp;
                    result.append(" : ").append(bf.getBitSize());
                }

                String comment = comp.getComment();
                if (comment != null && !comment.isEmpty()) {
                    result.append("  // ").append(comment);
                }

                result.append("\n");
            }
        }
        
        // Flush any remaining undefined bytes at the end
        if (undefinedStartOffset != null) {
            result.append(String.format("  -- %d undefined bytes at 0x%04x --\n",
                undefinedByteCount, undefinedStartOffset));
        }
    }

    private void formatUnion(Union union, StringBuilder result) {
        result.append("Type: Union\n\n");

        DataTypeComponent[] components = union.getComponents();
        if (components.length == 0) {
            result.append("(Empty union)\n");
            return;
        }

        result.append("Fields:\n");
        for (DataTypeComponent comp : components) {
            result.append(String.format("  [%3d] %-20s %s",
                comp.getLength(),
                comp.getDataType().getName(),
                comp.getFieldName() != null ? comp.getFieldName() : "(unnamed)"));

            String comment = comp.getComment();
            if (comment != null && !comment.isEmpty()) {
                result.append("  // ").append(comment);
            }

            result.append("\n");
        }
    }

    private void formatEnum(Enum enumType, StringBuilder result) {
        result.append("Type: Enum\n\n");

        String[] names = enumType.getNames();
        if (names.length == 0) {
            result.append("(Empty enum)\n");
            return;
        }

        result.append("Values:\n");
        for (String name : names) {
            long value = enumType.getValue(name);
            result.append(String.format("  %-30s = 0x%x (%d)\n", name, value, value));
        }
    }

    private void formatTypeDef(TypeDef typeDef, StringBuilder result) {
        result.append("Type: Typedef\n");
        result.append("Underlying Type: ").append(typeDef.getDataType().getName()).append("\n");
        result.append("Underlying Category: ").append(typeDef.getDataType().getCategoryPath().getPath()).append("\n");
    }

    private void formatPointer(Pointer pointer, StringBuilder result) {
        result.append("Type: Pointer\n");
        result.append("Points To: ").append(pointer.getDataType().getName()).append("\n");
        result.append("Pointer Size: ").append(pointer.getLength()).append(" bytes\n");
    }

    private void formatArray(Array array, StringBuilder result) {
        result.append("Type: Array\n");
        result.append("Element Type: ").append(array.getDataType().getName()).append("\n");
        result.append("Element Count: ").append(array.getNumElements()).append("\n");
        result.append("Element Size: ").append(array.getElementLength()).append(" bytes\n");
    }

    private void formatFunctionDefinition(FunctionDefinition funcDef, StringBuilder result) {
        result.append("Type: Function Definition\n\n");
        result.append("Signature: ").append(funcDef.getPrototypeString()).append("\n");
    }
}

```

`src/main/java/ghidrassistmcp/tools/GetFunctionInfoTool.java`:

```java
/* 
 * 
 */
package ghidrassistmcp.tools;

import java.util.List;
import java.util.Map;

import ghidra.program.model.listing.Program;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that provides detailed information about a specific function.
 */
public class GetFunctionInfoTool implements McpTool {

    @Override
    public boolean isCacheable() {
        return true;
    }

    @Override
    public String getName() {
        return "get_function_info";
    }
    
    @Override
    public String getDescription() {
        return "Get detailed information about a specific function";
    }
    
    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object", 
            Map.of("function_name", new McpSchema.JsonSchema("string", null, null, null, null, null)),
            List.of("function_name"), null, null, null);
    }
    
    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }
        
        String functionName = (String) arguments.get("function_name");
        if (functionName == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Function name is required")
                .build();
        }
        
        String info = getFunctionInfo(currentProgram, functionName);
        return McpSchema.CallToolResult.builder()
            .addTextContent(info)
            .build();
    }
    
    private String getFunctionInfo(Program program, String functionName) {
        var functionManager = program.getFunctionManager();
        var functions = functionManager.getFunctions(true);
        
        for (var function : functions) {
            if (function.getName().equals(functionName)) {
                StringBuilder info = new StringBuilder();
                info.append("Function Information:\n");
                info.append("Name: ").append(function.getName()).append("\n");
                info.append("Entry Point: ").append(function.getEntryPoint()).append("\n");
                info.append("Body: ").append(function.getBody()).append("\n");
                info.append("Parameter Count: ").append(function.getParameterCount()).append("\n");
                info.append("Return Type: ").append(function.getReturnType()).append("\n");
                info.append("Signature: ").append(function.getSignature()).append("\n");
                
                return info.toString();
            }
        }
        
        return "Function not found: " + functionName;
    }
}
```

`src/main/java/ghidrassistmcp/tools/GetHexdumpTool.java`:

```java
/*
 *
 */
package ghidrassistmcp.tools;

import java.util.List;
import java.util.Map;

import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.Memory;
import ghidra.program.model.mem.MemoryAccessException;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that retrieves a hexdump of memory at a specific address.
 * Displays data in standard hex+ASCII format.
 */
public class GetHexdumpTool implements McpTool {

    private static final int BYTES_PER_LINE = 16;

    @Override
    public String getName() {
        return "get_hexdump";
    }

    @Override
    public String getDescription() {
        return "Get a hexdump of memory at a specific address in standard hex+ASCII format. " +
               "Useful for examining data structures, .rodata, .data, .bss, and other non-code regions.";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object",
            Map.of(
                "address", new McpSchema.JsonSchema("string", null, null, null, null, null),
                "len", new McpSchema.JsonSchema("number", null, null, null, null, null)
            ),
            List.of("address", "len"), null, null, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        // Get and validate address parameter
        String addressStr = (String) arguments.get("address");
        if (addressStr == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("address parameter is required")
                .build();
        }

        // Get and validate length parameter
        Object lenObj = arguments.get("len");
        if (lenObj == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("len parameter is required")
                .build();
        }

        int length;
        try {
            // Handle both Integer and Double (JSON numbers can be either)
            if (lenObj instanceof Integer) {
                length = (Integer) lenObj;
            } else if (lenObj instanceof Double) {
                length = ((Double) lenObj).intValue();
            } else if (lenObj instanceof Long) {
                length = ((Long) lenObj).intValue();
            } else {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("len parameter must be a number")
                    .build();
            }

            if (length <= 0) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("len must be greater than 0")
                    .build();
            }

            // Limit maximum length to prevent excessive output
            if (length > 65536) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("len exceeds maximum allowed value of 65536 bytes")
                    .build();
            }
        } catch (Exception e) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Invalid len parameter: " + e.getMessage())
                .build();
        }

        // Parse the address
        Address address;
        try {
            address = currentProgram.getAddressFactory().getAddress(addressStr);
            if (address == null) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Invalid address format: " + addressStr)
                    .build();
            }
        } catch (Exception e) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Invalid address format: " + addressStr + " - " + e.getMessage())
                .build();
        }

        // Generate the hexdump
        try {
            String hexdump = generateHexdump(currentProgram, address, length);
            return McpSchema.CallToolResult.builder()
                .addTextContent(hexdump)
                .build();
        } catch (Exception e) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Error generating hexdump: " + e.getMessage())
                .build();
        }
    }

    /**
     * Generate a hexdump in standard format with hex and ASCII representation.
     * Format: ADDRESS  HEX_BYTES (16 per line, grouped by 8)  |ASCII|
     */
    private String generateHexdump(Program program, Address startAddr, int length) {
        StringBuilder result = new StringBuilder();
        Memory memory = program.getMemory();

        result.append("Hexdump at ").append(startAddr).append(" (").append(length).append(" bytes):\n\n");

        int bytesRead = 0;
        Address currentAddr = startAddr;

        while (bytesRead < length) {
            // Calculate how many bytes to read on this line
            int bytesToRead = Math.min(BYTES_PER_LINE, length - bytesRead);
            byte[] lineBytes = new byte[bytesToRead];

            // Read the bytes for this line
            int actualBytesRead = 0;
            for (int i = 0; i < bytesToRead; i++) {
                try {
                    lineBytes[i] = memory.getByte(currentAddr);
                    currentAddr = currentAddr.add(1);
                    actualBytesRead++;
                } catch (MemoryAccessException e) {
                    // If we can't read a byte, mark it as unreadable
                    lineBytes[i] = 0;
                    currentAddr = currentAddr.add(1);
                    actualBytesRead++;
                }
            }

            // Format the line
            result.append(formatHexdumpLine(startAddr.add(bytesRead), lineBytes, actualBytesRead));
            result.append("\n");

            bytesRead += actualBytesRead;
        }

        return result.toString();
    }

    /**
     * Format a single line of the hexdump.
     */
    private String formatHexdumpLine(Address lineAddr, byte[] bytes, int validBytes) {
        StringBuilder line = new StringBuilder();

        if ( lineAddr.getOffset() > (1L << 32)) {
	        // Address (8 hex digits)
	        line.append(String.format("%08x  ", lineAddr.getOffset()));
        } else {
            // Address (4 hex digits)
            line.append(String.format("%04x  ", lineAddr.getOffset()));
        }

        // Hex bytes (16 per line, with space after 8th byte)
        for (int i = 0; i < BYTES_PER_LINE; i++) {
            if (i < validBytes) {
                line.append(String.format("%02x ", bytes[i] & 0xFF));
            } else {
                line.append("   "); // 3 spaces for missing bytes
            }

            // Extra space after 8th byte
            if (i == 7) {
                line.append(" ");
            }
        }

        // ASCII representation
        line.append(" |");
        for (int i = 0; i < validBytes; i++) {
            char c = (char) (bytes[i] & 0xFF);
            // Print printable ASCII characters, otherwise use '.'
            if (c >= 32 && c <= 126) {
                line.append(c);
            } else {
                line.append('.');
            }
        }
        line.append("|");

        return line.toString();
    }
}

```

`src/main/java/ghidrassistmcp/tools/GetTaskStatusTool.java`:

```java
/*
 * MCP tool for getting task status.
 */
package ghidrassistmcp.tools;

import java.util.List;
import java.util.Map;

import ghidra.program.model.listing.Program;
import ghidrassistmcp.GhidrAssistMCPBackend;
import ghidrassistmcp.McpTool;
import ghidrassistmcp.tasks.McpTask;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that gets the status of an async task or retrieves its result.
 */
public class GetTaskStatusTool implements McpTool {

    @Override
    public String getName() {
        return "get_task_status";
    }

    @Override
    public String getDescription() {
        return "Get the status of an async task, or retrieve its result if completed";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object",
            Map.of(
                "task_id", new McpSchema.JsonSchema("string", null, null, null, null, null)
            ),
            List.of("task_id"), null, null, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        return McpSchema.CallToolResult.builder()
            .addTextContent("Task status requires backend reference. Use execute with backend parameter.")
            .build();
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram, GhidrAssistMCPBackend backend) {
        String taskId = (String) arguments.get("task_id");

        if (taskId == null || taskId.trim().isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("task_id parameter is required")
                .build();
        }

        var taskManager = backend.getTaskManager();
        if (taskManager == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Task manager not available")
                .build();
        }

        McpTask task = taskManager.getTask(taskId);
        if (task == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Task not found: " + taskId)
                .build();
        }

        // If task is completed, return the actual result
        if (task.getStatus() == McpTask.Status.COMPLETED && task.getResult() != null) {
            return task.getResult();
        }

        // Otherwise return status summary
        return McpSchema.CallToolResult.builder()
            .addTextContent(task.toSummary())
            .build();
    }
}

```

`src/main/java/ghidrassistmcp/tools/ListDataTool.java`:

```java
/* 
 * 
 */
package ghidrassistmcp.tools;

import java.util.List;
import java.util.Map;

import ghidra.program.model.data.DataType;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.DataIterator;
import ghidra.program.model.listing.Program;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that lists defined data in the program.
 */
public class ListDataTool implements McpTool {
    
    @Override
    public String getName() {
        return "list_data";
    }
    
    @Override
    public String getDescription() {
        return "List defined data elements in the program";
    }
    
    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object", 
            Map.of(
                "offset", new McpSchema.JsonSchema("integer", null, null, null, null, null),
                "limit", new McpSchema.JsonSchema("integer", null, null, null, null, null),
                "data_type_filter", new McpSchema.JsonSchema("string", null, null, null, null, null)
            ),
            List.of(), null, null, null);
    }
    
    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }
        
        // Parse optional parameters
        int offset = 0;
        int limit = 100; // Default limit
        String dataTypeFilter = (String) arguments.get("data_type_filter");
        
        if (arguments.get("offset") instanceof Number) {
            offset = ((Number) arguments.get("offset")).intValue();
        }
        if (arguments.get("limit") instanceof Number) {
            limit = ((Number) arguments.get("limit")).intValue();
        }
        
        StringBuilder result = new StringBuilder();
        result.append("Defined Data Elements");
        if (dataTypeFilter != null) {
            result.append(" (filtered by: ").append(dataTypeFilter).append(")");
        }
        result.append(":\n\n");
        
        DataIterator dataIter = currentProgram.getListing().getDefinedData(true);
        
        int count = 0;
        int totalCount = 0;
        
        while (dataIter.hasNext()) {
            Data data = dataIter.next();
            
            // Apply data type filter if specified
            if (dataTypeFilter != null) {
                DataType dataType = data.getDataType();
                if (dataType == null || !dataType.getName().toLowerCase().contains(dataTypeFilter.toLowerCase())) {
                    continue;
                }
            }
            
            totalCount++;
            
            // Apply offset
            if (totalCount <= offset) {
                continue;
            }
            
            // Apply limit
            if (count >= limit) {
                break;
            }
            
            DataType dataType = data.getDataType();
            String typeName = dataType != null ? dataType.getName() : "unknown";
            String value = data.getDefaultValueRepresentation();
            if (value != null && value.length() > 50) {
                value = value.substring(0, 47) + "...";
            }
            
            result.append("@ ").append(data.getAddress())
                  .append(" [").append(typeName).append("]");
            
            if (data.hasStringValue()) {
                result.append(" String: ").append(value != null ? value : "null");
            } else if (value != null) {
                result.append(" Value: ").append(value);
            }
            
            // Add symbol name if available
            if (data.getPrimarySymbol() != null) {
                result.append(" (").append(data.getPrimarySymbol().getName()).append(")");
            }
            
            result.append("\n");
            count++;
        }
        
        if (totalCount == 0) {
            if (dataTypeFilter != null) {
                result.append("No data elements found matching filter: ").append(dataTypeFilter);
            } else {
                result.append("No defined data elements found in the program.");
            }
        } else {
            result.append("\nShowing ").append(count).append(" of ").append(totalCount).append(" data elements");
            if (offset > 0) {
                result.append(" (offset: ").append(offset).append(")");
            }
        }
        
        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }
}
```

`src/main/java/ghidrassistmcp/tools/ListDataTypesTool.java`:

```java
/*
 *
 */
package ghidrassistmcp.tools;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.listing.Program;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that lists all available data types in the program.
 * This includes built-in types, user-defined structures, and imported data types.
 */
public class ListDataTypesTool implements McpTool {

    @Override
    public String getName() {
        return "list_data_types";
    }

    @Override
    public String getDescription() {
        return "List all available data types in the program, including built-in types, user-defined structures, and imported types. " +
               "Supports filtering by name pattern and category. " +
               "Examples: " +
               "1) List all types: {} " +
               "2) Search for structures: {\"filter\": \"mystruct\"} " +
               "3) List types in category: {\"category\": \"/myproject\"} " +
               "4) Paginate results: {\"offset\": 0, \"limit\": 50}";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object",
            Map.of(
                "filter", new McpSchema.JsonSchema("string", null, null, null, null, null),
                "category", new McpSchema.JsonSchema("string", null, null, null, null, null),
                "offset", new McpSchema.JsonSchema("integer", null, null, null, null, null),
                "limit", new McpSchema.JsonSchema("integer", null, null, null, null, null)
            ),
            List.of(), null, null, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        // Parse optional parameters
        String filter = (String) arguments.get("filter");
        String category = (String) arguments.get("category");
        int offset = 0;
        int limit = 100; // Default limit

        if (arguments.get("offset") instanceof Number) {
            offset = ((Number) arguments.get("offset")).intValue();
        }
        if (arguments.get("limit") instanceof Number) {
            limit = ((Number) arguments.get("limit")).intValue();
        }

        DataTypeManager dtm = currentProgram.getDataTypeManager();

        // Collect all data types
        List<DataType> dataTypes = new ArrayList<>();
        Iterator<DataType> iter = dtm.getAllDataTypes();
        while (iter.hasNext()) {
            DataType dt = iter.next();

            // Apply name filter if specified
            if (filter != null && !dt.getName().toLowerCase().contains(filter.toLowerCase())) {
                continue;
            }

            // Apply category filter if specified
            if (category != null && !dt.getCategoryPath().getPath().toLowerCase().contains(category.toLowerCase())) {
                continue;
            }

            dataTypes.add(dt);
        }

        // Sort by category path then name for consistent ordering
        Collections.sort(dataTypes, (a, b) -> {
            int pathCompare = a.getCategoryPath().getPath().compareTo(b.getCategoryPath().getPath());
            if (pathCompare != 0) {
                return pathCompare;
            }
            return a.getName().compareTo(b.getName());
        });

        StringBuilder result = new StringBuilder();
        result.append("Available Data Types");
        if (filter != null || category != null) {
            result.append(" (filtered");
            if (filter != null) {
                result.append(" by name: ").append(filter);
            }
            if (category != null) {
                result.append(" by category: ").append(category);
            }
            result.append(")");
        }
        result.append(":\n\n");

        int totalCount = dataTypes.size();
        int count = 0;

        // Apply offset and limit
        for (int i = offset; i < dataTypes.size() && count < limit; i++) {
            DataType dt = dataTypes.get(i);

            result.append("- ").append(dt.getName());
            result.append(" [").append(dt.getCategoryPath().getPath()).append("]");

            // Add size information
            int size = dt.getLength();
            if (size > 0) {
                result.append(" (").append(size).append(" bytes)");
            } else if (size == -1) {
                result.append(" (variable size)");
            }

            // Add description if available
            String description = dt.getDescription();
            if (description != null && !description.isEmpty()) {
                // Truncate long descriptions
                if (description.length() > 60) {
                    description = description.substring(0, 57) + "...";
                }
                result.append(" - ").append(description);
            }

            result.append("\n");
            count++;
        }

        if (totalCount == 0) {
            result.append("No data types found");
            if (filter != null) {
                result.append(" matching filter: ").append(filter);
            }
            if (category != null) {
                result.append(" in category: ").append(category);
            }
            result.append(".");
        } else {
            result.append("\nShowing ").append(count).append(" of ").append(totalCount).append(" data types");
            if (offset > 0) {
                result.append(" (offset: ").append(offset).append(")");
            }
        }

        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }
}

```

`src/main/java/ghidrassistmcp/tools/ListExportsTool.java`:

```java
/* 
 * 
 */
package ghidrassistmcp.tools;

import java.util.List;
import java.util.Map;

import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Symbol;
import ghidra.program.model.symbol.SymbolIterator;
import ghidra.program.model.symbol.SymbolType;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that lists exported functions and symbols.
 */
public class ListExportsTool implements McpTool {
    
    @Override
    public String getName() {
        return "list_exports";
    }
    
    @Override
    public String getDescription() {
        return "List exported functions and symbols";
    }
    
    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object", 
            Map.of(
                "offset", new McpSchema.JsonSchema("integer", null, null, null, null, null),
                "limit", new McpSchema.JsonSchema("integer", null, null, null, null, null)
            ),
            List.of(), null, null, null);
    }
    
    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }
        
        // Parse optional offset and limit
        int offset = 0;
        int limit = 100; // Default limit
        
        if (arguments.get("offset") instanceof Number) {
            offset = ((Number) arguments.get("offset")).intValue();
        }
        if (arguments.get("limit") instanceof Number) {
            limit = ((Number) arguments.get("limit")).intValue();
        }
        
        StringBuilder result = new StringBuilder();
        result.append("Exported Functions and Symbols:\n\n");
        
        SymbolIterator symbolIter = currentProgram.getSymbolTable().getSymbolIterator();
        
        int count = 0;
        int totalCount = 0;
        
        while (symbolIter.hasNext()) {
            Symbol symbol = symbolIter.next();
            
            // Only include global symbols that are potentially exported
            if (symbol.isGlobal() && !symbol.isExternal() &&
                (symbol.getSymbolType() == SymbolType.FUNCTION || 
                 symbol.getSymbolType() == SymbolType.LABEL)) {
                
                totalCount++;
                
                // Apply offset
                if (totalCount <= offset) {
                    continue;
                }
                
                // Apply limit
                if (count >= limit) {
                    break;
                }
                
                result.append("- ").append(symbol.getName())
                      .append(" @ ").append(symbol.getAddress())
                      .append(" (").append(symbol.getSymbolType()).append(")")
                      .append("\n");
                
                count++;
            }
        }
        
        if (totalCount == 0) {
            result.append("No exported symbols found in the program.");
        } else {
            result.append("\nShowing ").append(count).append(" of ").append(totalCount).append(" exports");
            if (offset > 0) {
                result.append(" (offset: ").append(offset).append(")");
            }
        }
        
        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }
}
```

`src/main/java/ghidrassistmcp/tools/ListFunctionsTool.java`:

```java
/*
 * MCP tool that lists functions with optional pattern filtering and pagination.
 * Consolidates list_functions and search_functions functionality.
 */
package ghidrassistmcp.tools;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.FunctionIterator;
import ghidra.program.model.listing.Program;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that lists functions with optional pattern filtering and pagination.
 * Consolidates list_functions and search_functions functionality.
 */
public class ListFunctionsTool implements McpTool {

    @Override
    public boolean isCacheable() {
        return true;
    }

    @Override
    public String getName() {
        return "list_functions";
    }

    @Override
    public String getDescription() {
        return "List functions with optional pattern filtering and pagination";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object",
            Map.of(
                "pattern", new McpSchema.JsonSchema("string", null, null, null, null, null),
                "case_sensitive", new McpSchema.JsonSchema("boolean", null, null, null, null, null),
                "offset", new McpSchema.JsonSchema("integer", null, null, null, null, null),
                "limit", new McpSchema.JsonSchema("integer", null, null, null, null, null)
            ),
            List.of(), null, null, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        // Parse optional parameters
        String pattern = (String) arguments.get("pattern");
        boolean caseSensitive = true;
        if (arguments.get("case_sensitive") instanceof Boolean) {
            caseSensitive = (Boolean) arguments.get("case_sensitive");
        }

        int offset = 0;
        int limit = 100;  // Default limit

        if (arguments.get("offset") instanceof Number) {
            offset = ((Number) arguments.get("offset")).intValue();
        }
        if (arguments.get("limit") instanceof Number) {
            limit = ((Number) arguments.get("limit")).intValue();
        }

        String result = listFunctions(currentProgram, pattern, caseSensitive, offset, limit);
        return McpSchema.CallToolResult.builder()
            .addTextContent(result)
            .build();
    }

    private String listFunctions(Program program, String pattern, boolean caseSensitive, int offset, int limit) {
        StringBuilder result = new StringBuilder();

        boolean hasPattern = pattern != null && !pattern.trim().isEmpty();
        String searchPattern = hasPattern ? (caseSensitive ? pattern : pattern.toLowerCase()) : null;

        if (hasPattern) {
            result.append("Functions matching pattern: \"").append(pattern).append("\"");
            result.append(" (case ").append(caseSensitive ? "sensitive" : "insensitive").append(")\n\n");
        } else {
            result.append("Functions in program:\n\n");
        }

        FunctionIterator functions = program.getFunctionManager().getFunctions(true);

        // Collect matching functions
        List<Function> matchingFunctions = new ArrayList<>();
        while (functions.hasNext()) {
            Function function = functions.next();

            if (hasPattern) {
                String functionName = caseSensitive ? function.getName() : function.getName().toLowerCase();
                if (functionName.contains(searchPattern)) {
                    matchingFunctions.add(function);
                }
            } else {
                matchingFunctions.add(function);
            }
        }

        int totalCount = matchingFunctions.size();
        int count = 0;

        // Apply offset and limit
        for (int i = offset; i < matchingFunctions.size() && count < limit; i++) {
            Function function = matchingFunctions.get(i);
            result.append("- ").append(function.getName())
                  .append(" @ ").append(function.getEntryPoint())
                  .append(" (").append(function.getParameterCount()).append(" params)")
                  .append("\n");
            count++;
        }

        if (totalCount == 0) {
            if (hasPattern) {
                result.append("No functions found matching pattern: \"").append(pattern).append("\"");
            } else {
                result.append("No functions found in the program.");
            }
        } else {
            result.append("\nShowing ").append(count).append(" of ").append(totalCount);
            result.append(hasPattern ? " matching functions" : " functions");
            if (offset > 0) {
                result.append(" (offset: ").append(offset).append(")");
            }
        }

        return result.toString();
    }
}
```

`src/main/java/ghidrassistmcp/tools/ListImportsTool.java`:

```java
/* 
 * 
 */
package ghidrassistmcp.tools;

import java.util.List;
import java.util.Map;

import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Symbol;
import ghidra.program.model.symbol.SymbolIterator;
import ghidra.program.model.symbol.SymbolType;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that lists imported functions and symbols.
 */
public class ListImportsTool implements McpTool {

    @Override
    public boolean isCacheable() {
        return true;
    }

    @Override
    public String getName() {
        return "list_imports";
    }
    
    @Override
    public String getDescription() {
        return "List imported functions and symbols";
    }
    
    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object", 
            Map.of(
                "offset", new McpSchema.JsonSchema("integer", null, null, null, null, null),
                "limit", new McpSchema.JsonSchema("integer", null, null, null, null, null)
            ),
            List.of(), null, null, null);
    }
    
    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }
        
        // Parse optional offset and limit
        int offset = 0;
        int limit = 100; // Default limit
        
        if (arguments.get("offset") instanceof Number) {
            offset = ((Number) arguments.get("offset")).intValue();
        }
        if (arguments.get("limit") instanceof Number) {
            limit = ((Number) arguments.get("limit")).intValue();
        }
        
        StringBuilder result = new StringBuilder();
        result.append("Imported Functions and Symbols:\n\n");
        
        SymbolIterator symbolIter = currentProgram.getSymbolTable().getSymbolIterator();
        
        int count = 0;
        int totalCount = 0;
        
        while (symbolIter.hasNext()) {
            Symbol symbol = symbolIter.next();
            
            // Only include external symbols (imports)
            if (symbol.isExternal() && 
                (symbol.getSymbolType() == SymbolType.FUNCTION || 
                 symbol.getSymbolType() == SymbolType.LABEL)) {
                
                totalCount++;
                
                // Apply offset
                if (totalCount <= offset) {
                    continue;
                }
                
                // Apply limit
                if (count >= limit) {
                    break;
                }
                
                String libraryName = "unknown";
                if (symbol.getParentNamespace() != null) {
                    libraryName = symbol.getParentNamespace().getName();
                }
                
                result.append("- ").append(symbol.getName())
                      .append(" from ").append(libraryName)
                      .append(" @ ").append(symbol.getAddress())
                      .append(" (").append(symbol.getSymbolType()).append(")")
                      .append("\n");
                
                count++;
            }
        }
        
        if (totalCount == 0) {
            result.append("No imported symbols found in the program.");
        } else {
            result.append("\nShowing ").append(count).append(" of ").append(totalCount).append(" imports");
            if (offset > 0) {
                result.append(" (offset: ").append(offset).append(")");
            }
        }
        
        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }
}
```

`src/main/java/ghidrassistmcp/tools/ListNamespacesTool.java`:

```java
/* 
 * 
 */
package ghidrassistmcp.tools;

import java.util.List;
import java.util.Map;

import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Namespace;
import ghidra.program.model.symbol.Symbol;
import ghidra.program.model.symbol.SymbolIterator;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that lists namespaces in the program.
 */
public class ListNamespacesTool implements McpTool {
    
    @Override
    public String getName() {
        return "list_namespaces";
    }
    
    @Override
    public String getDescription() {
        return "List namespaces in the program";
    }
    
    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object", 
            Map.of(
                "offset", new McpSchema.JsonSchema("integer", null, null, null, null, null),
                "limit", new McpSchema.JsonSchema("integer", null, null, null, null, null)
            ),
            List.of(), null, null, null);
    }
    
    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }
        
        // Parse optional offset and limit
        int offset = 0;
        int limit = 100; // Default limit
        
        if (arguments.get("offset") instanceof Number) {
            offset = ((Number) arguments.get("offset")).intValue();
        }
        if (arguments.get("limit") instanceof Number) {
            limit = ((Number) arguments.get("limit")).intValue();
        }
        
        StringBuilder result = new StringBuilder();
        result.append("Namespaces in program:\n\n");
        
        // Get all symbols and find unique namespaces
        SymbolIterator symbolIter = currentProgram.getSymbolTable().getSymbolIterator();
        java.util.Set<Namespace> uniqueNamespaces = new java.util.HashSet<>();
        
        while (symbolIter.hasNext()) {
            Symbol symbol = symbolIter.next();
            Namespace namespace = symbol.getParentNamespace();
            if (namespace != null && !namespace.isGlobal()) {
                uniqueNamespaces.add(namespace);
            }
        }
        
        int count = 0;
        int totalCount = 0;
        
        for (Namespace namespace : uniqueNamespaces) {
            totalCount++;
            
            // Apply offset
            if (totalCount <= offset) {
                continue;
            }
            
            // Apply limit
            if (count >= limit) {
                break;
            }
            
            result.append("- ").append(namespace.getName());
            
            // Show parent namespace if not global
            if (namespace.getParentNamespace() != null && !namespace.getParentNamespace().isGlobal()) {
                result.append(" (in ").append(namespace.getParentNamespace().getName()).append(")");
            }
            
            // Count symbols in this namespace
            try {
                int symbolCount = 0;
                SymbolIterator symbols = currentProgram.getSymbolTable().getSymbols(namespace);
                while (symbols.hasNext()) {
                    symbols.next();
                    symbolCount++;
                }
                result.append(" [").append(symbolCount).append(" symbols]");
            } catch (Exception e) {
                // Ignore errors counting symbols
            }
            
            result.append("\n");
            count++;
        }
        
        if (totalCount == 0) {
            result.append("No user-defined namespaces found in the program.");
        } else {
            result.append("\nShowing ").append(count).append(" of ").append(totalCount).append(" namespaces");
            if (offset > 0) {
                result.append(" (offset: ").append(offset).append(")");
            }
        }
        
        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }
}
```

`src/main/java/ghidrassistmcp/tools/ListProgramsTool.java`:

```java
/*
 * MCP tool for listing all open programs in Ghidra.
 */
package ghidrassistmcp.tools;

import java.util.List;
import java.util.Map;

import ghidra.program.model.listing.Program;
import ghidrassistmcp.GhidrAssistMCPBackend;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that lists all currently open programs in Ghidra.
 * This is essential for multi-program scenarios where the LLM needs to know
 * which programs are available and select the correct one for operations.
 */
public class ListProgramsTool implements McpTool {

    @Override
    public String getName() {
        return "list_programs";
    }

    @Override
    public String getDescription() {
        return "List all currently open programs/binaries in Ghidra. " +
               "Shows program names, paths, and which one is currently active. " +
               "Use this to discover available targets before running other tools. " +
               "IMPORTANT: When multiple programs are open, use the 'program_name' parameter " +
               "in other tools to specify which program to operate on. " +
               "Example: {}";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object",
            Map.of(),
            List.of(), null, null, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        // This tool needs the backend to access all programs
        return McpSchema.CallToolResult.builder()
            .addTextContent("This tool requires backend context. No programs available.")
            .build();
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram, GhidrAssistMCPBackend backend) {
        if (backend == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Backend context not available")
                .build();
        }

        List<Program> programs = backend.getAllOpenPrograms();
        Program activeProgram = backend.getCurrentProgram();

        if (programs.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No programs currently open in Ghidra.\n\n" +
                    "Please open a binary file in Ghidra before using MCP tools.")
                .build();
        }

        StringBuilder result = new StringBuilder();
        result.append("Open Programs in Ghidra:\n\n");

        for (int i = 0; i < programs.size(); i++) {
            Program p = programs.get(i);
            boolean isActive = (activeProgram != null && p.equals(activeProgram));

            result.append(String.format("%d. %s%s\n",
                i + 1,
                p.getName(),
                isActive ? " [ACTIVE]" : ""));

            // Add program details
            result.append(String.format("   Path: %s\n", p.getExecutablePath()));
            result.append(String.format("   Format: %s\n", p.getExecutableFormat()));
            result.append(String.format("   Language: %s\n", p.getLanguageID()));

            if (i < programs.size() - 1) {
                result.append("\n");
            }
        }

        result.append("\n---\n");
        result.append("Total: ").append(programs.size()).append(" program(s) open\n");

        if (programs.size() > 1) {
            result.append("\nNOTE: Multiple programs are open. To target a specific program, ");
            result.append("use the 'program_name' parameter in tool calls.\n");
            result.append("Example: {\"program_name\": \"").append(programs.get(0).getName()).append("\", ...}");
        }

        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }
}

```

`src/main/java/ghidrassistmcp/tools/ListRelocationsTool.java`:

```java
/*
 * MCP tool for listing relocations.
 */
package ghidrassistmcp.tools;

import java.util.Iterator;
import java.util.List;
import java.util.Map;

import ghidra.program.model.listing.Program;
import ghidra.program.model.reloc.Relocation;
import ghidra.program.model.reloc.RelocationTable;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that lists relocation entries from the program.
 */
public class ListRelocationsTool implements McpTool {

    @Override
    public boolean isCacheable() {
        return true;
    }

    @Override
    public String getName() {
        return "list_relocations";
    }

    @Override
    public String getDescription() {
        return "List relocation entries from the program's relocation table";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object",
            Map.of(
                "offset", new McpSchema.JsonSchema("integer", null, null, null, null, null),
                "limit", new McpSchema.JsonSchema("integer", null, null, null, null, null)
            ),
            List.of(), null, null, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        int offset = 0;
        int limit = 100;

        if (arguments.get("offset") instanceof Number) {
            offset = ((Number) arguments.get("offset")).intValue();
        }
        if (arguments.get("limit") instanceof Number) {
            limit = ((Number) arguments.get("limit")).intValue();
        }

        RelocationTable relocationTable = currentProgram.getRelocationTable();
        int totalCount = relocationTable.getSize();

        StringBuilder result = new StringBuilder();
        result.append("Relocation Table for: ").append(currentProgram.getName()).append("\n\n");
        result.append("Total relocations: ").append(totalCount).append("\n\n");

        if (totalCount == 0) {
            result.append("No relocations found in this program.\n");
            return McpSchema.CallToolResult.builder()
                .addTextContent(result.toString())
                .build();
        }

        result.append("## Relocations:\n\n");
        result.append("| Address | Type | Symbol | Values |\n");
        result.append("|---------|------|--------|--------|\n");

        Iterator<Relocation> iter = relocationTable.getRelocations();
        int currentIndex = 0;
        int displayedCount = 0;

        while (iter.hasNext() && displayedCount < limit) {
            Relocation reloc = iter.next();

            // Skip entries before offset
            if (currentIndex < offset) {
                currentIndex++;
                continue;
            }

            result.append("| ").append(reloc.getAddress()).append(" | ");
            result.append(reloc.getType()).append(" | ");

            String symbolName = reloc.getSymbolName();
            result.append(symbolName != null ? symbolName : "-").append(" | ");

            // Format relocation values
            long[] values = reloc.getValues();
            if (values != null && values.length > 0) {
                StringBuilder valStr = new StringBuilder();
                for (int i = 0; i < values.length && i < 4; i++) {
                    if (i > 0) valStr.append(", ");
                    valStr.append(String.format("0x%x", values[i]));
                }
                if (values.length > 4) {
                    valStr.append("...");
                }
                result.append(valStr);
            } else {
                result.append("-");
            }
            result.append(" |\n");

            currentIndex++;
            displayedCount++;
        }

        result.append("\n");
        result.append("Showing ").append(displayedCount).append(" of ").append(totalCount).append(" relocations");
        if (offset > 0) {
            result.append(" (offset: ").append(offset).append(")");
        }
        result.append("\n");

        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }
}

```

`src/main/java/ghidrassistmcp/tools/ListSegmentsTool.java`:

```java
/* 
 * 
 */
package ghidrassistmcp.tools;

import java.util.List;
import java.util.Map;

import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.MemoryBlock;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that lists memory segments/blocks in the program.
 */
public class ListSegmentsTool implements McpTool {
    
    @Override
    public String getName() {
        return "list_segments";
    }
    
    @Override
    public String getDescription() {
        return "List memory segments/blocks in the program";
    }
    
    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object", 
            Map.of(
                "offset", new McpSchema.JsonSchema("integer", null, null, null, null, null),
                "limit", new McpSchema.JsonSchema("integer", null, null, null, null, null)
            ),
            List.of(), null, null, null);
    }
    
    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }
        
        // Parse optional offset and limit
        int offset = 0;
        int limit = 100; // Default limit
        
        if (arguments.get("offset") instanceof Number) {
            offset = ((Number) arguments.get("offset")).intValue();
        }
        if (arguments.get("limit") instanceof Number) {
            limit = ((Number) arguments.get("limit")).intValue();
        }
        
        StringBuilder result = new StringBuilder();
        result.append("Memory Segments/Blocks:\n\n");
        
        MemoryBlock[] blocks = currentProgram.getMemory().getBlocks();
        
        int count = 0;
        int totalCount = blocks.length;
        
        for (int i = offset; i < blocks.length && count < limit; i++) {
            MemoryBlock block = blocks[i];
            
            String permissions = "";
            if (block.isRead()) permissions += "R";
            if (block.isWrite()) permissions += "W";
            if (block.isExecute()) permissions += "X";
            
            result.append("- ").append(block.getName())
                  .append(" @ ").append(block.getStart())
                  .append("-").append(block.getEnd())
                  .append(" (").append(String.format("0x%x", block.getSize())).append(" bytes)")
                  .append(" [").append(permissions).append("]")
                  .append(" Type: ").append(block.getType())
                  .append("\n");
            
            count++;
        }
        
        if (totalCount == 0) {
            result.append("No memory blocks found in the program.");
        } else {
            result.append("\nShowing ").append(count).append(" of ").append(totalCount).append(" segments");
            if (offset > 0) {
                result.append(" (offset: ").append(offset).append(")");
            }
        }
        
        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }
}
```

`src/main/java/ghidrassistmcp/tools/ListStringsTool.java`:

```java
/* 
 * 
 */
package ghidrassistmcp.tools;

import java.util.List;
import java.util.Map;

import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.DataIterator;
import ghidra.program.model.listing.Program;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that lists string data found in the program.
 */
public class ListStringsTool implements McpTool {

    @Override
    public boolean isCacheable() {
        return true;
    }

    @Override
    public String getName() {
        return "list_strings";
    }
    
    @Override
    public String getDescription() {
        return "List string data found in the program, with optional filtering";
    }
    
    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object", 
            Map.of(
                "offset", new McpSchema.JsonSchema("integer", null, null, null, null, null),
                "limit", new McpSchema.JsonSchema("integer", null, null, null, null, null),
                "min_length", new McpSchema.JsonSchema("integer", null, null, null, null, null),
                "filter", new McpSchema.JsonSchema("string", null, null, null, null, null)
            ),
            List.of(), null, null, null);
    }
    
    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }
        
        // Parse optional parameters
        int offset = 0;
        int limit = 100; // Default limit
        int minLength = 4; // Default minimum string length
        String filter = null;
        
        if (arguments.get("offset") instanceof Number) {
            offset = ((Number) arguments.get("offset")).intValue();
        }
        if (arguments.get("limit") instanceof Number) {
            limit = ((Number) arguments.get("limit")).intValue();
        }
        if (arguments.get("min_length") instanceof Number) {
            minLength = ((Number) arguments.get("min_length")).intValue();
        }
        if (arguments.get("filter") instanceof String) {
            filter = ((String) arguments.get("filter")).trim();
            if (filter.isEmpty()) {
                filter = null;
            }
        }
        
        StringBuilder result = new StringBuilder();
        result.append("Strings in program (min length: ").append(minLength);
        if (filter != null) {
            result.append(", filter: \"").append(filter).append("\"");
        }
        result.append("):\n\n");
        
        DataIterator dataIter = currentProgram.getListing().getDefinedData(true);
        
        int count = 0;
        int totalCount = 0;
        
        while (dataIter.hasNext()) {
            Data data = dataIter.next();
            
            // Check if this is string data
            if (data.hasStringValue()) {
                String stringValue = data.getDefaultValueRepresentation();
                String stringText = extractStringText(stringValue);
                
                // Apply minimum length filter
                if (stringText != null && stringText.length() >= minLength) {
                    // Apply optional contains filter (applies before offset/limit)
                    if (filter != null && !stringText.contains(filter)) {
                        continue;
                    }

                    totalCount++;
                    
                    // Apply offset
                    if (totalCount <= offset) {
                        continue;
                    }
                    
                    // Apply limit
                    if (count >= limit) {
                        break;
                    }
                    
                    // Clean up the string representation for display
                    String displayString = stringValue;
                    if (displayString.length() > 80) {
                        displayString = displayString.substring(0, 77) + "...";
                    }
                    
                    result.append("@ ").append(data.getAddress())
                          .append(" (").append(stringText.length()).append(" chars): ")
                          .append(displayString)
                          .append("\n");
                    
                    count++;
                }
            }
        }
        
        if (totalCount == 0) {
            result.append("No strings found in the program with minimum length ").append(minLength).append(".");
        } else {
            result.append("\nShowing ").append(count).append(" of ").append(totalCount).append(" strings");
            if (offset > 0) {
                result.append(" (offset: ").append(offset).append(")");
            }
        }
        
        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }

    /**
     * Extract the "actual" string text from Ghidra's default value representation.
     * This is usually quoted (e.g. "\"Hello\""), sometimes with a prefix (e.g. "L\"Hello\"").
     */
    private static String extractStringText(String defaultValueRepresentation) {
        if (defaultValueRepresentation == null) {
            return null;
        }

        int firstQuote = defaultValueRepresentation.indexOf('"');
        int lastQuote = defaultValueRepresentation.lastIndexOf('"');
        if (firstQuote >= 0 && lastQuote > firstQuote) {
            return defaultValueRepresentation.substring(firstQuote + 1, lastQuote);
        }

        return defaultValueRepresentation;
    }
}
```

`src/main/java/ghidrassistmcp/tools/ListTasksTool.java`:

```java
/*
 * MCP tool for listing async tasks.
 */
package ghidrassistmcp.tools;

import java.util.List;
import java.util.Map;

import ghidra.program.model.listing.Program;
import ghidrassistmcp.GhidrAssistMCPBackend;
import ghidrassistmcp.McpTool;
import ghidrassistmcp.tasks.McpTask;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that lists all async tasks and their status.
 */
public class ListTasksTool implements McpTool {

    @Override
    public String getName() {
        return "list_tasks";
    }

    @Override
    public String getDescription() {
        return "List all async tasks with their status";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object",
            Map.of(
                "status", Map.of(
                    "type", "string",
                    "description", "Optional: filter tasks by status",
                    "enum", List.of("PENDING", "RUNNING", "COMPLETED", "FAILED", "CANCELLED")
                )
            ),
            List.of(), null, null, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        return McpSchema.CallToolResult.builder()
            .addTextContent("Task listing requires backend reference. Use execute with backend parameter.")
            .build();
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram, GhidrAssistMCPBackend backend) {
        var taskManager = backend.getTaskManager();
        if (taskManager == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Task manager not available")
                .build();
        }

        // Check for optional status filter
        String statusStr = (String) arguments.get("status");
        McpTask.Status statusFilter = null;

        if (statusStr != null && !statusStr.trim().isEmpty()) {
            try {
                statusFilter = McpTask.Status.valueOf(statusStr.toUpperCase());
            } catch (IllegalArgumentException e) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Invalid status filter: " + statusStr +
                        ". Valid values: PENDING, RUNNING, COMPLETED, FAILED, CANCELLED")
                    .build();
            }
        }

        // Get tasks summary or filtered list
        if (statusFilter != null) {
            List<McpTask> tasks = taskManager.listTasks(statusFilter);
            StringBuilder sb = new StringBuilder();
            sb.append("Tasks with status ").append(statusFilter).append(":\n\n");

            if (tasks.isEmpty()) {
                sb.append("No tasks found with this status.");
            } else {
                for (McpTask task : tasks) {
                    sb.append("---\n").append(task.toSummary()).append("\n");
                }
            }

            return McpSchema.CallToolResult.builder()
                .addTextContent(sb.toString())
                .build();
        }

        // Return full summary
        return McpSchema.CallToolResult.builder()
            .addTextContent(taskManager.getTasksSummary())
            .build();
    }
}

```

`src/main/java/ghidrassistmcp/tools/ProgramInfoTool.java`:

```java
/* 
 * 
 */
package ghidrassistmcp.tools;

import java.util.List;
import java.util.Map;

import ghidra.program.model.listing.Program;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that provides basic information about the currently loaded program.
 */
public class ProgramInfoTool implements McpTool {
    
    @Override
    public String getName() {
        return "get_program_info";
    }
    
    @Override
    public String getDescription() {
        return "Get information about the currently loaded program";
    }
    
    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object", Map.of(), List.of(), null, null, null);
    }
    
    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }
        
        String info = buildProgramInfo(currentProgram);
        return McpSchema.CallToolResult.builder()
            .addTextContent(info)
            .build();
    }
    
    private String buildProgramInfo(Program program) {
        StringBuilder info = new StringBuilder();
        info.append("Program Information:\n");
        info.append("Name: ").append(program.getName()).append("\n");
        info.append("Language: ").append(program.getLanguage().getLanguageDescription()).append("\n");
        info.append("Address Space: ").append(program.getAddressFactory().getDefaultAddressSpace().getName()).append("\n");
        info.append("Image Base: ").append(program.getImageBase()).append("\n");
        info.append("Min Address: ").append(program.getMinAddress()).append("\n");
        info.append("Max Address: ").append(program.getMaxAddress()).append("\n");
        info.append("Function Count: ").append(program.getFunctionManager().getFunctionCount()).append("\n");
        
        return info.toString();
    }
}
```

`src/main/java/ghidrassistmcp/tools/RenameSymbolBatchTool.java`:

```java
/*
 * MCP tool for batch renaming symbols (functions, data, variables).
 * Uses the same core implementation as RenameSymbolTool to avoid duplicate logic.
 */
package ghidrassistmcp.tools;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;

import ghidra.program.model.listing.Program;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * Batch version of {@code rename_symbol}.
 *
 * Input: { "renames": [ { "target_type": "...", "identifier": "...", "new_name": "...", "variable_name"?: "..." }, ... ] }
 *
 * Output: JSON (as text) with per-item results to support partial success.
 */
public class RenameSymbolBatchTool implements McpTool {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public boolean isReadOnly() {
        return false;
    }

    @Override
    public boolean isIdempotent() {
        // Matches behavior/annotation of the single-item rename tool.
        return true;
    }

    @Override
    public String getName() {
        return "rename_symbol_batch";
    }

    @Override
    public String getDescription() {
        return "Batch rename symbols (functions, data/labels, or local variables) with partial success reporting";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        // NOTE: McpSchema.JsonSchema doesn't have an 'items' field, so we represent arrays using raw Maps.
        Map<String, Object> renameItemProps = new HashMap<>();
        renameItemProps.put("target_type", Map.of(
            "type", "string",
            "description", "What kind of symbol to rename",
            "enum", List.of("function", "data", "variable")
        ));
        renameItemProps.put("identifier", Map.of(
            "type", "string",
            "description", "Target identifier (function: old function name; data: address string; variable: function name)"
        ));
        renameItemProps.put("new_name", Map.of(
            "type", "string",
            "description", "New symbol name (functions may be qualified like Namespace::Func)"
        ));
        renameItemProps.put("variable_name", Map.of(
            "type", "string",
            "description", "Required when target_type is 'variable': old local name to rename"
        ));

        Map<String, Object> renameItemSchema = new HashMap<>();
        renameItemSchema.put("type", "object");
        renameItemSchema.put("properties", renameItemProps);
        renameItemSchema.put("required", List.of("target_type", "identifier", "new_name"));

        Map<String, Object> renamesSchema = new HashMap<>();
        renamesSchema.put("type", "array");
        renamesSchema.put("items", renameItemSchema);

        Map<String, Object> props = new HashMap<>();
        props.put("renames", renamesSchema);

        return new McpSchema.JsonSchema("object", props, List.of("renames"), null, null, null);
    }

    @Override
    @SuppressWarnings("unchecked")
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        Object renamesObj = arguments.get("renames");
        if (!(renamesObj instanceof List<?>)) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("renames parameter is required and must be an array")
                .build();
        }

        List<?> renames = (List<?>) renamesObj;

        ObjectNode root = objectMapper.createObjectNode();
        root.put("program", currentProgram.getName());
        root.put("total", renames.size());

        ArrayNode results = objectMapper.createArrayNode();
        List<ObjectNode> itemNodes = new ArrayList<>(renames.size());

        // Track variable renames per function so we can decompile once per function.
        Map<String, List<RenameSymbolCore.VariableRenameRequest>> variableRenamesByFunction = new HashMap<>();

        for (int i = 0; i < renames.size(); i++) {
            ObjectNode itemResult = objectMapper.createObjectNode();
            itemResult.put("index", i);
            itemNodes.add(itemResult);
            results.add(itemResult);

            Object item = renames.get(i);
            if (!(item instanceof Map<?, ?>)) {
                itemResult.put("success", false);
                itemResult.put("message", "Item is not an object/map");
                continue;
            }

            Map<String, Object> itemArgs;
            try {
                itemArgs = (Map<String, Object>) item;
            } catch (ClassCastException cce) {
                itemResult.put("success", false);
                itemResult.put("message", "Item is not a valid object/map");
                continue;
            }

            // Echo request fields (best-effort) to make partial failures easier to debug.
            Object tt = itemArgs.get("target_type");
            Object id = itemArgs.get("identifier");
            Object nn = itemArgs.get("new_name");
            Object vn = itemArgs.get("variable_name");
            if (tt instanceof String) itemResult.put("target_type", (String) tt);
            if (id instanceof String) itemResult.put("identifier", (String) id);
            if (nn instanceof String) itemResult.put("new_name", (String) nn);
            if (vn instanceof String) itemResult.put("variable_name", (String) vn);

            String targetType = tt instanceof String ? ((String) tt).toLowerCase() : null;
            if ("variable".equals(targetType) && id instanceof String && vn instanceof String && nn instanceof String) {
                // Defer variable renames so they can be applied in one decompile pass per function.
                String functionName = (String) id;
                variableRenamesByFunction
                    .computeIfAbsent(functionName, k -> new ArrayList<>())
                    .add(new RenameSymbolCore.VariableRenameRequest(i, (String) vn, (String) nn));
                continue;
            }

            RenameSymbolCore.RenameResult r;
            try {
                r = RenameSymbolCore.renameOne(itemArgs, currentProgram);
            } catch (Exception e) {
                r = new RenameSymbolCore.RenameResult(false, "Unhandled error: " + e.getMessage());
            }

            itemResult.put("success", r.success);
            itemResult.put("message", r.message);
        }

        // Apply variable renames in batches per function (one decompile pass per function).
        for (Map.Entry<String, List<RenameSymbolCore.VariableRenameRequest>> entry : variableRenamesByFunction.entrySet()) {
            String functionName = entry.getKey();
            List<RenameSymbolCore.VariableRenameRequest> reqs = entry.getValue();

            Map<Integer, RenameSymbolCore.RenameResult> perIndex =
                RenameSymbolCore.renameVariablesBatch(currentProgram, functionName, reqs);

            for (RenameSymbolCore.VariableRenameRequest req : reqs) {
                ObjectNode node = itemNodes.get(req.index);
                RenameSymbolCore.RenameResult r = perIndex.get(req.index);
                if (r == null) {
                    r = new RenameSymbolCore.RenameResult(false, "Unknown error renaming variable");
                }
                node.put("success", r.success);
                node.put("message", r.message);
            }
        }

        int succeeded = 0;
        int failed = 0;
        for (ObjectNode node : itemNodes) {
            if (node.has("success") && node.get("success").isBoolean() && node.get("success").asBoolean()) {
                succeeded++;
            } else {
                failed++;
            }
        }

        root.put("succeeded", succeeded);
        root.put("failed", failed);
        root.set("results", results);

        return McpSchema.CallToolResult.builder()
            .addTextContent(root.toPrettyString())
            .build();
    }
}


```

`src/main/java/ghidrassistmcp/tools/RenameSymbolTool.java`:

```java
/*
 * MCP tool for renaming symbols (functions, data, variables).
 * Consolidates rename_function, rename_data, and rename_variable into a single tool.
 */
package ghidrassistmcp.tools;

import java.util.Iterator;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicReference;

import javax.swing.SwingUtilities;

import ghidra.app.decompiler.DecompInterface;
import ghidra.app.decompiler.DecompileResults;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.program.model.pcode.HighFunction;
import ghidra.program.model.pcode.HighFunctionDBUtil;
import ghidra.program.model.pcode.HighSymbol;
import ghidra.program.model.symbol.Namespace;
import ghidra.program.model.symbol.SourceType;
import ghidra.program.model.symbol.Symbol;
import ghidra.program.model.symbol.SymbolTable;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.exception.InvalidInputException;
import ghidra.util.task.TaskMonitor;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that renames symbols (functions, data, or variables).
 * Replaces separate rename_function, rename_data, and rename_variable tools.
 */
public class RenameSymbolTool implements McpTool {

    @Override
    public boolean isReadOnly() {
        return false;
    }

    @Override
    public boolean isIdempotent() {
        return true;
    }

    @Override
    public String getName() {
        return "rename_symbol";
    }

    @Override
    public String getDescription() {
        return "Rename a symbol (function, data/label, or local variable)";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object",
            Map.of(
                "target_type", Map.of(
                    "type", "string",
                    "description", "What kind of symbol to rename",
                    "enum", List.of("function", "data", "variable")
                ),
                "identifier", Map.of(
                    "type", "string",
                    "description", "Target identifier (function: old function name; data: address string; variable: function name)"
                ),
                "new_name", Map.of(
                    "type", "string",
                    "description", "New symbol name (functions may be qualified like Namespace::Func)"
                ),
                "variable_name", Map.of(
                    "type", "string",
                    "description", "Required when target_type is 'variable': old local name to rename"
                )
            ),
            List.of("target_type", "identifier", "new_name"), null, null, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        RenameSymbolCore.RenameResult result = RenameSymbolCore.renameOne(arguments, currentProgram);
        return McpSchema.CallToolResult.builder()
            .addTextContent(result.message)
            .build();
    }
}

/**
 * Shared implementation for symbol renaming operations.
 *
 * Package-private so both `RenameSymbolTool` and a batch variant can share logic
 * without duplicating implementations.
 */
final class RenameSymbolCore {

    static final class RenameResult {
        final boolean success;
        final String message;

        RenameResult(boolean success, String message) {
            this.success = success;
            this.message = message;
        }
    }

    private RenameSymbolCore() {
        // utility
    }

    static RenameResult renameOne(Map<String, Object> arguments, Program program) {
        if (program == null) {
            return new RenameResult(false, "No program currently loaded");
        }

        String targetType = getString(arguments, "target_type");
        String identifier = getString(arguments, "identifier");
        String newName = getString(arguments, "new_name");

        if (targetType == null || targetType.isEmpty()) {
            return new RenameResult(false, "target_type parameter is required ('function', 'data', or 'variable')");
        }
        if (identifier == null || identifier.isEmpty()) {
            return new RenameResult(false, "identifier parameter is required");
        }
        if (newName == null || newName.isEmpty()) {
            return new RenameResult(false, "new_name parameter is required");
        }

        targetType = targetType.toLowerCase();

        switch (targetType) {
            case "function":
                return renameFunction(program, identifier, newName);
            case "data":
                return renameData(program, identifier, newName);
            case "variable": {
                String variableName = getString(arguments, "variable_name");
                if (variableName == null || variableName.isEmpty()) {
                    return new RenameResult(false, "variable_name parameter is required when target_type is 'variable'");
                }
                return renameVariable(program, identifier, variableName, newName);
            }
            default:
                return new RenameResult(false, "Invalid target_type. Use 'function', 'data', or 'variable'");
        }
    }

    private static String getString(Map<String, Object> arguments, String key) {
        Object v = arguments.get(key);
        if (v instanceof String) {
            return (String) v;
        }
        return null;
    }

    static final class VariableRenameRequest {
        final int index;
        final String oldName;
        final String newName;

        VariableRenameRequest(int index, String oldName, String newName) {
            this.index = index;
            this.oldName = oldName;
            this.newName = newName;
        }
    }

    /**
     * Batch rename variables within a single function using one decompile pass.
     *
     * This avoids the "renumbering" issue that can occur when you re-decompile after each rename
     * and rely on decompiler-generated names like uVar23/uVar24 being stable.
     *
     * Returns a result per request index (partial success supported).
     */
    static Map<Integer, RenameResult> renameVariablesBatch(Program program, String functionName,
                                                          List<VariableRenameRequest> renames) {
        Map<Integer, RenameResult> resultsByIndex = new HashMap<>();

        if (program == null) {
            for (VariableRenameRequest r : renames) {
                resultsByIndex.put(r.index, new RenameResult(false, "No program currently loaded"));
            }
            return resultsByIndex;
        }
        if (functionName == null || functionName.isEmpty()) {
            for (VariableRenameRequest r : renames) {
                resultsByIndex.put(r.index, new RenameResult(false, "Function name is required for variable renames"));
            }
            return resultsByIndex;
        }

        Function function = findFunctionByName(program, functionName);
        if (function == null) {
            for (VariableRenameRequest r : renames) {
                resultsByIndex.put(r.index, new RenameResult(false, "Function not found: " + functionName));
            }
            return resultsByIndex;
        }

        DecompInterface decompiler = new DecompInterface();
        try {
            decompiler.openProgram(program);
            DecompileResults decompileResults = decompiler.decompileFunction(function, 30, TaskMonitor.DUMMY);

            if (decompileResults.isTimedOut()) {
                for (VariableRenameRequest r : renames) {
                    resultsByIndex.put(r.index, new RenameResult(false,
                        "Decompilation timed out for function: " + functionName));
                }
                return resultsByIndex;
            }
            if (!decompileResults.isValid()) {
                for (VariableRenameRequest r : renames) {
                    resultsByIndex.put(r.index, new RenameResult(false,
                        "Decompilation error for function " + functionName + ": " + decompileResults.getErrorMessage()));
                }
                return resultsByIndex;
            }

            HighFunction highFunction = decompileResults.getHighFunction();
            if (highFunction == null) {
                for (VariableRenameRequest r : renames) {
                    resultsByIndex.put(r.index, new RenameResult(false,
                        "Could not get high function for: " + functionName));
                }
                return resultsByIndex;
            }

            Map<String, HighSymbol> symbolsByName = new HashMap<>();
            Iterator<HighSymbol> symbols = highFunction.getLocalSymbolMap().getSymbols();
            while (symbols.hasNext()) {
                HighSymbol s = symbols.next();
                // First one wins; duplicate names are rare but possible.
                symbolsByName.putIfAbsent(s.getName(), s);
            }

            // Resolve all symbols up-front from the single decompile pass.
            final List<ResolvedVarRename> toApply = new ArrayList<>();
            for (VariableRenameRequest req : renames) {
                if (req.oldName == null || req.oldName.isEmpty()) {
                    resultsByIndex.put(req.index, new RenameResult(false, "variable_name is required"));
                    continue;
                }
                if (req.newName == null || req.newName.isEmpty()) {
                    resultsByIndex.put(req.index, new RenameResult(false, "new_name parameter is required"));
                    continue;
                }

                HighSymbol sym = symbolsByName.get(req.oldName);
                if (sym == null) {
                    resultsByIndex.put(req.index, new RenameResult(false,
                        "Variable '" + req.oldName + "' not found in function '" + functionName + "'"));
                    continue;
                }
                toApply.add(new ResolvedVarRename(req.index, req.oldName, req.newName, sym));
            }

            // Apply on EDT. Use per-rename transactions so partial success is preserved.
            try {
                SwingUtilities.invokeAndWait(() -> {
                    for (ResolvedVarRename r : toApply) {
                        int txId = program.startTransaction("Rename Variable");
                        try {
                            HighFunctionDBUtil.updateDBVariable(r.symbol, r.newName, null, SourceType.USER_DEFINED);
                            program.endTransaction(txId, true);
                            resultsByIndex.put(r.index, new RenameResult(true,
                                "Successfully renamed variable '" + r.oldName + "' to '" + r.newName +
                                    "' in function '" + functionName + "'"));
                        } catch (DuplicateNameException e) {
                            program.endTransaction(txId, false);
                            resultsByIndex.put(r.index, new RenameResult(false,
                                "Variable with name '" + r.newName + "' already exists in function '" + functionName + "'"));
                        } catch (InvalidInputException e) {
                            program.endTransaction(txId, false);
                            resultsByIndex.put(r.index, new RenameResult(false, "Invalid variable name: " + r.newName));
                        } catch (Exception e) {
                            program.endTransaction(txId, false);
                            resultsByIndex.put(r.index, new RenameResult(false, "Error renaming variable: " + e.getMessage()));
                        }
                    }
                });
            } catch (Exception e) {
                // If EDT dispatch fails, mark anything that wasn't already resolved as a failure.
                for (ResolvedVarRename r : toApply) {
                    resultsByIndex.putIfAbsent(r.index, new RenameResult(false,
                        "Error executing rename on EDT: " + e.getMessage()));
                }
            }

            return resultsByIndex;
        } catch (Exception e) {
            for (VariableRenameRequest r : renames) {
                resultsByIndex.put(r.index, new RenameResult(false, "Error renaming variable: " + e.getMessage()));
            }
            return resultsByIndex;
        } finally {
            decompiler.dispose();
        }
    }

    private static final class ResolvedVarRename {
        final int index;
        final String oldName;
        final String newName;
        final HighSymbol symbol;

        ResolvedVarRename(int index, String oldName, String newName, HighSymbol symbol) {
            this.index = index;
            this.oldName = oldName;
            this.newName = newName;
            this.symbol = symbol;
        }
    }

    /**
     * Rename a function.
     * Supports C++ qualified names (e.g., "Class::method" or "Outer::Inner::method").
     * When a qualified name is provided, the namespace hierarchy is created if it doesn't exist.
     *
     * Note: Symbol operations must run on the Swing EDT to avoid race conditions with
     * Ghidra's Symbol Tree UI updates.
     */
    private static RenameResult renameFunction(Program program, String oldName, String newName) {
        Function function = findFunctionByName(program, oldName);
        if (function == null) {
            return new RenameResult(false, "Function not found: " + oldName);
        }

        AtomicReference<RenameResult> resultRef = new AtomicReference<>();
        final Function targetFunction = function;

        try {
            SwingUtilities.invokeAndWait(() -> {
                int transactionID = program.startTransaction("Rename Function");
                try {
                    Object[] parsed = parseAndCreateNamespace(program, newName);
                    if (parsed == null) {
                        program.endTransaction(transactionID, false);
                        resultRef.set(new RenameResult(false, "Invalid qualified name format: " + newName));
                        return;
                    }

                    Namespace targetNamespace = (Namespace) parsed[0];
                    String simpleName = (String) parsed[1];

                    // Check if a function with this name already exists in the target namespace
                    Function existingFunction = findFunctionByName(program, simpleName);
                    if (existingFunction != null && existingFunction != targetFunction &&
                        existingFunction.getParentNamespace().equals(targetNamespace)) {
                        program.endTransaction(transactionID, false);
                        resultRef.set(new RenameResult(false,
                            "Function with name '" + simpleName + "' already exists in namespace '" +
                                targetNamespace.getName(true) + "'"));
                        return;
                    }

                    if (!targetNamespace.isGlobal()) {
                        targetFunction.setParentNamespace(targetNamespace);
                    }

                    targetFunction.setName(simpleName, SourceType.USER_DEFINED);
                    program.endTransaction(transactionID, true);

                    String resultName = targetNamespace.isGlobal()
                        ? simpleName
                        : targetNamespace.getName(true) + "::" + simpleName;
                    resultRef.set(new RenameResult(true,
                        "Successfully renamed function '" + oldName + "' to '" + resultName + "'"));
                } catch (Exception e) {
                    program.endTransaction(transactionID, false);
                    resultRef.set(new RenameResult(false, "Error renaming function: " + e.getMessage()));
                }
            });
        } catch (Exception e) {
            return new RenameResult(false, "Error executing rename on EDT: " + e.getMessage());
        }

        return resultRef.get() != null ? resultRef.get() : new RenameResult(false, "Unknown error renaming function");
    }

    /**
     * Rename data/label at an address.
     *
     * Note: Symbol operations must run on the Swing EDT to avoid race conditions with
     * Ghidra's Symbol Tree UI updates.
     */
    private static RenameResult renameData(Program program, String addressStr, String newName) {
        Address address;
        try {
            address = program.getAddressFactory().getAddress(addressStr);
            if (address == null) {
                return new RenameResult(false, "Invalid address: " + addressStr);
            }
        } catch (Exception e) {
            return new RenameResult(false, "Invalid address format: " + addressStr);
        }

        AtomicReference<RenameResult> resultRef = new AtomicReference<>();
        final Address targetAddress = address;

        try {
            SwingUtilities.invokeAndWait(() -> {
                int transactionID = program.startTransaction("Rename Data");
                try {
                    Data data = program.getListing().getDataAt(targetAddress);
                    if (data != null) {
                        Symbol primarySymbol = data.getPrimarySymbol();
                        if (primarySymbol != null) {
                            String oldName = primarySymbol.getName();
                            try {
                                primarySymbol.setName(newName, SourceType.USER_DEFINED);
                                program.endTransaction(transactionID, true);
                                resultRef.set(new RenameResult(true,
                                    "Successfully renamed data at " + addressStr +
                                        " from '" + oldName + "' to '" + newName + "'"));
                                return;
                            } catch (DuplicateNameException e) {
                                program.endTransaction(transactionID, false);
                                resultRef.set(new RenameResult(false,
                                    "Symbol with name '" + newName + "' already exists"));
                                return;
                            } catch (InvalidInputException e) {
                                program.endTransaction(transactionID, false);
                                resultRef.set(new RenameResult(false, "Invalid symbol name: " + newName));
                                return;
                            }
                        }

                        program.getSymbolTable().createLabel(targetAddress, newName, SourceType.USER_DEFINED);
                        program.endTransaction(transactionID, true);
                        resultRef.set(new RenameResult(true,
                            "Successfully created label '" + newName + "' at " + addressStr));
                        return;
                    }

                    Symbol[] symbols = program.getSymbolTable().getSymbols(targetAddress);
                    if (symbols.length > 0) {
                        Symbol symbol = symbols[0];
                        String oldName = symbol.getName();
                        try {
                            symbol.setName(newName, SourceType.USER_DEFINED);
                            program.endTransaction(transactionID, true);
                            resultRef.set(new RenameResult(true,
                                "Successfully renamed symbol at " + addressStr +
                                    " from '" + oldName + "' to '" + newName + "'"));
                            return;
                        } catch (DuplicateNameException e) {
                            program.endTransaction(transactionID, false);
                            resultRef.set(new RenameResult(false,
                                "Symbol with name '" + newName + "' already exists"));
                            return;
                        } catch (InvalidInputException e) {
                            program.endTransaction(transactionID, false);
                            resultRef.set(new RenameResult(false, "Invalid symbol name: " + newName));
                            return;
                        }
                    }

                    program.getSymbolTable().createLabel(targetAddress, newName, SourceType.USER_DEFINED);
                    program.endTransaction(transactionID, true);
                    resultRef.set(new RenameResult(true,
                        "Successfully created label '" + newName + "' at " + addressStr));
                } catch (Exception e) {
                    program.endTransaction(transactionID, false);
                    resultRef.set(new RenameResult(false, "Error creating label: " + e.getMessage()));
                }
            });
        } catch (Exception e) {
            return new RenameResult(false, "Error executing rename on EDT: " + e.getMessage());
        }

        return resultRef.get() != null ? resultRef.get() : new RenameResult(false, "Unknown error renaming data");
    }

    /**
     * Rename a local variable within a function.
     *
     * Note: Symbol operations must run on the Swing EDT to avoid race conditions with
     * Ghidra's Symbol Tree UI updates.
     */
    private static RenameResult renameVariable(Program program, String functionName,
                                              String oldVariableName, String newVariableName) {
        Function function = findFunctionByName(program, functionName);
        if (function == null) {
            return new RenameResult(false, "Function not found: " + functionName);
        }

        DecompInterface decompiler = new DecompInterface();
        try {
            decompiler.openProgram(program);
            DecompileResults results = decompiler.decompileFunction(function, 30, TaskMonitor.DUMMY);

            if (results.isTimedOut()) {
                return new RenameResult(false, "Decompilation timed out for function: " + functionName);
            }
            if (!results.isValid()) {
                return new RenameResult(false,
                    "Decompilation error for function " + functionName + ": " + results.getErrorMessage());
            }

            HighFunction highFunction = results.getHighFunction();
            if (highFunction == null) {
                return new RenameResult(false, "Could not get high function for: " + functionName);
            }

            HighSymbol targetSymbol = null;
            Iterator<HighSymbol> symbols = highFunction.getLocalSymbolMap().getSymbols();
            while (symbols.hasNext()) {
                HighSymbol symbol = symbols.next();
                if (symbol.getName().equals(oldVariableName)) {
                    targetSymbol = symbol;
                    break;
                }
            }

            if (targetSymbol == null) {
                return new RenameResult(false,
                    "Variable '" + oldVariableName + "' not found in function '" + functionName + "'");
            }

            AtomicReference<RenameResult> resultRef = new AtomicReference<>();
            final HighSymbol symbolToRename = targetSymbol;

            SwingUtilities.invokeAndWait(() -> {
                int transactionID = program.startTransaction("Rename Variable");
                try {
                    HighFunctionDBUtil.updateDBVariable(symbolToRename, newVariableName, null, SourceType.USER_DEFINED);
                    program.endTransaction(transactionID, true);
                    resultRef.set(new RenameResult(true,
                        "Successfully renamed variable '" + oldVariableName + "' to '" + newVariableName +
                            "' in function '" + functionName + "'"));
                } catch (DuplicateNameException e) {
                    program.endTransaction(transactionID, false);
                    resultRef.set(new RenameResult(false,
                        "Variable with name '" + newVariableName + "' already exists in function '" + functionName + "'"));
                } catch (InvalidInputException e) {
                    program.endTransaction(transactionID, false);
                    resultRef.set(new RenameResult(false, "Invalid variable name: " + newVariableName));
                } catch (Exception e) {
                    program.endTransaction(transactionID, false);
                    resultRef.set(new RenameResult(false, "Error renaming variable: " + e.getMessage()));
                }
            });

            return resultRef.get() != null ? resultRef.get() : new RenameResult(false, "Unknown error renaming variable");
        } catch (Exception e) {
            return new RenameResult(false, "Error renaming variable: " + e.getMessage());
        } finally {
            decompiler.dispose();
        }
    }

    private static Function findFunctionByName(Program program, String functionName) {
        var functionManager = program.getFunctionManager();
        var functions = functionManager.getFunctions(true);
        for (Function function : functions) {
            if (function.getName().equals(functionName)) {
                return function;
            }
        }
        return null;
    }

    /**
     * Parse a qualified name (e.g., "Class::method" or "Outer::Inner::method")
     * and return the namespace and simple name.
     * Creates namespace hierarchy if it doesn't exist.
     *
     * @return Object[] with [Namespace, String simpleName], or null on error
     */
    private static Object[] parseAndCreateNamespace(Program program, String qualifiedName) {
        if (!qualifiedName.contains("::")) {
            return new Object[] { program.getGlobalNamespace(), qualifiedName };
        }

        String[] parts = qualifiedName.split("::");
        if (parts.length < 2) {
            return null;
        }

        String simpleName = parts[parts.length - 1];
        SymbolTable symbolTable = program.getSymbolTable();
        Namespace currentNamespace = program.getGlobalNamespace();

        for (int i = 0; i < parts.length - 1; i++) {
            String nsName = parts[i].trim();
            if (nsName.isEmpty()) {
                continue;
            }

            try {
                Namespace existingNs = symbolTable.getNamespace(nsName, currentNamespace);
                if (existingNs != null) {
                    currentNamespace = existingNs;
                } else {
                    currentNamespace = symbolTable.createClass(currentNamespace, nsName, SourceType.USER_DEFINED);
                }
            } catch (Exception e) {
                try {
                    currentNamespace = symbolTable.createNameSpace(currentNamespace, nsName, SourceType.USER_DEFINED);
                } catch (Exception e2) {
                    return null;
                }
            }
        }

        return new Object[] { currentNamespace, simpleName };
    }
}

```

`src/main/java/ghidrassistmcp/tools/SearchBytesTool.java`:

```java
/*
 * MCP tool for searching byte patterns in memory.
 */
package ghidrassistmcp.tools;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.Memory;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that searches for byte patterns in program memory.
 */
public class SearchBytesTool implements McpTool {

    @Override
    public String getName() {
        return "search_bytes";
    }

    @Override
    public String getDescription() {
        return "Search for byte patterns in program memory (hex string with optional wildcards '??')";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object",
            Map.of(
                "pattern", new McpSchema.JsonSchema("string", null, null, null, null, null),
                "limit", new McpSchema.JsonSchema("integer", null, null, null, null, null)
            ),
            List.of("pattern"), null, null, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        String pattern = (String) arguments.get("pattern");
        int limit = 100;

        if (arguments.get("limit") instanceof Number) {
            limit = ((Number) arguments.get("limit")).intValue();
        }

        if (pattern == null || pattern.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Pattern is required")
                .build();
        }

        // Parse the pattern (hex string with optional wildcards)
        byte[] searchBytes;
        byte[] searchMask;
        try {
            ParsedPattern parsed = parsePattern(pattern);
            searchBytes = parsed.bytes;
            searchMask = parsed.mask;
        } catch (Exception e) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Invalid pattern format: " + e.getMessage() +
                    "\nExpected hex bytes like '48 8b c1' or '48 ?? c1' for wildcards")
                .build();
        }

        Memory memory = currentProgram.getMemory();
        List<Address> matches = new ArrayList<>();

        StringBuilder result = new StringBuilder();
        result.append("Searching for pattern: ").append(pattern).append("\n");
        result.append("Pattern length: ").append(searchBytes.length).append(" bytes\n\n");

        // Search through all memory blocks
        try {
            Address startAddr = memory.getMinAddress();
            Address endAddr = memory.getMaxAddress();

            if (startAddr == null || endAddr == null) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("No memory to search")
                    .build();
            }

            Address addr = startAddr;
            while (addr != null && matches.size() < limit) {
                addr = memory.findBytes(addr, endAddr, searchBytes, searchMask, true, null);
                if (addr != null) {
                    matches.add(addr);
                    addr = addr.add(1); // Move past this match
                }
            }
        } catch (Exception e) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Error during search: " + e.getMessage())
                .build();
        }

        result.append("Found ").append(matches.size()).append(" matches");
        if (matches.size() >= limit) {
            result.append(" (limited to ").append(limit).append(")");
        }
        result.append(":\n\n");

        for (Address match : matches) {
            result.append("  ").append(match);

            // Try to get function context
            var func = currentProgram.getFunctionManager().getFunctionContaining(match);
            if (func != null) {
                result.append(" in ").append(func.getName());
            }
            result.append("\n");
        }

        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }

    private static class ParsedPattern {
        byte[] bytes;
        byte[] mask;
    }

    private ParsedPattern parsePattern(String pattern) throws Exception {
        // Remove common separators and normalize
        pattern = pattern.replaceAll("[\\s,]", "");

        if (pattern.length() % 2 != 0) {
            throw new Exception("Pattern must have even number of hex characters");
        }

        int length = pattern.length() / 2;
        byte[] bytes = new byte[length];
        byte[] mask = new byte[length];

        for (int i = 0; i < length; i++) {
            String byteStr = pattern.substring(i * 2, i * 2 + 2);

            if (byteStr.equals("??") || byteStr.equals("**")) {
                // Wildcard
                bytes[i] = 0;
                mask[i] = 0;
            } else {
                try {
                    bytes[i] = (byte) Integer.parseInt(byteStr, 16);
                    mask[i] = (byte) 0xFF;
                } catch (NumberFormatException e) {
                    throw new Exception("Invalid hex byte: " + byteStr);
                }
            }
        }

        ParsedPattern result = new ParsedPattern();
        result.bytes = bytes;
        result.mask = mask;
        return result;
    }
}

```

`src/main/java/ghidrassistmcp/tools/SetCommentTool.java`:

```java
/*
 * MCP tool for setting comments on functions or addresses.
 * Consolidates set_decompiler_comment and set_disassembly_comment into a single tool.
 */
package ghidrassistmcp.tools;

import java.util.List;
import java.util.Map;

import ghidra.program.model.address.Address;
import ghidra.program.model.listing.CodeUnit;
import ghidra.program.model.listing.CommentType;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that sets comments on functions or addresses.
 * Replaces separate set_decompiler_comment and set_disassembly_comment tools.
 */
public class SetCommentTool implements McpTool {

    @Override
    public boolean isReadOnly() {
        return false;
    }

    @Override
    public boolean isIdempotent() {
        return true;
    }

    @Override
    public String getName() {
        return "set_comment";
    }

    @Override
    public String getDescription() {
        return "Set a comment on a function (decompiler view) or at an address (disassembly view)";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object",
            Map.of(
                "target", Map.of(
                    "type", "string",
                    "description", "Where to set the comment",
                    "enum", List.of("function", "address")
                ),
                "function_name", Map.of(
                    "type", "string",
                    "description", "Required when target is 'function': function name"
                ),
                "address", Map.of(
                    "type", "string",
                    "description", "Required when target is 'address': address string"
                ),
                "comment", Map.of(
                    "type", "string",
                    "description", "Comment text"
                ),
                "comment_type", Map.of(
                    "type", "string",
                    "description", "Optional: comment type for target 'address' (canonical values). Aliases like 'eol_comment' are accepted at runtime.",
                    "enum", List.of("eol", "pre", "post", "plate", "repeatable"),
                    "default", "eol"
                )
            ),
            List.of("target", "comment"), null, null, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        String target = (String) arguments.get("target");
        String comment = (String) arguments.get("comment");

        if (target == null || target.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("target parameter is required ('function' or 'address')")
                .build();
        }

        if (comment == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("comment parameter is required")
                .build();
        }

        target = target.toLowerCase();
        if (!target.equals("function") && !target.equals("address")) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Invalid target. Use 'function' or 'address'")
                .build();
        }

        // Dispatch to appropriate handler based on target
        if (target.equals("function")) {
            return setFunctionComment(arguments, currentProgram, comment);
        }
        return setAddressComment(arguments, currentProgram, comment);
    }

    /**
     * Set a comment on a function (appears in decompiler view).
     */
    private McpSchema.CallToolResult setFunctionComment(Map<String, Object> arguments, Program program, String comment) {
        String functionName = (String) arguments.get("function_name");

        if (functionName == null || functionName.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("function_name parameter is required when target is 'function'")
                .build();
        }

        // Find the function
        Function function = findFunctionByName(program, functionName);
        if (function == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Function not found: " + functionName)
                .build();
        }

        // Set the function comment within a transaction
        int transactionID = program.startTransaction("Set Function Comment");
        try {
            function.setComment(comment);
            program.endTransaction(transactionID, true);

            return McpSchema.CallToolResult.builder()
                .addTextContent("Successfully set decompiler comment on function '" + functionName +
                              "': \"" + comment + "\"")
                .build();
        } catch (Exception e) {
            program.endTransaction(transactionID, false);
            return McpSchema.CallToolResult.builder()
                .addTextContent("Error setting function comment: " + e.getMessage())
                .build();
        }
    }

    /**
     * Set a comment at an address (appears in disassembly view).
     */
    private McpSchema.CallToolResult setAddressComment(Map<String, Object> arguments, Program program, String comment) {
        String addressStr = (String) arguments.get("address");
        String commentTypeStr = (String) arguments.get("comment_type");

        if (addressStr == null || addressStr.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("address parameter is required when target is 'address'")
                .build();
        }

        // Parse the address
        Address address;
        try {
            address = program.getAddressFactory().getAddress(addressStr);
            if (address == null) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Invalid address: " + addressStr)
                    .build();
            }
        } catch (Exception e) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Invalid address format: " + addressStr)
                .build();
        }

        // Determine comment type (default to EOL comment)
        CommentType commentType = parseCommentType(commentTypeStr);

        // Get the code unit at the address
        CodeUnit codeUnit = program.getListing().getCodeUnitAt(address);
        if (codeUnit == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No code unit found at address: " + addressStr)
                .build();
        }

        // Set the comment within a transaction
        int transactionID = program.startTransaction("Set Disassembly Comment");
        try {
            codeUnit.setComment(commentType, comment);
            program.endTransaction(transactionID, true);

            String commentTypeName = getCommentTypeName(commentType);
            return McpSchema.CallToolResult.builder()
                .addTextContent("Successfully set " + commentTypeName + " comment at " + addressStr +
                              ": \"" + comment + "\"")
                .build();
        } catch (Exception e) {
            program.endTransaction(transactionID, false);
            return McpSchema.CallToolResult.builder()
                .addTextContent("Error setting comment: " + e.getMessage())
                .build();
        }
    }

    /**
     * Parse comment type string into CommentType enum.
     */
    private CommentType parseCommentType(String commentTypeStr) {
        if (commentTypeStr == null) {
            return CommentType.EOL;
        }

        switch (commentTypeStr.toLowerCase()) {
            case "pre":
            case "pre_comment":
                return CommentType.PRE;
            case "post":
            case "post_comment":
                return CommentType.POST;
            case "plate":
            case "plate_comment":
                return CommentType.PLATE;
            case "repeatable":
            case "repeatable_comment":
                return CommentType.REPEATABLE;
            case "eol":
            case "eol_comment":
            default:
                return CommentType.EOL;
        }
    }

    /**
     * Get human-readable name for a comment type.
     */
    private String getCommentTypeName(CommentType commentType) {
        switch (commentType) {
            case PRE:
                return "pre";
            case POST:
                return "post";
            case PLATE:
                return "plate";
            case REPEATABLE:
                return "repeatable";
            case EOL:
            default:
                return "EOL";
        }
    }

    /**
     * Find a function by name.
     */
    private Function findFunctionByName(Program program, String functionName) {
        var functionManager = program.getFunctionManager();
        var functions = functionManager.getFunctions(true);

        for (Function function : functions) {
            if (function.getName().equals(functionName)) {
                return function;
            }
        }
        return null;
    }
}

```

`src/main/java/ghidrassistmcp/tools/SetDataTypeTool.java`:

```java
/* 
 * 
 */
package ghidrassistmcp.tools;

import java.util.List;
import java.util.Map;

import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.listing.Program;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that sets the data type at a specific address.
 */
public class SetDataTypeTool implements McpTool {

    @Override
    public boolean isReadOnly() {
        return false;
    }

    @Override
    public boolean isIdempotent() {
        return true;
    }

    @Override
    public String getName() {
        return "set_data_type";
    }
    
    @Override
    public String getDescription() {
        return "Set the data type at a specific address";
    }
    
    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object", 
            Map.of(
                "address", new McpSchema.JsonSchema("string", null, null, null, null, null),
                "data_type", new McpSchema.JsonSchema("string", null, null, null, null, null)
            ),
            List.of("address", "data_type"), null, null, null);
    }
    
    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }
        
        String addressStr = (String) arguments.get("address");
        String dataTypeName = (String) arguments.get("data_type");
        
        if (addressStr == null || dataTypeName == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("address and data_type parameters are required")
                .build();
        }
        
        // Parse the address
        Address address;
        try {
            address = currentProgram.getAddressFactory().getAddress(addressStr);
        } catch (Exception e) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Invalid address format: " + addressStr)
                .build();
        }
        
        // Find the data type
        DataTypeManager dtm = currentProgram.getDataTypeManager();
        DataType dataType = dtm.getDataType("/" + dataTypeName);
        if (dataType == null) {
            // Try finding by name without path
            dataType = dtm.getDataType(dataTypeName);
        }
        
        if (dataType == null) {
             // Search for type in all categories if simple lookup failed
             var allTypes = new java.util.ArrayList<DataType>();
             dtm.getAllDataTypes(allTypes);
             for (DataType dt : allTypes) {
                 if (dt.getName().equals(dataTypeName)) {
                     dataType = dt;
                     break;
                 }
             }
        }

        if (dataType == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Data type not found: " + dataTypeName + 
                              ". Use built-in types like 'int', 'char', 'void*', etc.")
                .build();
        }
        
        // Start transaction
        int transactionID = currentProgram.startTransaction("Set Data Type");
        try {
            // If fixed length, clear the area first
            if (dataType.getLength() > 0) {
                currentProgram.getListing().clearCodeUnits(address, address.add(dataType.getLength() - 1), false);
            } else {
                // For dynamic length, clear the current code unit at address
                currentProgram.getListing().clearCodeUnits(address, address, false);
            }
            
            currentProgram.getListing().createData(address, dataType);
            
            currentProgram.endTransaction(transactionID, true);
            return McpSchema.CallToolResult.builder()
                .addTextContent("Successfully set data type at " + addressStr + " to " + dataType.getName())
                .build();
        } catch (CodeUnitInsertionException e) {
            currentProgram.endTransaction(transactionID, false);
            return McpSchema.CallToolResult.builder()
                .addTextContent("Error setting data type (overlap or conflict): " + e.getMessage())
                .build();
        } catch (Exception e) {
            currentProgram.endTransaction(transactionID, false);
            return McpSchema.CallToolResult.builder()
                .addTextContent("Error setting data type: " + e.getMessage())
                .build();
        }
    }
}

```

`src/main/java/ghidrassistmcp/tools/SetFunctionPrototypeTool.java`:

```java
/* 
 * 
 */
package ghidrassistmcp.tools;

import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;

import javax.swing.SwingUtilities;

import ghidra.app.cmd.function.ApplyFunctionSignatureCmd;
import ghidra.app.util.parser.FunctionSignatureParser;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.FunctionDefinitionDataType;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.SourceType;
import ghidra.util.Msg;
import ghidra.util.task.ConsoleTaskMonitor;
import ghidrassistmcp.GhidrAssistMCPBackend;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that sets a function's prototype/signature.
 */
public class SetFunctionPrototypeTool implements McpTool {

    @Override
    public boolean isReadOnly() {
        return false;
    }

    @Override
    public boolean isIdempotent() {
        return true;
    }

    @Override
    public String getName() {
        return "set_function_prototype";
    }
    
    @Override
    public String getDescription() {
        return "Set a function's prototype/signature";
    }
    
    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object", 
            Map.of(
                "function_address", new McpSchema.JsonSchema("string", null, null, null, null, null),
                "prototype", new McpSchema.JsonSchema("string", null, null, null, null, null)
            ),
            List.of("function_address", "prototype"), null, null, null);
    }
    
    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        // Fallback for when backend reference is not available
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        String functionAddrStr = (String) arguments.get("function_address");
        String prototype = (String) arguments.get("prototype");

        if (functionAddrStr == null || functionAddrStr.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("function_address parameter is required")
                .build();
        }

        if (prototype == null || prototype.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("prototype parameter is required")
                .build();
        }

        // Use proper prototype setting with transaction handling
        PrototypeResult result = setFunctionPrototype(currentProgram, functionAddrStr, prototype);

        return McpSchema.CallToolResult.builder()
            .addTextContent(result.success ?
                "Successfully set function prototype: " + prototype :
                "Failed to set function prototype: " + result.errorMessage)
            .build();
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram, GhidrAssistMCPBackend backend) {
        // This tool doesn't need UI context, so just delegate to the base implementation
        return execute(arguments, currentProgram);
    }
    
    /**
     * Result class for prototype operations
     */
    private static class PrototypeResult {
        final boolean success;
        final String errorMessage;
        
        PrototypeResult(boolean success, String errorMessage) {
            this.success = success;
            this.errorMessage = errorMessage;
        }
    }
    
    /**
     * Set a function's prototype with proper error handling using ApplyFunctionSignatureCmd
     */
    private PrototypeResult setFunctionPrototype(Program program, String functionAddrStr, String prototype) {
        // Input validation
        if (program == null) return new PrototypeResult(false, "No program loaded");
        if (functionAddrStr == null || functionAddrStr.isEmpty()) {
            return new PrototypeResult(false, "Function address is required");
        }
        if (prototype == null || prototype.isEmpty()) {
            return new PrototypeResult(false, "Function prototype is required");
        }

        final StringBuilder errorMessage = new StringBuilder();
        final AtomicBoolean success = new AtomicBoolean(false);

        try {
            SwingUtilities.invokeAndWait(() -> 
                applyFunctionPrototype(program, functionAddrStr, prototype, success, errorMessage));
        } catch (Exception e) {
            String msg = "Failed to set function prototype on Swing thread: " + e.getMessage();
            errorMessage.append(msg);
            Msg.error(this, msg, e);
        }

        return new PrototypeResult(success.get(), errorMessage.toString());
    }

    /**
     * Helper method that applies the function prototype within a transaction
     */
    private void applyFunctionPrototype(Program program, String functionAddrStr, String prototype, 
                                       AtomicBoolean success, StringBuilder errorMessage) {
        try {
            // Get the address and function
            Address addr = program.getAddressFactory().getAddress(functionAddrStr);
            if (addr == null) {
                String msg = "Invalid address format: " + functionAddrStr;
                errorMessage.append(msg);
                Msg.error(this, msg);
                return;
            }
            
            Function func = program.getFunctionManager().getFunctionAt(addr);
            if (func == null) {
                String msg = "Could not find function at address: " + functionAddrStr;
                errorMessage.append(msg);
                Msg.error(this, msg);
                return;
            }

            Msg.info(this, "Setting prototype for function " + func.getName() + ": " + prototype);

            // Store original prototype as a comment for reference
            addPrototypeComment(program, func, prototype);

            // Use proper function signature parsing and application
            parseFunctionSignatureAndApply(program, addr, prototype, success, errorMessage);

        } catch (Exception e) {
            String msg = "Error setting function prototype: " + e.getMessage();
            errorMessage.append(msg);
            Msg.error(this, msg, e);
        }
    }
    
    /**
     * Parse and apply the function signature with error handling
     */
    private void parseFunctionSignatureAndApply(Program program, Address addr, String prototype,
                                              AtomicBoolean success, StringBuilder errorMessage) {
        // Use ApplyFunctionSignatureCmd to parse and apply the signature
        int txProto = program.startTransaction("Set function prototype");
        try {
            // Get data type manager
            DataTypeManager dtm = program.getDataTypeManager();

            // Create function signature parser
            // Note: Since we don't have access to the tool here, we'll create parser without DataTypeManagerService
            FunctionSignatureParser parser = new FunctionSignatureParser(dtm, null);

            // Parse the prototype into a function signature
            FunctionDefinitionDataType sig = parser.parse(null, prototype);

            if (sig == null) {
                String msg = "Failed to parse function prototype: " + prototype;
                errorMessage.append(msg);
                Msg.error(this, msg);
                return;
            }

            // Create and apply the command
            ApplyFunctionSignatureCmd cmd = new ApplyFunctionSignatureCmd(
                addr, sig, SourceType.USER_DEFINED);

            // Apply the command to the program
            boolean cmdResult = cmd.applyTo(program, new ConsoleTaskMonitor());

            if (cmdResult) {
                success.set(true);
                Msg.info(this, "Successfully applied function signature");
            } else {
                String msg = "Command failed: " + cmd.getStatusMsg();
                errorMessage.append(msg);
                Msg.error(this, msg);
            }
        } catch (Exception e) {
            String msg = "Error applying function signature: " + e.getMessage();
            errorMessage.append(msg);
            Msg.error(this, msg, e);
        } finally {
            program.endTransaction(txProto, success.get());
        }
    }
    
    /**
     * Add prototype as a comment for reference
     */
    private void addPrototypeComment(Program program, Function function, String prototype) {
        int transactionId = program.startTransaction("Add prototype comment");
        boolean committed = false;
        try {
            String currentComment = function.getComment();
            String newComment = "Applied prototype: " + prototype;
            if (currentComment != null && !currentComment.isEmpty()) {
                newComment = currentComment + "\n" + newComment;
            }
            function.setComment(newComment);
            committed = true;
        } catch (Exception e) {
            Msg.warn(this, "Could not add prototype comment: " + e.getMessage());
        } finally {
            program.endTransaction(transactionId, committed);
        }
    }
    
}
```

`src/main/java/ghidrassistmcp/tools/SetLocalVariableTypeTool.java`:

```java
/* 
 * 
 */
package ghidrassistmcp.tools;

import java.util.Iterator;
import java.util.List;
import java.util.Map;

import ghidra.app.decompiler.DecompInterface;
import ghidra.app.decompiler.DecompileResults;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.program.model.pcode.HighFunction;
import ghidra.program.model.pcode.HighSymbol;
import ghidra.program.model.pcode.HighVariable;
import ghidra.util.task.TaskMonitor;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that sets the data type of a local variable within a function.
 */
public class SetLocalVariableTypeTool implements McpTool {

    @Override
    public boolean isReadOnly() {
        return false;
    }

    @Override
    public boolean isIdempotent() {
        return true;
    }

    @Override
    public String getName() {
        return "set_local_variable_type";
    }
    
    @Override
    public String getDescription() {
        return "Set the data type of a local variable within a function";
    }
    
    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object", 
            Map.of(
                "function_name", new McpSchema.JsonSchema("string", null, null, null, null, null),
                "variable_name", new McpSchema.JsonSchema("string", null, null, null, null, null),
                "data_type", new McpSchema.JsonSchema("string", null, null, null, null, null)
            ),
            List.of("function_name", "variable_name", "data_type"), null, null, null);
    }
    
    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }
        
        String functionName = (String) arguments.get("function_name");
        String variableName = (String) arguments.get("variable_name");
        String dataTypeName = (String) arguments.get("data_type");
        
        if (functionName == null || variableName == null || dataTypeName == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("function_name, variable_name, and data_type are all required")
                .build();
        }
        
        // Find the function
        Function function = findFunctionByName(currentProgram, functionName);
        if (function == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Function not found: " + functionName)
                .build();
        }
        
        // Find the data type
        DataTypeManager dtm = currentProgram.getDataTypeManager();
        DataType dataType = dtm.getDataType("/" + dataTypeName);
        if (dataType == null) {
            // Try finding by name without path
            dataType = dtm.getDataType(dataTypeName);
        }
        if (dataType == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Data type not found: " + dataTypeName + 
                              ". Use built-in types like 'int', 'char', 'void*', etc.")
                .build();
        }
        
        // Get the high function and find the variable
        DecompInterface decompiler = new DecompInterface();
        try {
            decompiler.openProgram(currentProgram);
            
            DecompileResults results = decompiler.decompileFunction(function, 30, TaskMonitor.DUMMY);
            
            if (results.isTimedOut()) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Decompilation timed out for function: " + functionName)
                    .build();
            }
            
            if (results.isValid() == false) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Decompilation error for function " + functionName + ": " + results.getErrorMessage())
                    .build();
            }
            
            HighFunction highFunction = results.getHighFunction();
            if (highFunction == null) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Could not get high function for: " + functionName)
                    .build();
            }
            
            // Find the variable
            HighSymbol targetSymbol = null;
            Iterator<HighSymbol> symbols = highFunction.getLocalSymbolMap().getSymbols();
            
            while (symbols.hasNext()) {
                HighSymbol symbol = symbols.next();
                if (symbol.getName().equals(variableName)) {
                    targetSymbol = symbol;
                    break;
                }
            }
            
            if (targetSymbol == null) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Variable '" + variableName + "' not found in function '" + functionName + "'")
                    .build();
            }
            
            // Setting variable types in the decompiler is complex and may not persist
            // For now, return information about the variable and desired type
            try {
                HighVariable highVar = targetSymbol.getHighVariable();
                if (highVar != null) {
                    DataType currentType = highVar.getDataType();
                    String currentTypeName = currentType != null ? currentType.getName() : "unknown";
                    
                    return McpSchema.CallToolResult.builder()
                        .addTextContent("Variable '" + variableName + "' in function '" + functionName + 
                                      "' currently has type: " + currentTypeName + 
                                      ". Requested type: " + dataType.getName() + 
                                      " (Type setting not fully implemented - changes may not persist)")
                        .build();
                }
				return McpSchema.CallToolResult.builder()
				    .addTextContent("Cannot access type for variable '" + variableName + 
				                  "' - no high variable available")
				    .build();
            } catch (Exception e) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Error accessing variable type: " + e.getMessage())
                    .build();
            }
            
        } catch (Exception e) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Error processing function: " + e.getMessage())
                .build();
        } finally {
            decompiler.dispose();
        }
    }
    
    private Function findFunctionByName(Program program, String functionName) {
        var functionManager = program.getFunctionManager();
        var functions = functionManager.getFunctions(true);
        
        for (Function function : functions) {
            if (function.getName().equals(functionName)) {
                return function;
            }
        }
        return null;
    }
}
```

`src/main/java/ghidrassistmcp/tools/StructTool.java`:

```java
/*
 * MCP tool for structure operations.
 * Consolidates create_struct, modify_struct, auto_create_struct, rename_structure_field, and struct_field_xrefs.
 */
package ghidrassistmcp.tools;

import java.io.ByteArrayInputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;

import javax.swing.SwingUtilities;

import ghidra.app.decompiler.ClangFieldToken;
import ghidra.app.decompiler.ClangNode;
import ghidra.app.decompiler.ClangTokenGroup;
import ghidra.app.decompiler.DecompInterface;
import ghidra.app.decompiler.DecompileOptions;
import ghidra.app.decompiler.DecompileResults;
import ghidra.app.util.cparser.C.CParser;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.ArrayDataType;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeComponent;
import ghidra.program.model.data.DataTypeConflictHandler;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.PointerDataType;
import ghidra.program.model.data.Structure;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.data.TypeDef;
import ghidra.program.model.data.UnsignedCharDataType;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Function.FunctionUpdateType;
import ghidra.program.model.listing.FunctionIterator;
import ghidra.program.model.listing.Parameter;
import ghidra.program.model.listing.ParameterImpl;
import ghidra.program.model.listing.Program;
import ghidra.program.model.listing.Variable;
import ghidra.program.model.pcode.HighFunction;
import ghidra.program.model.pcode.HighFunctionDBUtil;
import ghidra.program.model.pcode.HighSymbol;
import ghidra.program.model.pcode.HighVariable;
import ghidra.program.model.symbol.RefType;
import ghidra.program.model.symbol.Reference;
import ghidra.program.model.symbol.ReferenceIterator;
import ghidra.program.model.symbol.SourceType;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.exception.InvalidInputException;
import ghidra.util.task.TaskMonitor;
import ghidrassistmcp.GhidrAssistMCPBackend;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool for structure operations.
 * Consolidates create_struct, modify_struct, auto_create_struct, rename_structure_field, and struct_field_xrefs.
 */
public class StructTool implements McpTool {

    private static class ComponentSnapshot {
        final int offset;
        final DataType dataType;
        final int length;
        final String fieldName;
        final String comment;

        ComponentSnapshot(int offset, DataType dataType, int length, String fieldName, String comment) {
            this.offset = offset;
            this.dataType = dataType;
            this.length = length;
            this.fieldName = fieldName;
            this.comment = comment;
        }
    }

    private static class StructureSnapshot {
        final boolean packed;
        final List<ComponentSnapshot> components;

        StructureSnapshot(boolean packed, List<ComponentSnapshot> components) {
            this.packed = packed;
            this.components = components;
        }
    }

    /**
     * Inner class to hold field reference results for field_xrefs action.
     */
    private static class FieldReference {
        Address address;
        String functionName;
        Address functionAddress;
        String accessType;  // "READ", "WRITE", "UNKNOWN"
        String context;
        String source;      // "DECOMPILER" or "ADDRESS"

        FieldReference(Address address, String functionName, Address functionAddress,
                      String accessType, String context, String source) {
            this.address = address;
            this.functionName = functionName;
            this.functionAddress = functionAddress;
            this.accessType = accessType;
            this.context = context;
            this.source = source;
        }

        @Override
        public String toString() {
            return String.format("[%s] %s: %s", accessType, address, context);
        }
    }

    @Override
    public boolean isReadOnly() {
        return false;
    }

    @Override
    public boolean isLongRunning() {
        // auto_create and field_xrefs actions require decompilation
        return true;
    }

    @Override
    public String getName() {
        return "struct";
    }

    @Override
    public String getDescription() {
        return "Structure operations: create, modify, merge, set_field, name_gap, auto_create, rename_field, or field_xrefs";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        // Note: This is a single tool with action-specific parameters.
        // We express this as a single object schema with rich per-field descriptions.
        return new McpSchema.JsonSchema("object",
            Map.ofEntries(
                Map.entry("action", Map.of(
                    "type", "string",
                    "description", "Structure operation to perform",
                    "enum", List.of("create", "modify", "merge", "set_field", "name_gap", "auto_create", "rename_field", "field_xrefs")
                )),

                // create
                Map.entry("name", Map.of(
                    "type", "string",
                    "description", "For action='create': structure name (required if c_definition is not provided)"
                )),
                Map.entry("size", Map.of(
                    "type", "integer",
                    "description", "For action='create' with name: initial struct size in bytes (default 0)",
                    "default", 0,
                    "minimum", 0
                )),
                Map.entry("packed", Map.of(
                    "type", "boolean",
                    "description", "For action='create' with name: if true, enable packing (no implicit alignment/padding). Default false.",
                    "default", false
                )),
                Map.entry("category", Map.of(
                    "type", "string",
                    "description", "For action='create': optional category path (e.g. \"/mytypes\" or \"/auto_structs\")"
                )),
                Map.entry("c_definition", Map.of(
                    "type", "string",
                    "description", "For action='create' or 'modify': C-like struct definition. Prefer exactly one struct definition.\n" +
                        "Examples:\n" +
                        "  \"struct Foo { int a; char b; };\"\n" +
                        "  \"typedef struct Bar { uint x; } Bar;\"\n" +
                        "Notes:\n" +
                        "- For modify, if multiple structs are defined, the tool will try to pick the one matching structure_name; otherwise it errors."
                )),

                // modify
                Map.entry("structure_name", Map.of(
                    "type", "string",
                    "description", "For action='modify'/'rename_field'/'field_xrefs': target structure name (searched in '/', '/auto_structs/', and by bare name)"
                )),
                Map.entry("new_name", Map.of(
                    "type", "string",
                    "description", "For action='modify': optional new name to rename the structure to"
                )),
                Map.entry("allow_empty", Map.of(
                    "type", "boolean",
                    "description", "For action='modify': if true, allow replacing a non-empty struct with an empty parsed definition. Default false (safety).",
                    "default", false
                )),
                Map.entry("update_packing", Map.of(
                    "type", "boolean",
                    "description", "For action='merge': if true, update the target structure's packing setting to match the parsed C definition. Default false.",
                    "default", false
                )),

                // auto_create
                Map.entry("function_identifier", Map.of(
                    "type", "string",
                    "description", "For action='auto_create': function name or address identifying which function to decompile"
                )),
                Map.entry("variable_name", Map.of(
                    "type", "string",
                    "description", "For action='auto_create': variable name in the decompiler output to infer/apply a structure to"
                )),

                // rename_field
                Map.entry("old_field_name", Map.of(
                    "type", "string",
                    "description", "For action='rename_field': existing field name to rename (provide either old_field_name or offset)"
                )),
                Map.entry("new_field_name", Map.of(
                    "type", "string",
                    "description", "For action='rename_field': new field name"
                )),
                Map.entry("offset", Map.of(
                    "type", "integer",
                    "description", "For action='rename_field': field offset (in bytes) if renaming by offset. For action='field_xrefs': pagination offset (number of results to skip).",
                    "minimum", 0
                )),

                // set_field / name_gap
                Map.entry("data_type", Map.of(
                    "type", "string",
                    "description", "For action='set_field': base data type name (e.g. \"uint\", \"int\", \"MyStruct\"). Must exist in the program DataTypeManager."
                )),
                Map.entry("comment", Map.of(
                    "type", "string",
                    "description", "For action='set_field'/'name_gap': optional field comment"
                )),
                Map.entry("pointer_level", Map.of(
                    "type", "integer",
                    "description", "For action='set_field': number of pointer indirections to apply to data_type (e.g. 1 for T*, 2 for T**). Default 0.",
                    "default", 0,
                    "minimum", 0
                )),
                Map.entry("array_count", Map.of(
                    "type", "integer",
                    "description", "For action='set_field': if provided, wraps the (possibly pointer-adjusted) type in an array of this many elements.",
                    "minimum", 1
                )),
                Map.entry("field_length", Map.of(
                    "type", "integer",
                    "description", "For action='set_field'/'name_gap': explicit length in bytes. Required when the resolved data type has variable/unknown length. For name_gap, this is the gap size.",
                    "minimum", 1
                )),
                Map.entry("op", Map.of(
                    "type", "string",
                    "description", "For action='set_field': how to apply the field at offset.",
                    "enum", List.of("replace", "insert"),
                    "default", "replace"
                )),
                Map.entry("grow", Map.of(
                    "type", "boolean",
                    "description", "For action='set_field'/'name_gap': if true, grows structure size as needed when offset+length exceeds current size. Default true.",
                    "default", true
                )),
                Map.entry("allow_overwrite", Map.of(
                    "type", "boolean",
                    "description", "For action='name_gap': if false (default), refuses to overwrite any non-undefined bytes in the target range.",
                    "default", false
                )),

                // field_xrefs + set_field/name_gap naming
                Map.entry("field_name", Map.of(
                    "type", "string",
                    "description", "For action='set_field'/'name_gap': field name to apply at the target offset. For action='field_xrefs': field name to find references for (provide either field_name or field_offset)."
                )),
                Map.entry("field_offset", Map.of(
                    "type", "integer",
                    "description", "For action='field_xrefs': field offset (in bytes) to find references for (provide either field_name or field_offset)",
                    "minimum", 0
                )),
                Map.entry("instance_address", Map.of(
                    "type", "string",
                    "description", "For action='field_xrefs': optional base address of a struct instance to find instance-based references (in addition to type-based)"
                )),
                Map.entry("limit", Map.of(
                    "type", "integer",
                    "description", "For action='field_xrefs': maximum number of references to return (default 100)",
                    "default", 100,
                    "minimum", 1
                ))
            ),
            List.of("action"), null, null, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        return execute(arguments, currentProgram, null);
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram, GhidrAssistMCPBackend backend) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        String action = (String) arguments.get("action");
        if (action == null || action.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("action parameter is required ('create', 'modify', 'auto_create', 'rename_field', or 'field_xrefs')")
                .build();
        }

        action = action.toLowerCase();

        switch (action) {
            case "create":
                return executeCreate(arguments, currentProgram);
            case "modify":
                return executeModify(arguments, currentProgram);
            case "merge":
                return executeMerge(arguments, currentProgram);
            case "set_field":
                return executeSetField(arguments, currentProgram);
            case "name_gap":
                return executeNameGap(arguments, currentProgram);
            case "auto_create":
                return executeAutoCreate(arguments, currentProgram);
            case "rename_field":
                return executeRenameField(arguments, currentProgram);
            case "field_xrefs":
                return executeFieldXrefs(arguments, currentProgram);
            default:
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Invalid action. Use 'create', 'modify', 'merge', 'set_field', 'name_gap', 'auto_create', 'rename_field', or 'field_xrefs'")
                    .build();
        }
    }

    // ========== CREATE ACTION ==========

    private McpSchema.CallToolResult executeCreate(Map<String, Object> arguments, Program currentProgram) {
        String name = (String) arguments.get("name");
        String cDefinition = (String) arguments.get("c_definition");
        String category = (String) arguments.get("category");
        Number sizeNum = (Number) arguments.get("size");
        Boolean packed = (Boolean) arguments.get("packed");

        // Validate input - need either name or c_definition
        if ((name == null || name.isEmpty()) && (cDefinition == null || cDefinition.isEmpty())) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Either 'name' (for empty struct) or 'c_definition' must be provided for create action")
                .build();
        }

        int txId = currentProgram.startTransaction("Create Structure");
        boolean committed = false;
        try {
            DataTypeManager dtm = currentProgram.getDataTypeManager();
            Structure result;

            if (cDefinition != null && !cDefinition.isEmpty()) {
                result = createStructFromCDefinition(dtm, cDefinition, category);
            } else {
                int size = sizeNum != null ? sizeNum.intValue() : 0;
                result = createEmptyStruct(dtm, name, size, category, packed != null && packed);
            }

            if (result == null) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Failed to create structure")
                    .build();
            }

            committed = true;
            return McpSchema.CallToolResult.builder()
                .addTextContent("Successfully created structure '" + result.getName() +
                    "' with " + result.getNumComponents() + " components, size " +
                    result.getLength() + " bytes at category " + result.getCategoryPath())
                .build();

        } catch (Exception e) {
            String msg = "Error creating structure: " + e.getMessage();
            Msg.error(this, msg, e);
            return McpSchema.CallToolResult.builder()
                .addTextContent(msg)
                .build();
        } finally {
            currentProgram.endTransaction(txId, committed);
        }
    }

    private Structure createEmptyStruct(DataTypeManager dtm, String name, int size,
                                        String category, boolean packed) {
        CategoryPath categoryPath = category != null && !category.isEmpty()
            ? new CategoryPath(category)
            : CategoryPath.ROOT;

        StructureDataType struct = new StructureDataType(categoryPath, name, size, dtm);

        if (packed) {
            struct.setPackingEnabled(true);
        }

        DataType addedType = dtm.addDataType(struct, DataTypeConflictHandler.REPLACE_HANDLER);

        if (addedType instanceof Structure) {
            Msg.info(this, "Created empty structure: " + name);
            return (Structure) addedType;
        }

        return null;
    }

    private Structure createStructFromCDefinition(DataTypeManager dtm, String cDefinition,
                                                   String category) throws Exception {
        String normalizedDef = cDefinition.trim();
        if (!normalizedDef.endsWith(";")) {
            normalizedDef += ";";
        }

        CParser parser = new CParser(dtm);

        try {
            ByteArrayInputStream inputStream = new ByteArrayInputStream(
                normalizedDef.getBytes(StandardCharsets.UTF_8));
            parser.parse(inputStream);

            Map<String, DataType> composites = parser.getComposites();

            if (composites.isEmpty()) {
                throw new Exception("No structure definition found in the provided C code. " +
                    "Make sure to use format: 'struct Name { type field; ... };'");
            }

            Structure parsedStruct = selectParsedStructure(composites, null);

            if (category != null && !category.isEmpty()) {
                CategoryPath categoryPath = new CategoryPath(category);
                parsedStruct.setCategoryPath(categoryPath);
            }

            DataType addedType = dtm.addDataType(parsedStruct, DataTypeConflictHandler.REPLACE_HANDLER);

            if (addedType instanceof Structure) {
                Msg.info(this, "Created structure from C definition: " + addedType.getName());
                return (Structure) addedType;
            }

            return null;

        } catch (ghidra.app.util.cparser.C.ParseException pe) {
            throw new Exception("C parse error: " + pe.getMessage() +
                ". Check your struct definition syntax.");
        }
    }

    // ========== MODIFY ACTION ==========

    private McpSchema.CallToolResult executeModify(Map<String, Object> arguments, Program currentProgram) {
        String structureName = (String) arguments.get("structure_name");
        String cDefinition = (String) arguments.get("c_definition");
        String newName = (String) arguments.get("new_name");
        Boolean allowEmpty = (Boolean) arguments.get("allow_empty");

        if (structureName == null || structureName.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("structure_name parameter is required for modify action")
                .build();
        }

        if (cDefinition == null || cDefinition.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("c_definition parameter is required for modify action")
                .build();
        }

        int txId = currentProgram.startTransaction("Modify Structure");
        boolean committed = false;
        try {
            DataTypeManager dtm = currentProgram.getDataTypeManager();

            Structure existingStruct = findStructure(dtm, structureName);
            if (existingStruct == null) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Structure '" + structureName + "' not found. " +
                        "Use action='create' to create a new structure.")
                    .build();
            }

            var categoryPath = existingStruct.getCategoryPath();

            Structure newStruct = parseStructFromCDefinition(dtm, cDefinition, structureName);
            if (newStruct == null) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Failed to parse C structure definition")
                    .build();
            }

            boolean allowEmptyStruct = allowEmpty != null && allowEmpty;
            Structure result = applyNewDefinition(dtm, existingStruct, newStruct, newName, categoryPath, allowEmptyStruct);

            if (result == null) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Failed to apply new structure definition")
                    .build();
            }

            committed = true;
            return McpSchema.CallToolResult.builder()
                .addTextContent("Successfully modified structure '" + result.getName() +
                    "': now has " + result.getNumComponents() + " components, size " +
                    result.getLength() + " bytes")
                .build();

        } catch (Exception e) {
            String msg = "Error modifying structure: " + e.getMessage();
            Msg.error(this, msg, e);
            return McpSchema.CallToolResult.builder()
                .addTextContent(msg)
                .build();
        } finally {
            currentProgram.endTransaction(txId, committed);
        }
    }

    // ========== MERGE ACTION ==========

    /**
     * Merge (overlay) a parsed C structure definition onto an existing structure without deleting
     * existing fields first. This is useful for incrementally adding a few fields without rewriting
     * the full definition.
     *
     * Notes:
     * - Only reliable for non-packed structures. For packed structures, use modify or set_field.
     */
    private McpSchema.CallToolResult executeMerge(Map<String, Object> arguments, Program currentProgram) {
        String structureName = (String) arguments.get("structure_name");
        String cDefinition = (String) arguments.get("c_definition");
        Boolean updatePacking = (Boolean) arguments.get("update_packing");

        if (structureName == null || structureName.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("structure_name parameter is required for merge action")
                .build();
        }
        if (cDefinition == null || cDefinition.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("c_definition parameter is required for merge action")
                .build();
        }

        int txId = currentProgram.startTransaction("Merge Structure Fields");
        boolean committed = false;
        try {
            DataTypeManager dtm = currentProgram.getDataTypeManager();
            Structure existingStruct = findStructure(dtm, structureName);
            if (existingStruct == null) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Structure '" + structureName + "' not found. Use action='create' first.")
                    .build();
            }

            if (existingStruct.isPackingEnabled()) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Cannot safely merge into a packed structure ('" + existingStruct.getName() +
                        "'). Use action='modify' or action='set_field' instead.")
                    .build();
            }

            Structure parsedStruct = parseStructFromCDefinition(dtm, cDefinition, structureName);
            if (parsedStruct == null) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Failed to parse C structure definition")
                    .build();
            }

            StructureSnapshot snapshot = snapshotStructure(parsedStruct);
            boolean shouldUpdatePacking = updatePacking != null && updatePacking;
            if (shouldUpdatePacking) {
                existingStruct.setPackingEnabled(snapshot.packed);
            }

            for (ComponentSnapshot comp : snapshot.components) {
                int offset = comp.offset;
                DataType compType = comp.dataType;
                int compLength = comp.length;
                String fieldName = comp.fieldName;
                String comment = comp.comment;

                if (!existingStruct.isPackingEnabled() && existingStruct.getLength() < offset) {
                    existingStruct.growStructure(offset - existingStruct.getLength());
                }
                try {
                    existingStruct.replaceAtOffset(offset, compType, compLength, fieldName, comment);
                } catch (Exception e) {
                    existingStruct.insertAtOffset(offset, compType, compLength, fieldName, comment);
                }
            }

            committed = true;
            return McpSchema.CallToolResult.builder()
                .addTextContent("Successfully merged fields into structure '" + existingStruct.getName() +
                    "': now has " + existingStruct.getNumComponents() + " components, size " +
                    existingStruct.getLength() + " bytes")
                .build();

        } catch (Exception e) {
            String msg = "Error merging structure fields: " + e.getMessage();
            Msg.error(this, msg, e);
            return McpSchema.CallToolResult.builder()
                .addTextContent(msg)
                .build();
        } finally {
            currentProgram.endTransaction(txId, committed);
        }
    }

    // ========== SET_FIELD ACTION ==========

    private McpSchema.CallToolResult executeSetField(Map<String, Object> arguments, Program currentProgram) {
        String structureName = (String) arguments.get("structure_name");
        Number fieldOffsetNum = (Number) arguments.get("field_offset");
        String dataTypeName = (String) arguments.get("data_type");
        String fieldName = (String) arguments.get("field_name");
        String comment = (String) arguments.get("comment");
        Number pointerLevelNum = (Number) arguments.get("pointer_level");
        Number arrayCountNum = (Number) arguments.get("array_count");
        Number fieldLengthNum = (Number) arguments.get("field_length");
        String op = (String) arguments.get("op");
        Boolean grow = (Boolean) arguments.get("grow");

        if (structureName == null || structureName.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("structure_name parameter is required for set_field action")
                .build();
        }
        if (fieldOffsetNum == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("field_offset parameter is required for set_field action")
                .build();
        }
        if (dataTypeName == null || dataTypeName.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("data_type parameter is required for set_field action")
                .build();
        }

        int fieldOffset = fieldOffsetNum.intValue();
        int pointerLevel = pointerLevelNum != null ? pointerLevelNum.intValue() : 0;
        Integer arrayCount = arrayCountNum != null ? arrayCountNum.intValue() : null;
        Integer explicitLength = fieldLengthNum != null ? fieldLengthNum.intValue() : null;
        String operation = op != null && !op.isBlank() ? op.toLowerCase() : "replace";
        boolean shouldGrow = grow == null || grow;

        if (!operation.equals("replace") && !operation.equals("insert")) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Invalid op for set_field: '" + op + "'. Use 'replace' or 'insert'.")
                .build();
        }
        if (fieldOffset < 0) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("field_offset must be >= 0")
                .build();
        }
        if (pointerLevel < 0) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("pointer_level must be >= 0")
                .build();
        }
        if (arrayCount != null && arrayCount < 1) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("array_count must be >= 1")
                .build();
        }
        if (explicitLength != null && explicitLength < 1) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("field_length must be >= 1")
                .build();
        }

        int txId = currentProgram.startTransaction("Set Structure Field");
        boolean committed = false;
        try {
            DataTypeManager dtm = currentProgram.getDataTypeManager();
            Structure struct = findStructure(dtm, structureName);
            if (struct == null) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Structure '" + structureName + "' not found")
                    .build();
            }

            DataType baseType = resolveDataType(dtm, dataTypeName);
            if (baseType == null) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Data type not found: " + dataTypeName)
                    .build();
            }

            DataType resolvedType = baseType;
            for (int i = 0; i < pointerLevel; i++) {
                resolvedType = dtm.getPointer(resolvedType);
            }
            if (arrayCount != null) {
                int elemLen = resolvedType.getLength();
                if (elemLen <= 0) {
                    return McpSchema.CallToolResult.builder()
                        .addTextContent("Cannot build array of variable-length type '" + resolvedType.getName() +
                            "'. Provide a fixed-length base type (or avoid array_count).")
                        .build();
                }
                resolvedType = new ArrayDataType(resolvedType, arrayCount, elemLen);
            }

            int length = explicitLength != null ? explicitLength : resolvedType.getLength();
            if (length <= 0) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Resolved data type '" + resolvedType.getName() + "' has variable/unknown length. " +
                        "Provide field_length explicitly.")
                    .build();
            }

            if (shouldGrow && struct.getLength() < fieldOffset + length) {
                int needed = (fieldOffset + length) - struct.getLength();
                if (needed > 0) {
                    struct.growStructure(needed);
                }
            }

            try {
                if (operation.equals("insert")) {
                    struct.insertAtOffset(fieldOffset, resolvedType, length, fieldName, comment);
                } else {
                    struct.replaceAtOffset(fieldOffset, resolvedType, length, fieldName, comment);
                }
            } catch (Exception e) {
                // Fallback: replace might fail if there's no component at offset, and insert might fail due to overlap.
                // Try the other operation before failing.
                try {
                    if (operation.equals("insert")) {
                        struct.replaceAtOffset(fieldOffset, resolvedType, length, fieldName, comment);
                    } else {
                        struct.insertAtOffset(fieldOffset, resolvedType, length, fieldName, comment);
                    }
                } catch (Exception e2) {
                    return McpSchema.CallToolResult.builder()
                        .addTextContent("Failed to apply field at offset 0x" + Integer.toHexString(fieldOffset) +
                            " in structure '" + struct.getName() + "': " + e2.getMessage())
                        .build();
                }
            }

            committed = true;
            return McpSchema.CallToolResult.builder()
                .addTextContent("Successfully set field at +0x" + Integer.toHexString(fieldOffset) +
                    " in structure '" + struct.getName() + "' to type '" + resolvedType.getName() + "'" +
                    (fieldName != null && !fieldName.isBlank() ? " name '" + fieldName + "'" : "") +
                    " (" + length + " bytes)")
                .build();

        } catch (Exception e) {
            String msg = "Error setting structure field: " + e.getMessage();
            Msg.error(this, msg, e);
            return McpSchema.CallToolResult.builder()
                .addTextContent(msg)
                .build();
        } finally {
            currentProgram.endTransaction(txId, committed);
        }
    }

    // ========== NAME_GAP ACTION ==========

    private McpSchema.CallToolResult executeNameGap(Map<String, Object> arguments, Program currentProgram) {
        String structureName = (String) arguments.get("structure_name");
        Number fieldOffsetNum = (Number) arguments.get("field_offset");
        Number fieldLengthNum = (Number) arguments.get("field_length");
        String fieldName = (String) arguments.get("field_name");
        String comment = (String) arguments.get("comment");
        Boolean allowOverwrite = (Boolean) arguments.get("allow_overwrite");
        Boolean grow = (Boolean) arguments.get("grow");

        if (structureName == null || structureName.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("structure_name parameter is required for name_gap action")
                .build();
        }
        if (fieldOffsetNum == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("field_offset parameter is required for name_gap action")
                .build();
        }
        if (fieldLengthNum == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("field_length parameter is required for name_gap action")
                .build();
        }
        if (fieldName == null || fieldName.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("field_name parameter is required for name_gap action")
                .build();
        }

        int fieldOffset = fieldOffsetNum.intValue();
        int fieldLength = fieldLengthNum.intValue();
        if (fieldOffset < 0 || fieldLength < 1) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("field_offset must be >= 0 and field_length must be >= 1")
                .build();
        }

        boolean shouldGrow = grow == null || grow;
        boolean canOverwrite = allowOverwrite != null && allowOverwrite;

        int txId = currentProgram.startTransaction("Name Structure Gap");
        boolean committed = false;
        try {
            DataTypeManager dtm = currentProgram.getDataTypeManager();
            Structure struct = findStructure(dtm, structureName);
            if (struct == null) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Structure '" + structureName + "' not found")
                    .build();
            }

            if (shouldGrow && struct.getLength() < fieldOffset + fieldLength) {
                int needed = (fieldOffset + fieldLength) - struct.getLength();
                if (needed > 0) {
                    struct.growStructure(needed);
                }
            }

            int start = fieldOffset;
            int endExclusive = fieldOffset + fieldLength;

            if (!canOverwrite) {
                for (DataTypeComponent comp : struct.getComponents()) {
                    int compStart = comp.getOffset();
                    int compEndExclusive = comp.getEndOffset() + 1;
                    boolean overlaps = compStart < endExclusive && compEndExclusive > start;
                    if (overlaps && !comp.isUndefined()) {
                        return McpSchema.CallToolResult.builder()
                            .addTextContent("Refusing to overwrite non-undefined component at +0x" +
                                Integer.toHexString(comp.getOffset()) + " (" + comp.getDataType().getName() + "). " +
                                "Pass allow_overwrite=true to force.")
                            .build();
                    }
                }
            }

            DataType gapElem = UnsignedCharDataType.dataType;
            DataType gapArray = new ArrayDataType(gapElem, fieldLength, gapElem.getLength());
            struct.replaceAtOffset(fieldOffset, gapArray, gapArray.getLength(), fieldName, comment);

            committed = true;
            return McpSchema.CallToolResult.builder()
                .addTextContent("Successfully named gap in structure '" + struct.getName() + "' at +0x" +
                    Integer.toHexString(fieldOffset) + " (" + fieldLength + " bytes) as '" + fieldName + "'")
                .build();

        } catch (Exception e) {
            String msg = "Error naming structure gap: " + e.getMessage();
            Msg.error(this, msg, e);
            return McpSchema.CallToolResult.builder()
                .addTextContent(msg)
                .build();
        } finally {
            currentProgram.endTransaction(txId, committed);
        }
    }

    private DataType resolveDataType(DataTypeManager dtm, String typeName) {
        if (typeName == null) {
            return null;
        }
        String t = typeName.trim();
        if (t.isEmpty()) {
            return null;
        }

        // Direct path lookup (if caller provides a full path)
        if (t.startsWith("/")) {
            DataType byPath = dtm.getDataType(t);
            if (byPath != null) {
                return byPath;
            }
        }

        // Common lookups
        DataType dt = dtm.getDataType("/" + t);
        if (dt == null) {
            dt = dtm.getDataType(t);
        }

        if (dt != null) {
            return dt;
        }

        // Search all types by name
        List<DataType> allTypes = new ArrayList<>();
        dtm.getAllDataTypes(allTypes);
        for (DataType candidate : allTypes) {
            if (candidate.getName().equals(t)) {
                return candidate;
            }
        }
        return null;
    }

    private Structure findStructure(DataTypeManager dtm, String structureName) {
        String[] searchPaths = {
            "/" + structureName,
            "/auto_structs/" + structureName,
            structureName
        };

        for (String path : searchPaths) {
            DataType dt = dtm.getDataType(path);
            if (dt instanceof Structure) {
                return (Structure) dt;
            }
        }

        List<DataType> allTypes = new ArrayList<>();
        dtm.getAllDataTypes(allTypes);
        for (DataType dt : allTypes) {
            if (dt instanceof Structure && dt.getName().equals(structureName)) {
                return (Structure) dt;
            }
        }

        return null;
    }

    private Structure parseStructFromCDefinition(DataTypeManager dtm, String cDefinition, String expectedStructName) throws Exception {
        String normalizedDef = cDefinition.trim();
        if (!normalizedDef.endsWith(";")) {
            normalizedDef += ";";
        }

        CParser parser = new CParser(dtm);

        try {
            ByteArrayInputStream inputStream = new ByteArrayInputStream(
                normalizedDef.getBytes(StandardCharsets.UTF_8));
            parser.parse(inputStream);

            Map<String, DataType> composites = parser.getComposites();

            if (composites.isEmpty()) {
                throw new Exception("No structure definition found in the provided C code. " +
                    "Make sure to use format: 'struct Name { type field; ... };'");
            }

            return selectParsedStructure(composites, expectedStructName);

        } catch (ghidra.app.util.cparser.C.ParseException pe) {
            throw new Exception("C parse error: " + pe.getMessage() +
                ". Check your struct definition syntax.");
        }
    }

    private Structure applyNewDefinition(DataTypeManager dtm, Structure existingStruct,
                                         Structure newStruct, String newName,
                                         ghidra.program.model.data.CategoryPath categoryPath,
                                         boolean allowEmptyStruct) throws Exception {
        // IMPORTANT: The C parser may return a Structure object that is the same DataType instance
        // as the struct we're modifying (or otherwise shares backing storage via the DTM).
        // If we delete components before snapshotting, we can accidentally wipe the parsed definition.
        StructureSnapshot snapshot = snapshotStructure(newStruct);

        int existingDefinedCount = existingStruct.getDefinedComponents().length;
        if (!allowEmptyStruct && snapshot.components.isEmpty() && existingDefinedCount > 0) {
            throw new Exception("Parsed structure definition contained no fields; refusing to replace a non-empty " +
                "structure with an empty one. If you really want an empty struct, pass allow_empty=true.");
        }

        existingStruct.deleteAll();

        boolean isPacked = snapshot.packed;
        existingStruct.setPackingEnabled(isPacked);

        for (ComponentSnapshot comp : snapshot.components) {
            DataType compType = comp.dataType;
            int compLength = comp.length;
            String fieldName = comp.fieldName;
            String comment = comp.comment;
            int offset = comp.offset;

            if (!isPacked && existingStruct.getLength() < offset) {
                existingStruct.growStructure(offset - existingStruct.getLength());
            }

            if (isPacked) {
                if (fieldName != null) {
                    existingStruct.add(compType, compLength, fieldName, comment);
                } else {
                    existingStruct.add(compType, compLength, null, comment);
                }
            } else {
                try {
                    existingStruct.replaceAtOffset(offset, compType, compLength, fieldName, comment);
                } catch (Exception e) {
                    existingStruct.insertAtOffset(offset, compType, compLength, fieldName, comment);
                }
            }
        }

        // Preserve original category path (C parser may have placed the parsed struct elsewhere)
        try {
            if (categoryPath != null) {
                existingStruct.setCategoryPath(categoryPath);
            }
        } catch (Exception e) {
            Msg.warn(this, "Could not preserve category path for '" + existingStruct.getName() + "': " + e.getMessage());
        }

        if (newName != null && !newName.isEmpty() && !newName.equals(existingStruct.getName())) {
            try {
                existingStruct.setName(newName);
            } catch (Exception e) {
                Msg.warn(this, "Could not rename structure to '" + newName + "': " + e.getMessage());
            }
        }

        Msg.info(this, "Modified structure: " + existingStruct.getName() +
            " with " + existingStruct.getNumComponents() + " components");

        return existingStruct;
    }

    private StructureSnapshot snapshotStructure(Structure struct) {
        boolean packed = struct.isPackingEnabled();
        DataTypeComponent[] defined = struct.getDefinedComponents();

        List<ComponentSnapshot> snapshots = new ArrayList<>(defined.length);
        for (DataTypeComponent comp : defined) {
            snapshots.add(new ComponentSnapshot(
                comp.getOffset(),
                comp.getDataType(),
                comp.getLength(),
                comp.getFieldName(),
                comp.getComment()
            ));
        }
        return new StructureSnapshot(packed, snapshots);
    }

    private Structure selectParsedStructure(Map<String, DataType> composites, String expectedStructName) throws Exception {
        List<Structure> parsedStructs = new ArrayList<>();
        for (DataType dt : composites.values()) {
            if (dt instanceof Structure) {
                parsedStructs.add((Structure) dt);
            }
        }

        if (parsedStructs.isEmpty()) {
            // Provide better diagnostics than "not a structure" on an arbitrary iterator().next()
            List<String> names = new ArrayList<>();
            for (DataType dt : composites.values()) {
                names.add(dt.getName());
            }
            throw new Exception("Parsed C code did not produce a structure. Parsed composites: " + names);
        }

        if (expectedStructName != null && !expectedStructName.isBlank()) {
            for (Structure s : parsedStructs) {
                if (expectedStructName.equals(s.getName())) {
                    return s;
                }
            }

            if (parsedStructs.size() == 1) {
                // If only one struct was defined, accept it even if the name didn't match
                return parsedStructs.get(0);
            }

            List<String> names = new ArrayList<>();
            for (Structure s : parsedStructs) {
                names.add(s.getName());
            }
            throw new Exception("C code defined multiple structures, but none matched expected name '" +
                expectedStructName + "'. Defined structures: " + names);
        }

        if (parsedStructs.size() > 1) {
            List<String> names = new ArrayList<>();
            for (Structure s : parsedStructs) {
                names.add(s.getName());
            }
            throw new Exception("C code defined multiple structures; please provide only one structure definition. " +
                "Defined structures: " + names);
        }

        return parsedStructs.get(0);
    }

    // ========== AUTO_CREATE ACTION ==========

    private McpSchema.CallToolResult executeAutoCreate(Map<String, Object> arguments, Program currentProgram) {
        String functionIdentifier = (String) arguments.get("function_identifier");
        String variableName = (String) arguments.get("variable_name");

        if (functionIdentifier == null || functionIdentifier.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("function_identifier parameter is required for auto_create action")
                .build();
        }

        if (variableName == null || variableName.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("variable_name parameter is required for auto_create action")
                .build();
        }

        StructureResult result = createAndApplyStructure(currentProgram, functionIdentifier, variableName);

        return McpSchema.CallToolResult.builder()
            .addTextContent(result.success ?
                "Successfully created and applied structure: " + result.message :
                "Failed to create structure: " + result.errorMessage)
            .build();
    }

    private static class StructureResult {
        final boolean success;
        final String message;
        final String errorMessage;

        StructureResult(boolean success, String message, String errorMessage) {
            this.success = success;
            this.message = message;
            this.errorMessage = errorMessage;
        }
    }

    private StructureResult createAndApplyStructure(Program program, String functionIdentifier, String variableName) {
        final StringBuilder errorMessage = new StringBuilder();
        final StringBuilder successMessage = new StringBuilder();
        final AtomicBoolean success = new AtomicBoolean(false);

        try {
            SwingUtilities.invokeAndWait(() ->
                performStructureCreation(program, functionIdentifier, variableName, success, successMessage, errorMessage));
        } catch (Exception e) {
            String msg = "Failed to create structure on Swing thread: " + e.getMessage();
            errorMessage.append(msg);
            Msg.error(this, msg, e);
        }

        return new StructureResult(success.get(), successMessage.toString(), errorMessage.toString());
    }

    private void performStructureCreation(Program program, String functionIdentifier, String variableName,
                                        AtomicBoolean success, StringBuilder successMessage, StringBuilder errorMessage) {
        int txId = program.startTransaction("Auto Create Structure");
        boolean committed = false;

        try {
            Function function = findFunction(program, functionIdentifier);
            if (function == null) {
                errorMessage.append("Could not find function: ").append(functionIdentifier);
                return;
            }

            Msg.info(this, "Creating structure for variable '" + variableName + "' in function " + function.getName());

            DecompInterface decompiler = new DecompInterface();
            setupDecompiler(decompiler, program);

            try {
                DecompileResults results = decompiler.decompileFunction(function, 30, TaskMonitor.DUMMY);

                if (!results.decompileCompleted()) {
                    errorMessage.append("Decompilation failed for function: ").append(function.getName());
                    return;
                }

                HighFunction highFunction = results.getHighFunction();

                HighVariable highVar = findHighVariable(highFunction, variableName);
                if (highVar == null) {
                    errorMessage.append("Could not find variable '").append(variableName).append("' in function");
                    return;
                }

                boolean applied = createAndApplyStructureImpl(program, function, highVar, decompiler, highFunction,
                    successMessage, errorMessage);

                if (applied) {
                    success.set(true);
                    committed = true;
                }

            } finally {
                decompiler.dispose();
            }

        } catch (Exception e) {
            String msg = "Error during structure creation: " + e.getMessage();
            errorMessage.append(msg);
            Msg.error(this, msg, e);
        } finally {
            program.endTransaction(txId, committed);
        }
    }

    private boolean createAndApplyStructureImpl(Program program, Function function, HighVariable highVar,
                                             DecompInterface decompiler, HighFunction highFunction,
                                             StringBuilder successMessage, StringBuilder errorMessage) throws Exception {

        Structure structDT = null;
        try {
            Class<?> fillHelperClass = Class.forName("ghidra.app.decompiler.util.FillOutStructureHelper");
            Object fillHelper = fillHelperClass.getConstructor(Program.class, TaskMonitor.class)
                .newInstance(program, TaskMonitor.DUMMY);

            java.lang.reflect.Method processMethod = fillHelperClass.getMethod("processStructure",
                HighVariable.class, Function.class, boolean.class, boolean.class, DecompInterface.class);

            structDT = (Structure) processMethod.invoke(fillHelper, highVar, function, false, true, decompiler);
        } catch (Exception e) {
            errorMessage.append("FillOutStructureHelper not available or failed: ").append(e.getMessage());
            return false;
        }

        if (structDT == null) {
            errorMessage.append("Failed to create structure from variable usage");
            return false;
        }

        DataTypeManager dtm = program.getDataTypeManager();
        structDT = (Structure) dtm.addDataType(structDT, DataTypeConflictHandler.DEFAULT_HANDLER);
        PointerDataType ptrStruct = new PointerDataType(structDT);

        Variable var = findVariableFromDecompiler(function, highFunction, highVar.getSymbol().getName());

        if (var != null && var instanceof ghidra.program.model.listing.AutoParameterImpl) {
            updateFunctionParameter(function, var.getName(), ptrStruct);
            successMessage.append("Updated function parameter '").append(var.getName())
                         .append("' with structure type: ").append(structDT.getName());
        } else {
            HighFunctionDBUtil.updateDBVariable(highVar.getSymbol(), null, ptrStruct, SourceType.USER_DEFINED);
            successMessage.append("Updated local variable '").append(highVar.getSymbol().getName())
                         .append("' with structure type: ").append(structDT.getName());
        }

        Msg.info(this, "Successfully created and applied structure: " + structDT.getName());
        return true;
    }

    private Function findFunction(Program program, String identifier) {
        try {
            Address addr = program.getAddressFactory().getAddress(identifier);
            if (addr != null) {
                return program.getFunctionManager().getFunctionAt(addr);
            }
        } catch (Exception e) {
            // Not an address, try as name
        }

        var functionManager = program.getFunctionManager();
        var functions = functionManager.getFunctions(true);

        for (Function function : functions) {
            if (function.getName().equals(identifier)) {
                return function;
            }
        }

        return null;
    }

    private void setupDecompiler(DecompInterface decompiler, Program program) {
        DecompileOptions options = new DecompileOptions();
        options.grabFromProgram(program);
        decompiler.setOptions(options);
        decompiler.openProgram(program);
    }

    private HighVariable findHighVariable(HighFunction highFunction, String varName) {
        var symbols = highFunction.getLocalSymbolMap().getSymbols();
        while (symbols.hasNext()) {
            HighSymbol sym = symbols.next();
            if (sym.getName().equals(varName)) {
                return sym.getHighVariable();
            }
        }
        return null;
    }

    private void commitLocalNames(Program program, Function function) {
        try {
            program.flushEvents();
            if (function != null) {
                function.getLocalVariables();
                function.getParameters();
            }
        } catch (Exception e) {
            Msg.warn(this, "Failed to commit local names for function " + function.getName() + ": " + e.getMessage());
        }
    }

    private Variable findVariableFromDecompiler(Function function, HighFunction highFunction, String varName) {
        commitLocalNames(function.getProgram(), function);

        var symbols = highFunction.getLocalSymbolMap().getSymbols();
        while (symbols.hasNext()) {
            var symbol = symbols.next();
            if (symbol.getName().equals(varName)) {
                HighVariable highVar = symbol.getHighVariable();
                if (highVar != null) {
                    try {
                        var representative = highVar.getRepresentative();
                        if (representative != null) {
                            for (Parameter param : function.getParameters()) {
                                var storage = param.getVariableStorage();
                                if (storage != null && storage.getVarnodes().length > 0) {
                                    var paramVarnode = storage.getVarnodes()[0];
                                    if (paramVarnode.getAddress().equals(representative.getAddress())) {
                                        return param;
                                    }
                                }
                            }

                            for (Variable localVar : function.getLocalVariables()) {
                                var storage = localVar.getVariableStorage();
                                if (storage != null && storage.getVarnodes().length > 0) {
                                    var localVarnode = storage.getVarnodes()[0];
                                    if (localVarnode.getAddress().equals(representative.getAddress())) {
                                        return localVar;
                                    }
                                }
                            }
                        }
                    } catch (Exception e) {
                        // Continue if storage comparison fails
                    }
                }
            }
        }

        return null;
    }

    private void updateFunctionParameter(Function function, String paramName,
                                       DataType newType) throws InvalidInputException, DuplicateNameException {

        Parameter[] parameters = function.getParameters();
        Parameter[] newParams = new Parameter[parameters.length];

        for (int i = 0; i < parameters.length; i++) {
            if (parameters[i].getName().equals(paramName)) {
                newParams[i] = new ParameterImpl(
                    parameters[i].getName(),
                    newType,
                    parameters[i].getVariableStorage(),
                    function.getProgram(),
                    SourceType.USER_DEFINED
                );
            } else {
                newParams[i] = parameters[i];
            }
        }

        function.updateFunction(
            function.getCallingConventionName(),
            null,
            FunctionUpdateType.CUSTOM_STORAGE,
            true,
            SourceType.USER_DEFINED,
            newParams
        );
    }

    // ========== RENAME_FIELD ACTION ==========

    private McpSchema.CallToolResult executeRenameField(Map<String, Object> arguments, Program currentProgram) {
        String structureName = (String) arguments.get("structure_name");
        String newFieldName = (String) arguments.get("new_field_name");
        String oldFieldName = (String) arguments.get("old_field_name");
        Number offsetNum = (Number) arguments.get("offset");

        if (structureName == null || structureName.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("structure_name parameter is required for rename_field action")
                .build();
        }

        if (newFieldName == null || newFieldName.isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("new_field_name parameter is required for rename_field action")
                .build();
        }

        if (oldFieldName == null && offsetNum == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Either old_field_name or offset must be provided to identify the field")
                .build();
        }

        int txId = currentProgram.startTransaction("Rename Structure Field");
        boolean committed = false;
        try {
            DataTypeManager dtm = currentProgram.getDataTypeManager();
            DataType dataType = dtm.getDataType("/" + structureName);
            if (dataType == null) {
                dataType = dtm.getDataType("/auto_structs/" + structureName);
            }

            if (dataType == null) {
                // Search all data types
                List<DataType> allTypes = new ArrayList<>();
                dtm.getAllDataTypes(allTypes);
                for (DataType dt : allTypes) {
                    if (dt instanceof Structure && dt.getName().equals(structureName)) {
                        dataType = dt;
                        break;
                    }
                }
            }

            if (dataType == null) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Structure '" + structureName + "' not found")
                    .build();
            } else if (!(dataType instanceof Structure)) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Data type '" + structureName + "' found but is not a structure")
                    .build();
            }

            Structure structure = (Structure) dataType;
            DataTypeComponent component = null;
            if (offsetNum != null) {
                int offset = offsetNum.intValue();
                if (offset < 0 || offset >= structure.getLength()) {
                     return McpSchema.CallToolResult.builder()
                        .addTextContent("Offset " + offset + " is out of bounds for structure '" + structureName + "' (length " + structure.getLength() + ")")
                        .build();
                }
                component = structure.getComponentAt(offset);
                if (component == null) {
                     return McpSchema.CallToolResult.builder()
                        .addTextContent("No component found at offset " + offset + " in structure '" + structureName + "'")
                        .build();
                }
            } else {
                DataTypeComponent[] components = structure.getComponents();
                for (DataTypeComponent c : components) {
                    String name = c.getFieldName();
                    if (name != null && name.equals(oldFieldName)) {
                        component = c;
                        break;
                    }
                }
                if (component == null) {
                    return McpSchema.CallToolResult.builder()
                        .addTextContent("Field '" + oldFieldName + "' not found in structure '" + structureName + "'")
                        .build();
                }
            }

            String previousName = component.getFieldName();
            try {
                component.setFieldName(newFieldName);
            } catch (Exception e) {
                 return McpSchema.CallToolResult.builder()
                    .addTextContent("Failed to set field name: " + e.getMessage())
                    .build();
            }

            committed = true;
            return McpSchema.CallToolResult.builder()
                .addTextContent("Successfully renamed field in structure '" + structure.getName() + "': " +
                                (previousName != null ? previousName : ("offset " + component.getOffset())) +
                                " -> " + newFieldName)
                .build();

        } catch (Exception e) {
            String msg = "Error renaming structure field: " + e.getMessage();
            Msg.error(this, msg, e);
            return McpSchema.CallToolResult.builder()
                .addTextContent(msg)
                .build();
        } finally {
            currentProgram.endTransaction(txId, committed);
        }
    }

    // ========== FIELD_XREFS ACTION ==========

    private McpSchema.CallToolResult executeFieldXrefs(Map<String, Object> arguments, Program currentProgram) {
        // Parse required parameters
        String structName = (String) arguments.get("structure_name");
        if (structName == null || structName.trim().isEmpty()) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("structure_name parameter is required for field_xrefs action")
                .build();
        }

        // Parse optional field identifiers
        String fieldName = (String) arguments.get("field_name");
        Integer fieldOffset = null;
        if (arguments.get("field_offset") instanceof Number) {
            fieldOffset = ((Number) arguments.get("field_offset")).intValue();
        }

        if ((fieldName == null || fieldName.trim().isEmpty()) && fieldOffset == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Either field_name or field_offset parameter is required for field_xrefs action")
                .build();
        }

        // Parse optional instance address
        String instanceAddressStr = (String) arguments.get("instance_address");
        Address instanceAddress = null;
        if (instanceAddressStr != null && !instanceAddressStr.trim().isEmpty()) {
            try {
                instanceAddress = currentProgram.getAddressFactory().getAddress(instanceAddressStr);
            } catch (Exception e) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Invalid instance_address format: " + instanceAddressStr)
                    .build();
            }
        }

        // Parse pagination
        int offset = 0;
        int limit = 100;
        if (arguments.get("offset") instanceof Number) {
            offset = ((Number) arguments.get("offset")).intValue();
        }
        if (arguments.get("limit") instanceof Number) {
            limit = ((Number) arguments.get("limit")).intValue();
        }

        // Resolve structure
        DataTypeManager dtm = currentProgram.getDataTypeManager();
        Structure struct = resolveStructureForXrefs(dtm, structName);
        if (struct == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Structure not found: " + structName)
                .build();
        }

        // Resolve field
        DataTypeComponent fieldComponent = resolveFieldForXrefs(struct, fieldName, fieldOffset);
        if (fieldComponent == null) {
            String fieldDesc = fieldName != null ? "field_name: " + fieldName : "field_offset: " + fieldOffset;
            return McpSchema.CallToolResult.builder()
                .addTextContent("Field not found in structure " + struct.getName() + " with " + fieldDesc)
                .build();
        }

        int resolvedFieldOffset = fieldComponent.getOffset();
        int fieldSize = fieldComponent.getLength();
        String resolvedFieldName = fieldComponent.getFieldName() != null ?
            fieldComponent.getFieldName() : "(offset_" + resolvedFieldOffset + ")";

        // Build result
        StringBuilder result = new StringBuilder();
        result.append("Struct Field Cross-References for ")
              .append(struct.getName()).append(".").append(resolvedFieldName)
              .append(" (offset +0x").append(String.format("%X", resolvedFieldOffset))
              .append(", ").append(fieldSize).append(" bytes):\n\n");

        List<FieldReference> allReferences = new ArrayList<>();

        // Run type-based query (decompiler analysis)
        List<FieldReference> typeBasedRefs = findTypeBasedReferences(
            currentProgram, struct, resolvedFieldName, resolvedFieldOffset);

        if (!typeBasedRefs.isEmpty()) {
            result.append("=== Type-Based References ===\n");
            allReferences.addAll(typeBasedRefs);
        }

        // Run instance-based query if address provided
        if (instanceAddress != null) {
            List<FieldReference> instanceRefs = findInstanceBasedReferences(
                currentProgram, instanceAddress, resolvedFieldOffset, fieldSize);

            if (!instanceRefs.isEmpty()) {
                result.append("\n=== Instance-Based References (at ")
                      .append(instanceAddress).append(") ===\n");
                allReferences.addAll(instanceRefs);
            }
        }

        // Format and paginate results
        if (allReferences.isEmpty()) {
            result.append("No references found.\n");
        } else {
            String currentFunction = null;
            int displayCount = 0;
            int totalCount = allReferences.size();

            for (int i = 0; i < allReferences.size(); i++) {
                if (i < offset) continue;
                if (displayCount >= limit) break;

                FieldReference ref = allReferences.get(i);

                // Print function header for new functions
                if (ref.source.equals("DECOMPILER") &&
                    (currentFunction == null || !currentFunction.equals(ref.functionName))) {
                    currentFunction = ref.functionName;
                    result.append("\nFunction: ").append(ref.functionName);
                    if (ref.functionAddress != null) {
                        result.append(" (").append(ref.functionAddress).append(")");
                    }
                    result.append("\n");
                }

                result.append("  ").append(ref.toString()).append("\n");
                displayCount++;
            }

            result.append("\nShowing ").append(displayCount).append(" of ")
                  .append(totalCount).append(" references");
            if (offset > 0) {
                result.append(" (offset: ").append(offset).append(")");
            }
            result.append("\n");
        }

        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }

    /**
     * Resolve a structure by name from the DataTypeManager for field_xrefs.
     */
    private Structure resolveStructureForXrefs(DataTypeManager dtm, String structName) {
        // Try direct lookup
        DataType dt = dtm.getDataType("/" + structName);
        if (dt instanceof Structure) {
            return (Structure) dt;
        }

        // Try without leading slash
        dt = dtm.getDataType(structName);
        if (dt instanceof Structure) {
            return (Structure) dt;
        }

        // Search all data types
        Iterator<DataType> iter = dtm.getAllDataTypes();
        while (iter.hasNext()) {
            DataType dataType = iter.next();

            // Unwrap TypeDef
            DataType baseType = dataType;
            while (baseType instanceof TypeDef) {
                baseType = ((TypeDef) baseType).getBaseDataType();
            }

            if (baseType instanceof Structure) {
                Structure s = (Structure) baseType;
                if (s.getName().equals(structName)) {
                    return s;
                }
            }
        }

        // Try case-insensitive search
        iter = dtm.getAllDataTypes();
        while (iter.hasNext()) {
            DataType dataType = iter.next();
            DataType baseType = dataType;
            while (baseType instanceof TypeDef) {
                baseType = ((TypeDef) baseType).getBaseDataType();
            }

            if (baseType instanceof Structure) {
                Structure s = (Structure) baseType;
                if (s.getName().equalsIgnoreCase(structName)) {
                    return s;
                }
            }
        }

        return null;
    }

    /**
     * Resolve a field within a structure by name or offset for field_xrefs.
     */
    private DataTypeComponent resolveFieldForXrefs(Structure struct, String fieldName, Integer fieldOffset) {
        DataTypeComponent[] components = struct.getComponents();

        // If offset is provided, use it directly
        if (fieldOffset != null) {
            DataTypeComponent comp = struct.getComponentAt(fieldOffset);
            if (comp != null) {
                return comp;
            }
            // Try exact offset match in components
            for (DataTypeComponent comp2 : components) {
                if (comp2.getOffset() == fieldOffset) {
                    return comp2;
                }
            }
            return null;
        }

        // Search by field name
        if (fieldName != null) {
            // Exact match first
            for (DataTypeComponent comp : components) {
                String compName = comp.getFieldName();
                if (compName != null && compName.equals(fieldName)) {
                    return comp;
                }
            }

            // Case-insensitive match
            for (DataTypeComponent comp : components) {
                String compName = comp.getFieldName();
                if (compName != null && compName.equalsIgnoreCase(fieldName)) {
                    return comp;
                }
            }
        }

        return null;
    }

    /**
     * Find type-based references using decompiler analysis.
     */
    private List<FieldReference> findTypeBasedReferences(
            Program program,
            Structure targetStruct,
            String targetFieldName,
            int targetFieldOffset) {

        List<FieldReference> references = new ArrayList<>();

        DecompInterface decompiler = new DecompInterface();
        try {
            // Setup decompiler
            DecompileOptions options = new DecompileOptions();
            options.grabFromProgram(program);
            decompiler.setOptions(options);
            decompiler.openProgram(program);

            // Iterate all functions
            FunctionIterator funcIter = program.getFunctionManager().getFunctions(true);
            while (funcIter.hasNext()) {
                Function function = funcIter.next();

                // Skip external/thunk functions
                if (function.isExternal() || function.isThunk()) {
                    continue;
                }

                try {
                    // Decompile with timeout
                    DecompileResults results = decompiler.decompileFunction(
                        function, 30, TaskMonitor.DUMMY);

                    if (!results.decompileCompleted()) {
                        continue;
                    }

                    ClangTokenGroup tokenGroup = results.getCCodeMarkup();
                    if (tokenGroup == null) {
                        continue;
                    }

                    // Walk token tree looking for field accesses
                    walkClangTokens(tokenGroup, targetStruct, targetFieldOffset,
                        function.getName(), function.getEntryPoint(), references);

                } catch (Exception e) {
                    // Skip functions that fail to decompile
                    continue;
                }
            }
        } finally {
            decompiler.dispose();
        }

        return references;
    }

    /**
     * Recursively walk the Clang token tree looking for ClangFieldToken nodes.
     */
    private void walkClangTokens(
            ClangNode node,
            Structure targetStruct,
            int targetFieldOffset,
            String functionName,
            Address functionAddress,
            List<FieldReference> results) {

        if (node instanceof ClangFieldToken) {
            ClangFieldToken fieldToken = (ClangFieldToken) node;

            // Get the data type this field belongs to
            DataType parentType = fieldToken.getDataType();
            int fieldOffset = fieldToken.getOffset();

            // Check if this matches our target
            if (isMatchingStructType(parentType, targetStruct) &&
                fieldOffset == targetFieldOffset) {

                // Determine access type from context
                String accessType = determineAccessType(fieldToken);

                // Get the address where this access occurs
                Address minAddress = fieldToken.getMinAddress();

                // Get context (the field access text)
                String context = fieldToken.toString();

                results.add(new FieldReference(
                    minAddress,
                    functionName,
                    functionAddress,
                    accessType,
                    context,
                    "DECOMPILER"
                ));
            }
        }

        // Recursively process children
        int numChildren = node.numChildren();
        for (int i = 0; i < numChildren; i++) {
            walkClangTokens(node.Child(i), targetStruct, targetFieldOffset,
                functionName, functionAddress, results);
        }
    }

    /**
     * Check if a data type matches the target structure.
     */
    private boolean isMatchingStructType(DataType type, Structure targetStruct) {
        if (type == null) {
            return false;
        }

        // Unwrap TypeDef
        while (type instanceof TypeDef) {
            type = ((TypeDef) type).getBaseDataType();
        }

        // Check direct match
        if (type instanceof Structure) {
            Structure s = (Structure) type;
            return s.getName().equals(targetStruct.getName());
        }

        return false;
    }

    /**
     * Try to determine if a field access is a read or write.
     */
    private String determineAccessType(ClangFieldToken fieldToken) {
        ClangNode parent = fieldToken.Parent();

        if (parent != null) {
            String parentText = parent.toString();
            if (parentText.contains("=") && !parentText.contains("==")) {
                String fieldText = fieldToken.toString();
                int equalPos = parentText.indexOf('=');
                int fieldPos = parentText.indexOf(fieldText);
                if (fieldPos >= 0 && fieldPos < equalPos) {
                    return "WRITE";
                }
            }
        }

        return "READ";
    }

    /**
     * Find instance-based references using ReferenceManager.
     */
    private List<FieldReference> findInstanceBasedReferences(
            Program program,
            Address baseAddress,
            int fieldOffset,
            int fieldSize) {

        List<FieldReference> references = new ArrayList<>();

        // Calculate field address
        Address fieldAddress = baseAddress.add(fieldOffset);

        // Get references to the field address (and adjacent bytes for multi-byte fields)
        for (int byteOffset = 0; byteOffset < fieldSize; byteOffset++) {
            Address targetAddr = fieldAddress.add(byteOffset);
            ReferenceIterator refIter = program.getReferenceManager().getReferencesTo(targetAddr);

            while (refIter.hasNext()) {
                Reference ref = refIter.next();
                Address fromAddr = ref.getFromAddress();
                RefType refType = ref.getReferenceType();

                // Determine access type
                String accessType = classifyReferenceType(refType);

                // Get containing function
                Function containingFunc = program.getFunctionManager().getFunctionContaining(fromAddr);
                String funcName = containingFunc != null ? containingFunc.getName() : "(unknown)";
                Address funcAddr = containingFunc != null ? containingFunc.getEntryPoint() : null;

                // Get instruction/data at reference
                String context = refType.toString() + " at " + fromAddr;

                // Avoid duplicate entries for multi-byte fields
                boolean isDuplicate = references.stream()
                    .anyMatch(r -> r.address.equals(fromAddr) && r.source.equals("ADDRESS"));

                if (!isDuplicate) {
                    references.add(new FieldReference(
                        fromAddr,
                        funcName,
                        funcAddr,
                        accessType,
                        context,
                        "ADDRESS"
                    ));
                }
            }
        }

        return references;
    }

    /**
     * Classify a reference type as READ, WRITE, or UNKNOWN.
     */
    private String classifyReferenceType(RefType refType) {
        if (refType.isRead()) {
            return "READ";
        } else if (refType.isWrite()) {
            return "WRITE";
        } else if (refType.isData()) {
            return "DATA";
        } else if (refType.isCall()) {
            return "CALL";
        }
        return "UNKNOWN";
    }
}

```

`src/main/java/ghidrassistmcp/tools/XrefsTool.java`:

```java
/*
 * MCP tool for getting cross-references to/from an address or function.
 * Consolidates xrefs_to, xrefs_from, and function_xrefs into a single tool.
 */
package ghidrassistmcp.tools;

import java.util.List;
import java.util.Map;
import java.util.Set;

import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Reference;
import ghidra.program.model.symbol.ReferenceIterator;
import ghidrassistmcp.McpTool;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * MCP tool that gets cross-references to and/or from an address or function.
 * Replaces separate xrefs_to, xrefs_from, and function_xrefs tools.
 */
public class XrefsTool implements McpTool {

    @Override
    public boolean isCacheable() {
        return true;
    }

    @Override
    public String getName() {
        return "xrefs";
    }

    @Override
    public String getDescription() {
        return "Get cross-references to/from an address or function (direction: to, from, or both)";
    }

    @Override
    public McpSchema.JsonSchema getInputSchema() {
        return new McpSchema.JsonSchema("object",
            Map.of(
                "address", Map.of(
                    "type", "string",
                    "description", "Optional: address to find xrefs for (either address or function must be provided)"
                ),
                "function", Map.of(
                    "type", "string",
                    "description", "Optional: function name to find callers/callees xrefs for (either address or function must be provided)"
                ),
                "direction", Map.of(
                    "type", "string",
                    "description", "Direction of cross-references to return",
                    "enum", List.of("to", "from", "both"),
                    "default", "both"
                ),
                "limit", Map.of(
                    "type", "integer",
                    "description", "Maximum number of references to return (default 100)"
                )
            ),
            List.of(), null, null, null);  // Neither address nor function is strictly required, but one must be provided
    }

    @Override
    public McpSchema.CallToolResult execute(Map<String, Object> arguments, Program currentProgram) {
        if (currentProgram == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("No program currently loaded")
                .build();
        }

        String addressStr = (String) arguments.get("address");
        String functionName = (String) arguments.get("function");
        String direction = (String) arguments.get("direction");
        int limit = 100;

        if (arguments.get("limit") instanceof Number) {
            limit = ((Number) arguments.get("limit")).intValue();
        }

        if (direction == null || direction.isEmpty()) {
            direction = "both";
        }
        direction = direction.toLowerCase();

        if (!direction.equals("to") && !direction.equals("from") && !direction.equals("both")) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Invalid direction. Use 'to', 'from', or 'both'")
                .build();
        }

        // Check that at least one of address or function is provided
        if ((addressStr == null || addressStr.isEmpty()) && (functionName == null || functionName.isEmpty())) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Either 'address' or 'function' parameter is required")
                .build();
        }

        // If function is provided, use function-based xrefs
        if (functionName != null && !functionName.isEmpty()) {
            return getFunctionXrefs(currentProgram, functionName, direction, limit);
        }

        // Otherwise, use address-based xrefs
        return getAddressXrefs(currentProgram, addressStr, direction, limit);
    }

    /**
     * Get cross-references for an address.
     */
    private McpSchema.CallToolResult getAddressXrefs(Program program, String addressStr, String direction, int limit) {
        // Parse the address
        Address address;
        try {
            address = program.getAddressFactory().getAddress(addressStr);
            if (address == null) {
                return McpSchema.CallToolResult.builder()
                    .addTextContent("Invalid address: " + addressStr)
                    .build();
            }
        } catch (Exception e) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Error parsing address: " + e.getMessage())
                .build();
        }

        StringBuilder result = new StringBuilder();
        result.append("Cross-references for ").append(addressStr).append(":\n\n");

        // Get references TO this address
        if (direction.equals("to") || direction.equals("both")) {
            result.append("## References TO this address:\n");
            ReferenceIterator refsTo = program.getReferenceManager().getReferencesTo(address);
            int count = 0;

            while (refsTo.hasNext() && count < limit) {
                Reference ref = refsTo.next();
                result.append("  - From: ").append(ref.getFromAddress())
                      .append(" (").append(ref.getReferenceType()).append(")\n");
                count++;
            }

            if (count == 0) {
                result.append("  No references found.\n");
            } else if (count >= limit) {
                result.append("  ... (limited to ").append(limit).append(" results)\n");
            }
            result.append("\n");
        }

        // Get references FROM this address
        if (direction.equals("from") || direction.equals("both")) {
            result.append("## References FROM this address:\n");
            Reference[] refsFrom = program.getReferenceManager().getReferencesFrom(address);
            int count = 0;

            for (Reference ref : refsFrom) {
                if (count >= limit) break;
                result.append("  - To: ").append(ref.getToAddress())
                      .append(" (").append(ref.getReferenceType()).append(")\n");
                count++;
            }

            if (count == 0) {
                result.append("  No references found.\n");
            } else if (count >= limit) {
                result.append("  ... (limited to ").append(limit).append(" results)\n");
            }
        }

        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }

    /**
     * Get cross-references for a function (callers and callees).
     */
    private McpSchema.CallToolResult getFunctionXrefs(Program program, String functionName, String direction, int limit) {
        // Find the function
        Function function = findFunctionByName(program, functionName);
        if (function == null) {
            return McpSchema.CallToolResult.builder()
                .addTextContent("Function not found: " + functionName)
                .build();
        }

        StringBuilder result = new StringBuilder();
        result.append("Cross-references for function: ").append(functionName).append("\n");
        result.append("Entry Point: ").append(function.getEntryPoint()).append("\n\n");

        int totalCount = 0;
        int count = 0;

        // Get XREFs TO the function (callers)
        if (direction.equals("to") || direction.equals("both")) {
            result.append("## References TO function (callers):\n");
            Set<Function> callingFunctions = function.getCallingFunctions(null);

            for (Function callerFunc : callingFunctions) {
                if (count >= limit) {
                    break;
                }

                result.append("  - ").append(callerFunc.getEntryPoint())
                      .append(" (").append(callerFunc.getName()).append(")\n");
                count++;
                totalCount++;
            }

            if (callingFunctions.isEmpty()) {
                result.append("  No callers found.\n");
            } else if (count >= limit) {
                result.append("  ... (limited to ").append(limit).append(" results)\n");
            }
            result.append("\n");
        }

        // Get XREFs FROM the function (callees)
        if (direction.equals("from") || direction.equals("both")) {
            result.append("## References FROM function (callees):\n");
            Set<Function> calledFunctions = function.getCalledFunctions(null);

            int calleeCount = 0;
            for (Function calledFunc : calledFunctions) {
                if (calleeCount >= limit) {
                    break;
                }

                result.append("  - ").append(calledFunc.getEntryPoint())
                      .append(" (").append(calledFunc.getName()).append(")\n");
                calleeCount++;
                totalCount++;
            }

            if (calledFunctions.isEmpty()) {
                result.append("  No called functions found.\n");
            } else if (calleeCount >= limit) {
                result.append("  ... (limited to ").append(limit).append(" results)\n");
            }
        }

        if (totalCount == 0) {
            result.append("No cross-references found for function: ").append(functionName);
        }

        return McpSchema.CallToolResult.builder()
            .addTextContent(result.toString())
            .build();
    }

    /**
     * Find a function by name.
     */
    private Function findFunctionByName(Program program, String functionName) {
        var functionManager = program.getFunctionManager();
        var functions = functionManager.getFunctions(true);

        for (Function function : functions) {
            if (function.getName().equals(functionName)) {
                return function;
            }
        }
        return null;
    }
}

```

`src/main/resources/images/README.txt`:

```txt
The "src/resources/images" directory is intended to hold all image/icon files used by
this module.

```