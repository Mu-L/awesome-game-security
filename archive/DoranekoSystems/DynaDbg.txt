Project Path: arc_DoranekoSystems_DynaDbg_xgtbd9rj

Source Tree:

```txt
arc_DoranekoSystems_DynaDbg_xgtbd9rj
├── CREDITS.md
├── Entitlements.plist
├── LICENSE
├── README.md
├── assets
│   └── image
│       └── shooting_game.png
├── benchmark
│   └── shooting_game
│       ├── Makefile
│       ├── README.md
│       └── shooting_game.cpp
├── doc
│   └── Creating a GUI-based macOS&iOS ARM64 Debugger.pdf
├── frameworks
│   └── wasm
│       └── chrome-extension
│           ├── background.js
│           ├── content.js
│           ├── icons
│           │   ├── icon128.png
│           │   ├── icon16.png
│           │   └── icon48.png
│           ├── inject.js
│           ├── manifest.json
│           ├── popup.html
│           └── popup.js
├── scripts
│   └── check-licenses.sh
└── src
    ├── client
    │   ├── README.md
    │   ├── application_icon.png
    │   ├── index.html
    │   ├── package-lock.json
    │   ├── package.json
    │   ├── src
    │   │   ├── App.tsx
    │   │   ├── assets
    │   │   │   ├── dynadbg-demo.mp4
    │   │   │   ├── dynadbg-icon.png
    │   │   │   ├── profile.png
    │   │   │   ├── tauri.svg
    │   │   │   ├── top-img.png
    │   │   │   ├── typescript.svg
    │   │   │   └── vite.svg
    │   │   ├── components
    │   │   │   ├── AboutContent.tsx
    │   │   │   ├── AssemblyView.tsx
    │   │   │   ├── CodeTracingWindow.tsx
    │   │   │   ├── ColumnResizer.tsx
    │   │   │   ├── DebuggerContent.tsx
    │   │   │   ├── DebuggerSidebar.tsx
    │   │   │   ├── DebuggerToolbar.tsx
    │   │   │   ├── DecompileView.tsx
    │   │   │   ├── DocumentationContent.tsx
    │   │   │   ├── ExceptionMonitor.tsx
    │   │   │   ├── ExpandableTreeItem.tsx
    │   │   │   ├── Footer.tsx
    │   │   │   ├── FunctionTreeItem.tsx
    │   │   │   ├── GhidraAnalyzer.tsx
    │   │   │   ├── GraphViewWindow.tsx
    │   │   │   ├── Header.tsx
    │   │   │   ├── HelpContent.tsx
    │   │   │   ├── HomePage.tsx
    │   │   │   ├── HomeSidebar.tsx
    │   │   │   ├── InformationContent.tsx
    │   │   │   ├── LicenseAgreementDialog.tsx
    │   │   │   ├── LinuxSpawnManager.tsx
    │   │   │   ├── MainApp.tsx
    │   │   │   ├── MemoryView.tsx
    │   │   │   ├── NewsContent.tsx
    │   │   │   ├── ProcessManager.tsx
    │   │   │   ├── RealtimeStateDisplay.tsx
    │   │   │   ├── RegisterView.tsx
    │   │   │   ├── Resizer.tsx
    │   │   │   ├── ScannerContent.tsx
    │   │   │   ├── ScannerSidebar.tsx
    │   │   │   ├── ScannerToolbar.tsx
    │   │   │   ├── ServerConnection.tsx
    │   │   │   ├── ServerContent.tsx
    │   │   │   ├── SettingsContent.tsx
    │   │   │   ├── Sidebar.tsx
    │   │   │   ├── SidebarPanel.tsx
    │   │   │   ├── SpawnManager.tsx
    │   │   │   ├── StackView.tsx
    │   │   │   ├── StatePanel.tsx
    │   │   │   ├── StatusBar.tsx
    │   │   │   ├── TerminalWindow.tsx
    │   │   │   ├── ToolsContent.tsx
    │   │   │   ├── TreeItem.tsx
    │   │   │   ├── VirtualizedTable.tsx
    │   │   │   └── WatchpointExceptionWindow.tsx
    │   │   ├── contexts
    │   │   │   └── TauriSystemStateContext.tsx
    │   │   ├── data
    │   │   │   └── sampleData.ts
    │   │   ├── hooks
    │   │   │   ├── useAppState.ts
    │   │   │   ├── useBreakpointExceptionHandler.ts
    │   │   │   ├── useColumnResize.ts
    │   │   │   ├── useDebugLogger.ts
    │   │   │   ├── useDebuggerContentState.ts
    │   │   │   ├── useExceptionHandler.ts
    │   │   │   ├── useGhidraAnalysis.ts
    │   │   │   ├── useGlobalDebugLogger.tsx
    │   │   │   ├── useGlobalExceptionHandler.tsx
    │   │   │   ├── useGlobalNetworkLogger.tsx
    │   │   │   ├── useLocalStorage.ts
    │   │   │   ├── useNetworkLogger.ts
    │   │   │   ├── useResizable.ts
    │   │   │   ├── useScanHistory.ts
    │   │   │   ├── useScannerGlobalState.ts
    │   │   │   ├── useScannerState.ts
    │   │   │   ├── useSidebarWidth.ts
    │   │   │   ├── useSymbolCache.ts
    │   │   │   ├── useTableColumnResize.ts
    │   │   │   ├── useTauriExceptionStore.ts
    │   │   │   ├── useTauriSystemState.ts
    │   │   │   ├── useTauriSystemStateSingleton.ts
    │   │   │   └── useWatchpointExceptionHandler.ts
    │   │   ├── lib
    │   │   │   └── api.ts
    │   │   ├── main.tsx
    │   │   ├── pages
    │   │   │   ├── CodeTracingPage.tsx
    │   │   │   ├── GraphViewPage.tsx
    │   │   │   ├── TerminalPage.tsx
    │   │   │   └── WatchpointExceptionPage.tsx
    │   │   ├── stores
    │   │   │   └── uiStore.ts
    │   │   ├── types
    │   │   │   └── index.ts
    │   │   ├── utils
    │   │   │   ├── addressEncoder.ts
    │   │   │   ├── arm64BranchPredictor.ts
    │   │   │   ├── constants.ts
    │   │   │   ├── theme.ts
    │   │   │   └── traceFileParser.ts
    │   │   └── vite-env.d.ts
    │   ├── src-tauri
    │   │   ├── Cargo.lock
    │   │   ├── Cargo.toml
    │   │   ├── build.rs
    │   │   ├── capabilities
    │   │   │   ├── default.json
    │   │   │   └── watchpoint.json
    │   │   ├── deny.toml
    │   │   ├── icons
    │   │   │   ├── 128x128.png
    │   │   │   ├── 128x128@2x.png
    │   │   │   ├── 32x32.png
    │   │   │   ├── 64x64.png
    │   │   │   ├── Square107x107Logo.png
    │   │   │   ├── Square142x142Logo.png
    │   │   │   ├── Square150x150Logo.png
    │   │   │   ├── Square284x284Logo.png
    │   │   │   ├── Square30x30Logo.png
    │   │   │   ├── Square310x310Logo.png
    │   │   │   ├── Square44x44Logo.png
    │   │   │   ├── Square71x71Logo.png
    │   │   │   ├── Square89x89Logo.png
    │   │   │   ├── StoreLogo.png
    │   │   │   ├── android
    │   │   │   │   ├── mipmap-hdpi
    │   │   │   │   │   ├── ic_launcher.png
    │   │   │   │   │   ├── ic_launcher_foreground.png
    │   │   │   │   │   └── ic_launcher_round.png
    │   │   │   │   ├── mipmap-mdpi
    │   │   │   │   │   ├── ic_launcher.png
    │   │   │   │   │   ├── ic_launcher_foreground.png
    │   │   │   │   │   └── ic_launcher_round.png
    │   │   │   │   ├── mipmap-xhdpi
    │   │   │   │   │   ├── ic_launcher.png
    │   │   │   │   │   ├── ic_launcher_foreground.png
    │   │   │   │   │   └── ic_launcher_round.png
    │   │   │   │   ├── mipmap-xxhdpi
    │   │   │   │   │   ├── ic_launcher.png
    │   │   │   │   │   ├── ic_launcher_foreground.png
    │   │   │   │   │   └── ic_launcher_round.png
    │   │   │   │   └── mipmap-xxxhdpi
    │   │   │   │       ├── ic_launcher.png
    │   │   │   │       ├── ic_launcher_foreground.png
    │   │   │   │       └── ic_launcher_round.png
    │   │   │   ├── icon copy.png
    │   │   │   ├── icon.icns
    │   │   │   ├── icon.ico
    │   │   │   ├── icon.png
    │   │   │   └── ios
    │   │   │       ├── AppIcon-20x20@1x.png
    │   │   │       ├── AppIcon-20x20@2x-1.png
    │   │   │       ├── AppIcon-20x20@2x.png
    │   │   │       ├── AppIcon-20x20@3x.png
    │   │   │       ├── AppIcon-29x29@1x.png
    │   │   │       ├── AppIcon-29x29@2x-1.png
    │   │   │       ├── AppIcon-29x29@2x.png
    │   │   │       ├── AppIcon-29x29@3x.png
    │   │   │       ├── AppIcon-40x40@1x.png
    │   │   │       ├── AppIcon-40x40@2x-1.png
    │   │   │       ├── AppIcon-40x40@2x.png
    │   │   │       ├── AppIcon-40x40@3x.png
    │   │   │       ├── AppIcon-512@2x.png
    │   │   │       ├── AppIcon-60x60@2x.png
    │   │   │       ├── AppIcon-60x60@3x.png
    │   │   │       ├── AppIcon-76x76@1x.png
    │   │   │       ├── AppIcon-76x76@2x.png
    │   │   │       └── AppIcon-83.5x83.5@2x.png
    │   │   ├── src
    │   │   │   ├── lib.rs
    │   │   │   ├── main.rs
    │   │   │   └── state.rs
    │   │   └── tauri.conf.json
    │   ├── tsconfig.json
    │   ├── vite.config.ts
    │   └── yarn.lock
    └── server
        ├── Cargo.toml
        ├── build.bat
        ├── build.rs
        ├── build.sh
        ├── deny.toml
        └── src
            ├── allocator.rs
            ├── api.rs
            ├── cpp
            │   └── src
            │       ├── common
            │       │   ├── arm64_decoder.cpp
            │       │   ├── arm64_decoder.h
            │       │   ├── dll_export.h
            │       │   ├── exception_info.h
            │       │   ├── trace_file.cpp
            │       │   ├── trace_file.h
            │       │   ├── util.cpp
            │       │   └── util.h
            │       ├── darwin
            │       │   ├── Makefile
            │       │   ├── core
            │       │   │   ├── callback_stubs.mm
            │       │   │   ├── file_api.h
            │       │   │   ├── file_api.mm
            │       │   │   ├── memory_io.h
            │       │   │   ├── memory_io.mm
            │       │   │   ├── native_api.h
            │       │   │   ├── native_api.mm
            │       │   │   ├── process_api.h
            │       │   │   └── process_api.mm
            │       │   └── debugger
            │       │       ├── arch_defs.h
            │       │       ├── debugger.h
            │       │       ├── debugger_breakpoint.mm
            │       │       ├── debugger_core.mm
            │       │       ├── debugger_exception.mm
            │       │       ├── debugger_internal.h
            │       │       ├── debugger_native_api.mm
            │       │       ├── debugger_register.mm
            │       │       ├── debugger_trace.mm
            │       │       ├── debugger_types.h
            │       │       └── debugger_watchpoint.mm
            │       ├── linux
            │       │   ├── Makefile
            │       │   ├── core
            │       │   │   ├── callback_stubs.cpp
            │       │   │   ├── file_api.cpp
            │       │   │   ├── file_api.h
            │       │   │   ├── memory_io.cpp
            │       │   │   ├── memory_io.h
            │       │   │   ├── native_api.cpp
            │       │   │   ├── native_api.h
            │       │   │   ├── process_api.cpp
            │       │   │   └── process_api.h
            │       │   ├── debugger
            │       │   │   ├── arch_defs.h
            │       │   │   ├── debugger.h
            │       │   │   ├── debugger_breakpoint.cpp
            │       │   │   ├── debugger_core.cpp
            │       │   │   ├── debugger_exception.cpp
            │       │   │   ├── debugger_internal.h
            │       │   │   ├── debugger_memory.cpp
            │       │   │   ├── debugger_native_api.cpp
            │       │   │   ├── debugger_register.cpp
            │       │   │   ├── debugger_spawn.cpp
            │       │   │   ├── debugger_thread.cpp
            │       │   │   ├── debugger_types.h
            │       │   │   └── debugger_watchpoint.cpp
            │       │   ├── elf
            │       │   │   ├── elf_parser.cpp
            │       │   │   └── elf_parser.h
            │       │   └── pty
            │       │       ├── pty_manager.cpp
            │       │       └── pty_manager.h
            │       └── windows
            │           ├── core
            │           │   ├── callback_stubs.cpp
            │           │   ├── file_api.cpp
            │           │   ├── file_api.h
            │           │   ├── memory_io.cpp
            │           │   ├── memory_io.h
            │           │   ├── native_api.cpp
            │           │   └── native_api.h
            │           └── debugger
            │               ├── debugger.cpp
            │               └── debugger.h
            ├── lib.rs
            ├── logger.rs
            ├── macho_bridge.rs
            ├── main.rs
            ├── native_bridge.rs
            ├── ptrscan.rs
            ├── request.rs
            ├── serve.rs
            ├── swift
            │   ├── Package.resolved
            │   ├── Package.swift
            │   └── Sources
            │       └── MachOBridge.swift
            ├── util.rs
            └── wasm_bridge.rs

```

`CREDITS.md`:

```md
# Credits

This project uses the following open source libraries:

## Client (TypeScript/React)
* [React](https://github.com/facebook/react) - MIT License
* [MUI (Material-UI)](https://github.com/mui/material-ui) - MIT License
* [Tauri](https://github.com/tauri-apps/tauri) - Apache-2.0 / MIT License
* [Vite](https://github.com/vitejs/vite) - MIT License
* [xterm.js](https://github.com/xtermjs/xterm.js) - MIT License
* [Prism.js](https://github.com/PrismJS/prism) - MIT License
* [Zustand](https://github.com/pmndrs/zustand) - MIT License
* [react-window](https://github.com/bvaughn/react-window) - MIT License

## Server (Rust)
* [Tokio](https://github.com/tokio-rs/tokio) - MIT License
* [Warp](https://github.com/seanmonstar/warp) - MIT License
* [Serde](https://github.com/serde-rs/serde) - Apache-2.0 / MIT License
* [Capstone](https://github.com/capstone-rust/capstone-rs) - MIT License
* [Rayon](https://github.com/rayon-rs/rayon) - Apache-2.0 / MIT License
* [Clap](https://github.com/clap-rs/clap) - Apache-2.0 / MIT License
* [yara-x](https://github.com/VirusTotal/yara-x) - BSD 3-Clause License

## Special Thanks
* [MachOKit](https://github.com/p-x9/MachOKit) by [p-x9](https://github.com/p-x9) - MIT License
* [Cetus](https://github.com/Qwokka/Cetus) by [Qwokka](https://github.com/Qwokka) - Apache License 2.0

```

`Entitlements.plist`:

```plist
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
    <dict>
        <key>com.apple.springboard.debugapplications</key>
        <true/>
        <key>get-task-allow</key>
        <true/>
        <key>task_for_pid-allow</key>
        <true/>
        <key>com.apple.security.network.client</key>
        <true/>
        <key>com.apple.security.network.server</key>
        <true/>
        <key>com.apple.security.cs.debugger</key>
        <true/>
    </dict>
</plist>
```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.
```

`README.md`:

```md
# DynaDbg

Next-Generation Remote Analysis Suite for Reverse Engineering.

[![License: GPL v3](https://img.shields.io/badge/License-GPLv3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0)

> 🎉 **Open Source Announcement**  
> This project is open source!  
> ⚠️ **Note:** I am currently not accepting pull requests while I work on code reorganization. Please also refrain from posting code suggestions in Issues. Thank you for your understanding.

> **Motivation**
> Curiosity — nothing more.
> _This project is driven purely by a desire to explore and understand how low-level execution behaves across different systems._
>
> **Goal**
> To visualize low-level execution across multiple operating systems and architectures, assisting reverse engineering analysis and deepening technical understanding.

# Support OS

## Host

- Windows(x86_64)
- Linux(x86_64)
- Mac(arm64)

## Remote

| OS | Arch | Scanner | Debugger |
|---|---|:---:|:---:|
| Windows | x86_64 | ○ | × |
| macOS | arm64 | ○ | △ |
| Linux | x86_64 | ○ | △ |
| iOS | arm64 | ○ | △ |
| Android | arm64 | ○ | △ |
| WebAssembly | Browser | ○ | × |

# Usage

Please refer to the [Wiki](https://github.com/DoranekoSystems/DynaDbg/wiki/Using-DynaDbg) for detailed usage instructions.

# Building

- **GitHub Actions:** Fork this repository and run the **Build DynaDbg** workflow from the Actions tab. See [Wiki](https://github.com/DoranekoSystems/DynaDbg/wiki/GitHub-Actions) for detailed build options.
- **Manual Build:** See [Wiki](https://github.com/DoranekoSystems/DynaDbg/wiki/Manual-Build) for step-by-step instructions.

# Developing

Please refer to the [Wiki](https://github.com/DoranekoSystems/DynaDbg/wiki/Developing-DynaDbg) for development setup and guidelines.

# Screenshot

<img width="1512" height="1150" alt="" src="https://github.com/user-attachments/assets/114a05f5-b766-409b-98a9-4af003e64683" />

# Function

- Debugger
  <img width="800" height="520" alt="" src="https://github.com/user-attachments/assets/9e2c9953-80e8-4dec-b75a-47f5c9d75d03" />

- Memory Scan

  `Normal` | `YARA` | `Pointer`
  <img width="756" height="556" alt="" src="https://github.com/user-attachments/assets/4b11a095-bda5-4cc3-a4e5-536058a7853b" />

- Hardware Watchpoint
  <img width="556" height="356" alt="screenshot" src="https://github.com/user-attachments/assets/d4aa5a0a-4a71-4ed8-8160-801d6f92a265" />

- Code Tracing
  <img width="800" height="600" alt="" src="https://github.com/user-attachments/assets/2ee34e74-2b39-4130-908d-3283d0063a6d" />

## Documentation

For detailed technical specifications and implementation details, please refer to:

- [Creating a GUI-based macOS&iOS ARM64 Debugger.pdf](doc/Creating%20a%20GUI-based%20macOS&iOS%20ARM64%20Debugger.pdf)

## Credits

For a full list of dependencies, see [CREDITS.md](CREDITS.md).

### Special Thanks

- [MachOKit](https://github.com/p-x9/MachOKit) by [p-x9](https://github.com/p-x9) - MIT License
- [Cetus](https://github.com/Qwokka/Cetus) by [Qwokka](https://github.com/Qwokka) - Apache License 2.0

```

`benchmark/shooting_game/Makefile`:

```
# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║           Stellar Defender - TUI Shooting Game Makefile                   ║
# ╚═══════════════════════════════════════════════════════════════════════════╝

CXX := g++
CXXFLAGS := -std=c++17 -Wall -Wextra
LDFLAGS := -pthread -lncurses

# Debug build (default) - for DynaDbg testing
DEBUG_FLAGS := -g3 -O0

# Release build
RELEASE_FLAGS := -O2 -DNDEBUG

TARGET := shooting_game
SRC := shooting_game.cpp

.PHONY: all clean debug release run help

# Default target: debug build
all: debug

# Debug build (recommended for DynaDbg)
debug: CXXFLAGS += $(DEBUG_FLAGS)
debug: $(TARGET)
	@echo ""
	@echo "╔═══════════════════════════════════════════════════════════════╗"
	@echo "║  Debug build complete: $(TARGET)                              ║"
	@echo "║  Run with: ./$(TARGET) or make run                            ║"
	@echo "╚═══════════════════════════════════════════════════════════════╝"

# Release build
release: CXXFLAGS += $(RELEASE_FLAGS)
release: $(TARGET)
	@echo ""
	@echo "╔═══════════════════════════════════════════════════════════════╗"
	@echo "║  Release build complete: $(TARGET)                            ║"
	@echo "╚═══════════════════════════════════════════════════════════════╝"

# Link
$(TARGET): $(SRC)
	@echo "Compiling $(SRC)..."
	$(CXX) $(CXXFLAGS) -o $@ $< $(LDFLAGS)

# Run the game
run: $(TARGET)
	./$(TARGET)

# Clean build artifacts
clean:
	rm -f $(TARGET)
	@echo "Cleaned."

# Help
help:
	@echo "Stellar Defender - Build Targets:"
	@echo ""
	@echo "  make          - Build debug version (default)"
	@echo "  make debug    - Build with debug symbols (-g3 -O0)"
	@echo "  make release  - Build optimized release version"
	@echo "  make run      - Build and run the game"
	@echo "  make clean    - Remove built files"
	@echo "  make help     - Show this help"
	@echo ""
	@echo "Prerequisites:"
	@echo "  - g++ with C++17 support"
	@echo "  - ncurses library (libncurses-dev)"
	@echo "  - pthread support"

```

`benchmark/shooting_game/README.md`:

```md
# Stellar Defender - DynaDbg Benchmark

A terminal-based shooting game designed as a benchmark application for testing DynaDbg debugging features.

![Game Screenshot](../../assets/image/shooting_game.png)

## Benchmark Purpose

This game is designed to verify the following debugging capabilities:

### 1. Multi-threaded clock_gettime calls (Hardware Breakpoint / Single Step)

- **Threads**: 4 threads
- **Behavior**: Each thread calls `clock_gettime(CLOCK_MONOTONIC, &ts)` at high frequency
- **Testing targets**: 
  - Hardware Breakpoint behavior in multi-threaded environment
  - Thread interference during Single Step execution

### 2. Multi-threaded memory access patterns (Hardware Watchpoint)

- **Threads**: 3 threads
- **Behavior**: High-frequency reads of `g_player_hp`, `g_score`, `g_combo_count`
- **Testing targets**:
  - Memory access detection from multiple threads via Hardware Watchpoint

## Global Variables (For Debugging)

| Variable | Type | Description |
|----------|------|-------------|
| `g_score` | `volatile int32_t` | Current score |
| `g_player_hp` | `volatile int32_t` | Player HP |
| `g_max_hp` | `volatile int32_t` | Maximum HP |
| `g_level` | `volatile int32_t` | Current level |
| `g_enemies_killed` | `volatile int32_t` | Number of enemies killed |
| `g_combo_count` | `volatile int32_t` | Combo count |

## Build

### Using GitHub Actions (Recommended)

1. Fork the repository on GitHub:
   - Go to https://github.com/DoranekoSystems/DynaDbg
   - Click **Fork** button

2. Go to **Actions** tab on your forked repository

3. Select **Build Benchmarks** workflow

4. Click **Run workflow** and configure options:
   - `linux_x86_64`: Build for Linux x86_64
   - `android_arm64`: Build for Android arm64
   - `shooting_game`: Build shooting_game benchmark

5. Download artifacts from the workflow run

### Local Build (Linux)

```bash
make
```

Or build manually:

```bash
g++ -g -O0 -std=c++17 -pthread -lncurses -o shooting_game shooting_game.cpp
```

## Controls

| Key | Action |
|-----|--------|
| `W` / `↑` | Move up |
| `S` / `↓` | Move down |
| `Space` | Fire |
| `P` | Pause/Resume |
| `M` | Show memory info |
| `Q` | Quit |

## Dependencies

- ncurses
- pthread
- C++17 compatible compiler

```

`benchmark/shooting_game/shooting_game.cpp`:

```cpp
/**
 * ╔═══════════════════════════════════════════════════════════════════════════╗
 * ║           STELLAR DEFENDER - Terminal Shooting Game                       ║
 * ║                  A DynaDbg Benchmark Application                         ║
 * ╚═══════════════════════════════════════════════════════════════════════════╝
 *
 * This game is designed for memory debugging and analysis testing.
 * Features:
 *   - Multi-threaded clock_gettime calls for timing analysis
 *   - Multi-threaded memory access patterns for HP/Score
 *   - Pause/Resume functionality via commands
 *   - Memory address display for debugging tools
 *
 * Build: g++ -g -O0 -std=c++17 -pthread -lncurses -o shooting_game shooting_game.cpp
 */

#include <ncurses.h>
#include <string>
#include <vector>
#include <thread>
#include <mutex>
#include <atomic>
#include <chrono>
#include <random>
#include <cmath>
#include <cstring>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <unistd.h>
#include <time.h>

// ============================================================================
// GLOBAL GAME STATE (Exposed for memory debugging)
// ============================================================================

// Primary game variables - these addresses are displayed for debugging
volatile int32_t g_score = 0;
volatile int32_t g_player_hp = 100;
volatile int32_t g_max_hp = 100;
volatile int32_t g_level = 1;
volatile int32_t g_enemies_killed = 0;
volatile int32_t g_bullets_fired = 0;
volatile int32_t g_combo_count = 0;
volatile int32_t g_high_score = 0;
volatile int64_t g_play_time_ms = 0;

// Game control flags
std::atomic<bool> g_game_running{true};
std::atomic<bool> g_game_paused{false};
std::atomic<bool> g_game_over{false};
std::atomic<bool> g_show_title{true};

// Thread synchronization
std::mutex g_state_mutex;
std::mutex g_render_mutex;

// ============================================================================
// COLOR DEFINITIONS
// ============================================================================

enum Colors
{
    COLOR_PAIR_DEFAULT = 1,
    COLOR_PAIR_PLAYER,
    COLOR_PAIR_PLAYER_SHIELD,
    COLOR_PAIR_BULLET,
    COLOR_PAIR_ENEMY_WEAK,
    COLOR_PAIR_ENEMY_NORMAL,
    COLOR_PAIR_ENEMY_STRONG,
    COLOR_PAIR_ENEMY_BOSS,
    COLOR_PAIR_EXPLOSION,
    COLOR_PAIR_POWERUP,
    COLOR_PAIR_UI_NORMAL,
    COLOR_PAIR_UI_WARNING,
    COLOR_PAIR_UI_DANGER,
    COLOR_PAIR_UI_HIGHLIGHT,
    COLOR_PAIR_TITLE,
    COLOR_PAIR_STAR_DIM,
    COLOR_PAIR_STAR_BRIGHT,
    COLOR_PAIR_DEBUG_INFO,
};

// ============================================================================
// GAME ENTITY STRUCTURES
// ============================================================================

struct Vec2
{
    float x, y;
    Vec2(float x = 0, float y = 0) : x(x), y(y) {}
};

struct Bullet
{
    Vec2 pos;
    Vec2 velocity;
    bool active = false;
    int damage = 10;
    char symbol = '-';
    int color = COLOR_PAIR_BULLET;
};

struct Enemy
{
    Vec2 pos;
    Vec2 velocity;
    bool active = false;
    int hp = 10;
    int max_hp = 10;
    int score_value = 100;
    int type = 0; // 0=weak, 1=normal, 2=strong, 3=boss
    std::string sprite;
    int color = COLOR_PAIR_ENEMY_NORMAL;
    int fire_cooldown = 0;
    float amplitude = 0; // For wave movement
    float phase = 0;
    float base_y = 0;
};

struct EnemyBullet
{
    Vec2 pos;
    Vec2 velocity;
    bool active = false;
    int damage = 5;
    char symbol = '*';
};

struct Explosion
{
    Vec2 pos;
    int frame = 0;
    int max_frames = 8;
    bool active = false;
};

struct Powerup
{
    Vec2 pos;
    Vec2 velocity;
    bool active = false;
    int type = 0; // 0=heal, 1=shield, 2=weapon
    char symbol = '+';
};

struct Star
{
    Vec2 pos;
    float speed;
    char symbol;
    int brightness; // 0=dim, 1=bright
};

struct Player
{
    Vec2 pos;
    int width = 5;
    int height = 3;
    int fire_cooldown = 0;
    int shield = 0;
    int weapon_level = 1;
    bool invincible = false;
    int invincible_timer = 0;

    // Player ship sprite (multi-line)
    const char *sprite[3] = {
        "  /=>",
        "<=###",
        "  \\=>"};
};

// ============================================================================
// GAME CLASS
// ============================================================================

class StellarDefender
{
private:
    Player player;
    std::vector<Bullet> bullets;
    std::vector<Enemy> enemies;
    std::vector<EnemyBullet> enemy_bullets;
    std::vector<Explosion> explosions;
    std::vector<Powerup> powerups;
    std::vector<Star> stars;

    int screen_width = 80;
    int screen_height = 24;
    int game_area_width = 60;
    int game_area_height = 20;
    int ui_panel_x = 62;

    std::mt19937 rng;
    int frame_count = 0;
    int enemy_spawn_timer = 0;
    int difficulty_timer = 0;

    // Double buffering to prevent flicker
    WINDOW *game_win = nullptr;
    WINDOW *ui_win = nullptr;

    // Timing threads
    std::vector<std::thread> clock_threads;
    std::vector<std::thread> memory_threads;
    std::atomic<int64_t> clock_call_count{0};
    std::atomic<int64_t> memory_read_count{0};

public:
    StellarDefender() : rng(std::random_device{}())
    {
        bullets.resize(50);
        enemies.resize(30);
        enemy_bullets.resize(100);
        explosions.resize(20);
        powerups.resize(10);
    }

    ~StellarDefender()
    {
        stopThreads();
        if (game_win)
            delwin(game_win);
        if (ui_win)
            delwin(ui_win);
    }

    void init()
    {
        // Initialize ncurses
        initscr();
        cbreak();
        noecho();
        keypad(stdscr, TRUE);
        nodelay(stdscr, TRUE);
        curs_set(0);

        // Get screen size
        getmaxyx(stdscr, screen_height, screen_width);
        game_area_width = std::min(60, screen_width - 22);
        game_area_height = std::min(20, screen_height - 4);
        ui_panel_x = game_area_width + 2;

        // Initialize colors
        if (has_colors())
        {
            start_color();
            use_default_colors();

            init_pair(COLOR_PAIR_DEFAULT, COLOR_WHITE, -1);
            init_pair(COLOR_PAIR_PLAYER, COLOR_CYAN, -1);
            init_pair(COLOR_PAIR_PLAYER_SHIELD, COLOR_BLUE, -1);
            init_pair(COLOR_PAIR_BULLET, COLOR_YELLOW, -1);
            init_pair(COLOR_PAIR_ENEMY_WEAK, COLOR_GREEN, -1);
            init_pair(COLOR_PAIR_ENEMY_NORMAL, COLOR_YELLOW, -1);
            init_pair(COLOR_PAIR_ENEMY_STRONG, COLOR_RED, -1);
            init_pair(COLOR_PAIR_ENEMY_BOSS, COLOR_MAGENTA, -1);
            init_pair(COLOR_PAIR_EXPLOSION, COLOR_RED, -1);
            init_pair(COLOR_PAIR_POWERUP, COLOR_GREEN, -1);
            init_pair(COLOR_PAIR_UI_NORMAL, COLOR_WHITE, -1);
            init_pair(COLOR_PAIR_UI_WARNING, COLOR_YELLOW, -1);
            init_pair(COLOR_PAIR_UI_DANGER, COLOR_RED, -1);
            init_pair(COLOR_PAIR_UI_HIGHLIGHT, COLOR_CYAN, -1);
            init_pair(COLOR_PAIR_TITLE, COLOR_CYAN, -1);
            init_pair(COLOR_PAIR_STAR_DIM, COLOR_BLUE, -1);
            init_pair(COLOR_PAIR_STAR_BRIGHT, COLOR_WHITE, -1);
            init_pair(COLOR_PAIR_DEBUG_INFO, COLOR_MAGENTA, -1);
        }

        // Create windows (for double buffering effect)
        game_win = newwin(game_area_height + 2, game_area_width + 2, 1, 0);
        ui_win = newwin(game_area_height + 2, 20, 1, ui_panel_x);

        // Initialize stars
        initStars();

        // Start benchmark threads
        startThreads();
    }

    void initStars()
    {
        stars.clear();
        for (int i = 0; i < 50; i++)
        {
            Star star;
            star.pos.x = rng() % game_area_width;
            star.pos.y = rng() % game_area_height;
            star.speed = 0.5f + (rng() % 100) / 100.0f;
            star.symbol = (rng() % 3 == 0) ? '*' : '.';
            star.brightness = (star.symbol == '*') ? 1 : 0;
            stars.push_back(star);
        }
    }

    void startThreads()
    {
        // Start clock_gettime threads (4 threads)
        for (int i = 0; i < 4; i++)
        {
            clock_threads.emplace_back([this, i]()
                                       {
                struct timespec ts;
                while (g_game_running.load()) {
                    if (!g_game_paused.load()) {
                        // Call clock_gettime frequently
                        for (int j = 0; j < 100; j++) {
                            clock_gettime(CLOCK_MONOTONIC, &ts);
                            clock_call_count++;
                        }
                    }
                    std::this_thread::sleep_for(std::chrono::microseconds(500));
                } });
        }

        // Start memory access threads (3 threads)
        for (int i = 0; i < 3; i++)
        {
            memory_threads.emplace_back([this, i]()
                                        {
                volatile int32_t local_hp, local_score, local_combo;
                while (g_game_running.load()) {
                    if (!g_game_paused.load()) {
                        // Read game state frequently
                        for (int j = 0; j < 50; j++) {
                            local_hp = g_player_hp;
                            local_score = g_score;
                            local_combo = g_combo_count;
                            memory_read_count++;
                            
                            // Small delay to prevent tight spin
                            std::this_thread::yield();
                        }
                    }
                    std::this_thread::sleep_for(std::chrono::microseconds(200));
                } });
        }
    }

    void stopThreads()
    {
        g_game_running.store(false);

        for (auto &t : clock_threads)
        {
            if (t.joinable())
                t.join();
        }
        for (auto &t : memory_threads)
        {
            if (t.joinable())
                t.join();
        }
    }

    void resetGame()
    {
        std::lock_guard<std::mutex> lock(g_state_mutex);

        // Reset player
        player.pos = Vec2(5, game_area_height / 2);
        player.shield = 0;
        player.weapon_level = 1;
        player.invincible = false;
        player.invincible_timer = 0;

        // Reset game state
        if (g_score > g_high_score)
        {
            g_high_score = g_score;
        }
        g_score = 0;
        g_player_hp = 100;
        g_max_hp = 100;
        g_level = 1;
        g_enemies_killed = 0;
        g_bullets_fired = 0;
        g_combo_count = 0;
        g_play_time_ms = 0;

        g_game_over.store(false);
        g_game_paused.store(false);

        // Clear entities
        for (auto &b : bullets)
            b.active = false;
        for (auto &e : enemies)
            e.active = false;
        for (auto &eb : enemy_bullets)
            eb.active = false;
        for (auto &ex : explosions)
            ex.active = false;
        for (auto &p : powerups)
            p.active = false;

        frame_count = 0;
        enemy_spawn_timer = 0;
        difficulty_timer = 0;
    }

    void showTitleScreen()
    {
        clear();

        int center_x = screen_width / 2;
        int y = 3;

        // Simple ASCII title
        attron(COLOR_PAIR(COLOR_PAIR_TITLE) | A_BOLD);
        mvprintw(y++, center_x - 20, "========================================");
        mvprintw(y++, center_x - 20, "        STELLAR DEFENDER v2.0           ");
        mvprintw(y++, center_x - 20, "    -- Horizontal Scrolling Shooter --  ");
        mvprintw(y++, center_x - 20, "========================================");
        attroff(COLOR_PAIR(COLOR_PAIR_TITLE) | A_BOLD);

        y += 2;

        // Menu
        attron(COLOR_PAIR(COLOR_PAIR_UI_NORMAL) | A_BOLD);
        mvprintw(y++, center_x - 12, "+----------------------+");
        mvprintw(y++, center_x - 12, "|   [ENTER] START      |");
        mvprintw(y++, center_x - 12, "|   [M] MEMORY INFO    |");
        mvprintw(y++, center_x - 12, "|   [Q] QUIT           |");
        mvprintw(y++, center_x - 12, "+----------------------+");
        attroff(COLOR_PAIR(COLOR_PAIR_UI_NORMAL) | A_BOLD);

        y += 2;

        // Controls
        attron(COLOR_PAIR(COLOR_PAIR_UI_WARNING));
        mvprintw(y++, center_x - 20, "CONTROLS: [W/S] Move  [SPACE] Fire  [P] Pause");
        attroff(COLOR_PAIR(COLOR_PAIR_UI_WARNING));

        y += 2;

        // Debug addresses
        attron(COLOR_PAIR(COLOR_PAIR_DEBUG_INFO));
        mvprintw(y++, center_x - 22, "--- DEBUG MEMORY ADDRESSES ---");
        mvprintw(y++, center_x - 22, "g_score:     %p = %d", (void *)&g_score, (int)g_score);
        mvprintw(y++, center_x - 22, "g_player_hp: %p = %d", (void *)&g_player_hp, (int)g_player_hp);
        attroff(COLOR_PAIR(COLOR_PAIR_DEBUG_INFO));

        // High score
        if (g_high_score > 0)
        {
            attron(COLOR_PAIR(COLOR_PAIR_UI_HIGHLIGHT) | A_BOLD);
            mvprintw(screen_height - 2, center_x - 10, "HIGH SCORE: %d", (int)g_high_score);
            attroff(COLOR_PAIR(COLOR_PAIR_UI_HIGHLIGHT) | A_BOLD);
        }

        refresh();
    }

    void showMemoryInfo()
    {
        clear();

        int y = 2;
        int x = 5;

        attron(COLOR_PAIR(COLOR_PAIR_TITLE) | A_BOLD);
        mvprintw(y++, x, "+------------------------------------------------------------------+");
        mvprintw(y++, x, "|              MEMORY DEBUGGING INFORMATION                        |");
        mvprintw(y++, x, "+------------------------------------------------------------------+");
        attroff(COLOR_PAIR(COLOR_PAIR_TITLE) | A_BOLD);

        y += 2;

        attron(COLOR_PAIR(COLOR_PAIR_DEBUG_INFO));
        mvprintw(y++, x, "Global variables exposed for debugging:");
        y++;

        mvprintw(y++, x, "+---------------------+--------------------+-----------------+");
        mvprintw(y++, x, "| Variable            | Address            | Current Value   |");
        mvprintw(y++, x, "+---------------------+--------------------+-----------------+");
        mvprintw(y++, x, "| g_score             | %18p | %15d |", (void *)&g_score, (int)g_score);
        mvprintw(y++, x, "| g_player_hp         | %18p | %15d |", (void *)&g_player_hp, (int)g_player_hp);
        mvprintw(y++, x, "| g_max_hp            | %18p | %15d |", (void *)&g_max_hp, (int)g_max_hp);
        mvprintw(y++, x, "| g_level             | %18p | %15d |", (void *)&g_level, (int)g_level);
        mvprintw(y++, x, "| g_enemies_killed    | %18p | %15d |", (void *)&g_enemies_killed, (int)g_enemies_killed);
        mvprintw(y++, x, "| g_bullets_fired     | %18p | %15d |", (void *)&g_bullets_fired, (int)g_bullets_fired);
        mvprintw(y++, x, "| g_combo_count       | %18p | %15d |", (void *)&g_combo_count, (int)g_combo_count);
        mvprintw(y++, x, "| g_high_score        | %18p | %15d |", (void *)&g_high_score, (int)g_high_score);
        mvprintw(y++, x, "| g_play_time_ms      | %18p | %15ld |", (void *)&g_play_time_ms, (long)g_play_time_ms);
        mvprintw(y++, x, "+---------------------+--------------------+-----------------+");

        y += 2;

        mvprintw(y++, x, "Benchmark Thread Status:");
        mvprintw(y++, x, "  - Clock threads: 4 (calling clock_gettime at high frequency)");
        mvprintw(y++, x, "  - Memory threads: 3 (reading HP/Score at high frequency)");
        mvprintw(y++, x, "  - Clock calls: %ld", clock_call_count.load());
        mvprintw(y++, x, "  - Memory reads: %ld", memory_read_count.load());

        attroff(COLOR_PAIR(COLOR_PAIR_DEBUG_INFO));

        y += 2;
        attron(COLOR_PAIR(COLOR_PAIR_UI_WARNING));
        mvprintw(y, x, "Press any key to return...");
        attroff(COLOR_PAIR(COLOR_PAIR_UI_WARNING));

        refresh();

        nodelay(stdscr, FALSE);
        getch();
        nodelay(stdscr, TRUE);
    }

    void spawnEnemy()
    {
        for (auto &e : enemies)
        {
            if (!e.active)
            {
                e.active = true;
                e.pos.x = game_area_width - 1;
                e.pos.y = 1 + (rng() % (game_area_height - 2));
                e.base_y = e.pos.y;

                // Determine enemy type based on level and random
                int type_roll = rng() % 100;
                int level = g_level;

                if (type_roll < 10 && level >= 5)
                {
                    // Boss (10% chance, level 5+)
                    e.type = 3;
                    e.hp = 100 + level * 20;
                    e.max_hp = e.hp;
                    e.score_value = 1000;
                    e.velocity = Vec2(-0.3f, 0);
                    e.sprite = "<[XXX]>";
                    e.color = COLOR_PAIR_ENEMY_BOSS;
                    e.amplitude = 3.0f;
                }
                else if (type_roll < 30 && level >= 3)
                {
                    // Strong (20% chance, level 3+)
                    e.type = 2;
                    e.hp = 30 + level * 5;
                    e.max_hp = e.hp;
                    e.score_value = 300;
                    e.velocity = Vec2(-0.6f, 0);
                    e.sprite = "<##>";
                    e.color = COLOR_PAIR_ENEMY_STRONG;
                    e.amplitude = 2.0f;
                }
                else if (type_roll < 60)
                {
                    // Normal (30% chance)
                    e.type = 1;
                    e.hp = 15 + level * 2;
                    e.max_hp = e.hp;
                    e.score_value = 150;
                    e.velocity = Vec2(-0.8f, 0);
                    e.sprite = "<#>";
                    e.color = COLOR_PAIR_ENEMY_NORMAL;
                    e.amplitude = 1.5f;
                }
                else
                {
                    // Weak (40% chance)
                    e.type = 0;
                    e.hp = 5 + level;
                    e.max_hp = e.hp;
                    e.score_value = 50;
                    e.velocity = Vec2(-1.0f, 0);
                    e.sprite = "<>";
                    e.color = COLOR_PAIR_ENEMY_WEAK;
                    e.amplitude = 1.0f;
                }

                e.phase = (rng() % 628) / 100.0f; // Random phase 0-2π
                e.fire_cooldown = 30 + rng() % 60;

                break;
            }
        }
    }

    void fireBullet()
    {
        for (auto &b : bullets)
        {
            if (!b.active)
            {
                b.active = true;
                b.pos = Vec2(player.pos.x + 5, player.pos.y + 1);
                b.velocity = Vec2(2.0f, 0);
                b.damage = 10 + player.weapon_level * 5;
                b.symbol = (player.weapon_level >= 3) ? '=' : '-';
                g_bullets_fired++;
                break;
            }
        }

        // Additional bullets for higher weapon levels
        if (player.weapon_level >= 2)
        {
            for (auto &b : bullets)
            {
                if (!b.active)
                {
                    b.active = true;
                    b.pos = Vec2(player.pos.x + 4, player.pos.y);
                    b.velocity = Vec2(2.0f, -0.3f);
                    b.damage = 8;
                    break;
                }
            }
            for (auto &b : bullets)
            {
                if (!b.active)
                {
                    b.active = true;
                    b.pos = Vec2(player.pos.x + 4, player.pos.y + 2);
                    b.velocity = Vec2(2.0f, 0.3f);
                    b.damage = 8;
                    break;
                }
            }
        }
    }

    void fireEnemyBullet(Enemy &enemy)
    {
        for (auto &eb : enemy_bullets)
        {
            if (!eb.active)
            {
                eb.active = true;
                eb.pos = Vec2(enemy.pos.x - 1, enemy.pos.y);
                eb.velocity = Vec2(-1.5f, 0);
                eb.damage = 5 + g_level;
                eb.symbol = (enemy.type >= 2) ? 'o' : '*';
                break;
            }
        }
    }

    void spawnExplosion(float x, float y)
    {
        for (auto &ex : explosions)
        {
            if (!ex.active)
            {
                ex.active = true;
                ex.pos = Vec2(x, y);
                ex.frame = 0;
                break;
            }
        }
    }

    void spawnPowerup(float x, float y)
    {
        if (rng() % 100 < 15)
        { // 15% chance
            for (auto &p : powerups)
            {
                if (!p.active)
                {
                    p.active = true;
                    p.pos = Vec2(x, y);
                    p.velocity = Vec2(-0.5f, 0);
                    p.type = rng() % 3;
                    switch (p.type)
                    {
                    case 0:
                        p.symbol = '+';
                        break; // Heal
                    case 1:
                        p.symbol = 'S';
                        break; // Shield
                    case 2:
                        p.symbol = 'W';
                        break; // Weapon
                    }
                    break;
                }
            }
        }
    }

    void update()
    {
        if (g_game_paused.load() || g_game_over.load())
            return;

        std::lock_guard<std::mutex> lock(g_state_mutex);

        frame_count++;
        g_play_time_ms += 33; // Approximately 30 FPS

        // Update difficulty
        difficulty_timer++;
        if (difficulty_timer >= 600)
        { // Every ~20 seconds
            difficulty_timer = 0;
            g_level++;
        }

        // Spawn enemies
        enemy_spawn_timer++;
        int spawn_rate = std::max(30, 90 - g_level * 5);
        if (enemy_spawn_timer >= spawn_rate)
        {
            enemy_spawn_timer = 0;
            spawnEnemy();
        }

        // Update player
        if (player.fire_cooldown > 0)
            player.fire_cooldown--;
        if (player.invincible)
        {
            player.invincible_timer--;
            if (player.invincible_timer <= 0)
            {
                player.invincible = false;
            }
        }

        // Update stars (parallax background)
        for (auto &star : stars)
        {
            star.pos.x -= star.speed;
            if (star.pos.x < 0)
            {
                star.pos.x = game_area_width - 1;
                star.pos.y = rng() % game_area_height;
            }
        }

        // Update bullets
        for (auto &b : bullets)
        {
            if (b.active)
            {
                b.pos.x += b.velocity.x;
                b.pos.y += b.velocity.y;

                if (b.pos.x >= game_area_width || b.pos.x < 0 ||
                    b.pos.y < 0 || b.pos.y >= game_area_height)
                {
                    b.active = false;
                }
            }
        }

        // Update enemies
        for (auto &e : enemies)
        {
            if (e.active)
            {
                e.pos.x += e.velocity.x;
                e.phase += 0.1f;
                e.pos.y = e.base_y + std::sin(e.phase) * e.amplitude;

                // Clamp to bounds
                e.pos.y = std::max(1.0f, std::min<float>((float)(game_area_height - 2), e.pos.y));

                // Fire bullets
                e.fire_cooldown--;
                if (e.fire_cooldown <= 0 && e.type >= 1)
                {
                    e.fire_cooldown = 60 + rng() % 60 - g_level * 2;
                    fireEnemyBullet(e);
                }

                // Off-screen
                if (e.pos.x < -5)
                {
                    e.active = false;
                    g_combo_count = 0; // Reset combo
                }
            }
        }

        // Update enemy bullets
        for (auto &eb : enemy_bullets)
        {
            if (eb.active)
            {
                eb.pos.x += eb.velocity.x;
                eb.pos.y += eb.velocity.y;

                if (eb.pos.x < 0 || eb.pos.x >= game_area_width ||
                    eb.pos.y < 0 || eb.pos.y >= game_area_height)
                {
                    eb.active = false;
                }
            }
        }

        // Update explosions
        for (auto &ex : explosions)
        {
            if (ex.active)
            {
                ex.frame++;
                if (ex.frame >= ex.max_frames)
                {
                    ex.active = false;
                }
            }
        }

        // Update powerups
        for (auto &p : powerups)
        {
            if (p.active)
            {
                p.pos.x += p.velocity.x;
                if (p.pos.x < 0)
                {
                    p.active = false;
                }
            }
        }

        // Check collisions
        checkCollisions();

        // Check game over
        if (g_player_hp <= 0)
        {
            g_game_over.store(true);
            if (g_score > g_high_score)
            {
                g_high_score = g_score;
            }
        }
    }

    void checkCollisions()
    {
        // Bullets vs Enemies
        for (auto &b : bullets)
        {
            if (!b.active)
                continue;

            for (auto &e : enemies)
            {
                if (!e.active)
                    continue;

                // Simple box collision
                if (b.pos.x >= e.pos.x - 1 && b.pos.x <= e.pos.x + (int)e.sprite.length() &&
                    b.pos.y >= e.pos.y - 0.5f && b.pos.y <= e.pos.y + 0.5f)
                {

                    b.active = false;
                    e.hp -= b.damage;

                    if (e.hp <= 0)
                    {
                        e.active = false;
                        g_enemies_killed++;
                        g_combo_count++;

                        // Score with combo multiplier
                        int combo_mult = std::min<int32_t>(10, (int)g_combo_count);
                        g_score += e.score_value * combo_mult;

                        spawnExplosion(e.pos.x, e.pos.y);
                        spawnPowerup(e.pos.x, e.pos.y);
                    }

                    break;
                }
            }
        }

        // Enemy bullets vs Player
        if (!player.invincible)
        {
            for (auto &eb : enemy_bullets)
            {
                if (!eb.active)
                    continue;

                if (eb.pos.x >= player.pos.x && eb.pos.x <= player.pos.x + 5 &&
                    eb.pos.y >= player.pos.y && eb.pos.y <= player.pos.y + 3)
                {

                    eb.active = false;

                    if (player.shield > 0)
                    {
                        player.shield -= eb.damage;
                        if (player.shield < 0)
                            player.shield = 0;
                    }
                    else
                    {
                        g_player_hp -= eb.damage;
                        player.invincible = true;
                        player.invincible_timer = 30;
                        g_combo_count = 0;
                    }
                }
            }
        }

        // Enemies vs Player (collision damage)
        if (!player.invincible)
        {
            for (auto &e : enemies)
            {
                if (!e.active)
                    continue;

                if (e.pos.x >= player.pos.x - 1 && e.pos.x <= player.pos.x + 5 &&
                    e.pos.y >= player.pos.y - 1 && e.pos.y <= player.pos.y + 3)
                {

                    e.active = false;
                    g_player_hp -= 20;
                    player.invincible = true;
                    player.invincible_timer = 60;
                    g_combo_count = 0;
                    spawnExplosion(e.pos.x, e.pos.y);
                }
            }
        }

        // Powerups vs Player
        for (auto &p : powerups)
        {
            if (!p.active)
                continue;

            if (p.pos.x >= player.pos.x && p.pos.x <= player.pos.x + 5 &&
                p.pos.y >= player.pos.y && p.pos.y <= player.pos.y + 3)
            {

                p.active = false;

                switch (p.type)
                {
                case 0: // Heal
                    g_player_hp = std::min((int)g_max_hp, g_player_hp + 30);
                    break;
                case 1: // Shield
                    player.shield = std::min(50, player.shield + 25);
                    break;
                case 2: // Weapon
                    player.weapon_level = std::min(3, player.weapon_level + 1);
                    break;
                }
            }
        }
    }

    void handleInput()
    {
        int ch = getch();
        if (ch == ERR)
            return;

        if (g_show_title.load())
        {
            switch (ch)
            {
            case '\n':
            case '\r':
            case KEY_ENTER:
                g_show_title.store(false);
                resetGame();
                break;
            case 'm':
            case 'M':
                showMemoryInfo();
                break;
            case 'q':
            case 'Q':
                g_game_running.store(false);
                break;
            }
            return;
        }

        if (g_game_over.load())
        {
            switch (ch)
            {
            case 'r':
            case 'R':
                resetGame();
                break;
            case 'q':
            case 'Q':
            case '\n':
            case '\r':
                g_show_title.store(true);
                break;
            }
            return;
        }

        switch (ch)
        {
        case 'w':
        case 'W':
        case KEY_UP:
            if (!g_game_paused.load())
            {
                std::lock_guard<std::mutex> lock(g_state_mutex);
                player.pos.y = std::max(0.0f, player.pos.y - 1);
            }
            break;

        case 's':
        case 'S':
        case KEY_DOWN:
            if (!g_game_paused.load())
            {
                std::lock_guard<std::mutex> lock(g_state_mutex);
                player.pos.y = std::min((float)(game_area_height - 3), player.pos.y + 1);
            }
            break;

        case ' ':
            if (!g_game_paused.load() && player.fire_cooldown <= 0)
            {
                std::lock_guard<std::mutex> lock(g_state_mutex);
                fireBullet();
                player.fire_cooldown = 5;
            }
            break;

        case 'p':
        case 'P':
            g_game_paused.store(!g_game_paused.load());
            break;

        case 'r':
        case 'R':
            resetGame();
            break;

        case 'q':
        case 'Q':
            g_show_title.store(true);
            break;

        case 'm':
        case 'M':
            showMemoryInfo();
            break;
        }
    }

    void render()
    {
        std::lock_guard<std::mutex> lock(g_render_mutex);

        // Clear windows
        werase(game_win);
        werase(ui_win);

        // Draw game area border
        wattron(game_win, COLOR_PAIR(COLOR_PAIR_UI_NORMAL));
        box(game_win, 0, 0);
        wattroff(game_win, COLOR_PAIR(COLOR_PAIR_UI_NORMAL));

        // Draw stars (background)
        for (const auto &star : stars)
        {
            int x = (int)star.pos.x + 1;
            int y = (int)star.pos.y + 1;
            if (x > 0 && x < game_area_width + 1 && y > 0 && y < game_area_height + 1)
            {
                wattron(game_win, COLOR_PAIR(star.brightness ? COLOR_PAIR_STAR_BRIGHT : COLOR_PAIR_STAR_DIM));
                mvwaddch(game_win, y, x, star.symbol);
                wattroff(game_win, COLOR_PAIR(star.brightness ? COLOR_PAIR_STAR_BRIGHT : COLOR_PAIR_STAR_DIM));
            }
        }

        // Draw explosions
        for (const auto &ex : explosions)
        {
            if (ex.active)
            {
                int x = (int)ex.pos.x + 1;
                int y = (int)ex.pos.y + 1;
                if (x > 0 && x < game_area_width + 1 && y > 0 && y < game_area_height + 1)
                {
                    wattron(game_win, COLOR_PAIR(COLOR_PAIR_EXPLOSION) | A_BOLD);
                    const char *frames[] = {"*", "+", "X", "#", "*", ".", " ", " "};
                    mvwaddch(game_win, y, x, frames[ex.frame][0]);
                    wattroff(game_win, COLOR_PAIR(COLOR_PAIR_EXPLOSION) | A_BOLD);
                }
            }
        }

        // Draw powerups
        for (const auto &p : powerups)
        {
            if (p.active)
            {
                int x = (int)p.pos.x + 1;
                int y = (int)p.pos.y + 1;
                if (x > 0 && x < game_area_width + 1 && y > 0 && y < game_area_height + 1)
                {
                    wattron(game_win, COLOR_PAIR(COLOR_PAIR_POWERUP) | A_BOLD | A_BLINK);
                    mvwaddch(game_win, y, x, p.symbol);
                    wattroff(game_win, COLOR_PAIR(COLOR_PAIR_POWERUP) | A_BOLD | A_BLINK);
                }
            }
        }

        // Draw bullets
        for (const auto &b : bullets)
        {
            if (b.active)
            {
                int x = (int)b.pos.x + 1;
                int y = (int)b.pos.y + 1;
                if (x > 0 && x < game_area_width + 1 && y > 0 && y < game_area_height + 1)
                {
                    wattron(game_win, COLOR_PAIR(COLOR_PAIR_BULLET) | A_BOLD);
                    mvwaddch(game_win, y, x, b.symbol);
                    wattroff(game_win, COLOR_PAIR(COLOR_PAIR_BULLET) | A_BOLD);
                }
            }
        }

        // Draw enemy bullets
        for (const auto &eb : enemy_bullets)
        {
            if (eb.active)
            {
                int x = (int)eb.pos.x + 1;
                int y = (int)eb.pos.y + 1;
                if (x > 0 && x < game_area_width + 1 && y > 0 && y < game_area_height + 1)
                {
                    wattron(game_win, COLOR_PAIR(COLOR_PAIR_ENEMY_STRONG));
                    mvwaddch(game_win, y, x, eb.symbol);
                    wattroff(game_win, COLOR_PAIR(COLOR_PAIR_ENEMY_STRONG));
                }
            }
        }

        // Draw enemies
        for (const auto &e : enemies)
        {
            if (e.active)
            {
                int x = (int)e.pos.x + 1;
                int y = (int)e.pos.y + 1;
                if (y > 0 && y < game_area_height + 1)
                {
                    wattron(game_win, COLOR_PAIR(e.color) | A_BOLD);
                    for (size_t i = 0; i < e.sprite.length(); i++)
                    {
                        int sx = x - (int)i;
                        if (sx > 0 && sx < game_area_width + 1)
                        {
                            mvwaddch(game_win, y, sx, e.sprite[e.sprite.length() - 1 - i]);
                        }
                    }
                    wattroff(game_win, COLOR_PAIR(e.color) | A_BOLD);

                    // Draw HP bar for strong enemies
                    if (e.type >= 2 && e.hp < e.max_hp)
                    {
                        int bar_x = x - (int)e.sprite.length() / 2;
                        if (bar_x > 0 && bar_x < game_area_width - 2 && y > 1)
                        {
                            float hp_ratio = (float)e.hp / e.max_hp;
                            wattron(game_win, COLOR_PAIR(hp_ratio > 0.5 ? COLOR_PAIR_ENEMY_WEAK : COLOR_PAIR_ENEMY_STRONG));
                            mvwaddch(game_win, y - 1, bar_x, '[');
                            int filled = (int)(hp_ratio * 4);
                            for (int i = 0; i < 4; i++)
                            {
                                mvwaddch(game_win, y - 1, bar_x + 1 + i, i < filled ? '=' : ' ');
                            }
                            mvwaddch(game_win, y - 1, bar_x + 5, ']');
                            wattroff(game_win, COLOR_PAIR(hp_ratio > 0.5 ? COLOR_PAIR_ENEMY_WEAK : COLOR_PAIR_ENEMY_STRONG));
                        }
                    }
                }
            }
        }

        // Draw player
        int px = (int)player.pos.x + 1;
        int py = (int)player.pos.y + 1;

        // Blinking effect when invincible
        bool draw_player = !player.invincible || (frame_count % 4 < 2);

        if (draw_player)
        {
            int player_color = player.shield > 0 ? COLOR_PAIR_PLAYER_SHIELD : COLOR_PAIR_PLAYER;
            wattron(game_win, COLOR_PAIR(player_color) | A_BOLD);

            for (int i = 0; i < 3; i++)
            {
                if (py + i > 0 && py + i < game_area_height + 1)
                {
                    for (int j = 0; j < 5; j++)
                    {
                        if (px + j > 0 && px + j < game_area_width + 1)
                        {
                            char c = player.sprite[i][j];
                            if (c != ' ')
                            {
                                mvwaddch(game_win, py + i, px + j, c);
                            }
                        }
                    }
                }
            }

            wattroff(game_win, COLOR_PAIR(player_color) | A_BOLD);
        }

        // Draw UI panel
        wattron(ui_win, COLOR_PAIR(COLOR_PAIR_UI_NORMAL));
        box(ui_win, 0, 0);
        mvwprintw(ui_win, 0, 2, " STATUS ");
        wattroff(ui_win, COLOR_PAIR(COLOR_PAIR_UI_NORMAL));

        int ui_y = 2;

        // Score
        wattron(ui_win, COLOR_PAIR(COLOR_PAIR_UI_HIGHLIGHT) | A_BOLD);
        mvwprintw(ui_win, ui_y++, 2, "SCORE");
        wattroff(ui_win, COLOR_PAIR(COLOR_PAIR_UI_HIGHLIGHT) | A_BOLD);
        wattron(ui_win, COLOR_PAIR(COLOR_PAIR_UI_NORMAL));
        mvwprintw(ui_win, ui_y++, 2, "%10d", (int)g_score);
        wattroff(ui_win, COLOR_PAIR(COLOR_PAIR_UI_NORMAL));

        ui_y++;

        // HP with color based on value
        wattron(ui_win, COLOR_PAIR(COLOR_PAIR_UI_HIGHLIGHT) | A_BOLD);
        mvwprintw(ui_win, ui_y++, 2, "HP");
        wattroff(ui_win, COLOR_PAIR(COLOR_PAIR_UI_HIGHLIGHT) | A_BOLD);

        float hp_ratio = (float)g_player_hp / g_max_hp;
        int hp_color = hp_ratio > 0.6 ? COLOR_PAIR_UI_NORMAL : (hp_ratio > 0.3 ? COLOR_PAIR_UI_WARNING : COLOR_PAIR_UI_DANGER);

        wattron(ui_win, COLOR_PAIR(hp_color) | A_BOLD);
        mvwprintw(ui_win, ui_y++, 2, "%3d / %3d", (int)g_player_hp, (int)g_max_hp);

        // HP Bar
        mvwaddch(ui_win, ui_y, 2, '[');
        int hp_bar_len = 12;
        int hp_filled = (int)(hp_ratio * hp_bar_len);
        for (int i = 0; i < hp_bar_len; i++)
        {
            mvwaddch(ui_win, ui_y, 3 + i, i < hp_filled ? '=' : ' ');
        }
        mvwaddch(ui_win, ui_y++, 3 + hp_bar_len, ']');
        wattroff(ui_win, COLOR_PAIR(hp_color) | A_BOLD);

        ui_y++;

        // Shield
        if (player.shield > 0)
        {
            wattron(ui_win, COLOR_PAIR(COLOR_PAIR_PLAYER_SHIELD) | A_BOLD);
            mvwprintw(ui_win, ui_y++, 2, "SHIELD: %d", player.shield);
            wattroff(ui_win, COLOR_PAIR(COLOR_PAIR_PLAYER_SHIELD) | A_BOLD);
            ui_y++;
        }

        // Level
        wattron(ui_win, COLOR_PAIR(COLOR_PAIR_UI_NORMAL));
        mvwprintw(ui_win, ui_y++, 2, "LEVEL: %d", (int)g_level);

        // Combo
        if (g_combo_count > 1)
        {
            wattron(ui_win, COLOR_PAIR(COLOR_PAIR_UI_WARNING) | A_BOLD);
            mvwprintw(ui_win, ui_y++, 2, "COMBO x%d", (int)g_combo_count);
            wattroff(ui_win, COLOR_PAIR(COLOR_PAIR_UI_WARNING) | A_BOLD);
        }
        else
        {
            ui_y++;
        }

        // Kills
        mvwprintw(ui_win, ui_y++, 2, "KILLS: %d", (int)g_enemies_killed);

        // Weapon level
        mvwprintw(ui_win, ui_y++, 2, "WEAPON: Lv%d", player.weapon_level);
        wattroff(ui_win, COLOR_PAIR(COLOR_PAIR_UI_NORMAL));

        ui_y++;

        // Memory addresses (debug info)
        wattron(ui_win, COLOR_PAIR(COLOR_PAIR_DEBUG_INFO));
        mvwprintw(ui_win, ui_y++, 1, "-- DEBUG --");
        mvwprintw(ui_win, ui_y++, 1, "Score:");
        mvwprintw(ui_win, ui_y++, 1, "%p", (void *)&g_score);
        mvwprintw(ui_win, ui_y++, 1, "HP:");
        mvwprintw(ui_win, ui_y++, 1, "%p", (void *)&g_player_hp);
        wattroff(ui_win, COLOR_PAIR(COLOR_PAIR_DEBUG_INFO));

        // Paused overlay
        if (g_game_paused.load())
        {
            wattron(game_win, COLOR_PAIR(COLOR_PAIR_UI_WARNING) | A_BOLD | A_REVERSE);
            mvwprintw(game_win, game_area_height / 2, game_area_width / 2 - 5, "  PAUSED  ");
            mvwprintw(game_win, game_area_height / 2 + 1, game_area_width / 2 - 8, " [P] to Resume ");
            wattroff(game_win, COLOR_PAIR(COLOR_PAIR_UI_WARNING) | A_BOLD | A_REVERSE);
        }

        // Game over overlay
        if (g_game_over.load())
        {
            wattron(game_win, COLOR_PAIR(COLOR_PAIR_UI_DANGER) | A_BOLD | A_REVERSE);
            mvwprintw(game_win, game_area_height / 2 - 1, game_area_width / 2 - 6, "  GAME OVER  ");
            mvwprintw(game_win, game_area_height / 2, game_area_width / 2 - 10, " Final Score: %6d ", (int)g_score);
            mvwprintw(game_win, game_area_height / 2 + 1, game_area_width / 2 - 8, " [R]estart [Q]uit ");
            wattroff(game_win, COLOR_PAIR(COLOR_PAIR_UI_DANGER) | A_BOLD | A_REVERSE);
        }

        // Refresh windows (double-buffered)
        wnoutrefresh(game_win);
        wnoutrefresh(ui_win);
        doupdate();
    }

    void run()
    {
        init();

        auto last_time = std::chrono::steady_clock::now();
        const auto frame_duration = std::chrono::milliseconds(33); // ~30 FPS

        while (g_game_running.load())
        {
            handleInput();

            if (g_show_title.load())
            {
                showTitleScreen();
                std::this_thread::sleep_for(std::chrono::milliseconds(50));
                continue;
            }

            update();
            render();

            // Frame timing
            auto current_time = std::chrono::steady_clock::now();
            auto elapsed = current_time - last_time;
            if (elapsed < frame_duration)
            {
                std::this_thread::sleep_for(frame_duration - elapsed);
            }
            last_time = std::chrono::steady_clock::now();
        }

        // Cleanup
        stopThreads();
        endwin();
    }
};

// ============================================================================
// MAIN
// ============================================================================

int main()
{
    // Print memory addresses before starting ncurses
    printf("\n");
    printf("+-------------------------------------------------------------------+\n");
    printf("|               STELLAR DEFENDER - Debug Information                |\n");
    printf("+-------------------------------------------------------------------+\n");
    printf("|  Variable           | Memory Address       | Initial Value       |\n");
    printf("+-------------------------------------------------------------------+\n");
    printf("|  g_score            | %-20p | %-19d |\n", (void *)&g_score, (int)g_score);
    printf("|  g_player_hp        | %-20p | %-19d |\n", (void *)&g_player_hp, (int)g_player_hp);
    printf("|  g_max_hp           | %-20p | %-19d |\n", (void *)&g_max_hp, (int)g_max_hp);
    printf("|  g_level            | %-20p | %-19d |\n", (void *)&g_level, (int)g_level);
    printf("|  g_enemies_killed   | %-20p | %-19d |\n", (void *)&g_enemies_killed, (int)g_enemies_killed);
    printf("|  g_bullets_fired    | %-20p | %-19d |\n", (void *)&g_bullets_fired, (int)g_bullets_fired);
    printf("|  g_combo_count      | %-20p | %-19d |\n", (void *)&g_combo_count, (int)g_combo_count);
    printf("|  g_high_score       | %-20p | %-19d |\n", (void *)&g_high_score, (int)g_high_score);
    printf("|  g_play_time_ms     | %-20p | %-19ld |\n", (void *)&g_play_time_ms, (long)g_play_time_ms);
    printf("+-------------------------------------------------------------------+\n");
    printf("\n");
    printf("Starting game... Press ENTER to continue.\n");
    getchar();

    StellarDefender game;
    game.run();

    return 0;
}

```

`frameworks/wasm/chrome-extension/background.js`:

```js
// ============================================================================
// DynaDbg WASM Bridge - Background Service Worker (Manifest V3)
// ============================================================================

let ws = null;
let wsConnected = false;
let debugServerUrl = "ws://localhost:8765";
let activeTabId = null;
let reconnectTimer = null;
let keepAliveInterval = null;
let intentionalDisconnect = false; // Flag to prevent auto-reconnect on user disconnect
let autoReconnectEnabled = false; // Only reconnect if explicitly enabled

// State storage (in-memory, will be synced with chrome.storage)
let wasmState = {
  binaryBuffer: null,
  symbols: [],
  exports: [],
  heapSize: 0,
  codeSize: 0,
  hasBinary: false,
  memoryBuffer: null
};

// ============================================================================
// State Persistence (chrome.storage for MV3 service worker survival)
// ============================================================================

async function saveState() {
  try {
    await chrome.storage.session.set({
      wasmState: {
        // Don't store large binary in storage, just metadata
        symbols: wasmState.symbols,
        exports: wasmState.exports,
        heapSize: wasmState.heapSize,
        codeSize: wasmState.codeSize,
        hasBinary: wasmState.hasBinary
      },
      wsConnected: wsConnected,
      debugServerUrl: debugServerUrl,
      activeTabId: activeTabId
    });
  } catch (e) {
    console.error("[DynaDbg] Failed to save state:", e);
  }
}

async function loadState() {
  try {
    const result = await chrome.storage.session.get(['wasmState', 'wsConnected', 'debugServerUrl', 'activeTabId']);
    if (result.wasmState) {
      wasmState.symbols = result.wasmState.symbols || [];
      wasmState.exports = result.wasmState.exports || [];
      wasmState.heapSize = result.wasmState.heapSize || 0;
      wasmState.codeSize = result.wasmState.codeSize || 0;
      wasmState.hasBinary = result.wasmState.hasBinary || false;
    }
    if (result.debugServerUrl) {
      debugServerUrl = result.debugServerUrl;
    }
    if (result.activeTabId) {
      activeTabId = result.activeTabId;
    }
    // Do NOT auto-reconnect on service worker startup
    // User must explicitly click Connect button
    console.log("[DynaDbg] State loaded (no auto-connect)");
  } catch (e) {
    console.error("[DynaDbg] Failed to load state:", e);
  }
}

// Load state on service worker startup
loadState();

// ============================================================================
// WebSocket Connection Management
// ============================================================================

function startKeepAlive() {
  // Keep service worker alive while connected
  if (keepAliveInterval) {
    clearInterval(keepAliveInterval);
  }
  keepAliveInterval = setInterval(() => {
    if (wsConnected && ws && ws.readyState === WebSocket.OPEN) {
      // Send ping to keep connection alive
      console.log("[DynaDbg] Keep-alive ping");
    }
  }, 20000); // Every 20 seconds
}

function stopKeepAlive() {
  if (keepAliveInterval) {
    clearInterval(keepAliveInterval);
    keepAliveInterval = null;
  }
}

function connectToServer(url) {
  if (ws && ws.readyState === WebSocket.OPEN) {
    console.log("[DynaDbg] Already connected");
    return;
  }

  // Reset disconnect flag when connecting
  intentionalDisconnect = false;
  autoReconnectEnabled = true;

  // Close existing connection if any
  if (ws) {
    try {
      ws.close();
    } catch (e) {}
    ws = null;
  }

  debugServerUrl = url || debugServerUrl;
  console.log("[DynaDbg] Connecting to " + debugServerUrl);

  try {
    ws = new WebSocket(debugServerUrl);

    ws.onopen = function() {
      wsConnected = true;
      console.log("[DynaDbg] Connected to debug server");
      saveState();
      broadcastStatus({ connected: true });
      startKeepAlive();
      
      // Clear reconnect timer
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
      
      // Send init signature if we have WASM data
      if (wasmState.hasBinary) {
        sendInitSignature();
      }
    };

    ws.onclose = function(event) {
      wsConnected = false;
      ws = null;
      console.log("[DynaDbg] Disconnected from debug server, code:", event.code, "intentional:", intentionalDisconnect);
      saveState();
      broadcastStatus({ connected: false });
      stopKeepAlive();
      
      // Only auto-reconnect if not intentional disconnect and auto-reconnect is enabled
      if (!intentionalDisconnect && autoReconnectEnabled && event.code !== 1000) {
        scheduleReconnect();
      }
    };

    ws.onerror = function(err) {
      console.error("[DynaDbg] WebSocket error:", err);
      wsConnected = false;
      saveState();
    };

    ws.onmessage = function(event) {
      handleServerMessage(event);
    };

  } catch (e) {
    console.error("[DynaDbg] Failed to connect:", e);
    scheduleReconnect();
  }
}

function scheduleReconnect() {
  if (reconnectTimer) {
    clearTimeout(reconnectTimer);
  }
  reconnectTimer = setTimeout(() => {
    reconnectTimer = null;
    if (!wsConnected) {
      console.log("[DynaDbg] Attempting reconnect...");
      connectToServer(debugServerUrl);
    }
  }, 3000);
}

function disconnectFromServer() {
  console.log("[DynaDbg] Disconnecting from server (user initiated)");
  intentionalDisconnect = true;
  autoReconnectEnabled = false;
  stopKeepAlive();
  if (reconnectTimer) {
    clearTimeout(reconnectTimer);
    reconnectTimer = null;
  }
  if (ws) {
    try {
      ws.close(1000, "User disconnect"); // Code 1000 = normal closure
    } catch (e) {
      console.error("[DynaDbg] Error closing WebSocket:", e);
    }
    ws = null;
  }
  wsConnected = false;
  saveState();
  broadcastStatus({ connected: false });
}

// ============================================================================
// Server Message Handling
// ============================================================================

async function handleServerMessage(event) {
  try {
    const data = JSON.parse(event.data);
    console.log("[DynaDbg] Received command:", data.command);

    switch (data.command) {
      case "get_heap_size":
        handleGetHeapSize(data);
        break;

      case "read_memory":
        await handleReadMemory(data);
        break;

      case "write_memory":
        await handleWriteMemory(data);
        break;

      case "get_code_size":
        handleGetCodeSize(data);
        break;

      case "read_code":
        handleReadCode(data);
        break;

      case "dump_code":
        handleDumpCode(data);
        break;

      case "get_symbols":
        handleGetSymbols(data);
        break;

      case "take_snapshot":
        await handleTakeSnapshot(data);
        break;

      case "read_snapshot":
        handleReadSnapshot(data);
        break;

      default:
        console.warn("[DynaDbg] Unknown command:", data.command);
        ws.send(JSON.stringify({ id: data.id, message: false, error: "Unknown command" }));
    }
  } catch (e) {
    console.error("[DynaDbg] Error handling message:", e);
  }
}

function handleGetHeapSize(data) {
  ws.send(JSON.stringify({
    id: data.id,
    message: wasmState.heapSize
  }));
}

async function handleReadMemory(data) {
  const addr = data.address || 0;
  const size = data.size || 256;

  // Request memory from content script
  const response = await sendToContentScript({
    type: "DYNADBG_READ_MEMORY",
    address: addr,
    size: size
  });

  if (response && response.success) {
    const buffer = new Uint8Array(response.data);
    ws.send(buffer.buffer);
  } else {
    ws.send(JSON.stringify({ id: data.id, message: false, error: response?.error || "Read failed" }));
  }
}

async function handleWriteMemory(data) {
  const addr = data.address || 0;
  const hexBytes = data.bytes || "";
  
  // Convert hex string to byte array
  const bytes = [];
  for (let i = 0; i < hexBytes.length; i += 2) {
    bytes.push(parseInt(hexBytes.substr(i, 2), 16));
  }

  const response = await sendToContentScript({
    type: "DYNADBG_WRITE_MEMORY",
    address: addr,
    data: bytes
  });

  ws.send(JSON.stringify({
    id: data.id,
    message: response?.success || false
  }));
}

function handleGetCodeSize(data) {
  ws.send(JSON.stringify({
    id: data.id,
    message: wasmState.codeSize
  }));
}

function handleReadCode(data) {
  if (!wasmState.binaryBuffer) {
    ws.send(JSON.stringify({ id: data.id, message: false, error: "WASM binary not captured" }));
    return;
  }

  const bufferLength = wasmState.binaryBuffer.byteLength;
  const addr = data.address || 0;
  const size = data.size || bufferLength;
  
  console.log("[DynaDbg] read_code: addr=", addr, "size=", size, "bufferLength=", bufferLength);
  
  if (addr + size <= bufferLength) {
    const view = new Uint8Array(wasmState.binaryBuffer, addr, size);
    ws.send(view);
  } else {
    ws.send(JSON.stringify({ id: data.id, message: false, error: `Out of bounds: addr=${addr} size=${size} bufLen=${bufferLength}` }));
  }
}

function handleDumpCode(data) {
  if (!wasmState.binaryBuffer) {
    ws.send(JSON.stringify({ id: data.id, message: false, error: "WASM binary not captured" }));
    return;
  }

  console.log("[DynaDbg] Sending WASM binary dump:", wasmState.binaryBuffer.byteLength, "bytes");
  const view = new Uint8Array(wasmState.binaryBuffer);
  ws.send(view);
}

function handleGetSymbols(data) {
  ws.send(JSON.stringify({
    id: data.id,
    symbols: wasmState.symbols,
    exports: wasmState.exports
  }));
}

async function handleTakeSnapshot(data) {
  const response = await sendToContentScript({
    type: "DYNADBG_TAKE_SNAPSHOT"
  });

  if (response && response.success) {
    wasmState.memoryBuffer = new Uint8Array(response.data);
    ws.send(JSON.stringify({
      id: data.id,
      message: true,
      size: wasmState.memoryBuffer.length
    }));
  } else {
    ws.send(JSON.stringify({ id: data.id, message: false }));
  }
}

function handleReadSnapshot(data) {
  if (!wasmState.memoryBuffer) {
    ws.send(JSON.stringify({ id: data.id, message: false, error: "No snapshot" }));
    return;
  }

  const offset = data.address || 0;
  const size = data.size || wasmState.memoryBuffer.length;

  if (offset + size <= wasmState.memoryBuffer.length) {
    const sliced = wasmState.memoryBuffer.slice(offset, offset + size);
    ws.send(sliced.buffer);
  } else {
    ws.send(JSON.stringify({ id: data.id, message: false }));
  }
}

// ============================================================================
// Init Signature (Cetus-style)
// ============================================================================

function sendInitSignature() {
  if (!ws || ws.readyState !== WebSocket.OPEN) return;

  // Generate signature from first 256 bytes of heap
  const signatureHex = wasmState.binaryBuffer 
    ? Array.from(new Uint8Array(wasmState.binaryBuffer.slice(0, 256)))
        .map(b => b.toString(16).padStart(2, '0')).join('')
    : "";

  const initMessage = {
    command: "init_signature",
    signature: signatureHex,
    heap_size: wasmState.heapSize,
    code_size: wasmState.codeSize,
    has_binary: wasmState.hasBinary,
    symbols: wasmState.symbols,
    module_name: "wasm_module",
    instrumented: true,
    watchpoint_count: 0
  };

  ws.send(JSON.stringify(initMessage));
  console.log("[DynaDbg] Sent init signature");
}

// ============================================================================
// Content Script Communication
// ============================================================================

function sendToContentScript(message) {
  return new Promise((resolve) => {
    if (!activeTabId) {
      resolve({ success: false, error: "No active tab" });
      return;
    }

    chrome.tabs.sendMessage(activeTabId, message, (response) => {
      if (chrome.runtime.lastError) {
        console.error("[DynaDbg] Content script error:", chrome.runtime.lastError);
        resolve({ success: false, error: chrome.runtime.lastError.message });
      } else {
        resolve(response);
      }
    });
  });
}

function broadcastStatus(status) {
  chrome.runtime.sendMessage({ type: "DYNADBG_STATUS", ...status }).catch(() => {});
}

// ============================================================================
// Message Listeners
// ============================================================================

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  console.log("[DynaDbg] Background received:", message.type);

  switch (message.type) {
    case "DYNADBG_WASM_INIT":
      // WASM instance captured from page
      wasmState.binaryBuffer = message.binary ? new Uint8Array(message.binary).buffer : null;
      wasmState.codeSize = message.codeSize || 0;
      wasmState.heapSize = message.heapSize || 0;
      wasmState.hasBinary = !!message.binary && message.binary.length > 0;
      wasmState.symbols = message.symbols || [];
      wasmState.exports = message.exports || [];
      activeTabId = sender.tab?.id;
      
      console.log("[DynaDbg] WASM captured - Code:", wasmState.codeSize, "Heap:", wasmState.heapSize, "hasBinary:", wasmState.hasBinary);
      
      // Save state to survive service worker restart
      saveState();
      
      if (wsConnected && ws && ws.readyState === WebSocket.OPEN) {
        sendInitSignature();
      }
      sendResponse({ success: true });
      break;

    case "DYNADBG_HEAP_UPDATE":
      wasmState.heapSize = message.heapSize;
      saveState();
      sendResponse({ success: true });
      break;

    case "DYNADBG_CONNECT":
      chrome.storage.local.set({ serverUrl: message.url, autoConnect: true });
      connectToServer(message.url);
      sendResponse({ success: true });
      break;

    case "DYNADBG_DISCONNECT":
      chrome.storage.local.set({ autoConnect: false });
      disconnectFromServer();
      sendResponse({ success: true });
      break;

    case "DYNADBG_GET_STATUS":
      // Check actual WebSocket state
      const isActuallyConnected = ws && ws.readyState === WebSocket.OPEN;
      sendResponse({
        connected: isActuallyConnected,
        hasBinary: wasmState.hasBinary,
        codeSize: wasmState.codeSize,
        heapSize: wasmState.heapSize,
        symbolCount: wasmState.symbols.length
      });
      break;

    case "DYNADBG_WEBGL_CONTEXT":
      // WebGL context created
      console.log("[DynaDbg] WebGL context captured:", message.contextType);
      activeTabId = sender.tab?.id;
      sendResponse({ success: true });
      break;

    default:
      sendResponse({ success: false, error: "Unknown message type" });
  }

  return true; // Keep channel open for async response
});

// ============================================================================
// Extension Lifecycle
// ============================================================================

chrome.runtime.onInstalled.addListener(() => {
  console.log("[DynaDbg] Extension installed");
  chrome.storage.local.set({ autoConnect: false, serverUrl: "ws://localhost:8765" });
});

chrome.runtime.onStartup.addListener(() => {
  console.log("[DynaDbg] Extension started");
  loadState();
});

// Tab activation tracking
chrome.tabs.onActivated.addListener((activeInfo) => {
  activeTabId = activeInfo.tabId;
  saveState();
});

// Keep service worker alive when connected
chrome.alarms.onAlarm.addListener((alarm) => {
  if (alarm.name === 'keepAlive') {
    console.log("[DynaDbg] Keep-alive alarm");
    // Check if we should reconnect
    chrome.storage.local.get(['autoConnect', 'serverUrl'], (result) => {
      if (result.autoConnect && (!ws || ws.readyState !== WebSocket.OPEN)) {
        connectToServer(result.serverUrl);
      }
    });
  }
});

// Set up keep-alive alarm
chrome.alarms.create('keepAlive', { periodInMinutes: 0.5 }); // Every 30 seconds

```

`frameworks/wasm/chrome-extension/content.js`:

```js
// ============================================================================
// DynaDbg WASM Bridge - Content Script (Manifest V3)
// Injects the hook script into page context
// ============================================================================

(function() {
  'use strict';

  // Inject the main hook script into the page context
  function injectScript() {
    const script = document.createElement('script');
    script.src = chrome.runtime.getURL('inject.js');
    script.onload = function() {
      this.remove();
    };
    (document.head || document.documentElement).appendChild(script);
  }

  // Inject as early as possible
  injectScript();

  // ============================================================================
  // Message Bridge: Page Context <-> Background Service Worker
  // ============================================================================

  // Listen for messages from injected script (page context)
  window.addEventListener('message', function(event) {
    if (event.source !== window) return;
    if (!event.data || !event.data.type) return;

    const data = event.data;

    switch (data.type) {
      case "DYNADBG_WASM_INIT":
        // Forward WASM init to background
        chrome.runtime.sendMessage({
          type: "DYNADBG_WASM_INIT",
          binary: data.binary,
          codeSize: data.codeSize,
          heapSize: data.heapSize,
          symbols: data.symbols,
          exports: data.exports
        });
        break;

      case "DYNADBG_HEAP_UPDATE":
        chrome.runtime.sendMessage({
          type: "DYNADBG_HEAP_UPDATE",
          heapSize: data.heapSize
        });
        break;

      case "DYNADBG_WEBGL_CONTEXT":
        chrome.runtime.sendMessage({
          type: "DYNADBG_WEBGL_CONTEXT",
          contextType: data.contextType
        });
        break;
    }
  });

  // ============================================================================
  // Handle requests from background service worker
  // ============================================================================

  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    switch (message.type) {
      case "DYNADBG_READ_MEMORY":
        // Forward to page context and wait for response
        const readId = 'read_' + Date.now() + '_' + Math.random();
        
        const readHandler = function(event) {
          if (event.data && event.data.type === "DYNADBG_READ_RESPONSE" && event.data.id === readId) {
            window.removeEventListener('message', readHandler);
            sendResponse(event.data);
          }
        };
        window.addEventListener('message', readHandler);
        
        window.postMessage({
          type: "DYNADBG_READ_MEMORY",
          id: readId,
          address: message.address,
          size: message.size
        }, '*');
        
        // Timeout after 5 seconds
        setTimeout(() => {
          window.removeEventListener('message', readHandler);
        }, 5000);
        
        return true; // Keep channel open
        
      case "DYNADBG_WRITE_MEMORY":
        const writeId = 'write_' + Date.now() + '_' + Math.random();
        
        const writeHandler = function(event) {
          if (event.data && event.data.type === "DYNADBG_WRITE_RESPONSE" && event.data.id === writeId) {
            window.removeEventListener('message', writeHandler);
            sendResponse(event.data);
          }
        };
        window.addEventListener('message', writeHandler);
        
        window.postMessage({
          type: "DYNADBG_WRITE_MEMORY",
          id: writeId,
          address: message.address,
          data: message.data
        }, '*');
        
        setTimeout(() => {
          window.removeEventListener('message', writeHandler);
        }, 5000);
        
        return true;

      case "DYNADBG_TAKE_SNAPSHOT":
        const snapId = 'snap_' + Date.now() + '_' + Math.random();
        
        const snapHandler = function(event) {
          if (event.data && event.data.type === "DYNADBG_SNAPSHOT_RESPONSE" && event.data.id === snapId) {
            window.removeEventListener('message', snapHandler);
            sendResponse(event.data);
          }
        };
        window.addEventListener('message', snapHandler);
        
        window.postMessage({
          type: "DYNADBG_TAKE_SNAPSHOT",
          id: snapId
        }, '*');
        
        setTimeout(() => {
          window.removeEventListener('message', snapHandler);
        }, 10000);
        
        return true;
    }
  });

  console.log("[DynaDbg] Content script loaded");
})();

```

`frameworks/wasm/chrome-extension/inject.js`:

```js
// ============================================================================
// DynaDbg WASM Bridge - Injected Script (Page Context)
// Hooks WebAssembly, WebGL, and other browser APIs
// ============================================================================

(function() {
  'use strict';

  // ============================================================================
  // State Storage
  // ============================================================================

  const dynaDbgState = {
    wasmBinaryBuffer: null,
    wasmMemory: null,
    wasmInstance: null,
    wasmExports: {},
    wasmSymbols: [],
    webglContexts: [],
    webgl2Contexts: []
  };

  // Make state accessible for debugging
  window.__dynaDbgState = dynaDbgState;

  // ============================================================================
  // Utility Functions
  // ============================================================================

  function extractSymbolsFromInstance(instance, binary) {
    const symbols = [];
    const exports = instance.exports;
    
    // Try to parse WASM binary to get function info (offset, size) and export mappings
    let parseResult = { functions: [], exportFuncIndices: {}, importFuncCount: 0 };
    if (binary) {
      try {
        parseResult = parseWasmBinary(binary);
      } catch (e) {
        console.warn("[DynaDbg] Failed to parse WASM binary:", e);
      }
    }
    
    const { functions, exportFuncIndices, importFuncCount } = parseResult;

    for (const name in exports) {
      const exp = exports[name];
      let type = "unknown";
      let address = 0;
      let size = 0;

      if (typeof exp === "function") {
        type = "function";
        
        // Get actual function index from export section
        const funcIndex = exportFuncIndices[name];
        if (funcIndex !== undefined) {
          // Code section only contains internal functions (not imports)
          const codeIndex = funcIndex - importFuncCount;
          if (codeIndex >= 0 && codeIndex < functions.length) {
            const funcInfo = functions[codeIndex];
            address = funcInfo.codeOffset;
            size = funcInfo.codeSize;
          }
        }
      } else if (exp instanceof WebAssembly.Memory) {
        type = "memory";
        dynaDbgState.wasmMemory = exp;
      } else if (exp instanceof WebAssembly.Table) {
        type = "table";
      } else if (exp instanceof WebAssembly.Global) {
        type = "global";
        try {
          address = exp.value;
        } catch (e) {}
      }

      symbols.push({
        name: name,
        type: type,
        address: address,
        size: size
      });

      dynaDbgState.wasmExports[name] = exp;
    }

    return symbols;
  }
  
  // Parse WASM binary to extract function info, imports, and exports
  function parseWasmBinary(binary) {
    const functions = []; // Code section function bodies
    const exportFuncIndices = {}; // name -> funcIndex
    let importFuncCount = 0;
    
    const bytes = new Uint8Array(binary);
    let offset = 0;
    
    // WASM magic number and version (8 bytes)
    if (bytes[0] !== 0x00 || bytes[1] !== 0x61 || bytes[2] !== 0x73 || bytes[3] !== 0x6D) {
      console.warn("[DynaDbg] Not a valid WASM binary");
      return { functions, exportFuncIndices, importFuncCount };
    }
    offset = 8;
    
    // Parse sections
    while (offset < bytes.length) {
      const sectionId = bytes[offset++];
      const [sectionSize, sizeLen] = readLEB128(bytes, offset);
      offset += sizeLen;
      const sectionEnd = offset + sectionSize;
      
      if (sectionId === 2) { // Import section
        const [numImports, numLen] = readLEB128(bytes, offset);
        let importOffset = offset + numLen;
        
        for (let i = 0; i < numImports; i++) {
          // Skip module name
          const [modLen, modLenSize] = readLEB128(bytes, importOffset);
          importOffset += modLenSize + modLen;
          
          // Skip field name
          const [fieldLen, fieldLenSize] = readLEB128(bytes, importOffset);
          importOffset += fieldLenSize + fieldLen;
          
          // Import kind
          const importKind = bytes[importOffset++];
          if (importKind === 0) { // Function import
            importFuncCount++;
            // Skip type index
            const [typeIdx, typeLen] = readLEB128(bytes, importOffset);
            importOffset += typeLen;
          } else if (importKind === 1) { // Table
            importOffset++; // elemtype
            const [limitsFlag] = readLEB128(bytes, importOffset);
            importOffset++;
            const [min, minLen] = readLEB128(bytes, importOffset);
            importOffset += minLen;
            if (limitsFlag === 1) {
              const [max, maxLen] = readLEB128(bytes, importOffset);
              importOffset += maxLen;
            }
          } else if (importKind === 2) { // Memory
            const [limitsFlag] = readLEB128(bytes, importOffset);
            importOffset++;
            const [min, minLen] = readLEB128(bytes, importOffset);
            importOffset += minLen;
            if (limitsFlag === 1) {
              const [max, maxLen] = readLEB128(bytes, importOffset);
              importOffset += maxLen;
            }
          } else if (importKind === 3) { // Global
            importOffset += 2; // type + mutability
          }
        }
        offset = sectionEnd;
        
      } else if (sectionId === 7) { // Export section
        const [numExports, numLen] = readLEB128(bytes, offset);
        let exportOffset = offset + numLen;
        
        for (let i = 0; i < numExports; i++) {
          // Read name
          const [nameLen, nameLenSize] = readLEB128(bytes, exportOffset);
          exportOffset += nameLenSize;
          const nameBytes = bytes.slice(exportOffset, exportOffset + nameLen);
          const name = new TextDecoder().decode(nameBytes);
          exportOffset += nameLen;
          
          // Export kind and index
          const exportKind = bytes[exportOffset++];
          const [exportIndex, indexLen] = readLEB128(bytes, exportOffset);
          exportOffset += indexLen;
          
          if (exportKind === 0) { // Function export
            exportFuncIndices[name] = exportIndex;
          }
        }
        offset = sectionEnd;
        
      } else if (sectionId === 10) { // Code section
        const [numFuncs, numLen] = readLEB128(bytes, offset);
        offset += numLen;
        
        for (let i = 0; i < numFuncs; i++) {
          const funcStart = offset;
          const [funcSize, funcSizeLen] = readLEB128(bytes, offset);
          const bodyStart = offset + funcSizeLen; // Start of local decls + code
          
          // Skip local variable declarations to find actual instruction start
          let localOffset = bodyStart;
          const [numLocalGroups, numLocalLen] = readLEB128(bytes, localOffset);
          localOffset += numLocalLen;
          
          // Skip each local group (count + type)
          for (let j = 0; j < numLocalGroups; j++) {
            const [localCount, countLen] = readLEB128(bytes, localOffset);
            localOffset += countLen;
            localOffset += 1; // Skip type byte
          }
          
          // localOffset now points to the first actual instruction
          const instructionOffset = localOffset;
          const instructionSize = funcSize - (instructionOffset - bodyStart);
          
          functions.push({
            offset: funcStart,
            size: funcSize + funcSizeLen,
            codeOffset: instructionOffset, // Points to first instruction
            codeSize: instructionSize,
            bodyOffset: bodyStart,
            bodySize: funcSize
          });
          
          offset += funcSizeLen + funcSize;
        }
        // Don't break here - continue parsing other sections
        offset = sectionEnd;
        
      } else {
        offset = sectionEnd;
      }
    }
    
    return { functions, exportFuncIndices, importFuncCount };
  }
  
  // Read unsigned LEB128 encoded integer
  function readLEB128(bytes, offset) {
    let result = 0;
    let shift = 0;
    let len = 0;
    let byte;
    
    do {
      byte = bytes[offset + len];
      result |= (byte & 0x7F) << shift;
      shift += 7;
      len++;
    } while (byte & 0x80);
    
    return [result, len];
  }

  function hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }

  function getHeapSize() {
    if (dynaDbgState.wasmMemory) {
      return dynaDbgState.wasmMemory.buffer.byteLength;
    }
    return 0;
  }

  function notifyWasmInit(binary, instance) {
    const symbols = extractSymbolsFromInstance(instance, binary);
    dynaDbgState.wasmSymbols = symbols;
    dynaDbgState.wasmInstance = instance;

    const heapSize = getHeapSize();
    const codeSize = binary ? binary.byteLength : 0;

    // Send to content script
    window.postMessage({
      type: "DYNADBG_WASM_INIT",
      binary: binary ? Array.from(new Uint8Array(binary)) : null,
      codeSize: codeSize,
      heapSize: heapSize,
      symbols: symbols,
      exports: Object.keys(dynaDbgState.wasmExports)
    }, '*');
  }

  // ============================================================================
  // WebAssembly Hooks
  // ============================================================================

  const originalInstantiate = WebAssembly.instantiate;
  const originalInstantiateStreaming = WebAssembly.instantiateStreaming;
  const originalCompile = WebAssembly.compile;
  const originalCompileStreaming = WebAssembly.compileStreaming;

  WebAssembly.instantiate = async function(bufferSource, importObject) {
    // Check if Memory is provided via importObject
    if (importObject) {
      for (const moduleName in importObject) {
        const module = importObject[moduleName];
        for (const name in module) {
          if (module[name] instanceof WebAssembly.Memory) {
            dynaDbgState.wasmMemory = module[name];
          }
        }
      }
    }

    let binary = null;

    if (bufferSource instanceof ArrayBuffer) {
      binary = bufferSource.slice(0);
      dynaDbgState.wasmBinaryBuffer = new Uint8Array(binary);
    } else if (bufferSource instanceof WebAssembly.Module) {
      // Module already compiled, no binary access
    } else if (ArrayBuffer.isView(bufferSource)) {
      binary = bufferSource.buffer.slice(
        bufferSource.byteOffset,
        bufferSource.byteOffset + bufferSource.byteLength
      );
      dynaDbgState.wasmBinaryBuffer = new Uint8Array(binary);
    }

    const result = await originalInstantiate.call(this, bufferSource, importObject);
    
    const instance = result.instance || result;
    notifyWasmInit(binary, instance);

    return result;
  };

  WebAssembly.instantiateStreaming = async function(source, importObject) {
    // Check if Memory is provided via importObject
    if (importObject) {
      for (const moduleName in importObject) {
        const module = importObject[moduleName];
        for (const name in module) {
          if (module[name] instanceof WebAssembly.Memory) {
            dynaDbgState.wasmMemory = module[name];
          }
        }
      }
    }

    try {
      // Clone the response to read the binary
      const response = await source;
      const clonedResponse = response.clone();
      const binary = await clonedResponse.arrayBuffer();
      
      dynaDbgState.wasmBinaryBuffer = new Uint8Array(binary.slice(0));

      const result = await originalInstantiateStreaming.call(this, source, importObject);
      
      notifyWasmInit(binary, result.instance);
      
      return result;
    } catch (e) {
      console.error("[DynaDbg] instantiateStreaming hook error:", e);
      return originalInstantiateStreaming.call(this, source, importObject);
    }
  };

  WebAssembly.compile = async function(bufferSource) {
    let binary = null;

    if (bufferSource instanceof ArrayBuffer) {
      binary = bufferSource.slice(0);
      dynaDbgState.wasmBinaryBuffer = new Uint8Array(binary);
    } else if (ArrayBuffer.isView(bufferSource)) {
      binary = bufferSource.buffer.slice(
        bufferSource.byteOffset,
        bufferSource.byteOffset + bufferSource.byteLength
      );
      dynaDbgState.wasmBinaryBuffer = new Uint8Array(binary);
    }

    return originalCompile.call(this, bufferSource);
  };

  WebAssembly.compileStreaming = async function(source) {
    try {
      const response = await source;
      const clonedResponse = response.clone();
      const binary = await clonedResponse.arrayBuffer();
      
      dynaDbgState.wasmBinaryBuffer = new Uint8Array(binary.slice(0));

      return originalCompileStreaming.call(this, source);
    } catch (e) {
      console.error("[DynaDbg] compileStreaming hook error:", e);
      return originalCompileStreaming.call(this, source);
    }
  };

  // ============================================================================
  // WebGL Hooks
  // ============================================================================

  const originalGetContext = HTMLCanvasElement.prototype.getContext;

  HTMLCanvasElement.prototype.getContext = function(contextType, contextAttributes) {
    const context = originalGetContext.call(this, contextType, contextAttributes);

    if (context) {
      if (contextType === 'webgl' || contextType === 'experimental-webgl') {
        dynaDbgState.webglContexts.push({
          canvas: this,
          context: context,
          type: 'webgl'
        });
        hookWebGLContext(context, 'webgl');
        
        window.postMessage({
          type: "DYNADBG_WEBGL_CONTEXT",
          contextType: 'webgl'
        }, '*');
      } else if (contextType === 'webgl2') {
        dynaDbgState.webgl2Contexts.push({
          canvas: this,
          context: context,
          type: 'webgl2'
        });
        hookWebGLContext(context, 'webgl2');
        
        window.postMessage({
          type: "DYNADBG_WEBGL_CONTEXT",
          contextType: 'webgl2'
        }, '*');
      }
    }

    return context;
  };

  function hookWebGLContext(gl, type) {
    // Hook shader compilation for debugging
    const originalShaderSource = gl.shaderSource;
    const originalCompileShader = gl.compileShader;
    const originalCreateProgram = gl.createProgram;
    const originalLinkProgram = gl.linkProgram;
    const originalDrawArrays = gl.drawArrays;
    const originalDrawElements = gl.drawElements;

    gl.shaderSource = function(shader, source) {
      shader.__dynaDbgSource = source;
      return originalShaderSource.call(this, shader, source);
    };

    gl.compileShader = function(shader) {
      const result = originalCompileShader.call(this, shader);
      if (!this.getShaderParameter(shader, this.COMPILE_STATUS)) {
        console.warn("[DynaDbg] Shader compilation failed:", this.getShaderInfoLog(shader));
      }
      return result;
    };

    gl.createProgram = function() {
      const program = originalCreateProgram.call(this);
      program.__dynaDbgId = 'prog_' + Date.now();
      return program;
    };

    gl.linkProgram = function(program) {
      const result = originalLinkProgram.call(this, program);
      if (!this.getProgramParameter(program, this.LINK_STATUS)) {
        console.warn("[DynaDbg] Program linking failed:", this.getProgramInfoLog(program));
      }
      return result;
    };

    // Track draw calls (optional, can be verbose)
    let drawCallCount = 0;
    gl.drawArrays = function(mode, first, count) {
      drawCallCount++;
      return originalDrawArrays.call(this, mode, first, count);
    };

    gl.drawElements = function(mode, count, type, offset) {
      drawCallCount++;
      return originalDrawElements.call(this, mode, count, type, offset);
    };

    // Expose draw call counter
    gl.__dynaDbgGetDrawCallCount = () => drawCallCount;
    gl.__dynaDbgResetDrawCallCount = () => { drawCallCount = 0; };
  }

  // ============================================================================
  // OffscreenCanvas Support (for Workers)
  // ============================================================================

  if (typeof OffscreenCanvas !== 'undefined') {
    const originalOffscreenGetContext = OffscreenCanvas.prototype.getContext;

    OffscreenCanvas.prototype.getContext = function(contextType, contextAttributes) {
      const context = originalOffscreenGetContext.call(this, contextType, contextAttributes);

      if (context && (contextType === 'webgl' || contextType === 'webgl2')) {
        hookWebGLContext(context, contextType);
      }

      return context;
    };
  }

  // ============================================================================
  // Memory Operations (called from content script)
  // ============================================================================

  window.addEventListener('message', function(event) {
    if (event.source !== window) return;
    if (!event.data || !event.data.type) return;

    const data = event.data;

    switch (data.type) {
      case "DYNADBG_READ_MEMORY":
        handleReadMemory(data);
        break;

      case "DYNADBG_WRITE_MEMORY":
        handleWriteMemory(data);
        break;

      case "DYNADBG_TAKE_SNAPSHOT":
        handleTakeSnapshot(data);
        break;
    }
  });

  function handleReadMemory(data) {
    try {
      if (!dynaDbgState.wasmMemory) {
        window.postMessage({
          type: "DYNADBG_READ_RESPONSE",
          id: data.id,
          success: false,
          error: "No WASM memory available"
        }, '*');
        return;
      }

      const buffer = dynaDbgState.wasmMemory.buffer;
      const addr = data.address || 0;
      const size = Math.min(data.size || 256, buffer.byteLength - addr);

      if (addr < 0 || addr >= buffer.byteLength) {
        window.postMessage({
          type: "DYNADBG_READ_RESPONSE",
          id: data.id,
          success: false,
          error: "Address out of bounds"
        }, '*');
        return;
      }

      const view = new Uint8Array(buffer, addr, size);
      const copy = Array.from(view);

      window.postMessage({
        type: "DYNADBG_READ_RESPONSE",
        id: data.id,
        success: true,
        data: copy
      }, '*');
    } catch (e) {
      window.postMessage({
        type: "DYNADBG_READ_RESPONSE",
        id: data.id,
        success: false,
        error: e.message
      }, '*');
    }
  }

  function handleWriteMemory(data) {
    try {
      if (!dynaDbgState.wasmMemory) {
        window.postMessage({
          type: "DYNADBG_WRITE_RESPONSE",
          id: data.id,
          success: false,
          error: "No WASM memory available"
        }, '*');
        return;
      }

      const buffer = dynaDbgState.wasmMemory.buffer;
      const addr = data.address || 0;
      const bytes = data.data || [];

      if (addr < 0 || addr + bytes.length > buffer.byteLength) {
        window.postMessage({
          type: "DYNADBG_WRITE_RESPONSE",
          id: data.id,
          success: false,
          error: "Address out of bounds"
        }, '*');
        return;
      }

      const view = new Uint8Array(buffer, addr, bytes.length);
      view.set(bytes);

      window.postMessage({
        type: "DYNADBG_WRITE_RESPONSE",
        id: data.id,
        success: true
      }, '*');
    } catch (e) {
      window.postMessage({
        type: "DYNADBG_WRITE_RESPONSE",
        id: data.id,
        success: false,
        error: e.message
      }, '*');
    }
  }

  function handleTakeSnapshot(data) {
    try {
      if (!dynaDbgState.wasmMemory) {
        window.postMessage({
          type: "DYNADBG_SNAPSHOT_RESPONSE",
          id: data.id,
          success: false,
          error: "No WASM memory available"
        }, '*');
        return;
      }

      const buffer = dynaDbgState.wasmMemory.buffer;
      const copy = Array.from(new Uint8Array(buffer));

      window.postMessage({
        type: "DYNADBG_SNAPSHOT_RESPONSE",
        id: data.id,
        success: true,
        data: copy
      }, '*');
    } catch (e) {
      window.postMessage({
        type: "DYNADBG_SNAPSHOT_RESPONSE",
        id: data.id,
        success: false,
        error: e.message
      }, '*');
    }
  }

  // ============================================================================
  // Memory Growth Detection
  // ============================================================================

  // Periodically check for memory growth
  let lastHeapSize = 0;
  setInterval(() => {
    const currentSize = getHeapSize();
    if (currentSize !== lastHeapSize && currentSize > 0) {
      lastHeapSize = currentSize;
      window.postMessage({
        type: "DYNADBG_HEAP_UPDATE",
        heapSize: currentSize
      }, '*');
    }
  }, 1000);

})();

```

`frameworks/wasm/chrome-extension/manifest.json`:

```json
{
  "manifest_version": 3,
  "name": "DynaDbg WASM Bridge",
  "version": "1.0.0",
  "description": "WebAssembly/WebGL debugging bridge for DynaDbg",
  "permissions": [
    "activeTab",
    "scripting",
    "storage",
    "alarms"
  ],
  "host_permissions": [
    "<all_urls>"
  ],
  "background": {
    "service_worker": "background.js",
    "type": "module"
  },
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["content.js"],
      "run_at": "document_start",
      "all_frames": true
    }
  ],
  "web_accessible_resources": [
    {
      "resources": ["inject.js"],
      "matches": ["<all_urls>"]
    }
  ],
  "action": {
    "default_popup": "popup.html",
    "default_icon": {
      "16": "icons/icon16.png",
      "48": "icons/icon48.png",
      "128": "icons/icon128.png"
    }
  },
  "icons": {
    "16": "icons/icon16.png",
    "48": "icons/icon48.png",
    "128": "icons/icon128.png"
  }
}

```

`frameworks/wasm/chrome-extension/popup.html`:

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>DynaDbg WASM Bridge</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      width: 320px;
      min-height: 200px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      padding: 16px;
    }

    h1 {
      font-size: 16px;
      margin-bottom: 12px;
      color: #00d4ff;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    h1::before {
      content: "⚡";
    }

    .section {
      background: #16213e;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 12px;
    }

    .section-title {
      font-size: 12px;
      color: #888;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .status-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 0;
      border-bottom: 1px solid #1a1a2e;
    }

    .status-row:last-child {
      border-bottom: none;
    }

    .status-label {
      font-size: 13px;
      color: #aaa;
    }

    .status-value {
      font-size: 13px;
      font-weight: 500;
    }

    .status-connected {
      color: #4ade80;
    }

    .status-disconnected {
      color: #f87171;
    }

    .status-number {
      color: #fbbf24;
      font-family: 'Monaco', 'Consolas', monospace;
    }

    .input-group {
      margin-bottom: 12px;
    }

    .input-group label {
      display: block;
      font-size: 12px;
      color: #888;
      margin-bottom: 4px;
    }

    .input-group input {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid #333;
      border-radius: 4px;
      background: #0f0f1a;
      color: #eee;
      font-size: 13px;
      font-family: 'Monaco', 'Consolas', monospace;
    }

    .input-group input:focus {
      outline: none;
      border-color: #00d4ff;
    }

    .btn-row {
      display: flex;
      gap: 8px;
    }

    button {
      flex: 1;
      padding: 10px 16px;
      border: none;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-connect {
      background: #00d4ff;
      color: #000;
    }

    .btn-connect:hover {
      background: #00b8e6;
    }

    .btn-connect:disabled {
      background: #333;
      color: #666;
      cursor: not-allowed;
    }

    .btn-disconnect {
      background: #333;
      color: #eee;
    }

    .btn-disconnect:hover {
      background: #444;
    }

    .indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 6px;
    }

    .indicator-on {
      background: #4ade80;
      box-shadow: 0 0 6px #4ade80;
    }

    .indicator-off {
      background: #666;
    }

    .footer {
      text-align: center;
      font-size: 11px;
      color: #555;
      margin-top: 8px;
    }
  </style>
</head>
<body>
  <h1>DynaDbg WASM Bridge</h1>

  <div class="section">
    <div class="section-title">Connection</div>
    <div class="input-group">
      <label for="serverUrl">Debug Server URL</label>
      <input type="text" id="serverUrl" value="ws://localhost:8765" />
    </div>
    <div class="btn-row">
      <button id="btnConnect" class="btn-connect">Connect</button>
      <button id="btnDisconnect" class="btn-disconnect">Disconnect</button>
    </div>
  </div>

  <div class="section">
    <div class="section-title">Status</div>
    <div class="status-row">
      <span class="status-label">Server</span>
      <span id="statusConnection" class="status-value status-disconnected">
        <span class="indicator indicator-off"></span>Disconnected
      </span>
    </div>
    <div class="status-row">
      <span class="status-label">WASM Binary</span>
      <span id="statusBinary" class="status-value status-disconnected">Not Captured</span>
    </div>
    <div class="status-row">
      <span class="status-label">Code Size</span>
      <span id="statusCodeSize" class="status-value status-number">0 bytes</span>
    </div>
    <div class="status-row">
      <span class="status-label">Heap Size</span>
      <span id="statusHeapSize" class="status-value status-number">0 bytes</span>
    </div>
    <div class="status-row">
      <span class="status-label">Symbols</span>
      <span id="statusSymbols" class="status-value status-number">0</span>
    </div>
  </div>

  <div class="footer">
    Refresh page to capture WASM on load
  </div>

  <script src="popup.js"></script>
</body>
</html>

```

`frameworks/wasm/chrome-extension/popup.js`:

```js
// ============================================================================
// DynaDbg WASM Bridge - Popup Script
// ============================================================================

document.addEventListener('DOMContentLoaded', function() {
  const serverUrlInput = document.getElementById('serverUrl');
  const btnConnect = document.getElementById('btnConnect');
  const btnDisconnect = document.getElementById('btnDisconnect');
  const statusConnection = document.getElementById('statusConnection');
  const statusBinary = document.getElementById('statusBinary');
  const statusCodeSize = document.getElementById('statusCodeSize');
  const statusHeapSize = document.getElementById('statusHeapSize');
  const statusSymbols = document.getElementById('statusSymbols');

  let lastStatus = null;

  // Load saved settings
  chrome.storage.local.get(['serverUrl'], (result) => {
    if (result.serverUrl) {
      serverUrlInput.value = result.serverUrl;
    }
  });

  // Update status display
  function updateStatus(status) {
    if (!status) return;
    
    // Only update if status actually changed (prevent flickering)
    const statusKey = JSON.stringify(status);
    if (lastStatus === statusKey) return;
    lastStatus = statusKey;

    if (status.connected) {
      statusConnection.innerHTML = '<span class="indicator indicator-on"></span>Connected';
      statusConnection.className = 'status-value status-connected';
      btnConnect.disabled = true;
      btnDisconnect.disabled = false;
    } else {
      statusConnection.innerHTML = '<span class="indicator indicator-off"></span>Disconnected';
      statusConnection.className = 'status-value status-disconnected';
      btnConnect.disabled = false;
      btnDisconnect.disabled = true;
    }

    if (status.hasBinary) {
      statusBinary.textContent = 'Captured';
      statusBinary.className = 'status-value status-connected';
    } else {
      statusBinary.textContent = 'Not Captured';
      statusBinary.className = 'status-value status-disconnected';
    }

    statusCodeSize.textContent = formatBytes(status.codeSize || 0);
    statusHeapSize.textContent = formatBytes(status.heapSize || 0);
    statusSymbols.textContent = (status.symbolCount || 0).toString();
  }

  function formatBytes(bytes) {
    if (bytes === 0) return '0 bytes';
    if (bytes < 1024) return bytes + ' bytes';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
  }

  // Get current status
  function refreshStatus() {
    chrome.runtime.sendMessage({ type: 'DYNADBG_GET_STATUS' }, (response) => {
      if (chrome.runtime.lastError) {
        console.log("[DynaDbg] Status check error:", chrome.runtime.lastError);
        return;
      }
      if (response) {
        updateStatus(response);
      }
    });
  }

  // Connect button
  btnConnect.addEventListener('click', () => {
    const url = serverUrlInput.value.trim();
    if (url) {
      btnConnect.disabled = true;
      btnConnect.textContent = 'Connecting...';
      chrome.storage.local.set({ serverUrl: url });
      chrome.runtime.sendMessage({ type: 'DYNADBG_CONNECT', url: url }, () => {
        setTimeout(() => {
          btnConnect.textContent = 'Connect';
          refreshStatus();
        }, 1000);
      });
    }
  });

  // Disconnect button
  btnDisconnect.addEventListener('click', () => {
    btnDisconnect.disabled = true;
    chrome.runtime.sendMessage({ type: 'DYNADBG_DISCONNECT' }, () => {
      setTimeout(() => {
        btnDisconnect.disabled = false;
        refreshStatus();
      }, 500);
    });
  });

  // Listen for status updates
  chrome.runtime.onMessage.addListener((message) => {
    if (message.type === 'DYNADBG_STATUS') {
      updateStatus(message);
    }
  });

  // Initial status refresh
  refreshStatus();

  // Periodic refresh
  setInterval(refreshStatus, 2000);
});

```

`scripts/check-licenses.sh`:

```sh
#!/bin/bash
# License check script for DynaDbg
# This script checks both Rust (cargo) and Node.js (npm) dependencies for license compliance

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo "=========================================="
echo "DynaDbg License Compliance Check"
echo "=========================================="
echo ""

# Track overall status
OVERALL_STATUS=0

# Check if cargo-deny is installed
check_cargo_deny() {
    if ! command -v cargo-deny &> /dev/null; then
        echo -e "${YELLOW}cargo-deny is not installed. Installing...${NC}"
        cargo install cargo-deny
    fi
}

# Check if license-checker is installed
check_license_checker() {
    if ! command -v license-checker &> /dev/null; then
        echo -e "${YELLOW}license-checker is not installed. Installing globally...${NC}"
        npm install -g license-checker
    fi
}

# Run cargo-deny for Rust dependencies
check_rust_licenses() {
    echo -e "${GREEN}[1/3] Checking Rust dependencies (Tauri backend)...${NC}"
    echo ""
    
    TAURI_DIR="$PROJECT_ROOT/src/client/src-tauri"
    
    if [ -f "$TAURI_DIR/Cargo.toml" ]; then
        cd "$TAURI_DIR"
        
        if [ -f "deny.toml" ]; then
            echo "Running cargo-deny check licenses..."
            if cargo deny check licenses 2>&1; then
                echo -e "${GREEN}✓ Rust license check passed${NC}"
            else
                echo -e "${RED}✗ Rust license check failed${NC}"
                OVERALL_STATUS=1
            fi
        else
            echo -e "${YELLOW}⚠ deny.toml not found in $TAURI_DIR${NC}"
        fi
        
        cd "$PROJECT_ROOT"
    else
        echo -e "${YELLOW}⚠ No Cargo.toml found in $TAURI_DIR${NC}"
    fi
    
    echo ""
}

# Run cargo-deny for server
check_server_licenses() {
    echo -e "${GREEN}[2/3] Checking Rust dependencies (Server)...${NC}"
    echo ""
    
    SERVER_DIR="$PROJECT_ROOT/src/server"
    
    if [ -f "$SERVER_DIR/Cargo.toml" ]; then
        cd "$SERVER_DIR"
        
        if [ -f "deny.toml" ]; then
            echo "Running cargo-deny check licenses..."
            if cargo deny check licenses 2>&1; then
                echo -e "${GREEN}✓ Server license check passed${NC}"
            else
                echo -e "${RED}✗ Server license check failed${NC}"
                OVERALL_STATUS=1
            fi
        else
            echo -e "${YELLOW}⚠ deny.toml not found in $SERVER_DIR (using default settings)${NC}"
            # Copy deny.toml from tauri if it exists
            if [ -f "$PROJECT_ROOT/src/client/src-tauri/deny.toml" ]; then
                cp "$PROJECT_ROOT/src/client/src-tauri/deny.toml" "$SERVER_DIR/deny.toml"
                echo "Copied deny.toml from tauri..."
                if cargo deny check licenses 2>&1; then
                    echo -e "${GREEN}✓ Server license check passed${NC}"
                else
                    echo -e "${RED}✗ Server license check failed${NC}"
                    OVERALL_STATUS=1
                fi
            fi
        fi
        
        cd "$PROJECT_ROOT"
    else
        echo -e "${YELLOW}⚠ No Cargo.toml found in $SERVER_DIR${NC}"
    fi
    
    echo ""
}

# Run license-checker for npm dependencies
check_npm_licenses() {
    echo -e "${GREEN}[3/3] Checking npm dependencies (Frontend)...${NC}"
    echo ""
    
    CLIENT_DIR="$PROJECT_ROOT/src/client"
    
    if [ -f "$CLIENT_DIR/package.json" ]; then
        cd "$CLIENT_DIR"
        
        # Ensure node_modules exists
        if [ ! -d "node_modules" ]; then
            echo "Installing npm dependencies first..."
            npm install
        fi
        
        echo "Running license-checker..."
        
        # Define allowed licenses (non-copyleft licenses only)
        # Note: Our project is GPL-3.0, but we only allow non-copyleft dependencies
        ALLOWED_LICENSES="MIT;Apache-2.0;BSD-2-Clause;BSD-3-Clause;ISC;0BSD;CC0-1.0;Unlicense;CC-BY-3.0;CC-BY-4.0;Python-2.0;BlueOak-1.0.0;MPL-2.0"
        
        # Exclude our own package (it's GPL-3.0 which is intentional)
        EXCLUDE_PACKAGES="dyna-dbg@0.1.0"
        
        # Run license-checker with allowed licenses, excluding our own package
        if license-checker --production --onlyAllow "$ALLOWED_LICENSES" --excludePackages "$EXCLUDE_PACKAGES" --summary 2>&1; then
            echo -e "${GREEN}✓ npm license check passed${NC}"
        else
            echo -e "${RED}✗ npm license check failed${NC}"
            echo ""
            echo "Packages with non-compliant licenses:"
            license-checker --production --onlyAllow "$ALLOWED_LICENSES" 2>&1 || true
            OVERALL_STATUS=1
        fi
        
        cd "$PROJECT_ROOT"
    else
        echo -e "${YELLOW}⚠ No package.json found in $CLIENT_DIR${NC}"
    fi
    
    echo ""
}

# Generate license report
generate_report() {
    echo -e "${GREEN}Generating license report...${NC}"
    echo ""
    
    REPORT_DIR="$PROJECT_ROOT/license-report"
    mkdir -p "$REPORT_DIR"
    
    # Generate npm license report
    CLIENT_DIR="$PROJECT_ROOT/src/client"
    if [ -f "$CLIENT_DIR/package.json" ] && [ -d "$CLIENT_DIR/node_modules" ]; then
        cd "$CLIENT_DIR"
        license-checker --production --json > "$REPORT_DIR/npm-licenses.json" 2>/dev/null || true
        license-checker --production --csv > "$REPORT_DIR/npm-licenses.csv" 2>/dev/null || true
        echo "  - npm licenses: $REPORT_DIR/npm-licenses.json"
        cd "$PROJECT_ROOT"
    fi
    
    # Generate cargo license report (if cargo-license is available)
    if command -v cargo-license &> /dev/null; then
        TAURI_DIR="$PROJECT_ROOT/src/client/src-tauri"
        if [ -f "$TAURI_DIR/Cargo.toml" ]; then
            cd "$TAURI_DIR"
            cargo license --json > "$REPORT_DIR/cargo-tauri-licenses.json" 2>/dev/null || true
            echo "  - Tauri licenses: $REPORT_DIR/cargo-tauri-licenses.json"
            cd "$PROJECT_ROOT"
        fi
        
        SERVER_DIR="$PROJECT_ROOT/src/server"
        if [ -f "$SERVER_DIR/Cargo.toml" ]; then
            cd "$SERVER_DIR"
            cargo license --json > "$REPORT_DIR/cargo-server-licenses.json" 2>/dev/null || true
            echo "  - Server licenses: $REPORT_DIR/cargo-server-licenses.json"
            cd "$PROJECT_ROOT"
        fi
    else
        echo -e "${YELLOW}  ⚠ cargo-license not installed (run: cargo install cargo-license)${NC}"
    fi
    
    echo ""
}

# Main execution
main() {
    check_cargo_deny
    check_license_checker
    
    echo ""
    
    check_rust_licenses
    check_server_licenses
    check_npm_licenses
    
    if [ "$1" == "--report" ]; then
        generate_report
    fi
    
    echo "=========================================="
    if [ $OVERALL_STATUS -eq 0 ]; then
        echo -e "${GREEN}All license checks passed!${NC}"
    else
        echo -e "${RED}Some license checks failed!${NC}"
        echo "Please review the packages with non-compliant licenses."
    fi
    echo "=========================================="
    
    exit $OVERALL_STATUS
}

# Show help
if [ "$1" == "--help" ] || [ "$1" == "-h" ]; then
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  --report    Generate detailed license reports"
    echo "  --help, -h  Show this help message"
    echo ""
    echo "Allowed licenses:"
    echo "  MIT, Apache-2.0, BSD-2-Clause, BSD-3-Clause, ISC, 0BSD,"
    echo "  CC0-1.0, Unlicense, Zlib, MPL-2.0, etc."
    echo ""
    echo "Denied licenses (copyleft):"
    echo "  GPL-2.0, GPL-3.0, LGPL-2.0, LGPL-2.1, LGPL-3.0, AGPL-3.0, etc."
    exit 0
fi

main "$@"

```

`src/client/README.md`:

```md
# Tauri + Vanilla TS

This template should help get you started developing with Tauri in vanilla HTML, CSS and Typescript.

## Recommended IDE Setup

- [VS Code](https://code.visualstudio.com/) + [Tauri](https://marketplace.visualstudio.com/items?itemName=tauri-apps.tauri-vscode) + [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer)

```

`src/client/index.html`:

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/src/assets/tauri.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DynaDbg</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        background-color: #1e1e1e;
      }
    </style>
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

```

`src/client/package-lock.json`:

```json
{
  "name": "dyna-dbg",
  "version": "0.1.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "dyna-dbg",
      "version": "0.1.0",
      "license": "GPL-3.0",
      "dependencies": {
        "@emotion/react": "^11.14.0",
        "@emotion/styled": "^11.14.1",
        "@mui/icons-material": "^7.2.0",
        "@mui/material": "^7.2.0",
        "@tauri-apps/api": "^2",
        "@tauri-apps/plugin-opener": "^2",
        "@tauri-apps/plugin-shell": "^2.3.3",
        "@types/prismjs": "^1.26.5",
        "@types/react": "^19.1.8",
        "@types/react-dom": "^19.1.6",
        "@types/react-router-dom": "^5.3.3",
        "@types/react-window": "^1.8.8",
        "@types/xterm": "^2.0.3",
        "@vitejs/plugin-react": "^4.7.0",
        "@xterm/addon-fit": "^0.10.0",
        "@xterm/xterm": "^5.5.0",
        "crypto-js": "^4.2.0",
        "prismjs": "^1.30.0",
        "react": "^19.1.0",
        "react-dom": "^19.1.0",
        "react-router-dom": "^7.7.1",
        "react-simple-code-editor": "^0.14.1",
        "react-window": "^2.2.3",
        "xterm": "^5.3.0",
        "xterm-addon-fit": "^0.8.0",
        "zustand": "^5.0.8"
      },
      "devDependencies": {
        "@tauri-apps/cli": "^2",
        "@types/crypto-js": "^4.2.2",
        "prettier": "3.6.2",
        "typescript": "~5.6.2",
        "vite": "^6.0.3"
      }
    },
    "node_modules/@ampproject/remapping": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.24"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/code-frame": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.27.1.tgz",
      "integrity": "sha512-cjQ7ZlQ0Mv3b47hABuTevyTuYN4i+loJKGeV9flcCgIK37cCXRh+L1bd3iBHlynerhQ7BhCkn2BPbQUL+rGqFg==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-validator-identifier": "^7.27.1",
        "js-tokens": "^4.0.0",
        "picocolors": "^1.1.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/compat-data": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.28.0.tgz",
      "integrity": "sha512-60X7qkglvrap8mn1lh2ebxXdZYtUcpd7gsmy9kLaBJ4i/WdY8PqTSdxyA8qraikqKQK5C1KRBKXqznrVapyNaw==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/core": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.28.0.tgz",
      "integrity": "sha512-UlLAnTPrFdNGoFtbSXwcGFQBtQZJCNjaN6hQNP3UPvuNXT1i82N26KL3dZeIpNalWywr9IuQuncaAfUaS1g6sQ==",
      "license": "MIT",
      "dependencies": {
        "@ampproject/remapping": "^2.2.0",
        "@babel/code-frame": "^7.27.1",
        "@babel/generator": "^7.28.0",
        "@babel/helper-compilation-targets": "^7.27.2",
        "@babel/helper-module-transforms": "^7.27.3",
        "@babel/helpers": "^7.27.6",
        "@babel/parser": "^7.28.0",
        "@babel/template": "^7.27.2",
        "@babel/traverse": "^7.28.0",
        "@babel/types": "^7.28.0",
        "convert-source-map": "^2.0.0",
        "debug": "^4.1.0",
        "gensync": "^1.0.0-beta.2",
        "json5": "^2.2.3",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/babel"
      }
    },
    "node_modules/@babel/generator": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.28.0.tgz",
      "integrity": "sha512-lJjzvrbEeWrhB4P3QBsH7tey117PjLZnDbLiQEKjQ/fNJTjuq4HSqgFA+UNSwZT8D7dxxbnuSBMsa1lrWzKlQg==",
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.28.0",
        "@babel/types": "^7.28.0",
        "@jridgewell/gen-mapping": "^0.3.12",
        "@jridgewell/trace-mapping": "^0.3.28",
        "jsesc": "^3.0.2"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-compilation-targets": {
      "version": "7.27.2",
      "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.27.2.tgz",
      "integrity": "sha512-2+1thGUUWWjLTYTHZWK1n8Yga0ijBz1XAhUXcKy81rd5g6yh7hGqMp45v7cadSbEHc9G3OTv45SyneRN3ps4DQ==",
      "license": "MIT",
      "dependencies": {
        "@babel/compat-data": "^7.27.2",
        "@babel/helper-validator-option": "^7.27.1",
        "browserslist": "^4.24.0",
        "lru-cache": "^5.1.1",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-globals": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/helper-globals/-/helper-globals-7.28.0.tgz",
      "integrity": "sha512-+W6cISkXFa1jXsDEdYA8HeevQT/FULhxzR99pxphltZcVaugps53THCeiWA8SguxxpSp3gKPiuYfSWopkLQ4hw==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-imports": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.27.1.tgz",
      "integrity": "sha512-0gSFWUPNXNopqtIPQvlD5WgXYI5GY2kP2cCvoT8kczjbfcfuIljTbcWrulD1CIPIX2gt1wghbDy08yE1p+/r3w==",
      "license": "MIT",
      "dependencies": {
        "@babel/traverse": "^7.27.1",
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-transforms": {
      "version": "7.27.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.27.3.tgz",
      "integrity": "sha512-dSOvYwvyLsWBeIRyOeHXp5vPj5l1I011r52FM1+r1jCERv+aFXYk4whgQccYEGYxK2H3ZAIA8nuPkQ0HaUo3qg==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-imports": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.27.1",
        "@babel/traverse": "^7.27.3"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-plugin-utils": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.27.1.tgz",
      "integrity": "sha512-1gn1Up5YXka3YYAHGKpbideQ5Yjf1tDa9qYcgysz+cNCXukyLl6DjPXhD3VRwSb8c0J9tA4b2+rHEZtc6R0tlw==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-string-parser": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-identifier": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.27.1.tgz",
      "integrity": "sha512-D2hP9eA+Sqx1kBZgzxZh0y1trbuU+JoDkiEwqhQ36nodYqJwyEIhPSdMNd7lOm/4io72luTPWH20Yda0xOuUow==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-option": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.27.1.tgz",
      "integrity": "sha512-YvjJow9FxbhFFKDSuFnVCe2WxXk1zWc22fFePVNEaWJEu8IrZVlda6N0uHwzZrUM1il7NC9Mlp4MaJYbYd9JSg==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helpers": {
      "version": "7.27.6",
      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.27.6.tgz",
      "integrity": "sha512-muE8Tt8M22638HU31A3CgfSUciwz1fhATfoVai05aPXGor//CdWDCbnlY1yvBPo07njuVOCNGCSp/GTt12lIug==",
      "license": "MIT",
      "dependencies": {
        "@babel/template": "^7.27.2",
        "@babel/types": "^7.27.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/parser": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.28.0.tgz",
      "integrity": "sha512-jVZGvOxOuNSsuQuLRTh13nU0AogFlw32w/MT+LV6D3sP5WdbW61E77RnkbaO2dUvmPAYrBDJXGn5gGS6tH4j8g==",
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.28.0"
      },
      "bin": {
        "parser": "bin/babel-parser.js"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-self": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-self/-/plugin-transform-react-jsx-self-7.27.1.tgz",
      "integrity": "sha512-6UzkCs+ejGdZ5mFFC/OCUrv028ab2fp1znZmCZjAOBKiBK2jXD1O+BPSfX8X2qjJ75fZBMSnQn3Rq2mrBJK2mw==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-source": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-source/-/plugin-transform-react-jsx-source-7.27.1.tgz",
      "integrity": "sha512-zbwoTsBruTeKB9hSq73ha66iFeJHuaFkUbwvqElnygoNbj/jHRsSeokowZFN3CZ64IvEqcmmkVe89OPXc7ldAw==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/runtime": {
      "version": "7.27.6",
      "resolved": "https://registry.npmjs.org/@babel/runtime/-/runtime-7.27.6.tgz",
      "integrity": "sha512-vbavdySgbTTrmFE+EsiqUTzlOr5bzlnJtUv9PynGCAKvfQqjIXbvFdumPM/GxMDfyuGMJaJAU6TO4zc1Jf1i8Q==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/template": {
      "version": "7.27.2",
      "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.27.2.tgz",
      "integrity": "sha512-LPDZ85aEJyYSd18/DkjNh4/y1ntkE5KwUHWTiqgRxruuZL2F1yuHligVHLvcHY2vMHXttKFpJn6LwfI7cw7ODw==",
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.27.1",
        "@babel/parser": "^7.27.2",
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/traverse": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.28.0.tgz",
      "integrity": "sha512-mGe7UK5wWyh0bKRfupsUchrQGqvDbZDbKJw+kcRGSmdHVYrv+ltd0pnpDTVpiTqnaBru9iEvA8pz8W46v0Amwg==",
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.27.1",
        "@babel/generator": "^7.28.0",
        "@babel/helper-globals": "^7.28.0",
        "@babel/parser": "^7.28.0",
        "@babel/template": "^7.27.2",
        "@babel/types": "^7.28.0",
        "debug": "^4.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/types": {
      "version": "7.28.1",
      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.28.1.tgz",
      "integrity": "sha512-x0LvFTekgSX+83TI28Y9wYPUfzrnl2aT5+5QLnO6v7mSJYtEEevuDRN0F0uSHRk1G1IWZC43o00Y0xDDrpBGPQ==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-string-parser": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@emotion/babel-plugin": {
      "version": "11.13.5",
      "resolved": "https://registry.npmjs.org/@emotion/babel-plugin/-/babel-plugin-11.13.5.tgz",
      "integrity": "sha512-pxHCpT2ex+0q+HH91/zsdHkw/lXd468DIN2zvfvLtPKLLMo6gQj7oLObq8PhkrxOZb/gGCq03S3Z7PDhS8pduQ==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-imports": "^7.16.7",
        "@babel/runtime": "^7.18.3",
        "@emotion/hash": "^0.9.2",
        "@emotion/memoize": "^0.9.0",
        "@emotion/serialize": "^1.3.3",
        "babel-plugin-macros": "^3.1.0",
        "convert-source-map": "^1.5.0",
        "escape-string-regexp": "^4.0.0",
        "find-root": "^1.1.0",
        "source-map": "^0.5.7",
        "stylis": "4.2.0"
      }
    },
    "node_modules/@emotion/babel-plugin/node_modules/convert-source-map": {
      "version": "1.9.0",
      "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-1.9.0.tgz",
      "integrity": "sha512-ASFBup0Mz1uyiIjANan1jzLQami9z1PoYSZCiiYW2FczPbenXc45FZdBZLzOT+r6+iciuEModtmCti+hjaAk0A==",
      "license": "MIT"
    },
    "node_modules/@emotion/cache": {
      "version": "11.14.0",
      "resolved": "https://registry.npmjs.org/@emotion/cache/-/cache-11.14.0.tgz",
      "integrity": "sha512-L/B1lc/TViYk4DcpGxtAVbx0ZyiKM5ktoIyafGkH6zg/tj+mA+NE//aPYKG0k8kCHSHVJrpLpcAlOBEXQ3SavA==",
      "license": "MIT",
      "dependencies": {
        "@emotion/memoize": "^0.9.0",
        "@emotion/sheet": "^1.4.0",
        "@emotion/utils": "^1.4.2",
        "@emotion/weak-memoize": "^0.4.0",
        "stylis": "4.2.0"
      }
    },
    "node_modules/@emotion/hash": {
      "version": "0.9.2",
      "resolved": "https://registry.npmjs.org/@emotion/hash/-/hash-0.9.2.tgz",
      "integrity": "sha512-MyqliTZGuOm3+5ZRSaaBGP3USLw6+EGykkwZns2EPC5g8jJ4z9OrdZY9apkl3+UP9+sdz76YYkwCKP5gh8iY3g==",
      "license": "MIT"
    },
    "node_modules/@emotion/is-prop-valid": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/@emotion/is-prop-valid/-/is-prop-valid-1.3.1.tgz",
      "integrity": "sha512-/ACwoqx7XQi9knQs/G0qKvv5teDMhD7bXYns9N/wM8ah8iNb8jZ2uNO0YOgiq2o2poIvVtJS2YALasQuMSQ7Kw==",
      "license": "MIT",
      "dependencies": {
        "@emotion/memoize": "^0.9.0"
      }
    },
    "node_modules/@emotion/memoize": {
      "version": "0.9.0",
      "resolved": "https://registry.npmjs.org/@emotion/memoize/-/memoize-0.9.0.tgz",
      "integrity": "sha512-30FAj7/EoJ5mwVPOWhAyCX+FPfMDrVecJAM+Iw9NRoSl4BBAQeqj4cApHHUXOVvIPgLVDsCFoz/hGD+5QQD1GQ==",
      "license": "MIT"
    },
    "node_modules/@emotion/react": {
      "version": "11.14.0",
      "resolved": "https://registry.npmjs.org/@emotion/react/-/react-11.14.0.tgz",
      "integrity": "sha512-O000MLDBDdk/EohJPFUqvnp4qnHeYkVP5B0xEG0D/L7cOKP9kefu2DXn8dj74cQfsEzUqh+sr1RzFqiL1o+PpA==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.18.3",
        "@emotion/babel-plugin": "^11.13.5",
        "@emotion/cache": "^11.14.0",
        "@emotion/serialize": "^1.3.3",
        "@emotion/use-insertion-effect-with-fallbacks": "^1.2.0",
        "@emotion/utils": "^1.4.2",
        "@emotion/weak-memoize": "^0.4.0",
        "hoist-non-react-statics": "^3.3.1"
      },
      "peerDependencies": {
        "react": ">=16.8.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@emotion/serialize": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/@emotion/serialize/-/serialize-1.3.3.tgz",
      "integrity": "sha512-EISGqt7sSNWHGI76hC7x1CksiXPahbxEOrC5RjmFRJTqLyEK9/9hZvBbiYn70dw4wuwMKiEMCUlR6ZXTSWQqxA==",
      "license": "MIT",
      "dependencies": {
        "@emotion/hash": "^0.9.2",
        "@emotion/memoize": "^0.9.0",
        "@emotion/unitless": "^0.10.0",
        "@emotion/utils": "^1.4.2",
        "csstype": "^3.0.2"
      }
    },
    "node_modules/@emotion/sheet": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/@emotion/sheet/-/sheet-1.4.0.tgz",
      "integrity": "sha512-fTBW9/8r2w3dXWYM4HCB1Rdp8NLibOw2+XELH5m5+AkWiL/KqYX6dc0kKYlaYyKjrQ6ds33MCdMPEwgs2z1rqg==",
      "license": "MIT"
    },
    "node_modules/@emotion/styled": {
      "version": "11.14.1",
      "resolved": "https://registry.npmjs.org/@emotion/styled/-/styled-11.14.1.tgz",
      "integrity": "sha512-qEEJt42DuToa3gurlH4Qqc1kVpNq8wO8cJtDzU46TjlzWjDlsVyevtYCRijVq3SrHsROS+gVQ8Fnea108GnKzw==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.18.3",
        "@emotion/babel-plugin": "^11.13.5",
        "@emotion/is-prop-valid": "^1.3.0",
        "@emotion/serialize": "^1.3.3",
        "@emotion/use-insertion-effect-with-fallbacks": "^1.2.0",
        "@emotion/utils": "^1.4.2"
      },
      "peerDependencies": {
        "@emotion/react": "^11.0.0-rc.0",
        "react": ">=16.8.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@emotion/unitless": {
      "version": "0.10.0",
      "resolved": "https://registry.npmjs.org/@emotion/unitless/-/unitless-0.10.0.tgz",
      "integrity": "sha512-dFoMUuQA20zvtVTuxZww6OHoJYgrzfKM1t52mVySDJnMSEa08ruEvdYQbhvyu6soU+NeLVd3yKfTfT0NeV6qGg==",
      "license": "MIT"
    },
    "node_modules/@emotion/use-insertion-effect-with-fallbacks": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/@emotion/use-insertion-effect-with-fallbacks/-/use-insertion-effect-with-fallbacks-1.2.0.tgz",
      "integrity": "sha512-yJMtVdH59sxi/aVJBpk9FQq+OR8ll5GT8oWd57UpeaKEVGab41JWaCFA7FRLoMLloOZF/c/wsPoe+bfGmRKgDg==",
      "license": "MIT",
      "peerDependencies": {
        "react": ">=16.8.0"
      }
    },
    "node_modules/@emotion/utils": {
      "version": "1.4.2",
      "resolved": "https://registry.npmjs.org/@emotion/utils/-/utils-1.4.2.tgz",
      "integrity": "sha512-3vLclRofFziIa3J2wDh9jjbkUz9qk5Vi3IZ/FSTKViB0k+ef0fPV7dYrUIugbgupYDx7v9ud/SjrtEP8Y4xLoA==",
      "license": "MIT"
    },
    "node_modules/@emotion/weak-memoize": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/@emotion/weak-memoize/-/weak-memoize-0.4.0.tgz",
      "integrity": "sha512-snKqtPW01tN0ui7yu9rGv69aJXr/a/Ywvl11sUjNtEcRc+ng/mQriFL0wLXMef74iHa/EkftbDzU9F8iFbH+zg==",
      "license": "MIT"
    },
    "node_modules/@esbuild/aix-ppc64": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.25.8.tgz",
      "integrity": "sha512-urAvrUedIqEiFR3FYSLTWQgLu5tb+m0qZw0NBEasUeo6wuqatkMDaRT+1uABiGXEu5vqgPd7FGE1BhsAIy9QVA==",
      "cpu": [
        "ppc64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "aix"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.25.8.tgz",
      "integrity": "sha512-RONsAvGCz5oWyePVnLdZY/HHwA++nxYWIX1atInlaW6SEkwq6XkP3+cb825EUcRs5Vss/lGh/2YxAb5xqc07Uw==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm64": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.25.8.tgz",
      "integrity": "sha512-OD3p7LYzWpLhZEyATcTSJ67qB5D+20vbtr6vHlHWSQYhKtzUYrETuWThmzFpZtFsBIxRvhO07+UgVA9m0i/O1w==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-x64": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.25.8.tgz",
      "integrity": "sha512-yJAVPklM5+4+9dTeKwHOaA+LQkmrKFX96BM0A/2zQrbS6ENCmxc4OVoBs5dPkCCak2roAD+jKCdnmOqKszPkjA==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-arm64": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.25.8.tgz",
      "integrity": "sha512-Jw0mxgIaYX6R8ODrdkLLPwBqHTtYHJSmzzd+QeytSugzQ0Vg4c5rDky5VgkoowbZQahCbsv1rT1KW72MPIkevw==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-x64": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.25.8.tgz",
      "integrity": "sha512-Vh2gLxxHnuoQ+GjPNvDSDRpoBCUzY4Pu0kBqMBDlK4fuWbKgGtmDIeEC081xi26PPjn+1tct+Bh8FjyLlw1Zlg==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-arm64": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.25.8.tgz",
      "integrity": "sha512-YPJ7hDQ9DnNe5vxOm6jaie9QsTwcKedPvizTVlqWG9GBSq+BuyWEDazlGaDTC5NGU4QJd666V0yqCBL2oWKPfA==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-x64": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.25.8.tgz",
      "integrity": "sha512-MmaEXxQRdXNFsRN/KcIimLnSJrk2r5H8v+WVafRWz5xdSVmWLoITZQXcgehI2ZE6gioE6HirAEToM/RvFBeuhw==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.25.8.tgz",
      "integrity": "sha512-FuzEP9BixzZohl1kLf76KEVOsxtIBFwCaLupVuk4eFVnOZfU+Wsn+x5Ryam7nILV2pkq2TqQM9EZPsOBuMC+kg==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm64": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.25.8.tgz",
      "integrity": "sha512-WIgg00ARWv/uYLU7lsuDK00d/hHSfES5BzdWAdAig1ioV5kaFNrtK8EqGcUBJhYqotlUByUKz5Qo6u8tt7iD/w==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ia32": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.25.8.tgz",
      "integrity": "sha512-A1D9YzRX1i+1AJZuFFUMP1E9fMaYY+GnSQil9Tlw05utlE86EKTUA7RjwHDkEitmLYiFsRd9HwKBPEftNdBfjg==",
      "cpu": [
        "ia32"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-loong64": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.25.8.tgz",
      "integrity": "sha512-O7k1J/dwHkY1RMVvglFHl1HzutGEFFZ3kNiDMSOyUrB7WcoHGf96Sh+64nTRT26l3GMbCW01Ekh/ThKM5iI7hQ==",
      "cpu": [
        "loong64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-mips64el": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.25.8.tgz",
      "integrity": "sha512-uv+dqfRazte3BzfMp8PAQXmdGHQt2oC/y2ovwpTteqrMx2lwaksiFZ/bdkXJC19ttTvNXBuWH53zy/aTj1FgGw==",
      "cpu": [
        "mips64el"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ppc64": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.25.8.tgz",
      "integrity": "sha512-GyG0KcMi1GBavP5JgAkkstMGyMholMDybAf8wF5A70CALlDM2p/f7YFE7H92eDeH/VBtFJA5MT4nRPDGg4JuzQ==",
      "cpu": [
        "ppc64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-riscv64": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.25.8.tgz",
      "integrity": "sha512-rAqDYFv3yzMrq7GIcen3XP7TUEG/4LK86LUPMIz6RT8A6pRIDn0sDcvjudVZBiiTcZCY9y2SgYX2lgK3AF+1eg==",
      "cpu": [
        "riscv64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-s390x": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.25.8.tgz",
      "integrity": "sha512-Xutvh6VjlbcHpsIIbwY8GVRbwoviWT19tFhgdA7DlenLGC/mbc3lBoVb7jxj9Z+eyGqvcnSyIltYUrkKzWqSvg==",
      "cpu": [
        "s390x"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-x64": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.25.8.tgz",
      "integrity": "sha512-ASFQhgY4ElXh3nDcOMTkQero4b1lgubskNlhIfJrsH5OKZXDpUAKBlNS0Kx81jwOBp+HCeZqmoJuihTv57/jvQ==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-arm64": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-arm64/-/netbsd-arm64-0.25.8.tgz",
      "integrity": "sha512-d1KfruIeohqAi6SA+gENMuObDbEjn22olAR7egqnkCD9DGBG0wsEARotkLgXDu6c4ncgWTZJtN5vcgxzWRMzcw==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-x64": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.25.8.tgz",
      "integrity": "sha512-nVDCkrvx2ua+XQNyfrujIG38+YGyuy2Ru9kKVNyh5jAys6n+l44tTtToqHjino2My8VAY6Lw9H7RI73XFi66Cg==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-arm64": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-arm64/-/openbsd-arm64-0.25.8.tgz",
      "integrity": "sha512-j8HgrDuSJFAujkivSMSfPQSAa5Fxbvk4rgNAS5i3K+r8s1X0p1uOO2Hl2xNsGFppOeHOLAVgYwDVlmxhq5h+SQ==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-x64": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.25.8.tgz",
      "integrity": "sha512-1h8MUAwa0VhNCDp6Af0HToI2TJFAn1uqT9Al6DJVzdIBAd21m/G0Yfc77KDM3uF3T/YaOgQq3qTJHPbTOInaIQ==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openharmony-arm64": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/openharmony-arm64/-/openharmony-arm64-0.25.8.tgz",
      "integrity": "sha512-r2nVa5SIK9tSWd0kJd9HCffnDHKchTGikb//9c7HX+r+wHYCpQrSgxhlY6KWV1nFo1l4KFbsMlHk+L6fekLsUg==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "openharmony"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/sunos-x64": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.25.8.tgz",
      "integrity": "sha512-zUlaP2S12YhQ2UzUfcCuMDHQFJyKABkAjvO5YSndMiIkMimPmxA+BYSBikWgsRpvyxuRnow4nS5NPnf9fpv41w==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-arm64": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.25.8.tgz",
      "integrity": "sha512-YEGFFWESlPva8hGL+zvj2z/SaK+pH0SwOM0Nc/d+rVnW7GSTFlLBGzZkuSU9kFIGIo8q9X3ucpZhu8PDN5A2sQ==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-ia32": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.25.8.tgz",
      "integrity": "sha512-hiGgGC6KZ5LZz58OL/+qVVoZiuZlUYlYHNAmczOm7bs2oE1XriPFi5ZHHrS8ACpV5EjySrnoCKmcbQMN+ojnHg==",
      "cpu": [
        "ia32"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.25.8.tgz",
      "integrity": "sha512-cn3Yr7+OaaZq1c+2pe+8yxC8E144SReCQjN6/2ynubzYjvyqZjTXfQJpAcQpsdJq3My7XADANiYGHoFC69pLQw==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@jridgewell/gen-mapping": {
      "version": "0.3.12",
      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.12.tgz",
      "integrity": "sha512-OuLGC46TjB5BbN1dH8JULVVZY4WTdkF7tV9Ys6wLL1rubZnCMstOhNHueU5bLCrnRuDhKPDM4g6sw4Bel5Gzqg==",
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.0",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.4",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.4.tgz",
      "integrity": "sha512-VT2+G1VQs/9oz078bLrYbecdZKs912zQlkelYpuf+SXF+QvZDYJlbx/LSx+meSAwdDFnF8FVXW92AVjjkVmgFw==",
      "license": "MIT"
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.29",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.29.tgz",
      "integrity": "sha512-uw6guiW/gcAGPDhLmd77/6lW8QLeiV5RUTsAX46Db6oLhGaVj4lhnPwb184s1bkc8kdVg/+h988dro8GRDpmYQ==",
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.1.0",
        "@jridgewell/sourcemap-codec": "^1.4.14"
      }
    },
    "node_modules/@mui/core-downloads-tracker": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/@mui/core-downloads-tracker/-/core-downloads-tracker-7.2.0.tgz",
      "integrity": "sha512-d49s7kEgI5iX40xb2YPazANvo7Bx0BLg/MNRwv+7BVpZUzXj1DaVCKlQTDex3gy/0jsCb4w7AY2uH4t4AJvSog==",
      "license": "MIT",
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/mui-org"
      }
    },
    "node_modules/@mui/icons-material": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/@mui/icons-material/-/icons-material-7.2.0.tgz",
      "integrity": "sha512-gRCspp3pfjHQyTmSOmYw7kUQTd9Udpdan4R8EnZvqPeoAtHnPzkvjBrBqzKaoAbbBp5bGF7BcD18zZJh4nwu0A==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.27.6"
      },
      "engines": {
        "node": ">=14.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/mui-org"
      },
      "peerDependencies": {
        "@mui/material": "^7.2.0",
        "@types/react": "^17.0.0 || ^18.0.0 || ^19.0.0",
        "react": "^17.0.0 || ^18.0.0 || ^19.0.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@mui/material": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/@mui/material/-/material-7.2.0.tgz",
      "integrity": "sha512-NTuyFNen5Z2QY+I242MDZzXnFIVIR6ERxo7vntFi9K1wCgSwvIl0HcAO2OOydKqqKApE6omRiYhpny1ZhGuH7Q==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.27.6",
        "@mui/core-downloads-tracker": "^7.2.0",
        "@mui/system": "^7.2.0",
        "@mui/types": "^7.4.4",
        "@mui/utils": "^7.2.0",
        "@popperjs/core": "^2.11.8",
        "@types/react-transition-group": "^4.4.12",
        "clsx": "^2.1.1",
        "csstype": "^3.1.3",
        "prop-types": "^15.8.1",
        "react-is": "^19.1.0",
        "react-transition-group": "^4.4.5"
      },
      "engines": {
        "node": ">=14.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/mui-org"
      },
      "peerDependencies": {
        "@emotion/react": "^11.5.0",
        "@emotion/styled": "^11.3.0",
        "@mui/material-pigment-css": "^7.2.0",
        "@types/react": "^17.0.0 || ^18.0.0 || ^19.0.0",
        "react": "^17.0.0 || ^18.0.0 || ^19.0.0",
        "react-dom": "^17.0.0 || ^18.0.0 || ^19.0.0"
      },
      "peerDependenciesMeta": {
        "@emotion/react": {
          "optional": true
        },
        "@emotion/styled": {
          "optional": true
        },
        "@mui/material-pigment-css": {
          "optional": true
        },
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@mui/private-theming": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/@mui/private-theming/-/private-theming-7.2.0.tgz",
      "integrity": "sha512-y6N1Yt3T5RMxVFnCh6+zeSWBuQdNDm5/UlM0EAYZzZR/1u+XKJWYQmbpx4e+F+1EpkYi3Nk8KhPiQDi83M3zIw==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.27.6",
        "@mui/utils": "^7.2.0",
        "prop-types": "^15.8.1"
      },
      "engines": {
        "node": ">=14.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/mui-org"
      },
      "peerDependencies": {
        "@types/react": "^17.0.0 || ^18.0.0 || ^19.0.0",
        "react": "^17.0.0 || ^18.0.0 || ^19.0.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@mui/styled-engine": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/@mui/styled-engine/-/styled-engine-7.2.0.tgz",
      "integrity": "sha512-yq08xynbrNYcB1nBcW9Fn8/h/iniM3ewRguGJXPIAbHvxEF7Pz95kbEEOAAhwzxMX4okhzvHmk0DFuC5ayvgIQ==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.27.6",
        "@emotion/cache": "^11.14.0",
        "@emotion/serialize": "^1.3.3",
        "@emotion/sheet": "^1.4.0",
        "csstype": "^3.1.3",
        "prop-types": "^15.8.1"
      },
      "engines": {
        "node": ">=14.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/mui-org"
      },
      "peerDependencies": {
        "@emotion/react": "^11.4.1",
        "@emotion/styled": "^11.3.0",
        "react": "^17.0.0 || ^18.0.0 || ^19.0.0"
      },
      "peerDependenciesMeta": {
        "@emotion/react": {
          "optional": true
        },
        "@emotion/styled": {
          "optional": true
        }
      }
    },
    "node_modules/@mui/system": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/@mui/system/-/system-7.2.0.tgz",
      "integrity": "sha512-PG7cm/WluU6RAs+gNND2R9vDwNh+ERWxPkqTaiXQJGIFAyJ+VxhyKfzpdZNk0z0XdmBxxi9KhFOpgxjehf/O0A==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.27.6",
        "@mui/private-theming": "^7.2.0",
        "@mui/styled-engine": "^7.2.0",
        "@mui/types": "^7.4.4",
        "@mui/utils": "^7.2.0",
        "clsx": "^2.1.1",
        "csstype": "^3.1.3",
        "prop-types": "^15.8.1"
      },
      "engines": {
        "node": ">=14.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/mui-org"
      },
      "peerDependencies": {
        "@emotion/react": "^11.5.0",
        "@emotion/styled": "^11.3.0",
        "@types/react": "^17.0.0 || ^18.0.0 || ^19.0.0",
        "react": "^17.0.0 || ^18.0.0 || ^19.0.0"
      },
      "peerDependenciesMeta": {
        "@emotion/react": {
          "optional": true
        },
        "@emotion/styled": {
          "optional": true
        },
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@mui/types": {
      "version": "7.4.4",
      "resolved": "https://registry.npmjs.org/@mui/types/-/types-7.4.4.tgz",
      "integrity": "sha512-p63yhbX52MO/ajXC7hDHJA5yjzJekvWD3q4YDLl1rSg+OXLczMYPvTuSuviPRCgRX8+E42RXz1D/dz9SxPSlWg==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.27.6"
      },
      "peerDependencies": {
        "@types/react": "^17.0.0 || ^18.0.0 || ^19.0.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@mui/utils": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/@mui/utils/-/utils-7.2.0.tgz",
      "integrity": "sha512-O0i1GQL6MDzhKdy9iAu5Yr0Sz1wZjROH1o3aoztuivdCXqEeQYnEjTDiRLGuFxI9zrUbTHBwobMyQH5sNtyacw==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.27.6",
        "@mui/types": "^7.4.4",
        "@types/prop-types": "^15.7.15",
        "clsx": "^2.1.1",
        "prop-types": "^15.8.1",
        "react-is": "^19.1.0"
      },
      "engines": {
        "node": ">=14.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/mui-org"
      },
      "peerDependencies": {
        "@types/react": "^17.0.0 || ^18.0.0 || ^19.0.0",
        "react": "^17.0.0 || ^18.0.0 || ^19.0.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@popperjs/core": {
      "version": "2.11.8",
      "resolved": "https://registry.npmjs.org/@popperjs/core/-/core-2.11.8.tgz",
      "integrity": "sha512-P1st0aksCrn9sGZhp8GMYwBnQsbvAWsZAX44oXNNvLHGqAOcoVxmjZiohstwQ7SqKnbR47akdNi+uleWD8+g6A==",
      "license": "MIT",
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/popperjs"
      }
    },
    "node_modules/@rolldown/pluginutils": {
      "version": "1.0.0-beta.27",
      "resolved": "https://registry.npmjs.org/@rolldown/pluginutils/-/pluginutils-1.0.0-beta.27.tgz",
      "integrity": "sha512-+d0F4MKMCbeVUJwG96uQ4SgAznZNSq93I3V+9NHA4OpvqG8mRCpGdKmK8l/dl02h2CCDHwW2FqilnTyDcAnqjA==",
      "license": "MIT"
    },
    "node_modules/@rollup/rollup-android-arm-eabi": {
      "version": "4.45.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.45.1.tgz",
      "integrity": "sha512-NEySIFvMY0ZQO+utJkgoMiCAjMrGvnbDLHvcmlA33UXJpYBCvlBEbMMtV837uCkS+plG2umfhn0T5mMAxGrlRA==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-android-arm64": {
      "version": "4.45.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.45.1.tgz",
      "integrity": "sha512-ujQ+sMXJkg4LRJaYreaVx7Z/VMgBBd89wGS4qMrdtfUFZ+TSY5Rs9asgjitLwzeIbhwdEhyj29zhst3L1lKsRQ==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-darwin-arm64": {
      "version": "4.45.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.45.1.tgz",
      "integrity": "sha512-FSncqHvqTm3lC6Y13xncsdOYfxGSLnP+73k815EfNmpewPs+EyM49haPS105Rh4aF5mJKywk9X0ogzLXZzN9lA==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-darwin-x64": {
      "version": "4.45.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.45.1.tgz",
      "integrity": "sha512-2/vVn/husP5XI7Fsf/RlhDaQJ7x9zjvC81anIVbr4b/f0xtSmXQTFcGIQ/B1cXIYM6h2nAhJkdMHTnD7OtQ9Og==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-arm64": {
      "version": "4.45.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.45.1.tgz",
      "integrity": "sha512-4g1kaDxQItZsrkVTdYQ0bxu4ZIQ32cotoQbmsAnW1jAE4XCMbcBPDirX5fyUzdhVCKgPcrwWuucI8yrVRBw2+g==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-x64": {
      "version": "4.45.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.45.1.tgz",
      "integrity": "sha512-L/6JsfiL74i3uK1Ti2ZFSNsp5NMiM4/kbbGEcOCps99aZx3g8SJMO1/9Y0n/qKlWZfn6sScf98lEOUe2mBvW9A==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-gnueabihf": {
      "version": "4.45.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.45.1.tgz",
      "integrity": "sha512-RkdOTu2jK7brlu+ZwjMIZfdV2sSYHK2qR08FUWcIoqJC2eywHbXr0L8T/pONFwkGukQqERDheaGTeedG+rra6Q==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-musleabihf": {
      "version": "4.45.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.45.1.tgz",
      "integrity": "sha512-3kJ8pgfBt6CIIr1o+HQA7OZ9mp/zDk3ctekGl9qn/pRBgrRgfwiffaUmqioUGN9hv0OHv2gxmvdKOkARCtRb8Q==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-gnu": {
      "version": "4.45.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.45.1.tgz",
      "integrity": "sha512-k3dOKCfIVixWjG7OXTCOmDfJj3vbdhN0QYEqB+OuGArOChek22hn7Uy5A/gTDNAcCy5v2YcXRJ/Qcnm4/ma1xw==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-musl": {
      "version": "4.45.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.45.1.tgz",
      "integrity": "sha512-PmI1vxQetnM58ZmDFl9/Uk2lpBBby6B6rF4muJc65uZbxCs0EA7hhKCk2PKlmZKuyVSHAyIw3+/SiuMLxKxWog==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loongarch64-gnu": {
      "version": "4.45.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loongarch64-gnu/-/rollup-linux-loongarch64-gnu-4.45.1.tgz",
      "integrity": "sha512-9UmI0VzGmNJ28ibHW2GpE2nF0PBQqsyiS4kcJ5vK+wuwGnV5RlqdczVocDSUfGX/Na7/XINRVoUgJyFIgipoRg==",
      "cpu": [
        "loong64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-powerpc64le-gnu": {
      "version": "4.45.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-powerpc64le-gnu/-/rollup-linux-powerpc64le-gnu-4.45.1.tgz",
      "integrity": "sha512-7nR2KY8oEOUTD3pBAxIBBbZr0U7U+R9HDTPNy+5nVVHDXI4ikYniH1oxQz9VoB5PbBU1CZuDGHkLJkd3zLMWsg==",
      "cpu": [
        "ppc64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-gnu": {
      "version": "4.45.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.45.1.tgz",
      "integrity": "sha512-nlcl3jgUultKROfZijKjRQLUu9Ma0PeNv/VFHkZiKbXTBQXhpytS8CIj5/NfBeECZtY2FJQubm6ltIxm/ftxpw==",
      "cpu": [
        "riscv64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-musl": {
      "version": "4.45.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-musl/-/rollup-linux-riscv64-musl-4.45.1.tgz",
      "integrity": "sha512-HJV65KLS51rW0VY6rvZkiieiBnurSzpzore1bMKAhunQiECPuxsROvyeaot/tcK3A3aGnI+qTHqisrpSgQrpgA==",
      "cpu": [
        "riscv64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-s390x-gnu": {
      "version": "4.45.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.45.1.tgz",
      "integrity": "sha512-NITBOCv3Qqc6hhwFt7jLV78VEO/il4YcBzoMGGNxznLgRQf43VQDae0aAzKiBeEPIxnDrACiMgbqjuihx08OOw==",
      "cpu": [
        "s390x"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-gnu": {
      "version": "4.45.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.45.1.tgz",
      "integrity": "sha512-+E/lYl6qu1zqgPEnTrs4WysQtvc/Sh4fC2nByfFExqgYrqkKWp1tWIbe+ELhixnenSpBbLXNi6vbEEJ8M7fiHw==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-musl": {
      "version": "4.45.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.45.1.tgz",
      "integrity": "sha512-a6WIAp89p3kpNoYStITT9RbTbTnqarU7D8N8F2CV+4Cl9fwCOZraLVuVFvlpsW0SbIiYtEnhCZBPLoNdRkjQFw==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-win32-arm64-msvc": {
      "version": "4.45.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.45.1.tgz",
      "integrity": "sha512-T5Bi/NS3fQiJeYdGvRpTAP5P02kqSOpqiopwhj0uaXB6nzs5JVi2XMJb18JUSKhCOX8+UE1UKQufyD6Or48dJg==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-ia32-msvc": {
      "version": "4.45.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.45.1.tgz",
      "integrity": "sha512-lxV2Pako3ujjuUe9jiU3/s7KSrDfH6IgTSQOnDWr9aJ92YsFd7EurmClK0ly/t8dzMkDtd04g60WX6yl0sGfdw==",
      "cpu": [
        "ia32"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-msvc": {
      "version": "4.45.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.45.1.tgz",
      "integrity": "sha512-M/fKi4sasCdM8i0aWJjCSFm2qEnYRR8AMLG2kxp6wD13+tMGA4Z1tVAuHkNRjud5SW2EM3naLuK35w9twvf6aA==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@tauri-apps/api": {
      "version": "2.9.1",
      "resolved": "https://registry.npmjs.org/@tauri-apps/api/-/api-2.9.1.tgz",
      "integrity": "sha512-IGlhP6EivjXHepbBic618GOmiWe4URJiIeZFlB7x3czM0yDHHYviH1Xvoiv4FefdkQtn6v7TuwWCRfOGdnVUGw==",
      "license": "Apache-2.0 OR MIT",
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/tauri"
      }
    },
    "node_modules/@tauri-apps/cli": {
      "version": "2.7.1",
      "resolved": "https://registry.npmjs.org/@tauri-apps/cli/-/cli-2.7.1.tgz",
      "integrity": "sha512-RcGWR4jOUEl92w3uvI0h61Llkfj9lwGD1iwvDRD2isMrDhOzjeeeVn9aGzeW1jubQ/kAbMYfydcA4BA0Cy733Q==",
      "dev": true,
      "license": "Apache-2.0 OR MIT",
      "bin": {
        "tauri": "tauri.js"
      },
      "engines": {
        "node": ">= 10"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/tauri"
      },
      "optionalDependencies": {
        "@tauri-apps/cli-darwin-arm64": "2.7.1",
        "@tauri-apps/cli-darwin-x64": "2.7.1",
        "@tauri-apps/cli-linux-arm-gnueabihf": "2.7.1",
        "@tauri-apps/cli-linux-arm64-gnu": "2.7.1",
        "@tauri-apps/cli-linux-arm64-musl": "2.7.1",
        "@tauri-apps/cli-linux-riscv64-gnu": "2.7.1",
        "@tauri-apps/cli-linux-x64-gnu": "2.7.1",
        "@tauri-apps/cli-linux-x64-musl": "2.7.1",
        "@tauri-apps/cli-win32-arm64-msvc": "2.7.1",
        "@tauri-apps/cli-win32-ia32-msvc": "2.7.1",
        "@tauri-apps/cli-win32-x64-msvc": "2.7.1"
      }
    },
    "node_modules/@tauri-apps/cli-darwin-arm64": {
      "version": "2.7.1",
      "resolved": "https://registry.npmjs.org/@tauri-apps/cli-darwin-arm64/-/cli-darwin-arm64-2.7.1.tgz",
      "integrity": "sha512-j2NXQN6+08G03xYiyKDKqbCV2Txt+hUKg0a8hYr92AmoCU8fgCjHyva/p16lGFGUG3P2Yu0xiNe1hXL9ZuRMzA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "Apache-2.0 OR MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tauri-apps/cli-darwin-x64": {
      "version": "2.7.1",
      "resolved": "https://registry.npmjs.org/@tauri-apps/cli-darwin-x64/-/cli-darwin-x64-2.7.1.tgz",
      "integrity": "sha512-CdYAefeM35zKsc91qIyKzbaO7FhzTyWKsE8hj7tEJ1INYpoh1NeNNyL/NSEA3Nebi5ilugioJ5tRK8ZXG8y3gw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "Apache-2.0 OR MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tauri-apps/cli-linux-arm-gnueabihf": {
      "version": "2.7.1",
      "resolved": "https://registry.npmjs.org/@tauri-apps/cli-linux-arm-gnueabihf/-/cli-linux-arm-gnueabihf-2.7.1.tgz",
      "integrity": "sha512-dnvyJrTA1UJxJjQ8q1N/gWomjP8Twij1BUQu2fdcT3OPpqlrbOk5R1yT0oD/721xoKNjroB5BXCsmmlykllxNg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "Apache-2.0 OR MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tauri-apps/cli-linux-arm64-gnu": {
      "version": "2.7.1",
      "resolved": "https://registry.npmjs.org/@tauri-apps/cli-linux-arm64-gnu/-/cli-linux-arm64-gnu-2.7.1.tgz",
      "integrity": "sha512-FtBW6LJPNRTws3qyUc294AqCWU91l/H0SsFKq6q4Q45MSS4x6wxLxou8zB53tLDGEPx3JSoPLcDaSfPlSbyujQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "Apache-2.0 OR MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tauri-apps/cli-linux-arm64-musl": {
      "version": "2.7.1",
      "resolved": "https://registry.npmjs.org/@tauri-apps/cli-linux-arm64-musl/-/cli-linux-arm64-musl-2.7.1.tgz",
      "integrity": "sha512-/HXY0t4FHkpFzjeYS5c16mlA6z0kzn5uKLWptTLTdFSnYpr8FCnOP4Sdkvm2TDQPF2ERxXtNCd+WR/jQugbGnA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "Apache-2.0 OR MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tauri-apps/cli-linux-riscv64-gnu": {
      "version": "2.7.1",
      "resolved": "https://registry.npmjs.org/@tauri-apps/cli-linux-riscv64-gnu/-/cli-linux-riscv64-gnu-2.7.1.tgz",
      "integrity": "sha512-GeW5lVI2GhhnaYckiDzstG2j2Jwlud5d2XefRGwlOK+C/bVGLT1le8MNPYK8wgRlpeK8fG1WnJJYD6Ke7YQ8bg==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "Apache-2.0 OR MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tauri-apps/cli-linux-x64-gnu": {
      "version": "2.7.1",
      "resolved": "https://registry.npmjs.org/@tauri-apps/cli-linux-x64-gnu/-/cli-linux-x64-gnu-2.7.1.tgz",
      "integrity": "sha512-DprxKQkPxIPYwUgg+cscpv2lcIUhn2nxEPlk0UeaiV9vATxCXyytxr1gLcj3xgjGyNPlM0MlJyYaPy1JmRg1cA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "Apache-2.0 OR MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tauri-apps/cli-linux-x64-musl": {
      "version": "2.7.1",
      "resolved": "https://registry.npmjs.org/@tauri-apps/cli-linux-x64-musl/-/cli-linux-x64-musl-2.7.1.tgz",
      "integrity": "sha512-KLlq3kOK7OUyDR757c0zQjPULpGZpLhNB0lZmZpHXvoOUcqZoCXJHh4dT/mryWZJp5ilrem5l8o9ngrDo0X1AA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "Apache-2.0 OR MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tauri-apps/cli-win32-arm64-msvc": {
      "version": "2.7.1",
      "resolved": "https://registry.npmjs.org/@tauri-apps/cli-win32-arm64-msvc/-/cli-win32-arm64-msvc-2.7.1.tgz",
      "integrity": "sha512-dH7KUjKkSypCeWPiainHyXoES3obS+JIZVoSwSZfKq2gWgs48FY3oT0hQNYrWveE+VR4VoR3b/F3CPGbgFvksA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "Apache-2.0 OR MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tauri-apps/cli-win32-ia32-msvc": {
      "version": "2.7.1",
      "resolved": "https://registry.npmjs.org/@tauri-apps/cli-win32-ia32-msvc/-/cli-win32-ia32-msvc-2.7.1.tgz",
      "integrity": "sha512-1oeibfyWQPVcijOrTg709qhbXArjX3x1MPjrmA5anlygwrbByxLBcLXvotcOeULFcnH2FYUMMLLant8kgvwE5A==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "Apache-2.0 OR MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tauri-apps/cli-win32-x64-msvc": {
      "version": "2.7.1",
      "resolved": "https://registry.npmjs.org/@tauri-apps/cli-win32-x64-msvc/-/cli-win32-x64-msvc-2.7.1.tgz",
      "integrity": "sha512-D7Q9kDObutuirCNLxYQ7KAg2Xxg99AjcdYz/KuMw5HvyEPbkC9Q7JL0vOrQOrHEHxIQ2lYzFOZvKKoC2yyqXcg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "Apache-2.0 OR MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tauri-apps/plugin-opener": {
      "version": "2.4.0",
      "resolved": "https://registry.npmjs.org/@tauri-apps/plugin-opener/-/plugin-opener-2.4.0.tgz",
      "integrity": "sha512-43VyN8JJtvKWJY72WI/KNZszTpDpzHULFxQs0CJBIYUdCRowQ6Q1feWTDb979N7nldqSuDOaBupZ6wz2nvuWwQ==",
      "license": "MIT OR Apache-2.0",
      "dependencies": {
        "@tauri-apps/api": "^2.6.0"
      }
    },
    "node_modules/@tauri-apps/plugin-shell": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/@tauri-apps/plugin-shell/-/plugin-shell-2.3.3.tgz",
      "integrity": "sha512-Xod+pRcFxmOWFWEnqH5yZcA7qwAMuaaDkMR1Sply+F8VfBj++CGnj2xf5UoialmjZ2Cvd8qrvSCbU+7GgNVsKQ==",
      "license": "MIT OR Apache-2.0",
      "dependencies": {
        "@tauri-apps/api": "^2.8.0"
      }
    },
    "node_modules/@types/babel__core": {
      "version": "7.20.5",
      "resolved": "https://registry.npmjs.org/@types/babel__core/-/babel__core-7.20.5.tgz",
      "integrity": "sha512-qoQprZvz5wQFJwMDqeseRXWv3rqMvhgpbXFfVyWhbx9X47POIA6i/+dXefEmZKoAgOaTdaIgNSMqMIU61yRyzA==",
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.20.7",
        "@babel/types": "^7.20.7",
        "@types/babel__generator": "*",
        "@types/babel__template": "*",
        "@types/babel__traverse": "*"
      }
    },
    "node_modules/@types/babel__generator": {
      "version": "7.27.0",
      "resolved": "https://registry.npmjs.org/@types/babel__generator/-/babel__generator-7.27.0.tgz",
      "integrity": "sha512-ufFd2Xi92OAVPYsy+P4n7/U7e68fex0+Ee8gSG9KX7eo084CWiQ4sdxktvdl0bOPupXtVJPY19zk6EwWqUQ8lg==",
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__template": {
      "version": "7.4.4",
      "resolved": "https://registry.npmjs.org/@types/babel__template/-/babel__template-7.4.4.tgz",
      "integrity": "sha512-h/NUaSyG5EyxBIp8YRxo4RMe2/qQgvyowRwVMzhYhBCONbW8PUsg4lkFMrhgZhUe5z3L3MiLDuvyJ/CaPa2A8A==",
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.1.0",
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__traverse": {
      "version": "7.20.7",
      "resolved": "https://registry.npmjs.org/@types/babel__traverse/-/babel__traverse-7.20.7.tgz",
      "integrity": "sha512-dkO5fhS7+/oos4ciWxyEyjWe48zmG6wbCheo/G2ZnHx4fs3EU6YC6UM8rk56gAjNJ9P3MTH2jo5jb92/K6wbng==",
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.20.7"
      }
    },
    "node_modules/@types/crypto-js": {
      "version": "4.2.2",
      "resolved": "https://registry.npmjs.org/@types/crypto-js/-/crypto-js-4.2.2.tgz",
      "integrity": "sha512-sDOLlVbHhXpAUAL0YHDUUwDZf3iN4Bwi4W6a0W0b+QcAezUbRtH4FVb+9J4h+XFPW7l/gQ9F8qC7P+Ec4k8QVQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/estree": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.8.tgz",
      "integrity": "sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==",
      "license": "MIT"
    },
    "node_modules/@types/history": {
      "version": "4.7.11",
      "resolved": "https://registry.npmjs.org/@types/history/-/history-4.7.11.tgz",
      "integrity": "sha512-qjDJRrmvBMiTx+jyLxvLfJU7UznFuokDv4f3WRuriHKERccVpFU+8XMQUAbDzoiJCsmexxRExQeMwwCdamSKDA==",
      "license": "MIT"
    },
    "node_modules/@types/parse-json": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/@types/parse-json/-/parse-json-4.0.2.tgz",
      "integrity": "sha512-dISoDXWWQwUquiKsyZ4Ng+HX2KsPL7LyHKHQwgGFEA3IaKac4Obd+h2a/a6waisAoepJlBcx9paWqjA8/HVjCw==",
      "license": "MIT"
    },
    "node_modules/@types/prismjs": {
      "version": "1.26.5",
      "resolved": "https://registry.npmjs.org/@types/prismjs/-/prismjs-1.26.5.tgz",
      "integrity": "sha512-AUZTa7hQ2KY5L7AmtSiqxlhWxb4ina0yd8hNbl4TWuqnv/pFP0nDMb3YrfSBf4hJVGLh2YEIBfKaBW/9UEl6IQ==",
      "license": "MIT"
    },
    "node_modules/@types/prop-types": {
      "version": "15.7.15",
      "resolved": "https://registry.npmjs.org/@types/prop-types/-/prop-types-15.7.15.tgz",
      "integrity": "sha512-F6bEyamV9jKGAFBEmlQnesRPGOQqS2+Uwi0Em15xenOxHaf2hv6L8YCVn3rPdPJOiJfPiCnLIRyvwVaqMY3MIw==",
      "license": "MIT"
    },
    "node_modules/@types/react": {
      "version": "19.1.8",
      "resolved": "https://registry.npmjs.org/@types/react/-/react-19.1.8.tgz",
      "integrity": "sha512-AwAfQ2Wa5bCx9WP8nZL2uMZWod7J7/JSplxbTmBQ5ms6QpqNYm672H0Vu9ZVKVngQ+ii4R/byguVEUZQyeg44g==",
      "license": "MIT",
      "dependencies": {
        "csstype": "^3.0.2"
      }
    },
    "node_modules/@types/react-dom": {
      "version": "19.1.6",
      "resolved": "https://registry.npmjs.org/@types/react-dom/-/react-dom-19.1.6.tgz",
      "integrity": "sha512-4hOiT/dwO8Ko0gV1m/TJZYk3y0KBnY9vzDh7W+DH17b2HFSOGgdj33dhihPeuy3l0q23+4e+hoXHV6hCC4dCXw==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "^19.0.0"
      }
    },
    "node_modules/@types/react-router": {
      "version": "5.1.20",
      "resolved": "https://registry.npmjs.org/@types/react-router/-/react-router-5.1.20.tgz",
      "integrity": "sha512-jGjmu/ZqS7FjSH6owMcD5qpq19+1RS9DeVRqfl1FeBMxTDQAGwlMWOcs52NDoXaNKyG3d1cYQFMs9rCrb88o9Q==",
      "license": "MIT",
      "dependencies": {
        "@types/history": "^4.7.11",
        "@types/react": "*"
      }
    },
    "node_modules/@types/react-router-dom": {
      "version": "5.3.3",
      "resolved": "https://registry.npmjs.org/@types/react-router-dom/-/react-router-dom-5.3.3.tgz",
      "integrity": "sha512-kpqnYK4wcdm5UaWI3fLcELopqLrHgLqNsdpHauzlQktfkHL3npOSwtj1Uz9oKBAzs7lFtVkV8j83voAz2D8fhw==",
      "license": "MIT",
      "dependencies": {
        "@types/history": "^4.7.11",
        "@types/react": "*",
        "@types/react-router": "*"
      }
    },
    "node_modules/@types/react-transition-group": {
      "version": "4.4.12",
      "resolved": "https://registry.npmjs.org/@types/react-transition-group/-/react-transition-group-4.4.12.tgz",
      "integrity": "sha512-8TV6R3h2j7a91c+1DXdJi3Syo69zzIZbz7Lg5tORM5LEJG7X/E6a1V3drRyBRZq7/utz7A+c4OgYLiLcYGHG6w==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*"
      }
    },
    "node_modules/@types/react-window": {
      "version": "1.8.8",
      "resolved": "https://registry.npmjs.org/@types/react-window/-/react-window-1.8.8.tgz",
      "integrity": "sha512-8Ls660bHR1AUA2kuRvVG9D/4XpRC6wjAaPT9dil7Ckc76eP9TKWZwwmgfq8Q1LANX3QNDnoU4Zp48A3w+zK69Q==",
      "license": "MIT",
      "dependencies": {
        "@types/react": "*"
      }
    },
    "node_modules/@types/xterm": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/@types/xterm/-/xterm-2.0.3.tgz",
      "integrity": "sha512-Owlz29ThHtn2RQry87juaNYeIc4Dr8ykLLX0JKKt4SdO6ujwJnsXCpBAr6bwo/f4L3xSfM9KA7OnPPf9Xit6tA==",
      "license": "MIT"
    },
    "node_modules/@vitejs/plugin-react": {
      "version": "4.7.0",
      "resolved": "https://registry.npmjs.org/@vitejs/plugin-react/-/plugin-react-4.7.0.tgz",
      "integrity": "sha512-gUu9hwfWvvEDBBmgtAowQCojwZmJ5mcLn3aufeCsitijs3+f2NsrPtlAWIR6OPiqljl96GVCUbLe0HyqIpVaoA==",
      "license": "MIT",
      "dependencies": {
        "@babel/core": "^7.28.0",
        "@babel/plugin-transform-react-jsx-self": "^7.27.1",
        "@babel/plugin-transform-react-jsx-source": "^7.27.1",
        "@rolldown/pluginutils": "1.0.0-beta.27",
        "@types/babel__core": "^7.20.5",
        "react-refresh": "^0.17.0"
      },
      "engines": {
        "node": "^14.18.0 || >=16.0.0"
      },
      "peerDependencies": {
        "vite": "^4.2.0 || ^5.0.0 || ^6.0.0 || ^7.0.0"
      }
    },
    "node_modules/@xterm/addon-fit": {
      "version": "0.10.0",
      "resolved": "https://registry.npmjs.org/@xterm/addon-fit/-/addon-fit-0.10.0.tgz",
      "integrity": "sha512-UFYkDm4HUahf2lnEyHvio51TNGiLK66mqP2JoATy7hRZeXaGMRDr00JiSF7m63vR5WKATF605yEggJKsw0JpMQ==",
      "license": "MIT",
      "peerDependencies": {
        "@xterm/xterm": "^5.0.0"
      }
    },
    "node_modules/@xterm/xterm": {
      "version": "5.5.0",
      "resolved": "https://registry.npmjs.org/@xterm/xterm/-/xterm-5.5.0.tgz",
      "integrity": "sha512-hqJHYaQb5OptNunnyAnkHyM8aCjZ1MEIDTQu1iIbbTD/xops91NB5yq1ZK/dC2JDbVWtF23zUtl9JE2NqwT87A==",
      "license": "MIT"
    },
    "node_modules/babel-plugin-macros": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/babel-plugin-macros/-/babel-plugin-macros-3.1.0.tgz",
      "integrity": "sha512-Cg7TFGpIr01vOQNODXOOaGz2NpCU5gl8x1qJFbb6hbZxR7XrcE2vtbAsTAbJ7/xwJtUuJEw8K8Zr/AE0LHlesg==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.12.5",
        "cosmiconfig": "^7.0.0",
        "resolve": "^1.19.0"
      },
      "engines": {
        "node": ">=10",
        "npm": ">=6"
      }
    },
    "node_modules/browserslist": {
      "version": "4.25.1",
      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.25.1.tgz",
      "integrity": "sha512-KGj0KoOMXLpSNkkEI6Z6mShmQy0bc1I+T7K9N81k4WWMrfz+6fQ6es80B/YLAeRoKvjYE1YSHHOW1qe9xIVzHw==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "caniuse-lite": "^1.0.30001726",
        "electron-to-chromium": "^1.5.173",
        "node-releases": "^2.0.19",
        "update-browserslist-db": "^1.1.3"
      },
      "bin": {
        "browserslist": "cli.js"
      },
      "engines": {
        "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
      }
    },
    "node_modules/callsites": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
      "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/caniuse-lite": {
      "version": "1.0.30001727",
      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001727.tgz",
      "integrity": "sha512-pB68nIHmbN6L/4C6MH1DokyR3bYqFwjaSs/sWDHGj4CTcFtQUQMuJftVwWkXq7mNWOybD3KhUv3oWHoGxgP14Q==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "CC-BY-4.0"
    },
    "node_modules/clsx": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/clsx/-/clsx-2.1.1.tgz",
      "integrity": "sha512-eYm0QWBtUrBWZWG0d386OGAw16Z995PiOVo2B7bjWSbHedGl5e0ZWaq65kOGgUSNesEIDkB9ISbTg/JK9dhCZA==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/convert-source-map": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-2.0.0.tgz",
      "integrity": "sha512-Kvp459HrV2FEJ1CAsi1Ku+MY3kasH19TFykTz2xWmMeq6bk2NU3XXvfJ+Q61m0xktWwt+1HSYf3JZsTms3aRJg==",
      "license": "MIT"
    },
    "node_modules/cookie": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-1.1.1.tgz",
      "integrity": "sha512-ei8Aos7ja0weRpFzJnEA9UHJ/7XQmqglbRwnf2ATjcB9Wq874VKH9kfjjirM6UhU2/E5fFYadylyhFldcqSidQ==",
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/cosmiconfig": {
      "version": "7.1.0",
      "resolved": "https://registry.npmjs.org/cosmiconfig/-/cosmiconfig-7.1.0.tgz",
      "integrity": "sha512-AdmX6xUzdNASswsFtmwSt7Vj8po9IuqXm0UXz7QKPuEUmPB4XyjGfaAr2PSuELMwkRMVH1EpIkX5bTZGRB3eCA==",
      "license": "MIT",
      "dependencies": {
        "@types/parse-json": "^4.0.0",
        "import-fresh": "^3.2.1",
        "parse-json": "^5.0.0",
        "path-type": "^4.0.0",
        "yaml": "^1.10.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/cosmiconfig/node_modules/yaml": {
      "version": "1.10.2",
      "resolved": "https://registry.npmjs.org/yaml/-/yaml-1.10.2.tgz",
      "integrity": "sha512-r3vXyErRCYJ7wg28yvBY5VSoAF8ZvlcW9/BwUzEtUsjvX/DKs24dIkuwjtuprwJJHsbyUbLApepYTR1BN4uHrg==",
      "license": "ISC",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/crypto-js": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/crypto-js/-/crypto-js-4.2.0.tgz",
      "integrity": "sha512-KALDyEYgpY+Rlob/iriUtjV6d5Eq+Y191A5g4UqLAi8CyGP9N1+FdVbkc1SxKc2r4YAYqG8JzO2KGL+AizD70Q==",
      "license": "MIT"
    },
    "node_modules/csstype": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/csstype/-/csstype-3.1.3.tgz",
      "integrity": "sha512-M1uQkMl8rQK/szD0LNhtqxIPLpimGm8sOBwU7lLnCpSbTyY3yeU1Vc7l4KT5zT4s/yOxHH5O7tIuuLOCnLADRw==",
      "license": "MIT"
    },
    "node_modules/debug": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.1.tgz",
      "integrity": "sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/dom-helpers": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/dom-helpers/-/dom-helpers-5.2.1.tgz",
      "integrity": "sha512-nRCa7CK3VTrM2NmGkIy4cbK7IZlgBE/PYMn55rrXefr5xXDP0LdtfPnblFDoVdcAfslJ7or6iqAUnx0CCGIWQA==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.8.7",
        "csstype": "^3.0.2"
      }
    },
    "node_modules/electron-to-chromium": {
      "version": "1.5.190",
      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.190.tgz",
      "integrity": "sha512-k4McmnB2091YIsdCgkS0fMVMPOJgxl93ltFzaryXqwip1AaxeDqKCGLxkXODDA5Ab/D+tV5EL5+aTx76RvLRxw==",
      "license": "ISC"
    },
    "node_modules/error-ex": {
      "version": "1.3.2",
      "resolved": "https://registry.npmjs.org/error-ex/-/error-ex-1.3.2.tgz",
      "integrity": "sha512-7dFHNmqeFSEt2ZBsCriorKnn3Z2pj+fd9kmI6QoWw4//DL+icEBfc0U7qJCisqrTsKTjw4fNFy2pW9OqStD84g==",
      "license": "MIT",
      "dependencies": {
        "is-arrayish": "^0.2.1"
      }
    },
    "node_modules/esbuild": {
      "version": "0.25.8",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.25.8.tgz",
      "integrity": "sha512-vVC0USHGtMi8+R4Kz8rt6JhEWLxsv9Rnu/lGYbPR8u47B+DCBksq9JarW0zOO7bs37hyOK1l2/oqtbciutL5+Q==",
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=18"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.25.8",
        "@esbuild/android-arm": "0.25.8",
        "@esbuild/android-arm64": "0.25.8",
        "@esbuild/android-x64": "0.25.8",
        "@esbuild/darwin-arm64": "0.25.8",
        "@esbuild/darwin-x64": "0.25.8",
        "@esbuild/freebsd-arm64": "0.25.8",
        "@esbuild/freebsd-x64": "0.25.8",
        "@esbuild/linux-arm": "0.25.8",
        "@esbuild/linux-arm64": "0.25.8",
        "@esbuild/linux-ia32": "0.25.8",
        "@esbuild/linux-loong64": "0.25.8",
        "@esbuild/linux-mips64el": "0.25.8",
        "@esbuild/linux-ppc64": "0.25.8",
        "@esbuild/linux-riscv64": "0.25.8",
        "@esbuild/linux-s390x": "0.25.8",
        "@esbuild/linux-x64": "0.25.8",
        "@esbuild/netbsd-arm64": "0.25.8",
        "@esbuild/netbsd-x64": "0.25.8",
        "@esbuild/openbsd-arm64": "0.25.8",
        "@esbuild/openbsd-x64": "0.25.8",
        "@esbuild/openharmony-arm64": "0.25.8",
        "@esbuild/sunos-x64": "0.25.8",
        "@esbuild/win32-arm64": "0.25.8",
        "@esbuild/win32-ia32": "0.25.8",
        "@esbuild/win32-x64": "0.25.8"
      }
    },
    "node_modules/escalade": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/escape-string-regexp": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
      "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/fdir": {
      "version": "6.4.6",
      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.4.6.tgz",
      "integrity": "sha512-hiFoqpyZcfNm1yc4u8oWCf9A2c4D3QjCrks3zmoVKVxpQRzmPNar1hUJcBG2RQHvEVGDN+Jm81ZheVLAQMK6+w==",
      "license": "MIT",
      "peerDependencies": {
        "picomatch": "^3 || ^4"
      },
      "peerDependenciesMeta": {
        "picomatch": {
          "optional": true
        }
      }
    },
    "node_modules/find-root": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/find-root/-/find-root-1.1.0.tgz",
      "integrity": "sha512-NKfW6bec6GfKc0SGx1e07QZY9PE99u0Bft/0rzSD5k3sO/vwkVUpDUKVm5Gpp5Ue3YfShPFTX2070tDs5kB9Ng==",
      "license": "MIT"
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/gensync": {
      "version": "1.0.0-beta.2",
      "resolved": "https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.2.tgz",
      "integrity": "sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/hoist-non-react-statics": {
      "version": "3.3.2",
      "resolved": "https://registry.npmjs.org/hoist-non-react-statics/-/hoist-non-react-statics-3.3.2.tgz",
      "integrity": "sha512-/gGivxi8JPKWNm/W0jSmzcMPpfpPLc3dY/6GxhX2hQ9iGj3aDfklV4ET7NjKpSinLpJ5vafa9iiGIEZg10SfBw==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "react-is": "^16.7.0"
      }
    },
    "node_modules/hoist-non-react-statics/node_modules/react-is": {
      "version": "16.13.1",
      "resolved": "https://registry.npmjs.org/react-is/-/react-is-16.13.1.tgz",
      "integrity": "sha512-24e6ynE2H+OKt4kqsOvNd8kBpV65zoxbA4BVsEOB3ARVWQki/DHzaUoC5KuON/BiccDaCCTZBuOcfZs70kR8bQ==",
      "license": "MIT"
    },
    "node_modules/import-fresh": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.1.tgz",
      "integrity": "sha512-TR3KfrTZTYLPB6jUjfx6MF9WcWrHL9su5TObK4ZkYgBdWKPOFoSoQIdEuTuR82pmtxH2spWG9h6etwfr1pLBqQ==",
      "license": "MIT",
      "dependencies": {
        "parent-module": "^1.0.0",
        "resolve-from": "^4.0.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/is-arrayish": {
      "version": "0.2.1",
      "resolved": "https://registry.npmjs.org/is-arrayish/-/is-arrayish-0.2.1.tgz",
      "integrity": "sha512-zz06S8t0ozoDXMG+ube26zeCTNXcKIPJZJi8hBrF4idCLms4CG9QtK7qBl1boi5ODzFpjswb5JPmHCbMpjaYzg==",
      "license": "MIT"
    },
    "node_modules/is-core-module": {
      "version": "2.16.1",
      "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.16.1.tgz",
      "integrity": "sha512-UfoeMA6fIJ8wTYFEUjelnaGI67v6+N7qXJEvQuIGa99l4xsCruSYOVSQ0uPANn4dAzm8lkYPaKLrrijLq7x23w==",
      "license": "MIT",
      "dependencies": {
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
      "license": "MIT"
    },
    "node_modules/jsesc": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-3.1.0.tgz",
      "integrity": "sha512-/sM3dO2FOzXjKQhJuo0Q173wf2KOo8t4I8vHy6lF9poUp7bKT0/NHE8fPX23PwfhnykfqnC2xRxOnVw5XuGIaA==",
      "license": "MIT",
      "bin": {
        "jsesc": "bin/jsesc"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/json-parse-even-better-errors": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/json-parse-even-better-errors/-/json-parse-even-better-errors-2.3.1.tgz",
      "integrity": "sha512-xyFwyhro/JEof6Ghe2iz2NcXoj2sloNsWr/XsERDK/oiPCfaNhl5ONfp+jQdAZRQQ0IJWNzH9zIZF7li91kh2w==",
      "license": "MIT"
    },
    "node_modules/json5": {
      "version": "2.2.3",
      "resolved": "https://registry.npmjs.org/json5/-/json5-2.2.3.tgz",
      "integrity": "sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==",
      "license": "MIT",
      "bin": {
        "json5": "lib/cli.js"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/lines-and-columns": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/lines-and-columns/-/lines-and-columns-1.2.4.tgz",
      "integrity": "sha512-7ylylesZQ/PV29jhEDl3Ufjo6ZX7gCqJr5F7PKrqc93v7fzSymt1BpwEU8nAUXs8qzzvqhbjhK5QZg6Mt/HkBg==",
      "license": "MIT"
    },
    "node_modules/loose-envify": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/loose-envify/-/loose-envify-1.4.0.tgz",
      "integrity": "sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==",
      "license": "MIT",
      "dependencies": {
        "js-tokens": "^3.0.0 || ^4.0.0"
      },
      "bin": {
        "loose-envify": "cli.js"
      }
    },
    "node_modules/lru-cache": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz",
      "integrity": "sha512-KpNARQA3Iwv+jTA0utUVVbrh+Jlrr1Fv0e56GGzAFOXN7dk/FviaDW8LHmK52DlcH4WP2n6gI8vN1aesBFgo9w==",
      "license": "ISC",
      "dependencies": {
        "yallist": "^3.0.2"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/node-releases": {
      "version": "2.0.19",
      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.19.tgz",
      "integrity": "sha512-xxOWJsBKtzAq7DY0J+DTzuz58K8e7sJbdgwkbMWQe8UYB6ekmsQ45q0M/tJDsGaZmbC+l7n57UV8Hl5tHxO9uw==",
      "license": "MIT"
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/parent-module": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
      "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
      "license": "MIT",
      "dependencies": {
        "callsites": "^3.0.0"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/parse-json": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/parse-json/-/parse-json-5.2.0.tgz",
      "integrity": "sha512-ayCKvm/phCGxOkYRSCM82iDwct8/EonSEgCSxWxD7ve6jHggsFl4fZVQBPRNgQoKiuV/odhFrGzQXZwbifC8Rg==",
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.0.0",
        "error-ex": "^1.3.1",
        "json-parse-even-better-errors": "^2.3.0",
        "lines-and-columns": "^1.1.6"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/path-parse": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz",
      "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==",
      "license": "MIT"
    },
    "node_modules/path-type": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz",
      "integrity": "sha512-gDKb8aZMDeD/tZWs9P6+q0J9Mwkdl6xMV8TjnGP3qJVJ06bdMgkbBlLU8IdfOsIsFz2BW1rNVT3XuNEl8zPAvw==",
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "license": "ISC"
    },
    "node_modules/picomatch": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/postcss": {
      "version": "8.5.6",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.6.tgz",
      "integrity": "sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.11",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/prettier": {
      "version": "3.6.2",
      "resolved": "https://registry.npmjs.org/prettier/-/prettier-3.6.2.tgz",
      "integrity": "sha512-I7AIg5boAr5R0FFtJ6rCfD+LFsWHp81dolrFD8S79U9tb8Az2nGrJncnMSnys+bpQJfRUzqs9hnA81OAA3hCuQ==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "prettier": "bin/prettier.cjs"
      },
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/prettier/prettier?sponsor=1"
      }
    },
    "node_modules/prismjs": {
      "version": "1.30.0",
      "resolved": "https://registry.npmjs.org/prismjs/-/prismjs-1.30.0.tgz",
      "integrity": "sha512-DEvV2ZF2r2/63V+tK8hQvrR2ZGn10srHbXviTlcv7Kpzw8jWiNTqbVgjO3IY8RxrrOUF8VPMQQFysYYYv0YZxw==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/prop-types": {
      "version": "15.8.1",
      "resolved": "https://registry.npmjs.org/prop-types/-/prop-types-15.8.1.tgz",
      "integrity": "sha512-oj87CgZICdulUohogVAR7AjlC0327U4el4L6eAvOqCeudMDVU0NThNaV+b9Df4dXgSP1gXMTnPdhfe/2qDH5cg==",
      "license": "MIT",
      "dependencies": {
        "loose-envify": "^1.4.0",
        "object-assign": "^4.1.1",
        "react-is": "^16.13.1"
      }
    },
    "node_modules/prop-types/node_modules/react-is": {
      "version": "16.13.1",
      "resolved": "https://registry.npmjs.org/react-is/-/react-is-16.13.1.tgz",
      "integrity": "sha512-24e6ynE2H+OKt4kqsOvNd8kBpV65zoxbA4BVsEOB3ARVWQki/DHzaUoC5KuON/BiccDaCCTZBuOcfZs70kR8bQ==",
      "license": "MIT"
    },
    "node_modules/react": {
      "version": "19.1.0",
      "resolved": "https://registry.npmjs.org/react/-/react-19.1.0.tgz",
      "integrity": "sha512-FS+XFBNvn3GTAWq26joslQgWNoFu08F4kl0J4CgdNKADkdSGXQyTCnKteIAJy96Br6YbpEU1LSzV5dYtjMkMDg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-dom": {
      "version": "19.1.0",
      "resolved": "https://registry.npmjs.org/react-dom/-/react-dom-19.1.0.tgz",
      "integrity": "sha512-Xs1hdnE+DyKgeHJeJznQmYMIBG3TKIHJJT95Q58nHLSrElKlGQqDTR2HQ9fx5CN/Gk6Vh/kupBTDLU11/nDk/g==",
      "license": "MIT",
      "dependencies": {
        "scheduler": "^0.26.0"
      },
      "peerDependencies": {
        "react": "^19.1.0"
      }
    },
    "node_modules/react-is": {
      "version": "19.1.0",
      "resolved": "https://registry.npmjs.org/react-is/-/react-is-19.1.0.tgz",
      "integrity": "sha512-Oe56aUPnkHyyDxxkvqtd7KkdQP5uIUfHxd5XTb3wE9d/kRnZLmKbDB0GWk919tdQ+mxxPtG6EAs6RMT6i1qtHg==",
      "license": "MIT"
    },
    "node_modules/react-refresh": {
      "version": "0.17.0",
      "resolved": "https://registry.npmjs.org/react-refresh/-/react-refresh-0.17.0.tgz",
      "integrity": "sha512-z6F7K9bV85EfseRCp2bzrpyQ0Gkw1uLoCel9XBVWPg/TjRj94SkJzUTGfOa4bs7iJvBWtQG0Wq7wnI0syw3EBQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-router": {
      "version": "7.12.0",
      "resolved": "https://registry.npmjs.org/react-router/-/react-router-7.12.0.tgz",
      "integrity": "sha512-kTPDYPFzDVGIIGNLS5VJykK0HfHLY5MF3b+xj0/tTyNYL1gF1qs7u67Z9jEhQk2sQ98SUaHxlG31g1JtF7IfVw==",
      "license": "MIT",
      "dependencies": {
        "cookie": "^1.0.1",
        "set-cookie-parser": "^2.6.0"
      },
      "engines": {
        "node": ">=20.0.0"
      },
      "peerDependencies": {
        "react": ">=18",
        "react-dom": ">=18"
      },
      "peerDependenciesMeta": {
        "react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/react-router-dom": {
      "version": "7.12.0",
      "resolved": "https://registry.npmjs.org/react-router-dom/-/react-router-dom-7.12.0.tgz",
      "integrity": "sha512-pfO9fiBcpEfX4Tx+iTYKDtPbrSLLCbwJ5EqP+SPYQu1VYCXdy79GSj0wttR0U4cikVdlImZuEZ/9ZNCgoaxwBA==",
      "license": "MIT",
      "dependencies": {
        "react-router": "7.12.0"
      },
      "engines": {
        "node": ">=20.0.0"
      },
      "peerDependencies": {
        "react": ">=18",
        "react-dom": ">=18"
      }
    },
    "node_modules/react-simple-code-editor": {
      "version": "0.14.1",
      "resolved": "https://registry.npmjs.org/react-simple-code-editor/-/react-simple-code-editor-0.14.1.tgz",
      "integrity": "sha512-BR5DtNRy+AswWJECyA17qhUDvrrCZ6zXOCfkQY5zSmb96BVUbpVAv03WpcjcwtCwiLbIANx3gebHOcXYn1EHow==",
      "license": "MIT",
      "peerDependencies": {
        "react": ">=16.8.0",
        "react-dom": ">=16.8.0"
      }
    },
    "node_modules/react-transition-group": {
      "version": "4.4.5",
      "resolved": "https://registry.npmjs.org/react-transition-group/-/react-transition-group-4.4.5.tgz",
      "integrity": "sha512-pZcd1MCJoiKiBR2NRxeCRg13uCXbydPnmB4EOeRrY7480qNWO8IIgQG6zlDkm6uRMsURXPuKq0GWtiM59a5Q6g==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@babel/runtime": "^7.5.5",
        "dom-helpers": "^5.0.1",
        "loose-envify": "^1.4.0",
        "prop-types": "^15.6.2"
      },
      "peerDependencies": {
        "react": ">=16.6.0",
        "react-dom": ">=16.6.0"
      }
    },
    "node_modules/react-window": {
      "version": "2.2.3",
      "resolved": "https://registry.npmjs.org/react-window/-/react-window-2.2.3.tgz",
      "integrity": "sha512-gTRqQYC8ojbiXyd9duYFiSn2TJw0ROXCgYjenOvNKITWzK0m0eCvkUsEUM08xvydkMh7ncp+LE0uS3DeNGZxnQ==",
      "license": "MIT",
      "peerDependencies": {
        "react": "^18.0.0 || ^19.0.0",
        "react-dom": "^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/resolve": {
      "version": "1.22.10",
      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.22.10.tgz",
      "integrity": "sha512-NPRy+/ncIMeDlTAsuqwKIiferiawhefFJtkNSW0qZJEqMEb+qBt/77B/jGeeek+F0uOeN05CDa6HXbbIgtVX4w==",
      "license": "MIT",
      "dependencies": {
        "is-core-module": "^2.16.0",
        "path-parse": "^1.0.7",
        "supports-preserve-symlinks-flag": "^1.0.0"
      },
      "bin": {
        "resolve": "bin/resolve"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/resolve-from": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
      "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/rollup": {
      "version": "4.45.1",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.45.1.tgz",
      "integrity": "sha512-4iya7Jb76fVpQyLoiVpzUrsjQ12r3dM7fIVz+4NwoYvZOShknRmiv+iu9CClZml5ZLGb0XMcYLutK6w9tgxHDw==",
      "license": "MIT",
      "dependencies": {
        "@types/estree": "1.0.8"
      },
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "@rollup/rollup-android-arm-eabi": "4.45.1",
        "@rollup/rollup-android-arm64": "4.45.1",
        "@rollup/rollup-darwin-arm64": "4.45.1",
        "@rollup/rollup-darwin-x64": "4.45.1",
        "@rollup/rollup-freebsd-arm64": "4.45.1",
        "@rollup/rollup-freebsd-x64": "4.45.1",
        "@rollup/rollup-linux-arm-gnueabihf": "4.45.1",
        "@rollup/rollup-linux-arm-musleabihf": "4.45.1",
        "@rollup/rollup-linux-arm64-gnu": "4.45.1",
        "@rollup/rollup-linux-arm64-musl": "4.45.1",
        "@rollup/rollup-linux-loongarch64-gnu": "4.45.1",
        "@rollup/rollup-linux-powerpc64le-gnu": "4.45.1",
        "@rollup/rollup-linux-riscv64-gnu": "4.45.1",
        "@rollup/rollup-linux-riscv64-musl": "4.45.1",
        "@rollup/rollup-linux-s390x-gnu": "4.45.1",
        "@rollup/rollup-linux-x64-gnu": "4.45.1",
        "@rollup/rollup-linux-x64-musl": "4.45.1",
        "@rollup/rollup-win32-arm64-msvc": "4.45.1",
        "@rollup/rollup-win32-ia32-msvc": "4.45.1",
        "@rollup/rollup-win32-x64-msvc": "4.45.1",
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/scheduler": {
      "version": "0.26.0",
      "resolved": "https://registry.npmjs.org/scheduler/-/scheduler-0.26.0.tgz",
      "integrity": "sha512-NlHwttCI/l5gCPR3D1nNXtWABUmBwvZpEQiD4IXSbIDq8BzLIK/7Ir5gTFSGZDUu37K5cMNp0hFtzO38sC7gWA==",
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "6.3.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
      "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      }
    },
    "node_modules/set-cookie-parser": {
      "version": "2.7.2",
      "resolved": "https://registry.npmjs.org/set-cookie-parser/-/set-cookie-parser-2.7.2.tgz",
      "integrity": "sha512-oeM1lpU/UvhTxw+g3cIfxXHyJRc/uidd3yK1P242gzHds0udQBYzs3y8j4gCCW+ZJ7ad0yctld8RYO+bdurlvw==",
      "license": "MIT"
    },
    "node_modules/source-map": {
      "version": "0.5.7",
      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz",
      "integrity": "sha512-LbrmJOMUSdEVxIKvdcJzQC+nQhe8FUZQTXQy6+I75skNgn3OoQ0DZA8YnFa7gp8tqtL3KPf1kmo0R5DoApeSGQ==",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/stylis": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/stylis/-/stylis-4.2.0.tgz",
      "integrity": "sha512-Orov6g6BB1sDfYgzWfTHDOxamtX1bE/zo104Dh9e6fqJ3PooipYyfJ0pUmrZO2wAvO8YbEyeFrkV91XTsGMSrw==",
      "license": "MIT"
    },
    "node_modules/supports-preserve-symlinks-flag": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz",
      "integrity": "sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/tinyglobby": {
      "version": "0.2.14",
      "resolved": "https://registry.npmjs.org/tinyglobby/-/tinyglobby-0.2.14.tgz",
      "integrity": "sha512-tX5e7OM1HnYr2+a2C/4V0htOcSQcoSTH9KgJnVvNm5zm/cyEWKJ7j7YutsH9CxMdtOkkLFy2AHrMci9IM8IPZQ==",
      "license": "MIT",
      "dependencies": {
        "fdir": "^6.4.4",
        "picomatch": "^4.0.2"
      },
      "engines": {
        "node": ">=12.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/SuperchupuDev"
      }
    },
    "node_modules/typescript": {
      "version": "5.6.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.6.3.tgz",
      "integrity": "sha512-hjcS1mhfuyi4WW8IWtjP7brDrG2cuDZukyrYrSauoXGNgx0S7zceP07adYkJycEr56BOUTNPzbInooiN3fn1qw==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/update-browserslist-db": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.1.3.tgz",
      "integrity": "sha512-UxhIZQ+QInVdunkDAaiazvvT/+fXL5Osr0JZlJulepYu6Jd7qJtDZjlur0emRlT71EN3ScPoE7gvsuIKKNavKw==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "escalade": "^3.2.0",
        "picocolors": "^1.1.1"
      },
      "bin": {
        "update-browserslist-db": "cli.js"
      },
      "peerDependencies": {
        "browserslist": ">= 4.21.0"
      }
    },
    "node_modules/vite": {
      "version": "6.4.1",
      "resolved": "https://registry.npmjs.org/vite/-/vite-6.4.1.tgz",
      "integrity": "sha512-+Oxm7q9hDoLMyJOYfUYBuHQo+dkAloi33apOPP56pzj+vsdJDzr+j1NISE5pyaAuKL4A3UD34qd0lx5+kfKp2g==",
      "license": "MIT",
      "dependencies": {
        "esbuild": "^0.25.0",
        "fdir": "^6.4.4",
        "picomatch": "^4.0.2",
        "postcss": "^8.5.3",
        "rollup": "^4.34.9",
        "tinyglobby": "^0.2.13"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^18.0.0 || ^20.0.0 || >=22.0.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      },
      "peerDependencies": {
        "@types/node": "^18.0.0 || ^20.0.0 || >=22.0.0",
        "jiti": ">=1.21.0",
        "less": "*",
        "lightningcss": "^1.21.0",
        "sass": "*",
        "sass-embedded": "*",
        "stylus": "*",
        "sugarss": "*",
        "terser": "^5.16.0",
        "tsx": "^4.8.1",
        "yaml": "^2.4.2"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "jiti": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "sass-embedded": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        },
        "tsx": {
          "optional": true
        },
        "yaml": {
          "optional": true
        }
      }
    },
    "node_modules/xterm": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/xterm/-/xterm-5.3.0.tgz",
      "integrity": "sha512-8QqjlekLUFTrU6x7xck1MsPzPA571K5zNqWm0M0oroYEWVOptZ0+ubQSkQ3uxIEhcIHRujJy6emDWX4A7qyFzg==",
      "deprecated": "This package is now deprecated. Move to @xterm/xterm instead.",
      "license": "MIT"
    },
    "node_modules/xterm-addon-fit": {
      "version": "0.8.0",
      "resolved": "https://registry.npmjs.org/xterm-addon-fit/-/xterm-addon-fit-0.8.0.tgz",
      "integrity": "sha512-yj3Np7XlvxxhYF/EJ7p3KHaMt6OdwQ+HDu573Vx1lRXsVxOcnVJs51RgjZOouIZOczTsskaS+CpXspK81/DLqw==",
      "deprecated": "This package is now deprecated. Move to @xterm/addon-fit instead.",
      "license": "MIT",
      "peerDependencies": {
        "xterm": "^5.0.0"
      }
    },
    "node_modules/yallist": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-3.1.1.tgz",
      "integrity": "sha512-a4UGQaWPH59mOXUYnAG2ewncQS4i4F43Tv3JoAM+s2VDAmS9NsK8GpDMLrCHPksFT7h3K6TOoUNn2pb7RoXx4g==",
      "license": "ISC"
    },
    "node_modules/yaml": {
      "version": "2.8.0",
      "resolved": "https://registry.npmjs.org/yaml/-/yaml-2.8.0.tgz",
      "integrity": "sha512-4lLa/EcQCB0cJkyts+FpIRx5G/llPxfP6VQU5KByHEhLxY3IJCH0f0Hy1MHI8sClTvsIb8qwRJ6R/ZdlDJ/leQ==",
      "license": "ISC",
      "optional": true,
      "peer": true,
      "bin": {
        "yaml": "bin.mjs"
      },
      "engines": {
        "node": ">= 14.6"
      }
    },
    "node_modules/zustand": {
      "version": "5.0.8",
      "resolved": "https://registry.npmjs.org/zustand/-/zustand-5.0.8.tgz",
      "integrity": "sha512-gyPKpIaxY9XcO2vSMrLbiER7QMAMGOQZVRdJ6Zi782jkbzZygq5GI9nG8g+sMgitRtndwaBSl7uiqC49o1SSiw==",
      "license": "MIT",
      "engines": {
        "node": ">=12.20.0"
      },
      "peerDependencies": {
        "@types/react": ">=18.0.0",
        "immer": ">=9.0.6",
        "react": ">=18.0.0",
        "use-sync-external-store": ">=1.2.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "immer": {
          "optional": true
        },
        "react": {
          "optional": true
        },
        "use-sync-external-store": {
          "optional": true
        }
      }
    }
  }
}

```

`src/client/package.json`:

```json
{
  "name": "dyna-dbg",
  "private": true,
  "version": "0.1.0",
  "license": "GPL-3.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "tauri": "tauri",
    "license:check": "license-checker --production --onlyAllow 'MIT;Apache-2.0;BSD-2-Clause;BSD-3-Clause;ISC;0BSD;CC0-1.0;Unlicense;CC-BY-3.0;CC-BY-4.0;Python-2.0;BlueOak-1.0.0;MPL-2.0'",
    "license:summary": "license-checker --production --summary",
    "license:report": "license-checker --production --json > license-report.json"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.1",
    "@mui/icons-material": "^7.2.0",
    "@mui/material": "^7.2.0",
    "@tauri-apps/api": "^2",
    "@tauri-apps/plugin-opener": "^2",
    "@tauri-apps/plugin-shell": "^2.3.3",
    "@types/prismjs": "^1.26.5",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "@types/react-router-dom": "^5.3.3",
    "@types/react-window": "^1.8.8",
    "@types/xterm": "^2.0.3",
    "@vitejs/plugin-react": "^4.7.0",
    "@xterm/addon-fit": "^0.10.0",
    "@xterm/xterm": "^5.5.0",
    "crypto-js": "^4.2.0",
    "prismjs": "^1.30.0",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-router-dom": "^7.7.1",
    "react-simple-code-editor": "^0.14.1",
    "react-window": "^2.2.3",
    "xterm": "^5.3.0",
    "xterm-addon-fit": "^0.8.0",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@tauri-apps/cli": "^2",
    "@types/crypto-js": "^4.2.2",
    "prettier": "3.6.2",
    "typescript": "~5.6.2",
    "vite": "^6.0.3"
  }
}

```

`src/client/src-tauri/Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "DynaDbg"
version = "0.1.0"
dependencies = [
 "anyhow",
 "base64 0.22.1",
 "capstone",
 "cpp_demangle",
 "dirs 5.0.1",
 "hex",
 "libc",
 "lz4_flex",
 "once_cell",
 "rayon",
 "reqwest",
 "rfd",
 "rusqlite",
 "rustc-demangle",
 "serde",
 "serde_json",
 "tauri",
 "tauri-build",
 "tauri-plugin-opener",
 "tauri-plugin-shell",
 "tokio",
 "urlencoding",
]

[[package]]
name = "addr2line"
version = "0.24.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfbe277e56a376000877090da837660b4427aad530e3028d44e0bffe4f89a1c1"
dependencies = [
 "gimli",
]

[[package]]
name = "adler2"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "320119579fcad9c21884f5c4861d16174d0e06250625266f50fe6898340abefa"

[[package]]
name = "ahash"
version = "0.8.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a15f179cd60c4584b8a8c596927aadc462e27f2ca70c04e0071964a73ba7a75"
dependencies = [
 "cfg-if",
 "once_cell",
 "version_check",
 "zerocopy",
]

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "alloc-no-stdlib"
version = "2.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cc7bb162ec39d46ab1ca8c77bf72e890535becd1751bb45f64c597edb4c8c6b3"

[[package]]
name = "alloc-stdlib"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94fb8275041c72129eb51b7d0322c29b8387a0386127718b096429201a5d6ece"
dependencies = [
 "alloc-no-stdlib",
]

[[package]]
name = "android-tzdata"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "anyhow"
version = "1.0.98"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e16d2d3311acee920a9eb8d33b8cbc1787ce4a264e85f964c2404b969bdcd487"

[[package]]
name = "ashpd"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6cbdf310d77fd3aaee6ea2093db7011dc2d35d2eb3481e5607f1f8d942ed99df"
dependencies = [
 "async-fs",
 "async-net",
 "enumflags2",
 "futures-channel",
 "futures-util",
 "rand 0.9.2",
 "raw-window-handle",
 "serde",
 "serde_repr",
 "url",
 "wayland-backend",
 "wayland-client",
 "wayland-protocols",
 "zbus",
]

[[package]]
name = "async-broadcast"
version = "0.7.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "435a87a52755b8f27fcf321ac4f04b2802e337c8c4872923137471ec39c37532"
dependencies = [
 "event-listener",
 "event-listener-strategy",
 "futures-core",
 "pin-project-lite",
]

[[package]]
name = "async-channel"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "924ed96dd52d1b75e9c1a3e6275715fd320f5f9439fb5a4a11fa51f4221158d2"
dependencies = [
 "concurrent-queue",
 "event-listener-strategy",
 "futures-core",
 "pin-project-lite",
]

[[package]]
name = "async-executor"
version = "1.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bb812ffb58524bdd10860d7d974e2f01cc0950c2438a74ee5ec2e2280c6c4ffa"
dependencies = [
 "async-task",
 "concurrent-queue",
 "fastrand",
 "futures-lite",
 "pin-project-lite",
 "slab",
]

[[package]]
name = "async-fs"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8034a681df4aed8b8edbd7fbe472401ecf009251c8b40556b304567052e294c5"
dependencies = [
 "async-lock",
 "blocking",
 "futures-lite",
]

[[package]]
name = "async-io"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19634d6336019ef220f09fd31168ce5c184b295cbf80345437cc36094ef223ca"
dependencies = [
 "async-lock",
 "cfg-if",
 "concurrent-queue",
 "futures-io",
 "futures-lite",
 "parking",
 "polling",
 "rustix",
 "slab",
 "windows-sys 0.60.2",
]

[[package]]
name = "async-lock"
version = "3.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff6e472cdea888a4bd64f342f09b3f50e1886d32afe8df3d663c01140b811b18"
dependencies = [
 "event-listener",
 "event-listener-strategy",
 "pin-project-lite",
]

[[package]]
name = "async-net"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b948000fad4873c1c9339d60f2623323a0cfd3816e5181033c6a5cb68b2accf7"
dependencies = [
 "async-io",
 "blocking",
 "futures-lite",
]

[[package]]
name = "async-process"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "65daa13722ad51e6ab1a1b9c01299142bc75135b337923cfa10e79bbbd669f00"
dependencies = [
 "async-channel",
 "async-io",
 "async-lock",
 "async-signal",
 "async-task",
 "blocking",
 "cfg-if",
 "event-listener",
 "futures-lite",
 "rustix",
]

[[package]]
name = "async-recursion"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b43422f69d8ff38f95f1b2bb76517c91589a924d1559a0e935d7c8ce0274c11"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "async-signal"
version = "0.2.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f567af260ef69e1d52c2b560ce0ea230763e6fbb9214a85d768760a920e3e3c1"
dependencies = [
 "async-io",
 "async-lock",
 "atomic-waker",
 "cfg-if",
 "futures-core",
 "futures-io",
 "rustix",
 "signal-hook-registry",
 "slab",
 "windows-sys 0.60.2",
]

[[package]]
name = "async-task"
version = "4.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b75356056920673b02621b35afd0f7dda9306d03c79a30f5c56c44cf256e3de"

[[package]]
name = "async-trait"
version = "0.1.88"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e539d3fca749fcee5236ab05e93a52867dd549cc157c8cb7f99595f3cedffdb5"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "atk"
version = "0.18.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "241b621213072e993be4f6f3a9e4b45f65b7e6faad43001be957184b7bb1824b"
dependencies = [
 "atk-sys",
 "glib",
 "libc",
]

[[package]]
name = "atk-sys"
version = "0.18.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c5e48b684b0ca77d2bbadeef17424c2ea3c897d44d566a1617e7e8f30614d086"
dependencies = [
 "glib-sys",
 "gobject-sys",
 "libc",
 "system-deps",
]

[[package]]
name = "atomic-waker"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1505bd5d3d116872e7271a6d4e16d81d0c8570876c8de68093a09ac269d8aac0"

[[package]]
name = "autocfg"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"

[[package]]
name = "backtrace"
version = "0.3.75"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6806a6321ec58106fea15becdad98371e28d92ccbc7c8f1b3b6dd724fe8f1002"
dependencies = [
 "addr2line",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
 "windows-targets 0.52.6",
]

[[package]]
name = "base64"
version = "0.21.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9d297deb1925b89f2ccc13d7635fa0714f12c87adce1c75356b39ca9b7178567"

[[package]]
name = "base64"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b8e56985ec62d17e9c1001dc89c88ecd7dc08e47eba5ec7c29c7b5eeecde967"
dependencies = [
 "serde",
]

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "block2"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c132eebf10f5cad5289222520a4a058514204aed6d791f1cf4fe8088b82d15f"
dependencies = [
 "objc2 0.5.2",
]

[[package]]
name = "block2"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "340d2f0bdb2a43c1d3cd40513185b2bd7def0aa1052f956455114bc98f82dcf2"
dependencies = [
 "objc2 0.6.1",
]

[[package]]
name = "blocking"
version = "1.6.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e83f8d02be6967315521be875afa792a316e28d57b5a2d401897e2a7921b7f21"
dependencies = [
 "async-channel",
 "async-task",
 "futures-io",
 "futures-lite",
 "piper",
]

[[package]]
name = "brotli"
version = "8.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9991eea70ea4f293524138648e41ee89b0b2b12ddef3b255effa43c8056e0e0d"
dependencies = [
 "alloc-no-stdlib",
 "alloc-stdlib",
 "brotli-decompressor",
]

[[package]]
name = "brotli-decompressor"
version = "5.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "874bb8112abecc98cbd6d81ea4fa7e94fb9449648c93cc89aa40c81c24d7de03"
dependencies = [
 "alloc-no-stdlib",
 "alloc-stdlib",
]

[[package]]
name = "bumpalo"
version = "3.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"

[[package]]
name = "bytemuck"
version = "1.23.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c76a5792e44e4abe34d3abf15636779261d45a7450612059293d1d2cfc63422"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bytes"
version = "1.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71b6127be86fdcfddb610f7182ac57211d4b18a3e9c82eb2d17662f2227ad6a"
dependencies = [
 "serde",
]

[[package]]
name = "cairo-rs"
version = "0.18.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ca26ef0159422fb77631dc9d17b102f253b876fe1586b03b803e63a309b4ee2"
dependencies = [
 "bitflags 2.9.1",
 "cairo-sys-rs",
 "glib",
 "libc",
 "once_cell",
 "thiserror 1.0.69",
]

[[package]]
name = "cairo-sys-rs"
version = "0.18.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "685c9fa8e590b8b3d678873528d83411db17242a73fccaed827770ea0fedda51"
dependencies = [
 "glib-sys",
 "libc",
 "system-deps",
]

[[package]]
name = "camino"
version = "1.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0da45bc31171d8d6960122e222a67740df867c1dd53b4d51caa297084c185cab"
dependencies = [
 "serde",
]

[[package]]
name = "capstone"
version = "0.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b08ca438d9585a2b216b0c2e88ea51e096286c5f197f7be2526bb515ef775b6c"
dependencies = [
 "capstone-sys",
 "libc",
]

[[package]]
name = "capstone-sys"
version = "0.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fe7183271711ffb7c63a6480e4baf480e0140da59eeba9b18fcc8bf3478950e3"
dependencies = [
 "cc",
 "libc",
]

[[package]]
name = "cargo-platform"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e35af189006b9c0f00a064685c727031e3ed2d8020f7ba284d78cc2671bd36ea"
dependencies = [
 "serde",
]

[[package]]
name = "cargo_metadata"
version = "0.19.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd5eb614ed4c27c5d706420e4320fbe3216ab31fa1c33cd8246ac36dae4479ba"
dependencies = [
 "camino",
 "cargo-platform",
 "semver",
 "serde",
 "serde_json",
 "thiserror 2.0.12",
]

[[package]]
name = "cargo_toml"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "02260d489095346e5cafd04dea8e8cb54d1d74fcd759022a9b72986ebe9a1257"
dependencies = [
 "serde",
 "toml 0.8.23",
]

[[package]]
name = "cc"
version = "1.2.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "deec109607ca693028562ed836a5f1c4b8bd77755c4e132fc5ce11b0b6211ae7"
dependencies = [
 "shlex",
]

[[package]]
name = "cesu8"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d43a04d8753f35258c91f8ec639f792891f748a1edbd759cf1dcea3382ad83c"

[[package]]
name = "cfb"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d38f2da7a0a2c4ccf0065be06397cc26a81f4e528be095826eee9d4adbb8c60f"
dependencies = [
 "byteorder",
 "fnv",
 "uuid",
]

[[package]]
name = "cfg-expr"
version = "0.15.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d067ad48b8650848b989a59a86c6c36a995d02d2bf778d45c3c5d57bc2718f02"
dependencies = [
 "smallvec",
 "target-lexicon",
]

[[package]]
name = "cfg-if"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9555578bc9e57714c812a1f84e4fc5b4d21fcb063490c624de019f7464c91268"

[[package]]
name = "cfg_aliases"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "613afe47fcd5fac7ccf1db93babcb082c5994d996f20b8b159f2ad1658eb5724"

[[package]]
name = "chrono"
version = "0.4.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c469d952047f47f91b68d1cba3f10d63c11d73e4636f24f08daf0278abf01c4d"
dependencies = [
 "android-tzdata",
 "iana-time-zone",
 "num-traits",
 "serde",
 "windows-link",
]

[[package]]
name = "combine"
version = "4.6.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba5a308b75df32fe02788e748662718f03fde005016435c444eea572398219fd"
dependencies = [
 "bytes",
 "memchr",
]

[[package]]
name = "concurrent-queue"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ca0197aee26d1ae37445ee532fefce43251d24cc7c166799f4d46817f1d3973"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "convert_case"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6245d59a3e82a7fc217c5828a6692dbc6dfb63a0c8c90495621f7b9d79704a0e"

[[package]]
name = "cookie"
version = "0.18.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ddef33a339a91ea89fb53151bd0a4689cfce27055c291dfa69945475d22c747"
dependencies = [
 "time",
 "version_check",
]

[[package]]
name = "core-foundation"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b2a6cd9ae233e7f62ba4e9353e81a88df7fc8a5987b8d445b4d90c879bd156f6"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "core-graphics"
version = "0.24.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa95a34622365fa5bbf40b20b75dba8dfa8c94c734aea8ac9a5ca38af14316f1"
dependencies = [
 "bitflags 2.9.1",
 "core-foundation 0.10.1",
 "core-graphics-types",
 "foreign-types 0.5.0",
 "libc",
]

[[package]]
name = "core-graphics-types"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3d44a101f213f6c4cdc1853d4b78aef6db6bdfa3468798cc1d9912f4735013eb"
dependencies = [
 "bitflags 2.9.1",
 "core-foundation 0.10.1",
 "libc",
]

[[package]]
name = "cpp_demangle"
version = "0.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2bb79cb74d735044c972aae58ed0aaa9a837e85b01106a54c39e42e97f62253"
dependencies = [
 "cfg-if",
]

[[package]]
name = "cpufeatures"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59ed5838eebb26a2bb2e58f6d5b5316989ae9d08bab10e0e6d103e656d1b0280"
dependencies = [
 "libc",
]

[[package]]
name = "crc32fast"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9481c1c90cbf2ac953f07c8d4a58aa3945c425b7185c9154d67a65e4230da511"
dependencies = [
 "cfg-if",
]

[[package]]
name = "crossbeam-channel"
version = "0.5.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "82b8f8f868b36967f9606790d1903570de9ceaf870a7bf9fbbd3016d636a2cb2"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-deque"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9dd111b7b7f7d55b72c0a6ae361660ee5853c9af73f70c3c2ef6858b950e2e51"
dependencies = [
 "crossbeam-epoch",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28"

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "cssparser"
version = "0.29.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f93d03419cb5950ccfd3daf3ff1c7a36ace64609a1a8746d493df1ca0afde0fa"
dependencies = [
 "cssparser-macros",
 "dtoa-short",
 "itoa",
 "matches",
 "phf 0.10.1",
 "proc-macro2",
 "quote",
 "smallvec",
 "syn 1.0.109",
]

[[package]]
name = "cssparser-macros"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13b588ba4ac1a99f7f2964d24b3d896ddc6bf847ee3855dbd4366f058cfcd331"
dependencies = [
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "ctor"
version = "0.2.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a2785755761f3ddc1492979ce1e48d2c00d09311c39e4466429188f3dd6501"
dependencies = [
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "darling"
version = "0.20.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc7f46116c46ff9ab3eb1597a45688b6715c6e628b5c133e288e709a29bcb4ee"
dependencies = [
 "darling_core",
 "darling_macro",
]

[[package]]
name = "darling_core"
version = "0.20.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0d00b9596d185e565c2207a0b01f8bd1a135483d02d9b7b0a54b11da8d53412e"
dependencies = [
 "fnv",
 "ident_case",
 "proc-macro2",
 "quote",
 "strsim",
 "syn 2.0.104",
]

[[package]]
name = "darling_macro"
version = "0.20.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc34b93ccb385b40dc71c6fceac4b2ad23662c7eeb248cf10d529b7e055b6ead"
dependencies = [
 "darling_core",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "deranged"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c9e6a11ca8224451684bc0d7d5a7adbf8f2fd6887261a1cfc3c0432f9d4068e"
dependencies = [
 "powerfmt",
 "serde",
]

[[package]]
name = "derive_more"
version = "0.99.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6edb4b64a43d977b8e99788fe3a04d483834fba1215a7e02caa415b626497f7f"
dependencies = [
 "convert_case",
 "proc-macro2",
 "quote",
 "rustc_version",
 "syn 2.0.104",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "crypto-common",
]

[[package]]
name = "dirs"
version = "5.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "44c45a9d03d6676652bcb5e724c7e988de1acad23a711b5217ab9cbecbec2225"
dependencies = [
 "dirs-sys 0.4.1",
]

[[package]]
name = "dirs"
version = "6.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3e8aa94d75141228480295a7d0e7feb620b1a5ad9f12bc40be62411e38cce4e"
dependencies = [
 "dirs-sys 0.5.0",
]

[[package]]
name = "dirs-sys"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "520f05a5cbd335fae5a99ff7a6ab8627577660ee5cfd6a94a6a929b52ff0321c"
dependencies = [
 "libc",
 "option-ext",
 "redox_users 0.4.6",
 "windows-sys 0.48.0",
]

[[package]]
name = "dirs-sys"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e01a3366d27ee9890022452ee61b2b63a67e6f13f58900b651ff5665f0bb1fab"
dependencies = [
 "libc",
 "option-ext",
 "redox_users 0.5.0",
 "windows-sys 0.60.2",
]

[[package]]
name = "dispatch"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd0c93bb4b0c6d9b77f4435b0ae98c24d17f1c45b2ff844c6151a07256ca923b"

[[package]]
name = "dispatch2"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89a09f22a6c6069a18470eb92d2298acf25463f14256d24778e1230d789a2aec"
dependencies = [
 "bitflags 2.9.1",
 "block2 0.6.1",
 "libc",
 "objc2 0.6.1",
]

[[package]]
name = "displaydoc"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97369cbbc041bc366949bc74d34658d6cda5621039731c6310521892a3a20ae0"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "dlib"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "330c60081dcc4c72131f8eb70510f1ac07223e5d4163db481a04a0befcffa412"
dependencies = [
 "libloading",
]

[[package]]
name = "dlopen2"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8d65cde5fb0c42a3d5882d99807698b459f5928de035fa7f547c784fb7b34219"
dependencies = [
 "dlopen2_derive",
 "libc",
 "once_cell",
 "winapi",
]

[[package]]
name = "dlopen2_derive"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "788160fb30de9cdd857af31c6a2675904b16ece8fc2737b2c7127ba368c9d0f4"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "downcast-rs"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75b325c5dbd37f80359721ad39aca5a29fb04c89279657cffdda8736d0c0b9d2"

[[package]]
name = "dpi"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d8b14ccef22fc6f5a8f4d7d768562a182c04ce9a3b3157b91390b52ddfdf1a76"
dependencies = [
 "serde",
]

[[package]]
name = "dtoa"
version = "1.0.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d6add3b8cff394282be81f3fc1a0605db594ed69890078ca6e2cab1c408bcf04"

[[package]]
name = "dtoa-short"
version = "0.3.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd1511a7b6a56299bd043a9c167a6d2bfb37bf84a6dfceaba651168adfb43c87"
dependencies = [
 "dtoa",
]

[[package]]
name = "dunce"
version = "1.0.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "92773504d58c093f6de2459af4af33faa518c13451eb8f2b5698ed3d36e7c813"

[[package]]
name = "dyn-clone"
version = "1.0.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1c7a8fb8a9fbf66c1f703fe16184d10ca0ee9d23be5b4436400408ba54a95005"

[[package]]
name = "either"
version = "1.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"

[[package]]
name = "embed-resource"
version = "3.0.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c6d81016d6c977deefb2ef8d8290da019e27cc26167e102185da528e6c0ab38"
dependencies = [
 "cc",
 "memchr",
 "rustc_version",
 "toml 0.9.2",
 "vswhom",
 "winreg",
]

[[package]]
name = "embed_plist"
version = "1.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ef6b89e5b37196644d8796de5268852ff179b44e96276cf4290264843743bb7"

[[package]]
name = "encoding_rs"
version = "0.8.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75030f3c4f45dafd7586dd6780965a8c7e8e285a5ecb86713e63a79c5b2766f3"
dependencies = [
 "cfg-if",
]

[[package]]
name = "endi"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a3d8a32ae18130a3c84dd492d4215c3d913c3b07c6b63c2eb3eb7ff1101ab7bf"

[[package]]
name = "enumflags2"
version = "0.7.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1027f7680c853e056ebcec683615fb6fbbc07dbaa13b4d5d9442b146ded4ecef"
dependencies = [
 "enumflags2_derive",
 "serde",
]

[[package]]
name = "enumflags2_derive"
version = "0.7.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67c78a4d8fdf9953a5c9d458f9efe940fd97a0cab0941c075a813ac594733827"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "erased-serde"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e004d887f51fcb9fef17317a2f3525c887d8aa3f4f50fed920816a688284a5b7"
dependencies = [
 "serde",
 "typeid",
]

[[package]]
name = "errno"
version = "0.3.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "778e2ac28f6c47af28e4907f13ffd1e1ddbd400980a9abd7c8df189bf578a5ad"
dependencies = [
 "libc",
 "windows-sys 0.60.2",
]

[[package]]
name = "event-listener"
version = "5.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3492acde4c3fc54c845eaab3eed8bd00c7a7d881f78bfc801e43a93dec1331ae"
dependencies = [
 "concurrent-queue",
 "parking",
 "pin-project-lite",
]

[[package]]
name = "event-listener-strategy"
version = "0.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8be9f3dfaaffdae2972880079a491a1a8bb7cbed0b8dd7a347f668b4150a3b93"
dependencies = [
 "event-listener",
 "pin-project-lite",
]

[[package]]
name = "fallible-iterator"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2acce4a10f12dc2fb14a218589d4f1f62ef011b2d0cc4b3cb1bba8e94da14649"

[[package]]
name = "fallible-streaming-iterator"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7360491ce676a36bf9bb3c56c1aa791658183a54d2744120f27285738d90465a"

[[package]]
name = "fastrand"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be"

[[package]]
name = "fdeflate"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e6853b52649d4ac5c0bd02320cddc5ba956bdb407c4b75a2c6b75bf51500f8c"
dependencies = [
 "simd-adler32",
]

[[package]]
name = "field-offset"
version = "0.3.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38e2275cc4e4fc009b0669731a1e5ab7ebf11f469eaede2bab9309a5b4d6057f"
dependencies = [
 "memoffset",
 "rustc_version",
]

[[package]]
name = "flate2"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a3d7db9596fecd151c5f638c0ee5d5bd487b6e0ea232e5dc96d5250f6f94b1d"
dependencies = [
 "crc32fast",
 "miniz_oxide",
]

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "foreign-types"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
dependencies = [
 "foreign-types-shared 0.1.1",
]

[[package]]
name = "foreign-types"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d737d9aa519fb7b749cbc3b962edcf310a8dd1f4b67c91c4f83975dbdd17d965"
dependencies = [
 "foreign-types-macros",
 "foreign-types-shared 0.3.1",
]

[[package]]
name = "foreign-types-macros"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a5c6c585bc94aaf2c7b51dd4c2ba22680844aba4c687be581871a6f518c5742"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "foreign-types-shared"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"

[[package]]
name = "foreign-types-shared"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aa9a19cbb55df58761df49b23516a86d432839add4af60fc256da840f66ed35b"

[[package]]
name = "form_urlencoded"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e13624c2627564efccf4934284bdd98cbaa14e79b0b5a141218e507b3a823456"
dependencies = [
 "percent-encoding",
]

[[package]]
name = "futf"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df420e2e84819663797d1ec6544b13c5be84629e7bb00dc960d6917db2987843"
dependencies = [
 "mac",
 "new_debug_unreachable",
]

[[package]]
name = "futures-channel"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10"
dependencies = [
 "futures-core",
]

[[package]]
name = "futures-core"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"

[[package]]
name = "futures-executor"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e28d1d997f585e54aebc3f97d39e72338912123a67330d723fdbb564d646c9f"
dependencies = [
 "futures-core",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-io"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"

[[package]]
name = "futures-lite"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f5edaec856126859abb19ed65f39e90fea3a9574b9707f13539acf4abf7eb532"
dependencies = [
 "fastrand",
 "futures-core",
 "futures-io",
 "parking",
 "pin-project-lite",
]

[[package]]
name = "futures-macro"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "162ee34ebcb7c64a8abebc059ce0fee27c2262618d7b60ed8faf72fef13c3650"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "futures-sink"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e575fab7d1e0dcb8d0c7bcf9a63ee213816ab51902e6d244a95819acacf1d4f7"

[[package]]
name = "futures-task"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f90f7dce0722e95104fcb095585910c0977252f286e354b5e3bd38902cd99988"

[[package]]
name = "futures-util"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
dependencies = [
 "futures-core",
 "futures-io",
 "futures-macro",
 "futures-sink",
 "futures-task",
 "memchr",
 "pin-project-lite",
 "pin-utils",
 "slab",
]

[[package]]
name = "fxhash"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c31b6d751ae2c7f11320402d34e41349dd1016f8d5d45e48c4312bc8625af50c"
dependencies = [
 "byteorder",
]

[[package]]
name = "gdk"
version = "0.18.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d9f245958c627ac99d8e529166f9823fb3b838d1d41fd2b297af3075093c2691"
dependencies = [
 "cairo-rs",
 "gdk-pixbuf",
 "gdk-sys",
 "gio",
 "glib",
 "libc",
 "pango",
]

[[package]]
name = "gdk-pixbuf"
version = "0.18.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50e1f5f1b0bfb830d6ccc8066d18db35c487b1b2b1e8589b5dfe9f07e8defaec"
dependencies = [
 "gdk-pixbuf-sys",
 "gio",
 "glib",
 "libc",
 "once_cell",
]

[[package]]
name = "gdk-pixbuf-sys"
version = "0.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9839ea644ed9c97a34d129ad56d38a25e6756f99f3a88e15cd39c20629caf7"
dependencies = [
 "gio-sys",
 "glib-sys",
 "gobject-sys",
 "libc",
 "system-deps",
]

[[package]]
name = "gdk-sys"
version = "0.18.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c2d13f38594ac1e66619e188c6d5a1adb98d11b2fcf7894fc416ad76aa2f3f7"
dependencies = [
 "cairo-sys-rs",
 "gdk-pixbuf-sys",
 "gio-sys",
 "glib-sys",
 "gobject-sys",
 "libc",
 "pango-sys",
 "pkg-config",
 "system-deps",
]

[[package]]
name = "gdkwayland-sys"
version = "0.18.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "140071d506d223f7572b9f09b5e155afbd77428cd5cc7af8f2694c41d98dfe69"
dependencies = [
 "gdk-sys",
 "glib-sys",
 "gobject-sys",
 "libc",
 "pkg-config",
 "system-deps",
]

[[package]]
name = "gdkx11"
version = "0.18.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3caa00e14351bebbc8183b3c36690327eb77c49abc2268dd4bd36b856db3fbfe"
dependencies = [
 "gdk",
 "gdkx11-sys",
 "gio",
 "glib",
 "libc",
 "x11",
]

[[package]]
name = "gdkx11-sys"
version = "0.18.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e2e7445fe01ac26f11601db260dd8608fe172514eb63b3b5e261ea6b0f4428d"
dependencies = [
 "gdk-sys",
 "glib-sys",
 "libc",
 "system-deps",
 "x11",
]

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getrandom"
version = "0.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8fc3cb4d91f53b50155bdcfd23f6a4c39ae1969c2ae85982b135750cccaf5fce"
dependencies = [
 "cfg-if",
 "libc",
 "wasi 0.9.0+wasi-snapshot-preview1",
]

[[package]]
name = "getrandom"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "335ff9f135e4384c8150d6f27c6daed433577f86b4750418338c01a1a2528592"
dependencies = [
 "cfg-if",
 "libc",
 "wasi 0.11.1+wasi-snapshot-preview1",
]

[[package]]
name = "getrandom"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26145e563e54f2cadc477553f1ec5ee650b00862f0a58bcd12cbdc5f0ea2d2f4"
dependencies = [
 "cfg-if",
 "libc",
 "r-efi",
 "wasi 0.14.2+wasi-0.2.4",
]

[[package]]
name = "gimli"
version = "0.31.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07e28edb80900c19c28f1072f2e8aeca7fa06b23cd4169cefe1af5aa3260783f"

[[package]]
name = "gio"
version = "0.18.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4fc8f532f87b79cbc51a79748f16a6828fb784be93145a322fa14d06d354c73"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-util",
 "gio-sys",
 "glib",
 "libc",
 "once_cell",
 "pin-project-lite",
 "smallvec",
 "thiserror 1.0.69",
]

[[package]]
name = "gio-sys"
version = "0.18.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37566df850baf5e4cb0dfb78af2e4b9898d817ed9263d1090a2df958c64737d2"
dependencies = [
 "glib-sys",
 "gobject-sys",
 "libc",
 "system-deps",
 "winapi",
]

[[package]]
name = "glib"
version = "0.18.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "233daaf6e83ae6a12a52055f568f9d7cf4671dabb78ff9560ab6da230ce00ee5"
dependencies = [
 "bitflags 2.9.1",
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-task",
 "futures-util",
 "gio-sys",
 "glib-macros",
 "glib-sys",
 "gobject-sys",
 "libc",
 "memchr",
 "once_cell",
 "smallvec",
 "thiserror 1.0.69",
]

[[package]]
name = "glib-macros"
version = "0.18.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0bb0228f477c0900c880fd78c8759b95c7636dbd7842707f49e132378aa2acdc"
dependencies = [
 "heck 0.4.1",
 "proc-macro-crate 2.0.0",
 "proc-macro-error",
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "glib-sys"
version = "0.18.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "063ce2eb6a8d0ea93d2bf8ba1957e78dbab6be1c2220dd3daca57d5a9d869898"
dependencies = [
 "libc",
 "system-deps",
]

[[package]]
name = "glob"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8d1add55171497b4705a648c6b583acafb01d58050a51727785f0b2c8e0a2b2"

[[package]]
name = "gobject-sys"
version = "0.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0850127b514d1c4a4654ead6dedadb18198999985908e6ffe4436f53c785ce44"
dependencies = [
 "glib-sys",
 "libc",
 "system-deps",
]

[[package]]
name = "gtk"
version = "0.18.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fd56fb197bfc42bd5d2751f4f017d44ff59fbb58140c6b49f9b3b2bdab08506a"
dependencies = [
 "atk",
 "cairo-rs",
 "field-offset",
 "futures-channel",
 "gdk",
 "gdk-pixbuf",
 "gio",
 "glib",
 "gtk-sys",
 "gtk3-macros",
 "libc",
 "pango",
 "pkg-config",
]

[[package]]
name = "gtk-sys"
version = "0.18.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f29a1c21c59553eb7dd40e918be54dccd60c52b049b75119d5d96ce6b624414"
dependencies = [
 "atk-sys",
 "cairo-sys-rs",
 "gdk-pixbuf-sys",
 "gdk-sys",
 "gio-sys",
 "glib-sys",
 "gobject-sys",
 "libc",
 "pango-sys",
 "system-deps",
]

[[package]]
name = "gtk3-macros"
version = "0.18.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "52ff3c5b21f14f0736fed6dcfc0bfb4225ebf5725f3c0209edeec181e4d73e9d"
dependencies = [
 "proc-macro-crate 1.3.1",
 "proc-macro-error",
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "h2"
version = "0.4.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17da50a276f1e01e0ba6c029e47b7100754904ee8a278f886546e98575380785"
dependencies = [
 "atomic-waker",
 "bytes",
 "fnv",
 "futures-core",
 "futures-sink",
 "http",
 "indexmap 2.10.0",
 "slab",
 "tokio",
 "tokio-util",
 "tracing",
]

[[package]]
name = "hashbrown"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888"

[[package]]
name = "hashbrown"
version = "0.14.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1"
dependencies = [
 "ahash",
]

[[package]]
name = "hashbrown"
version = "0.15.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5971ac85611da7067dbfcabef3c70ebb5606018acd9e2a3903a0da507521e0d5"

[[package]]
name = "hashlink"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6ba4ff7128dee98c7dc9794b6a411377e1404dba1c97deb8d1a55297bd25d8af"
dependencies = [
 "hashbrown 0.14.5",
]

[[package]]
name = "heck"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "95505c38b4572b2d910cecb0281560f54b440a19336cbbcb27bf6ce6adc6f5a8"

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "hermit-abi"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc0fef456e4baa96da950455cd02c081ca953b141298e41db3fc7e36b1da849c"

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "html5ever"
version = "0.29.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b7410cae13cbc75623c98ac4cbfd1f0bedddf3227afc24f370cf0f50a44a11c"
dependencies = [
 "log",
 "mac",
 "markup5ever",
 "match_token",
]

[[package]]
name = "http"
version = "1.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4a85d31aea989eead29a3aaf9e1115a180df8282431156e533de47660892565"
dependencies = [
 "bytes",
 "fnv",
 "itoa",
]

[[package]]
name = "http-body"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1efedce1fb8e6913f23e0c92de8e62cd5b772a67e7b3946df930a62566c93184"
dependencies = [
 "bytes",
 "http",
]

[[package]]
name = "http-body-util"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b021d93e26becf5dc7e1b75b1bed1fd93124b374ceb73f43d4d4eafec896a64a"
dependencies = [
 "bytes",
 "futures-core",
 "http",
 "http-body",
 "pin-project-lite",
]

[[package]]
name = "httparse"
version = "1.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6dbf3de79e51f3d586ab4cb9d5c3e2c14aa28ed23d180cf89b4df0454a69cc87"

[[package]]
name = "hyper"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cc2b571658e38e0c01b1fdca3bbbe93c00d3d71693ff2770043f8c29bc7d6f80"
dependencies = [
 "bytes",
 "futures-channel",
 "futures-util",
 "h2",
 "http",
 "http-body",
 "httparse",
 "itoa",
 "pin-project-lite",
 "smallvec",
 "tokio",
 "want",
]

[[package]]
name = "hyper-rustls"
version = "0.27.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3c93eb611681b207e1fe55d5a71ecf91572ec8a6705cdb6857f7d8d5242cf58"
dependencies = [
 "http",
 "hyper",
 "hyper-util",
 "rustls",
 "rustls-pki-types",
 "tokio",
 "tokio-rustls",
 "tower-service",
]

[[package]]
name = "hyper-tls"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70206fc6890eaca9fde8a0bf71caa2ddfc9fe045ac9e5c70df101a7dbde866e0"
dependencies = [
 "bytes",
 "http-body-util",
 "hyper",
 "hyper-util",
 "native-tls",
 "tokio",
 "tokio-native-tls",
 "tower-service",
]

[[package]]
name = "hyper-util"
version = "0.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8d9b05277c7e8da2c93a568989bb6207bef0112e8d17df7a6eda4a3cf143bc5e"
dependencies = [
 "base64 0.22.1",
 "bytes",
 "futures-channel",
 "futures-core",
 "futures-util",
 "http",
 "http-body",
 "hyper",
 "ipnet",
 "libc",
 "percent-encoding",
 "pin-project-lite",
 "socket2 0.6.0",
 "system-configuration",
 "tokio",
 "tower-service",
 "tracing",
 "windows-registry",
]

[[package]]
name = "iana-time-zone"
version = "0.1.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0c919e5debc312ad217002b8048a17b7d83f80703865bbfcfebb0458b0b27d8"
dependencies = [
 "android_system_properties",
 "core-foundation-sys",
 "iana-time-zone-haiku",
 "js-sys",
 "log",
 "wasm-bindgen",
 "windows-core",
]

[[package]]
name = "iana-time-zone-haiku"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
dependencies = [
 "cc",
]

[[package]]
name = "ico"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cc50b891e4acf8fe0e71ef88ec43ad82ee07b3810ad09de10f1d01f072ed4b98"
dependencies = [
 "byteorder",
 "png",
]

[[package]]
name = "icu_collections"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "200072f5d0e3614556f94a9930d5dc3e0662a652823904c3a75dc3b0af7fee47"
dependencies = [
 "displaydoc",
 "potential_utf",
 "yoke",
 "zerofrom",
 "zerovec",
]

[[package]]
name = "icu_locale_core"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0cde2700ccaed3872079a65fb1a78f6c0a36c91570f28755dda67bc8f7d9f00a"
dependencies = [
 "displaydoc",
 "litemap",
 "tinystr",
 "writeable",
 "zerovec",
]

[[package]]
name = "icu_normalizer"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "436880e8e18df4d7bbc06d58432329d6458cc84531f7ac5f024e93deadb37979"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_normalizer_data",
 "icu_properties",
 "icu_provider",
 "smallvec",
 "zerovec",
]

[[package]]
name = "icu_normalizer_data"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00210d6893afc98edb752b664b8890f0ef174c8adbb8d0be9710fa66fbbf72d3"

[[package]]
name = "icu_properties"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "016c619c1eeb94efb86809b015c58f479963de65bdb6253345c1a1276f22e32b"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_locale_core",
 "icu_properties_data",
 "icu_provider",
 "potential_utf",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "icu_properties_data"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "298459143998310acd25ffe6810ed544932242d3f07083eee1084d83a71bd632"

[[package]]
name = "icu_provider"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "03c80da27b5f4187909049ee2d72f276f0d9f99a42c306bd0131ecfe04d8e5af"
dependencies = [
 "displaydoc",
 "icu_locale_core",
 "stable_deref_trait",
 "tinystr",
 "writeable",
 "yoke",
 "zerofrom",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "ident_case"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39"

[[package]]
name = "idna"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "686f825264d630750a544639377bae737628043f20d38bbc029e8f29ea968a7e"
dependencies = [
 "idna_adapter",
 "smallvec",
 "utf8_iter",
]

[[package]]
name = "idna_adapter"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3acae9609540aa318d1bc588455225fb2085b9ed0c4f6bd0d9d5bcd86f1a0344"
dependencies = [
 "icu_normalizer",
 "icu_properties",
]

[[package]]
name = "indexmap"
version = "1.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99"
dependencies = [
 "autocfg",
 "hashbrown 0.12.3",
 "serde",
]

[[package]]
name = "indexmap"
version = "2.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fe4cd85333e22411419a0bcae1297d25e58c9443848b11dc6a86fefe8c78a661"
dependencies = [
 "equivalent",
 "hashbrown 0.15.4",
 "serde",
]

[[package]]
name = "infer"
version = "0.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a588916bfdfd92e71cacef98a63d9b1f0d74d6599980d11894290e7ddefffcf7"
dependencies = [
 "cfb",
]

[[package]]
name = "io-uring"
version = "0.7.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d93587f37623a1a17d94ef2bc9ada592f5465fe7732084ab7beefabe5c77c0c4"
dependencies = [
 "bitflags 2.9.1",
 "cfg-if",
 "libc",
]

[[package]]
name = "ipnet"
version = "2.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "469fb0b9cefa57e3ef31275ee7cacb78f2fdca44e4765491884a2b119d4eb130"

[[package]]
name = "iri-string"
version = "0.7.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dbc5ebe9c3a1a7a5127f920a418f7585e9e758e911d0466ed004f393b0e380b2"
dependencies = [
 "memchr",
 "serde",
]

[[package]]
name = "is-docker"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "928bae27f42bc99b60d9ac7334e3a21d10ad8f1835a4e12ec3ec0464765ed1b3"
dependencies = [
 "once_cell",
]

[[package]]
name = "is-wsl"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "173609498df190136aa7dea1a91db051746d339e18476eed5ca40521f02d7aa5"
dependencies = [
 "is-docker",
 "once_cell",
]

[[package]]
name = "itoa"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c"

[[package]]
name = "javascriptcore-rs"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ca5671e9ffce8ffba57afc24070e906da7fc4b1ba66f2cabebf61bf2ea257fcc"
dependencies = [
 "bitflags 1.3.2",
 "glib",
 "javascriptcore-rs-sys",
]

[[package]]
name = "javascriptcore-rs-sys"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "af1be78d14ffa4b75b66df31840478fef72b51f8c2465d4ca7c194da9f7a5124"
dependencies = [
 "glib-sys",
 "gobject-sys",
 "libc",
 "system-deps",
]

[[package]]
name = "jni"
version = "0.21.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a87aa2bb7d2af34197c04845522473242e1aa17c12f4935d5856491a7fb8c97"
dependencies = [
 "cesu8",
 "cfg-if",
 "combine",
 "jni-sys",
 "log",
 "thiserror 1.0.69",
 "walkdir",
 "windows-sys 0.45.0",
]

[[package]]
name = "jni-sys"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8eaf4bc02d17cbdd7ff4c7438cafcdf7fb9a4613313ad11b4f8fefe7d3fa0130"

[[package]]
name = "js-sys"
version = "0.3.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f"
dependencies = [
 "once_cell",
 "wasm-bindgen",
]

[[package]]
name = "json-patch"
version = "3.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "863726d7afb6bc2590eeff7135d923545e5e964f004c2ccf8716c25e70a86f08"
dependencies = [
 "jsonptr",
 "serde",
 "serde_json",
 "thiserror 1.0.69",
]

[[package]]
name = "jsonptr"
version = "0.6.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5dea2b27dd239b2556ed7a25ba842fe47fd602e7fc7433c2a8d6106d4d9edd70"
dependencies = [
 "serde",
 "serde_json",
]

[[package]]
name = "keyboard-types"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b750dcadc39a09dbadd74e118f6dd6598df77fa01df0cfcdc52c28dece74528a"
dependencies = [
 "bitflags 2.9.1",
 "serde",
 "unicode-segmentation",
]

[[package]]
name = "kuchikiki"
version = "0.8.8-speedreader"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "02cb977175687f33fa4afa0c95c112b987ea1443e5a51c8f8ff27dc618270cc2"
dependencies = [
 "cssparser",
 "html5ever",
 "indexmap 2.10.0",
 "selectors",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "libappindicator"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "03589b9607c868cc7ae54c0b2a22c8dc03dd41692d48f2d7df73615c6a95dc0a"
dependencies = [
 "glib",
 "gtk",
 "gtk-sys",
 "libappindicator-sys",
 "log",
]

[[package]]
name = "libappindicator-sys"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e9ec52138abedcc58dc17a7c6c0c00a2bdb4f3427c7f63fa97fd0d859155caf"
dependencies = [
 "gtk-sys",
 "libloading",
 "once_cell",
]

[[package]]
name = "libc"
version = "0.2.174"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1171693293099992e19cddea4e8b849964e9846f4acee11b3948bcc337be8776"

[[package]]
name = "libloading"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b67380fd3b2fbe7527a606e18729d21c6f3951633d0500574c4dc22d2d638b9f"
dependencies = [
 "cfg-if",
 "winapi",
]

[[package]]
name = "libredox"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4488594b9328dee448adb906d8b126d9b7deb7cf5c22161ee591610bb1be83c0"
dependencies = [
 "bitflags 2.9.1",
 "libc",
]

[[package]]
name = "libsqlite3-sys"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2e99fb7a497b1e3339bc746195567ed8d3e24945ecd636e3619d20b9de9e9149"
dependencies = [
 "cc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "linux-raw-sys"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd945864f07fe9f5371a27ad7b52a172b4b499999f1d97574c9fa68373937e12"

[[package]]
name = "litemap"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "241eaef5fd12c88705a01fc1066c48c4b36e0dd4377dcdc7ec3942cea7a69956"

[[package]]
name = "lock_api"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96936507f153605bddfcda068dd804796c84324ed2510809e5b2a624c81da765"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13dc2df351e3202783a1fe0d44375f7295ffb4049267b0f3018346dc122a1d94"

[[package]]
name = "lz4_flex"
version = "0.11.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08ab2867e3eeeca90e844d1940eab391c9dc5228783db2ed999acbc0a9ed375a"
dependencies = [
 "twox-hash",
]

[[package]]
name = "mac"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c41e0c4fef86961ac6d6f8a82609f55f31b05e4fce149ac5710e439df7619ba4"

[[package]]
name = "markup5ever"
version = "0.14.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c7a7213d12e1864c0f002f52c2923d4556935a43dec5e71355c2760e0f6e7a18"
dependencies = [
 "log",
 "phf 0.11.3",
 "phf_codegen 0.11.3",
 "string_cache",
 "string_cache_codegen",
 "tendril",
]

[[package]]
name = "match_token"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "88a9689d8d44bf9964484516275f5cd4c9b59457a6940c1d5d0ecbb94510a36b"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "matches"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2532096657941c2fea9c289d370a250971c689d4f143798ff67113ec042024a5"

[[package]]
name = "memchr"
version = "2.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"

[[package]]
name = "memoffset"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "488016bfae457b036d996092f6cb448677611ce4449e970ceaf42695203f218a"
dependencies = [
 "autocfg",
]

[[package]]
name = "mime"
version = "0.3.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"

[[package]]
name = "miniz_oxide"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fa76a2c86f704bdb222d66965fb3d63269ce38518b83cb0575fca855ebb6316"
dependencies = [
 "adler2",
 "simd-adler32",
]

[[package]]
name = "mio"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78bed444cc8a2160f01cbcf811ef18cac863ad68ae8ca62092e8db51d51c761c"
dependencies = [
 "libc",
 "wasi 0.11.1+wasi-snapshot-preview1",
 "windows-sys 0.59.0",
]

[[package]]
name = "muda"
version = "0.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "58b89bf91c19bf036347f1ab85a81c560f08c0667c8601bece664d860a600988"
dependencies = [
 "crossbeam-channel",
 "dpi",
 "gtk",
 "keyboard-types",
 "objc2 0.6.1",
 "objc2-app-kit",
 "objc2-core-foundation",
 "objc2-foundation 0.3.1",
 "once_cell",
 "png",
 "serde",
 "thiserror 2.0.12",
 "windows-sys 0.59.0",
]

[[package]]
name = "native-tls"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87de3442987e9dbec73158d5c715e7ad9072fda936bb03d19d7fa10e00520f0e"
dependencies = [
 "libc",
 "log",
 "openssl",
 "openssl-probe",
 "openssl-sys",
 "schannel",
 "security-framework",
 "security-framework-sys",
 "tempfile",
]

[[package]]
name = "ndk"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3f42e7bbe13d351b6bead8286a43aac9534b82bd3cc43e47037f012ebfd62d4"
dependencies = [
 "bitflags 2.9.1",
 "jni-sys",
 "log",
 "ndk-sys",
 "num_enum",
 "raw-window-handle",
 "thiserror 1.0.69",
]

[[package]]
name = "ndk-context"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "27b02d87554356db9e9a873add8782d4ea6e3e58ea071a9adb9a2e8ddb884a8b"

[[package]]
name = "ndk-sys"
version = "0.6.0+11769913"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee6cda3051665f1fb8d9e08fc35c96d5a244fb1be711a03b71118828afc9a873"
dependencies = [
 "jni-sys",
]

[[package]]
name = "new_debug_unreachable"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "650eef8c711430f1a879fdd01d4745a7deea475becfb90269c06775983bbf086"

[[package]]
name = "nix"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "74523f3a35e05aba87a1d978330aef40f67b0304ac79c1c00b294c9830543db6"
dependencies = [
 "bitflags 2.9.1",
 "cfg-if",
 "cfg_aliases",
 "libc",
 "memoffset",
]

[[package]]
name = "nodrop"
version = "0.1.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72ef4a56884ca558e5ddb05a1d1e7e1bfd9a68d9ed024c21704cc98872dae1bb"

[[package]]
name = "num-conv"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "51d515d32fb182ee37cda2ccdcb92950d6a3c2893aa280e540671c2cd0f3b1d9"

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
]

[[package]]
name = "num_enum"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a973b4e44ce6cad84ce69d797acf9a044532e4184c4f267913d1b546a0727b7a"
dependencies = [
 "num_enum_derive",
 "rustversion",
]

[[package]]
name = "num_enum_derive"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77e878c846a8abae00dd069496dbe8751b16ac1c3d6bd2a7283a938e8228f90d"
dependencies = [
 "proc-macro-crate 3.3.0",
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "objc-sys"
version = "0.3.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cdb91bdd390c7ce1a8607f35f3ca7151b65afc0ff5ff3b34fa350f7d7c7e4310"

[[package]]
name = "objc2"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46a785d4eeff09c14c487497c162e92766fbb3e4059a71840cecc03d9a50b804"
dependencies = [
 "objc-sys",
 "objc2-encode",
]

[[package]]
name = "objc2"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "88c6597e14493ab2e44ce58f2fdecf095a51f12ca57bec060a11c57332520551"
dependencies = [
 "objc2-encode",
 "objc2-exception-helper",
]

[[package]]
name = "objc2-app-kit"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6f29f568bec459b0ddff777cec4fe3fd8666d82d5a40ebd0ff7e66134f89bcc"
dependencies = [
 "bitflags 2.9.1",
 "block2 0.6.1",
 "libc",
 "objc2 0.6.1",
 "objc2-cloud-kit",
 "objc2-core-data",
 "objc2-core-foundation",
 "objc2-core-graphics",
 "objc2-core-image",
 "objc2-foundation 0.3.1",
 "objc2-quartz-core 0.3.1",
]

[[package]]
name = "objc2-cloud-kit"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17614fdcd9b411e6ff1117dfb1d0150f908ba83a7df81b1f118005fe0a8ea15d"
dependencies = [
 "bitflags 2.9.1",
 "objc2 0.6.1",
 "objc2-foundation 0.3.1",
]

[[package]]
name = "objc2-core-data"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "291fbbf7d29287518e8686417cf7239c74700fd4b607623140a7d4a3c834329d"
dependencies = [
 "bitflags 2.9.1",
 "objc2 0.6.1",
 "objc2-foundation 0.3.1",
]

[[package]]
name = "objc2-core-foundation"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1c10c2894a6fed806ade6027bcd50662746363a9589d3ec9d9bef30a4e4bc166"
dependencies = [
 "bitflags 2.9.1",
 "dispatch2",
 "objc2 0.6.1",
]

[[package]]
name = "objc2-core-graphics"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "989c6c68c13021b5c2d6b71456ebb0f9dc78d752e86a98da7c716f4f9470f5a4"
dependencies = [
 "bitflags 2.9.1",
 "dispatch2",
 "objc2 0.6.1",
 "objc2-core-foundation",
 "objc2-io-surface",
]

[[package]]
name = "objc2-core-image"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "79b3dc0cc4386b6ccf21c157591b34a7f44c8e75b064f85502901ab2188c007e"
dependencies = [
 "objc2 0.6.1",
 "objc2-foundation 0.3.1",
]

[[package]]
name = "objc2-encode"
version = "4.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef25abbcd74fb2609453eb695bd2f860d389e457f67dc17cafc8b8cbc89d0c33"

[[package]]
name = "objc2-exception-helper"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c7a1c5fbb72d7735b076bb47b578523aedc40f3c439bea6dfd595c089d79d98a"
dependencies = [
 "cc",
]

[[package]]
name = "objc2-foundation"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ee638a5da3799329310ad4cfa62fbf045d5f56e3ef5ba4149e7452dcf89d5a8"
dependencies = [
 "bitflags 2.9.1",
 "block2 0.5.1",
 "libc",
 "objc2 0.5.2",
]

[[package]]
name = "objc2-foundation"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "900831247d2fe1a09a683278e5384cfb8c80c79fe6b166f9d14bfdde0ea1b03c"
dependencies = [
 "bitflags 2.9.1",
 "block2 0.6.1",
 "libc",
 "objc2 0.6.1",
 "objc2-core-foundation",
]

[[package]]
name = "objc2-io-surface"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7282e9ac92529fa3457ce90ebb15f4ecbc383e8338060960760fa2cf75420c3c"
dependencies = [
 "bitflags 2.9.1",
 "objc2 0.6.1",
 "objc2-core-foundation",
]

[[package]]
name = "objc2-javascript-core"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9052cb1bb50a4c161d934befcf879526fb87ae9a68858f241e693ca46225cf5a"
dependencies = [
 "objc2 0.6.1",
 "objc2-core-foundation",
]

[[package]]
name = "objc2-metal"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd0cba1276f6023976a406a14ffa85e1fdd19df6b0f737b063b95f6c8c7aadd6"
dependencies = [
 "bitflags 2.9.1",
 "block2 0.5.1",
 "objc2 0.5.2",
 "objc2-foundation 0.2.2",
]

[[package]]
name = "objc2-quartz-core"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e42bee7bff906b14b167da2bac5efe6b6a07e6f7c0a21a7308d40c960242dc7a"
dependencies = [
 "bitflags 2.9.1",
 "block2 0.5.1",
 "objc2 0.5.2",
 "objc2-foundation 0.2.2",
 "objc2-metal",
]

[[package]]
name = "objc2-quartz-core"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "90ffb6a0cd5f182dc964334388560b12a57f7b74b3e2dec5e2722aa2dfb2ccd5"
dependencies = [
 "bitflags 2.9.1",
 "objc2 0.6.1",
 "objc2-foundation 0.3.1",
]

[[package]]
name = "objc2-security"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e1f8e0ef3ab66b08c42644dcb34dba6ec0a574bbd8adbb8bdbdc7a2779731a44"
dependencies = [
 "bitflags 2.9.1",
 "objc2 0.6.1",
 "objc2-core-foundation",
]

[[package]]
name = "objc2-ui-kit"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "25b1312ad7bc8a0e92adae17aa10f90aae1fb618832f9b993b022b591027daed"
dependencies = [
 "bitflags 2.9.1",
 "objc2 0.6.1",
 "objc2-core-foundation",
 "objc2-foundation 0.3.1",
]

[[package]]
name = "objc2-web-kit"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91672909de8b1ce1c2252e95bbee8c1649c9ad9d14b9248b3d7b4c47903c47ad"
dependencies = [
 "bitflags 2.9.1",
 "block2 0.6.1",
 "objc2 0.6.1",
 "objc2-app-kit",
 "objc2-core-foundation",
 "objc2-foundation 0.3.1",
 "objc2-javascript-core",
 "objc2-security",
]

[[package]]
name = "object"
version = "0.36.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62948e14d923ea95ea2c7c86c71013138b66525b86bdc08d2dcc262bdb497b87"
dependencies = [
 "memchr",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "open"
version = "5.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2483562e62ea94312f3576a7aca397306df7990b8d89033e18766744377ef95"
dependencies = [
 "dunce",
 "is-wsl",
 "libc",
 "pathdiff",
]

[[package]]
name = "openssl"
version = "0.10.73"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8505734d46c8ab1e19a1dce3aef597ad87dcb4c37e7188231769bd6bd51cebf8"
dependencies = [
 "bitflags 2.9.1",
 "cfg-if",
 "foreign-types 0.3.2",
 "libc",
 "once_cell",
 "openssl-macros",
 "openssl-sys",
]

[[package]]
name = "openssl-macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a948666b637a0f465e8564c73e89d4dde00d72d4d473cc972f390fc3dcee7d9c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "openssl-probe"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d05e27ee213611ffe7d6348b942e8f942b37114c00cc03cec254295a4a17852e"

[[package]]
name = "openssl-sys"
version = "0.9.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "90096e2e47630d78b7d1c20952dc621f957103f8bc2c8359ec81290d75238571"
dependencies = [
 "cc",
 "libc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "option-ext"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04744f49eae99ab78e0d5c0b603ab218f515ea8cfe5a456d7629ad883a3b6e7d"

[[package]]
name = "ordered-stream"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9aa2b01e1d916879f73a53d01d1d6cee68adbb31d6d9177a8cfce093cced1d50"
dependencies = [
 "futures-core",
 "pin-project-lite",
]

[[package]]
name = "os_pipe"
version = "1.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7d8fae84b431384b68627d0f9b3b1245fcf9f46f6c0e3dc902e9dce64edd1967"
dependencies = [
 "libc",
 "windows-sys 0.60.2",
]

[[package]]
name = "pango"
version = "0.18.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7ca27ec1eb0457ab26f3036ea52229edbdb74dee1edd29063f5b9b010e7ebee4"
dependencies = [
 "gio",
 "glib",
 "libc",
 "once_cell",
 "pango-sys",
]

[[package]]
name = "pango-sys"
version = "0.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "436737e391a843e5933d6d9aa102cb126d501e815b83601365a948a518555dc5"
dependencies = [
 "glib-sys",
 "gobject-sys",
 "libc",
 "system-deps",
]

[[package]]
name = "parking"
version = "2.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f38d5652c16fde515bb1ecef450ab0f6a219d619a7274976324d5e377f7dceba"

[[package]]
name = "parking_lot"
version = "0.12.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70d58bf43669b5795d1576d0641cfb6fbb2057bf629506267a92807158584a13"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc838d2a56b5b1a6c25f55575dfc605fabb63bb2365f6c2353ef9159aa69e4a5"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall",
 "smallvec",
 "windows-targets 0.52.6",
]

[[package]]
name = "pathdiff"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df94ce210e5bc13cb6651479fa48d14f601d9858cfe0467f43ae157023b938d3"

[[package]]
name = "percent-encoding"
version = "2.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"

[[package]]
name = "phf"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3dfb61232e34fcb633f43d12c58f83c1df82962dcdfa565a4e866ffc17dafe12"
dependencies = [
 "phf_shared 0.8.0",
]

[[package]]
name = "phf"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fabbf1ead8a5bcbc20f5f8b939ee3f5b0f6f281b6ad3468b84656b658b455259"
dependencies = [
 "phf_macros 0.10.0",
 "phf_shared 0.10.0",
 "proc-macro-hack",
]

[[package]]
name = "phf"
version = "0.11.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd6780a80ae0c52cc120a26a1a42c1ae51b247a253e4e06113d23d2c2edd078"
dependencies = [
 "phf_macros 0.11.3",
 "phf_shared 0.11.3",
]

[[package]]
name = "phf_codegen"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cbffee61585b0411840d3ece935cce9cb6321f01c45477d30066498cd5e1a815"
dependencies = [
 "phf_generator 0.8.0",
 "phf_shared 0.8.0",
]

[[package]]
name = "phf_codegen"
version = "0.11.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aef8048c789fa5e851558d709946d6d79a8ff88c0440c587967f8e94bfb1216a"
dependencies = [
 "phf_generator 0.11.3",
 "phf_shared 0.11.3",
]

[[package]]
name = "phf_generator"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17367f0cc86f2d25802b2c26ee58a7b23faeccf78a396094c13dced0d0182526"
dependencies = [
 "phf_shared 0.8.0",
 "rand 0.7.3",
]

[[package]]
name = "phf_generator"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d5285893bb5eb82e6aaf5d59ee909a06a16737a8970984dd7746ba9283498d6"
dependencies = [
 "phf_shared 0.10.0",
 "rand 0.8.5",
]

[[package]]
name = "phf_generator"
version = "0.11.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c80231409c20246a13fddb31776fb942c38553c51e871f8cbd687a4cfb5843d"
dependencies = [
 "phf_shared 0.11.3",
 "rand 0.8.5",
]

[[package]]
name = "phf_macros"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "58fdf3184dd560f160dd73922bea2d5cd6e8f064bf4b13110abd81b03697b4e0"
dependencies = [
 "phf_generator 0.10.0",
 "phf_shared 0.10.0",
 "proc-macro-hack",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "phf_macros"
version = "0.11.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f84ac04429c13a7ff43785d75ad27569f2951ce0ffd30a3321230db2fc727216"
dependencies = [
 "phf_generator 0.11.3",
 "phf_shared 0.11.3",
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "phf_shared"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c00cf8b9eafe68dde5e9eaa2cef8ee84a9336a47d566ec55ca16589633b65af7"
dependencies = [
 "siphasher 0.3.11",
]

[[package]]
name = "phf_shared"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6796ad771acdc0123d2a88dc428b5e38ef24456743ddb1744ed628f9815c096"
dependencies = [
 "siphasher 0.3.11",
]

[[package]]
name = "phf_shared"
version = "0.11.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67eabc2ef2a60eb7faa00097bd1ffdb5bd28e62bf39990626a582201b7a754e5"
dependencies = [
 "siphasher 1.0.1",
]

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "piper"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96c8c490f422ef9a4efd2cb5b42b76c8613d7e7dfc1caf667b8a3350a5acc066"
dependencies = [
 "atomic-waker",
 "fastrand",
 "futures-io",
]

[[package]]
name = "pkg-config"
version = "0.3.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7edddbd0b52d732b21ad9a5fab5c704c14cd949e5e9a1ec5929a24fded1b904c"

[[package]]
name = "plist"
version = "1.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3af6b589e163c5a788fab00ce0c0366f6efbb9959c2f9874b224936af7fce7e1"
dependencies = [
 "base64 0.22.1",
 "indexmap 2.10.0",
 "quick-xml 0.38.0",
 "serde",
 "time",
]

[[package]]
name = "png"
version = "0.17.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "82151a2fc869e011c153adc57cf2789ccb8d9906ce52c0b39a6b5697749d7526"
dependencies = [
 "bitflags 1.3.2",
 "crc32fast",
 "fdeflate",
 "flate2",
 "miniz_oxide",
]

[[package]]
name = "polling"
version = "3.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ee9b2fa7a4517d2c91ff5bc6c297a427a96749d15f98fcdbb22c05571a4d4b7"
dependencies = [
 "cfg-if",
 "concurrent-queue",
 "hermit-abi",
 "pin-project-lite",
 "rustix",
 "windows-sys 0.60.2",
]

[[package]]
name = "pollster"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f3a9f18d041e6d0e102a0a46750538147e5e8992d3b4873aaafee2520b00ce3"

[[package]]
name = "potential_utf"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5a7c30837279ca13e7c867e9e40053bc68740f988cb07f7ca6df43cc734b585"
dependencies = [
 "zerovec",
]

[[package]]
name = "powerfmt"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "439ee305def115ba05938db6eb1644ff94165c5ab5e9420d1c1bcedbba909391"

[[package]]
name = "ppv-lite86"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85eae3c4ed2f50dcfe72643da4befc30deadb458a9b590d720cde2f2b1e97da9"
dependencies = [
 "zerocopy",
]

[[package]]
name = "precomputed-hash"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "925383efa346730478fb4838dbe9137d2a47675ad789c546d150a6e1dd4ab31c"

[[package]]
name = "proc-macro-crate"
version = "1.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f4c021e1093a56626774e81216a4ce732a735e5bad4868a03f3ed65ca0c3919"
dependencies = [
 "once_cell",
 "toml_edit 0.19.15",
]

[[package]]
name = "proc-macro-crate"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e8366a6159044a37876a2b9817124296703c586a5c92e2c53751fa06d8d43e8"
dependencies = [
 "toml_edit 0.20.7",
]

[[package]]
name = "proc-macro-crate"
version = "3.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "edce586971a4dfaa28950c6f18ed55e0406c1ab88bbce2c6f6293a7aaba73d35"
dependencies = [
 "toml_edit 0.22.27",
]

[[package]]
name = "proc-macro-error"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c"
dependencies = [
 "proc-macro-error-attr",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
 "version_check",
]

[[package]]
name = "proc-macro-error-attr"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869"
dependencies = [
 "proc-macro2",
 "quote",
 "version_check",
]

[[package]]
name = "proc-macro-hack"
version = "0.5.20+deprecated"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc375e1527247fe1a97d8b7156678dfe7c1af2fc075c9a4db3690ecd2a148068"

[[package]]
name = "proc-macro2"
version = "1.0.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quick-xml"
version = "0.37.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "331e97a1af0bf59823e6eadffe373d7b27f485be8748f71471c662c1f269b7fb"
dependencies = [
 "memchr",
]

[[package]]
name = "quick-xml"
version = "0.38.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8927b0664f5c5a98265138b7e3f90aa19a6b21353182469ace36d4ac527b7b1b"
dependencies = [
 "memchr",
]

[[package]]
name = "quote"
version = "1.0.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "r-efi"
version = "5.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69cdb34c158ceb288df11e18b4bd39de994f6657d83847bdffdbd7f346754b0f"

[[package]]
name = "rand"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03"
dependencies = [
 "getrandom 0.1.16",
 "libc",
 "rand_chacha 0.2.2",
 "rand_core 0.5.1",
 "rand_hc",
 "rand_pcg",
]

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha 0.3.1",
 "rand_core 0.6.4",
]

[[package]]
name = "rand"
version = "0.9.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6db2770f06117d490610c7488547d543617b21bfa07796d7a12f6f1bd53850d1"
dependencies = [
 "rand_chacha 0.9.0",
 "rand_core 0.9.3",
]

[[package]]
name = "rand_chacha"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4c8ed856279c9737206bf725bf36935d8666ead7aa69b52be55af369d193402"
dependencies = [
 "ppv-lite86",
 "rand_core 0.5.1",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core 0.6.4",
]

[[package]]
name = "rand_chacha"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3022b5f1df60f26e1ffddd6c66e8aa15de382ae63b3a0c1bfc0e4d3e3f325cb"
dependencies = [
 "ppv-lite86",
 "rand_core 0.9.3",
]

[[package]]
name = "rand_core"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "90bde5296fc891b0cef12a6d03ddccc162ce7b2aff54160af9338f8d40df6d19"
dependencies = [
 "getrandom 0.1.16",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom 0.2.16",
]

[[package]]
name = "rand_core"
version = "0.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "99d9a13982dcf210057a8a78572b2217b667c3beacbf3a0d8b454f6f82837d38"
dependencies = [
 "getrandom 0.3.3",
]

[[package]]
name = "rand_hc"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ca3129af7b92a17112d59ad498c6f81eaf463253766b90396d39ea7a39d6613c"
dependencies = [
 "rand_core 0.5.1",
]

[[package]]
name = "rand_pcg"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "16abd0c1b639e9eb4d7c50c0b8100b0d0f849be2349829c740fe8e6eb4816429"
dependencies = [
 "rand_core 0.5.1",
]

[[package]]
name = "raw-window-handle"
version = "0.6.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "20675572f6f24e9e76ef639bc5552774ed45f1c30e2951e1e99c59888861c539"

[[package]]
name = "rayon"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "368f01d005bf8fd9b1206fb6fa653e6c4a81ceb1466406b81792d87c5677a58f"
dependencies = [
 "either",
 "rayon-core",
]

[[package]]
name = "rayon-core"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22e18b0f0062d30d4230b2e85ff77fdfe4326feb054b9783a3460d8435c8ab91"
dependencies = [
 "crossbeam-deque",
 "crossbeam-utils",
]

[[package]]
name = "redox_syscall"
version = "0.5.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e8af0dde094006011e6a740d4879319439489813bd0bcdc7d821beaeeff48ec"
dependencies = [
 "bitflags 2.9.1",
]

[[package]]
name = "redox_users"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba009ff324d1fc1b900bd1fdb31564febe58a8ccc8a6fdbb93b543d33b13ca43"
dependencies = [
 "getrandom 0.2.16",
 "libredox",
 "thiserror 1.0.69",
]

[[package]]
name = "redox_users"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd6f9d3d47bdd2ad6945c5015a226ec6155d0bcdfd8f7cd29f86b71f8de99d2b"
dependencies = [
 "getrandom 0.2.16",
 "libredox",
 "thiserror 2.0.12",
]

[[package]]
name = "ref-cast"
version = "1.0.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a0ae411dbe946a674d89546582cea4ba2bb8defac896622d6496f14c23ba5cf"
dependencies = [
 "ref-cast-impl",
]

[[package]]
name = "ref-cast-impl"
version = "1.0.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1165225c21bff1f3bbce98f5a1f889949bc902d3575308cc7b0de30b4f6d27c7"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "regex"
version = "1.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b544ef1b4eac5dc2db33ea63606ae9ffcfac26c1416a2806ae0bf5f56b201191"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "regex-automata"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "809e8dc61f6de73b46c85f4c96486310fe304c434cfa43669d7b40f711150908"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c"

[[package]]
name = "reqwest"
version = "0.12.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cbc931937e6ca3a06e3b6c0aa7841849b160a90351d6ab467a8b9b9959767531"
dependencies = [
 "base64 0.22.1",
 "bytes",
 "encoding_rs",
 "futures-core",
 "futures-util",
 "h2",
 "http",
 "http-body",
 "http-body-util",
 "hyper",
 "hyper-rustls",
 "hyper-tls",
 "hyper-util",
 "js-sys",
 "log",
 "mime",
 "native-tls",
 "percent-encoding",
 "pin-project-lite",
 "rustls-pki-types",
 "serde",
 "serde_json",
 "serde_urlencoded",
 "sync_wrapper",
 "tokio",
 "tokio-native-tls",
 "tokio-util",
 "tower",
 "tower-http",
 "tower-service",
 "url",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "wasm-streams",
 "web-sys",
]

[[package]]
name = "rfd"
version = "0.15.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef2bee61e6cffa4635c72d7d81a84294e28f0930db0ddcb0f66d10244674ebed"
dependencies = [
 "ashpd",
 "block2 0.6.1",
 "dispatch2",
 "js-sys",
 "log",
 "objc2 0.6.1",
 "objc2-app-kit",
 "objc2-core-foundation",
 "objc2-foundation 0.3.1",
 "pollster",
 "raw-window-handle",
 "urlencoding",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
 "windows-sys 0.59.0",
]

[[package]]
name = "ring"
version = "0.17.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4689e6c2294d81e88dc6261c768b63bc4fcdb852be6d1352498b114f61383b7"
dependencies = [
 "cc",
 "cfg-if",
 "getrandom 0.2.16",
 "libc",
 "untrusted",
 "windows-sys 0.52.0",
]

[[package]]
name = "rusqlite"
version = "0.32.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7753b721174eb8ff87a9a0e799e2d7bc3749323e773db92e0984debb00019d6e"
dependencies = [
 "bitflags 2.9.1",
 "fallible-iterator",
 "fallible-streaming-iterator",
 "hashlink",
 "libsqlite3-sys",
 "smallvec",
]

[[package]]
name = "rustc-demangle"
version = "0.1.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "989e6739f80c4ad5b13e0fd7fe89531180375b18520cc8c82080e4dc4035b84f"

[[package]]
name = "rustc_version"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfcb3a22ef46e85b45de6ee7e79d063319ebb6594faafcf1c225ea92ab6e9b92"
dependencies = [
 "semver",
]

[[package]]
name = "rustix"
version = "1.0.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "11181fbabf243db407ef8df94a6ce0b2f9a733bd8be4ad02b4eda9602296cac8"
dependencies = [
 "bitflags 2.9.1",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.60.2",
]

[[package]]
name = "rustls"
version = "0.23.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2491382039b29b9b11ff08b76ff6c97cf287671dbb74f0be44bda389fffe9bd1"
dependencies = [
 "once_cell",
 "rustls-pki-types",
 "rustls-webpki",
 "subtle",
 "zeroize",
]

[[package]]
name = "rustls-pki-types"
version = "1.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "229a4a4c221013e7e1f1a043678c5cc39fe5171437c88fb47151a21e6f5b5c79"
dependencies = [
 "zeroize",
]

[[package]]
name = "rustls-webpki"
version = "0.103.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0a17884ae0c1b773f1ccd2bd4a8c72f16da897310a98b0e84bf349ad5ead92fc"
dependencies = [
 "ring",
 "rustls-pki-types",
 "untrusted",
]

[[package]]
name = "rustversion"
version = "1.0.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a0d197bd2c9dc6e53b84da9556a69ba4cdfab8619eb41a8bd1cc2027a0f6b1d"

[[package]]
name = "ryu"
version = "1.0.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f"

[[package]]
name = "same-file"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
dependencies = [
 "winapi-util",
]

[[package]]
name = "schannel"
version = "0.1.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f29ebaa345f945cec9fbbc532eb307f0fdad8161f281b6369539c8d84876b3d"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "schemars"
version = "0.8.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3fbf2ae1b8bc8e02df939598064d22402220cd5bbcca1c76f7d6a310974d5615"
dependencies = [
 "dyn-clone",
 "indexmap 1.9.3",
 "schemars_derive",
 "serde",
 "serde_json",
 "url",
 "uuid",
]

[[package]]
name = "schemars"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4cd191f9397d57d581cddd31014772520aa448f65ef991055d7f61582c65165f"
dependencies = [
 "dyn-clone",
 "ref-cast",
 "serde",
 "serde_json",
]

[[package]]
name = "schemars"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "82d20c4491bc164fa2f6c5d44565947a52ad80b9505d8e36f8d54c27c739fcd0"
dependencies = [
 "dyn-clone",
 "ref-cast",
 "serde",
 "serde_json",
]

[[package]]
name = "schemars_derive"
version = "0.8.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32e265784ad618884abaea0600a9adf15393368d840e0222d101a072f3f7534d"
dependencies = [
 "proc-macro2",
 "quote",
 "serde_derive_internals",
 "syn 2.0.104",
]

[[package]]
name = "scoped-tls"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e1cf6437eb19a8f4a6cc0f7dca544973b0b78843adbfeb3683d1a94a0024a294"

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "security-framework"
version = "2.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "897b2245f0b511c87893af39b033e5ca9cce68824c4d7e7630b5a1d339658d02"
dependencies = [
 "bitflags 2.9.1",
 "core-foundation 0.9.4",
 "core-foundation-sys",
 "libc",
 "security-framework-sys",
]

[[package]]
name = "security-framework-sys"
version = "2.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49db231d56a190491cb4aeda9527f1ad45345af50b0851622a7adb8c03b01c32"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "selectors"
version = "0.24.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c37578180969d00692904465fb7f6b3d50b9a2b952b87c23d0e2e5cb5013416"
dependencies = [
 "bitflags 1.3.2",
 "cssparser",
 "derive_more",
 "fxhash",
 "log",
 "phf 0.8.0",
 "phf_codegen 0.8.0",
 "precomputed-hash",
 "servo_arc",
 "smallvec",
]

[[package]]
name = "semver"
version = "1.0.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56e6fa9c48d24d85fb3de5ad847117517440f6beceb7798af16b4a87d616b8d0"
dependencies = [
 "serde",
]

[[package]]
name = "serde"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f0e2c6ed6606019b4e29e69dbaba95b11854410e5347d525002456dbbb786b6"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde-untagged"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "299d9c19d7d466db4ab10addd5703e4c615dec2a5a16dbbafe191045e87ee66e"
dependencies = [
 "erased-serde",
 "serde",
 "typeid",
]

[[package]]
name = "serde_derive"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "serde_derive_internals"
version = "0.29.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "18d26a20a969b9e3fdf2fc2d9f21eda6c40e2de84c9408bb5d3b05d499aae711"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "serde_json"
version = "1.0.141"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "30b9eff21ebe718216c6ec64e1d9ac57087aad11efc64e32002bce4a0d4c03d3"
dependencies = [
 "itoa",
 "memchr",
 "ryu",
 "serde",
]

[[package]]
name = "serde_repr"
version = "0.1.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "175ee3e80ae9982737ca543e96133087cbd9a485eecc3bc4de9c1a37b47ea59c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "serde_spanned"
version = "0.6.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf41e0cfaf7226dca15e8197172c295a782857fcb97fad1808a166870dee75a3"
dependencies = [
 "serde",
]

[[package]]
name = "serde_spanned"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40734c41988f7306bb04f0ecf60ec0f3f1caa34290e4e8ea471dcd3346483b83"
dependencies = [
 "serde",
]

[[package]]
name = "serde_urlencoded"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3491c14715ca2294c4d6a88f15e84739788c1d030eed8c110436aafdaa2f3fd"
dependencies = [
 "form_urlencoded",
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "serde_with"
version = "3.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2c45cd61fefa9db6f254525d46e392b852e0e61d9a1fd36e5bd183450a556d5"
dependencies = [
 "base64 0.22.1",
 "chrono",
 "hex",
 "indexmap 1.9.3",
 "indexmap 2.10.0",
 "schemars 0.9.0",
 "schemars 1.0.4",
 "serde",
 "serde_derive",
 "serde_json",
 "serde_with_macros",
 "time",
]

[[package]]
name = "serde_with_macros"
version = "3.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "de90945e6565ce0d9a25098082ed4ee4002e047cb59892c318d66821e14bb30f"
dependencies = [
 "darling",
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "serialize-to-javascript"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04f3666a07a197cdb77cdf306c32be9b7f598d7060d50cfd4d5aa04bfd92f6c5"
dependencies = [
 "serde",
 "serde_json",
 "serialize-to-javascript-impl",
]

[[package]]
name = "serialize-to-javascript-impl"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "772ee033c0916d670af7860b6e1ef7d658a4629a6d0b4c8c3e67f09b3765b75d"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "servo_arc"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d52aa42f8fdf0fed91e5ce7f23d8138441002fa31dca008acf47e6fd4721f741"
dependencies = [
 "nodrop",
 "stable_deref_trait",
]

[[package]]
name = "sha2"
version = "0.10.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7507d819769d01a365ab707794a4084392c824f54a7a6a7862f8c3d0892b283"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "shared_child"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e362d9935bc50f019969e2f9ecd66786612daae13e8f277be7bfb66e8bed3f7"
dependencies = [
 "libc",
 "sigchld",
 "windows-sys 0.60.2",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "sigchld"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "47106eded3c154e70176fc83df9737335c94ce22f821c32d17ed1db1f83badb1"
dependencies = [
 "libc",
 "os_pipe",
 "signal-hook",
]

[[package]]
name = "signal-hook"
version = "0.3.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d881a16cf4426aa584979d30bd82cb33429027e42122b169753d6ef1085ed6e2"
dependencies = [
 "libc",
 "signal-hook-registry",
]

[[package]]
name = "signal-hook-registry"
version = "1.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9203b8055f63a2a00e2f593bb0510367fe707d7ff1e5c872de2f537b339e5410"
dependencies = [
 "libc",
]

[[package]]
name = "simd-adler32"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d66dc143e6b11c1eddc06d5c423cfc97062865baf299914ab64caa38182078fe"

[[package]]
name = "siphasher"
version = "0.3.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38b58827f4464d87d377d175e90bf58eb00fd8716ff0a62f80356b5e61555d0d"

[[package]]
name = "siphasher"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56199f7ddabf13fe5074ce809e7d3f42b42ae711800501b5b16ea82ad029c39d"

[[package]]
name = "slab"
version = "0.4.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04dc19736151f35336d325007ac991178d504a119863a2fcb3758cdb5e52c50d"

[[package]]
name = "smallvec"
version = "1.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"

[[package]]
name = "socket2"
version = "0.5.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e22376abed350d73dd1cd119b57ffccad95b4e585a7cda43e286245ce23c0678"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "socket2"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "233504af464074f9d066d7b5416c5f9b894a5862a6506e306f7b816cdd6f1807"
dependencies = [
 "libc",
 "windows-sys 0.59.0",
]

[[package]]
name = "softbuffer"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "18051cdd562e792cad055119e0cdb2cfc137e44e3987532e0f9659a77931bb08"
dependencies = [
 "bytemuck",
 "cfg_aliases",
 "core-graphics",
 "foreign-types 0.5.0",
 "js-sys",
 "log",
 "objc2 0.5.2",
 "objc2-foundation 0.2.2",
 "objc2-quartz-core 0.2.2",
 "raw-window-handle",
 "redox_syscall",
 "wasm-bindgen",
 "web-sys",
 "windows-sys 0.59.0",
]

[[package]]
name = "soup3"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "471f924a40f31251afc77450e781cb26d55c0b650842efafc9c6cbd2f7cc4f9f"
dependencies = [
 "futures-channel",
 "gio",
 "glib",
 "libc",
 "soup3-sys",
]

[[package]]
name = "soup3-sys"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7ebe8950a680a12f24f15ebe1bf70db7af98ad242d9db43596ad3108aab86c27"
dependencies = [
 "gio-sys",
 "glib-sys",
 "gobject-sys",
 "libc",
 "system-deps",
]

[[package]]
name = "stable_deref_trait"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"

[[package]]
name = "static_assertions"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"

[[package]]
name = "string_cache"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf776ba3fa74f83bf4b63c3dcbbf82173db2632ed8452cb2d891d33f459de70f"
dependencies = [
 "new_debug_unreachable",
 "parking_lot",
 "phf_shared 0.11.3",
 "precomputed-hash",
 "serde",
]

[[package]]
name = "string_cache_codegen"
version = "0.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c711928715f1fe0fe509c53b43e993a9a557babc2d0a3567d0a3006f1ac931a0"
dependencies = [
 "phf_generator 0.11.3",
 "phf_shared 0.11.3",
 "proc-macro2",
 "quote",
]

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "subtle"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"

[[package]]
name = "swift-rs"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4057c98e2e852d51fdcfca832aac7b571f6b351ad159f9eda5db1655f8d0c4d7"
dependencies = [
 "base64 0.21.7",
 "serde",
 "serde_json",
]

[[package]]
name = "syn"
version = "1.0.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn"
version = "2.0.104"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17b6f705963418cdb9927482fa304bc562ece2fdd4f616084c50b7023b435a40"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "sync_wrapper"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0bf256ce5efdfa370213c1dabab5935a12e49f2c58d15e9eac2870d3b4f27263"
dependencies = [
 "futures-core",
]

[[package]]
name = "synstructure"
version = "0.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "728a70f3dbaf5bab7f0c4b1ac8d7ae5ea60a4b5549c8a5914361c99147a709d2"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "system-configuration"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c879d448e9d986b661742763247d3693ed13609438cf3d006f51f5368a5ba6b"
dependencies = [
 "bitflags 2.9.1",
 "core-foundation 0.9.4",
 "system-configuration-sys",
]

[[package]]
name = "system-configuration-sys"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e1d1b10ced5ca923a1fcb8d03e96b8d3268065d724548c0211415ff6ac6bac4"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "system-deps"
version = "6.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a3e535eb8dded36d55ec13eddacd30dec501792ff23a0b1682c38601b8cf2349"
dependencies = [
 "cfg-expr",
 "heck 0.5.0",
 "pkg-config",
 "toml 0.8.23",
 "version-compare",
]

[[package]]
name = "tao"
version = "0.34.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3a753bdc39c07b192151523a3f77cd0394aa75413802c883a0f6f6a0e5ee2e7"
dependencies = [
 "bitflags 2.9.1",
 "block2 0.6.1",
 "core-foundation 0.10.1",
 "core-graphics",
 "crossbeam-channel",
 "dispatch",
 "dlopen2",
 "dpi",
 "gdkwayland-sys",
 "gdkx11-sys",
 "gtk",
 "jni",
 "lazy_static",
 "libc",
 "log",
 "ndk",
 "ndk-context",
 "ndk-sys",
 "objc2 0.6.1",
 "objc2-app-kit",
 "objc2-foundation 0.3.1",
 "once_cell",
 "parking_lot",
 "raw-window-handle",
 "scopeguard",
 "tao-macros",
 "unicode-segmentation",
 "url",
 "windows",
 "windows-core",
 "windows-version",
 "x11-dl",
]

[[package]]
name = "tao-macros"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4e16beb8b2ac17db28eab8bca40e62dbfbb34c0fcdc6d9826b11b7b5d047dfd"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "target-lexicon"
version = "0.12.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "61c41af27dd6d1e27b1b16b489db798443478cef1f06a660c96db617ba5de3b1"

[[package]]
name = "tauri"
version = "2.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "15524fc7959bfcaa051ba6d0b3fb1ef18e978de2176c7c6acb977f7fd14d35c7"
dependencies = [
 "anyhow",
 "bytes",
 "cookie",
 "dirs 6.0.0",
 "dunce",
 "embed_plist",
 "getrandom 0.3.3",
 "glob",
 "gtk",
 "heck 0.5.0",
 "http",
 "jni",
 "libc",
 "log",
 "mime",
 "muda",
 "objc2 0.6.1",
 "objc2-app-kit",
 "objc2-foundation 0.3.1",
 "objc2-ui-kit",
 "objc2-web-kit",
 "percent-encoding",
 "plist",
 "raw-window-handle",
 "reqwest",
 "serde",
 "serde_json",
 "serde_repr",
 "serialize-to-javascript",
 "swift-rs",
 "tauri-build",
 "tauri-macros",
 "tauri-runtime",
 "tauri-runtime-wry",
 "tauri-utils",
 "thiserror 2.0.12",
 "tokio",
 "tray-icon",
 "url",
 "webkit2gtk",
 "webview2-com",
 "window-vibrancy",
 "windows",
]

[[package]]
name = "tauri-build"
version = "2.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17fcb8819fd16463512a12f531d44826ce566f486d7ccd211c9c8cebdaec4e08"
dependencies = [
 "anyhow",
 "cargo_toml",
 "dirs 6.0.0",
 "glob",
 "heck 0.5.0",
 "json-patch",
 "schemars 0.8.22",
 "semver",
 "serde",
 "serde_json",
 "tauri-utils",
 "tauri-winres",
 "toml 0.9.2",
 "walkdir",
]

[[package]]
name = "tauri-codegen"
version = "2.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fa9844cefcf99554a16e0a278156ae73b0d8680bbc0e2ad1e4287aadd8489cf"
dependencies = [
 "base64 0.22.1",
 "brotli",
 "ico",
 "json-patch",
 "plist",
 "png",
 "proc-macro2",
 "quote",
 "semver",
 "serde",
 "serde_json",
 "sha2",
 "syn 2.0.104",
 "tauri-utils",
 "thiserror 2.0.12",
 "time",
 "url",
 "uuid",
 "walkdir",
]

[[package]]
name = "tauri-macros"
version = "2.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3764a12f886d8245e66b7ee9b43ccc47883399be2019a61d80cf0f4117446fde"
dependencies = [
 "heck 0.5.0",
 "proc-macro2",
 "quote",
 "syn 2.0.104",
 "tauri-codegen",
 "tauri-utils",
]

[[package]]
name = "tauri-plugin"
version = "2.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0e1d0a4860b7ff570c891e1d2a586bf1ede205ff858fbc305e0b5ae5d14c1377"
dependencies = [
 "anyhow",
 "glob",
 "plist",
 "schemars 0.8.22",
 "serde",
 "serde_json",
 "tauri-utils",
 "toml 0.9.2",
 "walkdir",
]

[[package]]
name = "tauri-plugin-opener"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ecee219f11cdac713ab32959db5d0cceec4810ba4f4458da992292ecf9660321"
dependencies = [
 "dunce",
 "glob",
 "objc2-app-kit",
 "objc2-foundation 0.3.1",
 "open",
 "schemars 0.8.22",
 "serde",
 "serde_json",
 "tauri",
 "tauri-plugin",
 "thiserror 2.0.12",
 "url",
 "windows",
 "zbus",
]

[[package]]
name = "tauri-plugin-shell"
version = "2.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c374b6db45f2a8a304f0273a15080d98c70cde86178855fc24653ba657a1144c"
dependencies = [
 "encoding_rs",
 "log",
 "open",
 "os_pipe",
 "regex",
 "schemars 0.8.22",
 "serde",
 "serde_json",
 "shared_child",
 "tauri",
 "tauri-plugin",
 "thiserror 2.0.12",
 "tokio",
]

[[package]]
name = "tauri-runtime"
version = "2.9.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87f766fe9f3d1efc4b59b17e7a891ad5ed195fa8d23582abb02e6c9a01137892"
dependencies = [
 "cookie",
 "dpi",
 "gtk",
 "http",
 "jni",
 "objc2 0.6.1",
 "objc2-ui-kit",
 "objc2-web-kit",
 "raw-window-handle",
 "serde",
 "serde_json",
 "tauri-utils",
 "thiserror 2.0.12",
 "url",
 "webkit2gtk",
 "webview2-com",
 "windows",
]

[[package]]
name = "tauri-runtime-wry"
version = "2.9.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7950f3bde6bcca6655bc5e76d3d6ec587ceb81032851ab4ddbe1f508bdea2729"
dependencies = [
 "gtk",
 "http",
 "jni",
 "log",
 "objc2 0.6.1",
 "objc2-app-kit",
 "objc2-foundation 0.3.1",
 "once_cell",
 "percent-encoding",
 "raw-window-handle",
 "softbuffer",
 "tao",
 "tauri-runtime",
 "tauri-utils",
 "url",
 "webkit2gtk",
 "webview2-com",
 "windows",
 "wry",
]

[[package]]
name = "tauri-utils"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76a423c51176eb3616ee9b516a9fa67fed5f0e78baaba680e44eb5dd2cc37490"
dependencies = [
 "anyhow",
 "brotli",
 "cargo_metadata",
 "ctor",
 "dunce",
 "glob",
 "html5ever",
 "http",
 "infer",
 "json-patch",
 "kuchikiki",
 "log",
 "memchr",
 "phf 0.11.3",
 "proc-macro2",
 "quote",
 "regex",
 "schemars 0.8.22",
 "semver",
 "serde",
 "serde-untagged",
 "serde_json",
 "serde_with",
 "swift-rs",
 "thiserror 2.0.12",
 "toml 0.9.2",
 "url",
 "urlpattern",
 "uuid",
 "walkdir",
]

[[package]]
name = "tauri-winres"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8d321dbc6f998d825ab3f0d62673e810c861aac2d0de2cc2c395328f1d113b4"
dependencies = [
 "embed-resource",
 "indexmap 2.10.0",
 "toml 0.8.23",
]

[[package]]
name = "tempfile"
version = "3.20.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8a64e3985349f2441a1a9ef0b853f869006c3855f2cda6862a94d26ebb9d6a1"
dependencies = [
 "fastrand",
 "getrandom 0.3.3",
 "once_cell",
 "rustix",
 "windows-sys 0.59.0",
]

[[package]]
name = "tendril"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d24a120c5fc464a3458240ee02c299ebcb9d67b5249c8848b09d639dca8d7bb0"
dependencies = [
 "futf",
 "mac",
 "utf-8",
]

[[package]]
name = "thiserror"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
dependencies = [
 "thiserror-impl 1.0.69",
]

[[package]]
name = "thiserror"
version = "2.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "567b8a2dae586314f7be2a752ec7474332959c6460e02bde30d702a66d488708"
dependencies = [
 "thiserror-impl 2.0.12",
]

[[package]]
name = "thiserror-impl"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "thiserror-impl"
version = "2.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f7cf42b4507d8ea322120659672cf1b9dbb93f8f2d4ecfd6e51350ff5b17a1d"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "time"
version = "0.3.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a7619e19bc266e0f9c5e6686659d394bc57973859340060a69221e57dbc0c40"
dependencies = [
 "deranged",
 "itoa",
 "num-conv",
 "powerfmt",
 "serde",
 "time-core",
 "time-macros",
]

[[package]]
name = "time-core"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c9e9a38711f559d9e3ce1cdb06dd7c5b8ea546bc90052da6d06bb76da74bb07c"

[[package]]
name = "time-macros"
version = "0.2.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3526739392ec93fd8b359c8e98514cb3e8e021beb4e5f597b00a0221f8ed8a49"
dependencies = [
 "num-conv",
 "time-core",
]

[[package]]
name = "tinystr"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d4f6d1145dcb577acf783d4e601bc1d76a13337bb54e6233add580b07344c8b"
dependencies = [
 "displaydoc",
 "zerovec",
]

[[package]]
name = "tokio"
version = "1.46.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0cc3a2344dafbe23a245241fe8b09735b521110d30fcefbbd5feb1797ca35d17"
dependencies = [
 "backtrace",
 "bytes",
 "io-uring",
 "libc",
 "mio",
 "parking_lot",
 "pin-project-lite",
 "signal-hook-registry",
 "slab",
 "socket2 0.5.10",
 "tokio-macros",
 "windows-sys 0.52.0",
]

[[package]]
name = "tokio-macros"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e06d43f1345a3bcd39f6a56dbb7dcab2ba47e68e8ac134855e7e2bdbaf8cab8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "tokio-native-tls"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbae76ab933c85776efabc971569dd6119c580d8f5d448769dec1764bf796ef2"
dependencies = [
 "native-tls",
 "tokio",
]

[[package]]
name = "tokio-rustls"
version = "0.26.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e727b36a1a0e8b74c376ac2211e40c2c8af09fb4013c60d910495810f008e9b"
dependencies = [
 "rustls",
 "tokio",
]

[[package]]
name = "tokio-util"
version = "0.7.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "66a539a9ad6d5d281510d5bd368c973d636c02dbf8a67300bfb6b950696ad7df"
dependencies = [
 "bytes",
 "futures-core",
 "futures-sink",
 "pin-project-lite",
 "tokio",
]

[[package]]
name = "toml"
version = "0.8.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc1beb996b9d83529a9e75c17a1686767d148d70663143c7854d8b4a09ced362"
dependencies = [
 "serde",
 "serde_spanned 0.6.9",
 "toml_datetime 0.6.11",
 "toml_edit 0.22.27",
]

[[package]]
name = "toml"
version = "0.9.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed0aee96c12fa71097902e0bb061a5e1ebd766a6636bb605ba401c45c1650eac"
dependencies = [
 "indexmap 2.10.0",
 "serde",
 "serde_spanned 1.0.0",
 "toml_datetime 0.7.0",
 "toml_parser",
 "toml_writer",
 "winnow 0.7.12",
]

[[package]]
name = "toml_datetime"
version = "0.6.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22cddaf88f4fbc13c51aebbf5f8eceb5c7c5a9da2ac40a13519eb5b0a0e8f11c"
dependencies = [
 "serde",
]

[[package]]
name = "toml_datetime"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bade1c3e902f58d73d3f294cd7f20391c1cb2fbcb643b73566bc773971df91e3"
dependencies = [
 "serde",
]

[[package]]
name = "toml_edit"
version = "0.19.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b5bb770da30e5cbfde35a2d7b9b8a2c4b8ef89548a7a6aeab5c9a576e3e7421"
dependencies = [
 "indexmap 2.10.0",
 "toml_datetime 0.6.11",
 "winnow 0.5.40",
]

[[package]]
name = "toml_edit"
version = "0.20.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70f427fce4d84c72b5b732388bf4a9f4531b53f74e2887e3ecb2481f68f66d81"
dependencies = [
 "indexmap 2.10.0",
 "toml_datetime 0.6.11",
 "winnow 0.5.40",
]

[[package]]
name = "toml_edit"
version = "0.22.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41fe8c660ae4257887cf66394862d21dbca4a6ddd26f04a3560410406a2f819a"
dependencies = [
 "indexmap 2.10.0",
 "serde",
 "serde_spanned 0.6.9",
 "toml_datetime 0.6.11",
 "toml_write",
 "winnow 0.7.12",
]

[[package]]
name = "toml_parser"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97200572db069e74c512a14117b296ba0a80a30123fbbb5aa1f4a348f639ca30"
dependencies = [
 "winnow 0.7.12",
]

[[package]]
name = "toml_write"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d99f8c9a7727884afe522e9bd5edbfc91a3312b36a77b5fb8926e4c31a41801"

[[package]]
name = "toml_writer"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fcc842091f2def52017664b53082ecbbeb5c7731092bad69d2c63050401dfd64"

[[package]]
name = "tower"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d039ad9159c98b70ecfd540b2573b97f7f52c3e8d9f8ad57a24b916a536975f9"
dependencies = [
 "futures-core",
 "futures-util",
 "pin-project-lite",
 "sync_wrapper",
 "tokio",
 "tower-layer",
 "tower-service",
]

[[package]]
name = "tower-http"
version = "0.6.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "adc82fd73de2a9722ac5da747f12383d2bfdb93591ee6c58486e0097890f05f2"
dependencies = [
 "bitflags 2.9.1",
 "bytes",
 "futures-util",
 "http",
 "http-body",
 "iri-string",
 "pin-project-lite",
 "tower",
 "tower-layer",
 "tower-service",
]

[[package]]
name = "tower-layer"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "121c2a6cda46980bb0fcd1647ffaf6cd3fc79a013de288782836f6df9c48780e"

[[package]]
name = "tower-service"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8df9b6e13f2d32c91b9bd719c00d1958837bc7dec474d94952798cc8e69eeec3"

[[package]]
name = "tracing"
version = "0.1.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
dependencies = [
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-attributes"
version = "0.1.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "81383ab64e72a7a8b8e13130c49e3dab29def6d0c7d76a03087b3cf71c5c6903"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "tracing-core"
version = "0.1.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9d12581f227e93f094d3af2ae690a574abb8a2b9b7a96e7cfe9647b2b617678"
dependencies = [
 "once_cell",
]

[[package]]
name = "tray-icon"
version = "0.21.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2da75ec677957aa21f6e0b361df0daab972f13a5bee3606de0638fd4ee1c666a"
dependencies = [
 "crossbeam-channel",
 "dirs 6.0.0",
 "libappindicator",
 "muda",
 "objc2 0.6.1",
 "objc2-app-kit",
 "objc2-core-foundation",
 "objc2-core-graphics",
 "objc2-foundation 0.3.1",
 "once_cell",
 "png",
 "serde",
 "thiserror 2.0.12",
 "windows-sys 0.59.0",
]

[[package]]
name = "try-lock"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e421abadd41a4225275504ea4d6566923418b7f05506fbc9c0fe86ba7396114b"

[[package]]
name = "twox-hash"
version = "2.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ea3136b675547379c4bd395ca6b938e5ad3c3d20fad76e7fe85f9e0d011419c"

[[package]]
name = "typeid"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc7d623258602320d5c55d1bc22793b57daff0ec7efc270ea7d55ce1d5f5471c"

[[package]]
name = "typenum"
version = "1.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1dccffe3ce07af9386bfd29e80c0ab1a8205a2fc34e4bcd40364df902cfa8f3f"

[[package]]
name = "uds_windows"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89daebc3e6fd160ac4aa9fc8b3bf71e1f74fbf92367ae71fb83a037e8bf164b9"
dependencies = [
 "memoffset",
 "tempfile",
 "winapi",
]

[[package]]
name = "unic-char-property"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8c57a407d9b6fa02b4795eb81c5b6652060a15a7903ea981f3d723e6c0be221"
dependencies = [
 "unic-char-range",
]

[[package]]
name = "unic-char-range"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0398022d5f700414f6b899e10b8348231abf9173fa93144cbc1a43b9793c1fbc"

[[package]]
name = "unic-common"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "80d7ff825a6a654ee85a63e80f92f054f904f21e7d12da4e22f9834a4aaa35bc"

[[package]]
name = "unic-ucd-ident"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e230a37c0381caa9219d67cf063aa3a375ffed5bf541a452db16e744bdab6987"
dependencies = [
 "unic-char-property",
 "unic-char-range",
 "unic-ucd-version",
]

[[package]]
name = "unic-ucd-version"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96bd2f2237fe450fcd0a1d2f5f4e91711124f7857ba2e964247776ebeeb7b0c4"
dependencies = [
 "unic-common",
]

[[package]]
name = "unicode-ident"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"

[[package]]
name = "unicode-segmentation"
version = "1.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6ccf251212114b54433ec949fd6a7841275f9ada20dddd2f29e9ceea4501493"

[[package]]
name = "untrusted"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ecb6da28b8a351d773b68d5825ac39017e680750f980f3a1a85cd8dd28a47c1"

[[package]]
name = "url"
version = "2.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32f8b686cadd1473f4bd0117a5d28d36b1ade384ea9b5069a1c40aefed7fda60"
dependencies = [
 "form_urlencoded",
 "idna",
 "percent-encoding",
 "serde",
]

[[package]]
name = "urlencoding"
version = "2.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "daf8dba3b7eb870caf1ddeed7bc9d2a049f3cfdfae7cb521b087cc33ae4c49da"

[[package]]
name = "urlpattern"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70acd30e3aa1450bc2eece896ce2ad0d178e9c079493819301573dae3c37ba6d"
dependencies = [
 "regex",
 "serde",
 "unic-ucd-ident",
 "url",
]

[[package]]
name = "utf-8"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09cc8ee72d2a9becf2f2febe0205bbed8fc6615b7cb429ad062dc7b7ddd036a9"

[[package]]
name = "utf8_iter"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6c140620e7ffbb22c2dee59cafe6084a59b5ffc27a8859a5f0d494b5d52b6be"

[[package]]
name = "uuid"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3cf4199d1e5d15ddd86a694e4d0dffa9c323ce759fea589f00fef9d81cc1931d"
dependencies = [
 "getrandom 0.3.3",
 "js-sys",
 "serde",
 "wasm-bindgen",
]

[[package]]
name = "vcpkg"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"

[[package]]
name = "version-compare"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "852e951cb7832cb45cb1169900d19760cfa39b82bc0ea9c0e5a14ae88411c98b"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "vswhom"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "be979b7f07507105799e854203b470ff7c78a1639e330a58f183b5fea574608b"
dependencies = [
 "libc",
 "vswhom-sys",
]

[[package]]
name = "vswhom-sys"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fb067e4cbd1ff067d1df46c9194b5de0e98efd2810bbc95c5d5e5f25a3231150"
dependencies = [
 "cc",
 "libc",
]

[[package]]
name = "walkdir"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29790946404f91d9c5d06f9874efddea1dc06c5efe94541a7d6863108e3a5e4b"
dependencies = [
 "same-file",
 "winapi-util",
]

[[package]]
name = "want"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfa7760aed19e106de2c7c0b581b509f2f25d3dacaf737cb82ac61bc6d760b0e"
dependencies = [
 "try-lock",
]

[[package]]
name = "wasi"
version = "0.9.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cccddf32554fecc6acb585f82a32a72e28b48f8c4c1883ddfeeeaa96f7d8e519"

[[package]]
name = "wasi"
version = "0.11.1+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"

[[package]]
name = "wasi"
version = "0.14.2+wasi-0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9683f9a5a998d873c0d21fcbe3c083009670149a8fab228644b8bd36b2c48cb3"
dependencies = [
 "wit-bindgen-rt",
]

[[package]]
name = "wasm-bindgen"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5"
dependencies = [
 "cfg-if",
 "once_cell",
 "rustversion",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6"
dependencies = [
 "bumpalo",
 "log",
 "proc-macro2",
 "quote",
 "syn 2.0.104",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-futures"
version = "0.4.50"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "555d470ec0bc3bb57890405e5d4322cc9ea83cebb085523ced7be4144dac1e61"
dependencies = [
 "cfg-if",
 "js-sys",
 "once_cell",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "wasm-streams"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "15053d8d85c7eccdbefef60f06769760a563c7f0a9d6902a13d35c7800b0ad65"
dependencies = [
 "futures-util",
 "js-sys",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
]

[[package]]
name = "wayland-backend"
version = "0.3.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "673a33c33048a5ade91a6b139580fa174e19fb0d23f396dca9fa15f2e1e49b35"
dependencies = [
 "cc",
 "downcast-rs",
 "rustix",
 "scoped-tls",
 "smallvec",
 "wayland-sys",
]

[[package]]
name = "wayland-client"
version = "0.31.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c66a47e840dc20793f2264eb4b3e4ecb4b75d91c0dd4af04b456128e0bdd449d"
dependencies = [
 "bitflags 2.9.1",
 "rustix",
 "wayland-backend",
 "wayland-scanner",
]

[[package]]
name = "wayland-protocols"
version = "0.32.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "efa790ed75fbfd71283bd2521a1cfdc022aabcc28bdcff00851f9e4ae88d9901"
dependencies = [
 "bitflags 2.9.1",
 "wayland-backend",
 "wayland-client",
 "wayland-scanner",
]

[[package]]
name = "wayland-scanner"
version = "0.31.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "54cb1e9dc49da91950bdfd8b848c49330536d9d1fb03d4bfec8cae50caa50ae3"
dependencies = [
 "proc-macro2",
 "quick-xml 0.37.5",
 "quote",
]

[[package]]
name = "wayland-sys"
version = "0.31.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34949b42822155826b41db8e5d0c1be3a2bd296c747577a43a3e6daefc296142"
dependencies = [
 "dlib",
 "log",
 "pkg-config",
]

[[package]]
name = "web-sys"
version = "0.3.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33b6dd2ef9186f1f2072e409e99cd22a975331a6b3591b12c764e0e55c60d5d2"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "webkit2gtk"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76b1bc1e54c581da1e9f179d0b38512ba358fb1af2d634a1affe42e37172361a"
dependencies = [
 "bitflags 1.3.2",
 "cairo-rs",
 "gdk",
 "gdk-sys",
 "gio",
 "gio-sys",
 "glib",
 "glib-sys",
 "gobject-sys",
 "gtk",
 "gtk-sys",
 "javascriptcore-rs",
 "libc",
 "once_cell",
 "soup3",
 "webkit2gtk-sys",
]

[[package]]
name = "webkit2gtk-sys"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62daa38afc514d1f8f12b8693d30d5993ff77ced33ce30cd04deebc267a6d57c"
dependencies = [
 "bitflags 1.3.2",
 "cairo-sys-rs",
 "gdk-sys",
 "gio-sys",
 "glib-sys",
 "gobject-sys",
 "gtk-sys",
 "javascriptcore-rs-sys",
 "libc",
 "pkg-config",
 "soup3-sys",
 "system-deps",
]

[[package]]
name = "webview2-com"
version = "0.38.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4ba622a989277ef3886dd5afb3e280e3dd6d974b766118950a08f8f678ad6a4"
dependencies = [
 "webview2-com-macros",
 "webview2-com-sys",
 "windows",
 "windows-core",
 "windows-implement",
 "windows-interface",
]

[[package]]
name = "webview2-com-macros"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d228f15bba3b9d56dde8bddbee66fa24545bd17b48d5128ccf4a8742b18e431"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "webview2-com-sys"
version = "0.38.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36695906a1b53a3bf5c4289621efedac12b73eeb0b89e7e1a89b517302d5d75c"
dependencies = [
 "thiserror 2.0.12",
 "windows",
 "windows-core",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf221c93e13a30d793f7645a0e7762c55d169dbb0a49671918a2319d289b10bb"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "window-vibrancy"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d9bec5a31f3f9362f2258fd0e9c9dd61a9ca432e7306cc78c444258f0dce9a9c"
dependencies = [
 "objc2 0.6.1",
 "objc2-app-kit",
 "objc2-core-foundation",
 "objc2-foundation 0.3.1",
 "raw-window-handle",
 "windows-sys 0.59.0",
 "windows-version",
]

[[package]]
name = "windows"
version = "0.61.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9babd3a767a4c1aef6900409f85f5d53ce2544ccdfaa86dad48c91782c6d6893"
dependencies = [
 "windows-collections",
 "windows-core",
 "windows-future",
 "windows-link",
 "windows-numerics",
]

[[package]]
name = "windows-collections"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3beeceb5e5cfd9eb1d76b381630e82c4241ccd0d27f1a39ed41b2760b255c5e8"
dependencies = [
 "windows-core",
]

[[package]]
name = "windows-core"
version = "0.61.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0fdd3ddb90610c7638aa2b3a3ab2904fb9e5cdbecc643ddb3647212781c4ae3"
dependencies = [
 "windows-implement",
 "windows-interface",
 "windows-link",
 "windows-result",
 "windows-strings",
]

[[package]]
name = "windows-future"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc6a41e98427b19fe4b73c550f060b59fa592d7d686537eebf9385621bfbad8e"
dependencies = [
 "windows-core",
 "windows-link",
 "windows-threading",
]

[[package]]
name = "windows-implement"
version = "0.60.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "windows-interface"
version = "0.59.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "windows-link"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e6ad25900d524eaabdbbb96d20b4311e1e7ae1699af4fb28c17ae66c80d798a"

[[package]]
name = "windows-numerics"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9150af68066c4c5c07ddc0ce30421554771e528bde427614c61038bc2c92c2b1"
dependencies = [
 "windows-core",
 "windows-link",
]

[[package]]
name = "windows-registry"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b8a9ed28765efc97bbc954883f4e6796c33a06546ebafacbabee9696967499e"
dependencies = [
 "windows-link",
 "windows-result",
 "windows-strings",
]

[[package]]
name = "windows-result"
version = "0.3.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56f42bd332cc6c8eac5af113fc0c1fd6a8fd2aa08a0119358686e5160d0586c6"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-strings"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56e6c93f3a0c3b36176cb1327a4958a0353d5d166c2a35cb268ace15e91d3b57"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-sys"
version = "0.45.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75283be5efb2831d37ea142365f009c02ec203cd29a3ebecbc093d52315b66d0"
dependencies = [
 "windows-targets 0.42.2",
]

[[package]]
name = "windows-sys"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
dependencies = [
 "windows-targets 0.48.5",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.60.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2f500e4d28234f72040990ec9d39e3a6b950f9f22d3dba18416c35882612bcb"
dependencies = [
 "windows-targets 0.53.2",
]

[[package]]
name = "windows-targets"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e5180c00cd44c9b1c88adb3693291f1cd93605ded80c250a75d472756b4d071"
dependencies = [
 "windows_aarch64_gnullvm 0.42.2",
 "windows_aarch64_msvc 0.42.2",
 "windows_i686_gnu 0.42.2",
 "windows_i686_msvc 0.42.2",
 "windows_x86_64_gnu 0.42.2",
 "windows_x86_64_gnullvm 0.42.2",
 "windows_x86_64_msvc 0.42.2",
]

[[package]]
name = "windows-targets"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
dependencies = [
 "windows_aarch64_gnullvm 0.48.5",
 "windows_aarch64_msvc 0.48.5",
 "windows_i686_gnu 0.48.5",
 "windows_i686_msvc 0.48.5",
 "windows_x86_64_gnu 0.48.5",
 "windows_x86_64_gnullvm 0.48.5",
 "windows_x86_64_msvc 0.48.5",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm 0.52.6",
 "windows_aarch64_msvc 0.52.6",
 "windows_i686_gnu 0.52.6",
 "windows_i686_gnullvm 0.52.6",
 "windows_i686_msvc 0.52.6",
 "windows_x86_64_gnu 0.52.6",
 "windows_x86_64_gnullvm 0.52.6",
 "windows_x86_64_msvc 0.52.6",
]

[[package]]
name = "windows-targets"
version = "0.53.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c66f69fcc9ce11da9966ddb31a40968cad001c5bedeb5c2b82ede4253ab48aef"
dependencies = [
 "windows_aarch64_gnullvm 0.53.0",
 "windows_aarch64_msvc 0.53.0",
 "windows_i686_gnu 0.53.0",
 "windows_i686_gnullvm 0.53.0",
 "windows_i686_msvc 0.53.0",
 "windows_x86_64_gnu 0.53.0",
 "windows_x86_64_gnullvm 0.53.0",
 "windows_x86_64_msvc 0.53.0",
]

[[package]]
name = "windows-threading"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b66463ad2e0ea3bbf808b7f1d371311c80e115c0b71d60efc142cafbcfb057a6"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-version"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e04a5c6627e310a23ad2358483286c7df260c964eb2d003d8efd6d0f4e79265c"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "597a5118570b68bc08d8d59125332c54f1ba9d9adeedeef5b99b02ba2b0698f8"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "86b8d5f90ddd19cb4a147a5fa63ca848db3df085e25fee3cc10b39b6eebae764"

[[package]]
name = "windows_aarch64_msvc"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e08e8864a60f06ef0d0ff4ba04124db8b0fb3be5776a5cd47641e942e58c4d43"

[[package]]
name = "windows_aarch64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_aarch64_msvc"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c7651a1f62a11b8cbd5e0d42526e55f2c99886c77e007179efff86c2b137e66c"

[[package]]
name = "windows_i686_gnu"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c61d927d8da41da96a81f029489353e68739737d3beca43145c8afec9a31a84f"

[[package]]
name = "windows_i686_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnu"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c1dc67659d35f387f5f6c479dc4e28f1d4bb90ddd1a5d3da2e5d97b42d6272c3"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_gnullvm"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ce6ccbdedbf6d6354471319e781c0dfef054c81fbc7cf83f338a4296c0cae11"

[[package]]
name = "windows_i686_msvc"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "44d840b6ec649f480a41c8d80f9c65108b92d89345dd94027bfe06ac444d1060"

[[package]]
name = "windows_i686_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_i686_msvc"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "581fee95406bb13382d2f65cd4a908ca7b1e4c2f1917f143ba16efe98a589b5d"

[[package]]
name = "windows_x86_64_gnu"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8de912b8b8feb55c064867cf047dda097f92d51efad5b491dfb98f6bbb70cb36"

[[package]]
name = "windows_x86_64_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnu"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2e55b5ac9ea33f2fc1716d1742db15574fd6fc8dadc51caab1c16a3d3b4190ba"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26d41b46a36d453748aedef1486d5c7a85db22e56aff34643984ea85514e94a3"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0a6e035dd0599267ce1ee132e51c27dd29437f63325753051e71dd9e42406c57"

[[package]]
name = "windows_x86_64_msvc"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9aec5da331524158c6d1a4ac0ab1541149c0b9505fde06423b02f5ef0106b9f0"

[[package]]
name = "windows_x86_64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "windows_x86_64_msvc"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "271414315aff87387382ec3d271b52d7ae78726f5d44ac98b4f4030c91880486"

[[package]]
name = "winnow"
version = "0.5.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f593a95398737aeed53e489c785df13f3618e41dbcd6718c6addbf1395aa6876"
dependencies = [
 "memchr",
]

[[package]]
name = "winnow"
version = "0.7.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3edebf492c8125044983378ecb5766203ad3b4c2f7a922bd7dd207f6d443e95"
dependencies = [
 "memchr",
]

[[package]]
name = "winreg"
version = "0.55.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb5a765337c50e9ec252c2069be9bf91c7df47afb103b642ba3a53bf8101be97"
dependencies = [
 "cfg-if",
 "windows-sys 0.59.0",
]

[[package]]
name = "wit-bindgen-rt"
version = "0.39.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f42320e61fe2cfd34354ecb597f86f413484a798ba44a8ca1165c58d42da6c1"
dependencies = [
 "bitflags 2.9.1",
]

[[package]]
name = "writeable"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ea2f10b9bb0928dfb1b42b65e1f9e36f7f54dbdf08457afefb38afcdec4fa2bb"

[[package]]
name = "wry"
version = "0.53.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "728b7d4c8ec8d81cab295e0b5b8a4c263c0d41a785fb8f8c4df284e5411140a2"
dependencies = [
 "base64 0.22.1",
 "block2 0.6.1",
 "cookie",
 "crossbeam-channel",
 "dirs 6.0.0",
 "dpi",
 "dunce",
 "gdkx11",
 "gtk",
 "html5ever",
 "http",
 "javascriptcore-rs",
 "jni",
 "kuchikiki",
 "libc",
 "ndk",
 "objc2 0.6.1",
 "objc2-app-kit",
 "objc2-core-foundation",
 "objc2-foundation 0.3.1",
 "objc2-ui-kit",
 "objc2-web-kit",
 "once_cell",
 "percent-encoding",
 "raw-window-handle",
 "sha2",
 "soup3",
 "tao-macros",
 "thiserror 2.0.12",
 "url",
 "webkit2gtk",
 "webkit2gtk-sys",
 "webview2-com",
 "windows",
 "windows-core",
 "windows-version",
 "x11-dl",
]

[[package]]
name = "x11"
version = "2.21.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "502da5464ccd04011667b11c435cb992822c2c0dbde1770c988480d312a0db2e"
dependencies = [
 "libc",
 "pkg-config",
]

[[package]]
name = "x11-dl"
version = "2.21.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38735924fedd5314a6e548792904ed8c6de6636285cb9fec04d5b1db85c1516f"
dependencies = [
 "libc",
 "once_cell",
 "pkg-config",
]

[[package]]
name = "yoke"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f41bb01b8226ef4bfd589436a297c53d118f65921786300e427be8d487695cc"
dependencies = [
 "serde",
 "stable_deref_trait",
 "yoke-derive",
 "zerofrom",
]

[[package]]
name = "yoke-derive"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38da3c9736e16c5d3c8c597a9aaa5d1fa565d0532ae05e27c24aa62fb32c0ab6"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
 "synstructure",
]

[[package]]
name = "zbus"
version = "5.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4bb4f9a464286d42851d18a605f7193b8febaf5b0919d71c6399b7b26e5b0aad"
dependencies = [
 "async-broadcast",
 "async-executor",
 "async-io",
 "async-lock",
 "async-process",
 "async-recursion",
 "async-task",
 "async-trait",
 "blocking",
 "enumflags2",
 "event-listener",
 "futures-core",
 "futures-lite",
 "hex",
 "nix",
 "ordered-stream",
 "serde",
 "serde_repr",
 "tracing",
 "uds_windows",
 "windows-sys 0.59.0",
 "winnow 0.7.12",
 "zbus_macros",
 "zbus_names",
 "zvariant",
]

[[package]]
name = "zbus_macros"
version = "5.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef9859f68ee0c4ee2e8cde84737c78e3f4c54f946f2a38645d0d4c7a95327659"
dependencies = [
 "proc-macro-crate 3.3.0",
 "proc-macro2",
 "quote",
 "syn 2.0.104",
 "zbus_names",
 "zvariant",
 "zvariant_utils",
]

[[package]]
name = "zbus_names"
version = "4.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7be68e64bf6ce8db94f63e72f0c7eb9a60d733f7e0499e628dfab0f84d6bcb97"
dependencies = [
 "serde",
 "static_assertions",
 "winnow 0.7.12",
 "zvariant",
]

[[package]]
name = "zerocopy"
version = "0.8.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1039dd0d3c310cf05de012d8a39ff557cb0d23087fd44cad61df08fc31907a2f"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.8.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ecf5b4cc5364572d7f4c329661bcc82724222973f2cab6f050a4e5c22f75181"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "zerofrom"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50cc42e0333e05660c3587f3bf9d0478688e15d870fab3346451ce7f8c9fbea5"
dependencies = [
 "zerofrom-derive",
]

[[package]]
name = "zerofrom-derive"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71e5d6e06ab090c67b5e44993ec16b72dcbaabc526db883a360057678b48502"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
 "synstructure",
]

[[package]]
name = "zeroize"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ced3678a2879b30306d323f4542626697a464a97c0a07c9aebf7ebca65cd4dde"

[[package]]
name = "zerotrie"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36f0bbd478583f79edad978b407914f61b2972f5af6fa089686016be8f9af595"
dependencies = [
 "displaydoc",
 "yoke",
 "zerofrom",
]

[[package]]
name = "zerovec"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a05eb080e015ba39cc9e23bbe5e7fb04d5fb040350f99f34e338d5fdd294428"
dependencies = [
 "yoke",
 "zerofrom",
 "zerovec-derive",
]

[[package]]
name = "zerovec-derive"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b96237efa0c878c64bd89c436f661be4e46b2f3eff1ebb976f7ef2321d2f58f"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.104",
]

[[package]]
name = "zvariant"
version = "5.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d91b3680bb339216abd84714172b5138a4edac677e641ef17e1d8cb1b3ca6e6f"
dependencies = [
 "endi",
 "enumflags2",
 "serde",
 "url",
 "winnow 0.7.12",
 "zvariant_derive",
 "zvariant_utils",
]

[[package]]
name = "zvariant_derive"
version = "5.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3a8c68501be459a8dbfffbe5d792acdd23b4959940fc87785fb013b32edbc208"
dependencies = [
 "proc-macro-crate 3.3.0",
 "proc-macro2",
 "quote",
 "syn 2.0.104",
 "zvariant_utils",
]

[[package]]
name = "zvariant_utils"
version = "3.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e16edfee43e5d7b553b77872d99bc36afdda75c223ca7ad5e3fbecd82ca5fc34"
dependencies = [
 "proc-macro2",
 "quote",
 "serde",
 "static_assertions",
 "syn 2.0.104",
 "winnow 0.7.12",
]

```

`src/client/src-tauri/Cargo.toml`:

```toml
[package]
name = "DynaDbg"
version = "0.1.0"
description = "A Tauri App"
authors = ["ichise@doranekosystems.com"]
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[features]
default = []

[lib]
# The `_lib` suffix may seem redundant but it is necessary
# to make the lib name unique and wouldn't conflict with the bin name.
# This seems to be only an issue on Windows, see https://github.com/rust-lang/cargo/issues/8519
name = "dyna_dbg_lib"
crate-type = ["staticlib", "cdylib", "rlib"]

[build-dependencies]
tauri-build = { version = "2", features = [] }

[dependencies]
tauri = { version = "2", features = [] }
tauri-plugin-opener = "2"
tauri-plugin-shell = "2"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
tokio = { version = "1", features = ["full"] }
reqwest = { version = "0.12", features = ["json"] }
anyhow = "1.0"
capstone = "0.12"
cpp_demangle = "0.4"
rustc-demangle = "0.1"
dirs = "5.0"
urlencoding = "2.1"
rusqlite = { version = "0.32", features = ["bundled"] }
once_cell = "1.19"
libc = "0.2"
rfd = "0.15"
base64 = "0.22"
hex = "0.4"
lz4_flex = "0.11"
rayon = "1.10"
walrus = "0.23"
wasmparser = "0.220"



```

`src/client/src-tauri/build.rs`:

```rs
fn main() {
    tauri_build::build()
}

```

`src/client/src-tauri/capabilities/default.json`:

```json
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "default",
  "description": "Capability for the main window",
  "windows": ["main", "*"],
  "permissions": [
    "core:default",
    "core:app:default",
    "core:app:allow-app-show",
    "core:app:allow-app-hide",
    "core:window:default",
    "core:window:allow-show",
    "core:window:allow-hide",
    "core:window:allow-minimize",
    "core:window:allow-maximize",
    "core:window:allow-close",
    "core:window:allow-destroy",
    "core:window:allow-set-resizable",
    "core:window:allow-set-title",
    "core:window:allow-set-focus",
    "core:window:allow-set-always-on-top",
    "core:window:allow-create",
    "core:webview:default",
    "core:webview:allow-create-webview",
    "core:webview:allow-create-webview-window",
    "core:webview:allow-internal-toggle-devtools",
    "core:event:default",
    "core:event:allow-listen",
    "core:event:allow-emit",
    "core:event:allow-unlisten",
    "opener:default",
    "shell:allow-open"
  ]
}

```

`src/client/src-tauri/capabilities/watchpoint.json`:

```json
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "watchpoint",
  "description": "Capability for watchpoint windows",
  "windows": ["*"],
  "permissions": [
    "core:default",
    "core:app:default",
    "core:window:default",
    "core:window:allow-show",
    "core:window:allow-hide",
    "core:window:allow-minimize",
    "core:window:allow-maximize",
    "core:window:allow-close",
    "core:window:allow-set-resizable",
    "core:window:allow-set-title",
    "core:window:allow-set-focus",
    "core:window:allow-set-always-on-top",
    "core:webview:default",
    "core:webview:allow-internal-toggle-devtools",
    "core:event:default",
    "core:event:allow-listen",
    "core:event:allow-emit",
    "core:event:allow-unlisten"
  ]
}

```

`src/client/src-tauri/deny.toml`:

```toml
# cargo-deny configuration
# Run with: cargo deny check
# Install with: cargo install cargo-deny

[advisories]
db-path = "~/.cargo/advisory-db"
db-urls = ["https://github.com/rustsec/advisory-db"]
version = 2

# Use 'ignore' to specify advisories to skip
ignore = [
    # Example: "RUSTSEC-2020-0001"
]

[licenses]
# List of explicitly allowed licenses
allow = [
    "MIT",
    "Apache-2.0",
    "Apache-2.0 WITH LLVM-exception",
    "BSD-2-Clause",
    "BSD-3-Clause",
    "ISC",
    "Zlib",
    "0BSD",
    "CC0-1.0",
    "Unlicense",
    "BSL-1.0",        # Boost Software License
    "Unicode-DFS-2016",
    "MPL-2.0",        # Mozilla Public License (weak copyleft, file-level only)
]

# Confidence threshold for detecting a license
confidence-threshold = 0.8

# Allow 1 or more licenses on a per-crate basis
exceptions = [
    # Example: { allow = ["LGPL-3.0"], name = "some-crate" }
]

# Deny copyleft licenses that would require open-sourcing proprietary code
[licenses.private]
ignore = false
registries = []

# Some crates don't have (easily) machine readable licensing
[[licenses.clarify]]
name = "ring"
expression = "MIT AND ISC AND OpenSSL"
license-files = [{ path = "LICENSE", hash = 0xbd0eed23 }]

[[licenses.clarify]]
name = "encoding_rs"
expression = "(Apache-2.0 OR MIT) AND BSD-3-Clause"
license-files = [{ path = "LICENSE", hash = 0x19881434 }]

[bans]
# Lint level for when multiple versions of the same crate are detected
multiple-versions = "warn"
# Lint level for when a crate version has been yanked from crates.io
wildcards = "allow"
highlight = "all"

# List of crates to deny
deny = [
    # Add any crates you want to explicitly deny
]

# List of crates to allow
allow = [
    # Add any crates you want to explicitly allow
]

# Certain crates/versions that will be skipped when doing duplicate detection
skip = [
    # Add any crates you want to skip
]

skip-tree = [
    # Add any crate trees you want to skip
]

[sources]
# Lint level for what to happen when a crate from a crate registry is not found
unknown-registry = "warn"
# Lint level for what to happen when a crate from a git repository is not found
unknown-git = "warn"
# List of URLs for allowed crate registries
allow-registry = ["https://github.com/rust-lang/crates.io-index"]
# List of URLs for allowed Git repositories
allow-git = []

```

`src/client/src-tauri/src/lib.rs`:

```rs
use serde::{Deserialize, Serialize};
use capstone::prelude::*;
use tauri::{Manager, PhysicalSize, Size, Emitter};
use cpp_demangle::Symbol as CppSymbol;
use rustc_demangle::demangle as rustc_demangle;
use std::path::PathBuf;
use std::process::{Command, Child, Stdio};
use std::sync::{Mutex, RwLock};
use tokio::fs;
use tokio::io::AsyncWriteExt;
use rusqlite::{Connection, params};
use once_cell::sync::Lazy;
use std::collections::HashMap;
use wasmparser::{Parser, Payload, Operator};

#[cfg(windows)]
use std::os::windows::process::CommandExt;

#[cfg(unix)]
use std::os::unix::process::CommandExt as UnixCommandExt;

// Windows flag to create process without a console window
#[cfg(windows)]
const CREATE_NO_WINDOW: u32 = 0x08000000;

/// Configure a Command to hide the console window on Windows
#[cfg(windows)]
fn hide_console_window(cmd: &mut Command) -> &mut Command {
    cmd.creation_flags(CREATE_NO_WINDOW)
}

/// Configure a Command to detach from terminal on Unix
#[cfg(unix)]
fn hide_console_window(cmd: &mut Command) -> &mut Command {
    // Detach from controlling terminal by creating a new session
    // SAFETY: setsid() is async-signal-safe
    unsafe {
        cmd.pre_exec(|| {
            libc::setsid();
            Ok(())
        });
    }
    // Also redirect stdin from /dev/null to prevent terminal interaction
    cmd.stdin(Stdio::null())
}

#[cfg(not(any(windows, unix)))]
fn hide_console_window(cmd: &mut Command) -> &mut Command {
    cmd
}

mod state;

// Global SQLite connection for Ghidra functions cache
static GHIDRA_DB: Lazy<Mutex<Option<Connection>>> = Lazy::new(|| {
    Mutex::new(None)
});

// Global Ghidra server processes (project_path -> child process)
static GHIDRA_SERVERS: Lazy<Mutex<HashMap<String, Child>>> = Lazy::new(|| {
    Mutex::new(HashMap::new())
});

// Ghidra server port mapping (project_path -> port)
static GHIDRA_SERVER_PORTS: Lazy<Mutex<HashMap<String, u16>>> = Lazy::new(|| {
    Mutex::new(HashMap::new())
});

// Ghidra server logs (project_path -> log lines)
static GHIDRA_SERVER_LOGS: Lazy<Mutex<HashMap<String, Vec<String>>>> = Lazy::new(|| {
    Mutex::new(HashMap::new())
});

// Global pointer scan cancel flag
static PTRSCAN_CANCEL: Lazy<std::sync::atomic::AtomicBool> = Lazy::new(|| {
    std::sync::atomic::AtomicBool::new(false)
});

fn init_ghidra_db() -> Result<(), String> {
    let ghidra_dir = get_ghidra_projects_dir();
    std::fs::create_dir_all(&ghidra_dir).map_err(|e| e.to_string())?;
    
    let db_path = ghidra_dir.join("ghidra_cache.db");
    let conn = Connection::open(&db_path).map_err(|e| e.to_string())?;
    
    // Create tables
    conn.execute(
        "CREATE TABLE IF NOT EXISTS analyzed_modules (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            target_os TEXT NOT NULL,
            module_name TEXT NOT NULL,
            module_path TEXT NOT NULL,
            local_path TEXT NOT NULL,
            project_path TEXT NOT NULL,
            analyzed_at INTEGER NOT NULL,
            UNIQUE(target_os, module_name)
        )",
        [],
    ).map_err(|e| e.to_string())?;
    
    conn.execute(
        "CREATE TABLE IF NOT EXISTS module_functions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            module_id INTEGER NOT NULL,
            name TEXT NOT NULL,
            address TEXT NOT NULL,
            size INTEGER NOT NULL,
            FOREIGN KEY(module_id) REFERENCES analyzed_modules(id) ON DELETE CASCADE
        )",
        [],
    ).map_err(|e| e.to_string())?;
    
    conn.execute(
        "CREATE INDEX IF NOT EXISTS idx_module_functions_module_id ON module_functions(module_id)",
        [],
    ).map_err(|e| e.to_string())?;
    
    // Simple JSON cache table for frontend compatibility
    conn.execute(
        "CREATE TABLE IF NOT EXISTS ghidra_functions_cache (
            target_os TEXT NOT NULL,
            module_name TEXT NOT NULL,
            functions_json TEXT NOT NULL,
            updated_at TEXT NOT NULL,
            PRIMARY KEY(target_os, module_name)
        )",
        [],
    ).map_err(|e| e.to_string())?;
    
    // Decompile cache table
    conn.execute(
        "CREATE TABLE IF NOT EXISTS ghidra_decompile_cache (
            target_os TEXT NOT NULL,
            module_name TEXT NOT NULL,
            function_address TEXT NOT NULL,
            function_name TEXT NOT NULL,
            decompiled_code TEXT NOT NULL,
            line_mapping_json TEXT,
            updated_at TEXT NOT NULL,
            PRIMARY KEY(target_os, module_name, function_address)
        )",
        [],
    ).map_err(|e| e.to_string())?;
    
    // Xref cache table
    conn.execute(
        "CREATE TABLE IF NOT EXISTS ghidra_xref_cache (
            target_os TEXT NOT NULL,
            module_name TEXT NOT NULL,
            function_address TEXT NOT NULL,
            function_name TEXT NOT NULL,
            xrefs_json TEXT NOT NULL,
            updated_at TEXT NOT NULL,
            PRIMARY KEY(target_os, module_name, function_address)
        )",
        [],
    ).map_err(|e| e.to_string())?;
    
    *GHIDRA_DB.lock().unwrap() = Some(conn);
    Ok(())
}

// Helper function to format ARM64 operands more clearly
fn format_arm64_operands(op_str: &str) -> String {
    // Basic formatting for ARM64 operands
    // Add spaces around commas for better readability
    let formatted = op_str.replace(",", ", ");
    
    // Handle common ARM64 addressing modes
    if formatted.contains("[") && formatted.contains("]") {
        // Memory addressing - keep as is but ensure proper spacing
        formatted
    } else if formatted.contains("#") {
        // Immediate values - ensure proper spacing
            formatted.replace("#", "#")
    } else {
        // Register operands - ensure proper spacing
        formatted
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DisassembleRequest {
    pub address: u64,
    pub size: usize,
    pub architecture: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DisassembleResponse {
    pub success: bool,
    pub disassembly: Option<String>,
    pub instructions_count: usize,
    pub error: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MemoryReadRequest {
    pub address: u64,
    pub size: usize,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MemoryReadResponse {
    pub success: bool,
    pub data: Option<Vec<u8>>,
    pub error: Option<String>,
}

// Ghidra integration structures
#[derive(Debug, Serialize, Deserialize)]
pub struct GhidraAnalysisStatus {
    pub library_path: String,
    pub analyzed: bool,
    pub project_path: Option<String>,
    pub error: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GhidraTokenInfo {
    pub text: String,
    pub line: u32,
    pub col_start: u32,
    pub col_end: u32,
    pub token_type: String, // "function", "variable", "type", "field", "data", "unknown"
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_offset: Option<String>, // For function calls
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_name: Option<String>, // For function calls
    #[serde(skip_serializing_if = "Option::is_none")]
    pub var_name: Option<String>, // For variables
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data_type: Option<String>, // For variables/types
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_parameter: Option<bool>, // For variables
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GhidraDecompileResult {
    pub success: bool,
    #[serde(default)]
    pub function_name: Option<String>,
    #[serde(default)]
    pub address: Option<String>,
    pub decompiled_code: Option<String>,
    pub line_mapping: Option<std::collections::HashMap<String, String>>, // line number (as string) -> offset (hex string)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tokens: Option<Vec<GhidraTokenInfo>>, // Token information for syntax highlighting
    pub error: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GhidraVariableInfo {
    pub name: String,
    pub data_type: String,
    pub storage: String,
    pub is_parameter: bool,
    pub size: i32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GhidraCalledFunction {
    pub name: String,
    pub offset: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GhidraFunctionInfoResult {
    pub success: bool,
    pub function_name: Option<String>,
    pub function_offset: Option<String>,
    pub variables: Vec<GhidraVariableInfo>,
    pub called_functions: Vec<GhidraCalledFunction>,
    pub error: Option<String>,
}

// Memory filter structures
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemoryFilterRequest {
    pub addresses: Vec<u64>,           // List of addresses to filter
    pub old_values: Vec<Vec<u8>>,      // Previous values at those addresses (hex bytes)
    pub pattern: String,               // Hex-encoded pattern for comparison (min for range)
    pub pattern_max: Option<String>,   // Hex-encoded max pattern for range filter
    pub data_type: String,             // "int8", "uint8", "int16", "uint16", "int32", "uint32", "int64", "uint64", "float", "double", "bytes", "string", "regex"
    pub filter_method: String,         // "exact", "range", "greater_or_equal", "less_than", "changed", "unchanged", "increased", "decreased"
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemoryFilterResult {
    pub address: u64,
    pub value: Vec<u8>,  // New value at the address
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemoryFilterResponse {
    pub success: bool,
    pub results: Vec<MemoryFilterResult>,
    pub total_processed: usize,
    pub error: Option<String>,
}

// Global state to store server connection info
struct ServerConfig {
    host: String,
    port: u16,
    auth_token: Option<String>,
}

static SERVER_CONFIG: Lazy<RwLock<ServerConfig>> = Lazy::new(|| {
    RwLock::new(ServerConfig {
        host: String::new(),
        port: 3030,
        auth_token: None,
    })
});

// Learn more about Tauri commands at https://tauri.app/develop/calling-rust/
#[tauri::command]
fn greet(name: &str) -> String {
    format!("Hello, {}! You've been greeted from Rust!", name)
}

#[tauri::command]
async fn set_server_connection(host: String, port: u16) -> Result<(), String> {
    let mut config = SERVER_CONFIG.write().map_err(|e| e.to_string())?;
    config.host = host;
    config.port = port;
    Ok(())
}

#[tauri::command]
fn set_auth_token(token: Option<String>) -> Result<(), String> {
    let mut config = SERVER_CONFIG.write().map_err(|e| e.to_string())?;
    config.auth_token = token;
    Ok(())
}

/// Helper function to read memory from server
async fn read_memory_from_server(host: &str, port: u16, address: u64, size: usize) -> Result<Vec<u8>, String> {
    let client = reqwest::Client::new();
    let url = format!("http://{}:{}/api/memory/read?address={}&size={}", host, port, address, size);
    
    let response = client.get(&url).send().await
        .map_err(|e| format!("Network error: {}", e))?;
    
    if !response.status().is_success() {
        return Err(format!("Server error: {}", response.status()));
    }
    
    let bytes = response.bytes().await
        .map_err(|e| format!("Failed to read response: {}", e))?;
    
    Ok(bytes.to_vec())
}

/// Compare two values based on data type and filter method
fn compare_values(
    new_val: &[u8],
    old_val: &[u8],
    pattern: &[u8],
    pattern_max: Option<&[u8]>,
    data_type: &str,
    filter_method: &str,
) -> bool {
    match filter_method {
        "exact" => new_val == pattern,
        "range" => {
            let max_bytes = match pattern_max {
                Some(b) => b,
                None => return false,
            };
            match data_type {
                "int8" => {
                    if new_val.is_empty() || pattern.is_empty() || max_bytes.is_empty() { return false; }
                    let val = new_val[0] as i8;
                    let min = pattern[0] as i8;
                    let max = max_bytes[0] as i8;
                    val >= min && val <= max
                }
                "uint8" => {
                    if new_val.is_empty() || pattern.is_empty() || max_bytes.is_empty() { return false; }
                    new_val[0] >= pattern[0] && new_val[0] <= max_bytes[0]
                }
                "int16" => {
                    if new_val.len() < 2 || pattern.len() < 2 || max_bytes.len() < 2 { return false; }
                    let val = i16::from_le_bytes([new_val[0], new_val[1]]);
                    let min = i16::from_le_bytes([pattern[0], pattern[1]]);
                    let max = i16::from_le_bytes([max_bytes[0], max_bytes[1]]);
                    val >= min && val <= max
                }
                "uint16" => {
                    if new_val.len() < 2 || pattern.len() < 2 || max_bytes.len() < 2 { return false; }
                    let val = u16::from_le_bytes([new_val[0], new_val[1]]);
                    let min = u16::from_le_bytes([pattern[0], pattern[1]]);
                    let max = u16::from_le_bytes([max_bytes[0], max_bytes[1]]);
                    val >= min && val <= max
                }
                "int32" => {
                    if new_val.len() < 4 || pattern.len() < 4 || max_bytes.len() < 4 { return false; }
                    let val = i32::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3]]);
                    let min = i32::from_le_bytes([pattern[0], pattern[1], pattern[2], pattern[3]]);
                    let max = i32::from_le_bytes([max_bytes[0], max_bytes[1], max_bytes[2], max_bytes[3]]);
                    val >= min && val <= max
                }
                "uint32" => {
                    if new_val.len() < 4 || pattern.len() < 4 || max_bytes.len() < 4 { return false; }
                    let val = u32::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3]]);
                    let min = u32::from_le_bytes([pattern[0], pattern[1], pattern[2], pattern[3]]);
                    let max = u32::from_le_bytes([max_bytes[0], max_bytes[1], max_bytes[2], max_bytes[3]]);
                    val >= min && val <= max
                }
                "int64" => {
                    if new_val.len() < 8 || pattern.len() < 8 || max_bytes.len() < 8 { return false; }
                    let val = i64::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3], new_val[4], new_val[5], new_val[6], new_val[7]]);
                    let min = i64::from_le_bytes([pattern[0], pattern[1], pattern[2], pattern[3], pattern[4], pattern[5], pattern[6], pattern[7]]);
                    let max = i64::from_le_bytes([max_bytes[0], max_bytes[1], max_bytes[2], max_bytes[3], max_bytes[4], max_bytes[5], max_bytes[6], max_bytes[7]]);
                    val >= min && val <= max
                }
                "uint64" => {
                    if new_val.len() < 8 || pattern.len() < 8 || max_bytes.len() < 8 { return false; }
                    let val = u64::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3], new_val[4], new_val[5], new_val[6], new_val[7]]);
                    let min = u64::from_le_bytes([pattern[0], pattern[1], pattern[2], pattern[3], pattern[4], pattern[5], pattern[6], pattern[7]]);
                    let max = u64::from_le_bytes([max_bytes[0], max_bytes[1], max_bytes[2], max_bytes[3], max_bytes[4], max_bytes[5], max_bytes[6], max_bytes[7]]);
                    val >= min && val <= max
                }
                "float" => {
                    if new_val.len() < 4 || pattern.len() < 4 || max_bytes.len() < 4 { return false; }
                    let val = f32::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3]]);
                    let min = f32::from_le_bytes([pattern[0], pattern[1], pattern[2], pattern[3]]);
                    let max = f32::from_le_bytes([max_bytes[0], max_bytes[1], max_bytes[2], max_bytes[3]]);
                    !val.is_nan() && val >= min && val <= max
                }
                "double" => {
                    if new_val.len() < 8 || pattern.len() < 8 || max_bytes.len() < 8 { return false; }
                    let val = f64::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3], new_val[4], new_val[5], new_val[6], new_val[7]]);
                    let min = f64::from_le_bytes([pattern[0], pattern[1], pattern[2], pattern[3], pattern[4], pattern[5], pattern[6], pattern[7]]);
                    let max = f64::from_le_bytes([max_bytes[0], max_bytes[1], max_bytes[2], max_bytes[3], max_bytes[4], max_bytes[5], max_bytes[6], max_bytes[7]]);
                    !val.is_nan() && val >= min && val <= max
                }
                _ => false,
            }
        }
        "greater_or_equal" | "less_than" => {
            let is_gte = filter_method == "greater_or_equal";
            match data_type {
                "int8" => {
                    if new_val.is_empty() || pattern.is_empty() { return false; }
                    let val = new_val[0] as i8;
                    let cmp = pattern[0] as i8;
                    if is_gte { val >= cmp } else { val < cmp }
                }
                "uint8" => {
                    if new_val.is_empty() || pattern.is_empty() { return false; }
                    if is_gte { new_val[0] >= pattern[0] } else { new_val[0] < pattern[0] }
                }
                "int16" => {
                    if new_val.len() < 2 || pattern.len() < 2 { return false; }
                    let val = i16::from_le_bytes([new_val[0], new_val[1]]);
                    let cmp = i16::from_le_bytes([pattern[0], pattern[1]]);
                    if is_gte { val >= cmp } else { val < cmp }
                }
                "uint16" => {
                    if new_val.len() < 2 || pattern.len() < 2 { return false; }
                    let val = u16::from_le_bytes([new_val[0], new_val[1]]);
                    let cmp = u16::from_le_bytes([pattern[0], pattern[1]]);
                    if is_gte { val >= cmp } else { val < cmp }
                }
                "int32" => {
                    if new_val.len() < 4 || pattern.len() < 4 { return false; }
                    let val = i32::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3]]);
                    let cmp = i32::from_le_bytes([pattern[0], pattern[1], pattern[2], pattern[3]]);
                    if is_gte { val >= cmp } else { val < cmp }
                }
                "uint32" => {
                    if new_val.len() < 4 || pattern.len() < 4 { return false; }
                    let val = u32::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3]]);
                    let cmp = u32::from_le_bytes([pattern[0], pattern[1], pattern[2], pattern[3]]);
                    if is_gte { val >= cmp } else { val < cmp }
                }
                "int64" => {
                    if new_val.len() < 8 || pattern.len() < 8 { return false; }
                    let val = i64::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3], new_val[4], new_val[5], new_val[6], new_val[7]]);
                    let cmp = i64::from_le_bytes([pattern[0], pattern[1], pattern[2], pattern[3], pattern[4], pattern[5], pattern[6], pattern[7]]);
                    if is_gte { val >= cmp } else { val < cmp }
                }
                "uint64" => {
                    if new_val.len() < 8 || pattern.len() < 8 { return false; }
                    let val = u64::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3], new_val[4], new_val[5], new_val[6], new_val[7]]);
                    let cmp = u64::from_le_bytes([pattern[0], pattern[1], pattern[2], pattern[3], pattern[4], pattern[5], pattern[6], pattern[7]]);
                    if is_gte { val >= cmp } else { val < cmp }
                }
                "float" => {
                    if new_val.len() < 4 || pattern.len() < 4 { return false; }
                    let val = f32::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3]]);
                    let cmp = f32::from_le_bytes([pattern[0], pattern[1], pattern[2], pattern[3]]);
                    !val.is_nan() && if is_gte { val >= cmp } else { val < cmp }
                }
                "double" => {
                    if new_val.len() < 8 || pattern.len() < 8 { return false; }
                    let val = f64::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3], new_val[4], new_val[5], new_val[6], new_val[7]]);
                    let cmp = f64::from_le_bytes([pattern[0], pattern[1], pattern[2], pattern[3], pattern[4], pattern[5], pattern[6], pattern[7]]);
                    !val.is_nan() && if is_gte { val >= cmp } else { val < cmp }
                }
                _ => false,
            }
        }
        "changed" => new_val != old_val,
        "unchanged" => new_val == old_val,
        "increased" => {
            match data_type {
                "int8" => {
                    if new_val.is_empty() || old_val.is_empty() { return false; }
                    (new_val[0] as i8) > (old_val[0] as i8)
                }
                "uint8" => {
                    if new_val.is_empty() || old_val.is_empty() { return false; }
                    new_val[0] > old_val[0]
                }
                "int16" => {
                    if new_val.len() < 2 || old_val.len() < 2 { return false; }
                    i16::from_le_bytes([new_val[0], new_val[1]]) > i16::from_le_bytes([old_val[0], old_val[1]])
                }
                "uint16" => {
                    if new_val.len() < 2 || old_val.len() < 2 { return false; }
                    u16::from_le_bytes([new_val[0], new_val[1]]) > u16::from_le_bytes([old_val[0], old_val[1]])
                }
                "int32" => {
                    if new_val.len() < 4 || old_val.len() < 4 { return false; }
                    i32::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3]]) > i32::from_le_bytes([old_val[0], old_val[1], old_val[2], old_val[3]])
                }
                "uint32" => {
                    if new_val.len() < 4 || old_val.len() < 4 { return false; }
                    u32::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3]]) > u32::from_le_bytes([old_val[0], old_val[1], old_val[2], old_val[3]])
                }
                "int64" => {
                    if new_val.len() < 8 || old_val.len() < 8 { return false; }
                    i64::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3], new_val[4], new_val[5], new_val[6], new_val[7]]) > 
                    i64::from_le_bytes([old_val[0], old_val[1], old_val[2], old_val[3], old_val[4], old_val[5], old_val[6], old_val[7]])
                }
                "uint64" => {
                    if new_val.len() < 8 || old_val.len() < 8 { return false; }
                    u64::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3], new_val[4], new_val[5], new_val[6], new_val[7]]) > 
                    u64::from_le_bytes([old_val[0], old_val[1], old_val[2], old_val[3], old_val[4], old_val[5], old_val[6], old_val[7]])
                }
                "float" => {
                    if new_val.len() < 4 || old_val.len() < 4 { return false; }
                    let n = f32::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3]]);
                    let o = f32::from_le_bytes([old_val[0], old_val[1], old_val[2], old_val[3]]);
                    !n.is_nan() && !o.is_nan() && n > o
                }
                "double" => {
                    if new_val.len() < 8 || old_val.len() < 8 { return false; }
                    let n = f64::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3], new_val[4], new_val[5], new_val[6], new_val[7]]);
                    let o = f64::from_le_bytes([old_val[0], old_val[1], old_val[2], old_val[3], old_val[4], old_val[5], old_val[6], old_val[7]]);
                    !n.is_nan() && !o.is_nan() && n > o
                }
                _ => false,
            }
        }
        "decreased" => {
            match data_type {
                "int8" => {
                    if new_val.is_empty() || old_val.is_empty() { return false; }
                    (new_val[0] as i8) < (old_val[0] as i8)
                }
                "uint8" => {
                    if new_val.is_empty() || old_val.is_empty() { return false; }
                    new_val[0] < old_val[0]
                }
                "int16" => {
                    if new_val.len() < 2 || old_val.len() < 2 { return false; }
                    i16::from_le_bytes([new_val[0], new_val[1]]) < i16::from_le_bytes([old_val[0], old_val[1]])
                }
                "uint16" => {
                    if new_val.len() < 2 || old_val.len() < 2 { return false; }
                    u16::from_le_bytes([new_val[0], new_val[1]]) < u16::from_le_bytes([old_val[0], old_val[1]])
                }
                "int32" => {
                    if new_val.len() < 4 || old_val.len() < 4 { return false; }
                    i32::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3]]) < i32::from_le_bytes([old_val[0], old_val[1], old_val[2], old_val[3]])
                }
                "uint32" => {
                    if new_val.len() < 4 || old_val.len() < 4 { return false; }
                    u32::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3]]) < u32::from_le_bytes([old_val[0], old_val[1], old_val[2], old_val[3]])
                }
                "int64" => {
                    if new_val.len() < 8 || old_val.len() < 8 { return false; }
                    i64::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3], new_val[4], new_val[5], new_val[6], new_val[7]]) < 
                    i64::from_le_bytes([old_val[0], old_val[1], old_val[2], old_val[3], old_val[4], old_val[5], old_val[6], old_val[7]])
                }
                "uint64" => {
                    if new_val.len() < 8 || old_val.len() < 8 { return false; }
                    u64::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3], new_val[4], new_val[5], new_val[6], new_val[7]]) < 
                    u64::from_le_bytes([old_val[0], old_val[1], old_val[2], old_val[3], old_val[4], old_val[5], old_val[6], old_val[7]])
                }
                "float" => {
                    if new_val.len() < 4 || old_val.len() < 4 { return false; }
                    let n = f32::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3]]);
                    let o = f32::from_le_bytes([old_val[0], old_val[1], old_val[2], old_val[3]]);
                    !n.is_nan() && !o.is_nan() && n < o
                }
                "double" => {
                    if new_val.len() < 8 || old_val.len() < 8 { return false; }
                    let n = f64::from_le_bytes([new_val[0], new_val[1], new_val[2], new_val[3], new_val[4], new_val[5], new_val[6], new_val[7]]);
                    let o = f64::from_le_bytes([old_val[0], old_val[1], old_val[2], old_val[3], old_val[4], old_val[5], old_val[6], old_val[7]]);
                    !n.is_nan() && !o.is_nan() && n < o
                }
                _ => false,
            }
        }
        _ => false,
    }
}

/// Get data size for a given data type
fn get_data_size(data_type: &str) -> usize {
    match data_type {
        "int8" | "uint8" => 1,
        "int16" | "uint16" => 2,
        "int32" | "uint32" | "float" => 4,
        "int64" | "uint64" | "double" => 8,
        _ => 1,
    }
}

/// Native memory filter command - filters addresses locally using network memory reads
/// Optimizes by reading contiguous memory regions in bulk when there are many addresses
#[tauri::command]
async fn filter_memory_native(request: MemoryFilterRequest) -> Result<MemoryFilterResponse, String> {
    let (host, port) = {
        let config = SERVER_CONFIG.read().map_err(|e| e.to_string())?;
        (config.host.clone(), config.port)
    };
    
    if host.is_empty() {
        return Ok(MemoryFilterResponse {
            success: false,
            results: vec![],
            total_processed: 0,
            error: Some("No server connection configured".to_string()),
        });
    }

    let data_size = get_data_size(&request.data_type);
    let pattern_bytes = hex::decode(&request.pattern).unwrap_or_default();
    let pattern_max_bytes = request.pattern_max.as_ref()
        .and_then(|p| hex::decode(p).ok());

    let addresses = &request.addresses;
    let old_values = &request.old_values;
    
    if addresses.is_empty() {
        return Ok(MemoryFilterResponse {
            success: true,
            results: vec![],
            total_processed: 0,
            error: None,
        });
    }

    let mut results: Vec<MemoryFilterResult> = Vec::new();
    
    // Optimization threshold: if more than 100 addresses and they span less than 1MB, read entire range
    const BULK_READ_THRESHOLD: usize = 100;
    const MAX_BULK_READ_SIZE: u64 = 1024 * 1024; // 1MB max for bulk read
    
    let min_addr = *addresses.iter().min().unwrap();
    let max_addr = *addresses.iter().max().unwrap();
    let addr_range = max_addr - min_addr + data_size as u64;
    
    if addresses.len() >= BULK_READ_THRESHOLD && addr_range <= MAX_BULK_READ_SIZE {
        // Bulk read: read the entire min-max range at once
        match read_memory_from_server(&host, port, min_addr, addr_range as usize).await {
            Ok(bulk_data) => {
                for (i, &addr) in addresses.iter().enumerate() {
                    let offset = (addr - min_addr) as usize;
                    if offset + data_size <= bulk_data.len() {
                        let new_val = &bulk_data[offset..offset + data_size];
                        let old_val = if i < old_values.len() { &old_values[i] } else { &[] as &[u8] };
                        
                        if compare_values(
                            new_val,
                            old_val,
                            &pattern_bytes,
                            pattern_max_bytes.as_deref(),
                            &request.data_type,
                            &request.filter_method,
                        ) {
                            results.push(MemoryFilterResult {
                                address: addr,
                                value: new_val.to_vec(),
                            });
                        }
                    }
                }
            }
            Err(e) => {
                return Ok(MemoryFilterResponse {
                    success: false,
                    results: vec![],
                    total_processed: 0,
                    error: Some(format!("Bulk memory read failed: {}", e)),
                });
            }
        }
    } else {
        // For fewer addresses or very scattered addresses, group into contiguous chunks
        // and read each chunk separately
        const CHUNK_GAP_THRESHOLD: u64 = 4096; // If gap is more than 4KB, start a new chunk
        const MAX_CHUNK_SIZE: usize = 65536; // Max 64KB per chunk
        
        // Sort addresses with their original indices
        let mut addr_indices: Vec<(u64, usize)> = addresses.iter().enumerate()
            .map(|(i, &a)| (a, i))
            .collect();
        addr_indices.sort_by_key(|&(a, _)| a);
        
        // Group into chunks
        let mut chunks: Vec<(u64, usize, Vec<(u64, usize)>)> = Vec::new(); // (start_addr, size, [(addr, original_idx)])
        
        for (addr, orig_idx) in addr_indices {
            if chunks.is_empty() {
                chunks.push((addr, data_size, vec![(addr, orig_idx)]));
            } else {
                let last = chunks.last_mut().unwrap();
                let gap = addr.saturating_sub(last.0 + last.1 as u64);
                let new_size = (addr - last.0) as usize + data_size;
                
                if gap <= CHUNK_GAP_THRESHOLD && new_size <= MAX_CHUNK_SIZE {
                    // Extend current chunk
                    last.1 = new_size;
                    last.2.push((addr, orig_idx));
                } else {
                    // Start new chunk
                    chunks.push((addr, data_size, vec![(addr, orig_idx)]));
                }
            }
        }
        
        // Read and process each chunk
        for (chunk_start, chunk_size, chunk_addrs) in chunks {
            match read_memory_from_server(&host, port, chunk_start, chunk_size).await {
                Ok(chunk_data) => {
                    for (addr, orig_idx) in chunk_addrs {
                        let offset = (addr - chunk_start) as usize;
                        if offset + data_size <= chunk_data.len() {
                            let new_val = &chunk_data[offset..offset + data_size];
                            let old_val = if orig_idx < old_values.len() { &old_values[orig_idx] } else { &[] as &[u8] };
                            
                            if compare_values(
                                new_val,
                                old_val,
                                &pattern_bytes,
                                pattern_max_bytes.as_deref(),
                                &request.data_type,
                                &request.filter_method,
                            ) {
                                results.push(MemoryFilterResult {
                                    address: addr,
                                    value: new_val.to_vec(),
                                });
                            }
                        }
                    }
                }
                Err(_) => {
                    // Skip this chunk on error, continue with others
                    continue;
                }
            }
        }
    }

    Ok(MemoryFilterResponse {
        success: true,
        results,
        total_processed: addresses.len(),
        error: None,
    })
}

/// Native lookup command - reads current values for a list of addresses
#[tauri::command]
async fn lookup_memory_native(addresses: Vec<u64>, data_type: String) -> Result<MemoryFilterResponse, String> {
    let (host, port) = {
        let config = SERVER_CONFIG.read().map_err(|e| e.to_string())?;
        (config.host.clone(), config.port)
    };
    
    if host.is_empty() {
        return Ok(MemoryFilterResponse {
            success: false,
            results: vec![],
            total_processed: 0,
            error: Some("No server connection configured".to_string()),
        });
    }

    if addresses.is_empty() {
        return Ok(MemoryFilterResponse {
            success: true,
            results: vec![],
            total_processed: 0,
            error: None,
        });
    }

    let data_size = get_data_size(&data_type);
    let mut results: Vec<MemoryFilterResult> = Vec::new();
    
    // Use same chunking strategy as filter
    const BULK_READ_THRESHOLD: usize = 100;
    const MAX_BULK_READ_SIZE: u64 = 1024 * 1024;
    
    let min_addr = *addresses.iter().min().unwrap();
    let max_addr = *addresses.iter().max().unwrap();
    let addr_range = max_addr - min_addr + data_size as u64;
    
    if addresses.len() >= BULK_READ_THRESHOLD && addr_range <= MAX_BULK_READ_SIZE {
        match read_memory_from_server(&host, port, min_addr, addr_range as usize).await {
            Ok(bulk_data) => {
                for &addr in &addresses {
                    let offset = (addr - min_addr) as usize;
                    if offset + data_size <= bulk_data.len() {
                        results.push(MemoryFilterResult {
                            address: addr,
                            value: bulk_data[offset..offset + data_size].to_vec(),
                        });
                    }
                }
            }
            Err(e) => {
                return Ok(MemoryFilterResponse {
                    success: false,
                    results: vec![],
                    total_processed: 0,
                    error: Some(format!("Bulk memory read failed: {}", e)),
                });
            }
        }
    } else {
        const CHUNK_GAP_THRESHOLD: u64 = 4096;
        const MAX_CHUNK_SIZE: usize = 65536;
        
        let mut addr_indices: Vec<(u64, usize)> = addresses.iter().enumerate()
            .map(|(i, &a)| (a, i))
            .collect();
        addr_indices.sort_by_key(|&(a, _)| a);
        
        let mut chunks: Vec<(u64, usize, Vec<u64>)> = Vec::new();
        
        for (addr, _) in addr_indices {
            if chunks.is_empty() {
                chunks.push((addr, data_size, vec![addr]));
            } else {
                let last = chunks.last_mut().unwrap();
                let gap = addr.saturating_sub(last.0 + last.1 as u64);
                let new_size = (addr - last.0) as usize + data_size;
                
                if gap <= CHUNK_GAP_THRESHOLD && new_size <= MAX_CHUNK_SIZE {
                    last.1 = new_size;
                    last.2.push(addr);
                } else {
                    chunks.push((addr, data_size, vec![addr]));
                }
            }
        }
        
        for (chunk_start, chunk_size, chunk_addrs) in chunks {
            match read_memory_from_server(&host, port, chunk_start, chunk_size).await {
                Ok(chunk_data) => {
                    for addr in chunk_addrs {
                        let offset = (addr - chunk_start) as usize;
                        if offset + data_size <= chunk_data.len() {
                            results.push(MemoryFilterResult {
                                address: addr,
                                value: chunk_data[offset..offset + data_size].to_vec(),
                            });
                        }
                    }
                }
                Err(_) => continue,
            }
        }
    }

    Ok(MemoryFilterResponse {
        success: true,
        results,
        total_processed: addresses.len(),
        error: None,
    })
}

/// Unknown scan request structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UnknownScanRequest {
    pub address_ranges: Vec<(u64, u64)>,  // [(start, end), ...]
    pub data_type: String,                 // "int8", "uint8", "int16", "uint16", "int32", "uint32", "int64", "uint64", "float", "double"
    pub alignment: usize,                  // Alignment for scanning
    pub scan_id: String,                   // Unique scan ID for temp file storage
}

/// Unknown scan progress structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UnknownScanProgress {
    pub scan_id: String,
    pub progress_percentage: f64,
    pub processed_bytes: u64,
    pub total_bytes: u64,
    pub found_count: u64,
    pub is_scanning: bool,
    pub current_region: Option<String>,
}

/// Unknown scan response - returns scan metadata (results stored in temp files)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UnknownScanResponse {
    pub success: bool,
    pub scan_id: String,
    pub total_addresses: usize,
    pub temp_dir: String,
    pub error: Option<String>,
}

/// Unknown scan result for lookup
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UnknownScanLookupResponse {
    pub success: bool,
    pub results: Vec<MemoryFilterResult>,
    pub total_count: usize,
    pub error: Option<String>,
}

// Global storage for unknown scan progress
static UNKNOWN_SCAN_PROGRESS: Lazy<RwLock<HashMap<String, UnknownScanProgress>>> = Lazy::new(|| {
    RwLock::new(HashMap::new())
});

/// Get temp directory for unknown scan data
fn get_unknown_scan_temp_dir(scan_id: &str) -> PathBuf {
    let temp_dir = std::env::temp_dir();
    temp_dir.join("dynadbg_unknown_scan").join(scan_id)
}

/// Native unknown scan command - scans memory ranges and saves to temp files
/// Progress can be queried via get_unknown_scan_progress
#[tauri::command]
async fn unknown_scan_native(request: UnknownScanRequest) -> Result<UnknownScanResponse, String> {
    let (host, port) = {
        let config = SERVER_CONFIG.read().map_err(|e| e.to_string())?;
        (config.host.clone(), config.port)
    };
    
    if host.is_empty() {
        return Ok(UnknownScanResponse {
            success: false,
            scan_id: request.scan_id.clone(),
            total_addresses: 0,
            temp_dir: String::new(),
            error: Some("No server connection configured".to_string()),
        });
    }

    let data_size = get_data_size(&request.data_type);
    let alignment = if request.alignment > 0 { request.alignment } else { data_size };
    let scan_id = request.scan_id.clone();
    
    // Calculate total bytes to scan for progress
    let total_bytes: u64 = request.address_ranges.iter()
        .map(|(start, end)| end - start)
        .sum();
    
    // Create temp directory
    let temp_dir = get_unknown_scan_temp_dir(&scan_id);
    if let Err(e) = std::fs::create_dir_all(&temp_dir) {
        return Ok(UnknownScanResponse {
            success: false,
            scan_id,
            total_addresses: 0,
            temp_dir: String::new(),
            error: Some(format!("Failed to create temp directory: {}", e)),
        });
    }
    
    // Initialize progress
    {
        let mut progress_map = UNKNOWN_SCAN_PROGRESS.write().unwrap();
        progress_map.insert(scan_id.clone(), UnknownScanProgress {
            scan_id: scan_id.clone(),
            progress_percentage: 0.0,
            processed_bytes: 0,
            total_bytes,
            found_count: 0,
            is_scanning: true,
            current_region: Some("Starting scan...".to_string()),
        });
    }
    
    // Maximum chunk size for reading (4MB per read for efficiency)
    const MAX_READ_CHUNK: usize = 4 * 1024 * 1024;
    // Maximum sub-region size (64MB) - split large regions to avoid memory issues
    const MAX_SUB_REGION: u64 = 64 * 1024 * 1024;
    // Number of parallel reads
    const PARALLEL_READS: usize = 8;
    
    let total_found = std::sync::Arc::new(std::sync::atomic::AtomicU64::new(0));
    let processed_bytes = std::sync::Arc::new(std::sync::atomic::AtomicU64::new(0));
    let success_reads = std::sync::Arc::new(std::sync::atomic::AtomicU64::new(0));
    let failed_reads = std::sync::Arc::new(std::sync::atomic::AtomicU64::new(0));
    
    // Split large regions into smaller sub-regions (max 64MB each)
    let mut sub_regions: Vec<(u64, u64)> = Vec::new();
    for (range_start, range_end) in &request.address_ranges {
        let mut current = *range_start;
        while current < *range_end {
            let sub_end = (current + MAX_SUB_REGION).min(*range_end);
            sub_regions.push((current, sub_end));
            current = sub_end;
        }
    }
    
    eprintln!("[Unknown Scan] Starting scan: {} original regions -> {} sub-regions (max {}MB each), total_bytes: {}", 
        request.address_ranges.len(), sub_regions.len(), MAX_SUB_REGION / 1024 / 1024, total_bytes);
    
    let total_sub_regions = sub_regions.len();
    
    // Process sub-regions in parallel (up to 4 at a time)
    let sub_region_chunks: Vec<_> = sub_regions.iter().enumerate().collect::<Vec<_>>()
        .chunks(4).map(|c| c.to_vec()).collect();
    
    for sub_region_batch in sub_region_chunks {
        let mut region_tasks = Vec::new();
        
        for (_sub_region_index, (range_start, range_end)) in sub_region_batch {
            let host = host.clone();
            let scan_id = scan_id.clone();
            let temp_dir = temp_dir.clone();
            let total_found = total_found.clone();
            let processed_bytes = processed_bytes.clone();
            let success_reads = success_reads.clone();
            let failed_reads = failed_reads.clone();
            let range_start = *range_start;
            let range_end = *range_end;
            let _total_sub_regions = total_sub_regions;
            
            let task = tokio::spawn(async move {
                let mut current_addr = range_start;
                
                // Align start address
                if current_addr % alignment as u64 != 0 {
                    current_addr = (current_addr / alignment as u64 + 1) * alignment as u64;
                }
                
                // Create file for this sub-region
                let region_file_path = temp_dir.join(format!("region_{:016x}_{:016x}.bin", range_start, range_end));
                let mut region_file = match std::fs::File::create(&region_file_path) {
                    Ok(f) => std::io::BufWriter::with_capacity(1024 * 1024, f), // 1MB buffer
                    Err(e) => {
                        eprintln!("[Unknown Scan] Failed to create region file: {}", e);
                        return (0u64, 0u64);
                    }
                };
                
                // Write header: data_size (4 bytes) + alignment (4 bytes) + start_addr (8 bytes)
                use std::io::Write;
                let _ = region_file.write_all(&(data_size as u32).to_le_bytes());
                let _ = region_file.write_all(&(alignment as u32).to_le_bytes());
                let _ = region_file.write_all(&range_start.to_le_bytes());
                
                let mut all_addresses: Vec<u64> = Vec::new();
                let mut all_data: Vec<u8> = Vec::new();
                
                // Split sub-region into chunks for parallel reading
                let region_size = (range_end - current_addr) as usize;
                let mut chunks_to_read: Vec<(u64, usize)> = Vec::new();
                
                let mut chunk_start = current_addr;
                while chunk_start < range_end {
                    let remaining = (range_end - chunk_start) as usize;
                    let chunk_size = remaining.min(MAX_READ_CHUNK);
                    chunks_to_read.push((chunk_start, chunk_size));
                    chunk_start += chunk_size as u64;
                }
                
                // Process chunks in parallel batches
                for chunk_batch in chunks_to_read.chunks(PARALLEL_READS) {
                    let mut read_tasks = Vec::new();
                    
                    for (addr, size) in chunk_batch.iter().cloned() {
                        let host = host.clone();
                        let read_task = tokio::spawn(async move {
                            // Add timeout to prevent hanging on unresponsive regions
                            match tokio::time::timeout(
                                std::time::Duration::from_secs(2),
                                read_memory_from_server(&host, port, addr, size)
                            ).await {
                                Ok(Ok(data)) => Some((addr, data)),
                                Ok(Err(_)) => None,
                                Err(_) => None, // Timeout
                            }
                        });
                        read_tasks.push((addr, size, read_task));
                    }
                    
                    // Collect results and maintain order
                    let mut results: Vec<(u64, Option<Vec<u8>>, usize)> = Vec::new();
                    for (addr, size, task) in read_tasks {
                        match task.await {
                            Ok(result) => results.push((addr, result.map(|(_, d)| d), size)),
                            Err(_) => results.push((addr, None, size)),
                        }
                    }
                    
                    // Sort by address to maintain order
                    results.sort_by_key(|(addr, _, _)| *addr);
                    
                    for (addr, data_opt, chunk_size) in results {
                        if let Some(chunk_data) = data_opt {
                            success_reads.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
                            
                            // Extract values at aligned positions
                            let mut offset: usize = 0;
                            while offset + data_size <= chunk_data.len() {
                                let value_addr = addr + offset as u64;
                                all_addresses.push(value_addr);
                                all_data.extend_from_slice(&chunk_data[offset..offset + data_size]);
                                offset += alignment;
                            }
                        } else {
                            failed_reads.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
                        }
                        
                        // Update progress after each chunk
                        processed_bytes.fetch_add(chunk_size as u64, std::sync::atomic::Ordering::Relaxed);
                        let current_processed = processed_bytes.load(std::sync::atomic::Ordering::Relaxed);
                        let progress = if total_bytes > 0 {
                            (current_processed as f64 / total_bytes as f64) * 100.0
                        } else {
                            0.0
                        };
                        
                        if let Ok(mut progress_map) = UNKNOWN_SCAN_PROGRESS.write() {
                            if let Some(p) = progress_map.get_mut(&scan_id) {
                                p.progress_percentage = progress;
                                p.processed_bytes = current_processed;
                                p.found_count = total_found.load(std::sync::atomic::Ordering::Relaxed) + all_addresses.len() as u64;
                            }
                        }
                    }
                }
                
                let region_found = all_addresses.len() as u64;
                
                // Compress and write region data using lz4
                if !all_data.is_empty() {
                    // Write number of addresses
                    let _ = region_file.write_all(&(all_addresses.len() as u64).to_le_bytes());
                    
                    // Write addresses (compressed)
                    let addr_bytes: Vec<u8> = all_addresses.iter()
                        .flat_map(|a| a.to_le_bytes())
                        .collect();
                    let compressed_addrs = lz4_flex::compress_prepend_size(&addr_bytes);
                    let _ = region_file.write_all(&(compressed_addrs.len() as u64).to_le_bytes());
                    let _ = region_file.write_all(&compressed_addrs);
                    
                    // Write values (compressed)
                    let compressed_data = lz4_flex::compress_prepend_size(&all_data);
                    let _ = region_file.write_all(&(compressed_data.len() as u64).to_le_bytes());
                    let _ = region_file.write_all(&compressed_data);
                }
                
                let _ = region_file.flush();
                
                (region_found, region_size as u64)
            });
            
            region_tasks.push(task);
        }
        
        // Wait for all region tasks in this batch
        for task in region_tasks {
            if let Ok((found, _)) = task.await {
                total_found.fetch_add(found, std::sync::atomic::Ordering::Relaxed);
            }
        }
    }
    
    let final_found = total_found.load(std::sync::atomic::Ordering::Relaxed);
    let final_success = success_reads.load(std::sync::atomic::Ordering::Relaxed);
    let final_failed = failed_reads.load(std::sync::atomic::Ordering::Relaxed);
    
    eprintln!("[Unknown Scan] Completed: total_found={}, success_reads={}, failed_reads={}, temp_dir={}", 
        final_found, final_success, final_failed, temp_dir.display());
    
    // Mark scan as complete
    {
        let mut progress_map = UNKNOWN_SCAN_PROGRESS.write().unwrap();
        if let Some(p) = progress_map.get_mut(&scan_id) {
            p.progress_percentage = 100.0;
            p.processed_bytes = total_bytes;
            p.found_count = final_found;
            p.is_scanning = false;
            p.current_region = None;
        }
    }

    Ok(UnknownScanResponse {
        success: true,
        scan_id: scan_id.clone(),
        total_addresses: final_found as usize,
        temp_dir: temp_dir.to_string_lossy().to_string(),
        error: None,
    })
}

/// Initialize unknown scan progress (call before starting scan to prevent race condition)
#[tauri::command]
fn init_unknown_scan_progress(scan_id: String, total_bytes: u64) -> Result<(), String> {
    let mut progress_map = UNKNOWN_SCAN_PROGRESS.write().unwrap();
    progress_map.insert(scan_id.clone(), UnknownScanProgress {
        scan_id,
        progress_percentage: 0.0,
        processed_bytes: 0,
        total_bytes,
        found_count: 0,
        is_scanning: true,
        current_region: Some("Initializing...".to_string()),
    });
    Ok(())
}

/// Get unknown scan progress
#[tauri::command]
fn get_unknown_scan_progress(scan_id: String) -> Result<UnknownScanProgress, String> {
    let progress_map = UNKNOWN_SCAN_PROGRESS.read().unwrap();
    if let Some(progress) = progress_map.get(&scan_id) {
        Ok(progress.clone())
    } else {
        // Return is_scanning: true when not found - scan might be starting
        Ok(UnknownScanProgress {
            scan_id,
            progress_percentage: 0.0,
            processed_bytes: 0,
            total_bytes: 0,
            found_count: 0,
            is_scanning: true,
            current_region: Some("Waiting for scan to start...".to_string()),
        })
    }
}

/// Load unknown scan results from temp files (for display/lookup)
#[tauri::command]
#[allow(unused_assignments)]
async fn load_unknown_scan_results(scan_id: String, offset: usize, limit: usize) -> Result<UnknownScanLookupResponse, String> {
    let temp_dir = get_unknown_scan_temp_dir(&scan_id);
    
    if !temp_dir.exists() {
        return Ok(UnknownScanLookupResponse {
            success: false,
            results: vec![],
            total_count: 0,
            error: Some("Scan data not found".to_string()),
        });
    }
    
    let mut all_results: Vec<MemoryFilterResult> = Vec::new();
    let mut total_count: usize = 0;
    
    // Read all region files
    let entries = match std::fs::read_dir(&temp_dir) {
        Ok(e) => e,
        Err(e) => return Ok(UnknownScanLookupResponse {
            success: false,
            results: vec![],
            total_count: 0,
            error: Some(format!("Failed to read temp directory: {}", e)),
        }),
    };
    
    let mut files: Vec<_> = entries.filter_map(|e| e.ok()).collect();
    files.sort_by_key(|e| e.path());
    
    for entry in files {
        let path = entry.path();
        if !path.extension().map_or(false, |e| e == "bin") {
            continue;
        }
        
        let file_data = match std::fs::read(&path) {
            Ok(d) => d,
            Err(_) => continue,
        };
        
        if file_data.len() < 28 {
            continue;
        }
        
        let mut pos = 0;
        
        // Read header
        let _data_size = u32::from_le_bytes([file_data[pos], file_data[pos+1], file_data[pos+2], file_data[pos+3]]) as usize;
        pos += 4;
        let _alignment = u32::from_le_bytes([file_data[pos], file_data[pos+1], file_data[pos+2], file_data[pos+3]]) as usize;
        pos += 4;
        let _start_addr = u64::from_le_bytes([
            file_data[pos], file_data[pos+1], file_data[pos+2], file_data[pos+3],
            file_data[pos+4], file_data[pos+5], file_data[pos+6], file_data[pos+7]
        ]);
        pos += 8;
        
        // Read number of addresses
        let addr_count = u64::from_le_bytes([
            file_data[pos], file_data[pos+1], file_data[pos+2], file_data[pos+3],
            file_data[pos+4], file_data[pos+5], file_data[pos+6], file_data[pos+7]
        ]) as usize;
        pos += 8;
        
        total_count += addr_count;
        
        // Skip if we haven't reached offset yet
        if total_count <= offset {
            // Skip compressed data
            let compressed_addr_len = u64::from_le_bytes([
                file_data[pos], file_data[pos+1], file_data[pos+2], file_data[pos+3],
                file_data[pos+4], file_data[pos+5], file_data[pos+6], file_data[pos+7]
            ]) as usize;
            pos += 8 + compressed_addr_len;
            
            let compressed_data_len = u64::from_le_bytes([
                file_data[pos], file_data[pos+1], file_data[pos+2], file_data[pos+3],
                file_data[pos+4], file_data[pos+5], file_data[pos+6], file_data[pos+7]
            ]) as usize;
            pos += 8 + compressed_data_len;
            continue;
        }
        
        // Read compressed addresses
        let compressed_addr_len = u64::from_le_bytes([
            file_data[pos], file_data[pos+1], file_data[pos+2], file_data[pos+3],
            file_data[pos+4], file_data[pos+5], file_data[pos+6], file_data[pos+7]
        ]) as usize;
        pos += 8;
        
        let compressed_addrs = &file_data[pos..pos + compressed_addr_len];
        pos += compressed_addr_len;
        
        let addr_bytes = match lz4_flex::decompress_size_prepended(compressed_addrs) {
            Ok(d) => d,
            Err(_) => continue,
        };
        
        // Read compressed values
        let compressed_data_len = u64::from_le_bytes([
            file_data[pos], file_data[pos+1], file_data[pos+2], file_data[pos+3],
            file_data[pos+4], file_data[pos+5], file_data[pos+6], file_data[pos+7]
        ]) as usize;
        pos += 8;
        
        let compressed_values = &file_data[pos..pos + compressed_data_len];
        
        let value_bytes = match lz4_flex::decompress_size_prepended(compressed_values) {
            Ok(d) => d,
            Err(_) => continue,
        };
        
        // Parse addresses and values
        let data_size = _data_size;
        let start_idx = if total_count - addr_count <= offset { offset - (total_count - addr_count) } else { 0 };
        let end_idx = (start_idx + limit - all_results.len()).min(addr_count);
        
        for i in start_idx..end_idx {
            if all_results.len() >= limit {
                break;
            }
            
            let addr_offset = i * 8;
            if addr_offset + 8 <= addr_bytes.len() {
                let addr = u64::from_le_bytes([
                    addr_bytes[addr_offset], addr_bytes[addr_offset+1],
                    addr_bytes[addr_offset+2], addr_bytes[addr_offset+3],
                    addr_bytes[addr_offset+4], addr_bytes[addr_offset+5],
                    addr_bytes[addr_offset+6], addr_bytes[addr_offset+7],
                ]);
                
                let val_offset = i * data_size;
                if val_offset + data_size <= value_bytes.len() {
                    all_results.push(MemoryFilterResult {
                        address: addr,
                        value: value_bytes[val_offset..val_offset + data_size].to_vec(),
                    });
                }
            }
        }
        
        if all_results.len() >= limit {
            break;
        }
    }
    
    Ok(UnknownScanLookupResponse {
        success: true,
        results: all_results,
        total_count,
        error: None,
    })
}

/// Clear unknown scan temp files
#[tauri::command]
fn clear_unknown_scan(scan_id: String) -> Result<bool, String> {
    let temp_dir = get_unknown_scan_temp_dir(&scan_id);
    if temp_dir.exists() {
        let _ = std::fs::remove_dir_all(&temp_dir);
    }
    
    // Remove progress entry
    if let Ok(mut progress_map) = UNKNOWN_SCAN_PROGRESS.write() {
        progress_map.remove(&scan_id);
    }
    
    Ok(true)
}

/// Get the unknown scan data file path
fn get_unknown_scan_data_file(scan_id: &str) -> PathBuf {
    std::env::temp_dir()
        .join("dynadbg_unknown_scan")
        .join(format!("{}.bin", scan_id))
}

/// Initialize unknown scan streaming file (creates fresh file)
#[tauri::command]
fn init_unknown_scan_file(scan_id: String, alignment: u32, data_size: u32) -> Result<String, String> {
    let file_path = get_unknown_scan_data_file(&scan_id);
    
    // Ensure parent directory exists
    if let Some(parent) = file_path.parent() {
        std::fs::create_dir_all(parent).map_err(|e| format!("Failed to create directory: {}", e))?;
    }
    
    // Create file with header: alignment (4 bytes) + data_size (4 bytes) + chunk_count (8 bytes)
    let header = [
        alignment.to_le_bytes().as_slice(),
        data_size.to_le_bytes().as_slice(),
        0u64.to_le_bytes().as_slice(),  // chunk_count placeholder
    ].concat();
    
    std::fs::write(&file_path, &header).map_err(|e| format!("Failed to create file: {}", e))?;
    
    Ok(file_path.to_string_lossy().to_string())
}

/// Append a compressed chunk to the unknown scan file
/// Each chunk format: offset (8 bytes) + compressed_len (8 bytes) + compressed_data
#[tauri::command]
fn append_unknown_scan_chunk(
    scan_id: String,
    offset: u64,
    compressed_data: Vec<u8>
) -> Result<bool, String> {
    use std::io::Write;
    
    let file_path = get_unknown_scan_data_file(&scan_id);
    
    let mut file = std::fs::OpenOptions::new()
        .append(true)
        .open(&file_path)
        .map_err(|e| format!("Failed to open file: {}", e))?;
    
    // Write: offset (8 bytes) + compressed_len (8 bytes) + compressed_data
    file.write_all(&offset.to_le_bytes()).map_err(|e| format!("Write offset failed: {}", e))?;
    file.write_all(&(compressed_data.len() as u64).to_le_bytes()).map_err(|e| format!("Write len failed: {}", e))?;
    file.write_all(&compressed_data).map_err(|e| format!("Write data failed: {}", e))?;
    
    Ok(true)
}

/// Update the chunk count in file header
#[tauri::command]
fn finalize_unknown_scan_file(scan_id: String, chunk_count: u64) -> Result<bool, String> {
    use std::io::{Seek, SeekFrom, Write};
    
    let file_path = get_unknown_scan_data_file(&scan_id);
    
    let mut file = std::fs::OpenOptions::new()
        .write(true)
        .open(&file_path)
        .map_err(|e| format!("Failed to open file: {}", e))?;
    
    // Write chunk_count at offset 8 (after alignment + data_size)
    file.seek(SeekFrom::Start(8)).map_err(|e| format!("Seek failed: {}", e))?;
    file.write_all(&chunk_count.to_le_bytes()).map_err(|e| format!("Write chunk count failed: {}", e))?;
    
    Ok(true)
}

/// Get unknown scan file info
#[tauri::command]
fn get_unknown_scan_file_info(scan_id: String) -> Result<serde_json::Value, String> {
    let file_path = get_unknown_scan_data_file(&scan_id);
    
    if !file_path.exists() {
        return Err("File not found".to_string());
    }
    
    let metadata = std::fs::metadata(&file_path)
        .map_err(|e| format!("Failed to get metadata: {}", e))?;
    
    // Read header
    let file_data = std::fs::read(&file_path)
        .map_err(|e| format!("Failed to read file: {}", e))?;
    
    if file_data.len() < 16 {
        return Err("Invalid file header".to_string());
    }
    
    let alignment = u32::from_le_bytes([file_data[0], file_data[1], file_data[2], file_data[3]]);
    let data_size = u32::from_le_bytes([file_data[4], file_data[5], file_data[6], file_data[7]]);
    let chunk_count = u64::from_le_bytes([
        file_data[8], file_data[9], file_data[10], file_data[11],
        file_data[12], file_data[13], file_data[14], file_data[15]
    ]);
    
    Ok(serde_json::json!({
        "path": file_path.to_string_lossy(),
        "size": metadata.len(),
        "alignment": alignment,
        "data_size": data_size,
        "chunk_count": chunk_count,
    }))
}

#[tauri::command]
async fn read_memory(address: u64, size: usize) -> Result<MemoryReadResponse, String> {
    let (host, port) = {
        let config = SERVER_CONFIG.read().map_err(|e| e.to_string())?;
        (config.host.clone(), config.port)
    };
    
    if host.is_empty() {
        return Ok(MemoryReadResponse {
            success: false,
            data: None,
            error: Some("No server connection configured".to_string()),
        });
    }

    let client = reqwest::Client::new();
    let url = format!("http://{}:{}/api/memory/read", host, port);
    
    let request_body = serde_json::json!({
        "address": address,
        "size": size
    });

    match client.post(&url).json(&request_body).send().await {
        Ok(response) => {
            if response.status().is_success() {
                match response.json::<serde_json::Value>().await {
                    Ok(json_response) => {
                        if let Some(data_str) = json_response.get("data").and_then(|v| v.as_str()) {
                            // Convert hex string to bytes
                            let hex_clean = data_str.replace(" ", "").replace("\n", "");
                            let mut bytes = Vec::new();
                            
                            // Parse hex string in pairs
                            for chunk in hex_clean.chars().collect::<Vec<char>>().chunks(2) {
                                if chunk.len() == 2 {
                                    let hex_str: String = chunk.iter().collect();
                                    if let Ok(byte) = u8::from_str_radix(&hex_str, 16) {
                                        bytes.push(byte);
                                    }
                                }
                            }
                            
                            Ok(MemoryReadResponse {
                                success: true,
                                data: Some(bytes),
                                error: None,
                            })
                        } else {
                            Ok(MemoryReadResponse {
                                success: false,
                                data: None,
                                error: Some("Invalid response format - no data field".to_string()),
                            })
                        }
                    }
                    Err(e) => Ok(MemoryReadResponse {
                        success: false,
                        data: None,
                        error: Some(format!("Failed to parse response: {}", e)),
                    })
                }
            } else {
                Ok(MemoryReadResponse {
                    success: false,
                    data: None,
                    error: Some(format!("Server error: {}", response.status())),
                })
            }
        }
        Err(e) => Ok(MemoryReadResponse {
            success: false,
            data: None,
            error: Some(format!("Network error: {}", e)),
        })
    }
}

/// WASM opcode to mnemonic mapping (basic opcodes)
fn wasm_opcode_to_string(opcode: u8) -> (&'static str, usize) {
    // Returns (mnemonic, instruction_length including opcode)
    match opcode {
        // Control instructions
        0x00 => ("unreachable", 1),
        0x01 => ("nop", 1),
        0x02 => ("block", 2),      // + blocktype
        0x03 => ("loop", 2),       // + blocktype
        0x04 => ("if", 2),         // + blocktype
        0x05 => ("else", 1),
        0x0B => ("end", 1),
        0x0C => ("br", 2),         // + labelidx
        0x0D => ("br_if", 2),      // + labelidx
        0x0E => ("br_table", 2),   // variable, simplified
        0x0F => ("return", 1),
        0x10 => ("call", 5),       // + funcidx (leb128)
        0x11 => ("call_indirect", 6), // + typeidx + tableidx
        
        // Parametric instructions
        0x1A => ("drop", 1),
        0x1B => ("select", 1),
        0x1C => ("select", 2),     // typed select
        
        // Variable instructions
        0x20 => ("local.get", 2),
        0x21 => ("local.set", 2),
        0x22 => ("local.tee", 2),
        0x23 => ("global.get", 2),
        0x24 => ("global.set", 2),
        
        // Table instructions
        0x25 => ("table.get", 2),
        0x26 => ("table.set", 2),
        
        // Memory instructions
        0x28 => ("i32.load", 3),
        0x29 => ("i64.load", 3),
        0x2A => ("f32.load", 3),
        0x2B => ("f64.load", 3),
        0x2C => ("i32.load8_s", 3),
        0x2D => ("i32.load8_u", 3),
        0x2E => ("i32.load16_s", 3),
        0x2F => ("i32.load16_u", 3),
        0x30 => ("i64.load8_s", 3),
        0x31 => ("i64.load8_u", 3),
        0x32 => ("i64.load16_s", 3),
        0x33 => ("i64.load16_u", 3),
        0x34 => ("i64.load32_s", 3),
        0x35 => ("i64.load32_u", 3),
        0x36 => ("i32.store", 3),
        0x37 => ("i64.store", 3),
        0x38 => ("f32.store", 3),
        0x39 => ("f64.store", 3),
        0x3A => ("i32.store8", 3),
        0x3B => ("i32.store16", 3),
        0x3C => ("i64.store8", 3),
        0x3D => ("i64.store16", 3),
        0x3E => ("i64.store32", 3),
        0x3F => ("memory.size", 2),
        0x40 => ("memory.grow", 2),
        
        // Numeric instructions - constants
        0x41 => ("i32.const", 5),   // + i32 leb128
        0x42 => ("i64.const", 9),   // + i64 leb128
        0x43 => ("f32.const", 5),   // + f32
        0x44 => ("f64.const", 9),   // + f64
        
        // Numeric instructions - comparison
        0x45 => ("i32.eqz", 1),
        0x46 => ("i32.eq", 1),
        0x47 => ("i32.ne", 1),
        0x48 => ("i32.lt_s", 1),
        0x49 => ("i32.lt_u", 1),
        0x4A => ("i32.gt_s", 1),
        0x4B => ("i32.gt_u", 1),
        0x4C => ("i32.le_s", 1),
        0x4D => ("i32.le_u", 1),
        0x4E => ("i32.ge_s", 1),
        0x4F => ("i32.ge_u", 1),
        
        0x50 => ("i64.eqz", 1),
        0x51 => ("i64.eq", 1),
        0x52 => ("i64.ne", 1),
        0x53 => ("i64.lt_s", 1),
        0x54 => ("i64.lt_u", 1),
        0x55 => ("i64.gt_s", 1),
        0x56 => ("i64.gt_u", 1),
        0x57 => ("i64.le_s", 1),
        0x58 => ("i64.le_u", 1),
        0x59 => ("i64.ge_s", 1),
        0x5A => ("i64.ge_u", 1),
        
        0x5B => ("f32.eq", 1),
        0x5C => ("f32.ne", 1),
        0x5D => ("f32.lt", 1),
        0x5E => ("f32.gt", 1),
        0x5F => ("f32.le", 1),
        0x60 => ("f32.ge", 1),
        
        0x61 => ("f64.eq", 1),
        0x62 => ("f64.ne", 1),
        0x63 => ("f64.lt", 1),
        0x64 => ("f64.gt", 1),
        0x65 => ("f64.le", 1),
        0x66 => ("f64.ge", 1),
        
        // Numeric instructions - arithmetic
        0x67 => ("i32.clz", 1),
        0x68 => ("i32.ctz", 1),
        0x69 => ("i32.popcnt", 1),
        0x6A => ("i32.add", 1),
        0x6B => ("i32.sub", 1),
        0x6C => ("i32.mul", 1),
        0x6D => ("i32.div_s", 1),
        0x6E => ("i32.div_u", 1),
        0x6F => ("i32.rem_s", 1),
        0x70 => ("i32.rem_u", 1),
        0x71 => ("i32.and", 1),
        0x72 => ("i32.or", 1),
        0x73 => ("i32.xor", 1),
        0x74 => ("i32.shl", 1),
        0x75 => ("i32.shr_s", 1),
        0x76 => ("i32.shr_u", 1),
        0x77 => ("i32.rotl", 1),
        0x78 => ("i32.rotr", 1),
        
        0x79 => ("i64.clz", 1),
        0x7A => ("i64.ctz", 1),
        0x7B => ("i64.popcnt", 1),
        0x7C => ("i64.add", 1),
        0x7D => ("i64.sub", 1),
        0x7E => ("i64.mul", 1),
        0x7F => ("i64.div_s", 1),
        0x80 => ("i64.div_u", 1),
        0x81 => ("i64.rem_s", 1),
        0x82 => ("i64.rem_u", 1),
        0x83 => ("i64.and", 1),
        0x84 => ("i64.or", 1),
        0x85 => ("i64.xor", 1),
        0x86 => ("i64.shl", 1),
        0x87 => ("i64.shr_s", 1),
        0x88 => ("i64.shr_u", 1),
        0x89 => ("i64.rotl", 1),
        0x8A => ("i64.rotr", 1),
        
        // Float operations
        0x8B => ("f32.abs", 1),
        0x8C => ("f32.neg", 1),
        0x8D => ("f32.ceil", 1),
        0x8E => ("f32.floor", 1),
        0x8F => ("f32.trunc", 1),
        0x90 => ("f32.nearest", 1),
        0x91 => ("f32.sqrt", 1),
        0x92 => ("f32.add", 1),
        0x93 => ("f32.sub", 1),
        0x94 => ("f32.mul", 1),
        0x95 => ("f32.div", 1),
        0x96 => ("f32.min", 1),
        0x97 => ("f32.max", 1),
        0x98 => ("f32.copysign", 1),
        
        0x99 => ("f64.abs", 1),
        0x9A => ("f64.neg", 1),
        0x9B => ("f64.ceil", 1),
        0x9C => ("f64.floor", 1),
        0x9D => ("f64.trunc", 1),
        0x9E => ("f64.nearest", 1),
        0x9F => ("f64.sqrt", 1),
        0xA0 => ("f64.add", 1),
        0xA1 => ("f64.sub", 1),
        0xA2 => ("f64.mul", 1),
        0xA3 => ("f64.div", 1),
        0xA4 => ("f64.min", 1),
        0xA5 => ("f64.max", 1),
        0xA6 => ("f64.copysign", 1),
        
        // Conversions
        0xA7 => ("i32.wrap_i64", 1),
        0xA8 => ("i32.trunc_f32_s", 1),
        0xA9 => ("i32.trunc_f32_u", 1),
        0xAA => ("i32.trunc_f64_s", 1),
        0xAB => ("i32.trunc_f64_u", 1),
        0xAC => ("i64.extend_i32_s", 1),
        0xAD => ("i64.extend_i32_u", 1),
        0xAE => ("i64.trunc_f32_s", 1),
        0xAF => ("i64.trunc_f32_u", 1),
        0xB0 => ("i64.trunc_f64_s", 1),
        0xB1 => ("i64.trunc_f64_u", 1),
        0xB2 => ("f32.convert_i32_s", 1),
        0xB3 => ("f32.convert_i32_u", 1),
        0xB4 => ("f32.convert_i64_s", 1),
        0xB5 => ("f32.convert_i64_u", 1),
        0xB6 => ("f32.demote_f64", 1),
        0xB7 => ("f64.convert_i32_s", 1),
        0xB8 => ("f64.convert_i32_u", 1),
        0xB9 => ("f64.convert_i64_s", 1),
        0xBA => ("f64.convert_i64_u", 1),
        0xBB => ("f64.promote_f32", 1),
        0xBC => ("i32.reinterpret_f32", 1),
        0xBD => ("i64.reinterpret_f64", 1),
        0xBE => ("f32.reinterpret_i32", 1),
        0xBF => ("f64.reinterpret_i64", 1),
        
        // Sign extension
        0xC0 => ("i32.extend8_s", 1),
        0xC1 => ("i32.extend16_s", 1),
        0xC2 => ("i64.extend8_s", 1),
        0xC3 => ("i64.extend16_s", 1),
        0xC4 => ("i64.extend32_s", 1),
        
        // Multi-byte opcodes (FC prefix)
        0xFC => ("(FC prefix)", 2),
        // Multi-byte opcodes (FD prefix - SIMD)
        0xFD => ("(FD simd)", 2),
        
        _ => ("unknown", 1),
    }
}

/// Read unsigned LEB128 from bytes, returns (value, bytes_consumed)
fn read_uleb128(data: &[u8], offset: usize) -> (u64, usize) {
    let mut result: u64 = 0;
    let mut shift = 0;
    let mut idx = 0;
    
    while offset + idx < data.len() {
        let byte = data[offset + idx];
        result |= ((byte & 0x7f) as u64) << shift;
        idx += 1;
        if byte & 0x80 == 0 {
            break;
        }
        shift += 7;
        if shift >= 64 {
            break;
        }
    }
    
    (result, idx)
}

/// Read signed LEB128 from bytes
fn read_sleb128(data: &[u8], offset: usize) -> (i64, usize) {
    let mut result: i64 = 0;
    let mut shift = 0;
    let mut idx = 0;
    let mut byte = 0u8;
    
    while offset + idx < data.len() {
        byte = data[offset + idx];
        result |= ((byte & 0x7f) as i64) << shift;
        shift += 7;
        idx += 1;
        if byte & 0x80 == 0 {
            break;
        }
        if shift >= 64 {
            break;
        }
    }
    
    // Sign extend if needed
    if shift < 64 && (byte & 0x40) != 0 {
        result |= !0i64 << shift;
    }
    
    (result, idx)
}

/// Get WASM instruction info: (mnemonic, total_bytes, operand_string, is_branch, branch_target_offset)
fn decode_wasm_instruction(data: &[u8], offset: usize, _base_address: u64) -> (String, usize, String, bool, Option<u64>) {
    if offset >= data.len() {
        return ("".to_string(), 0, "".to_string(), false, None);
    }
    
    let opcode = data[offset];
    let mut consumed = 1usize;
    let mut operand = String::new();
    let mut is_branch = false;
    let mut branch_target: Option<u64> = None;
    
    let mnemonic = match opcode {
        // Control instructions
        0x00 => "unreachable",
        0x01 => "nop",
        0x02 => { // block
            if offset + 1 < data.len() {
                let blocktype = data[offset + 1] as i8;
                consumed += 1;
                operand = match blocktype {
                    0x40 => "".to_string(),
                    t => format!("{:02x}", t as u8),
                };
            }
            "block"
        }
        0x03 => { // loop
            if offset + 1 < data.len() {
                let blocktype = data[offset + 1] as i8;
                consumed += 1;
                operand = match blocktype {
                    0x40 => "".to_string(),
                    t => format!("{:02x}", t as u8),
                };
            }
            "loop"
        }
        0x04 => { // if
            if offset + 1 < data.len() {
                consumed += 1;
            }
            "if"
        }
        0x05 => "else",
        0x0B => "end",
        0x0C => { // br
            let (labelidx, len) = read_uleb128(data, offset + 1);
            consumed += len;
            operand = format!("{}", labelidx);
            is_branch = true;
            "br"
        }
        0x0D => { // br_if
            let (labelidx, len) = read_uleb128(data, offset + 1);
            consumed += len;
            operand = format!("{}", labelidx);
            is_branch = true;
            "br_if"
        }
        0x0E => { // br_table
            let (count, len1) = read_uleb128(data, offset + 1);
            consumed += len1;
            let mut labels = Vec::new();
            for _ in 0..=count {
                let (label, len) = read_uleb128(data, offset + consumed);
                labels.push(label);
                consumed += len;
            }
            operand = labels.iter().map(|l| l.to_string()).collect::<Vec<_>>().join(" ");
            is_branch = true;
            "br_table"
        }
        0x0F => "return",
        0x10 => { // call
            let (funcidx, len) = read_uleb128(data, offset + 1);
            consumed += len;
            operand = format!("func[{}]", funcidx);
            is_branch = true;
            branch_target = Some(funcidx); // Function index as target
            "call"
        }
        0x11 => { // call_indirect
            let (typeidx, len1) = read_uleb128(data, offset + 1);
            consumed += len1;
            let (tableidx, len2) = read_uleb128(data, offset + 1 + len1);
            consumed += len2;
            operand = format!("type[{}] table[{}]", typeidx, tableidx);
            "call_indirect"
        }
        
        // Parametric
        0x1A => "drop",
        0x1B => "select",
        
        // Variable instructions
        0x20 => { // local.get
            let (idx, len) = read_uleb128(data, offset + 1);
            consumed += len;
            operand = format!("{}", idx);
            "local.get"
        }
        0x21 => { // local.set
            let (idx, len) = read_uleb128(data, offset + 1);
            consumed += len;
            operand = format!("{}", idx);
            "local.set"
        }
        0x22 => { // local.tee
            let (idx, len) = read_uleb128(data, offset + 1);
            consumed += len;
            operand = format!("{}", idx);
            "local.tee"
        }
        0x23 => { // global.get
            let (idx, len) = read_uleb128(data, offset + 1);
            consumed += len;
            operand = format!("{}", idx);
            "global.get"
        }
        0x24 => { // global.set
            let (idx, len) = read_uleb128(data, offset + 1);
            consumed += len;
            operand = format!("{}", idx);
            "global.set"
        }
        
        // Memory load/store
        0x28..=0x3E => {
            let (align, len1) = read_uleb128(data, offset + 1);
            consumed += len1;
            let (mem_offset, len2) = read_uleb128(data, offset + 1 + len1);
            consumed += len2;
            operand = format!("align={} offset={}", align, mem_offset);
            match opcode {
                0x28 => "i32.load",
                0x29 => "i64.load",
                0x2A => "f32.load",
                0x2B => "f64.load",
                0x2C => "i32.load8_s",
                0x2D => "i32.load8_u",
                0x2E => "i32.load16_s",
                0x2F => "i32.load16_u",
                0x30 => "i64.load8_s",
                0x31 => "i64.load8_u",
                0x32 => "i64.load16_s",
                0x33 => "i64.load16_u",
                0x34 => "i64.load32_s",
                0x35 => "i64.load32_u",
                0x36 => "i32.store",
                0x37 => "i64.store",
                0x38 => "f32.store",
                0x39 => "f64.store",
                0x3A => "i32.store8",
                0x3B => "i32.store16",
                0x3C => "i64.store8",
                0x3D => "i64.store16",
                0x3E => "i64.store32",
                _ => "memory_op",
            }
        }
        0x3F => { // memory.size
            let (memidx, len) = read_uleb128(data, offset + 1);
            consumed += len;
            operand = format!("{}", memidx);
            "memory.size"
        }
        0x40 => { // memory.grow
            let (memidx, len) = read_uleb128(data, offset + 1);
            consumed += len;
            operand = format!("{}", memidx);
            "memory.grow"
        }
        
        // Constants
        0x41 => { // i32.const
            let (val, len) = read_sleb128(data, offset + 1);
            consumed += len;
            operand = format!("{}", val as i32);
            "i32.const"
        }
        0x42 => { // i64.const
            let (val, len) = read_sleb128(data, offset + 1);
            consumed += len;
            operand = format!("{}", val);
            "i64.const"
        }
        0x43 => { // f32.const
            if offset + 5 <= data.len() {
                let bytes = [data[offset+1], data[offset+2], data[offset+3], data[offset+4]];
                let val = f32::from_le_bytes(bytes);
                operand = format!("{}", val);
                consumed += 4;
            }
            "f32.const"
        }
        0x44 => { // f64.const
            if offset + 9 <= data.len() {
                let bytes = [data[offset+1], data[offset+2], data[offset+3], data[offset+4],
                             data[offset+5], data[offset+6], data[offset+7], data[offset+8]];
                let val = f64::from_le_bytes(bytes);
                operand = format!("{}", val);
                consumed += 8;
            }
            "f64.const"
        }
        
        // Comparison i32
        0x45 => "i32.eqz",
        0x46 => "i32.eq",
        0x47 => "i32.ne",
        0x48 => "i32.lt_s",
        0x49 => "i32.lt_u",
        0x4A => "i32.gt_s",
        0x4B => "i32.gt_u",
        0x4C => "i32.le_s",
        0x4D => "i32.le_u",
        0x4E => "i32.ge_s",
        0x4F => "i32.ge_u",
        
        // Comparison i64
        0x50 => "i64.eqz",
        0x51 => "i64.eq",
        0x52 => "i64.ne",
        0x53 => "i64.lt_s",
        0x54 => "i64.lt_u",
        0x55 => "i64.gt_s",
        0x56 => "i64.gt_u",
        0x57 => "i64.le_s",
        0x58 => "i64.le_u",
        0x59 => "i64.ge_s",
        0x5A => "i64.ge_u",
        
        // Comparison f32
        0x5B => "f32.eq",
        0x5C => "f32.ne",
        0x5D => "f32.lt",
        0x5E => "f32.gt",
        0x5F => "f32.le",
        0x60 => "f32.ge",
        
        // Comparison f64
        0x61 => "f64.eq",
        0x62 => "f64.ne",
        0x63 => "f64.lt",
        0x64 => "f64.gt",
        0x65 => "f64.le",
        0x66 => "f64.ge",
        
        // Numeric i32
        0x67 => "i32.clz",
        0x68 => "i32.ctz",
        0x69 => "i32.popcnt",
        0x6A => "i32.add",
        0x6B => "i32.sub",
        0x6C => "i32.mul",
        0x6D => "i32.div_s",
        0x6E => "i32.div_u",
        0x6F => "i32.rem_s",
        0x70 => "i32.rem_u",
        0x71 => "i32.and",
        0x72 => "i32.or",
        0x73 => "i32.xor",
        0x74 => "i32.shl",
        0x75 => "i32.shr_s",
        0x76 => "i32.shr_u",
        0x77 => "i32.rotl",
        0x78 => "i32.rotr",
        
        // Numeric i64
        0x79 => "i64.clz",
        0x7A => "i64.ctz",
        0x7B => "i64.popcnt",
        0x7C => "i64.add",
        0x7D => "i64.sub",
        0x7E => "i64.mul",
        0x7F => "i64.div_s",
        0x80 => "i64.div_u",
        0x81 => "i64.rem_s",
        0x82 => "i64.rem_u",
        0x83 => "i64.and",
        0x84 => "i64.or",
        0x85 => "i64.xor",
        0x86 => "i64.shl",
        0x87 => "i64.shr_s",
        0x88 => "i64.shr_u",
        0x89 => "i64.rotl",
        0x8A => "i64.rotr",
        
        // Numeric f32
        0x8B => "f32.abs",
        0x8C => "f32.neg",
        0x8D => "f32.ceil",
        0x8E => "f32.floor",
        0x8F => "f32.trunc",
        0x90 => "f32.nearest",
        0x91 => "f32.sqrt",
        0x92 => "f32.add",
        0x93 => "f32.sub",
        0x94 => "f32.mul",
        0x95 => "f32.div",
        0x96 => "f32.min",
        0x97 => "f32.max",
        0x98 => "f32.copysign",
        
        // Numeric f64
        0x99 => "f64.abs",
        0x9A => "f64.neg",
        0x9B => "f64.ceil",
        0x9C => "f64.floor",
        0x9D => "f64.trunc",
        0x9E => "f64.nearest",
        0x9F => "f64.sqrt",
        0xA0 => "f64.add",
        0xA1 => "f64.sub",
        0xA2 => "f64.mul",
        0xA3 => "f64.div",
        0xA4 => "f64.min",
        0xA5 => "f64.max",
        0xA6 => "f64.copysign",
        
        // Conversions
        0xA7 => "i32.wrap_i64",
        0xA8 => "i32.trunc_f32_s",
        0xA9 => "i32.trunc_f32_u",
        0xAA => "i32.trunc_f64_s",
        0xAB => "i32.trunc_f64_u",
        0xAC => "i64.extend_i32_s",
        0xAD => "i64.extend_i32_u",
        0xAE => "i64.trunc_f32_s",
        0xAF => "i64.trunc_f32_u",
        0xB0 => "i64.trunc_f64_s",
        0xB1 => "i64.trunc_f64_u",
        0xB2 => "f32.convert_i32_s",
        0xB3 => "f32.convert_i32_u",
        0xB4 => "f32.convert_i64_s",
        0xB5 => "f32.convert_i64_u",
        0xB6 => "f32.demote_f64",
        0xB7 => "f64.convert_i32_s",
        0xB8 => "f64.convert_i32_u",
        0xB9 => "f64.convert_i64_s",
        0xBA => "f64.convert_i64_u",
        0xBB => "f64.promote_f32",
        0xBC => "i32.reinterpret_f32",
        0xBD => "i64.reinterpret_f64",
        0xBE => "f32.reinterpret_i32",
        0xBF => "f64.reinterpret_i64",
        
        // Sign extension
        0xC0 => "i32.extend8_s",
        0xC1 => "i32.extend16_s",
        0xC2 => "i64.extend8_s",
        0xC3 => "i64.extend16_s",
        0xC4 => "i64.extend32_s",
        
        // FC prefix (extended instructions)
        0xFC => {
            if offset + 1 < data.len() {
                let (subop, len) = read_uleb128(data, offset + 1);
                consumed += len;
                match subop {
                    0 => "i32.trunc_sat_f32_s",
                    1 => "i32.trunc_sat_f32_u",
                    2 => "i32.trunc_sat_f64_s",
                    3 => "i32.trunc_sat_f64_u",
                    4 => "i64.trunc_sat_f32_s",
                    5 => "i64.trunc_sat_f32_u",
                    6 => "i64.trunc_sat_f64_s",
                    7 => "i64.trunc_sat_f64_u",
                    8 => { // memory.init
                        let (dataidx, len1) = read_uleb128(data, offset + consumed);
                        consumed += len1;
                        let (memidx, len2) = read_uleb128(data, offset + consumed);
                        consumed += len2;
                        operand = format!("data[{}] mem[{}]", dataidx, memidx);
                        "memory.init"
                    }
                    9 => { // data.drop
                        let (dataidx, len1) = read_uleb128(data, offset + consumed);
                        consumed += len1;
                        operand = format!("{}", dataidx);
                        "data.drop"
                    }
                    10 => { // memory.copy
                        let (dst, len1) = read_uleb128(data, offset + consumed);
                        consumed += len1;
                        let (src, len2) = read_uleb128(data, offset + consumed);
                        consumed += len2;
                        operand = format!("dst={} src={}", dst, src);
                        "memory.copy"
                    }
                    11 => { // memory.fill
                        let (memidx, len1) = read_uleb128(data, offset + consumed);
                        consumed += len1;
                        operand = format!("{}", memidx);
                        "memory.fill"
                    }
                    _ => "fc_unknown",
                }
            } else {
                "fc_prefix"
            }
        }
        
        // FD prefix (SIMD)
        0xFD => {
            if offset + 1 < data.len() {
                let (subop, len) = read_uleb128(data, offset + 1);
                consumed += len;
                operand = format!("{}", subop);
            }
            "simd"
        }
        
        _ => "unknown",
    };
    
    (mnemonic.to_string(), consumed, operand, is_branch, branch_target)
}

/// Disassemble WASM bytecode with detailed output
fn disassemble_wasm(memory_data: &[u8], base_address: u64) -> DisassembleResponse {
    let mut lines = Vec::new();
    let mut offset: usize = 0;
    let max_instructions = 500;
    
    while offset < memory_data.len() && lines.len() < max_instructions {
        let (mnemonic, consumed, operand, is_branch, _branch_target) = 
            decode_wasm_instruction(memory_data, offset, base_address);
        
        if consumed == 0 {
            break;
        }
        
        let current_address = base_address + offset as u64;
        let end_offset = std::cmp::min(offset + consumed, memory_data.len());
        
        // Format bytes (max 8 shown)
        let bytes_display = memory_data[offset..end_offset]
            .iter()
            .take(8)
            .map(|b| format!("{:02x}", b))
            .collect::<Vec<_>>()
            .join(" ");
        let bytes_suffix = if consumed > 8 { ".." } else { "" };
        
        // Format branch arrow hint
        let branch_hint = if is_branch { " <-" } else { "" };
        
        // Format: address|bytes|mnemonic operand (pipe-separated for parser)
        // Only add space before operand if operand is not empty
        let instruction_text = if operand.is_empty() {
            format!("{}{}", mnemonic, branch_hint)
        } else {
            format!("{} {}{}", mnemonic, operand, branch_hint)
        };
        
        let line = format!(
            "0x{:08x}|{}{}|{}",
            current_address,
            bytes_display,
            bytes_suffix,
            instruction_text
        );
        lines.push(line);
        
        offset += consumed;
    }
    
    DisassembleResponse {
        success: true,
        disassembly: Some(lines.join("\n")),
        instructions_count: lines.len(),
        error: None,
    }
}

// ============================================================================
// WASM File Analysis with wasmparser
// ============================================================================

/// WASM module directory for saved .wasm files
fn get_wasm_modules_dir() -> PathBuf {
    dirs::data_local_dir()
        .unwrap_or_else(|| PathBuf::from("."))
        .join("DynaDbg")
        .join("wasm_modules")
}

/// WASM function info from wasmparser analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WasmFunctionInfo {
    pub index: u32,
    pub name: Option<String>,
    pub code_offset: u32,      // Offset within the Code section
    pub code_size: u32,        // Size of function body
    pub local_count: u32,      // Number of locals
    pub param_count: u32,      // Number of parameters (from type)
    pub result_count: u32,     // Number of results (from type)
    pub instructions: Vec<WasmInstructionInfo>,
}

/// WASM instruction info with structured details
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WasmInstructionInfo {
    pub offset: u32,           // Byte offset within function
    pub bytes: Vec<u8>,        // Raw instruction bytes
    pub mnemonic: String,      // Instruction name
    pub operands: String,      // Formatted operands
    pub is_branch: bool,       // Is this a branch/control flow instruction
    pub depth_change: i32,     // Block nesting change (+1 for block/loop/if, -1 for end)
}

/// WASM module analysis result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WasmModuleAnalysis {
    pub file_path: String,
    pub functions: Vec<WasmFunctionInfo>,
    pub import_count: u32,
    pub export_count: u32,
    pub memory_count: u32,
    pub table_count: u32,
    pub global_count: u32,
}

/// Save WASM binary data to a .wasm file for Ghidra analysis
#[tauri::command]
async fn save_wasm_binary(
    binary_data: Vec<u8>,
    module_name: String,
    project_name: Option<String>,
) -> Result<String, String> {
    // Save to ghidra_projects/libraries/{project_name}/ directory (same as native libraries)
    // This ensures consistency with how native libraries are stored
    let ghidra_dir = get_ghidra_projects_dir();
    let libs_dir = if let Some(ref proj_name) = project_name {
        ghidra_dir.join("libraries").join(proj_name)
    } else {
        ghidra_dir.join("libraries")
    };
    std::fs::create_dir_all(&libs_dir).map_err(|e| format!("Failed to create libraries directory: {}", e))?;
    
    // Sanitize module name for filename
    let safe_name = module_name
        .chars()
        .map(|c| if c.is_alphanumeric() || c == '_' || c == '-' { c } else { '_' })
        .collect::<String>();
    
    let timestamp = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs();
    
    let filename = format!("{}_{}.wasm", safe_name, timestamp);
    let file_path = libs_dir.join(&filename);
    
    // Write the WASM binary
    std::fs::write(&file_path, &binary_data)
        .map_err(|e| format!("Failed to write WASM file: {}", e))?;
    
    let path_str = file_path.to_string_lossy().to_string();
    println!("[WASM] Saved WASM binary to: {} ({} bytes)", path_str, binary_data.len());
    
    Ok(path_str)
}

/// Get saved WASM files list
#[tauri::command]
async fn list_wasm_files() -> Result<Vec<String>, String> {
    let wasm_dir = get_wasm_modules_dir();
    
    if !wasm_dir.exists() {
        return Ok(Vec::new());
    }
    
    let entries = std::fs::read_dir(&wasm_dir)
        .map_err(|e| format!("Failed to read WASM directory: {}", e))?;
    
    let mut files = Vec::new();
    for entry in entries {
        if let Ok(entry) = entry {
            let path = entry.path();
            if path.extension().map(|e| e == "wasm").unwrap_or(false) {
                files.push(path.to_string_lossy().to_string());
            }
        }
    }
    
    files.sort();
    Ok(files)
}

/// Format a wasmparser Operator to mnemonic and operands
fn format_wasm_operator(op: &Operator) -> (String, String, bool, i32) {
    use Operator::*;
    
    match op {
        // Control flow
        Unreachable => ("unreachable".into(), "".into(), false, 0),
        Nop => ("nop".into(), "".into(), false, 0),
        Block { blockty } => ("block".into(), format!("{:?}", blockty), false, 1),
        Loop { blockty } => ("loop".into(), format!("{:?}", blockty), true, 1),
        If { blockty } => ("if".into(), format!("{:?}", blockty), true, 1),
        Else => ("else".into(), "".into(), false, 0),
        End => ("end".into(), "".into(), false, -1),
        Br { relative_depth } => ("br".into(), format!("{}", relative_depth), true, 0),
        BrIf { relative_depth } => ("br_if".into(), format!("{}", relative_depth), true, 0),
        BrTable { targets } => ("br_table".into(), format!("{} targets", targets.len()), true, 0),
        Return => ("return".into(), "".into(), true, 0),
        Call { function_index } => ("call".into(), format!("func[{}]", function_index), true, 0),
        CallIndirect { type_index, table_index } => 
            ("call_indirect".into(), format!("type[{}] table[{}]", type_index, table_index), true, 0),
        
        // Parametric
        Drop => ("drop".into(), "".into(), false, 0),
        Select => ("select".into(), "".into(), false, 0),
        
        // Variable access
        LocalGet { local_index } => ("local.get".into(), format!("{}", local_index), false, 0),
        LocalSet { local_index } => ("local.set".into(), format!("{}", local_index), false, 0),
        LocalTee { local_index } => ("local.tee".into(), format!("{}", local_index), false, 0),
        GlobalGet { global_index } => ("global.get".into(), format!("{}", global_index), false, 0),
        GlobalSet { global_index } => ("global.set".into(), format!("{}", global_index), false, 0),
        
        // Memory operations
        I32Load { memarg } => ("i32.load".into(), format!("offset={} align={}", memarg.offset, memarg.align), false, 0),
        I64Load { memarg } => ("i64.load".into(), format!("offset={} align={}", memarg.offset, memarg.align), false, 0),
        F32Load { memarg } => ("f32.load".into(), format!("offset={} align={}", memarg.offset, memarg.align), false, 0),
        F64Load { memarg } => ("f64.load".into(), format!("offset={} align={}", memarg.offset, memarg.align), false, 0),
        I32Load8S { memarg } => ("i32.load8_s".into(), format!("offset={}", memarg.offset), false, 0),
        I32Load8U { memarg } => ("i32.load8_u".into(), format!("offset={}", memarg.offset), false, 0),
        I32Load16S { memarg } => ("i32.load16_s".into(), format!("offset={}", memarg.offset), false, 0),
        I32Load16U { memarg } => ("i32.load16_u".into(), format!("offset={}", memarg.offset), false, 0),
        I64Load8S { memarg } => ("i64.load8_s".into(), format!("offset={}", memarg.offset), false, 0),
        I64Load8U { memarg } => ("i64.load8_u".into(), format!("offset={}", memarg.offset), false, 0),
        I64Load16S { memarg } => ("i64.load16_s".into(), format!("offset={}", memarg.offset), false, 0),
        I64Load16U { memarg } => ("i64.load16_u".into(), format!("offset={}", memarg.offset), false, 0),
        I64Load32S { memarg } => ("i64.load32_s".into(), format!("offset={}", memarg.offset), false, 0),
        I64Load32U { memarg } => ("i64.load32_u".into(), format!("offset={}", memarg.offset), false, 0),
        I32Store { memarg } => ("i32.store".into(), format!("offset={} align={}", memarg.offset, memarg.align), false, 0),
        I64Store { memarg } => ("i64.store".into(), format!("offset={} align={}", memarg.offset, memarg.align), false, 0),
        F32Store { memarg } => ("f32.store".into(), format!("offset={} align={}", memarg.offset, memarg.align), false, 0),
        F64Store { memarg } => ("f64.store".into(), format!("offset={} align={}", memarg.offset, memarg.align), false, 0),
        I32Store8 { memarg } => ("i32.store8".into(), format!("offset={}", memarg.offset), false, 0),
        I32Store16 { memarg } => ("i32.store16".into(), format!("offset={}", memarg.offset), false, 0),
        I64Store8 { memarg } => ("i64.store8".into(), format!("offset={}", memarg.offset), false, 0),
        I64Store16 { memarg } => ("i64.store16".into(), format!("offset={}", memarg.offset), false, 0),
        I64Store32 { memarg } => ("i64.store32".into(), format!("offset={}", memarg.offset), false, 0),
        MemorySize { mem, .. } => ("memory.size".into(), format!("{}", mem), false, 0),
        MemoryGrow { mem, .. } => ("memory.grow".into(), format!("{}", mem), false, 0),
        
        // Constants
        I32Const { value } => ("i32.const".into(), format!("{}", value), false, 0),
        I64Const { value } => ("i64.const".into(), format!("{}", value), false, 0),
        F32Const { value } => ("f32.const".into(), format!("{:?}", value), false, 0),
        F64Const { value } => ("f64.const".into(), format!("{:?}", value), false, 0),
        
        // Comparison
        I32Eqz => ("i32.eqz".into(), "".into(), false, 0),
        I32Eq => ("i32.eq".into(), "".into(), false, 0),
        I32Ne => ("i32.ne".into(), "".into(), false, 0),
        I32LtS => ("i32.lt_s".into(), "".into(), false, 0),
        I32LtU => ("i32.lt_u".into(), "".into(), false, 0),
        I32GtS => ("i32.gt_s".into(), "".into(), false, 0),
        I32GtU => ("i32.gt_u".into(), "".into(), false, 0),
        I32LeS => ("i32.le_s".into(), "".into(), false, 0),
        I32LeU => ("i32.le_u".into(), "".into(), false, 0),
        I32GeS => ("i32.ge_s".into(), "".into(), false, 0),
        I32GeU => ("i32.ge_u".into(), "".into(), false, 0),
        I64Eqz => ("i64.eqz".into(), "".into(), false, 0),
        I64Eq => ("i64.eq".into(), "".into(), false, 0),
        I64Ne => ("i64.ne".into(), "".into(), false, 0),
        I64LtS => ("i64.lt_s".into(), "".into(), false, 0),
        I64LtU => ("i64.lt_u".into(), "".into(), false, 0),
        I64GtS => ("i64.gt_s".into(), "".into(), false, 0),
        I64GtU => ("i64.gt_u".into(), "".into(), false, 0),
        I64LeS => ("i64.le_s".into(), "".into(), false, 0),
        I64LeU => ("i64.le_u".into(), "".into(), false, 0),
        I64GeS => ("i64.ge_s".into(), "".into(), false, 0),
        I64GeU => ("i64.ge_u".into(), "".into(), false, 0),
        F32Eq => ("f32.eq".into(), "".into(), false, 0),
        F32Ne => ("f32.ne".into(), "".into(), false, 0),
        F32Lt => ("f32.lt".into(), "".into(), false, 0),
        F32Gt => ("f32.gt".into(), "".into(), false, 0),
        F32Le => ("f32.le".into(), "".into(), false, 0),
        F32Ge => ("f32.ge".into(), "".into(), false, 0),
        F64Eq => ("f64.eq".into(), "".into(), false, 0),
        F64Ne => ("f64.ne".into(), "".into(), false, 0),
        F64Lt => ("f64.lt".into(), "".into(), false, 0),
        F64Gt => ("f64.gt".into(), "".into(), false, 0),
        F64Le => ("f64.le".into(), "".into(), false, 0),
        F64Ge => ("f64.ge".into(), "".into(), false, 0),
        
        // Arithmetic
        I32Clz => ("i32.clz".into(), "".into(), false, 0),
        I32Ctz => ("i32.ctz".into(), "".into(), false, 0),
        I32Popcnt => ("i32.popcnt".into(), "".into(), false, 0),
        I32Add => ("i32.add".into(), "".into(), false, 0),
        I32Sub => ("i32.sub".into(), "".into(), false, 0),
        I32Mul => ("i32.mul".into(), "".into(), false, 0),
        I32DivS => ("i32.div_s".into(), "".into(), false, 0),
        I32DivU => ("i32.div_u".into(), "".into(), false, 0),
        I32RemS => ("i32.rem_s".into(), "".into(), false, 0),
        I32RemU => ("i32.rem_u".into(), "".into(), false, 0),
        I32And => ("i32.and".into(), "".into(), false, 0),
        I32Or => ("i32.or".into(), "".into(), false, 0),
        I32Xor => ("i32.xor".into(), "".into(), false, 0),
        I32Shl => ("i32.shl".into(), "".into(), false, 0),
        I32ShrS => ("i32.shr_s".into(), "".into(), false, 0),
        I32ShrU => ("i32.shr_u".into(), "".into(), false, 0),
        I32Rotl => ("i32.rotl".into(), "".into(), false, 0),
        I32Rotr => ("i32.rotr".into(), "".into(), false, 0),
        I64Clz => ("i64.clz".into(), "".into(), false, 0),
        I64Ctz => ("i64.ctz".into(), "".into(), false, 0),
        I64Popcnt => ("i64.popcnt".into(), "".into(), false, 0),
        I64Add => ("i64.add".into(), "".into(), false, 0),
        I64Sub => ("i64.sub".into(), "".into(), false, 0),
        I64Mul => ("i64.mul".into(), "".into(), false, 0),
        I64DivS => ("i64.div_s".into(), "".into(), false, 0),
        I64DivU => ("i64.div_u".into(), "".into(), false, 0),
        I64RemS => ("i64.rem_s".into(), "".into(), false, 0),
        I64RemU => ("i64.rem_u".into(), "".into(), false, 0),
        I64And => ("i64.and".into(), "".into(), false, 0),
        I64Or => ("i64.or".into(), "".into(), false, 0),
        I64Xor => ("i64.xor".into(), "".into(), false, 0),
        I64Shl => ("i64.shl".into(), "".into(), false, 0),
        I64ShrS => ("i64.shr_s".into(), "".into(), false, 0),
        I64ShrU => ("i64.shr_u".into(), "".into(), false, 0),
        I64Rotl => ("i64.rotl".into(), "".into(), false, 0),
        I64Rotr => ("i64.rotr".into(), "".into(), false, 0),
        F32Abs => ("f32.abs".into(), "".into(), false, 0),
        F32Neg => ("f32.neg".into(), "".into(), false, 0),
        F32Ceil => ("f32.ceil".into(), "".into(), false, 0),
        F32Floor => ("f32.floor".into(), "".into(), false, 0),
        F32Trunc => ("f32.trunc".into(), "".into(), false, 0),
        F32Nearest => ("f32.nearest".into(), "".into(), false, 0),
        F32Sqrt => ("f32.sqrt".into(), "".into(), false, 0),
        F32Add => ("f32.add".into(), "".into(), false, 0),
        F32Sub => ("f32.sub".into(), "".into(), false, 0),
        F32Mul => ("f32.mul".into(), "".into(), false, 0),
        F32Div => ("f32.div".into(), "".into(), false, 0),
        F32Min => ("f32.min".into(), "".into(), false, 0),
        F32Max => ("f32.max".into(), "".into(), false, 0),
        F32Copysign => ("f32.copysign".into(), "".into(), false, 0),
        F64Abs => ("f64.abs".into(), "".into(), false, 0),
        F64Neg => ("f64.neg".into(), "".into(), false, 0),
        F64Ceil => ("f64.ceil".into(), "".into(), false, 0),
        F64Floor => ("f64.floor".into(), "".into(), false, 0),
        F64Trunc => ("f64.trunc".into(), "".into(), false, 0),
        F64Nearest => ("f64.nearest".into(), "".into(), false, 0),
        F64Sqrt => ("f64.sqrt".into(), "".into(), false, 0),
        F64Add => ("f64.add".into(), "".into(), false, 0),
        F64Sub => ("f64.sub".into(), "".into(), false, 0),
        F64Mul => ("f64.mul".into(), "".into(), false, 0),
        F64Div => ("f64.div".into(), "".into(), false, 0),
        F64Min => ("f64.min".into(), "".into(), false, 0),
        F64Max => ("f64.max".into(), "".into(), false, 0),
        F64Copysign => ("f64.copysign".into(), "".into(), false, 0),
        
        // Conversions
        I32WrapI64 => ("i32.wrap_i64".into(), "".into(), false, 0),
        I32TruncF32S => ("i32.trunc_f32_s".into(), "".into(), false, 0),
        I32TruncF32U => ("i32.trunc_f32_u".into(), "".into(), false, 0),
        I32TruncF64S => ("i32.trunc_f64_s".into(), "".into(), false, 0),
        I32TruncF64U => ("i32.trunc_f64_u".into(), "".into(), false, 0),
        I64ExtendI32S => ("i64.extend_i32_s".into(), "".into(), false, 0),
        I64ExtendI32U => ("i64.extend_i32_u".into(), "".into(), false, 0),
        I64TruncF32S => ("i64.trunc_f32_s".into(), "".into(), false, 0),
        I64TruncF32U => ("i64.trunc_f32_u".into(), "".into(), false, 0),
        I64TruncF64S => ("i64.trunc_f64_s".into(), "".into(), false, 0),
        I64TruncF64U => ("i64.trunc_f64_u".into(), "".into(), false, 0),
        F32ConvertI32S => ("f32.convert_i32_s".into(), "".into(), false, 0),
        F32ConvertI32U => ("f32.convert_i32_u".into(), "".into(), false, 0),
        F32ConvertI64S => ("f32.convert_i64_s".into(), "".into(), false, 0),
        F32ConvertI64U => ("f32.convert_i64_u".into(), "".into(), false, 0),
        F32DemoteF64 => ("f32.demote_f64".into(), "".into(), false, 0),
        F64ConvertI32S => ("f64.convert_i32_s".into(), "".into(), false, 0),
        F64ConvertI32U => ("f64.convert_i32_u".into(), "".into(), false, 0),
        F64ConvertI64S => ("f64.convert_i64_s".into(), "".into(), false, 0),
        F64ConvertI64U => ("f64.convert_i64_u".into(), "".into(), false, 0),
        F64PromoteF32 => ("f64.promote_f32".into(), "".into(), false, 0),
        I32ReinterpretF32 => ("i32.reinterpret_f32".into(), "".into(), false, 0),
        I64ReinterpretF64 => ("i64.reinterpret_f64".into(), "".into(), false, 0),
        F32ReinterpretI32 => ("f32.reinterpret_i32".into(), "".into(), false, 0),
        F64ReinterpretI64 => ("f64.reinterpret_i64".into(), "".into(), false, 0),
        
        // Sign extension
        I32Extend8S => ("i32.extend8_s".into(), "".into(), false, 0),
        I32Extend16S => ("i32.extend16_s".into(), "".into(), false, 0),
        I64Extend8S => ("i64.extend8_s".into(), "".into(), false, 0),
        I64Extend16S => ("i64.extend16_s".into(), "".into(), false, 0),
        I64Extend32S => ("i64.extend32_s".into(), "".into(), false, 0),
        
        // Reference types
        RefNull { hty } => ("ref.null".into(), format!("{:?}", hty), false, 0),
        RefIsNull => ("ref.is_null".into(), "".into(), false, 0),
        RefFunc { function_index } => ("ref.func".into(), format!("{}", function_index), false, 0),
        
        // Catch-all for other instructions
        _ => ("unknown".into(), format!("{:?}", op), false, 0),
    }
}

/// Analyze WASM binary using wasmparser for structured disassembly
#[tauri::command]
async fn analyze_wasm_binary(
    binary_data: Vec<u8>,
    _base_address: u64,
) -> Result<WasmModuleAnalysis, String> {
    let parser = Parser::new(0);
    let mut functions: Vec<WasmFunctionInfo> = Vec::new();
    let mut import_count = 0u32;
    let mut export_count = 0u32;
    let mut memory_count = 0u32;
    let mut table_count = 0u32;
    let mut global_count = 0u32;
    let mut type_section_types: Vec<(u32, u32)> = Vec::new(); // (params, results)
    let mut function_type_indices: Vec<u32> = Vec::new();
    let mut func_index = 0u32;
    
    for payload in parser.parse_all(&binary_data) {
        match payload {
            Ok(Payload::TypeSection(reader)) => {
                for ty in reader.into_iter_err_on_gc_types() {
                    match ty {
                        Ok(ft) => {
                            type_section_types.push((
                                ft.params().len() as u32,
                                ft.results().len() as u32,
                            ));
                        }
                        Err(_) => {}
                    }
                }
            }
            Ok(Payload::ImportSection(reader)) => {
                for import in reader {
                    if let Ok(imp) = import {
                        import_count += 1;
                        if matches!(imp.ty, wasmparser::TypeRef::Func(_)) {
                            func_index += 1;
                        }
                    }
                }
            }
            Ok(Payload::FunctionSection(reader)) => {
                for func_type in reader {
                    if let Ok(type_idx) = func_type {
                        function_type_indices.push(type_idx);
                    }
                }
            }
            Ok(Payload::TableSection(reader)) => {
                table_count = reader.count();
            }
            Ok(Payload::MemorySection(reader)) => {
                memory_count = reader.count();
            }
            Ok(Payload::GlobalSection(reader)) => {
                global_count = reader.count();
            }
            Ok(Payload::ExportSection(reader)) => {
                export_count = reader.count();
            }
            Ok(Payload::CodeSectionEntry(body)) => {
                let code_offset = body.range().start as u32;
                let code_size = body.range().len() as u32;
                
                // Get type info
                let local_func_idx = (func_index - import_count) as usize;
                let (param_count, result_count) = if local_func_idx < function_type_indices.len() {
                    let type_idx = function_type_indices[local_func_idx] as usize;
                    if type_idx < type_section_types.len() {
                        type_section_types[type_idx]
                    } else {
                        (0, 0)
                    }
                } else {
                    (0, 0)
                };
                
                // Count locals
                let mut local_count = 0u32;
                if let Ok(locals_reader) = body.get_locals_reader() {
                    for local in locals_reader {
                        if let Ok((count, _)) = local {
                            local_count += count;
                        }
                    }
                }
                
                // Parse instructions
                let mut instructions = Vec::new();
                if let Ok(ops_reader) = body.get_operators_reader() {
                    let mut reader = ops_reader;
                    let base_offset = body.range().start;
                    
                    while !reader.eof() {
                        let pos_before = reader.original_position();
                        match reader.read() {
                            Ok(op) => {
                                let pos_after = reader.original_position();
                                let _instr_size = pos_after - pos_before;
                                let instr_offset = pos_before - base_offset;
                                
                                // Get raw bytes
                                let bytes = if pos_before < binary_data.len() && pos_after <= binary_data.len() {
                                    binary_data[pos_before..pos_after].to_vec()
                                } else {
                                    vec![]
                                };
                                
                                let (mnemonic, operands, is_branch, depth_change) = format_wasm_operator(&op);
                                
                                instructions.push(WasmInstructionInfo {
                                    offset: instr_offset as u32,
                                    bytes,
                                    mnemonic,
                                    operands,
                                    is_branch,
                                    depth_change,
                                });
                            }
                            Err(_) => break,
                        }
                    }
                }
                
                functions.push(WasmFunctionInfo {
                    index: func_index,
                    name: None, // Will be filled from name section if available
                    code_offset,
                    code_size,
                    local_count,
                    param_count,
                    result_count,
                    instructions,
                });
                
                func_index += 1;
            }
            Ok(Payload::CustomSection(reader)) => {
                if reader.name() == "name" {
                    // Parse name section for function names
                    // This is optional and may not be present
                }
            }
            _ => {}
        }
    }
    
    Ok(WasmModuleAnalysis {
        file_path: String::new(),
        functions,
        import_count,
        export_count,
        memory_count,
        table_count,
        global_count,
    })
}

/// Disassemble a specific WASM function with wasmparser-based analysis
#[tauri::command]
async fn disassemble_wasm_function(
    binary_data: Vec<u8>,
    function_offset: u32,
    function_size: u32,
    base_address: u64,
) -> Result<DisassembleResponse, String> {
    // Validate offset and size
    if function_offset as usize >= binary_data.len() {
        return Err("Function offset out of bounds".to_string());
    }
    
    let end_offset = std::cmp::min(
        function_offset as usize + function_size as usize,
        binary_data.len()
    );
    
    let function_bytes = &binary_data[function_offset as usize..end_offset];
    
    // Try to parse as function body
    let mut lines = Vec::new();
    let mut offset = 0usize;
    let mut block_depth = 0i32;
    
    // Skip locals encoding if present (for raw function bodies)
    // First, read local count as LEB128
    let (local_groups, consumed) = read_uleb128(function_bytes, 0);
    offset += consumed;
    
    // Skip local declarations
    for _ in 0..local_groups {
        let (_count, c1) = read_uleb128(function_bytes, offset);
        offset += c1;
        if offset < function_bytes.len() {
            offset += 1; // Skip type byte
        }
    }
    
    // Now decode instructions
    while offset < function_bytes.len() && lines.len() < 500 {
        let (mnemonic, consumed, operand, is_branch, _) = 
            decode_wasm_instruction(function_bytes, offset, base_address);
        
        if consumed == 0 {
            break;
        }
        
        // Track block depth for indentation
        let indent = if mnemonic == "end" || mnemonic == "else" {
            block_depth = (block_depth - 1).max(0);
            "  ".repeat(block_depth as usize)
        } else {
            let indent = "  ".repeat(block_depth as usize);
            if mnemonic == "block" || mnemonic == "loop" || mnemonic == "if" {
                block_depth += 1;
            }
            indent
        };
        
        let current_address = base_address + (function_offset as u64) + (offset as u64);
        let end_off = std::cmp::min(offset + consumed, function_bytes.len());
        
        let bytes_display = function_bytes[offset..end_off]
            .iter()
            .take(8)
            .map(|b| format!("{:02x}", b))
            .collect::<Vec<_>>()
            .join(" ");
        let bytes_suffix = if consumed > 8 { ".." } else { "" };
        let branch_hint = if is_branch { " <-" } else { "" };
        
        // Only add space before operand if operand is not empty
        let instruction_text = if operand.is_empty() {
            format!("{}{}{}", indent, mnemonic, branch_hint)
        } else {
            format!("{}{} {}{}", indent, mnemonic, operand, branch_hint)
        };
        
        let line = format!(
            "0x{:08x}|{}{}|{}",
            current_address,
            bytes_display,
            bytes_suffix,
            instruction_text
        );
        lines.push(line);
        
        offset += consumed;
        
        // Stop at function end
        if mnemonic == "end" && block_depth == 0 {
            break;
        }
    }
    
    Ok(DisassembleResponse {
        success: true,
        disassembly: Some(lines.join("\n")),
        instructions_count: lines.len(),
        error: None,
    })
}

/// Open WASM modules directory in file explorer
#[tauri::command]
async fn open_wasm_modules_directory() -> Result<String, String> {
    let wasm_dir = get_wasm_modules_dir();
    std::fs::create_dir_all(&wasm_dir).map_err(|e| format!("Failed to create directory: {}", e))?;
    
    #[cfg(target_os = "windows")]
    {
        Command::new("explorer")
            .arg(&wasm_dir)
            .spawn()
            .map_err(|e| format!("Failed to open explorer: {}", e))?;
    }
    
    #[cfg(target_os = "macos")]
    {
        Command::new("open")
            .arg(&wasm_dir)
            .spawn()
            .map_err(|e| format!("Failed to open Finder: {}", e))?;
    }
    
    #[cfg(target_os = "linux")]
    {
        Command::new("xdg-open")
            .arg(&wasm_dir)
            .spawn()
            .map_err(|e| format!("Failed to open file manager: {}", e))?;
    }
    
    Ok(wasm_dir.to_string_lossy().to_string())
}

#[tauri::command]
async fn disassemble_memory_direct(
    memory_data: Vec<u8>,
    address: u64,
    architecture: String,
) -> Result<DisassembleResponse, String> {
    // Determine instruction size for the architecture (used for fallback on invalid bytes)
    let instruction_size: usize = match architecture.as_str() {
        "arm64" | "aarch64" | "arm" => 4,
        "x86" | "x86_64" => 1, // x86 is variable length, use 1 for fallback
        "wasm32" | "wasm" => 1, // WASM is variable length
        _ => 4,
    };

    // Handle WASM architecture specially (no Capstone support)
    if architecture == "wasm32" || architecture == "wasm" {
        return Ok(disassemble_wasm(&memory_data, address));
    }

    // Create capstone engine with proper architecture support
    let cs = match architecture.as_str() {
        "x86" => Capstone::new()
            .x86()
            .mode(arch::x86::ArchMode::Mode32)
            .detail(true)
            .build(),
        "x86_64" => Capstone::new()
            .x86()
            .mode(arch::x86::ArchMode::Mode64)
            .detail(true)
            .build(),
        "arm" => Capstone::new()
            .arm()
            .mode(arch::arm::ArchMode::Arm)
            .detail(true)
            .build(),
        "arm64" | "aarch64" => {
            // ARM64 architecture with proper settings for iOS/macOS
            let cs_builder = Capstone::new()
                .arm64()
                .mode(arch::arm64::ArchMode::Arm)
                .detail(true);
            
            // Enable extra details for ARM64
            cs_builder.build()
        },
        _ => {
            // Default to x86_64, but log the unsupported architecture
            eprintln!("Warning: Unsupported architecture '{}', defaulting to x86_64", architecture);
            Capstone::new()
                .x86()
                .mode(arch::x86::ArchMode::Mode64)
                .detail(true)
                .build()
        },
    };
    
    let cs = match cs {
        Ok(cs) => cs,
        Err(e) => {
            return Ok(DisassembleResponse {
                success: false,
                disassembly: None,
                instructions_count: 0,
                error: Some(format!("Failed to create disassembler: {}", e)),
            });
        }
    };

    // Disassemble the memory with fallback for unrecognized bytes
    let mut disassembly_lines = Vec::new();
    let mut offset: usize = 0;

    while offset < memory_data.len() {
        // Try to disassemble from current offset
        let slice = &memory_data[offset..];
        let current_address = address + offset as u64;

        match cs.disasm_count(slice, current_address, 1) {
            Ok(instructions) if instructions.len() > 0 => {
                // Successfully disassembled one instruction
                let insn = &instructions.as_ref()[0];
                let address_str = format!("0x{:x}", insn.address());
                let bytes = insn.bytes().iter()
                    .map(|b| format!("{:02x}", b))
                    .collect::<Vec<_>>()
                    .join(" ");
                let mnemonic = insn.mnemonic().unwrap_or("???");
                let op_str = insn.op_str().unwrap_or("");
                
                // Enhanced formatting for ARM64
                let formatted_operands = if !op_str.is_empty() {
                    match architecture.as_str() {
                        "arm64" | "aarch64" => {
                            // Format ARM64 operands more clearly
                            format_arm64_operands(op_str)
                        },
                        _ => op_str.to_string(),
                    }
                } else {
                    String::new()
                };
                
                // Format: address|bytes|mnemonic operands
                let line = format!("{}|{}|{} {}", address_str, bytes, mnemonic, formatted_operands);
                disassembly_lines.push(line);
                
                // Move offset by the instruction size
                offset += insn.bytes().len();
            }
            _ => {
                // Failed to disassemble - create a placeholder entry for undecodable bytes
                let bytes_to_show = std::cmp::min(instruction_size, memory_data.len() - offset);
                let bytes_str = memory_data[offset..offset + bytes_to_show]
                    .iter()
                    .map(|b| format!("{:02x}", b))
                    .collect::<Vec<_>>()
                    .join(" ");
                
                let address_str = format!("0x{:x}", current_address);
                // Show as "???" with .byte pseudo-instruction style, or just "???" for cleaner display
                let line = format!("{}|{}|??? ", address_str, bytes_str);
                disassembly_lines.push(line);
                
                // Move by instruction_size for fixed-width architectures, or 1 byte for variable-width
                offset += bytes_to_show;
            }
        }
    }

    if disassembly_lines.is_empty() {
        // No instructions could be parsed at all - return error
        Ok(DisassembleResponse {
            success: false,
            disassembly: None,
            instructions_count: 0,
            error: Some("No data to disassemble".to_string()),
        })
    } else {
        Ok(DisassembleResponse {
            success: true,
            disassembly: Some(disassembly_lines.join("\n")),
            instructions_count: disassembly_lines.len(),
            error: None,
        })
    }
}

#[tauri::command]
async fn disassemble_memory(request: DisassembleRequest) -> Result<DisassembleResponse, String> {
    // First, read memory from the server
    let memory_response = read_memory(request.address, request.size).await?;
    
    if !memory_response.success {
        return Ok(DisassembleResponse {
            success: false,
            disassembly: None,
            instructions_count: 0,
            error: memory_response.error,
        });
    }

    let memory_data = match memory_response.data {
        Some(data) => data,
        None => {
            return Ok(DisassembleResponse {
                success: false,
                disassembly: None,
                instructions_count: 0,
                error: Some("No memory data received".to_string()),
            });
        }
    };

    // Create capstone engine with proper architecture support
    let cs = match request.architecture.as_str() {
        "x86" => Capstone::new()
            .x86()
            .mode(arch::x86::ArchMode::Mode32)
            .detail(true)
            .build(),
        "x86_64" => Capstone::new()
            .x86()
            .mode(arch::x86::ArchMode::Mode64)
            .detail(true)
            .build(),
        "arm" => Capstone::new()
            .arm()
            .mode(arch::arm::ArchMode::Arm)
            .detail(true)
            .build(),
        "arm64" | "aarch64" => {
            // ARM64 architecture with proper settings for iOS/macOS
            let cs_builder = Capstone::new()
                .arm64()
                .mode(arch::arm64::ArchMode::Arm)
                .detail(true);
            
            // Enable extra details for ARM64
            cs_builder.build()
        },
        _ => {
            // Default to x86_64, but log the unsupported architecture
            eprintln!("Warning: Unsupported architecture '{}', defaulting to x86_64", request.architecture);
            Capstone::new()
                .x86()
                .mode(arch::x86::ArchMode::Mode64)
                .detail(true)
                .build()
        },
    };
    
    let cs = match cs
    {
        Ok(cs) => cs,
        Err(e) => {
            return Ok(DisassembleResponse {
                success: false,
                disassembly: None,
                instructions_count: 0,
                error: Some(format!("Failed to create disassembler: {}", e)),
            });
        }
    };

    // Disassemble the memory
    let instructions_result = cs.disasm_all(&memory_data, request.address);
    match instructions_result {
        Ok(instructions) => {
            let mut disassembly_lines = Vec::new();
            
            for insn in instructions.iter() {
                let address = format!("0x{:x}", insn.address());
                let bytes = insn.bytes().iter()
                    .map(|b| format!("{:02x}", b))
                    .collect::<Vec<_>>()
                    .join(" ");
                let mnemonic = insn.mnemonic().unwrap_or("???");
                let op_str = insn.op_str().unwrap_or("");
                
                // Enhanced formatting for ARM64
                let formatted_operands = if !op_str.is_empty() {
                    match request.architecture.as_str() {
                        "arm64" | "aarch64" => {
                            // Format ARM64 operands more clearly
                            format_arm64_operands(op_str)
                        },
                        _ => op_str.to_string(),
                    }
                } else {
                    String::new()
                };
                
                // Format: address|bytes|mnemonic operands
                let line = format!("{}|{}|{} {}", address, bytes, mnemonic, formatted_operands);
                disassembly_lines.push(line);
            }

            Ok(DisassembleResponse {
                success: true,
                disassembly: Some(disassembly_lines.join("\n")),
                instructions_count: disassembly_lines.len(),
                error: None,
            })
        }
        Err(e) => Ok(DisassembleResponse {
            success: false,
            disassembly: None,
            instructions_count: 0,
            error: Some(format!("Disassembly failed: {}", e)),
        })
    }
}

/// Demangle a list of symbol names (C++ and Rust)
#[tauri::command]
fn demangle_symbols(names: Vec<String>) -> Vec<String> {
    names
        .into_iter()
        .map(|name| {
            // Try C++ demangling first
            if let Ok(symbol) = CppSymbol::new(&name) {
                if let Ok(demangled) = symbol.demangle(&cpp_demangle::DemangleOptions::default()) {
                    return demangled;
                }
            }
            // Try Rust demangling
            let demangled = rustc_demangle(&name).to_string();
            if demangled != name {
                return demangled;
            }
            // Return original if no demangling possible
            name
        })
        .collect()
}

/// Get the Ghidra projects directory for storing analysis data
fn get_ghidra_projects_dir() -> PathBuf {
    let data_dir = dirs::data_local_dir()
        .unwrap_or_else(|| PathBuf::from("."))
        .join("DynaDbg")
        .join("ghidra_projects");
    data_dir
}

/// Download a library file from the server and save it locally
#[tauri::command]
async fn download_library_file(library_path: String, project_name: Option<String>) -> Result<String, String> {
    let (host, port, auth_token) = {
        let config = SERVER_CONFIG.read().map_err(|e| e.to_string())?;
        (config.host.clone(), config.port, config.auth_token.clone())
    };
    
    if host.is_empty() {
        return Err("No server connection configured".to_string());
    }

    let client = reqwest::Client::new();
    let encoded_path = urlencoding::encode(&library_path);
    let url = format!("http://{}:{}/api/utils/file?path={}", host, port, encoded_path);
    
    let mut request_builder = client.get(&url);
    if let Some(token) = auth_token {
        request_builder = request_builder.header("Authorization", format!("Bearer {}", token));
    }
    
    let response = request_builder
        .send()
        .await
        .map_err(|e| format!("Failed to fetch library: {}", e))?;
    
    if !response.status().is_success() {
        return Err(format!("Server returned error: {}", response.status()));
    }
    
    let bytes = response.bytes()
        .await
        .map_err(|e| format!("Failed to read response: {}", e))?;
    
    // Create local directory for libraries with optional project name subdirectory
    let ghidra_dir = get_ghidra_projects_dir();
    let libs_dir = if let Some(ref proj_name) = project_name {
        ghidra_dir.join("libraries").join(proj_name)
    } else {
        ghidra_dir.join("libraries")
    };
    fs::create_dir_all(&libs_dir)
        .await
        .map_err(|e| format!("Failed to create directory: {}", e))?;
    
    // Extract filename from path
    let filename = PathBuf::from(&library_path)
        .file_name()
        .map(|n| n.to_string_lossy().to_string())
        .unwrap_or_else(|| "unknown_library".to_string());
    
    let local_path = libs_dir.join(&filename);
    
    let mut file = fs::File::create(&local_path)
        .await
        .map_err(|e| format!("Failed to create file: {}", e))?;
    
    file.write_all(&bytes)
        .await
        .map_err(|e| format!("Failed to write file: {}", e))?;
    
    Ok(local_path.to_string_lossy().to_string())
}

/// Download any file from the server and save it to the user's downloads folder
#[tauri::command]
async fn download_server_file(remote_path: String) -> Result<String, String> {
    let (host, port, auth_token) = {
        let config = SERVER_CONFIG.read().map_err(|e| e.to_string())?;
        (config.host.clone(), config.port, config.auth_token.clone())
    };
    
    if host.is_empty() {
        return Err("No server connection configured".to_string());
    }

    let client = reqwest::Client::new();
    let encoded_path = urlencoding::encode(&remote_path);
    let url = format!("http://{}:{}/api/utils/file?path={}", host, port, encoded_path);
    
    let mut request_builder = client.get(&url);
    if let Some(token) = auth_token {
        request_builder = request_builder.header("Authorization", format!("Bearer {}", token));
    }
    
    let response = request_builder
        .send()
        .await
        .map_err(|e| format!("Failed to fetch file: {}", e))?;
    
    if !response.status().is_success() {
        return Err(format!("Server returned error: {}", response.status()));
    }
    
    let bytes = response.bytes()
        .await
        .map_err(|e| format!("Failed to read response: {}", e))?;
    
    // Create downloads directory in app data
    let downloads_dir = dirs::download_dir()
        .ok_or_else(|| "Could not find downloads directory".to_string())?
        .join("DynaDbg");
    
    fs::create_dir_all(&downloads_dir)
        .await
        .map_err(|e| format!("Failed to create directory: {}", e))?;
    
    // Extract filename from path
    let filename = PathBuf::from(&remote_path)
        .file_name()
        .map(|n| n.to_string_lossy().to_string())
        .unwrap_or_else(|| "downloaded_file".to_string());
    
    let local_path = downloads_dir.join(&filename);
    
    // Handle duplicate filenames
    let final_path = if local_path.exists() {
        let stem = local_path.file_stem()
            .map(|s| s.to_string_lossy().to_string())
            .unwrap_or_else(|| "file".to_string());
        let ext = local_path.extension()
            .map(|s| format!(".{}", s.to_string_lossy()))
            .unwrap_or_default();
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .map(|d| d.as_secs())
            .unwrap_or(0);
        downloads_dir.join(format!("{}_{}{}", stem, timestamp, ext))
    } else {
        local_path
    };
    
    let mut file = fs::File::create(&final_path)
        .await
        .map_err(|e| format!("Failed to create file: {}", e))?;
    
    file.write_all(&bytes)
        .await
        .map_err(|e| format!("Failed to write file: {}", e))?;
    
    Ok(final_path.to_string_lossy().to_string())
}

/// Upload a file from host to server
#[tauri::command]
async fn upload_file_to_server(local_path: String, remote_path: String) -> Result<String, String> {
    let (host, port) = {
        let config = SERVER_CONFIG.read().map_err(|e| e.to_string())?;
        (config.host.clone(), config.port)
    };
    
    if host.is_empty() {
        return Err("No server connection configured".to_string());
    }

    // Read local file
    let file_contents = fs::read(&local_path)
        .await
        .map_err(|e| format!("Failed to read local file: {}", e))?;

    let auth_token = {
        let config = SERVER_CONFIG.read().map_err(|e| e.to_string())?;
        config.auth_token.clone()
    };

    let client = reqwest::Client::new();
    let encoded_path = urlencoding::encode(&remote_path);
    let url = format!("http://{}:{}/api/utils/file?path={}", host, port, encoded_path);
    
    let mut request_builder = client.post(&url)
        .body(file_contents);
    
    if let Some(token) = auth_token {
        request_builder = request_builder.header("Authorization", format!("Bearer {}", token));
    }
    
    let response = request_builder
        .send()
        .await
        .map_err(|e| format!("Failed to upload file: {}", e))?;
    
    if !response.status().is_success() {
        let error_text = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());
        return Err(format!("Server returned error: {}", error_text));
    }
    
    Ok(remote_path)
}

/// Analyze a library file with Ghidra headless
#[tauri::command]
async fn analyze_with_ghidra(
    local_library_path: String,
    ghidra_path: String,
    project_name: Option<String>,
) -> Result<GhidraAnalysisStatus, String> {
    let library_path = PathBuf::from(&local_library_path);
    if !library_path.exists() {
        return Ok(GhidraAnalysisStatus {
            library_path: local_library_path,
            analyzed: false,
            project_path: None,
            error: Some("Library file not found".to_string()),
        });
    }
    
    let library_name = library_path
        .file_stem()
        .map(|s| s.to_string_lossy().to_string())
        .unwrap_or_else(|| "unknown".to_string());
    
    // Create project directory with optional project name subdirectory
    let ghidra_dir = get_ghidra_projects_dir();
    let project_dir = if let Some(ref proj_name) = project_name {
        ghidra_dir.join(proj_name).join(&library_name)
    } else {
        ghidra_dir.join(&library_name)
    };
    fs::create_dir_all(&project_dir)
        .await
        .map_err(|e| format!("Failed to create project directory: {}", e))?;
    
    // Build headless analyzer path
    let ghidra_base = PathBuf::from(&ghidra_path);
    let analyzer_path = if cfg!(windows) {
        ghidra_base.join("support").join("analyzeHeadless.bat")
    } else {
        ghidra_base.join("support").join("analyzeHeadless")
    };
    
    if !analyzer_path.exists() {
        return Ok(GhidraAnalysisStatus {
            library_path: local_library_path,
            analyzed: false,
            project_path: None,
            error: Some(format!("Ghidra analyzeHeadless not found at: {}", analyzer_path.display())),
        });
    }
    
    // Run Ghidra headless analysis
    let output = hide_console_window(&mut Command::new(&analyzer_path))
        .arg(project_dir.to_string_lossy().to_string())
        .arg(&library_name)
        .arg("-import")
        .arg(&local_library_path)
        .arg("-overwrite")
        .arg("-analysisTimeoutPerFile")
        .arg("300")  // 5 minutes timeout
        .output()
        .map_err(|e| format!("Failed to run Ghidra: {}", e))?;
    
    let stdout = String::from_utf8_lossy(&output.stdout);
    let stderr = String::from_utf8_lossy(&output.stderr);
    
    if !output.status.success() {
        return Ok(GhidraAnalysisStatus {
            library_path: local_library_path,
            analyzed: false,
            project_path: Some(project_dir.to_string_lossy().to_string()),
            error: Some(format!("Ghidra analysis failed: {}\n{}", stdout, stderr)),
        });
    }
    
    Ok(GhidraAnalysisStatus {
        library_path: local_library_path,
        analyzed: true,
        project_path: Some(project_dir.to_string_lossy().to_string()),
        error: None,
    })
}

/// Decompile a function using Ghidra
#[tauri::command]
async fn ghidra_decompile(
    project_path: String,
    library_name: String,
    function_address: String,
    ghidra_path: String,
) -> Result<GhidraDecompileResult, String> {
    let ghidra_base = PathBuf::from(&ghidra_path);
    let analyzer_path = if cfg!(windows) {
        ghidra_base.join("support").join("analyzeHeadless.bat")
    } else {
        ghidra_base.join("support").join("analyzeHeadless")
    };
    
    if !analyzer_path.exists() {
        return Ok(GhidraDecompileResult {
            success: false,
            function_name: None,
            address: Some(function_address.clone()),
            decompiled_code: None,
            error: Some("Ghidra analyzeHeadless not found".to_string()),
            line_mapping: None,
            tokens: None,
        });
    }
    
    // Create a temporary script to decompile the function
    let ghidra_dir = get_ghidra_projects_dir();
    let script_path = ghidra_dir.join("decompile_function.py");
    let output_path = ghidra_dir.join("decompile_output.txt");
    
    // Ghidra Python script for decompilation with line-to-address mapping
    // The function_address is an offset from module base. We need to add Ghidra's image base.
    let script_content = format!(r#"#@runtime Jython
# @category DynaDbg
# @description Decompile function at offset with line-to-address mapping

from ghidra.app.decompiler import DecompInterface
from ghidra.util.task import ConsoleTaskMonitor
from java.util import ArrayList

def get_line_address_mapping(clang_tokens, image_base):
    """Extract address mapping for each line from Clang tokens using flatten()"""
    line_addresses = {{}}
    
    try:
        # Use flatten() to get all tokens as a flat list
        token_list = ArrayList()
        clang_tokens.flatten(token_list)
        
        for token in token_list:
            try:
                min_addr = token.getMinAddress()
                if min_addr is not None:
                    line_parent = token.getLineParent()
                    if line_parent is not None:
                        # ClangLine has getLineNumber() method
                        line_number = line_parent.getLineNumber()
                        if line_number is not None and line_number > 0:
                            offset = min_addr.getOffset() - image_base.getOffset()
                            if line_number not in line_addresses or offset < line_addresses[line_number]:
                                line_addresses[line_number] = offset
            except Exception as e:
                continue
    except Exception as e:
        print("DEBUG: Error in get_line_address_mapping: " + str(e))
    
    return line_addresses

def decompile_at_offset(offset_str):
    decompiler = DecompInterface()
    decompiler.openProgram(currentProgram)
    
    # Get Ghidra's image base address
    image_base = currentProgram.getImageBase()
    print("DEBUG: Image base = " + str(image_base))
    
    # Parse offset
    offset_str = offset_str.strip()
    if offset_str.startswith("0x"):
        offset_str = offset_str[2:]
    
    try:
        offset = int(offset_str, 16)
    except:
        return "Error: Invalid offset format: " + offset_str
    
    # Calculate actual address = image_base + offset
    addr = image_base.add(offset)
    print("DEBUG: Offset = 0x" + format(offset, 'x'))
    print("DEBUG: Calculated address = " + str(addr))
    
    if addr is None:
        return "Error: Could not calculate address"
    
    func = getFunctionContaining(addr)
    if func is None:
        # Try to get function exactly at address
        func = getFunctionAt(addr)
    
    if func is None:
        return "Error: No function found at address " + str(addr) + " (offset 0x" + format(offset, 'x') + ")"
    
    print("DEBUG: Found function: " + func.getName())
    
    monitor = ConsoleTaskMonitor()
    results = decompiler.decompileFunction(func, 60, monitor)
    
    if results and results.decompileCompleted():
        decomp = results.getDecompiledFunction()
        if decomp:
            code = decomp.getC()
            
            # Get line-to-address mapping from ClangTokenGroup
            clang_tokens = results.getCCodeMarkup()
            line_mapping = {{}}
            if clang_tokens:
                line_mapping = get_line_address_mapping(clang_tokens, image_base)
            
            # Format line mapping as JSON-like string
            mapping_str = ";".join(["{{}}:0x{{:x}}".format(ln, addr) for ln, addr in sorted(line_mapping.items())])
            
            return "FUNCTION_NAME:" + func.getName() + "\nLINE_MAPPING:" + mapping_str + "\n" + code
    
    return "Error: Decompilation failed"

# Get offset from script arguments
offset = "{}"
result = decompile_at_offset(offset)

# Write output to file
with open(r"{}", "w") as f:
    f.write(result)
"#, function_address, output_path.to_string_lossy().replace("\\", "\\\\"));
    
    fs::write(&script_path, &script_content)
        .await
        .map_err(|e| format!("Failed to write decompile script: {}", e))?;
    
    // Clean library name (without extension)
    // Ghidra stores imported programs with file_stem (no extension) as the program name
    let clean_lib_name = PathBuf::from(&library_name)
        .file_stem()
        .map(|s| s.to_string_lossy().to_string())
        .unwrap_or(library_name.clone());
    
    // Run Ghidra with the decompile script
    // Use clean_lib_name (without extension) for -process option
    // Ghidra stores imported programs without file extensions
    let output = hide_console_window(&mut Command::new(&analyzer_path))
        .arg(&project_path)
        .arg(&clean_lib_name)
        .arg("-process")
        .arg(&clean_lib_name)
        .arg("-noanalysis")
        .arg("-postScript")
        .arg(script_path.to_string_lossy().to_string())
        .output()
        .map_err(|e| format!("Failed to run Ghidra: {}", e))?;
    
    // Log Ghidra output for debugging
    let stdout = String::from_utf8_lossy(&output.stdout);
    let stderr = String::from_utf8_lossy(&output.stderr);
    println!("[GHIDRA] stdout: {}", stdout);
    println!("[GHIDRA] stderr: {}", stderr);
    println!("[GHIDRA] exit status: {:?}", output.status);

    if !output.status.success() {
        return Ok(GhidraDecompileResult {
            success: false,
            function_name: None,
            address: Some(function_address),
            decompiled_code: None,
            line_mapping: None,
            tokens: None,
            error: Some(format!("Ghidra process failed (exit code {:?}): \nStdout: {}\nStderr: {}", output.status.code(), stdout, stderr)),
        });
    }
    
    // Read the output file
    let decompiled = match fs::read_to_string(&output_path).await {
        Ok(content) => content,
        Err(e) => {
            // If we couldn't read the file, include Ghidra's output in error
            let error_msg = format!(
                "Error: Could not read decompilation output ({}). \nStdout: {}\nStderr: {}",
                e,
                stdout.chars().take(1000).collect::<String>(),
                stderr.chars().take(1000).collect::<String>()
            );
            return Ok(GhidraDecompileResult {
                success: false,
                function_name: None,
                address: Some(function_address),
                decompiled_code: None,
                line_mapping: None,
                tokens: None,
                error: Some(error_msg),
            });
        }
    };
    
    // Clean up
    let _ = fs::remove_file(&script_path).await;
    let _ = fs::remove_file(&output_path).await;
    
    // Parse result
    if decompiled.starts_with("Error:") {
        return Ok(GhidraDecompileResult {
            success: false,
            function_name: None,
            address: Some(function_address),
            decompiled_code: None,
            line_mapping: None,
            tokens: None,
            error: Some(decompiled),
        });
    }
    
    // Extract function name and line mapping from result
    let mut function_name = String::new();
    let mut line_mapping: std::collections::HashMap<String, String> = std::collections::HashMap::new();
    let mut code_lines: Vec<&str> = Vec::new();
    let mut in_code = false;
    
    for line in decompiled.lines() {
        if line.starts_with("FUNCTION_NAME:") {
            function_name = line.replace("FUNCTION_NAME:", "");
        } else if line.starts_with("LINE_MAPPING:") {
            // Parse line mapping: "1:0x100;2:0x104;3:0x108"
            let mapping_str = line.replace("LINE_MAPPING:", "");
            for pair in mapping_str.split(';') {
                if let Some((line_num_str, addr_str)) = pair.split_once(':') {
                    line_mapping.insert(line_num_str.to_string(), addr_str.to_string());
                }
            }
            in_code = true; // Code starts after LINE_MAPPING
        } else if in_code || (!line.starts_with("FUNCTION_NAME:") && !line.starts_with("LINE_MAPPING:")) {
            in_code = true;
            code_lines.push(line);
        }
    }
    
    let code = code_lines.join("\n");
    
    if !output.status.success() && code.is_empty() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Ok(GhidraDecompileResult {
            success: false,
            function_name: if function_name.is_empty() { None } else { Some(function_name) },
            address: Some(function_address),
            decompiled_code: None,
            line_mapping: None,
            tokens: None,
            error: Some(format!("Ghidra decompilation process failed: {}", stderr)),
        });
    }
    
    // NOTE: Do NOT format the code with clang-format because it changes line numbers
    // and breaks the line-to-address mapping from Ghidra.
    // If you want to enable formatting, you would need to also remap line numbers.
    // let formatted_code = format_cpp_code(&code).await.unwrap_or(code);
    let formatted_code = code;
    
    Ok(GhidraDecompileResult {
        success: true,
        function_name: if function_name.is_empty() { None } else { Some(function_name) },
        address: Some(function_address),
        decompiled_code: Some(formatted_code),
        line_mapping: if line_mapping.is_empty() { None } else { Some(line_mapping) },
        tokens: None,
        error: None,
    })
}

// ============================================================================
// Ghidra Server Mode - HTTP server running inside Ghidra for fast operations
// ============================================================================

/// Generate the Ghidra HTTP server script
fn generate_ghidra_server_script(port: u16) -> String {
    format!(r#"#@runtime Jython
# @category DynaDbg
# @description HTTP Server for fast Ghidra operations

from ghidra.app.decompiler import DecompInterface, DecompileOptions
from ghidra.program.model.block import BasicBlockModel
from ghidra.program.model.symbol import RefType
from ghidra.util.task import ConsoleTaskMonitor
from java.util import ArrayList
import BaseHTTPServer
import urlparse
import json
import threading
import codecs

# Global decompiler instance (reused)
decompiler = None

def init_decompiler():
    global decompiler
    if decompiler is None:
        decompiler = DecompInterface()
        # Set decompiler options to prevent line wrapping
        opts = DecompileOptions()
        opts.setMaxWidth(300)  # Increase max line width to prevent mid-line breaks
        decompiler.setOptions(opts)
        decompiler.openProgram(currentProgram)
    return decompiler

def get_line_address_mapping(clang_tokens, image_base):
    line_addresses = {{}}
    try:
        token_list = ArrayList()
        clang_tokens.flatten(token_list)
        for token in token_list:
            try:
                min_addr = token.getMinAddress()
                if min_addr is not None:
                    line_parent = token.getLineParent()
                    if line_parent is not None:
                        line_number = line_parent.getLineNumber()
                        if line_number is not None and line_number > 0:
                            offset = min_addr.getOffset() - image_base.getOffset()
                            if line_number not in line_addresses or offset < line_addresses[line_number]:
                                line_addresses[line_number] = offset
            except:
                continue
    except:
        pass
    return line_addresses

def get_token_info(clang_tokens, image_base, high_func):
    """Extract detailed token information from decompiled code"""
    from ghidra.app.decompiler import ClangFuncNameToken, ClangVariableToken, ClangTypeToken, ClangFieldToken
    
    tokens_info = []
    try:
        token_list = ArrayList()
        clang_tokens.flatten(token_list)
        
        for token in token_list:
            try:
                token_text = token.toString()
                if not token_text or len(token_text.strip()) == 0:
                    continue
                
                line_parent = token.getLineParent()
                if line_parent is None:
                    continue
                    
                line_number = line_parent.getLineNumber()
                if line_number is None or line_number <= 0:
                    continue
                
                # Get column position (character offset within the line)
                col_start = 0
                col_end = 0
                try:
                    # Calculate column by finding token position in line
                    line_text = ""
                    siblings = []
                    for i in range(line_parent.numChildren()):
                        child = line_parent.Child(i)
                        if child:
                            siblings.append(child)
                    
                    char_pos = 0
                    for sibling in siblings:
                        sib_text = sibling.toString() if sibling else ""
                        if sibling == token:
                            col_start = char_pos
                            col_end = char_pos + len(token_text)
                            break
                        char_pos += len(sib_text)
                except:
                    pass
                
                token_info = {{
                    "text": token_text,
                    "line": line_number,
                    "col_start": col_start,
                    "col_end": col_end,
                    "token_type": "unknown"
                }}
                
                # Determine token type
                if isinstance(token, ClangFuncNameToken):
                    token_info["token_type"] = "function"
                    # Get function address if available
                    try:
                        pcode_op = token.getPcodeOp()
                        if pcode_op:
                            called_addr = pcode_op.getInput(0)
                            if called_addr:
                                addr = called_addr.getAddress()
                                if addr:
                                    called_func = getFunctionAt(addr)
                                    if called_func:
                                        func_offset = addr.getOffset() - image_base.getOffset()
                                        if func_offset >= 0:
                                            token_info["target_offset"] = "0x{{:x}}".format(func_offset)
                                            token_info["target_name"] = called_func.getName()
                    except:
                        pass
                        
                elif isinstance(token, ClangVariableToken):
                    token_info["token_type"] = "variable"
                    try:
                        high_var = token.getHighVariable()
                        if high_var:
                            token_info["var_name"] = high_var.getName()
                            dt = high_var.getDataType()
                            if dt:
                                token_info["data_type"] = dt.getName()
                            sym = high_var.getSymbol()
                            if sym:
                                token_info["is_parameter"] = sym.isParameter()
                    except:
                        pass
                        
                elif isinstance(token, ClangTypeToken):
                    token_info["token_type"] = "type"
                    
                elif isinstance(token, ClangFieldToken):
                    token_info["token_type"] = "field"
                
                # Only add meaningful tokens
                if token_info["token_type"] != "unknown" or token_text.startswith("FUN_") or token_text.startswith("DAT_"):
                    if token_text.startswith("FUN_"):
                        token_info["token_type"] = "function"
                    elif token_text.startswith("DAT_"):
                        token_info["token_type"] = "data"
                    tokens_info.append(token_info)
                    
            except:
                continue
    except:
        pass
    
    return tokens_info

def decompile_function(offset_str):
    dec = init_decompiler()
    image_base = currentProgram.getImageBase()
    
    offset_str = offset_str.strip()
    if offset_str.startswith("0x"):
        offset_str = offset_str[2:]
    
    try:
        offset = int(offset_str, 16)
    except:
        return {{"success": False, "error": "Invalid offset format"}}
    
    addr = image_base.add(offset)
    func = getFunctionContaining(addr)
    if func is None:
        func = getFunctionAt(addr)
    
    if func is None:
        return {{"success": False, "error": "No function found at offset 0x" + format(offset, 'x')}}
    
    monitor = ConsoleTaskMonitor()
    results = dec.decompileFunction(func, 60, monitor)
    
    if results and results.decompileCompleted():
        decomp = results.getDecompiledFunction()
        high_func = results.getHighFunction()
        if decomp:
            code = decomp.getC()
            clang_tokens = results.getCCodeMarkup()
            line_mapping = {{}}
            tokens_info = []
            if clang_tokens:
                line_mapping = get_line_address_mapping(clang_tokens, image_base)
                tokens_info = get_token_info(clang_tokens, image_base, high_func)
            
            return {{
                "success": True,
                "function_name": func.getName(),
                "address": "0x" + format(offset, 'x'),
                "decompiled_code": code,
                "line_mapping": dict((str(k), "0x{{:x}}".format(v)) for k, v in line_mapping.items()),
                "tokens": tokens_info,
                "error": None
            }}
    
    return {{"success": False, "error": "Decompilation failed"}}

def get_data_items():
    """Get all defined data items (strings, variables, constants) from the program"""
    image_base = currentProgram.getImageBase()
    listing = currentProgram.getListing()
    data_type_mgr = currentProgram.getDataTypeManager()
    
    data_items = []
    max_items = 5000  # Limit to prevent overload
    
    # Iterate through all defined data in the program
    data_iter = listing.getDefinedData(True)
    count = 0
    
    while data_iter.hasNext() and count < max_items:
        data = data_iter.next()
        try:
            addr = data.getAddress()
            data_offset = addr.getOffset() - image_base.getOffset()
            
            # Skip negative offsets (external references)
            if data_offset < 0:
                continue
            
            data_type = data.getDataType()
            type_name = data_type.getName() if data_type else "undefined"
            size = data.getLength()
            
            # Get the data value as string representation
            value_str = None
            try:
                value = data.getValue()
                if value is not None:
                    if isinstance(value, str):
                        # Truncate long strings
                        value_str = value[:100] + "..." if len(value) > 100 else value
                    else:
                        value_str = str(value)[:100]
            except:
                pass
            
            # Get label/name if exists
            symbol = data.getPrimarySymbol()
            name = symbol.getName() if symbol else None
            
            # Categorize the data type
            category = "other"
            type_lower = type_name.lower()
            if "string" in type_lower or "char" in type_lower and data.hasStringValue():
                category = "string"
            elif "pointer" in type_lower or "ptr" in type_lower:
                category = "pointer"
            elif type_lower in ["byte", "word", "dword", "qword", "int", "uint", "long", "ulong", "short", "ushort"]:
                category = "integer"
            elif "float" in type_lower or "double" in type_lower:
                category = "float"
            elif "struct" in type_lower or data_type.toString().startswith("struct"):
                category = "struct"
            elif "array" in type_lower or "[" in type_name:
                category = "array"
            
            data_items.append({{
                "address": "0x{{:x}}".format(data_offset),
                "name": name,
                "type": type_name,
                "category": category,
                "size": size,
                "value": value_str
            }})
            count += 1
        except:
            continue
    
    return {{
        "success": True,
        "data": data_items,
        "total": count,
        "truncated": count >= max_items,
        "error": None
    }}

def get_xrefs(offset_str):
    image_base = currentProgram.getImageBase()
    listing = currentProgram.getListing()
    
    offset_str = offset_str.strip()
    if offset_str.startswith("0x"):
        offset_str = offset_str[2:]
    
    try:
        offset = int(offset_str, 16)
    except:
        return {{"success": False, "error": "Invalid offset format"}}
    
    addr = image_base.add(offset)
    func = getFunctionContaining(addr)
    if func is None:
        func = getFunctionAt(addr)
    
    if func is None:
        return {{"success": False, "error": "No function found at offset"}}
    
    xrefs = []
    refs = getReferencesTo(func.getEntryPoint())
    for ref in refs:
        from_addr = ref.getFromAddress()
        from_offset = from_addr.getOffset() - image_base.getOffset()
        if from_offset < 0:
            continue
        from_func = getFunctionContaining(from_addr)
        # Get the instruction at the reference address
        instruction = listing.getInstructionAt(from_addr)
        instr_str = None
        if instruction:
            instr_str = instruction.toString()
        # Calculate offset within the function (from_addr - function_entry)
        func_offset = None
        if from_func:
            func_entry_offset = from_func.getEntryPoint().getOffset() - image_base.getOffset()
            func_offset = from_offset - func_entry_offset
        xrefs.append({{
            "from_address": "0x{{:x}}".format(from_offset),
            "from_function": from_func.getName() if from_func else None,
            "from_function_offset": "0x{{:x}}".format(func_offset) if func_offset is not None else None,
            "ref_type": ref.getReferenceType().getName(),
            "instruction": instr_str
        }})
    
    return {{
        "success": True,
        "target_function": func.getName(),
        "target_address": "0x{{:x}}".format(offset),
        "xrefs": xrefs,
        "error": None
    }}

def get_function_info(offset_str):
    """Get detailed function info including variables and called functions"""
    dec = init_decompiler()
    image_base = currentProgram.getImageBase()
    listing = currentProgram.getListing()
    
    offset_str = offset_str.strip()
    if offset_str.startswith("0x"):
        offset_str = offset_str[2:]
    
    try:
        offset = int(offset_str, 16)
    except:
        return {{"success": False, "error": "Invalid offset format", "variables": [], "called_functions": []}}
    
    addr = image_base.add(offset)
    func = getFunctionContaining(addr)
    if func is None:
        func = getFunctionAt(addr)
    
    if func is None:
        return {{"success": False, "error": "No function found at offset", "variables": [], "called_functions": []}}
    
    monitor = ConsoleTaskMonitor()
    results = dec.decompileFunction(func, 60, monitor)
    
    variables = []
    called_functions = []
    
    if results and results.decompileCompleted():
        high_func = results.getHighFunction()
        if high_func:
            # Get local variables from high function
            local_sym = high_func.getLocalSymbolMap()
            if local_sym:
                for sym in local_sym.getSymbols():
                    var_info = {{
                        "name": sym.getName(),
                        "data_type": str(sym.getDataType()) if sym.getDataType() else "unknown",
                        "storage": str(sym.getStorage()) if sym.getStorage() else "unknown",
                        "is_parameter": sym.isParameter(),
                        "size": sym.getSize()
                    }}
                    variables.append(var_info)
    
    # Get called functions by scanning references from the function body
    func_body = func.getBody()
    ref_mgr = currentProgram.getReferenceManager()
    seen_funcs = set()
    
    addr_iter = func_body.getAddresses(True)
    while addr_iter.hasNext():
        from_addr = addr_iter.next()
        refs = ref_mgr.getReferencesFrom(from_addr)
        for ref in refs:
            if ref.getReferenceType().isCall():
                to_addr = ref.getToAddress()
                to_func = getFunctionAt(to_addr)
                if to_func and to_func.getName() not in seen_funcs:
                    seen_funcs.add(to_func.getName())
                    to_offset = to_func.getEntryPoint().getOffset() - image_base.getOffset()
                    if to_offset >= 0:
                        called_functions.append({{
                            "name": to_func.getName(),
                            "offset": "0x{{:x}}".format(to_offset)
                        }})
    
    func_offset = func.getEntryPoint().getOffset() - image_base.getOffset()
    
    return {{
        "success": True,
        "function_name": func.getName(),
        "function_offset": "0x{{:x}}".format(func_offset),
        "variables": variables,
        "called_functions": called_functions,
        "error": None
    }}

def get_cfg(offset_str):
    """Get Control Flow Graph (CFG) for a function using Ghidra's BasicBlockModel"""
    image_base = currentProgram.getImageBase()
    listing = currentProgram.getListing()
    monitor = ConsoleTaskMonitor()
    
    offset_str = offset_str.strip()
    if offset_str.startswith("0x"):
        offset_str = offset_str[2:]
    
    try:
        offset = int(offset_str, 16)
    except:
        return {{"success": False, "error": "Invalid offset format", "blocks": [], "edges": []}}
    
    addr = image_base.add(offset)
    func = getFunctionContaining(addr)
    if func is None:
        func = getFunctionAt(addr)
    
    if func is None:
        return {{"success": False, "error": "No function found at offset", "blocks": [], "edges": []}}
    
    # Use BasicBlockModel for CFG analysis
    block_model = BasicBlockModel(currentProgram)
    func_body = func.getBody()
    
    blocks = []
    edges = []
    block_id_map = {{}}  # address -> block_id
    
    # Get all basic blocks in the function
    block_iterator = block_model.getCodeBlocksContaining(func_body, monitor)
    block_index = 0
    
    while block_iterator.hasNext():
        block = block_iterator.next()
        block_start = block.getFirstStartAddress()
        block_end_range = block.getMaxAddress()
        
        # Calculate offsets
        start_offset = block_start.getOffset() - image_base.getOffset()
        end_offset = block_end_range.getOffset() - image_base.getOffset()
        
        # Get instructions in this block
        instructions = []
        addr_set = block.getAddresses(True)
        while addr_set.hasNext():
            instr_addr = addr_set.next()
            instruction = listing.getInstructionAt(instr_addr)
            if instruction:
                instr_offset = instr_addr.getOffset() - image_base.getOffset()
                # Get instruction bytes as hex string
                instr_bytes = instruction.getBytes()
                bytes_hex = "".join("{:02x}".format(b & 0xff) for b in instr_bytes)
                
                instructions.append({{
                    "address": "0x{{:x}}".format(instr_offset),
                    "bytes": bytes_hex,
                    "opcode": instruction.getMnemonicString(),
                    "operands": ", ".join(str(op) for op in instruction.getOpObjects(0) + instruction.getOpObjects(1) if op is not None) or str(instruction.getDefaultOperandRepresentation(0) or "")
                }})
        
        # Sort instructions by address
        instructions.sort(key=lambda x: int(x["address"], 16))
        
        block_id = "block_0x{{:x}}".format(start_offset)
        block_id_map[block_start] = block_id
        
        # Determine if this is entry/exit block
        is_entry = (block_start == func.getEntryPoint())
        
        # Check if this block ends with a return instruction
        is_exit = False
        if instructions:
            last_opcode = instructions[-1]["opcode"].lower()
            if last_opcode in ["ret", "retn", "retf"]:
                is_exit = True
        
        blocks.append({{
            "id": block_id,
            "startAddress": "0x{{:x}}".format(start_offset),
            "endAddress": "0x{{:x}}".format(end_offset),
            "instructions": instructions,
            "successors": [],
            "predecessors": [],
            "isEntry": is_entry,
            "isExit": is_exit
        }})
        block_index += 1
    
    # Build edges using block destinations
    block_iterator = block_model.getCodeBlocksContaining(func_body, monitor)
    
    while block_iterator.hasNext():
        block = block_iterator.next()
        block_start = block.getFirstStartAddress()
        from_block_id = block_id_map.get(block_start)
        
        if from_block_id is None:
            continue
        
        # Get successors
        dest_iter = block.getDestinations(monitor)
        while dest_iter.hasNext():
            dest_ref = dest_iter.next()
            dest_addr = dest_ref.getDestinationAddress()
            dest_block = dest_ref.getDestinationBlock()
            
            if dest_block is None:
                continue
                
            dest_block_start = dest_block.getFirstStartAddress()
            to_block_id = block_id_map.get(dest_block_start)
            
            if to_block_id is None:
                continue
            
            # Determine edge type based on flow type
            flow_type = dest_ref.getFlowType()
            if flow_type.isConditional():
                # Check if this is the fall-through or jump target
                block_max = block.getMaxAddress()
                next_addr = block_max.add(1)
                if dest_addr == next_addr or dest_block_start == next_addr:
                    edge_type = "conditional-false"
                else:
                    edge_type = "conditional-true"
            elif flow_type.isUnConditional():
                edge_type = "unconditional"
            else:
                edge_type = "normal"
            
            edges.append({{
                "from": from_block_id,
                "to": to_block_id,
                "type": edge_type
            }})
            
            # Update successors/predecessors in blocks
            for b in blocks:
                if b["id"] == from_block_id and to_block_id not in b["successors"]:
                    b["successors"].append(to_block_id)
                if b["id"] == to_block_id and from_block_id not in b["predecessors"]:
                    b["predecessors"].append(from_block_id)
    
    # Mark blocks with no successors as exit blocks
    for b in blocks:
        if not b["successors"]:
            b["isExit"] = True
    
    func_offset_val = func.getEntryPoint().getOffset() - image_base.getOffset()
    
    return {{
        "success": True,
        "function_name": func.getName(),
        "function_offset": "0x{{:x}}".format(func_offset_val),
        "blocks": blocks,
        "edges": edges,
        "error": None
    }}

def analyze_reachability(func_offset_str, current_block_str, registers_json):
    """Analyze block reachability from current block with given register values"""
    image_base = currentProgram.getImageBase()
    listing = currentProgram.getListing()
    monitor = ConsoleTaskMonitor()
    
    # Parse function offset
    func_offset_str = func_offset_str.strip()
    if func_offset_str.startswith("0x"):
        func_offset_str = func_offset_str[2:]
    
    try:
        func_offset = int(func_offset_str, 16)
    except:
        return {{"success": False, "error": "Invalid function offset format", "blocks": []}}
    
    # Parse current block offset  
    current_block_str = current_block_str.strip()
    if current_block_str.startswith("0x"):
        current_block_str = current_block_str[2:]
    
    try:
        current_block_offset = int(current_block_str, 16)
    except:
        return {{"success": False, "error": "Invalid current block offset format", "blocks": []}}
    
    # Parse register values
    registers = {{}}
    if registers_json:
        try:
            registers = json.loads(registers_json)
        except:
            pass
    
    # Get function
    func_addr = image_base.add(func_offset)
    func = getFunctionContaining(func_addr)
    if func is None:
        func = getFunctionAt(func_addr)
    
    if func is None:
        return {{"success": False, "error": "No function found at offset", "blocks": []}}
    
    # Build CFG
    block_model = BasicBlockModel(currentProgram)
    func_body = func.getBody()
    
    # Collect all blocks
    block_map = {{}}  # address -> block
    block_info = {{}}  # address -> info dict
    
    block_iterator = block_model.getCodeBlocksContaining(func_body, monitor)
    while block_iterator.hasNext():
        block = block_iterator.next()
        block_start = block.getFirstStartAddress()
        start_offset = block_start.getOffset() - image_base.getOffset()
        end_offset = block.getMaxAddress().getOffset() - image_base.getOffset()
        
        block_id = "block_0x{{:x}}".format(start_offset)
        block_map[block_start] = block
        block_info[block_start] = {{
            "blockId": block_id,
            "startAddress": "0x{{:x}}".format(start_offset),
            "endAddress": "0x{{:x}}".format(end_offset),
            "status": "unknown",
            "condition": ""
        }}
    
    # Find current block
    current_addr = image_base.add(current_block_offset)
    current_block = None
    current_block_start = None
    
    for block_start, block in block_map.items():
        if block.contains(current_addr):
            current_block = block
            current_block_start = block_start
            break
    
    if current_block is None:
        # Try exact match
        if current_addr in block_map:
            current_block = block_map[current_addr]
            current_block_start = current_addr
    
    if current_block is None:
        return {{"success": False, "error": "Current block not found", "blocks": []}}
    
    # Mark current block
    block_info[current_block_start]["status"] = "current"
    
    # BFS to find reachable blocks
    from java.util import LinkedList, HashSet
    
    queue = LinkedList()
    visited = HashSet()
    queue.add(current_block_start)
    visited.add(current_block_start)
    
    while not queue.isEmpty():
        block_addr = queue.poll()
        block = block_map.get(block_addr)
        
        if block is None:
            continue
        
        # Get last instruction to determine branch type
        block_max = block.getMaxAddress()
        last_instr = listing.getInstructionAt(block_max)
        
        # Get successors
        dest_iter = block.getDestinations(monitor)
        successors = []
        
        while dest_iter.hasNext():
            dest_ref = dest_iter.next()
            dest_block = dest_ref.getDestinationBlock()
            
            if dest_block is None:
                continue
                
            dest_start = dest_block.getFirstStartAddress()
            if dest_start not in block_map:
                continue
                
            flow_type = dest_ref.getFlowType()
            successors.append((dest_start, flow_type, dest_ref.getDestinationAddress()))
        
        # Analyze reachability based on branch condition and registers
        is_conditional = last_instr is not None and any(ft.isConditional() for _, ft, _ in successors)
        
        if is_conditional and last_instr is not None:
            mnemonic = last_instr.getMnemonicString().lower()
            
            # Try to evaluate condition based on register values
            condition_result = evaluate_branch_condition(mnemonic, last_instr, registers)
            
            for dest_start, flow_type, dest_addr in successors:
                if visited.contains(dest_start):
                    continue
                
                info = block_info[dest_start]
                
                if condition_result is None:
                    # Can't determine - mark as conditional
                    info["status"] = "conditional"
                    info["condition"] = mnemonic
                    visited.add(dest_start)
                    queue.add(dest_start)
                elif condition_result == True:
                    # Branch taken
                    if flow_type.isConditional():
                        # Check if this is the taken path
                        block_max_next = block_max.add(1)
                        if dest_addr == block_max_next or dest_start == block_max_next:
                            # Fall-through - not taken
                            info["status"] = "unreachable"
                            info["condition"] = "branch taken, fall-through skipped"
                        else:
                            # Jump target - taken
                            info["status"] = "reachable"
                            info["condition"] = mnemonic + " taken"
                            visited.add(dest_start)
                            queue.add(dest_start)
                    else:
                        info["status"] = "reachable"
                        visited.add(dest_start)
                        queue.add(dest_start)
                else:
                    # Branch not taken
                    if flow_type.isConditional():
                        block_max_next = block_max.add(1)
                        if dest_addr == block_max_next or dest_start == block_max_next:
                            # Fall-through - taken
                            info["status"] = "reachable"
                            info["condition"] = mnemonic + " not taken"
                            visited.add(dest_start)
                            queue.add(dest_start)
                        else:
                            # Jump target - not taken
                            info["status"] = "unreachable"
                            info["condition"] = "branch not taken"
                    else:
                        info["status"] = "reachable"
                        visited.add(dest_start)
                        queue.add(dest_start)
        else:
            # Unconditional - all successors are reachable
            for dest_start, flow_type, _ in successors:
                if visited.contains(dest_start):
                    continue
                    
                block_info[dest_start]["status"] = "reachable"
                visited.add(dest_start)
                queue.add(dest_start)
    
    # Mark unvisited blocks as unreachable
    for block_start, info in block_info.items():
        if info["status"] == "unknown":
            info["status"] = "unreachable"
    
    func_offset_val = func.getEntryPoint().getOffset() - image_base.getOffset()
    
    return {{
        "success": True,
        "functionName": func.getName(),
        "functionOffset": "0x{{:x}}".format(func_offset_val),
        "currentBlock": "0x{{:x}}".format(current_block_offset),
        "blocks": list(block_info.values()),
        "error": None
    }}

def evaluate_branch_condition(mnemonic, instr, registers):
    """Evaluate branch condition based on register values. Returns True/False/None."""
    # Get operands
    ops = []
    for i in range(instr.getNumOperands()):
        op_objs = instr.getOpObjects(i)
        if op_objs:
            ops.extend([str(o).lower() for o in op_objs])
    
    # cbz/cbnz - compare register with zero
    if mnemonic == "cbz" and ops:
        reg_name = ops[0]
        if reg_name in registers:
            try:
                val = int(registers[reg_name], 16) if isinstance(registers[reg_name], str) else registers[reg_name]
                return val == 0
            except:
                pass
        return None
    
    if mnemonic == "cbnz" and ops:
        reg_name = ops[0]
        if reg_name in registers:
            try:
                val = int(registers[reg_name], 16) if isinstance(registers[reg_name], str) else registers[reg_name]
                return val != 0
            except:
                pass
        return None
    
    # tbz/tbnz - test bit and branch
    if mnemonic == "tbz" and len(ops) >= 2:
        reg_name = ops[0]
        try:
            bit_num = int(ops[1])
            if reg_name in registers:
                val = int(registers[reg_name], 16) if isinstance(registers[reg_name], str) else registers[reg_name]
                return (val >> bit_num) & 1 == 0
        except:
            pass
        return None
    
    if mnemonic == "tbnz" and len(ops) >= 2:
        reg_name = ops[0]
        try:
            bit_num = int(ops[1])
            if reg_name in registers:
                val = int(registers[reg_name], 16) if isinstance(registers[reg_name], str) else registers[reg_name]
                return (val >> bit_num) & 1 != 0
        except:
            pass
        return None
    
    # For flag-based conditions (b.eq, b.ne, etc.), we'd need NZCV flags
    # Return None to indicate we can't determine
    return None

class GhidraHandler(BaseHTTPServer.BaseHTTPRequestHandler):
    def log_message(self, format, *args):
        pass  # Suppress logging
    
    def do_GET(self):
        parsed = urlparse.urlparse(self.path)
        params = urlparse.parse_qs(parsed.query)
        
        if parsed.path == "/decompile":
            offset = params.get("offset", [""])[0]
            result = decompile_function(offset)
        elif parsed.path == "/xrefs":
            offset = params.get("offset", [""])[0]
            result = get_xrefs(offset)
        elif parsed.path == "/function_info":
            offset = params.get("offset", [""])[0]
            result = get_function_info(offset)
        elif parsed.path == "/cfg":
            offset = params.get("offset", [""])[0]
            result = get_cfg(offset)
        elif parsed.path == "/reachability":
            func_offset = params.get("func_offset", [""])[0]
            current_block = params.get("current_block", [""])[0]
            registers = params.get("registers", ["{{}}"])[0]
            result = analyze_reachability(func_offset, current_block, registers)
        elif parsed.path == "/data":
            result = get_data_items()
        elif parsed.path == "/ping":
            result = {{"status": "ok", "program": currentProgram.getName()}}
        elif parsed.path == "/info":
            image_base = currentProgram.getImageBase()
            funcs = []
            func_mgr = currentProgram.getFunctionManager()
            for func in func_mgr.getFunctions(True):
                func_offset = func.getEntryPoint().getOffset() - image_base.getOffset()
                if func_offset >= 0:
                    funcs.append({{"name": func.getName(), "offset": "0x{{:x}}".format(func_offset)}})
            result = {{
                "status": "ok",
                "program": currentProgram.getName(),
                "image_base": "0x{{:x}}".format(image_base.getOffset()),
                "functions": funcs
            }}
        elif parsed.path == "/shutdown":
            result = {{"status": "shutting_down"}}
            self.send_response(200)
            self.send_header("Content-Type", "application/json")
            self.send_header("Access-Control-Allow-Origin", "*")
            self.end_headers()
            self.wfile.write(json.dumps(result))
            threading.Thread(target=self.server.shutdown).start()
            return
        else:
            result = {{"error": "Unknown endpoint"}}
        
        self.send_response(200)
        self.send_header("Content-Type", "application/json")
        self.send_header("Access-Control-Allow-Origin", "*")
        self.end_headers()
        self.wfile.write(json.dumps(result))

print("Starting Ghidra HTTP Server on port {0}...")
server = BaseHTTPServer.HTTPServer(("127.0.0.1", {0}), GhidraHandler)
print("Ghidra Server ready on http://127.0.0.1:{0}")
print("GHIDRA_SERVER_READY")
server.serve_forever()
"#, port)
}

/// Start Ghidra server for a project
#[tauri::command]
async fn start_ghidra_server(
    project_path: String,
    library_name: String,
    ghidra_path: String,
    port: u16,
) -> Result<bool, String> {
    // Check if server is already running
    {
        let ports = GHIDRA_SERVER_PORTS.lock().map_err(|e| e.to_string())?;
        if ports.contains_key(&project_path) {
            return Ok(true); // Already running
        }
    }
    
    let ghidra_base = PathBuf::from(&ghidra_path);
    let analyzer_path = if cfg!(windows) {
        ghidra_base.join("support").join("analyzeHeadless.bat")
    } else {
        ghidra_base.join("support").join("analyzeHeadless")
    };
    
    if !analyzer_path.exists() {
        return Err("Ghidra analyzeHeadless not found".to_string());
    }
    
    // Generate and save the server script
    let ghidra_dir = get_ghidra_projects_dir();
    let script_path = ghidra_dir.join("ghidra_server.py");
    let script_content = generate_ghidra_server_script(port);
    
    fs::write(&script_path, &script_content)
        .await
        .map_err(|e| format!("Failed to write server script: {}", e))?;
    
    // Clean library name (without extension)
    // Ghidra stores imported programs with file_stem (no extension) as the program name
    let clean_lib_name = PathBuf::from(&library_name)
        .file_stem()
        .map(|s| s.to_string_lossy().to_string())
        .unwrap_or(library_name.clone());
    
    // Start Ghidra with the server script (non-blocking)
    // Use clean_lib_name (without extension) for -process option
    // Ghidra stores imported programs without file extensions
    let mut child = hide_console_window(&mut Command::new(&analyzer_path))
        .arg(&project_path)
        .arg(&clean_lib_name)
        .arg("-process")
        .arg(&clean_lib_name)
        .arg("-noanalysis")
        .arg("-postScript")
        .arg(script_path.to_string_lossy().to_string())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .map_err(|e| format!("Failed to start Ghidra server: {}", e))?;
    
    // Spawn threads to consume stdout/stderr to prevent blocking
    let stdout = child.stdout.take();
    let stderr = child.stderr.take();
    let project_path_clone = project_path.clone();
    
    if let Some(stdout) = stdout {
        std::thread::spawn(move || {
            use std::io::{BufRead, BufReader};
            let reader = BufReader::new(stdout);
            for line in reader.lines() {
                if let Ok(line) = line {
                    let mut logs = GHIDRA_SERVER_LOGS.lock().unwrap();
                    logs.entry(project_path_clone.clone())
                        .or_insert_with(Vec::new)
                        .push(format!("[stdout] {}", line));
                }
            }
        });
    }
    
    let project_path_clone2 = project_path.clone();
    if let Some(stderr) = stderr {
        std::thread::spawn(move || {
            use std::io::{BufRead, BufReader};
            let reader = BufReader::new(stderr);
            for line in reader.lines() {
                if let Ok(line) = line {
                    let mut logs = GHIDRA_SERVER_LOGS.lock().unwrap();
                    logs.entry(project_path_clone2.clone())
                        .or_insert_with(Vec::new)
                        .push(format!("[stderr] {}", line));
                }
            }
        });
    }
    
    // Store the process and port
    {
        let mut servers = GHIDRA_SERVERS.lock().map_err(|e| e.to_string())?;
        servers.insert(project_path.clone(), child);
    }
    {
        let mut ports = GHIDRA_SERVER_PORTS.lock().map_err(|e| e.to_string())?;
        ports.insert(project_path.clone(), port);
    }
    {
        let mut logs = GHIDRA_SERVER_LOGS.lock().map_err(|e| e.to_string())?;
        logs.insert(project_path, Vec::new());
    }
    
    Ok(true)
}

/// Stop Ghidra server for a project
#[tauri::command]
async fn stop_ghidra_server(project_path: String) -> Result<bool, String> {
    // Try to send shutdown request first
    let port = {
        let ports = GHIDRA_SERVER_PORTS.lock().map_err(|e| e.to_string())?;
        ports.get(&project_path).copied()
    };
    
    if let Some(port) = port {
        let _ = reqwest::get(&format!("http://127.0.0.1:{}/shutdown", port)).await;
    }
    
    // Kill the process
    {
        let mut servers = GHIDRA_SERVERS.lock().map_err(|e| e.to_string())?;
        if let Some(mut child) = servers.remove(&project_path) {
            let _ = child.kill();
        }
    }
    {
        let mut ports = GHIDRA_SERVER_PORTS.lock().map_err(|e| e.to_string())?;
        ports.remove(&project_path);
    }
    {
        let mut logs = GHIDRA_SERVER_LOGS.lock().map_err(|e| e.to_string())?;
        logs.remove(&project_path);
    }
    
    Ok(true)
}

/// Check if Ghidra server is running
#[tauri::command]
async fn check_ghidra_server(project_path: String) -> Result<Option<u16>, String> {
    let port = {
        let ports = GHIDRA_SERVER_PORTS.lock().map_err(|e| e.to_string())?;
        ports.get(&project_path).copied()
    };
    
    if let Some(port) = port {
        // Ping the server to check if it's responsive
        match reqwest::get(&format!("http://127.0.0.1:{}/ping", port)).await {
            Ok(resp) if resp.status().is_success() => Ok(Some(port)),
            _ => {
                // Server not responding yet, but don't kill it - it might still be starting
                // Just return None to indicate it's not ready
                Ok(None)
            }
        }
    } else {
        Ok(None)
    }
}

/// Get Ghidra server logs for debugging
#[tauri::command]
async fn get_ghidra_server_logs(project_path: String) -> Result<Vec<String>, String> {
    let logs = GHIDRA_SERVER_LOGS.lock().map_err(|e| e.to_string())?;
    Ok(logs.get(&project_path).cloned().unwrap_or_default())
}

/// Fast decompile using running Ghidra server
#[tauri::command]
async fn ghidra_server_decompile(
    project_path: String,
    function_address: String,
) -> Result<GhidraDecompileResult, String> {
    let port = {
        let ports = GHIDRA_SERVER_PORTS.lock().map_err(|e| e.to_string())?;
        ports.get(&project_path).copied()
    };
    
    let port = port.ok_or("Ghidra server not running for this project")?;
    
    let url = format!("http://127.0.0.1:{}/decompile?offset={}", port, function_address);
    
    let resp = reqwest::get(&url)
        .await
        .map_err(|e| format!("Failed to connect to Ghidra server: {}", e))?;
    
    // First get the raw text to see what we're receiving
    let text = resp
        .text()
        .await
        .map_err(|e| format!("Failed to get response text: {}", e))?;
    
    // Try to parse the JSON with better error handling
    let result: GhidraDecompileResult = serde_json::from_str(&text)
        .map_err(|e| format!("Failed to parse response: {}. Response was: {}", e, text.chars().take(500).collect::<String>()))?;
    
    Ok(result)
}

/// Fast xrefs using running Ghidra server
#[tauri::command]
async fn ghidra_server_xrefs(
    project_path: String,
    function_address: String,
) -> Result<GhidraXrefsResult, String> {
    let port = {
        let ports = GHIDRA_SERVER_PORTS.lock().map_err(|e| e.to_string())?;
        ports.get(&project_path).copied()
    };
    
    let port = port.ok_or("Ghidra server not running for this project")?;
    
    let url = format!("http://127.0.0.1:{}/xrefs?offset={}", port, function_address);
    
    let resp = reqwest::get(&url)
        .await
        .map_err(|e| format!("Failed to connect to Ghidra server: {}", e))?;
    
    // First get the raw text to see what we're receiving
    let text = resp
        .text()
        .await
        .map_err(|e| format!("Failed to get response text: {}", e))?;
    
    // Try to parse the JSON with better error handling
    let result: GhidraXrefsResult = serde_json::from_str(&text)
        .map_err(|e| format!("Failed to parse response: {}. Response was: {}", e, text.chars().take(500).collect::<String>()))?;
    
    Ok(result)
}

/// Fast function info using running Ghidra server
#[tauri::command]
async fn ghidra_server_function_info(
    project_path: String,
    function_address: String,
) -> Result<GhidraFunctionInfoResult, String> {
    let port = {
        let ports = GHIDRA_SERVER_PORTS.lock().map_err(|e| e.to_string())?;
        ports.get(&project_path).copied()
    };
    
    let port = port.ok_or("Ghidra server not running for this project")?;
    
    let url = format!("http://127.0.0.1:{}/function_info?offset={}", port, function_address);
    
    let resp = reqwest::get(&url)
        .await
        .map_err(|e| format!("Failed to connect to Ghidra server: {}", e))?;
    
    let result: GhidraFunctionInfoResult = resp
        .json()
        .await
        .map_err(|e| format!("Failed to parse response: {}", e))?;
    
    Ok(result)
}

// ============================================================================
// Ghidra CFG (Control Flow Graph) types and commands
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GhidraCfgInstruction {
    pub address: String,
    pub bytes: String,
    pub opcode: String,
    pub operands: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GhidraCfgBlock {
    pub id: String,
    #[serde(rename = "startAddress")]
    pub start_address: String,
    #[serde(rename = "endAddress")]
    pub end_address: String,
    pub instructions: Vec<GhidraCfgInstruction>,
    pub successors: Vec<String>,
    pub predecessors: Vec<String>,
    #[serde(rename = "isEntry")]
    pub is_entry: bool,
    #[serde(rename = "isExit")]
    pub is_exit: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GhidraCfgEdge {
    pub from: String,
    pub to: String,
    #[serde(rename = "type")]
    pub edge_type: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GhidraCfgResult {
    pub success: bool,
    pub function_name: Option<String>,
    pub function_offset: Option<String>,
    pub blocks: Vec<GhidraCfgBlock>,
    pub edges: Vec<GhidraCfgEdge>,
    pub error: Option<String>,
}

/// Get CFG (Control Flow Graph) using running Ghidra server
#[tauri::command]
async fn ghidra_server_cfg(
    project_path: String,
    function_address: String,
) -> Result<GhidraCfgResult, String> {
    let port = {
        let ports = GHIDRA_SERVER_PORTS.lock().map_err(|e| e.to_string())?;
        ports.get(&project_path).copied()
    };
    
    let port = port.ok_or("Ghidra server not running for this project")?;
    
    let url = format!("http://127.0.0.1:{}/cfg?offset={}", port, function_address);
    
    let resp = reqwest::get(&url)
        .await
        .map_err(|e| format!("Failed to connect to Ghidra server: {}", e))?;
    
    let text = resp
        .text()
        .await
        .map_err(|e| format!("Failed to get response text: {}", e))?;
    
    let result: GhidraCfgResult = serde_json::from_str(&text)
        .map_err(|e| format!("Failed to parse CFG response: {}. Response was: {}", e, text.chars().take(500).collect::<String>()))?;
    
    Ok(result)
}

/// Ghidra Data item from analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GhidraDataItem {
    pub address: String,
    pub name: Option<String>,
    #[serde(rename = "type")]
    pub data_type: String,
    pub category: String,  // "string", "pointer", "integer", "float", "struct", "array", "other"
    pub size: i64,
    pub value: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GhidraDataResult {
    pub success: bool,
    pub data: Vec<GhidraDataItem>,
    pub total: i64,
    pub truncated: bool,
    pub error: Option<String>,
}

/// Get Data items (strings, variables, constants) using running Ghidra server
#[tauri::command]
async fn ghidra_server_data(
    project_path: String,
) -> Result<GhidraDataResult, String> {
    let port = {
        let ports = GHIDRA_SERVER_PORTS.lock().map_err(|e| e.to_string())?;
        ports.get(&project_path).copied()
    };
    
    let port = port.ok_or("Ghidra server not running for this project")?;
    
    let url = format!("http://127.0.0.1:{}/data", port);
    
    let resp = reqwest::get(&url)
        .await
        .map_err(|e| format!("Failed to connect to Ghidra server: {}", e))?;
    
    let text = resp
        .text()
        .await
        .map_err(|e| format!("Failed to get response text: {}", e))?;
    
    let result: GhidraDataResult = serde_json::from_str(&text)
        .map_err(|e| format!("Failed to parse Data response: {}. Response was: {}", e, text.chars().take(500).collect::<String>()))?;
    
    Ok(result)
}

// ============================================================================
// Block Reachability Analysis with Z3
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlockReachability {
    #[serde(rename = "blockId")]
    pub block_id: String,
    #[serde(rename = "startAddress")]
    pub start_address: String,
    #[serde(rename = "endAddress")]
    pub end_address: String,
    pub status: String,  // "current", "reachable", "unreachable", "conditional", "unknown"
    #[serde(default)]
    pub condition: String,  // Human-readable condition description
    #[serde(skip_serializing_if = "Option::is_none")]
    pub probability: Option<f64>,  // For conditional blocks (0.0 - 1.0)
    #[serde(rename = "pathConditions", skip_serializing_if = "Option::is_none")]
    pub path_conditions: Option<Vec<String>>,  // Path conditions to reach this block
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReachabilityResult {
    pub success: bool,
    #[serde(rename = "functionName")]
    pub function_name: Option<String>,
    #[serde(rename = "functionOffset")]
    pub function_offset: Option<String>,
    #[serde(rename = "currentBlock")]
    pub current_block: Option<String>,
    pub blocks: Vec<BlockReachability>,
    pub error: Option<String>,
}

/// Analyze block reachability using Z3 (via Ghidra headless Java script)
#[tauri::command]
async fn ghidra_analyze_reachability(
    project_path: String,
    library_name: String,
    function_offset: String,
    current_block_offset: String,
    dbgsrv_url: String, // URL of dbgsrv for memory access
    auth_token: String, // Authentication token for dbgsrv API
    ghidra_path: String,
    registers_json: String, // JSON string of register values from UI (e.g., {"x0": "0x1234", "x1": "0x5678", ...})
    library_base_address: String, // Base address of the library in memory (e.g., "0x71d7d93000")
) -> Result<ReachabilityResult, String> {
    let ghidra_base = PathBuf::from(&ghidra_path);
    let analyzer_path = if cfg!(windows) {
        ghidra_base.join("support").join("analyzeHeadless.bat")
    } else {
        ghidra_base.join("support").join("analyzeHeadless")
    };
    
    if !analyzer_path.exists() {
        return Ok(ReachabilityResult {
            success: false,
            function_name: None,
            function_offset: None,
            current_block: None,
            blocks: vec![],
            error: Some(format!("Ghidra analyzeHeadless not found at: {:?}", analyzer_path)),
        });
    }
    
    // Get script path from the application's scripts directory
    let script_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("scripts")
        .join("ReachabilityAnalysis.java");
    
    if !script_path.exists() {
        return Ok(ReachabilityResult {
            success: false,
            function_name: None,
            function_offset: None,
            current_block: None,
            blocks: vec![],
            error: Some(format!("ReachabilityAnalysis.java script not found at: {:?}", script_path)),
        });
    }
    
    // Clean library name for Ghidra project (stem without extension)
    // Ghidra stores imported programs with file_stem (no extension) as the program name
    let clean_lib_name = PathBuf::from(&library_name)
        .file_stem()
        .map(|s| s.to_string_lossy().to_string())
        .unwrap_or(library_name.clone());
    
    // Run Ghidra headless with the Z3 reachability script
    // Format: analyzeHeadless <project> <name> -process <file> -noanalysis 
    //         -scriptPath <dir> -preScript <script> <arg1> <arg2> <arg3>
    // Each argument must be a separate command-line argument
    // Use clean_lib_name (without extension) for -process option
    let script_name = script_path.file_name().unwrap().to_string_lossy().to_string();
    let script_dir = script_path.parent().unwrap_or(&script_path).to_string_lossy().to_string();
    
    let output = hide_console_window(&mut Command::new(&analyzer_path))
        .arg(&project_path)
        .arg(&clean_lib_name)
        .arg("-process")
        .arg(&clean_lib_name)
        .arg("-noanalysis")
        .arg("-readOnly")
        .arg("-scriptPath")
        .arg(&script_dir)
        .arg("-preScript")
        .arg(&script_name)
        .arg(&function_offset)
        .arg(&current_block_offset)
        .arg(&dbgsrv_url)
        .arg(&auth_token)
        .arg(&registers_json)
        .arg(&library_base_address)
        .output()
        .map_err(|e| format!("Failed to run Ghidra: {}", e))?;
    
    let stdout = String::from_utf8_lossy(&output.stdout);
    let stderr = String::from_utf8_lossy(&output.stderr);
    
    // Parse result from stdout - look for REACHABILITY_RESULT: marker
    for line in stdout.lines() {
        if line.starts_with("REACHABILITY_RESULT:") {
            let json_str = line.trim_start_matches("REACHABILITY_RESULT:");
            // Extract only the JSON part (from first '{' to last '}')
            // Ghidra may append extra text like "(GhidraScript)" after the JSON
            let json_str = if let (Some(start), Some(end)) = (json_str.find('{'), json_str.rfind('}')) {
                &json_str[start..=end]
            } else {
                json_str
            };
            match serde_json::from_str::<ReachabilityResult>(json_str) {
                Ok(result) => return Ok(result),
                Err(e) => {
                    return Ok(ReachabilityResult {
                        success: false,
                        function_name: None,
                        function_offset: None,
                        current_block: None,
                        blocks: vec![],
                        error: Some(format!("Failed to parse result: {}. JSON: {}", e, json_str)),
                    });
                }
            }
        }
    }
    
    // No result found - return debug info with more context
    Ok(ReachabilityResult {
        success: false,
        function_name: None,
        function_offset: None,
        current_block: None,
        blocks: vec![],
        error: Some(format!(
            "No reachability result found. stdout: {}, stderr: {}",
            stdout.chars().take(3000).collect::<String>(),
            stderr.chars().take(1500).collect::<String>()
        )),
    })
}

// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
struct XrefEntry {
    from_address: String,
    from_function: Option<String>,
    #[serde(default)]
    from_function_offset: Option<String>,
    ref_type: String,
    #[serde(default)]
    instruction: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct GhidraXrefsResult {
    success: bool,
    target_function: String,
    target_address: String,
    xrefs: Vec<XrefEntry>,
    error: Option<String>,
}

/// Get cross-references (xrefs) to a function using Ghidra
#[tauri::command]
async fn ghidra_get_xrefs(
    project_path: String,
    library_name: String,
    function_address: String,
    ghidra_path: String,
) -> Result<GhidraXrefsResult, String> {
    let ghidra_base = PathBuf::from(&ghidra_path);
    let analyzer_path = if cfg!(windows) {
        ghidra_base.join("support").join("analyzeHeadless.bat")
    } else {
        ghidra_base.join("support").join("analyzeHeadless")
    };
    
    if !analyzer_path.exists() {
        return Ok(GhidraXrefsResult {
            success: false,
            target_function: String::new(),
            target_address: function_address.clone(),
            xrefs: vec![],
            error: Some("Ghidra analyzeHeadless not found".to_string()),
        });
    }
    
    let ghidra_dir = get_ghidra_projects_dir();
    let script_path = ghidra_dir.join("get_xrefs.py");
    let output_path = ghidra_dir.join("xrefs_output.txt");
    
    // Ghidra Python script to get xrefs
    let script_content = format!(r#"#@runtime Jython
# @category DynaDbg
# @description Get cross-references to a function at offset

def get_xrefs_at_offset(offset_str):
    image_base = currentProgram.getImageBase()
    
    offset_str = offset_str.strip()
    if offset_str.startswith("0x"):
        offset_str = offset_str[2:]
    
    try:
        offset = int(offset_str, 16)
    except:
        return "Error: Invalid offset format: " + offset_str
    
    addr = image_base.add(offset)
    
    func = getFunctionContaining(addr)
    if func is None:
        func = getFunctionAt(addr)
    
    if func is None:
        return "Error: No function found at address " + str(addr)
    
    func_name = func.getName()
    func_entry = func.getEntryPoint()
    func_offset = func_entry.getOffset() - image_base.getOffset()
    
    result = "TARGET_FUNCTION:" + func_name + "\n"
    result += "TARGET_ADDRESS:0x{{:x}}\n".format(func_offset)
    result += "XREFS:\n"
    
    # Get references TO this function
    ref_manager = currentProgram.getReferenceManager()
    refs = ref_manager.getReferencesTo(func_entry)
    
    xref_count = 0
    for ref in refs:
        if xref_count >= 100:  # Limit to 100 xrefs
            break
        from_addr = ref.getFromAddress()
        from_offset = from_addr.getOffset() - image_base.getOffset()
        ref_type = str(ref.getReferenceType())
        
        # Skip external references (negative offsets or special addresses)
        if from_offset < 0:
            continue
        
        # Get function containing the reference
        from_func = getFunctionContaining(from_addr)
        from_func_name = from_func.getName() if from_func else "unknown"
        
        # Calculate offset within the function
        from_func_offset = "unknown"
        if from_func:
            func_entry_offset = from_func.getEntryPoint().getOffset() - image_base.getOffset()
            from_func_offset = "0x{{:x}}".format(from_offset - func_entry_offset)
        
        result += "0x{{:x}}|{{}}|{{}}||{{}}\n".format(from_offset, from_func_name, ref_type, from_func_offset)
        xref_count += 1
    
    return result

offset = "{}"
result = get_xrefs_at_offset(offset)

with open(r"{}", "w") as f:
    f.write(result)
"#, function_address, output_path.to_string_lossy().replace("\\", "\\\\"));
    
    fs::write(&script_path, &script_content)
        .await
        .map_err(|e| format!("Failed to write xref script: {}", e))?;
    
    // Clean library name (without extension)
    // Ghidra stores imported programs with file_stem (no extension) as the program name
    let clean_lib_name = PathBuf::from(&library_name)
        .file_stem()
        .map(|s| s.to_string_lossy().to_string())
        .unwrap_or(library_name.clone());
    
    // Use clean_lib_name (without extension) for -process option
    // Ghidra stores imported programs without file extensions
    let output = hide_console_window(&mut Command::new(&analyzer_path))
        .arg(&project_path)
        .arg(&clean_lib_name)
        .arg("-process")
        .arg(&clean_lib_name)
        .arg("-noanalysis")
        .arg("-postScript")
        .arg(script_path.to_string_lossy().to_string())
        .output()
        .map_err(|e| format!("Failed to run Ghidra: {}", e))?;
    
    if !output.status.success() {
        let stdout = String::from_utf8_lossy(&output.stdout);
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Ok(GhidraXrefsResult {
            success: false,
            target_function: String::new(),
            target_address: function_address,
            xrefs: vec![],
            error: Some(format!("Ghidra process failed (exit code {:?}): \nStdout: {}\nStderr: {}", output.status.code(), stdout, stderr)),
        });
    }

    let xref_output = match fs::read_to_string(&output_path).await {
        Ok(content) => content,
        Err(e) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Ok(GhidraXrefsResult {
                success: false,
                target_function: String::new(),
                target_address: function_address,
                xrefs: vec![],
                error: Some(format!("Could not read xref output: {}. \nStdout: {}\nStderr: {}", e, stdout, stderr)),
            });
        }
    };
    
    let _ = fs::remove_file(&script_path).await;
    let _ = fs::remove_file(&output_path).await;
    
    if xref_output.starts_with("Error:") {
        return Ok(GhidraXrefsResult {
            success: false,
            target_function: String::new(),
            target_address: function_address,
            xrefs: vec![],
            error: Some(xref_output),
        });
    }
    
    let mut target_function = String::new();
    let mut target_address = String::new();
    let mut xrefs: Vec<XrefEntry> = vec![];
    let mut in_xrefs = false;
    
    for line in xref_output.lines() {
        if line.starts_with("TARGET_FUNCTION:") {
            target_function = line.replace("TARGET_FUNCTION:", "");
        } else if line.starts_with("TARGET_ADDRESS:") {
            target_address = line.replace("TARGET_ADDRESS:", "");
        } else if line.starts_with("XREFS:") {
            in_xrefs = true;
        } else if in_xrefs && !line.is_empty() {
            let parts: Vec<&str> = line.split('|').collect();
            if parts.len() >= 3 {
                xrefs.push(XrefEntry {
                    from_address: parts[0].to_string(),
                    from_function: if parts[1] == "unknown" { None } else { Some(parts[1].to_string()) },
                    from_function_offset: if parts.len() >= 5 && parts[4] != "unknown" { Some(parts[4].to_string()) } else { None },
                    ref_type: parts[2].to_string(),
                    instruction: if parts.len() >= 4 { Some(parts[3].to_string()) } else { None },
                });
            }
        }
    }
    
    Ok(GhidraXrefsResult {
        success: true,
        target_function,
        target_address,
        xrefs,
        error: None,
    })
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct GhidraFunctionEntry {
    name: String,
    address: String, // offset from image base as hex string
    size: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct GhidraFunctionListResult {
    success: bool,
    functions: Vec<GhidraFunctionEntry>,
    error: Option<String>,
}

/// Get all functions from an analyzed library using Ghidra
#[tauri::command]
async fn ghidra_get_functions(
    project_path: String,
    library_name: String,
    ghidra_path: String,
) -> Result<GhidraFunctionListResult, String> {
    let ghidra_base = PathBuf::from(&ghidra_path);
    let analyzer_path = if cfg!(windows) {
        ghidra_base.join("support").join("analyzeHeadless.bat")
    } else {
        ghidra_base.join("support").join("analyzeHeadless")
    };
    
    if !analyzer_path.exists() {
        return Ok(GhidraFunctionListResult {
            success: false,
            functions: vec![],
            error: Some("Ghidra analyzeHeadless not found".to_string()),
        });
    }
    
    let ghidra_dir = get_ghidra_projects_dir();
    let script_path = ghidra_dir.join("get_functions.py");
    let output_path = ghidra_dir.join("functions_output.txt");
    
    // Ghidra Python script to get all functions
    let script_content = format!(r#"#@runtime Jython
# @category DynaDbg
# @description Get all functions from the program

def get_all_functions():
    image_base = currentProgram.getImageBase()
    func_manager = currentProgram.getFunctionManager()
    
    result = "FUNCTIONS:\n"
    
    for func in func_manager.getFunctions(True):  # True = forward iteration
        func_name = func.getName()
        entry_point = func.getEntryPoint()
        offset = entry_point.getOffset() - image_base.getOffset()
        body = func.getBody()
        size = body.getNumAddresses() if body else 0
        
        # Format: name|offset|size
        result += "{{}}|0x{{:x}}|{{}}\n".format(func_name, offset, size)
    
    return result

result = get_all_functions()

import codecs
with codecs.open(r"{}", "w", "utf-8") as f:
    f.write(result)
"#, output_path.to_string_lossy().replace("\\", "\\\\"));
    
    fs::write(&script_path, &script_content)
        .await
        .map_err(|e| format!("Failed to write functions script: {}", e))?;
    
    // Clean library name (without extension)
    // Ghidra stores imported programs with file_stem (no extension) as the program name
    let clean_lib_name = PathBuf::from(&library_name)
        .file_stem()
        .map(|s| s.to_string_lossy().to_string())
        .unwrap_or(library_name.clone());
    
    // Use clean_lib_name (without extension) for -process option
    // Ghidra stores imported programs without file extensions
    let output = hide_console_window(&mut Command::new(&analyzer_path))
        .arg(&project_path)
        .arg(&clean_lib_name)
        .arg("-process")
        .arg(&clean_lib_name)
        .arg("-noanalysis")
        .arg("-postScript")
        .arg(script_path.to_string_lossy().to_string())
        .output()
        .map_err(|e| format!("Failed to run Ghidra: {}", e))?;
    
    if !output.status.success() {
        let stdout = String::from_utf8_lossy(&output.stdout);
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Ok(GhidraFunctionListResult {
            success: false,
            functions: vec![],
            error: Some(format!("Ghidra process failed (exit code {:?}): \nStdout: {}\nStderr: {}", output.status.code(), stdout, stderr)),
        });
    }

    let func_output = match fs::read_to_string(&output_path).await {
        Ok(content) => content,
        Err(e) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Ok(GhidraFunctionListResult {
                success: false,
                functions: vec![],
                error: Some(format!("Could not read functions output: {}. \nStdout: {}\nStderr: {}", e, stdout, stderr)),
            });
        }
    };
    
    let _ = fs::remove_file(&script_path).await;
    let _ = fs::remove_file(&output_path).await;
    
    let mut functions: Vec<GhidraFunctionEntry> = vec![];
    let mut in_functions = false;
    
    for line in func_output.lines() {
        if line.starts_with("FUNCTIONS:") {
            in_functions = true;
        } else if in_functions && !line.is_empty() {
            let parts: Vec<&str> = line.split('|').collect();
            if parts.len() >= 3 {
                functions.push(GhidraFunctionEntry {
                    name: parts[0].to_string(),
                    address: parts[1].to_string(),
                    size: parts[2].parse().unwrap_or(0),
                });
            }
        }
    }
    
    Ok(GhidraFunctionListResult {
        success: true,
        functions,
        error: None,
    })
}

/// Save analyzed module and its functions to SQLite database
#[tauri::command]
fn save_ghidra_functions_to_db(
    target_os: String,
    module_name: String,
    module_path: String,
    local_path: String,
    project_path: String,
    functions: Vec<GhidraFunctionEntry>,
) -> Result<bool, String> {
    let db_guard = GHIDRA_DB.lock().map_err(|e| e.to_string())?;
    let conn = db_guard.as_ref().ok_or("Database not initialized")?;
    
    let analyzed_at = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .map(|d| d.as_secs() as i64)
        .unwrap_or(0);
    
    // Insert or replace the module record
    conn.execute(
        "INSERT OR REPLACE INTO analyzed_modules (target_os, module_name, module_path, local_path, project_path, analyzed_at)
         VALUES (?1, ?2, ?3, ?4, ?5, ?6)",
        params![target_os, module_name, module_path, local_path, project_path, analyzed_at],
    ).map_err(|e| e.to_string())?;
    
    // Get the module ID
    let module_id: i64 = conn.query_row(
        "SELECT id FROM analyzed_modules WHERE target_os = ?1 AND module_name = ?2",
        params![target_os, module_name],
        |row| row.get(0),
    ).map_err(|e| e.to_string())?;
    
    // Delete existing functions for this module
    conn.execute(
        "DELETE FROM module_functions WHERE module_id = ?1",
        params![module_id],
    ).map_err(|e| e.to_string())?;
    
    // Insert all functions
    for func in &functions {
        conn.execute(
            "INSERT INTO module_functions (module_id, name, address, size) VALUES (?1, ?2, ?3, ?4)",
            params![module_id, func.name, func.address, func.size],
        ).map_err(|e| e.to_string())?;
    }
    
    Ok(true)
}

/// Get functions from SQLite database for a module
#[tauri::command]
fn get_ghidra_functions_from_db(
    target_os: String,
    module_name: String,
) -> Result<GhidraFunctionListResult, String> {
    let db_guard = GHIDRA_DB.lock().map_err(|e| e.to_string())?;
    let conn = db_guard.as_ref().ok_or("Database not initialized")?;
    
    // Get the module ID
    let module_id: Result<i64, _> = conn.query_row(
        "SELECT id FROM analyzed_modules WHERE target_os = ?1 AND module_name = ?2",
        params![target_os, module_name],
        |row| row.get(0),
    );
    
    let module_id = match module_id {
        Ok(id) => id,
        Err(_) => {
            return Ok(GhidraFunctionListResult {
                success: false,
                functions: vec![],
                error: Some("Module not found in database".to_string()),
            });
        }
    };
    
    // Get all functions for this module
    let mut stmt = conn.prepare(
        "SELECT name, address, size FROM module_functions WHERE module_id = ?1"
    ).map_err(|e| e.to_string())?;
    
    let functions: Vec<GhidraFunctionEntry> = stmt.query_map(params![module_id], |row| {
        Ok(GhidraFunctionEntry {
            name: row.get(0)?,
            address: row.get(1)?,
            size: row.get(2)?,
        })
    }).map_err(|e| e.to_string())?
    .filter_map(|r| r.ok())
    .collect();
    
    Ok(GhidraFunctionListResult {
        success: true,
        functions,
        error: None,
    })
}

/// Check if a module is analyzed in the database
#[tauri::command]
fn is_module_analyzed_in_db(
    target_os: String,
    module_name: String,
) -> Result<bool, String> {
    let db_guard = GHIDRA_DB.lock().map_err(|e| e.to_string())?;
    let conn = db_guard.as_ref().ok_or("Database not initialized")?;
    
    let count: i64 = conn.query_row(
        "SELECT COUNT(*) FROM analyzed_modules WHERE target_os = ?1 AND module_name = ?2",
        params![target_os, module_name],
        |row| row.get(0),
    ).unwrap_or(0);
    
    Ok(count > 0)
}

/// Get module info from database
#[tauri::command]
fn get_module_info_from_db(
    target_os: String,
    module_name: String,
) -> Result<Option<AnalyzedModuleInfo>, String> {
    let db_guard = GHIDRA_DB.lock().map_err(|e| e.to_string())?;
    let conn = db_guard.as_ref().ok_or("Database not initialized")?;
    
    let result = conn.query_row(
        "SELECT module_path, local_path, project_path, analyzed_at FROM analyzed_modules WHERE target_os = ?1 AND module_name = ?2",
        params![target_os, module_name],
        |row| {
            Ok(AnalyzedModuleInfo {
                module_path: row.get(0)?,
                local_path: row.get(1)?,
                project_path: row.get(2)?,
                analyzed_at: row.get(3)?,
            })
        },
    );
    
    match result {
        Ok(info) => Ok(Some(info)),
        Err(_) => Ok(None),
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct AnalyzedModuleInfo {
    module_path: String,
    local_path: String,
    project_path: String,
    analyzed_at: i64,
}

/// Simple save functions to SQLite (JSON string version for frontend compatibility)
#[tauri::command]
fn save_ghidra_functions(
    target_os: String,
    module_name: String,
    functions_json: String,
) -> Result<bool, String> {
    let _functions: Vec<GhidraFunctionEntry> = serde_json::from_str(&functions_json)
        .map_err(|e| format!("Failed to parse functions JSON: {}", e))?;
    
    let db_guard = GHIDRA_DB.lock().map_err(|e| e.to_string())?;
    let conn = db_guard.as_ref().ok_or("Database not initialized")?;
    
    // Use simple key-value style storage with JSON
    conn.execute(
        "INSERT OR REPLACE INTO ghidra_functions_cache (target_os, module_name, functions_json, updated_at)
         VALUES (?1, ?2, ?3, datetime('now'))",
        params![target_os, module_name, functions_json],
    ).map_err(|e| e.to_string())?;
    
    Ok(true)
}

/// Simple get functions from SQLite (JSON string version for frontend compatibility)
#[tauri::command]
fn get_ghidra_functions(
    target_os: String,
    module_name: String,
) -> Result<Option<String>, String> {
    let db_guard = GHIDRA_DB.lock().map_err(|e| e.to_string())?;
    let conn = db_guard.as_ref().ok_or("Database not initialized")?;
    
    let result: Result<String, _> = conn.query_row(
        "SELECT functions_json FROM ghidra_functions_cache WHERE target_os = ?1 AND module_name = ?2",
        params![target_os, module_name],
        |row| row.get(0),
    );
    
    match result {
        Ok(json) => Ok(Some(json)),
        Err(_) => Ok(None),
    }
}

/// Save decompiled code to SQLite cache
#[tauri::command]
fn save_decompile_cache(
    target_os: String,
    module_name: String,
    function_address: String,
    function_name: String,
    decompiled_code: String,
    line_mapping_json: Option<String>,
) -> Result<bool, String> {
    let db_guard = GHIDRA_DB.lock().map_err(|e| e.to_string())?;
    let conn = db_guard.as_ref().ok_or("Database not initialized")?;
    
    conn.execute(
        "INSERT OR REPLACE INTO ghidra_decompile_cache 
         (target_os, module_name, function_address, function_name, decompiled_code, line_mapping_json, updated_at)
         VALUES (?1, ?2, ?3, ?4, ?5, ?6, datetime('now'))",
        params![target_os, module_name, function_address, function_name, decompiled_code, line_mapping_json],
    ).map_err(|e| e.to_string())?;
    
    Ok(true)
}

/// Get decompiled code from SQLite cache
#[tauri::command]
fn get_decompile_cache(
    target_os: String,
    module_name: String,
    function_address: String,
) -> Result<Option<GhidraDecompileResult>, String> {
    let db_guard = GHIDRA_DB.lock().map_err(|e| e.to_string())?;
    let conn = db_guard.as_ref().ok_or("Database not initialized")?;
    
    let result = conn.query_row(
        "SELECT function_name, decompiled_code, line_mapping_json FROM ghidra_decompile_cache 
         WHERE target_os = ?1 AND module_name = ?2 AND function_address = ?3",
        params![target_os, module_name, function_address],
        |row| {
            let function_name: String = row.get(0)?;
            let decompiled_code: String = row.get(1)?;
            let line_mapping_json: Option<String> = row.get(2)?;
            
            let line_mapping: Option<std::collections::HashMap<String, String>> = line_mapping_json
                .and_then(|json| serde_json::from_str(&json).ok());
            
            Ok(GhidraDecompileResult {
                success: true,
                function_name: if function_name.is_empty() { None } else { Some(function_name) },
                address: Some(function_address.clone()),
                decompiled_code: Some(decompiled_code),
                line_mapping,
                tokens: None,
                error: None,
            })
        },
    );
    
    match result {
        Ok(r) => Ok(Some(r)),
        Err(_) => Ok(None),
    }
}

/// Save xrefs to SQLite cache
#[tauri::command]
fn save_xref_cache(
    target_os: String,
    module_name: String,
    function_address: String,
    function_name: String,
    xrefs_json: String,
) -> Result<bool, String> {
    let db_guard = GHIDRA_DB.lock().map_err(|e| e.to_string())?;
    let conn = db_guard.as_ref().ok_or("Database not initialized")?;
    
    conn.execute(
        "INSERT OR REPLACE INTO ghidra_xref_cache 
         (target_os, module_name, function_address, function_name, xrefs_json, updated_at)
         VALUES (?1, ?2, ?3, ?4, ?5, datetime('now'))",
        params![target_os, module_name, function_address, function_name, xrefs_json],
    ).map_err(|e| e.to_string())?;
    
    Ok(true)
}

/// Get xrefs from SQLite cache
#[tauri::command]
fn get_xref_cache(
    target_os: String,
    module_name: String,
    function_address: String,
) -> Result<Option<GhidraXrefsResult>, String> {
    let db_guard = GHIDRA_DB.lock().map_err(|e| e.to_string())?;
    let conn = db_guard.as_ref().ok_or("Database not initialized")?;
    
    let result = conn.query_row(
        "SELECT function_name, xrefs_json FROM ghidra_xref_cache 
         WHERE target_os = ?1 AND module_name = ?2 AND function_address = ?3",
        params![target_os, module_name, function_address],
        |row| {
            let function_name: String = row.get(0)?;
            let xrefs_json: String = row.get(1)?;
            
            let xrefs: Vec<XrefEntry> = serde_json::from_str(&xrefs_json).unwrap_or_default();
            
            Ok(GhidraXrefsResult {
                success: true,
                target_function: function_name,
                target_address: function_address.clone(),
                xrefs,
                error: None,
            })
        },
    );
    
    match result {
        Ok(r) => Ok(Some(r)),
        Err(_) => Ok(None),
    }
}

/// Clear all Ghidra cache from SQLite database
#[tauri::command]
fn clear_ghidra_cache() -> Result<bool, String> {
    let db_guard = GHIDRA_DB.lock().map_err(|e| e.to_string())?;
    let conn = db_guard.as_ref().ok_or("Database not initialized")?;
    
    // Clear all cache tables
    conn.execute("DELETE FROM ghidra_functions_cache", [])
        .map_err(|e| format!("Failed to clear functions cache: {}", e))?;
    
    conn.execute("DELETE FROM ghidra_decompile_cache", [])
        .map_err(|e| format!("Failed to clear decompile cache: {}", e))?;
    
    conn.execute("DELETE FROM ghidra_xref_cache", [])
        .map_err(|e| format!("Failed to clear xref cache: {}", e))?;
    
    conn.execute("DELETE FROM analyzed_modules", [])
        .map_err(|e| format!("Failed to clear analyzed modules: {}", e))?;
    
    conn.execute("DELETE FROM module_functions", [])
        .map_err(|e| format!("Failed to clear module functions: {}", e))?;
    
    // VACUUM to reclaim space
    conn.execute("VACUUM", [])
        .map_err(|e| format!("Failed to vacuum database: {}", e))?;
    
    Ok(true)
}

/// Format C/C++ code using clang-format if available, otherwise use simple Rust formatter
#[allow(dead_code)]
async fn format_cpp_code(code: &str) -> Option<String> {
    // First try clang-format
    if let Some(formatted) = try_clang_format(code).await {
        return Some(formatted);
    }
    
    // Fall back to simple Rust-based formatter
    Some(simple_cpp_format(code))
}

/// Try to format using clang-format binary
#[allow(dead_code)]
async fn try_clang_format(code: &str) -> Option<String> {
    // Try to find clang-format
    let clang_format = if cfg!(windows) {
        // Try common Windows paths
        let paths = vec![
            "clang-format",
            "clang-format.exe",
            "C:\\Program Files\\LLVM\\bin\\clang-format.exe",
            "C:\\Program Files (x86)\\LLVM\\bin\\clang-format.exe",
        ];
        paths.into_iter().find(|p| {
            hide_console_window(&mut Command::new(p))
                .arg("--version")
                .output()
                .map(|o| o.status.success())
                .unwrap_or(false)
        }).map(|s| s.to_string())
    } else {
        // Unix - just try clang-format in PATH
        if hide_console_window(&mut Command::new("clang-format"))
            .arg("--version")
            .output()
            .map(|o| o.status.success())
            .unwrap_or(false)
        {
            Some("clang-format".to_string())
        } else {
            None
        }
    };
    
    let clang_format = clang_format?;
    
    // Create a temp file with the code
    let ghidra_dir = get_ghidra_projects_dir();
    let temp_file = ghidra_dir.join("temp_format.c");
    
    if let Err(_) = fs::write(&temp_file, code).await {
        return None;
    }
    
    // Run clang-format
    let output = hide_console_window(&mut Command::new(&clang_format))
        .arg("-style={BasedOnStyle: LLVM, IndentWidth: 2, ColumnLimit: 100}")
        .arg(&temp_file)
        .output()
        .ok()?;
    
    // Clean up temp file
    let _ = fs::remove_file(&temp_file).await;
    
    if output.status.success() {
        String::from_utf8(output.stdout).ok()
    } else {
        None
    }
}

/// Simple C/C++ formatter implemented in pure Rust
/// Handles basic indentation and brace formatting
#[allow(dead_code)]
fn simple_cpp_format(code: &str) -> String {
    let mut result = String::new();
    let mut indent_level: i32 = 0;
    let indent_str = "  "; // 2 spaces
    
    for line in code.lines() {
        let trimmed = line.trim();
        
        // Skip empty lines but preserve them
        if trimmed.is_empty() {
            result.push('\n');
            continue;
        }
        
        // Decrease indent before closing braces
        if trimmed.starts_with('}') || trimmed.starts_with(')') {
            indent_level = (indent_level - 1).max(0);
        }
        
        // Add indentation
        for _ in 0..indent_level {
            result.push_str(indent_str);
        }
        
        // Add the trimmed line
        result.push_str(trimmed);
        result.push('\n');
        
        // Increase indent after opening braces
        if trimmed.ends_with('{') {
            indent_level += 1;
        }
        
        // Handle single-line cases like "} else {"
        if trimmed.contains('{') && !trimmed.ends_with('{') && !trimmed.starts_with("//") {
            // Count braces
            let opens = trimmed.matches('{').count() as i32;
            let closes = trimmed.matches('}').count() as i32;
            indent_level = (indent_level + opens - closes).max(0);
        }
    }
    
    result
}

/// Check if a library has been analyzed with Ghidra
#[tauri::command]
async fn check_ghidra_analysis(library_name: String) -> Result<GhidraAnalysisStatus, String> {
    let clean_name = PathBuf::from(&library_name)
        .file_stem()
        .map(|s| s.to_string_lossy().to_string())
        .unwrap_or(library_name.clone());
    
    let ghidra_dir = get_ghidra_projects_dir();
    let project_dir = ghidra_dir.join(&clean_name);
    let gpr_file = project_dir.join(format!("{}.gpr", clean_name));
    
    if gpr_file.exists() {
        Ok(GhidraAnalysisStatus {
            library_path: library_name,
            analyzed: true,
            project_path: Some(project_dir.to_string_lossy().to_string()),
            error: None,
        })
    } else {
        Ok(GhidraAnalysisStatus {
            library_path: library_name,
            analyzed: false,
            project_path: None,
            error: None,
        })
    }
}

/// Check if a path exists on the local filesystem
#[tauri::command]
fn path_exists(path: String) -> bool {
    std::path::Path::new(&path).exists()
}

/// Read a local text file from the host OS filesystem
#[tauri::command]
async fn read_local_text_file(file_path: String) -> Result<String, String> {
    use tokio::fs::read_to_string;
    
    read_to_string(&file_path)
        .await
        .map_err(|e| format!("Failed to read file '{}': {}", file_path, e))
}

/// Open a folder selection dialog and return the selected path
#[tauri::command]
async fn select_folder_dialog(title: String) -> Result<Option<String>, String> {
    use rfd::AsyncFileDialog;
    
    let dialog = AsyncFileDialog::new()
        .set_title(&title);
    
    let folder = dialog.pick_folder().await;
    
    Ok(folder.map(|f| f.path().to_string_lossy().to_string()))
}

/// Open a save file dialog and save binary data to the selected path
#[tauri::command]
async fn save_binary_file_dialog(
    title: String,
    default_filename: String,
    filter_name: String,
    filter_extensions: Vec<String>,
    data: Vec<u8>,
) -> Result<Option<String>, String> {
    use rfd::AsyncFileDialog;
    use tokio::fs;
    
    let extensions: Vec<&str> = filter_extensions.iter().map(|s| s.as_str()).collect();
    
    let dialog = AsyncFileDialog::new()
        .set_title(&title)
        .set_file_name(&default_filename)
        .add_filter(&filter_name, &extensions);
    
    let file = dialog.save_file().await;
    
    if let Some(file_handle) = file {
        let path = file_handle.path().to_string_lossy().to_string();
        fs::write(file_handle.path(), &data)
            .await
            .map_err(|e| format!("Failed to write file: {}", e))?;
        Ok(Some(path))
    } else {
        Ok(None)
    }
}

/// Open a file dialog to select multiple PointerMap files
#[tauri::command]
async fn open_pointermap_files_dialog() -> Result<Vec<PointerMapFileInfo>, String> {
    use rfd::AsyncFileDialog;
    
    let dialog = AsyncFileDialog::new()
        .set_title("Select PointerMap Files")
        .add_filter("PointerMap Files", &["dptr"]);
    
    let files = dialog.pick_files().await;
    
    if let Some(file_handles) = files {
        let result: Vec<PointerMapFileInfo> = file_handles
            .iter()
            .map(|f| PointerMapFileInfo {
                path: f.path().to_string_lossy().to_string(),
                name: f.file_name(),
            })
            .collect();
        Ok(result)
    } else {
        Ok(vec![])
    }
}

#[derive(Serialize, Deserialize)]
struct PointerMapFileInfo {
    path: String,
    name: String,
}

#[derive(Serialize, Deserialize, Clone)]
struct PointerScanFileInput {
    path: String,
    #[serde(rename = "targetAddress")]
    target_address: String,
}

#[derive(Serialize, Deserialize)]
struct PointerChainStep {
    #[serde(skip_serializing_if = "Option::is_none")]
    module: Option<String>,
    offset: i64,
}

#[derive(Serialize, Deserialize)]
struct PointerScanResult {
    chain: Vec<PointerChainStep>,
    #[serde(rename = "finalAddress")]
    final_address: String,
}

/// Run multi-level pointer scan to find common pointer paths across multiple PointerMap files
/// Each file has its own target address
/// Optimized algorithm: uses binary search for range queries, parallel BFS, and progressive intersection
#[tauri::command]
async fn run_pointer_scan(
    app_handle: tauri::AppHandle,
    files: Vec<PointerScanFileInput>,
    max_depth: u32,
    max_offset: u32,
    max_results: Option<u32>,
) -> Result<Vec<PointerScanResult>, String> {
    use lz4_flex::decompress_size_prepended;
    use rayon::prelude::*;
    use std::collections::{HashMap, HashSet};
    use std::sync::atomic::{AtomicU64, AtomicBool, Ordering};
    use std::sync::{Arc, Mutex};
    
    // Reset cancel flag at the start
    PTRSCAN_CANCEL.store(false, Ordering::Relaxed);
    
    let max_results = max_results.unwrap_or(1000) as usize;
    
    if files.len() < 2 {
        return Err("At least 2 PointerMap files are required".to_string());
    }
    
    // Parse target addresses
    let target_addresses: Vec<u64> = files.iter()
        .map(|file| {
            u64::from_str_radix(
                file.target_address.trim_start_matches("0x").trim_start_matches("0X"),
                16
            )
        })
        .collect::<Result<Vec<_>, _>>()
        .map_err(|e| format!("Invalid target address: {}", e))?;
    
    // Emit initial progress - loading files
    let _ = app_handle.emit("ptr-scan-progress", serde_json::json!({
        "nodesProcessed": 0,
        "chainsFound": 0,
        "fileIndex": 0,
        "totalFiles": files.len(),
        "phase": "loading"
    }));
    
    // Load all files first (async)
    let mut file_data: Vec<Vec<u8>> = Vec::new();
    for (idx, file) in files.iter().enumerate() {
        let _ = app_handle.emit("ptr-scan-progress", serde_json::json!({
            "nodesProcessed": 0,
            "chainsFound": 0,
            "fileIndex": idx,
            "totalFiles": files.len(),
            "phase": "loading"
        }));
        
        let compressed_data = tokio::fs::read(&file.path)
            .await
            .map_err(|e| format!("Failed to read file {}: {}", file.path, e))?;
        file_data.push(compressed_data);
    }
    
    let total_files = files.len();
    
    // Emit decompressing phase
    let _ = app_handle.emit("ptr-scan-progress", serde_json::json!({
        "nodesProcessed": 0,
        "chainsFound": 0,
        "fileIndex": 0,
        "totalFiles": total_files,
        "phase": "decompressing"
    }));
    
    // Shared progress state - using std primitives for cross-thread access
    let nodes_counter = Arc::new(AtomicU64::new(0));
    let chains_counter = Arc::new(AtomicU64::new(0));
    let file_idx_counter = Arc::new(AtomicU64::new(0));
    let scan_complete = Arc::new(AtomicBool::new(false));
    let phase_str = Arc::new(Mutex::new(String::from("scanning")));
    
    // Clone for progress thread (std::thread, not tokio)
    let nodes_for_progress = Arc::clone(&nodes_counter);
    let chains_for_progress = Arc::clone(&chains_counter);
    let file_idx_for_progress = Arc::clone(&file_idx_counter);
    let complete_for_progress = Arc::clone(&scan_complete);
    let phase_for_progress = Arc::clone(&phase_str);
    let app_handle_clone = app_handle.clone();
    
    // Spawn progress emitter in a std::thread (not tokio) so it runs independently
    let progress_thread = std::thread::spawn(move || {
        let mut last_nodes = 0u64;
        let mut last_chains = 0u64;
        let mut last_phase = String::new();
        loop {
            std::thread::sleep(std::time::Duration::from_millis(100));
            
            if complete_for_progress.load(Ordering::Relaxed) {
                break;
            }
            
            let nodes = nodes_for_progress.load(Ordering::Relaxed);
            let chains = chains_for_progress.load(Ordering::Relaxed);
            let file_idx = file_idx_for_progress.load(Ordering::Relaxed);
            let phase = phase_for_progress.lock().unwrap().clone();
            
            // Emit if there's any change in nodes, chains, or phase
            if nodes != last_nodes || chains != last_chains || phase != last_phase {
                last_nodes = nodes;
                last_chains = chains;
                last_phase = phase.clone();
                let _ = app_handle_clone.emit("ptr-scan-progress", serde_json::json!({
                    "nodesProcessed": nodes,
                    "chainsFound": chains,
                    "fileIndex": file_idx,
                    "totalFiles": total_files,
                    "phase": phase
                }));
            }
        }
    });
    
    // Clone counters for the blocking computation
    let nodes_for_scan = Arc::clone(&nodes_counter);
    let chains_for_scan = Arc::clone(&chains_counter);
    let file_idx_for_scan = Arc::clone(&file_idx_counter);
    let complete_for_scan = Arc::clone(&scan_complete);
    let phase_for_scan = Arc::clone(&phase_str);
    
    // Move heavy computation to blocking thread pool
    let result = tokio::task::spawn_blocking(move || {
        // Update phase
        *phase_for_scan.lock().unwrap() = "decompressing".to_string();
        
        // Decompress and parse all files in parallel
        let all_pointer_maps: Vec<PointerMapData> = file_data
            .par_iter()
            .map(|compressed_data| {
                let data = decompress_size_prepended(compressed_data)
                    .map_err(|e| format!("Failed to decompress: {}", e))?;
                parse_pointer_map(&data)
            })
            .collect::<Result<Vec<_>, String>>()?;
        
        // Update phase to scanning
        *phase_for_scan.lock().unwrap() = "scanning".to_string();
        
        // Optimized reverse map with sorted keys for binary search
        struct OptimizedReverseMap {
            sorted_targets: Vec<u64>,
            map: HashMap<u64, Vec<(u64, Option<(u32, u32)>)>>,
        }
        
        // Build reverse maps in parallel
        let reverse_maps: Vec<OptimizedReverseMap> = all_pointer_maps
            .par_iter()
            .map(|pm| {
                let mut map: HashMap<u64, Vec<(u64, Option<(u32, u32)>)>> = HashMap::new();
                for (target, pointers) in &pm.pointers {
                    for (ptr_addr, static_data) in pointers {
                        map.entry(*target).or_default().push((*ptr_addr, *static_data));
                    }
                }
                let mut sorted_targets: Vec<u64> = map.keys().cloned().collect();
                sorted_targets.sort_unstable();
                OptimizedReverseMap { sorted_targets, map }
            })
            .collect();
        
        #[derive(Clone, Debug, Hash, Eq, PartialEq)]
        struct NormalizedChain {
            base_module: String,
            base_offset: u32,
            offsets: Vec<i64>,
        }
        
        // Parallel BFS chain finder using level-by-level parallelism
        fn find_chains_parallel(
            target_addr: u64,
            reverse_map: &OptimizedReverseMap,
            pointer_map: &PointerMapData,
            max_depth: u32,
            max_offset: u32,
            max_chains: usize,
            nodes_counter: &Arc<AtomicU64>,
            chains_counter: &Arc<AtomicU64>,
            candidate_filter: Option<&HashSet<NormalizedChain>>,
        ) -> Vec<NormalizedChain> {
            let chains: Arc<Mutex<Vec<NormalizedChain>>> = Arc::new(Mutex::new(Vec::new()));
            let visited: Arc<Mutex<HashMap<u64, usize>>> = Arc::new(Mutex::new(HashMap::new()));
            let found_enough = Arc::new(AtomicBool::new(false));
            
            // Start with target address
            let mut current_level: Vec<(u64, Vec<i64>)> = vec![(target_addr, vec![])];
            
            for depth in 0..max_depth as usize {
                if current_level.is_empty() || found_enough.load(Ordering::Relaxed) {
                    break;
                }
                
                // Check for cancellation
                if PTRSCAN_CANCEL.load(Ordering::Relaxed) {
                    break;
                }
                
                // Process current level in parallel
                let next_level: Vec<(u64, Vec<i64>)> = current_level
                    .par_iter()
                    .flat_map(|(current_addr, offsets)| {
                        if found_enough.load(Ordering::Relaxed) || PTRSCAN_CANCEL.load(Ordering::Relaxed) {
                            return vec![];
                        }
                        
                        let current_addr = *current_addr;
                        let current_depth = offsets.len();
                        
                        // Update progress
                        nodes_counter.fetch_add(1, Ordering::Relaxed);
                        
                        // Check visited
                        {
                            let mut visited_lock = visited.lock().unwrap();
                            if let Some(&prev_depth) = visited_lock.get(&current_addr) {
                                if prev_depth <= current_depth {
                                    return vec![];
                                }
                            }
                            visited_lock.insert(current_addr, current_depth);
                        }
                        
                        // Binary search for range
                        let range_start = current_addr.saturating_sub(max_offset as u64);
                        let start_idx = reverse_map.sorted_targets.partition_point(|&x| x < range_start);
                        
                        let mut local_next: Vec<(u64, Vec<i64>)> = Vec::new();
                        
                        for &pointed_addr in &reverse_map.sorted_targets[start_idx..] {
                            if pointed_addr > current_addr || found_enough.load(Ordering::Relaxed) {
                                break;
                            }
                            
                            if let Some(ptrs) = reverse_map.map.get(&pointed_addr) {
                                let delta = (current_addr as i64) - (pointed_addr as i64);
                                
                                for (ptr_addr, static_data) in ptrs {
                                    let mut new_offsets = vec![delta];
                                    new_offsets.extend(offsets.iter().copied());
                                    
                                    if new_offsets.len() > max_depth as usize {
                                        continue;
                                    }
                                    
                                    if let Some((module_idx, module_offset)) = static_data {
                                        let module_name = if (*module_idx as usize) < pointer_map.modules.len() {
                                            pointer_map.modules[*module_idx as usize].name.clone()
                                        } else {
                                            format!("module_{}", module_idx)
                                        };
                                        
                                        let chain = NormalizedChain {
                                            base_module: module_name,
                                            base_offset: *module_offset,
                                            offsets: new_offsets.clone(),
                                        };
                                        
                                        let should_add = match candidate_filter {
                                            Some(filter) => filter.contains(&chain),
                                            None => true,
                                        };
                                        
                                        if should_add {
                                            let mut chains_lock = chains.lock().unwrap();
                                            chains_lock.push(chain);
                                            chains_counter.fetch_add(1, Ordering::Relaxed);
                                            if chains_lock.len() >= max_chains {
                                                found_enough.store(true, Ordering::Relaxed);
                                                return vec![];
                                            }
                                        }
                                    } else if depth + 1 < max_depth as usize {
                                        local_next.push((*ptr_addr, new_offsets));
                                    }
                                }
                            }
                        }
                        
                        local_next
                    })
                    .collect();
                
                current_level = next_level;
            }
            
            Arc::try_unwrap(chains).unwrap().into_inner().unwrap()
        }
        
        // Reset counters for first file
        nodes_for_scan.store(0, Ordering::Relaxed);
        chains_for_scan.store(0, Ordering::Relaxed);
        file_idx_for_scan.store(0, Ordering::Relaxed);
        
        // Find chains in first file
        let first_chains = find_chains_parallel(
            target_addresses[0],
            &reverse_maps[0],
            &all_pointer_maps[0],
            max_depth,
            max_offset,
            max_results * 10,
            &nodes_for_scan,
            &chains_for_scan,
            None,
        );
        
        if first_chains.is_empty() {
            complete_for_scan.store(true, Ordering::Relaxed);
            return Ok(vec![]);
        }
        
        // Check for cancellation after first file
        if PTRSCAN_CANCEL.load(Ordering::Relaxed) {
            complete_for_scan.store(true, Ordering::Relaxed);
            return Err("Scan cancelled".to_string());
        }
        
        let mut candidate_chains: HashSet<NormalizedChain> = first_chains.into_iter().collect();
        
        // Filter with subsequent files
        for (file_idx, target_addr) in target_addresses.iter().enumerate().skip(1) {
            if candidate_chains.is_empty() {
                break;
            }
            
            // Check for cancellation
            if PTRSCAN_CANCEL.load(Ordering::Relaxed) {
                complete_for_scan.store(true, Ordering::Relaxed);
                return Err("Scan cancelled".to_string());
            }
            
            // Reset counters for this file
            nodes_for_scan.store(0, Ordering::Relaxed);
            chains_for_scan.store(0, Ordering::Relaxed);
            file_idx_for_scan.store(file_idx as u64, Ordering::Relaxed);
            
            let file_chains = find_chains_parallel(
                *target_addr,
                &reverse_maps[file_idx],
                &all_pointer_maps[file_idx],
                max_depth,
                max_offset,
                max_results * 10,
                &nodes_for_scan,
                &chains_for_scan,
                Some(&candidate_chains),
            );
            
            let file_chain_set: HashSet<NormalizedChain> = file_chains.into_iter().collect();
            candidate_chains = candidate_chains.intersection(&file_chain_set).cloned().collect();
        }
        
        complete_for_scan.store(true, Ordering::Relaxed);
        
        // Convert to results
        let results: Vec<PointerScanResult> = candidate_chains
            .iter()
            .take(100)
            .map(|chain| {
                let mut result_chain: Vec<PointerChainStep> = vec![PointerChainStep {
                    module: Some(chain.base_module.clone()),
                    offset: chain.base_offset as i64,
                }];
                
                for &offset in &chain.offsets {
                    result_chain.push(PointerChainStep {
                        module: None,
                        offset,
                    });
                }
                
                PointerScanResult {
                    chain: result_chain,
                    final_address: format!("0x{:X}", target_addresses[0]),
                }
            })
            .collect();
        
        Ok::<Vec<PointerScanResult>, String>(results)
    }).await.map_err(|e| format!("Task join error: {}", e))??;
    
    // Signal completion and wait for progress thread
    scan_complete.store(true, Ordering::Relaxed);
    let _ = progress_thread.join();
    
    // Emit final progress
    let _ = app_handle.emit("ptr-scan-progress", serde_json::json!({
        "nodesProcessed": nodes_counter.load(std::sync::atomic::Ordering::Relaxed),
        "chainsFound": chains_counter.load(std::sync::atomic::Ordering::Relaxed),
        "fileIndex": files.len() - 1,
        "totalFiles": files.len(),
        "phase": "complete"
    }));
    
    Ok(result)
}

/// Cancel an ongoing pointer scan
#[tauri::command]
fn cancel_pointer_scan() -> Result<bool, String> {
    use std::sync::atomic::Ordering;
    PTRSCAN_CANCEL.store(true, Ordering::Relaxed);
    Ok(true)
}

struct ModuleInfo {
    name: String,
    #[allow(dead_code)]
    base_address: u64,
    #[allow(dead_code)]
    size: u32,
}

struct PointerMapData {
    modules: Vec<ModuleInfo>,
    pointers: HashMap<u64, Vec<(u64, Option<(u32, u32)>)>>, // target -> [(source_addr, (module_idx, offset))]
}

fn parse_pointer_map(data: &[u8]) -> Result<PointerMapData, String> {
    let mut cursor = 0;
    
    // Check magic "DPTR"
    if data.len() < 8 {
        return Err("Invalid PointerMap: too short".to_string());
    }
    if &data[0..4] != b"DPTR" {
        return Err("Invalid PointerMap: wrong magic".to_string());
    }
    cursor += 4;
    
    // Version
    let _version = u32::from_le_bytes(data[cursor..cursor+4].try_into().unwrap());
    cursor += 4;
    
    // Number of modules
    let module_count = u32::from_le_bytes(data[cursor..cursor+4].try_into().unwrap()) as usize;
    cursor += 4;
    
    let mut modules = Vec::with_capacity(module_count);
    for _ in 0..module_count {
        let name_len = u32::from_le_bytes(data[cursor..cursor+4].try_into().unwrap()) as usize;
        cursor += 4;
        
        let name = String::from_utf8_lossy(&data[cursor..cursor+name_len]).to_string();
        cursor += name_len;
        
        let base_address = u64::from_le_bytes(data[cursor..cursor+8].try_into().unwrap());
        cursor += 8;
        
        let size = i32::from_le_bytes(data[cursor..cursor+4].try_into().unwrap()) as u32;
        cursor += 4;
        
        modules.push(ModuleInfo { name, base_address, size });
    }
    
    // Number of unique targets
    let target_count = u64::from_le_bytes(data[cursor..cursor+8].try_into().unwrap()) as usize;
    cursor += 8;
    
    // Total pointer count
    let _total_pointers = u64::from_le_bytes(data[cursor..cursor+8].try_into().unwrap());
    cursor += 8;
    
    // Read pointer entries
    let mut pointers: HashMap<u64, Vec<(u64, Option<(u32, u32)>)>> = HashMap::with_capacity(target_count);
    
    for _ in 0..target_count {
        if cursor + 12 > data.len() {
            break;
        }
        
        let target_value = u64::from_le_bytes(data[cursor..cursor+8].try_into().unwrap());
        cursor += 8;
        
        let ptr_count = u32::from_le_bytes(data[cursor..cursor+4].try_into().unwrap()) as usize;
        cursor += 4;
        
        let mut ptrs = Vec::with_capacity(ptr_count);
        for _ in 0..ptr_count {
            if cursor + 9 > data.len() {
                break;
            }
            
            let ptr_addr = u64::from_le_bytes(data[cursor..cursor+8].try_into().unwrap());
            cursor += 8;
            
            let has_static = data[cursor] != 0;
            cursor += 1;
            
            let static_data = if has_static {
                if cursor + 8 > data.len() {
                    break;
                }
                let module_idx = u32::from_le_bytes(data[cursor..cursor+4].try_into().unwrap());
                cursor += 4;
                let offset = u32::from_le_bytes(data[cursor..cursor+4].try_into().unwrap());
                cursor += 4;
                Some((module_idx, offset))
            } else {
                None
            };
            
            ptrs.push((ptr_addr, static_data));
        }
        
        pointers.insert(target_value, ptrs);
    }
    
    Ok(PointerMapData { modules, pointers })
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_opener::init())
        .plugin(tauri_plugin_shell::init())
        .manage(state::AppStateType::new(std::sync::Mutex::new(state::AppState::default())))
        .manage(state::DebuggerSidebarCacheType::new(std::sync::Mutex::new(state::DebuggerSidebarCache::default())))
        .invoke_handler(tauri::generate_handler![
            greet,
            set_server_connection,
            set_auth_token,
            read_memory,
            filter_memory_native,
            lookup_memory_native,
            unknown_scan_native,
            init_unknown_scan_progress,
            get_unknown_scan_progress,
            load_unknown_scan_results,
            clear_unknown_scan,
            init_unknown_scan_file,
            append_unknown_scan_chunk,
            finalize_unknown_scan_file,
            get_unknown_scan_file_info,
            disassemble_memory,
            disassemble_memory_direct,
            demangle_symbols,
            state::get_app_state,
            state::update_app_state,
            state::update_single_state,
            state::get_connection_state,
            state::get_debug_state,
            state::add_exceptions,
            state::get_exceptions,
            state::get_watchpoint_exceptions,
            state::clear_exceptions,
            state::clear_watchpoint_exceptions,
            // Trace session commands
            state::start_trace_session,
            state::add_trace_entry,
            state::add_trace_entries_batch,
            state::get_trace_entries,
            state::get_trace_session,
            state::stop_trace_session,
            state::set_trace_tracked_thread,
            state::clear_trace_entries,
            // Graph view commands
            state::store_graph_view_data,
            state::get_graph_view_data,
            state::clear_graph_view_data,
            // Trace file commands
            state::open_trace_file_dialog,
            state::read_trace_file,
            // DebuggerSidebar cache commands
            state::get_sidebar_cache,
            state::set_sidebar_modules,
            state::set_sidebar_symbols,
            state::set_sidebar_ghidra_functions,
            state::set_sidebar_ghidra_data,
            state::clear_sidebar_cache,
            // Ghidra integration commands
            download_library_file,
            download_server_file,
            upload_file_to_server,
            analyze_with_ghidra,
            ghidra_decompile,
            ghidra_get_xrefs,
            ghidra_get_functions,
            check_ghidra_analysis,
            path_exists,
            // Ghidra SQLite database commands
            save_ghidra_functions_to_db,
            get_ghidra_functions_from_db,
            is_module_analyzed_in_db,
            get_module_info_from_db,
            save_ghidra_functions,
            get_ghidra_functions,
            save_decompile_cache,
            get_decompile_cache,
            save_xref_cache,
            get_xref_cache,
            clear_ghidra_cache,
            // Ghidra server mode commands
            start_ghidra_server,
            stop_ghidra_server,
            check_ghidra_server,
            get_ghidra_server_logs,
            ghidra_server_decompile,
            ghidra_server_xrefs,
            ghidra_server_function_info,
            ghidra_server_cfg,
            ghidra_server_data,
            ghidra_analyze_reachability,
            read_local_text_file,
            select_folder_dialog,
            save_binary_file_dialog,
            // Pointer scan commands
            open_pointermap_files_dialog,
            run_pointer_scan,
            cancel_pointer_scan,
            // WASM analysis commands
            save_wasm_binary,
            list_wasm_files,
            analyze_wasm_binary,
            disassemble_wasm_function,
            open_wasm_modules_directory
        ])
        .setup(|app| {
            if let Err(e) = init_ghidra_db() {
                eprintln!("Failed to initialize Ghidra database: {e}");
            }
            
            if let Some(window) = app.get_webview_window("main") {
                if let Ok(monitor_opt) = window.current_monitor() {
                    if let Some(monitor) = monitor_opt {
                        let screen = monitor.size();
                        let mut target_w: u32 = 1400;
                        let mut target_h: u32 = 1000;
                        let margin_w: u32 = 40;
                        let margin_h: u32 = 80;

                        if screen.width < target_w + margin_w {
                            target_w = (screen.width.saturating_sub(margin_w)).max(1024);
                        }
                        if screen.height < target_h + margin_h {
                            target_h = (screen.height.saturating_sub(margin_h)).max(680);
                        }

                        if let Err(e) = window.set_size(Size::Physical(PhysicalSize { width: target_w, height: target_h })) {
                            eprintln!("Failed to set dynamic window size: {e}");
                        } else {
                            let _ = window.center();
                        }
                    }
                }
            }
            Ok(())
        })
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}

```

`src/client/src-tauri/src/main.rs`:

```rs
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

fn main() {
    // Set WEBKIT_DISABLE_COMPOSITING_MODE=1 when running on Linux (Host OS) to fix rendering issues
    #[cfg(target_os = "linux")]
    std::env::set_var("WEBKIT_DISABLE_COMPOSITING_MODE", "1");

    dyna_dbg_lib::run()
}

```

`src/client/src-tauri/src/state.rs`:

```rs
use serde::{Deserialize, Serialize};
use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use tauri::{AppHandle, Manager, Emitter};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExceptionData {
    pub exception_type: String, // "watchpoint", "breakpoint", "singlestep"
    pub address: String,
    pub instruction: Option<String>,
    pub timestamp: String,
    pub thread_id: Option<u64>,
    pub watchpoint_id: Option<String>,
    pub memory_address: Option<u64>,
    pub singlestep_mode: Option<u64>,
    pub registers: serde_json::Value,
    pub bytecode: Option<String>,
    pub opcode: Option<String>,
    pub pc: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TraceEntryData {
    pub id: u32,
    pub address: String,
    pub instruction: String,
    pub opcode: String,
    pub operands: String,
    pub registers: serde_json::Value,
    pub depth: u32,
    pub is_call: bool,
    pub is_return: bool,
    pub function_name: Option<String>,
    pub timestamp: u64,
    pub library_expression: Option<String>,
    pub target_address: String, // trace session identifier
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TraceSession {
    pub target_address: String,
    pub total_count: u32,
    pub current_count: u32,
    pub is_active: bool,
    pub started_at: u64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tracked_thread_id: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessInfo {
    pub pid: u32,
    pub processname: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerInfo {
    pub git_hash: String,
    pub arch: String,
    pub pid: u32,
    pub mode: String,
    pub target_os: String,
    pub build_timestamp: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppInfo {
    pub name: String,
    pub pid: u32,
    pub icon: Option<String>,
    pub arch: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModuleInfo {
    pub modulename: String,
    pub base: u64,
    pub size: u64,
    pub path: Option<String>,
    pub is_64bit: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WatchpointInfo {
    pub id: String,
    pub address: String,
    pub size: u32,
    #[serde(rename = "accessType")]
    pub access_type: WatchpointAccessType,
    #[serde(rename = "hitCount")]
    pub hit_count: u32,
    #[serde(rename = "createdAt")]
    pub created_at: String, // ISO 8601 timestamp
    pub description: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum WatchpointAccessType {
    #[serde(rename = "r")]
    Read,
    #[serde(rename = "w")]
    Write,
    #[serde(rename = "rw")]
    ReadWrite,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppState {
    #[serde(rename = "serverConnected")]
    pub server_connected: bool,
    #[serde(rename = "debuggerConnected")]
    pub debugger_connected: bool,
    #[serde(rename = "connectionHost")]
    pub connection_host: Option<String>,
    #[serde(rename = "connectionPort")]
    pub connection_port: Option<u16>,
    
    #[serde(rename = "authToken")]
    pub auth_token: Option<String>,
    #[serde(rename = "serverSessionId")]
    pub server_session_id: Option<String>,
    
    #[serde(rename = "attachedProcess")]
    pub attached_process: Option<ProcessInfo>,
    #[serde(rename = "serverInfo")]
    pub server_info: Option<ServerInfo>,
    #[serde(rename = "attachedAppInfo")]
    pub attached_app_info: Option<AppInfo>,
    #[serde(rename = "attachedModules")]
    pub attached_modules: Vec<ModuleInfo>,
    
    #[serde(rename = "spawnSuspended")]
    pub spawn_suspended: bool,
    
    #[serde(rename = "isInBreakState")]
    pub is_in_break_state: bool,
    #[serde(rename = "currentThreadId")]
    pub current_thread_id: Option<u32>,
    #[serde(rename = "currentBreakAddress")]
    pub current_break_address: Option<String>,
    #[serde(rename = "currentRegisterData")]
    pub current_register_data: HashMap<String, String>,
    
    #[serde(rename = "activeBreakpoints")]
    pub active_breakpoints: Vec<String>,
    #[serde(rename = "softwareBreakpoints")]
    pub software_breakpoints: Vec<String>,
    pub watchpoints: Vec<WatchpointInfo>,
    
    #[serde(rename = "showRegisters")]
    pub show_registers: bool,
    #[serde(rename = "showToolbar")]
    pub show_toolbar: bool,
    #[serde(rename = "sidebarWidth")]
    pub sidebar_width: u32,
    
    #[serde(skip)]
    pub exception_store: Vec<ExceptionData>,
    
    #[serde(skip)]
    pub trace_store: Vec<TraceEntryData>,
    
    #[serde(skip)]
    pub active_trace_session: Option<TraceSession>,
    
    #[serde(rename = "lastUpdate")]
    pub last_update: u64,
    
    #[serde(skip)]
    pub graph_view_store: HashMap<String, GraphViewData>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GraphViewData {
    pub address: String,
    pub function_name: String,
    pub instructions: String, // JSON string of instructions
    pub function_start_address: String,
    pub function_end_address: String,
    // Ghidra CFG mode fields (optional)
    #[serde(default)]
    pub library_path: String,
    #[serde(default)]
    pub function_offset: String,
    // dbgsrv URL for Z3 reachability analysis
    #[serde(default)]
    pub server_url: String,
    // Authentication token for dbgsrv
    #[serde(default)]
    pub auth_token: String,
}

impl Default for AppState {
    fn default() -> Self {
        Self {
            server_connected: false,
            debugger_connected: false,
            connection_host: None,
            connection_port: None,
            auth_token: None,
            server_session_id: None,
            attached_process: None,
            server_info: None,
            attached_app_info: None,
            attached_modules: Vec::new(),
            spawn_suspended: false,
            is_in_break_state: false,
            current_thread_id: None,
            current_break_address: None,
            current_register_data: HashMap::new(),
            active_breakpoints: Vec::new(),
            software_breakpoints: Vec::new(),
            watchpoints: Vec::new(),
            show_registers: false,
            show_toolbar: true,
            sidebar_width: 240,
            exception_store: Vec::new(),
            trace_store: Vec::new(),
            active_trace_session: None,
            graph_view_store: HashMap::new(),
            last_update: 0,
        }
    }
}

pub type AppStateType = Arc<Mutex<AppState>>;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StateUpdateEvent {
    pub field: String,
    pub value: serde_json::Value,
    pub timestamp: u64,
}

impl AppState {
    pub fn current_timestamp() -> u64 {
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_millis() as u64
    }

    pub fn touch(&mut self) {
        self.last_update = Self::current_timestamp();
    }

    pub fn get_field_as_json(&self, field: &str) -> Option<serde_json::Value> {
        match field {
            "serverConnected" => Some(serde_json::json!(self.server_connected)),
            "debuggerConnected" => Some(serde_json::json!(self.debugger_connected)),
            "connectionHost" => Some(serde_json::json!(self.connection_host)),
            "connectionPort" => Some(serde_json::json!(self.connection_port)),
            "authToken" => Some(serde_json::json!(self.auth_token)),
            "serverSessionId" => Some(serde_json::json!(self.server_session_id)),
            "isInBreakState" => Some(serde_json::json!(self.is_in_break_state)),
            "currentThreadId" => Some(serde_json::json!(self.current_thread_id)),
            "currentBreakAddress" => Some(serde_json::json!(self.current_break_address)),
            "currentRegisterData" => serde_json::to_value(&self.current_register_data).ok(),
            "attachedProcess" => serde_json::to_value(&self.attached_process).ok(),
            "serverInfo" => serde_json::to_value(&self.server_info).ok(),
            "attachedAppInfo" => serde_json::to_value(&self.attached_app_info).ok(),
            "attachedModules" => serde_json::to_value(&self.attached_modules).ok(),
            "spawnSuspended" => Some(serde_json::json!(self.spawn_suspended)),
            "activeBreakpoints" => serde_json::to_value(&self.active_breakpoints).ok(),
            "softwareBreakpoints" => serde_json::to_value(&self.software_breakpoints).ok(),
            "watchpoints" => serde_json::to_value(&self.watchpoints).ok(),
            "showRegisters" => Some(serde_json::json!(self.show_registers)),
            "showToolbar" => Some(serde_json::json!(self.show_toolbar)),
            "sidebarWidth" => Some(serde_json::json!(self.sidebar_width)),
            _ => None,
        }
    }

    pub fn update_field(&mut self, field: &str, value: &serde_json::Value) -> Result<(), String> {
        match field {
            "serverConnected" => {
                if let Some(val) = value.as_bool() {
                    self.server_connected = val;
                }
            },
            "debuggerConnected" => {
                if let Some(val) = value.as_bool() {
                    self.debugger_connected = val;
                }
            },
            "connectionHost" => {
                self.connection_host = value.as_str().map(|s| s.to_string());
            },
            "connectionPort" => {
                if let Some(val) = value.as_u64() {
                    self.connection_port = Some(val as u16);
                } else if value.is_null() {
                    self.connection_port = None;
                }
            },
            "authToken" => {
                if value.is_null() {
                    self.auth_token = None;
                } else {
                    self.auth_token = value.as_str().map(|s| s.to_string());
                }
            },
            "serverSessionId" => {
                if value.is_null() {
                    self.server_session_id = None;
                } else {
                    self.server_session_id = value.as_str().map(|s| s.to_string());
                }
            },
            "isInBreakState" => {
                if let Some(val) = value.as_bool() {
                    self.is_in_break_state = val;
                }
            },
            "currentThreadId" => {
                if let Some(val) = value.as_u64() {
                    self.current_thread_id = Some(val as u32);
                } else if value.is_null() {
                    self.current_thread_id = None;
                }
            },
            "currentBreakAddress" => {
                self.current_break_address = value.as_str().map(|s| s.to_string());
            },
            "currentRegisterData" => {
                if let Ok(registers) = serde_json::from_value::<HashMap<String, String>>(value.clone()) {
                    self.current_register_data = registers;
                }
            },
            "attachedProcess" => {
                if value.is_null() {
                    self.attached_process = None;
                } else if let Ok(process) = serde_json::from_value::<ProcessInfo>(value.clone()) {
                    self.attached_process = Some(process);
                }
            },
            "serverInfo" => {
                if value.is_null() {
                    self.server_info = None;
                } else if let Ok(info) = serde_json::from_value::<ServerInfo>(value.clone()) {
                    self.server_info = Some(info);
                }
            },
            "attachedAppInfo" => {
                if value.is_null() {
                    self.attached_app_info = None;
                } else if let Ok(info) = serde_json::from_value::<AppInfo>(value.clone()) {
                    self.attached_app_info = Some(info);
                }
            },
            "attachedModules" => {
                if let Ok(modules) = serde_json::from_value::<Vec<ModuleInfo>>(value.clone()) {
                    self.attached_modules = modules;
                }
            },
            "spawnSuspended" => {
                if let Some(val) = value.as_bool() {
                    self.spawn_suspended = val;
                }
            },
            "activeBreakpoints" => {
                if let Ok(breakpoints) = serde_json::from_value::<Vec<String>>(value.clone()) {
                    self.active_breakpoints = breakpoints;
                }
            },
            "softwareBreakpoints" => {
                if let Ok(breakpoints) = serde_json::from_value::<Vec<String>>(value.clone()) {
                    self.software_breakpoints = breakpoints;
                }
            },
            "watchpoints" => {
                if let Ok(watchpoints) = serde_json::from_value::<Vec<WatchpointInfo>>(value.clone()) {
                    self.watchpoints = watchpoints;
                }
            },
            "showRegisters" => {
                if let Some(val) = value.as_bool() {
                    self.show_registers = val;
                }
            },
            "showToolbar" => {
                if let Some(val) = value.as_bool() {
                    self.show_toolbar = val;
                }
            },
            "sidebarWidth" => {
                if let Some(val) = value.as_u64() {
                    self.sidebar_width = val as u32;
                }
            },
            _ => {
                return Err(format!("Unknown state field: {}", field));
            }
        }
        
        self.touch();
        Ok(())
    }
}

#[tauri::command]
pub async fn get_app_state(state: tauri::State<'_, AppStateType>) -> Result<AppState, String> {
    let state_guard = state.lock().map_err(|e| format!("Failed to lock state: {}", e))?;
    Ok(state_guard.clone())
}

#[tauri::command]
pub async fn update_app_state(
    app: AppHandle,
    state: tauri::State<'_, AppStateType>,
    updates: HashMap<String, serde_json::Value>
) -> Result<(), String> {
    let timestamp = AppState::current_timestamp();
    let mut changed_fields: Vec<(String, serde_json::Value)> = Vec::new();

    {
        let mut state_guard = state.lock().map_err(|e| format!("Failed to lock state: {}", e))?;
        
        for (field, value) in &updates {
            // Check if the value actually changed before updating
            let current_value = state_guard.get_field_as_json(field);
            if current_value.as_ref() != Some(value) {
                if let Err(e) = state_guard.update_field(field, value) {
                    eprintln!("Failed to update field {}: {}", field, e);
                } else {
                    changed_fields.push((field.clone(), value.clone()));
                }
            }
        }
    }

    for (field, value) in changed_fields {
        let event = StateUpdateEvent {
            field: field.clone(),
            value: value.clone(),
            timestamp,
        };
        
        for window in app.webview_windows().values() {
            if let Err(e) = window.emit("state-updated", &event) {
                eprintln!("Failed to emit state update event to window: {}", e);
            }
        }
    }
    
    Ok(())
}

#[tauri::command]
pub async fn update_single_state(
    app: AppHandle,
    state: tauri::State<'_, AppStateType>,
    field: String,
    value: serde_json::Value
) -> Result<(), String> {
    let mut updates = HashMap::new();
    updates.insert(field, value);
    update_app_state(app, state, updates).await
}

#[tauri::command]
pub async fn get_connection_state(state: tauri::State<'_, AppStateType>) -> Result<serde_json::Value, String> {
    let state_guard = state.lock().map_err(|e| format!("Failed to lock state: {}", e))?;
    Ok(serde_json::json!({
        "serverConnected": state_guard.server_connected,
        "debuggerConnected": state_guard.debugger_connected,
        "connectionHost": state_guard.connection_host,
        "connectionPort": state_guard.connection_port,
        "isConnected": state_guard.server_connected && state_guard.debugger_connected
    }))
}

#[tauri::command]
pub async fn get_debug_state(state: tauri::State<'_, AppStateType>) -> Result<serde_json::Value, String> {
    let state_guard = state.lock().map_err(|e| format!("Failed to lock state: {}", e))?;
    Ok(serde_json::json!({
        "isInBreakState": state_guard.is_in_break_state,
        "currentThreadId": state_guard.current_thread_id,
        "currentBreakAddress": state_guard.current_break_address,
        "currentRegisterData": state_guard.current_register_data,
        "activeBreakpoints": state_guard.active_breakpoints,
        "softwareBreakpoints": state_guard.software_breakpoints,
        "watchpoints": state_guard.watchpoints
    }))
}

#[tauri::command]
pub async fn add_exceptions(
    app: AppHandle,
    state: tauri::State<'_, AppStateType>,
    exceptions: Vec<ExceptionData>
) -> Result<(), String> {
    {
        let mut state_guard = state.lock().map_err(|e| format!("Failed to lock state: {}", e))?;
        state_guard.exception_store.extend(exceptions.clone());
        state_guard.touch();
    }
    
    for window in app.webview_windows().values() {
        if let Err(e) = window.emit("exceptions-added", &exceptions) {
            eprintln!("Failed to emit exceptions-added event to window: {}", e);
        }
    }
    
    Ok(())
}

#[tauri::command]
pub async fn get_exceptions(
    state: tauri::State<'_, AppStateType>,
    exception_type_filter: Option<Vec<String>>,
    limit: Option<usize>
) -> Result<Vec<ExceptionData>, String> {
    let state_guard = state.lock().map_err(|e| format!("Failed to lock state: {}", e))?;
    
    let mut exceptions: Vec<ExceptionData> = state_guard.exception_store.clone();
    
    if let Some(types) = exception_type_filter {
        exceptions.retain(|ex| types.contains(&ex.exception_type));
    }
    
    if let Some(limit_count) = limit {
        let start = exceptions.len().saturating_sub(limit_count);
        exceptions = exceptions[start..].to_vec();
    }
    
    Ok(exceptions)
}

#[tauri::command]
pub async fn get_watchpoint_exceptions(
    state: tauri::State<'_, AppStateType>,
    watchpoint_id: Option<String>,
    limit: Option<usize>
) -> Result<Vec<ExceptionData>, String> {
    let state_guard = state.lock().map_err(|e| format!("Failed to lock state: {}", e))?;
    
    let mut exceptions: Vec<ExceptionData> = state_guard.exception_store
        .iter()
        .filter(|ex| ex.exception_type == "watchpoint")
        .cloned()
        .collect();
    
    if let Some(id) = watchpoint_id {
        exceptions.retain(|ex| ex.watchpoint_id.as_ref() == Some(&id));
    }
    
    if let Some(limit_count) = limit {
        let start = exceptions.len().saturating_sub(limit_count);
        exceptions = exceptions[start..].to_vec();
    }
    
    Ok(exceptions)
}

#[tauri::command]
pub async fn clear_exceptions(
    app: AppHandle,
    state: tauri::State<'_, AppStateType>,
    exception_type: Option<String>
) -> Result<(), String> {
    {
        let mut state_guard = state.lock().map_err(|e| format!("Failed to lock state: {}", e))?;
        
        if let Some(exc_type) = exception_type {
            state_guard.exception_store.retain(|ex| ex.exception_type != exc_type);
        } else {
            state_guard.exception_store.clear();
        }
        
        state_guard.touch();
    }
    
    for window in app.webview_windows().values() {
        if let Err(e) = window.emit("exceptions-cleared", &serde_json::json!({})) {
            eprintln!("Failed to emit exceptions-cleared event to window: {}", e);
        }
    }
    
    Ok(())
}

#[tauri::command]
pub async fn clear_watchpoint_exceptions(
    app: AppHandle,
    state: tauri::State<'_, AppStateType>,
    watchpoint_address: u64,
    watchpoint_size: u64,
) -> Result<(), String> {
    {
        let mut state_guard = state.lock().map_err(|e| format!("Failed to lock state: {}", e))?;
        
        state_guard.exception_store.retain(|ex| {
            if ex.exception_type != "watchpoint" {
                return true;
            }
            
            if let Some(memory_addr) = ex.memory_address {
                !(memory_addr >= watchpoint_address && memory_addr < watchpoint_address + watchpoint_size)
            } else {
                true
            }
        });
        
        state_guard.touch();
    }
    
    for window in app.webview_windows().values() {
        if let Err(e) = window.emit("watchpoint-exceptions-cleared", &serde_json::json!({
            "address": watchpoint_address,
            "size": watchpoint_size
        })) {
            eprintln!("Failed to emit watchpoint-exceptions-cleared event to window: {}", e);
        }
    }
    
    Ok(())
}

#[tauri::command]
pub async fn start_trace_session(
    app: AppHandle,
    state: tauri::State<'_, AppStateType>,
    target_address: String,
    total_count: u32,
) -> Result<(), String> {
    {
        let mut state_guard = state.lock().map_err(|e| format!("Failed to lock state: {}", e))?;
        
        state_guard.trace_store.clear();
        state_guard.active_trace_session = Some(TraceSession {
            target_address: target_address.clone(),
            total_count,
            current_count: 0,
            is_active: true,
            started_at: AppState::current_timestamp(),
            tracked_thread_id: None,
        });
        
        state_guard.touch();
    }
    
    for window in app.webview_windows().values() {
        if let Err(e) = window.emit("trace-session-started", &serde_json::json!({
            "targetAddress": target_address,
            "totalCount": total_count
        })) {
            eprintln!("Failed to emit trace-session-started event to window: {}", e);
        }
    }
    
    Ok(())
}

#[tauri::command]
pub async fn add_trace_entry(
    app: AppHandle,
    state: tauri::State<'_, AppStateType>,
    mut entry: TraceEntryData,
) -> Result<(), String> {
    let session_complete;
    let current_count;
    let total_count;
    let was_duplicate;
    
    {
        let mut state_guard = state.lock().map_err(|e| format!("Failed to lock state: {}", e))?;
        
        {
            let session = state_guard.active_trace_session.as_ref()
                .ok_or("No active trace session")?;
            
            if !session.is_active {
                return Err("Trace session is not active".to_string());
            }
        }
        
        let already_exists = state_guard.trace_store.iter().any(|existing| {
            existing.address == entry.address && existing.timestamp == entry.timestamp
        });
        
        if already_exists {
            was_duplicate = true;
            current_count = state_guard.active_trace_session.as_ref()
                .map(|s| s.current_count)
                .unwrap_or(0);
            total_count = state_guard.active_trace_session.as_ref()
                .map(|s| s.total_count)
                .unwrap_or(0);
            session_complete = false;
        } else {
            was_duplicate = false;
            
            if let Some(session) = state_guard.active_trace_session.as_mut() {
                session.current_count += 1;
                
                current_count = session.current_count;
                total_count = session.total_count;
                
                entry.id = current_count;
                
                session_complete = session.current_count >= session.total_count;
                if session_complete {
                    session.is_active = false;
                }
            } else {
                return Err("No active trace session".to_string());
            }
            
            state_guard.trace_store.push(entry.clone());
            
            state_guard.touch();
        }
    }
    
    if was_duplicate {
        return Ok(());
    }
    
    for window in app.webview_windows().values() {
        if let Err(e) = window.emit("trace-entry-added", &entry) {
            eprintln!("Failed to emit trace-entry-added event to window: {}", e);
        }
        
        if let Err(e) = window.emit("trace-progress", &serde_json::json!({
            "current": current_count,
            "total": total_count
        })) {
            eprintln!("Failed to emit trace-progress event to window: {}", e);
        }
    }
    
    if session_complete {
        for window in app.webview_windows().values() {
            if let Err(e) = window.emit("trace-session-complete", &serde_json::json!({
                "totalEntries": current_count
            })) {
                eprintln!("Failed to emit trace-session-complete event to window: {}", e);
            }
        }
    }
    
    Ok(())
}

#[tauri::command]
pub async fn add_trace_entries_batch(
    app: AppHandle,
    state: tauri::State<'_, AppStateType>,
    entries: Vec<TraceEntryData>,
) -> Result<(), String> {
    let session_complete;
    let current_count;
    let total_count;
    let added_entries: Vec<TraceEntryData>;
    
    {
        let mut state_guard = state.lock().map_err(|e| format!("Failed to lock state: {}", e))?;
        
        {
            let session = state_guard.active_trace_session.as_ref()
                .ok_or("No active trace session")?;
            
            if !session.is_active {
                return Err("Trace session is not active".to_string());
            }
        }
        let existing_keys: std::collections::HashSet<(String, u64)> = state_guard
            .trace_store
            .iter()
            .map(|e| (e.address.clone(), e.timestamp))
            .collect();
        
        let mut new_entries: Vec<TraceEntryData> = entries
            .into_iter()
            .filter(|e| !existing_keys.contains(&(e.address.clone(), e.timestamp)))
            .collect();
        
        if new_entries.is_empty() {
            current_count = state_guard.active_trace_session.as_ref()
                .map(|s| s.current_count)
                .unwrap_or(0);
            total_count = state_guard.active_trace_session.as_ref()
                .map(|s| s.total_count)
                .unwrap_or(0);
            session_complete = false;
            added_entries = Vec::new();
        } else {
            if let Some(session) = state_guard.active_trace_session.as_mut() {
                for entry in &mut new_entries {
                    session.current_count += 1;
                    entry.id = session.current_count;
                }
                
                current_count = session.current_count;
                total_count = session.total_count;
                
                session_complete = session.current_count >= session.total_count;
                if session_complete {
                    session.is_active = false;
                }
            } else {
                return Err("No active trace session".to_string());
            }
            
            state_guard.trace_store.extend(new_entries.clone());
            added_entries = new_entries;
            
            state_guard.touch();
        }
    }
    
    if !added_entries.is_empty() {
        for window in app.webview_windows().values() {
            if let Err(e) = window.emit("trace-entries-added", &added_entries) {
                eprintln!("Failed to emit trace-entries-added event to window: {}", e);
            }
            
            if let Err(e) = window.emit("trace-progress", &serde_json::json!({
                "current": current_count,
                "total": total_count
            })) {
                eprintln!("Failed to emit trace-progress event to window: {}", e);
            }
        }
    }
    
    if session_complete {
        for window in app.webview_windows().values() {
            if let Err(e) = window.emit("trace-session-complete", &serde_json::json!({
                "totalEntries": current_count
            })) {
                eprintln!("Failed to emit trace-session-complete event to window: {}", e);
            }
        }
    }
    
    Ok(())
}

#[tauri::command]
pub async fn get_trace_entries(
    state: tauri::State<'_, AppStateType>,
    target_address: Option<String>,
    limit: Option<usize>,
) -> Result<Vec<TraceEntryData>, String> {
    let state_guard = state.lock().map_err(|e| format!("Failed to lock state: {}", e))?;
    
    let mut entries: Vec<TraceEntryData> = state_guard.trace_store.clone();
    
    if let Some(addr) = target_address {
        entries.retain(|e| e.target_address == addr);
    }
    
    if let Some(limit_count) = limit {
        let start = entries.len().saturating_sub(limit_count);
        entries = entries[start..].to_vec();
    }
    
    Ok(entries)
}

#[tauri::command]
pub async fn get_trace_session(
    state: tauri::State<'_, AppStateType>,
) -> Result<Option<TraceSession>, String> {
    let state_guard = state.lock().map_err(|e| format!("Failed to lock state: {}", e))?;
    Ok(state_guard.active_trace_session.clone())
}

#[tauri::command]
pub async fn stop_trace_session(
    app: AppHandle,
    state: tauri::State<'_, AppStateType>,
) -> Result<(), String> {
    {
        let mut state_guard = state.lock().map_err(|e| format!("Failed to lock state: {}", e))?;
        
        if let Some(session) = state_guard.active_trace_session.as_mut() {
            session.is_active = false;
        }
        
        state_guard.touch();
    }
    
    for window in app.webview_windows().values() {
        if let Err(e) = window.emit("trace-session-stopped", &serde_json::json!({})) {
            eprintln!("Failed to emit trace-session-stopped event to window: {}", e);
        }
    }
    
    Ok(())
}

#[tauri::command]
pub async fn set_trace_tracked_thread(
    app: AppHandle,
    state: tauri::State<'_, AppStateType>,
    thread_id: u64,
) -> Result<(), String> {
    {
        let mut state_guard = state.lock().map_err(|e| format!("Failed to lock state: {}", e))?;
        
        if let Some(session) = state_guard.active_trace_session.as_mut() {
            if session.tracked_thread_id.is_none() {
                session.tracked_thread_id = Some(thread_id);
                state_guard.touch();
                
                for window in app.webview_windows().values() {
                    if let Err(e) = window.emit("trace-thread-tracked", &serde_json::json!({
                        "threadId": thread_id
                    })) {
                        eprintln!("Failed to emit trace-thread-tracked event: {}", e);
                    }
                }
            }
        } else {
            return Err("No active trace session".to_string());
        }
    }
    
    Ok(())
}

#[tauri::command]
pub async fn clear_trace_entries(
    app: AppHandle,
    state: tauri::State<'_, AppStateType>,
) -> Result<(), String> {
    {
        let mut state_guard = state.lock().map_err(|e| format!("Failed to lock state: {}", e))?;
        state_guard.trace_store.clear();
        state_guard.active_trace_session = None;
        state_guard.touch();
    }
    
    for window in app.webview_windows().values() {
        if let Err(e) = window.emit("trace-entries-cleared", &serde_json::json!({})) {
            eprintln!("Failed to emit trace-entries-cleared event to window: {}", e);
        }
    }
    
    Ok(())
}

#[tauri::command]
pub async fn store_graph_view_data(
    state: tauri::State<'_, AppStateType>,
    address: String,
    function_name: String,
    instructions: String,
    function_start_address: String,
    function_end_address: String,
    library_path: Option<String>,
    function_offset: Option<String>,
    server_url: Option<String>,
    auth_token: Option<String>,
) -> Result<(), String> {
    let mut state_guard = state.lock().map_err(|e| format!("Failed to lock state: {}", e))?;
    
    let data = GraphViewData {
        address: address.clone(),
        function_name,
        instructions,
        function_start_address,
        function_end_address,
        library_path: library_path.unwrap_or_default(),
        function_offset: function_offset.unwrap_or_default(),
        server_url: server_url.unwrap_or_default(),
        auth_token: auth_token.unwrap_or_default(),
    };
    
    state_guard.graph_view_store.insert(address, data);
    state_guard.touch();
    
    Ok(())
}

#[tauri::command]
pub async fn get_graph_view_data(
    state: tauri::State<'_, AppStateType>,
    address: String,
) -> Result<Option<GraphViewData>, String> {
    let state_guard = state.lock().map_err(|e| format!("Failed to lock state: {}", e))?;
    
    Ok(state_guard.graph_view_store.get(&address).cloned())
}

#[tauri::command]
pub async fn clear_graph_view_data(
    state: tauri::State<'_, AppStateType>,
    address: Option<String>,
) -> Result<(), String> {
    let mut state_guard = state.lock().map_err(|e| format!("Failed to lock state: {}", e))?;
    
    if let Some(addr) = address {
        state_guard.graph_view_store.remove(&addr);
    } else {
        state_guard.graph_view_store.clear();
    }
    
    state_guard.touch();
    Ok(())
}

#[tauri::command]
pub fn open_trace_file_dialog() -> Result<Option<String>, String> {
    use rfd::FileDialog;
    
    let file = FileDialog::new()
        .add_filter("DynaDbg Trace", &["dyntrace", "bin"])
        .add_filter("All Files", &["*"])
        .set_title("Select Trace File")
        .pick_file();
    
    Ok(file.map(|p| p.to_string_lossy().to_string()))
}

#[tauri::command]
pub async fn read_trace_file(path: String) -> Result<String, String> {
    use std::fs;
    use base64::{Engine as _, engine::general_purpose};
    
    let bytes = fs::read(&path).map_err(|e| format!("Failed to read file {}: {}", path, e))?;
    Ok(general_purpose::STANDARD.encode(&bytes))
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CachedModuleInfo {
    pub modulename: String,
    pub base: u64,
    pub size: u64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_64bit: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CachedSymbolInfo {
    pub address: String,
    pub name: String,
    pub size: u64,
    pub symbol_type: String,
    pub scope: String,
    pub module_base: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub line_number: Option<u32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_external: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_private_external: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_weak_def: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_weak_ref: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_thumb: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub section_index: Option<u32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub library_ordinal: Option<u32>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CachedGhidraFunction {
    pub name: String,
    pub address: String,
    pub size: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CachedGhidraDataItem {
    pub address: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub data_type: String,
    pub category: String, // "string" | "pointer" | "integer" | "float" | "struct" | "array" | "other"
    pub size: u64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct DebuggerSidebarCache {
    pub modules: Vec<CachedModuleInfo>,
    pub symbols: Vec<CachedSymbolInfo>,
    pub ghidra_functions: Vec<CachedGhidraFunction>,
    pub ghidra_data_items: Vec<CachedGhidraDataItem>,
    pub cached_process_pid: Option<u32>,
    pub cached_module_path: Option<String>,
    pub last_update: u64,
}

pub type DebuggerSidebarCacheType = Arc<Mutex<DebuggerSidebarCache>>;

#[tauri::command]
pub async fn get_sidebar_cache(
    cache: tauri::State<'_, DebuggerSidebarCacheType>,
) -> Result<DebuggerSidebarCache, String> {
    let cache_guard = cache.lock().map_err(|e| format!("Failed to lock cache: {}", e))?;
    Ok(cache_guard.clone())
}

#[tauri::command]
pub async fn set_sidebar_modules(
    cache: tauri::State<'_, DebuggerSidebarCacheType>,
    modules: Vec<CachedModuleInfo>,
    process_pid: u32,
) -> Result<(), String> {
    let mut cache_guard = cache.lock().map_err(|e| format!("Failed to lock cache: {}", e))?;
    cache_guard.modules = modules;
    cache_guard.cached_process_pid = Some(process_pid);
    cache_guard.last_update = AppState::current_timestamp();
    Ok(())
}

#[tauri::command]
pub async fn set_sidebar_symbols(
    cache: tauri::State<'_, DebuggerSidebarCacheType>,
    symbols: Vec<CachedSymbolInfo>,
    module_path: String,
) -> Result<(), String> {
    let mut cache_guard = cache.lock().map_err(|e| format!("Failed to lock cache: {}", e))?;
    cache_guard.symbols = symbols;
    cache_guard.cached_module_path = Some(module_path);
    cache_guard.last_update = AppState::current_timestamp();
    Ok(())
}

#[tauri::command]
pub async fn set_sidebar_ghidra_functions(
    cache: tauri::State<'_, DebuggerSidebarCacheType>,
    functions: Vec<CachedGhidraFunction>,
    module_path: String,
) -> Result<(), String> {
    let mut cache_guard = cache.lock().map_err(|e| format!("Failed to lock cache: {}", e))?;
    cache_guard.ghidra_functions = functions;
    cache_guard.cached_module_path = Some(module_path);
    cache_guard.last_update = AppState::current_timestamp();
    Ok(())
}

#[tauri::command]
pub async fn set_sidebar_ghidra_data(
    cache: tauri::State<'_, DebuggerSidebarCacheType>,
    data_items: Vec<CachedGhidraDataItem>,
    module_path: String,
) -> Result<(), String> {
    let mut cache_guard = cache.lock().map_err(|e| format!("Failed to lock cache: {}", e))?;
    cache_guard.ghidra_data_items = data_items;
    cache_guard.cached_module_path = Some(module_path);
    cache_guard.last_update = AppState::current_timestamp();
    Ok(())
}

#[tauri::command]
pub async fn clear_sidebar_cache(
    cache: tauri::State<'_, DebuggerSidebarCacheType>,
) -> Result<(), String> {
    let mut cache_guard = cache.lock().map_err(|e| format!("Failed to lock cache: {}", e))?;
    *cache_guard = DebuggerSidebarCache::default();
    Ok(())
}

```

`src/client/src-tauri/tauri.conf.json`:

```json
{
  "$schema": "https://schema.tauri.app/config/2",
  "productName": "DynaDbg",
  "version": "0.1.0",
  "identifier": "com.doranekosystems.DynaDbg",
  "build": {
    "beforeDevCommand": "npm run dev",
    "devUrl": "http://localhost:1420",
    "beforeBuildCommand": "npm run build",
    "frontendDist": "../dist"
  },
  "app": {
    "withGlobalTauri": true,
    "windows": [
      {
        "label": "main",
        "title": "DynaDbg",
        "width": 1400,
        "height": 1000,
        "resizable": true,
        "fullscreen": false,
        "minimizable": true,
        "maximizable": true,
        "closable": true,
        "devtools": true,
        "theme": "Dark"
      }
    ],
    "security": {
      "csp": null
    }
  },
  "bundle": {
    "active": true,
    "targets": "all",
    "icon": [
      "icons/32x32.png",
      "icons/128x128.png",
      "icons/128x128@2x.png",
      "icons/icon.icns",
      "icons/icon.ico"
    ]
  },
  "plugins": {}
}

```

`src/client/src/App.tsx`:

```tsx
import { useState, useEffect, useCallback } from "react";
import { Routes, Route, useLocation } from "react-router-dom";
import { MainApp } from "./components/MainApp";
import { WatchpointExceptionPage } from "./pages/WatchpointExceptionPage";
import { CodeTracingPage } from "./pages/CodeTracingPage";
import { GraphViewPage } from "./pages/GraphViewPage";
import { TerminalPage } from "./pages/TerminalPage";
import { LicenseAgreementDialog } from "./components/LicenseAgreementDialog";
import { getCurrentWebviewWindow } from "@tauri-apps/api/webviewWindow";

const LICENSE_AGREED_KEY = "dynadbg_license_agreed";

// Main Application Component with Routing
function TauriDebugger() {
  const location = useLocation();
  const [showLicenseDialog, setShowLicenseDialog] = useState(false);
  const [licenseAgreed, setLicenseAgreed] = useState(false);

  console.log("TauriDebugger component rendered");
  console.log("Current location:", window.location);
  console.log("React Router location:", location);
  console.log("pathname:", location.pathname);
  console.log("hash:", location.hash);

  // Check if this is a child window (Code Tracing, Watchpoint, Graph View)
  // Child windows are opened from already-authenticated main window, so skip auth checks
  const isChildWindow = location.pathname !== "/" && location.pathname !== "";

  // Check license on mount (skip for child windows)
  useEffect(() => {
    // Skip license check for child windows - they inherit from main window
    if (isChildWindow) {
      setLicenseAgreed(true);
      return;
    }

    const licenseAgreed = localStorage.getItem(LICENSE_AGREED_KEY);
    if (licenseAgreed === "true") {
      setLicenseAgreed(true);
    } else {
      setShowLicenseDialog(true);
    }
  }, [isChildWindow]);

  const handleLicenseAgree = useCallback(() => {
    localStorage.setItem(LICENSE_AGREED_KEY, "true");
    setShowLicenseDialog(false);
    setLicenseAgreed(true);
  }, []);

  const handleLicenseDisagree = useCallback(async () => {
    // Close the application
    const window = getCurrentWebviewWindow();
    await window.close();
  }, []);

  // Show license dialog if not agreed
  if (!licenseAgreed) {
    return (
      <LicenseAgreementDialog
        open={showLicenseDialog}
        onAgree={handleLicenseAgree}
        onDisagree={handleLicenseDisagree}
      />
    );
  }

  return (
    <Routes>
      <Route path="/" element={<MainApp />} />
      <Route
        path="/watchpoint-exception/:watchpointId"
        element={<WatchpointExceptionPage />}
      />
      <Route path="/code-tracing" element={<CodeTracingPage />} />
      <Route path="/graph-view" element={<GraphViewPage />} />
      <Route path="/terminal" element={<TerminalPage />} />
    </Routes>
  );
}

export default TauriDebugger;

```

`src/client/src/assets/tauri.svg`:

```svg
<svg width="206" height="231" viewBox="0 0 206 231" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M143.143 84C143.143 96.1503 133.293 106 121.143 106C108.992 106 99.1426 96.1503 99.1426 84C99.1426 71.8497 108.992 62 121.143 62C133.293 62 143.143 71.8497 143.143 84Z" fill="#FFC131"/>
<ellipse cx="84.1426" cy="147" rx="22" ry="22" transform="rotate(180 84.1426 147)" fill="#24C8DB"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M166.738 154.548C157.86 160.286 148.023 164.269 137.757 166.341C139.858 160.282 141 153.774 141 147C141 144.543 140.85 142.121 140.558 139.743C144.975 138.204 149.215 136.139 153.183 133.575C162.73 127.404 170.292 118.608 174.961 108.244C179.63 97.8797 181.207 86.3876 179.502 75.1487C177.798 63.9098 172.884 53.4021 165.352 44.8883C157.82 36.3744 147.99 30.2165 137.042 27.1546C126.095 24.0926 114.496 24.2568 103.64 27.6274C92.7839 30.998 83.1319 37.4317 75.8437 46.1553C74.9102 47.2727 74.0206 48.4216 73.176 49.5993C61.9292 50.8488 51.0363 54.0318 40.9629 58.9556C44.2417 48.4586 49.5653 38.6591 56.679 30.1442C67.0505 17.7298 80.7861 8.57426 96.2354 3.77762C111.685 -1.01901 128.19 -1.25267 143.769 3.10474C159.348 7.46215 173.337 16.2252 184.056 28.3411C194.775 40.457 201.767 55.4101 204.193 71.404C206.619 87.3978 204.374 103.752 197.73 118.501C191.086 133.25 180.324 145.767 166.738 154.548ZM41.9631 74.275L62.5557 76.8042C63.0459 72.813 63.9401 68.9018 65.2138 65.1274C57.0465 67.0016 49.2088 70.087 41.9631 74.275Z" fill="#FFC131"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M38.4045 76.4519C47.3493 70.6709 57.2677 66.6712 67.6171 64.6132C65.2774 70.9669 64 77.8343 64 85.0001C64 87.1434 64.1143 89.26 64.3371 91.3442C60.0093 92.8732 55.8533 94.9092 51.9599 97.4256C42.4128 103.596 34.8505 112.392 30.1816 122.756C25.5126 133.12 23.9357 144.612 25.6403 155.851C27.3449 167.09 32.2584 177.598 39.7906 186.112C47.3227 194.626 57.153 200.784 68.1003 203.846C79.0476 206.907 90.6462 206.743 101.502 203.373C112.359 200.002 122.011 193.568 129.299 184.845C130.237 183.722 131.131 182.567 131.979 181.383C143.235 180.114 154.132 176.91 164.205 171.962C160.929 182.49 155.596 192.319 148.464 200.856C138.092 213.27 124.357 222.426 108.907 227.222C93.458 232.019 76.9524 232.253 61.3736 227.895C45.7948 223.538 31.8055 214.775 21.0867 202.659C10.3679 190.543 3.37557 175.59 0.949823 159.596C-1.47592 143.602 0.768139 127.248 7.41237 112.499C14.0566 97.7497 24.8183 85.2327 38.4045 76.4519ZM163.062 156.711L163.062 156.711C162.954 156.773 162.846 156.835 162.738 156.897C162.846 156.835 162.954 156.773 163.062 156.711Z" fill="#24C8DB"/>
</svg>

```

`src/client/src/assets/typescript.svg`:

```svg
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 20010904//EN"
 "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg version="1.0" xmlns="http://www.w3.org/2000/svg"
 width="512.000000pt" height="512.000000pt" viewBox="0 0 512.000000 512.000000"
 preserveAspectRatio="xMidYMid meet">

<g transform="translate(0.000000,512.000000) scale(0.100000,-0.100000)"
fill="#2D79C7" stroke="none">
<path d="M430 5109 c-130 -19 -248 -88 -325 -191 -53 -71 -83 -147 -96 -247
-6 -49 -9 -813 -7 -2166 l3 -2090 22 -65 c54 -159 170 -273 328 -323 l70 -22
2140 0 2140 0 66 23 c160 55 272 169 322 327 l22 70 0 2135 0 2135 -22 70
c-49 157 -155 265 -319 327 l-59 23 -2115 1 c-1163 1 -2140 -2 -2170 -7z
m3931 -2383 c48 -9 120 -26 160 -39 l74 -23 3 -237 c1 -130 0 -237 -2 -237 -3
0 -26 14 -53 30 -61 38 -197 84 -310 106 -110 20 -293 15 -368 -12 -111 -39
-175 -110 -175 -193 0 -110 97 -197 335 -300 140 -61 309 -146 375 -189 30
-20 87 -68 126 -107 119 -117 164 -234 164 -426 0 -310 -145 -518 -430 -613
-131 -43 -248 -59 -445 -60 -243 -1 -405 24 -577 90 l-68 26 0 242 c0 175 -3
245 -12 254 -9 9 -9 12 0 12 7 0 12 -4 12 -9 0 -17 139 -102 223 -138 136 -57
233 -77 382 -76 145 0 224 19 295 68 75 52 100 156 59 242 -41 84 -135 148
-374 253 -367 161 -522 300 -581 520 -23 86 -23 253 -1 337 73 275 312 448
682 492 109 13 401 6 506 -13z m-1391 -241 l0 -205 -320 0 -320 0 0 -915 0
-915 -255 0 -255 0 0 915 0 915 -320 0 -320 0 0 205 0 205 895 0 895 0 0 -205z"/>
</g>
</svg>

```

`src/client/src/assets/vite.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
```

`src/client/src/components/AboutContent.tsx`:

```tsx
import React from "react";
import {
  Box,
  Typography,
  Stack,
  Card,
  CardContent,
  IconButton,
  alpha,
  Avatar,
  useMediaQuery,
  Divider,
} from "@mui/material";
import {
  Favorite as FavoriteIcon,
  Work as WorkIcon,
  Security as SecurityIcon,
  Code as CodeIcon,
  BugReport as BugReportIcon,
  Pets as PetsIcon,
  MusicNote as MusicNoteIcon,
  SetMeal as SetMealIcon,
} from "@mui/icons-material";

// プロフィール画像をインポート
import profileImage from "../assets/profile.png";

interface ExperienceItem {
  icon: React.ReactNode;
  title: string;
  description: string;
  color: string;
}

const experiences: ExperienceItem[] = [
  {
    icon: <SecurityIcon sx={{ fontSize: 32 }} />,
    title: "Security Engineer",
    description: "Web / Mobile / Game / LLM",
    color: "#ef4444",
  },
  {
    icon: <BugReportIcon sx={{ fontSize: 32 }} />,
    title: "Reverse Engineering",
    description: "Low-level analysis & debugging",
    color: "#8b5cf6",
  },
  {
    icon: <CodeIcon sx={{ fontSize: 32 }} />,
    title: "Software Development",
    description: "Full-stack development",
    color: "#3b82f6",
  },
];

const favorites = [
  { icon: <PetsIcon />, label: "Animals", color: "#f97316" },
  { icon: <MusicNoteIcon />, label: "Music", color: "#ec4899" },
  { icon: <SetMealIcon />, label: "Seafood", color: "#06b6d4" },
];

export const AboutContent: React.FC = () => {
  // Compact mode for height < 800px
  const isCompactHeight = useMediaQuery("(max-height: 800px)");

  return (
    <Box
      sx={{
        height: "100%",
        overflow: "auto",
        backgroundColor: "#0f0f0f",
        p: isCompactHeight ? 2 : 4,
        "&::-webkit-scrollbar": {
          width: "8px",
        },
        "&::-webkit-scrollbar-track": {
          background: "#1a1a1a",
        },
        "&::-webkit-scrollbar-thumb": {
          background: "#3a3a3a",
          borderRadius: "4px",
          "&:hover": {
            background: "#4a4a4a",
          },
        },
      }}
    >
      <Box sx={{ maxWidth: 800, mx: "auto" }}>
        {/* Header Section */}
        <Box sx={{ mb: isCompactHeight ? 2 : 5, textAlign: "center" }}>
          <Avatar
            src={profileImage}
            sx={{
              width: isCompactHeight ? 80 : 100,
              height: isCompactHeight ? 80 : 100,
              mx: "auto",
              mb: isCompactHeight ? 1 : 3,
              backgroundColor: alpha("#3b82f6", 0.2),
              fontSize: isCompactHeight ? 24 : 32,
              fontWeight: 600,
              color: "#3b82f6",
            }}
          >
            D
          </Avatar>
          <Typography
            variant={isCompactHeight ? "h5" : "h4"}
            sx={{
              fontWeight: 600,
              background: "linear-gradient(135deg, #3b82f6, #8b5cf6)",
              backgroundClip: "text",
              WebkitBackgroundClip: "text",
              WebkitTextFillColor: "transparent",
              mb: 1,
            }}
          >
            DoranekoSystems
          </Typography>
          <Typography variant="body1" color="text.secondary">
            Security Researcher
          </Typography>
        </Box>

        {/* Favorites Section */}
        <Box sx={{ mb: 5 }}>
          <Stack direction="row" alignItems="center" spacing={1} sx={{ mb: 3 }}>
            <FavoriteIcon sx={{ color: "#ec4899" }} />
            <Typography variant="h6" sx={{ color: "#e5e7eb" }}>
              Favorites
            </Typography>
          </Stack>

          <Stack
            direction="row"
            spacing={2}
            justifyContent="center"
            flexWrap="wrap"
            useFlexGap
          >
            {favorites.map((item, index) => (
              <Card
                key={index}
                sx={{
                  backgroundColor: alpha("#1a1a1a", 0.8),
                  border: "1px solid #2d2d2d",
                  borderRadius: 2,
                  minWidth: isCompactHeight ? 100 : 140,
                  transition: "all 0.3s ease",
                  "&:hover": {
                    borderColor: item.color,
                    transform: "translateY(-2px)",
                  },
                }}
              >
                <CardContent
                  sx={{ textAlign: "center", py: isCompactHeight ? 1.5 : 3 }}
                >
                  <Box sx={{ color: item.color, mb: 1 }}>{item.icon}</Box>
                  <Typography variant="body2" sx={{ color: "#e5e7eb" }}>
                    {item.label}
                  </Typography>
                </CardContent>
              </Card>
            ))}
          </Stack>
        </Box>

        <Divider sx={{ borderColor: "#2d2d2d", my: 4 }} />

        {/* Experience Section */}
        <Box sx={{ mb: 5 }}>
          <Stack direction="row" alignItems="center" spacing={1} sx={{ mb: 3 }}>
            <WorkIcon sx={{ color: "#3b82f6" }} />
            <Typography variant="h6" sx={{ color: "#e5e7eb" }}>
              Experience
            </Typography>
          </Stack>

          <Stack spacing={isCompactHeight ? 1 : 2}>
            {experiences.map((exp, index) => (
              <Card
                key={index}
                sx={{
                  backgroundColor: alpha("#1a1a1a", 0.8),
                  border: "1px solid #2d2d2d",
                  borderRadius: 2,
                  transition: "all 0.3s ease",
                  "&:hover": {
                    borderColor: exp.color,
                  },
                }}
              >
                <CardContent sx={{ p: isCompactHeight ? 1.5 : undefined }}>
                  <Stack
                    direction="row"
                    spacing={isCompactHeight ? 2 : 3}
                    alignItems="center"
                  >
                    <Box
                      sx={{
                        width: isCompactHeight ? 44 : 60,
                        height: isCompactHeight ? 44 : 60,
                        borderRadius: 2,
                        backgroundColor: alpha(exp.color, 0.1),
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                        color: exp.color,
                        flexShrink: 0,
                        "& svg": {
                          fontSize: isCompactHeight ? 24 : 32,
                        },
                      }}
                    >
                      {exp.icon}
                    </Box>
                    <Box sx={{ flex: 1 }}>
                      <Typography
                        variant="h6"
                        sx={{
                          color: "#fff",
                          fontWeight: 500,
                          fontSize: "1rem",
                          mb: 0.5,
                        }}
                      >
                        {exp.title}
                      </Typography>
                      <Typography variant="body2" color="text.secondary">
                        {exp.description}
                      </Typography>
                    </Box>
                  </Stack>
                </CardContent>
              </Card>
            ))}
          </Stack>
        </Box>

        <Divider sx={{ borderColor: "#2d2d2d", my: isCompactHeight ? 2 : 4 }} />

        {/* Contact Section */}
        <Box
          sx={{
            textAlign: "center",
            p: isCompactHeight ? 2 : 4,
            backgroundColor: alpha("#1a1a1a", 0.5),
            borderRadius: 2,
            border: "1px solid #2d2d2d",
          }}
        >
          <Typography
            variant="h6"
            sx={{ mb: isCompactHeight ? 1 : 2, color: "#e5e7eb" }}
          >
            Contact
          </Typography>
          <Typography
            variant="body2"
            color="text.secondary"
            sx={{ mb: isCompactHeight ? 1.5 : 3 }}
          >
            Want to chat? Feel free to reach out on X
          </Typography>
          <IconButton
            component="a"
            href="https://x.com/DoranekoSystems"
            target="_blank"
            rel="noopener noreferrer"
            sx={{
              backgroundColor: alpha("#fff", 0.1),
              color: "#fff",
              width: isCompactHeight ? 44 : 56,
              height: isCompactHeight ? 44 : 56,
              transition: "all 0.3s ease",
              "&:hover": {
                backgroundColor: "#fff",
                color: "#000",
                transform: "scale(1.1)",
              },
            }}
          >
            <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
              <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" />
            </svg>
          </IconButton>
          <Typography
            variant="caption"
            display="block"
            sx={{ mt: 2, color: "#6b7280" }}
          >
            @DoranekoSystems
          </Typography>
        </Box>
      </Box>
    </Box>
  );
};

```

`src/client/src/components/AssemblyView.tsx`:

```tsx
import React, {
  useState,
  useEffect,
  useRef,
  useCallback,
  useMemo,
} from "react";
import {
  Box,
  Typography,
  IconButton,
  Tooltip,
  styled,
  alpha,
  Table,
  TableHead,
  TableBody,
  TableRow,
  TableCell,
  TableSortLabel,
  Menu,
  MenuItem,
  ListItemIcon,
  ListItemText,
  Divider,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  TextField,
  CircularProgress,
  Snackbar,
  Alert,
  Checkbox,
  FormControlLabel,
} from "@mui/material";
import {
  Functions as FunctionsIcon,
  KeyboardArrowUp as ArrowUpIcon,
  KeyboardArrowDown as ArrowDownIcon,
  Clear as ClearIcon,
  Refresh as RefreshIcon,
  AutoStories as DecompileIcon,
  Timeline as TimelineIcon,
  PushPin as BreakpointIcon,
  ContentCopy as CopyIcon,
  SwapHoriz as SwapHorizIcon,
  Code as CodeIcon,
  AccountTree as GraphIcon,
  VerticalAlignTop as FunctionStartIcon,
  VerticalAlignBottom as FunctionEndIcon,
  CallReceived as CallReceivedIcon,
  CheckCircleOutline as CheckCircleOutlineIcon,
  BlockOutlined as NopIcon,
  Settings as SettingsIcon,
  Close as CloseIcon,
  InsertDriveFile as FileIcon,
} from "@mui/icons-material";
import { invoke } from "@tauri-apps/api/core";
import { listen } from "@tauri-apps/api/event";
import {
  ServerInfo,
  DisassembleResponse,
  getApiClient,
  ModuleInfo,
} from "../lib/api";
import { useGlobalDebugLogger } from "../hooks/useGlobalDebugLogger";
import { useTableColumnResize } from "../hooks/useTableColumnResize";
import { useLocalStorage } from "../hooks/useLocalStorage";
import { ColumnResizer } from "./ColumnResizer";
import { useUIStore, SourceBreakpoint } from "../stores/uiStore";
import { useSymbolCache } from "../hooks/useSymbolCache";
import { useTauriSystemStateSingleton } from "../hooks/useTauriSystemStateSingleton";
import { encodeAddressToLibraryExpression } from "../utils/addressEncoder";
import { openCodeTracingWindow, startTraceSession } from "./CodeTracingWindow";
import {
  predictNextInstruction,
  convertRegistersToState,
} from "../utils/arm64BranchPredictor";
import {
  openGraphViewWindow,
  GraphViewData,
  GraphViewInstruction,
} from "./GraphViewWindow";
import { useGhidraAnalysis, GhidraTokenInfo } from "../hooks/useGhidraAnalysis";

// Empty array constant for default value (prevents infinite loop in zustand selector)
const EMPTY_SOURCE_BREAKPOINTS: SourceBreakpoint[] = [];

interface Instruction {
  address: string;
  bytes: string;
  opcode: string;
  operands: Array<{
    type: string;
    value: string;
  }>;
  comment: string;
  active: boolean;
  breakpoint: boolean;
  isSoftwareBreakpoint?: boolean; // true if software breakpoint, false/undefined if hardware
  jumpTarget: boolean;
  isFunction?: boolean;
  isFunctionStart?: boolean;
  isFunctionEnd?: boolean;
  indent?: number; // Indentation level for WASM block structure
}

// Branch arrow information for visualization
interface BranchArrowInfo {
  fromIndex: number;
  toIndex: number;
  fromAddress: string;
  toAddress: string;
  isConditional: boolean;
  isDownward: boolean;
  depth: number; // For nested arrows (0 = leftmost)
  isPredictedNext?: boolean; // True if this is the predicted next instruction based on register state
}

const DisassemblyContainer = styled(Box)(() => ({
  overflowY: "hidden",
  height: "100%",
  backgroundColor: "#1e1e1e",
  position: "relative",
  "&:focus": {
    outline: "none",
  },
}));

const ScrollableContent = styled(Box)(() => ({
  height: "100%",
  overflowY: "auto",
  "&::-webkit-scrollbar": {
    width: "8px",
  },
  "&::-webkit-scrollbar-track": {
    background: "#1e1e1e",
  },
  "&::-webkit-scrollbar-thumb": {
    background: "#424242",
    borderRadius: "4px",
  },
  "&::-webkit-scrollbar-thumb:hover": {
    background: "#5a5a5e",
  },
}));

// New table components for assembly view, similar to MemoryView
const AssemblyTable = styled(Table)(() => ({
  backgroundColor: "#1a1a1a",
  tableLayout: "fixed",
  "& .MuiTableCell-root": {
    borderBottom: "1px solid #2d2d30",
    padding: "2px 4px",
    fontSize: "12px",
    fontFamily: 'Consolas, "Courier New", monospace',
    color: "#d4d4d4",
  },
  "& .MuiTableHead-root .MuiTableCell-root": {
    backgroundColor: "#252526",
    color: "#4fc1ff",
    fontWeight: 600,
    fontSize: "10px",
    padding: "4px",
    position: "sticky",
    top: 0,
    zIndex: 1,
    borderBottom: "2px solid #4fc1ff",
  },
  "& .MuiTableBody-root .MuiTableRow-root": {
    minHeight: "18px",
    "&:hover": {
      backgroundColor: "rgba(79, 193, 255, 0.08)",
    },
    "& .MuiTableCell-root": {
      padding: "1px 4px",
    },
    // Ensure bytes column maintains its orange color
    "& .MuiTableCell-root:nth-of-type(3)": {
      color: "#ce9178 !important",
    },
  },
  "@media (max-height: 800px)": {
    "& .MuiTableCell-root": {
      padding: "1px 2px",
      fontSize: "10px",
    },
    "& .MuiTableHead-root .MuiTableCell-root": {
      fontSize: "9px",
      padding: "2px",
    },
    "& .MuiTableBody-root .MuiTableRow-root": {
      minHeight: "14px",
      "& .MuiTableCell-root": {
        padding: "0px 2px",
      },
    },
  },
}));

const AssemblyTableWrapper = styled(Box)(() => ({
  margin: "8px",
  backgroundColor: "#1a1a1a",
  border: "1px solid #2d2d30",
  borderRadius: "4px",
  height: "calc(100% - 16px)",
  overflow: "hidden",
  display: "flex",
  flexDirection: "column",
  "@media (max-height: 800px)": {
    margin: "4px",
    height: "calc(100% - 8px)",
  },
}));

const AssemblyTableContainer = styled(Box)(() => ({
  flex: 1,
  overflow: "hidden",
  position: "relative", // For SVG branch arrow overlay positioning
}));

const BreakpointTableCell = styled(TableCell)(() => ({
  textAlign: "center",
  padding: "2px !important",
  borderRight: "1px solid #2d2d30",
  cursor: "pointer",
  position: "relative",
  "&:hover": {
    backgroundColor: "rgba(255, 68, 68, 0.2)",
  },
}));

const AddressTableCell = styled(TableCell)(() => ({
  color: "#4fc1ff", // Keep original address color
  borderRight: "1px solid #2d2d30",
  cursor: "pointer",
  position: "relative",
  "&:hover": {
    color: "#4fc1ff",
    textDecoration: "underline",
  },
}));

const BytesTableCell = styled(TableCell)(() => ({
  color: "#ce9178", // Orange bytes color
  borderRight: "1px solid #2d2d30",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  position: "relative",
  "& .MuiTableCell-root": {
    color: "#ce9178 !important", // Ensure bytes color is applied
  },
}));

const DetailTableCell = styled(TableCell)(() => ({
  color: "#d4d4d4", // Default text color
  borderRight: "1px solid #2d2d30",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  fontSize: "11px",
  position: "relative",
  "& .filename": {
    color: "#569cd6", // Same blue as opcode for filename part
    fontWeight: "bold",
  },
  "& .offset": {
    color: "#d4d4d4", // Default color for offset part
  },
}));

const InstructionTableCell = styled(TableCell)(() => ({
  color: "#d4d4d4",
  paddingLeft: "8px !important",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
}));

const BreakpointIndicator = styled(Box, {
  shouldForwardProp: (prop) => prop !== "active" && prop !== "isSoftware",
})<{ active?: boolean; isSoftware?: boolean }>(({ active, isSoftware }) => ({
  width: "8px",
  height: "8px",
  borderRadius: "50%",
  backgroundColor: active
    ? isSoftware
      ? "#44bb44"
      : "#ff4444"
    : "transparent",
  border: "1px solid",
  borderColor: active
    ? isSoftware
      ? "#44bb44"
      : "#ff4444"
    : "rgba(255, 255, 255, 0.3)",
  transition: "all 0.15s ease",
  pointerEvents: "none",
  margin: "0 auto",
}));

const OpcodeText = styled(Box)(() => ({
  color: "#569cd6", // Keep original opcode color
  marginRight: "8px",
  fontWeight: "bold",
  minWidth: "40px",
  display: "inline-block",
}));

const OperandsText = styled(Box)(() => ({
  color: "#d4d4d4", // Keep original operands color
  marginRight: "12px",
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap",
  display: "inline",
}));

const CommentText = styled(Box)(() => ({
  color: "#6a9955", // Keep original comment color
  fontSize: "11px",
  fontStyle: "italic",
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap",
  display: "inline",
  flexShrink: 0,
  maxWidth: "100%",
}));

const NavigationButtons = styled(Box)(() => ({
  position: "absolute",
  right: "8px",
  top: "50%",
  transform: "translateY(-50%)",
  display: "flex",
  flexDirection: "column",
  gap: "4px",
  zIndex: 1,
}));

const NavButton = styled(IconButton)(() => ({
  width: "24px",
  height: "24px",
  backgroundColor: "rgba(37, 37, 38, 0.9)",
  border: "1px solid #2d2d30",
  "&:hover": {
    backgroundColor: "rgba(45, 45, 48, 0.9)",
  },
  "& .MuiSvgIcon-root": {
    fontSize: "16px",
    color: "#cccccc",
  },
}));

const DisassemblyHeader = styled(Box)(() => ({
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  padding: "6px 12px",
  backgroundColor: "#252526",
  borderBottom: "1px solid #2d2d30",
  minHeight: "40px",
  height: "40px",
  "@media (max-height: 800px)": {
    padding: "4px 8px",
    minHeight: "30px",
    height: "30px",
  },
}));

const DisassemblyTitle = styled(Typography)(() => ({
  fontSize: "12px",
  fontWeight: "bold",
  color: "#4fc1ff",
  display: "flex",
  alignItems: "center",
  "& .MuiSvgIcon-root": {
    fontSize: "16px",
    marginRight: "4px",
    "@media (max-height: 800px)": {
      fontSize: "12px",
      marginRight: "2px",
    },
  },
  "@media (max-height: 800px)": {
    fontSize: "10px",
  },
}));

const DisassemblyActions = styled(Box)(() => ({
  display: "flex",
  alignItems: "center",
  gap: "4px",
}));

interface AssemblyViewProps {
  serverInfo?: ServerInfo;
  onBreakpointSet?: (address: string, isSoftware?: boolean) => void;
  onBreakpointRemove?: (address: string) => void;
  onBreakpointHit?: (address: string) => void;
  currentBreakAddress?: string | null; // Add break address for highlighting
  isInBreakState?: boolean; // Add break state for conditional highlighting
  activeBreakpoints?: string[]; // Add active breakpoints list from parent
  softwareBreakpoints?: Map<string, string>; // Map of address to original bytes for software BPs
  isSoftwareBreakpoint?: boolean; // Whether to set software breakpoints (from toolbar toggle)
  attachedModules?: ModuleInfo[]; // Add attached modules for detail info
  registerData?: Record<string, string>; // Register values for branch prediction
  // Decompile view related props
  isDecompileVisible?: boolean;
  onToggleDecompile?: () => void;
  hasDecompileResult?: boolean; // Whether there's a decompile result available to show
  // Ghidra integration props
  onDecompileRequest?: (
    libraryPath: string,
    address: string,
    functionName: string | null,
    decompiledCode: string,
    moduleBase: number,
    lineMapping: Record<number, string> | null,
    tokens?: GhidraTokenInfo[] | null
  ) => void;
  onDecompileError?: (error: string | null) => void; // Callback for decompile errors
  // Callback when assembly address is clicked (for syncing with DecompileView)
  onAssemblyAddressClicked?: (address: string) => void;
  // Address to highlight (without scrolling if visible, with scrolling if not)
  highlightAddress?: string | null;
  // Callback when highlight is complete
  onHighlightComplete?: () => void;
}

// Function to format operands as string
const formatOperands = (operands: any[]): string => {
  return operands
    .map((op) => {
      switch (op.type) {
        case "reg":
          return op.value;
        case "imm":
          return op.value;
        case "mem":
          if (op.base && op.disp) {
            return `[${op.base}+${op.disp}]`;
          } else if (op.base) {
            return `[${op.base}]`;
          }
          return op.value || "";
        default:
          return op.value || "";
      }
    })
    .join(", ");
};

// Function to detect jump instructions (b系とretのみ)
const isJumpInstruction = (opcode: string): boolean => {
  const jumpOpcodes = [
    // ARM64 branch instructions (b系とret)
    "b", // Unconditional branch
    "bl", // Branch with link
    "br", // Branch to register
    "blr", // Branch with link to register
    "ret", // Return
    "b.eq", // Branch if equal
    "b.ne", // Branch if not equal
    "b.cs", // Branch if carry set
    "b.cc", // Branch if carry clear
    "b.mi", // Branch if minus
    "b.pl", // Branch if plus
    "b.vs", // Branch if overflow
    "b.vc", // Branch if no overflow
    "b.hi", // Branch if higher
    "b.ls", // Branch if lower or same
    "b.ge", // Branch if greater or equal
    "b.lt", // Branch if less than
    "b.gt", // Branch if greater than
    "b.le", // Branch if less or equal
    "b.al", // Branch always (unconditional)
    // ARM64 compare and branch instructions
    "cbz", // Compare and Branch if Zero
    "cbnz", // Compare and Branch if Not Zero
    "tbz", // Test Bit and Branch if Zero
    "tbnz", // Test Bit and Branch if Not Zero
    // x86/x86_64 jump instructions
    "jmp", // Unconditional jump
    "je",
    "jz", // Jump if equal/zero
    "jne",
    "jnz", // Jump if not equal/not zero
    "jc",
    "jb",
    "jnae", // Jump if carry/below/not above or equal
    "jnc",
    "jae",
    "jnb", // Jump if not carry/above or equal/not below
    "js", // Jump if sign
    "jns", // Jump if not sign
    "jo", // Jump if overflow
    "jno", // Jump if not overflow
    "jp",
    "jpe", // Jump if parity/parity even
    "jnp",
    "jpo", // Jump if not parity/parity odd
    "ja",
    "jnbe", // Jump if above/not below or equal
    "jbe",
    "jna", // Jump if below or equal/not above
    "jg",
    "jnle", // Jump if greater/not less or equal
    "jge",
    "jnl", // Jump if greater or equal/not less
    "jl",
    "jnge", // Jump if less/not greater or equal
    "jle",
    "jng", // Jump if less or equal/not greater
    "call", // Call
    "ret",
    "retn", // Return
  ];
  return jumpOpcodes.includes(opcode.toLowerCase());
};

// Function to check if jump is conditional (includes ARM64 instructions)
const isConditionalJump = (opcode: string): boolean => {
  const conditionalOpcodes = [
    // x86/x86_64 conditional jumps
    "je",
    "jne",
    "jz",
    "jnz",
    "jc",
    "jnc",
    "js",
    "jns",
    "jo",
    "jno",
    "jp",
    "jnp",
    "jpe",
    "jpo",
    "ja",
    "jae",
    "jb",
    "jbe",
    "jg",
    "jge",
    "jl",
    "jle",
    "loop",
    "loope",
    "loopne",
    "loopz",
    "loopnz",
    "jcxz",
    "jecxz",
    "jrcxz",
    // ARM64 conditional branches
    "b.eq", // Branch if equal
    "b.ne", // Branch if not equal
    "b.cs", // Branch if carry set
    "b.cc", // Branch if carry clear
    "b.mi", // Branch if minus
    "b.pl", // Branch if plus
    "b.vs", // Branch if overflow
    "b.vc", // Branch if no overflow
    "b.hi", // Branch if higher
    "b.ls", // Branch if lower or same
    "b.ge", // Branch if greater or equal
    "b.lt", // Branch if less than
    "b.gt", // Branch if greater than
    "b.le", // Branch if less or equal
    // ARM64 compare and branch instructions (conditional)
    "cbz", // Compare and Branch if Zero
    "cbnz", // Compare and Branch if Not Zero
    "tbz", // Test Bit and Branch if Zero
    "tbnz", // Test Bit and Branch if Not Zero
  ];
  return conditionalOpcodes.includes(opcode.toLowerCase());
};

// Function to extract jump target address from instruction operands
const extractJumpTargetAddress = (instruction: Instruction): string | null => {
  if (!isJumpInstruction(instruction.opcode)) return null;
  if (instruction.operands.length === 0) return null;

  const operandsStr = instruction.operands.map((op) => op.value).join(", ");
  // Extract address from operands (handle various formats)
  // Common patterns: "0x1234", "#0x1234", "0x1234 <symbol>"
  const addressMatch = operandsStr.match(/(0x[0-9a-fA-F]+)/i);
  if (addressMatch) {
    return addressMatch[1].toLowerCase();
  }

  return null;
};

// Function to calculate branch arrows for the current view
const calculateBranchArrows = (
  instructions: Instruction[]
): BranchArrowInfo[] => {
  const arrows: BranchArrowInfo[] = [];

  // Build address to index map for quick lookup
  const addressToIndex = new Map<string, number>();
  // Also build address to numeric value map for range comparison
  const addressValues: number[] = [];

  instructions.forEach((instruction, index) => {
    // Normalize address for comparison
    const normalizedAddr = instruction.address
      .toLowerCase()
      .replace(/^0x0*/, "0x");
    addressToIndex.set(normalizedAddr, index);
    // Also store without leading zeros
    const withoutLeadingZeros = instruction.address
      .toLowerCase()
      .replace(/^0x/, "");
    addressToIndex.set("0x" + withoutLeadingZeros, index);

    // Store numeric value
    const numericAddr = parseInt(instruction.address.replace(/^0x/i, ""), 16);
    addressValues.push(numericAddr);
  });

  // Get view range for out-of-bounds detection
  const viewMinAddr = addressValues.length > 0 ? Math.min(...addressValues) : 0;
  const viewMaxAddr = addressValues.length > 0 ? Math.max(...addressValues) : 0;

  // Find all branch instructions
  instructions.forEach((instruction, fromIndex) => {
    if (!isJumpInstruction(instruction.opcode)) return;
    // Skip ret instructions - they don't have a visible target
    if (
      instruction.opcode.toLowerCase() === "ret" ||
      instruction.opcode.toLowerCase() === "retn"
    )
      return;
    // Skip call instructions for cleaner display
    if (
      instruction.opcode.toLowerCase() === "call" ||
      instruction.opcode.toLowerCase() === "bl" ||
      instruction.opcode.toLowerCase() === "blr"
    )
      return;

    const targetAddress = extractJumpTargetAddress(instruction);
    if (!targetAddress) return;

    // Normalize target address
    const normalizedTarget = targetAddress.toLowerCase().replace(/^0x0*/, "0x");
    const targetNumeric = parseInt(targetAddress.replace(/^0x/i, ""), 16);

    // Check if target is in current view
    let toIndex = addressToIndex.get(normalizedTarget);
    if (toIndex === undefined) {
      // Try alternative normalization
      const altNormalized =
        "0x" + targetAddress.toLowerCase().replace(/^0x/, "");
      toIndex = addressToIndex.get(altNormalized);
    }

    if (toIndex !== undefined && toIndex !== fromIndex) {
      // Target is in view
      arrows.push({
        fromIndex,
        toIndex,
        fromAddress: instruction.address,
        toAddress: targetAddress,
        isConditional: isConditionalJump(instruction.opcode),
        isDownward: toIndex > fromIndex,
        depth: 0,
      });
    } else if (toIndex === undefined) {
      // Target is out of view - determine direction
      if (targetNumeric < viewMinAddr) {
        // Target is above current view - arrow goes up from fromIndex to top (index -1)
        arrows.push({
          fromIndex,
          toIndex: -1, // Special value for "above view"
          fromAddress: instruction.address,
          toAddress: targetAddress,
          isConditional: isConditionalJump(instruction.opcode),
          isDownward: false,
          depth: 0,
        });
      } else if (targetNumeric > viewMaxAddr) {
        // Target is below current view - arrow goes down from fromIndex to bottom
        arrows.push({
          fromIndex,
          toIndex: instructions.length, // Special value for "below view"
          fromAddress: instruction.address,
          toAddress: targetAddress,
          isConditional: isConditionalJump(instruction.opcode),
          isDownward: true,
          depth: 0,
        });
      }
    }
  });

  // Calculate depths to avoid overlapping arrows
  // Sort arrows by span size (smaller spans get higher priority/lower depth)
  arrows.sort((a, b) => {
    const spanA = Math.abs(a.toIndex - a.fromIndex);
    const spanB = Math.abs(b.toIndex - b.fromIndex);
    return spanA - spanB;
  });

  // Assign depths to avoid overlaps
  const usedDepths: Map<number, number[]>[] = []; // For each row, track which depths are in use

  // Initialize usedDepths for each row
  for (let i = 0; i < instructions.length; i++) {
    usedDepths.push(new Map());
  }

  arrows.forEach((arrow) => {
    // Handle out-of-bounds arrows
    const effectiveFromIndex = Math.max(0, arrow.fromIndex);
    const effectiveToIndex = Math.min(
      instructions.length - 1,
      Math.max(0, arrow.toIndex)
    );
    const minIndex = Math.min(effectiveFromIndex, effectiveToIndex);
    const maxIndex = Math.max(effectiveFromIndex, effectiveToIndex);

    // Find first available depth for this arrow's range
    let depth = 0;
    let depthFound = false;

    while (!depthFound && depth < 10) {
      let depthAvailable = true;
      for (let row = minIndex; row <= maxIndex; row++) {
        if (row >= 0 && row < usedDepths.length) {
          const rowDepths = usedDepths[row].get(depth);
          if (rowDepths !== undefined) {
            depthAvailable = false;
            break;
          }
        }
      }

      if (depthAvailable) {
        depthFound = true;
        arrow.depth = depth;
        // Mark this depth as used for all rows in range
        for (let row = minIndex; row <= maxIndex; row++) {
          if (row >= 0 && row < usedDepths.length) {
            usedDepths[row].set(depth, []);
          }
        }
      } else {
        depth++;
      }
    }
  });

  return arrows;
};

// Fixed width for arrow area (4 depth levels reserved)
const ARROW_AREA_WIDTH = 44; // 4 levels * 6px + 20px padding

// Arrow line info for a specific row
interface RowArrowInfo {
  depth: number;
  color: string;
  isStart: boolean; // This row is the start of the arrow
  isEnd: boolean; // This row is the end of the arrow
  isVertical: boolean; // This row has a vertical line passing through
  isDownward: boolean; // Arrow direction: true = downward, false = upward
  isOutOfBoundsStart: boolean; // Arrow starts from outside view (above)
  isOutOfBoundsEnd: boolean; // Arrow ends outside view (below)
}

// Function to calculate arrow info for each row
const calculateRowArrowInfo = (
  rowIndex: number,
  arrows: BranchArrowInfo[],
  totalRows: number
): RowArrowInfo[] => {
  const rowArrows: RowArrowInfo[] = [];

  arrows.forEach((arrow) => {
    // Handle out-of-bounds arrows
    // isOutOfBoundsAbove: target is above view (arrow goes upward and exits top)
    const isOutOfBoundsAbove = arrow.toIndex < 0;
    // isOutOfBoundsBelow: target is below view (arrow goes downward and exits bottom)
    const isOutOfBoundsBelow = arrow.toIndex >= totalRows;

    // Calculate the visible range of this arrow
    // For arrows going out of bounds, we extend to the edge of the view
    let visibleStartRow: number;
    let visibleEndRow: number;

    if (isOutOfBoundsAbove) {
      // Arrow goes from fromIndex upward to above the view (row 0 and beyond)
      visibleStartRow = 0;
      visibleEndRow = arrow.fromIndex;
    } else if (isOutOfBoundsBelow) {
      // Arrow goes from fromIndex downward to below the view (last row and beyond)
      visibleStartRow = arrow.fromIndex;
      visibleEndRow = totalRows - 1;
    } else {
      // Normal arrow within view
      visibleStartRow = Math.min(arrow.fromIndex, arrow.toIndex);
      visibleEndRow = Math.max(arrow.fromIndex, arrow.toIndex);
    }

    // Check if this row is involved in this arrow
    if (rowIndex >= visibleStartRow && rowIndex <= visibleEndRow) {
      // Predicted next instruction arrow gets special cyan color
      const color = arrow.isPredictedNext
        ? "#00d4ff" // Cyan for predicted next instruction
        : arrow.isConditional
          ? arrow.isDownward
            ? "#cc9900" // Yellow for conditional downward
            : "#ff6b6b" // Red for conditional upward (loop-like)
          : "#66cc66"; // Green for unconditional

      const isStart = rowIndex === arrow.fromIndex;
      const isEnd =
        !isOutOfBoundsAbove &&
        !isOutOfBoundsBelow &&
        rowIndex === arrow.toIndex;

      // Vertical line is needed for:
      // 1. Rows between start and end (exclusive)
      // 2. Boundary rows for out-of-bounds arrows (but not if it's also the start)
      const isMiddleRow =
        rowIndex > visibleStartRow && rowIndex < visibleEndRow;
      const isBoundaryRow =
        (isOutOfBoundsAbove && rowIndex === 0) ||
        (isOutOfBoundsBelow && rowIndex === totalRows - 1);

      rowArrows.push({
        depth: arrow.depth,
        color,
        isStart,
        isEnd,
        isVertical: isMiddleRow || (isBoundaryRow && !isStart),
        isDownward: arrow.isDownward,
        isOutOfBoundsStart: isOutOfBoundsAbove && rowIndex === 0,
        isOutOfBoundsEnd: isOutOfBoundsBelow && rowIndex === totalRows - 1,
      });
    }
  });

  return rowArrows;
};

interface DisasmLineComponentProps {
  instruction: Instruction;
  rowIndex: number;
  isFocused?: boolean;
  onFocus?: (address: string) => void;
  onBreakpointClick: (address: string, event: React.MouseEvent) => void;
  onAddressClick: (address: string, event: React.MouseEvent) => void;
  onDetailClick?: (address: string, event: React.MouseEvent) => void; // Function to handle detail column click
  onBytesClick?: (address: string, event: React.MouseEvent) => void; // Function to handle bytes column click (DecompileView sync only)
  onInstructionClick?: (address: string, event: React.MouseEvent) => void; // Function to handle instruction column click (DecompileView sync only)
  onCommentClick?: (address: string) => void; // Function to handle comment click (jump to branch target)
  onContextMenu?: (
    address: string,
    instruction: Instruction,
    event: React.MouseEvent
  ) => void;
  currentBreakAddress?: string | null;
  isInBreakState?: boolean;
  isWasmMode?: boolean; // WASM mode - no debugger features available (BP/HW disabled)
  softwareBreakpointOriginalBytes?: string; // Original bytes for software breakpoint (if any)
  getModuleDetail?: (address: string) => React.ReactNode; // Function to get module detail for address
  getModuleDetailText?: (address: string) => string; // Function to get module detail text for tooltip
  getFormattedComment?: (instruction: Instruction) => string; // Function to get formatted comment based on address display format
  getBranchTargetAddress?: (instruction: Instruction) => string | null; // Function to extract branch target address from instruction
  columnWidths?: Record<string, number>; // Add column widths prop
  rowArrowInfo: RowArrowInfo[]; // Arrow info for this row
}

const DisasmLineComponent: React.FC<DisasmLineComponentProps> = React.memo(
  ({
    instruction,
    rowIndex: _rowIndex,
    onAddressClick,
    onDetailClick,
    onBytesClick,
    onInstructionClick,
    onBreakpointClick,
    onCommentClick,
    onContextMenu,
    currentBreakAddress,
    isFocused = false,
    onFocus,
    isInBreakState = false,
    isWasmMode = false,
    softwareBreakpointOriginalBytes,
    getModuleDetail,
    getModuleDetailText,
    getFormattedComment,
    getBranchTargetAddress,
    rowArrowInfo,
    columnWidths = {},
  }) => {
    const isJump = useMemo(
      () => isJumpInstruction(instruction.opcode),
      [instruction.opcode]
    );
    const isConditional = useMemo(
      () => isConditionalJump(instruction.opcode),
      [instruction.opcode]
    );

    // Helper function to normalize addresses for comparison
    const normalizeAddress = useCallback((addr: string) => {
      if (!addr) return "";
      const cleaned =
        addr.replace(/^0x/i, "").toLowerCase().replace(/^0+/, "") || "0";
      return `0x${cleaned}`;
    }, []);

    // Check if this instruction is at the current breakpoint address
    const isCurrentBreakpoint = useMemo(
      () =>
        isInBreakState &&
        currentBreakAddress &&
        normalizeAddress(instruction.address) ===
          normalizeAddress(currentBreakAddress),
      [
        isInBreakState,
        currentBreakAddress,
        instruction.address,
        normalizeAddress,
      ]
    );

    const formattedOperands = useMemo(
      () => formatOperands(instruction.operands),
      [instruction.operands]
    );

    // Determine row background color and border
    const getRowStyle = () => {
      // If focused (from DecompileView click), use hover-like background
      if (isFocused) {
        const hoverBg = instruction.active
          ? alpha("#4fc1ff", 0.15)
          : instruction.isFunction
            ? alpha("#89d185", 0.2)
            : instruction.isFunctionStart
              ? alpha("#ffa500", 0.15)
              : instruction.isFunctionEnd
                ? alpha("#ff6b6b", 0.15)
                : alpha("#3c3c3c", 0.8);
        return {
          backgroundColor: hoverBg,
          borderLeft: "3px solid #569cd6",
        };
      }
      if (isCurrentBreakpoint) {
        return {
          backgroundColor: "rgba(76, 175, 80, 0.2)",
          borderLeft: "3px solid #4CAF50",
        };
      }
      if (instruction.active) {
        return {
          backgroundColor: alpha("#4fc1ff", 0.1),
          borderLeft: "3px solid #4fc1ff",
        };
      }
      if (instruction.isFunction) {
        return {
          backgroundColor: alpha("#89d185", 0.15),
          borderLeft: "3px solid #89d185",
        };
      }
      if (instruction.isFunctionStart) {
        return {
          backgroundColor: alpha("#ffa500", 0.1),
          borderLeft: "3px solid #ffa500",
        };
      }
      if (instruction.isFunctionEnd) {
        return {
          backgroundColor: alpha("#ff6b6b", 0.1),
          borderLeft: "3px solid #ff6b6b",
        };
      }
      return {
        backgroundColor: "transparent",
        borderLeft: "3px solid transparent",
      };
    };

    return (
      <TableRow
        data-address={instruction.address}
        sx={{
          ...getRowStyle(),
          "&:hover": {
            backgroundColor: instruction.active
              ? alpha("#4fc1ff", 0.15)
              : instruction.isFunction
                ? alpha("#89d185", 0.2)
                : instruction.isFunctionStart
                  ? alpha("#ffa500", 0.15)
                  : instruction.isFunctionEnd
                    ? alpha("#ff6b6b", 0.15)
                    : alpha("#3c3c3c", 0.8),
          },
          cursor: "pointer",
          transition: "background-color 0.15s ease, border-color 0.15s ease",
        }}
        onMouseEnter={() => {
          if (onFocus) {
            onFocus(instruction.address);
          }
        }}
        onContextMenu={(e) => {
          if (onContextMenu) {
            e.preventDefault();
            onContextMenu(instruction.address, instruction, e);
          }
        }}
      >
        {/* Arrow Column - renders branch arrow lines */}
        <TableCell
          sx={{
            width: `${ARROW_AREA_WIDTH}px`,
            minWidth: `${ARROW_AREA_WIDTH}px`,
            maxWidth: `${ARROW_AREA_WIDTH}px`,
            padding: "0 !important",
            position: "relative",
            borderRight: "1px solid #2d2d30",
            borderBottom: "none !important",
            backgroundColor: "transparent",
          }}
        >
          <svg
            width={ARROW_AREA_WIDTH}
            height="100%"
            style={{
              position: "absolute",
              left: 0,
              top: 0,
              height: "100%",
              pointerEvents: "none",
            }}
          >
            {rowArrowInfo.map((arrowInfo, idx) => {
              const x = ARROW_AREA_WIDTH - 12 - arrowInfo.depth * 6;
              const startX = ARROW_AREA_WIDTH - 4;
              const midY = 10; // Half of row height (20px / 2)

              // Calculate vertical line y coordinates based on arrow direction
              // For start: line goes from midY toward the target direction
              // For end: line comes from the source direction to midY
              // For middle/vertical: line goes full height (0 to 20)
              let y1 = 0;
              let y2 = 20;

              if (arrowInfo.isStart && !arrowInfo.isEnd) {
                // Start point: line goes from midY in the direction of the target
                y1 = midY;
                y2 = arrowInfo.isDownward ? 20 : 0; // Down: toward bottom, Up: toward top
              } else if (arrowInfo.isEnd && !arrowInfo.isStart) {
                // End point: line comes from the source direction to midY
                y1 = arrowInfo.isDownward ? 0 : 20; // Down: from top, Up: from bottom
                y2 = midY;
              } else if (arrowInfo.isStart && arrowInfo.isEnd) {
                // Same row (shouldn't happen for branch arrows, but handle it)
                y1 = midY;
                y2 = midY;
              }
              // else: vertical/middle row, use full height (0 to 20)

              return (
                <g key={`arrow-line-${idx}`}>
                  {/* Vertical line through the cell */}
                  {(arrowInfo.isVertical ||
                    arrowInfo.isStart ||
                    arrowInfo.isEnd) && (
                    <line
                      x1={x}
                      y1={y1}
                      x2={x}
                      y2={y2}
                      stroke={arrowInfo.color}
                      strokeWidth="1.5"
                      strokeOpacity="0.8"
                    />
                  )}
                  {/* Horizontal line from start point */}
                  {arrowInfo.isStart && (
                    <>
                      <line
                        x1={startX}
                        y1={midY}
                        x2={x}
                        y2={midY}
                        stroke={arrowInfo.color}
                        strokeWidth="1.5"
                        strokeOpacity="0.8"
                      />
                      {/* Source dot */}
                      <circle
                        cx={startX}
                        cy={midY}
                        r="2"
                        fill={arrowInfo.color}
                        fillOpacity="0.8"
                      />
                    </>
                  )}
                  {/* Horizontal line to end point with arrowhead */}
                  {arrowInfo.isEnd && (
                    <>
                      <line
                        x1={x}
                        y1={midY}
                        x2={startX - 5}
                        y2={midY}
                        stroke={arrowInfo.color}
                        strokeWidth="1.5"
                        strokeOpacity="0.8"
                      />
                      {/* Arrowhead */}
                      <polygon
                        points={`${startX},${midY} ${startX - 5},${midY - 3} ${startX - 5},${midY + 3}`}
                        fill={arrowInfo.color}
                        fillOpacity="0.8"
                      />
                    </>
                  )}
                  {/* Out of bounds indicator at top (arrow coming from above) */}
                  {arrowInfo.isOutOfBoundsStart && (
                    <>
                      {/* Vertical line extending to top of cell */}
                      <line
                        x1={x}
                        y1={0}
                        x2={x}
                        y2={20}
                        stroke={arrowInfo.color}
                        strokeWidth="1.5"
                        strokeOpacity="0.8"
                      />
                      {/* Triangle pointing up at top */}
                      <polygon
                        points={`${x},0 ${x - 3},6 ${x + 3},6`}
                        fill={arrowInfo.color}
                        fillOpacity="0.8"
                      />
                    </>
                  )}
                  {/* Out of bounds indicator at bottom (arrow going below) */}
                  {arrowInfo.isOutOfBoundsEnd && (
                    <>
                      {/* Vertical line extending to bottom of cell */}
                      <line
                        x1={x}
                        y1={0}
                        x2={x}
                        y2={20}
                        stroke={arrowInfo.color}
                        strokeWidth="1.5"
                        strokeOpacity="0.8"
                      />
                      {/* Triangle pointing down at bottom */}
                      <polygon
                        points={`${x},20 ${x - 3},14 ${x + 3},14`}
                        fill={arrowInfo.color}
                        fillOpacity="0.8"
                      />
                    </>
                  )}
                </g>
              );
            })}
          </svg>
        </TableCell>

        {/* Breakpoint Column */}
        <BreakpointTableCell
          sx={{
            width: columnWidths.breakpoint
              ? `${columnWidths.breakpoint}px`
              : undefined,
            minWidth: columnWidths.breakpoint
              ? `${columnWidths.breakpoint}px`
              : undefined,
            maxWidth: columnWidths.breakpoint
              ? `${columnWidths.breakpoint}px`
              : undefined,
            // Disable visual feedback in WASM mode
            ...(isWasmMode && {
              cursor: "not-allowed",
              opacity: 0.5,
              "&:hover": {
                backgroundColor: "transparent",
              },
            }),
          }}
          onClick={(e) => {
            e.stopPropagation();
            // Skip breakpoint toggle in WASM mode (no debugger support)
            if (isWasmMode) return;
            onBreakpointClick(instruction.address, e);
          }}
        >
          {isFocused ? (
            <BreakpointIndicator
              active={instruction.breakpoint}
              isSoftware={instruction.isSoftwareBreakpoint}
            />
          ) : instruction.breakpoint ? (
            <Box
              sx={{
                color: instruction.isSoftwareBreakpoint ? "#44bb44" : "#ff4444",
                fontSize: "12px",
              }}
            >
              ●
            </Box>
          ) : null}
        </BreakpointTableCell>

        {/* Address Column */}
        <AddressTableCell
          sx={{
            width: columnWidths.address
              ? `${columnWidths.address}px`
              : undefined,
            minWidth: columnWidths.address
              ? `${columnWidths.address}px`
              : undefined,
            maxWidth: columnWidths.address
              ? `${columnWidths.address}px`
              : undefined,
          }}
          onClick={(e) => {
            e.stopPropagation();
            onAddressClick(instruction.address, e);
          }}
        >
          {instruction.address}
        </AddressTableCell>

        {/* Detail Column */}
        <DetailTableCell
          sx={{
            width: columnWidths.detail ? `${columnWidths.detail}px` : undefined,
            minWidth: columnWidths.detail
              ? `${columnWidths.detail}px`
              : undefined,
            maxWidth: columnWidths.detail
              ? `${columnWidths.detail}px`
              : undefined,
            cursor: onDetailClick ? "pointer" : "default",
          }}
          title={
            getModuleDetailText ? getModuleDetailText(instruction.address) : ""
          }
          onClick={(e) => {
            if (onDetailClick) {
              e.stopPropagation();
              onDetailClick(instruction.address, e);
            }
          }}
        >
          {getModuleDetail ? getModuleDetail(instruction.address) : ""}
        </DetailTableCell>

        {/* Bytes Column */}
        <BytesTableCell
          sx={{
            width: columnWidths.bytes ? `${columnWidths.bytes}px` : undefined,
            minWidth: columnWidths.bytes
              ? `${columnWidths.bytes}px`
              : undefined,
            maxWidth: columnWidths.bytes
              ? `${columnWidths.bytes}px`
              : undefined,
            cursor: onBytesClick ? "pointer" : "default",
          }}
          title={
            softwareBreakpointOriginalBytes
              ? `Original: ${softwareBreakpointOriginalBytes} (SW BP active)`
              : instruction.bytes
          }
          onClick={(e) => {
            if (onBytesClick) {
              e.stopPropagation();
              onBytesClick(instruction.address, e);
            }
          }}
        >
          <span
            style={{
              color: softwareBreakpointOriginalBytes ? "#ffa726" : "#ce9178",
              fontStyle: softwareBreakpointOriginalBytes ? "italic" : "normal",
            }}
          >
            {softwareBreakpointOriginalBytes || instruction.bytes || "-- -- --"}
          </span>
        </BytesTableCell>

        {/* Instruction Column */}
        <InstructionTableCell
          sx={{
            cursor: onInstructionClick ? "pointer" : "default",
          }}
          onClick={(e) => {
            if (onInstructionClick) {
              e.stopPropagation();
              onInstructionClick(instruction.address, e);
            }
          }}
        >
          {/* WASM block indentation - add padding based on indent level */}
          {instruction.indent != null && instruction.indent > 0 && (
            <span
              style={{
                display: "inline-block",
                width: `${instruction.indent * 16}px`,
                minWidth: `${instruction.indent * 16}px`,
              }}
            />
          )}
          <OpcodeText
            sx={{
              color:
                instruction.opcode === "???" ||
                instruction.opcode === "unknown" ||
                instruction.opcode === "error"
                  ? "#808080" // Gray for invalid/unknown instructions
                  : isJump
                    ? isConditional
                      ? "#cc9900"
                      : "#66cc66"
                    : instruction.isFunctionStart
                      ? "#ffa500"
                      : instruction.isFunctionEnd
                        ? "#ff6b6b"
                        : "#569cd6",
            }}
          >
            {instruction.opcode}
          </OpcodeText>
          {formattedOperands && <OperandsText> {formattedOperands}</OperandsText>}
          {(() => {
            // getFormattedCommentがあればそれを使い、なければinstruction.commentを使う
            const displayComment = getFormattedComment
              ? getFormattedComment(instruction)
              : instruction.comment;
            // ブランチターゲットアドレスを取得（クリック可能かどうかの判定用）
            const branchTargetAddress = getBranchTargetAddress
              ? getBranchTargetAddress(instruction)
              : null;
            const isClickable = branchTargetAddress && onCommentClick;
            return displayComment ? (
              <CommentText
                sx={{
                  color:
                    instruction.isFunctionStart || instruction.isFunctionEnd
                      ? "#ffa500"
                      : "#6a9955",
                  cursor: isClickable ? "pointer" : "inherit",
                  "&:hover": isClickable
                    ? {
                        textDecoration: "underline",
                        color: "#89d185",
                      }
                    : {},
                }}
                onClick={
                  isClickable
                    ? (e: React.MouseEvent) => {
                        e.stopPropagation();
                        onCommentClick(branchTargetAddress);
                      }
                    : undefined
                }
              >
                ; {displayComment}
              </CommentText>
            ) : null;
          })()}
        </InstructionTableCell>
      </TableRow>
    );
  }
);

// VS Code-style C syntax highlighting
const highlightCCode = (code: string): React.ReactNode[] => {
  const tokens: React.ReactNode[] = [];
  let remaining = code;
  let key = 0;

  // Color definitions (VS Code Dark+ theme)
  const colors = {
    keyword: "#569cd6", // blue - control keywords
    type: "#4ec9b0", // teal - types
    function: "#dcdcaa", // yellow - function calls
    string: "#ce9178", // orange - strings
    number: "#b5cea8", // light green - numbers
    comment: "#6a9955", // green - comments
    preprocessor: "#c586c0", // purple - preprocessor
    operator: "#d4d4d4", // white - operators
    default: "#d4d4d4", // white - default
  };

  const keywords = [
    "if",
    "else",
    "for",
    "while",
    "do",
    "switch",
    "case",
    "default",
    "break",
    "continue",
    "return",
    "goto",
    "sizeof",
    "NULL",
    "nullptr",
  ];

  const types = [
    "void",
    "int",
    "char",
    "short",
    "long",
    "float",
    "double",
    "unsigned",
    "signed",
    "const",
    "static",
    "extern",
    "volatile",
    "struct",
    "typedef",
    "enum",
    "union",
    "auto",
    "register",
    "inline",
    "size_t",
    "uint8_t",
    "uint16_t",
    "uint32_t",
    "uint64_t",
    "int8_t",
    "int16_t",
    "int32_t",
    "int64_t",
    "bool",
    "true",
    "false",
  ];

  const addToken = (text: string, color: string) => {
    tokens.push(
      <span key={key++} style={{ color }}>
        {text}
      </span>
    );
  };

  while (remaining.length > 0) {
    let matched = false;

    // Single-line comment
    if (remaining.startsWith("//")) {
      const endIdx = remaining.indexOf("\n");
      const comment = endIdx >= 0 ? remaining.slice(0, endIdx) : remaining;
      addToken(comment, colors.comment);
      remaining = endIdx >= 0 ? remaining.slice(endIdx) : "";
      matched = true;
    }
    // Multi-line comment
    else if (remaining.startsWith("/*")) {
      const endIdx = remaining.indexOf("*/");
      const comment = endIdx >= 0 ? remaining.slice(0, endIdx + 2) : remaining;
      addToken(comment, colors.comment);
      remaining = endIdx >= 0 ? remaining.slice(endIdx + 2) : "";
      matched = true;
    }
    // Preprocessor directive
    else if (remaining.match(/^#\w*/)) {
      const match = remaining.match(/^#\w*/);
      if (match) {
        addToken(match[0], colors.preprocessor);
        remaining = remaining.slice(match[0].length);
        matched = true;
      }
    }
    // String literal
    else if (remaining.startsWith('"')) {
      let endIdx = 1;
      while (endIdx < remaining.length) {
        if (remaining[endIdx] === "\\") {
          endIdx += 2;
        } else if (remaining[endIdx] === '"') {
          endIdx++;
          break;
        } else {
          endIdx++;
        }
      }
      addToken(remaining.slice(0, endIdx), colors.string);
      remaining = remaining.slice(endIdx);
      matched = true;
    }
    // Character literal
    else if (remaining.startsWith("'")) {
      let endIdx = 1;
      while (endIdx < remaining.length) {
        if (remaining[endIdx] === "\\") {
          endIdx += 2;
        } else if (remaining[endIdx] === "'") {
          endIdx++;
          break;
        } else {
          endIdx++;
        }
      }
      addToken(remaining.slice(0, endIdx), colors.string);
      remaining = remaining.slice(endIdx);
      matched = true;
    }
    // Number (hex, float, int)
    else if (remaining.match(/^0x[0-9a-fA-F]+/)) {
      const match = remaining.match(/^0x[0-9a-fA-F]+/);
      if (match) {
        addToken(match[0], colors.number);
        remaining = remaining.slice(match[0].length);
        matched = true;
      }
    } else if (remaining.match(/^\d+\.?\d*[fF]?/)) {
      const match = remaining.match(/^\d+\.?\d*[fF]?/);
      if (match) {
        addToken(match[0], colors.number);
        remaining = remaining.slice(match[0].length);
        matched = true;
      }
    }
    // Identifier (keyword, type, or function)
    else if (remaining.match(/^[a-zA-Z_][a-zA-Z0-9_]*/)) {
      const match = remaining.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
      if (match) {
        const word = match[0];
        const afterWord = remaining.slice(word.length);
        // Check if it's a function call (followed by parenthesis)
        const isFunctionCall = afterWord.match(/^\s*\(/);

        if (keywords.includes(word)) {
          addToken(word, colors.keyword);
        } else if (types.includes(word)) {
          addToken(word, colors.type);
        } else if (isFunctionCall) {
          addToken(word, colors.function);
        } else {
          addToken(word, colors.default);
        }
        remaining = afterWord;
        matched = true;
      }
    }

    // If nothing matched, add single character
    if (!matched) {
      addToken(remaining[0], colors.default);
      remaining = remaining.slice(1);
    }
  }

  return tokens;
};

export const AssemblyView: React.FC<AssemblyViewProps> = ({
  serverInfo,
  onBreakpointSet,
  onBreakpointRemove,
  onBreakpointHit,
  currentBreakAddress,
  isInBreakState = false,
  activeBreakpoints = [], // Add activeBreakpoints prop with default empty array
  softwareBreakpoints = new Map(), // Map of address to original bytes for software BPs
  isSoftwareBreakpoint = false, // Whether to set software breakpoints
  attachedModules = [], // Add attachedModules prop with default empty array
  registerData = {}, // Register data for branch prediction
  isDecompileVisible = true,
  onToggleDecompile: _onToggleDecompile,
  hasDecompileResult: _hasDecompileResult = false,
  onDecompileRequest,
  onDecompileError,
  onAssemblyAddressClicked,
  highlightAddress,
  onHighlightComplete,
}) => {
  const { addLog } = useGlobalDebugLogger();
  
  // Check if WASM mode (no debugger features available)
  const isWasmMode = serverInfo?.arch === "wasm32" || serverInfo?.mode === "wasm";

  // グローバルストアからassemblyAddressを取得
  const assemblyAddress = useUIStore(
    (state) => state.debuggerState.assemblyAddress
  );
  // ナビゲーショントリガーも取得（同じアドレスへの連続goto用）
  const assemblyNavigationTrigger = useUIStore(
    (state) => state.debuggerState.assemblyNavigationTrigger
  );
  // グローバルストアへの更新関数を取得
  const setAssemblyAddress = useUIStore(
    (state) => state.actions.setAssemblyAddress
  );
  // Navigate with history tracking for Back button
  const setAssemblyAddressWithHistory = useUIStore(
    (state) => state.actions.setAssemblyAddressWithHistory
  );

  // Table column resize hook
  const columnResize = useTableColumnResize({
    storageKey: "assembly-view-column-widths",
    defaultWidths: {
      breakpoint: 24,
      address: 120,
      detail: 200,
      bytes: 120,
    },
    minWidth: 30,
    maxWidth: 500,
  });

  const [instructions, setInstructions] = useState<Instruction[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [currentBaseAddress, setCurrentBaseAddress] = useState<number>(0); // Always points to the first instruction in buffer
  const [bufferSize] = useState<number>(1024); // Reduced buffer size for faster loading
  const [instructionBuffer, setInstructionBuffer] = useState<Instruction[]>([]);
  const [viewportStart, setViewportStart] = useState<number>(0);
  const [viewportSize] = useState<number>(40); // Instructions to display in viewport

  // Context menu state
  const [contextMenu, setContextMenu] = useState<{
    mouseX: number;
    mouseY: number;
    address: string;
    instruction: Instruction;
  } | null>(null);

  // Trace count dialog state
  const [traceCountDialogOpen, setTraceCountDialogOpen] = useState(false);
  const [traceCountInput, setTraceCountInput] = useState("100");
  const [traceEndAddressInput, setTraceEndAddressInput] = useState(""); // Optional end address
  const [pendingTraceAddress, setPendingTraceAddress] = useState<string>("");
  const [traceToFile, setTraceToFile] = useState(false); // Trace to file option
  // Full memory cache option (currently disabled in UI)
  const fullMemoryCache = false;

  // File trace progress state
  const [fileTraceProgress, setFileTraceProgress] = useState<{
    isActive: boolean;
    current: number;
    total: number;
    filePath: string;
  } | null>(null);

  // File trace download dialog state
  const [fileTraceCompleteDialog, setFileTraceCompleteDialog] = useState<{
    open: boolean;
    entryCount: number;
    filePath: string;
    downloaded: boolean;
  }>({ open: false, entryCount: 0, filePath: "", downloaded: false });

  // Graph View address range dialog state
  const [graphViewDialogOpen, setGraphViewDialogOpen] = useState(false);
  const [graphViewStartAddress, setGraphViewStartAddress] =
    useState<string>("");
  const [graphViewEndAddress, setGraphViewEndAddress] = useState<string>("");
  const [pendingGraphViewAddress, setPendingGraphViewAddress] =
    useState<string>("");
  const [pendingGraphViewFunctionName, setPendingGraphViewFunctionName] =
    useState<string | undefined>(undefined);

  // Ghidra integration state
  const GHIDRA_PATH_KEY = "dynadbg_ghidra_path";
  const [ghidraSettingsDialogOpen, setGhidraSettingsDialogOpen] =
    useState(false);
  const [ghidraPathInput, setGhidraPathInput] = useState<string>("");
  const [pendingGhidraAction, setPendingGhidraAction] = useState<
    "analyze" | "decompile" | null
  >(null);
  const [pendingGhidraLibraryInfo, setPendingGhidraLibraryInfo] = useState<{
    path: string;
    offset: number;
    functionStartOffset: number | null;
    functionName: string | null;
    moduleBase: number;
  } | null>(null);
  const [pendingGhidraAddress, setPendingGhidraAddress] = useState<
    string | null
  >(null);
  const {
    isAnalyzing,
    isDecompiling,
    analysisProgress,
    isLibraryAnalyzed,
    analyzeLibrary,
    decompileFunction,
    getXrefs,
    getDecompileFromCache,
    getXrefFromCache,
    saveDecompileToCache,
    saveXrefToCache,
    serverRunning,
    serverProjectPath,
    getAnalyzedLibraryInfo,
  } = useGhidraAnalysis();

  // Xref dialog state
  const [xrefDialogOpen, setXrefDialogOpen] = useState(false);
  const [xrefLoading, setXrefLoading] = useState(false);
  const [xrefData, setXrefData] = useState<{
    targetFunction: string;
    targetAddress: string;
    moduleBase: number; // Module base address for converting offset to real address
    moduleName: string; // Module name for display
    xrefs: Array<{
      from_address: string;
      from_function: string | null;
      from_function_offset?: string | null;
      ref_type: string;
      instruction?: string | null;
    }>;
  } | null>(null);

  // Debugger settings dialog state (from global store)
  const debuggerSettingsOpen = useUIStore(
    (state) => state.debuggerState.debuggerSettingsOpen
  );
  const setDebuggerSettingsOpen = useUIStore(
    (state) => state.actions.setDebuggerSettingsOpen
  );
  // Signal configs: map from signal number to {catch_signal, pass_signal}
  // Persisted to localStorage as array of [signal, config] tuples
  const [signalConfigsArray, setSignalConfigsArray] = useLocalStorage<
    Array<[number, { catch_signal: boolean; pass_signal: boolean }]>
  >("debugger-signal-configs", []);

  // Convert array to Map for easy lookup
  const signalConfigs = useMemo(
    () => new Map(signalConfigsArray),
    [signalConfigsArray]
  );

  // Helper to update signal configs (converts Map to array for storage)
  const setSignalConfigs = useCallback(
    (
      updater:
        | Map<number, { catch_signal: boolean; pass_signal: boolean }>
        | ((
            prev: Map<number, { catch_signal: boolean; pass_signal: boolean }>
          ) => Map<number, { catch_signal: boolean; pass_signal: boolean }>)
    ) => {
      if (typeof updater === "function") {
        setSignalConfigsArray((prevArray) => {
          const prevMap = new Map(prevArray);
          const newMap = updater(prevMap);
          return Array.from(newMap.entries());
        });
      } else {
        setSignalConfigsArray(Array.from(updater.entries()));
      }
    },
    [setSignalConfigsArray]
  );

  const [loadingSignals, setLoadingSignals] = useState(false);
  const [signalSortField, setSignalSortField] = useState<"signal" | "name">(
    "signal"
  );
  const [signalSortOrder, setSignalSortOrder] = useState<"asc" | "desc">("asc");

  // Signal definitions for UI (default: not monitored = signals passed to process)
  const signalDefinitions = useMemo(() => {
    const defs = [
      { signal: 4, name: "SIGILL", description: "Illegal instruction" },
      { signal: 6, name: "SIGABRT", description: "Process abort signal" },
      {
        signal: 7,
        name: "SIGBUS",
        description: "Bus error (bad memory access)",
      },
      { signal: 8, name: "SIGFPE", description: "Floating-point exception" },
      { signal: 11, name: "SIGSEGV", description: "Segmentation fault" },
    ];
    return [...defs].sort((a, b) => {
      const aVal = a[signalSortField];
      const bVal = b[signalSortField];
      if (typeof aVal === "number" && typeof bVal === "number") {
        return signalSortOrder === "asc" ? aVal - bVal : bVal - aVal;
      }
      const aStr = String(aVal);
      const bStr = String(bVal);
      return signalSortOrder === "asc"
        ? aStr.localeCompare(bStr)
        : bStr.localeCompare(aStr);
    });
  }, [signalSortField, signalSortOrder]);

  const handleSignalSortChange = useCallback(
    (field: "signal" | "name") => {
      if (signalSortField === field) {
        setSignalSortOrder((order) => (order === "asc" ? "desc" : "asc"));
      } else {
        setSignalSortField(field);
        setSignalSortOrder("asc");
      }
    },
    [signalSortField]
  );

  // Processing snackbar state for long-running Ghidra operations
  const [processingSnackbar, setProcessingSnackbar] = useState<{
    open: boolean;
    message: string;
  }>({ open: false, message: "" });

  // Convert activeBreakpoints array to Set for faster lookups
  const breakpoints = useMemo(
    () => new Set(activeBreakpoints),
    [activeBreakpoints]
  );

  /* Check if the current view's module is analyzed (for showing Decompile icon) - currently unused
  const isCurrentLibraryAnalyzed = useMemo(() => {
    if (!instructionBuffer.length || !attachedModules.length) return false;

    // Get the first instruction's address to determine the module
    const firstInstruction = instructionBuffer[0];
    if (!firstInstruction) return false;

    const address = firstInstruction.address;
    let numericAddress: number;
    if (address.startsWith("0x") || address.startsWith("0X")) {
      numericAddress = parseInt(address, 16);
    } else {
      numericAddress = parseInt(address, 10);
    }

    if (isNaN(numericAddress)) return false;

    // Find the module for this address
    for (const module of attachedModules) {
      const moduleBase = module.base;
      const moduleEnd = moduleBase + module.size;

      if (numericAddress >= moduleBase && numericAddress < moduleEnd) {
        const modulePath = module.modulename || module.name || "";
        return isLibraryAnalyzed(modulePath);
      }
    }

    return false;
  }, [instructionBuffer, attachedModules, isLibraryAnalyzed]);
  */

  // アドレス表示形式の取得（library / function）
  const addressDisplayFormat = useUIStore(
    (state) => state.debuggerState.addressDisplayFormat
  );
  const toggleAddressDisplayFormat = useUIStore(
    (state) => state.actions.toggleAddressDisplayFormat
  );

  // Assembly Demangle設定の取得
  const assemblyDemangleEnabled = useUIStore(
    (state) => state.debuggerState.assemblyDemangleEnabled
  );
  const toggleAssemblyDemangle = useUIStore(
    (state) => state.actions.toggleAssemblyDemangle
  );

  // Source Code Level Debug設定の取得
  const sourceCodeLevelDebug = useUIStore(
    (state) => state.debuggerState.sourceCodeLevelDebug
  );
  const toggleSourceCodeLevelDebug = useUIStore(
    (state) => state.actions.toggleSourceCodeLevelDebug
  );

  // DWARF解析結果を取得（ソースコード表示用）
  const dwarfAnalysisResult = useUIStore(
    (state) => state.toolsState.debugState?.analysisResult
  );

  // ソースブレークポイント一覧を取得
  const sourceBreakpoints = useUIStore(
    (state) =>
      state.toolsState.debugState?.sourceBreakpoints ?? EMPTY_SOURCE_BREAKPOINTS
  );

  // 現在停止中のアドレス
  const currentHitAddress = useUIStore(
    (state) => state.toolsState.debugState?.currentHitAddress
  );

  const selectedModuleBase = useUIStore(
    (state) => state.toolsState.debugState?.selectedModuleBase
  );

  const addSourceBreakpoint = useUIStore(
    (state) => state.actions.addSourceBreakpoint
  );
  const removeSourceBreakpoint = useUIStore(
    (state) => state.actions.removeSourceBreakpoint
  );

  const sourceRootPath = useUIStore(
    (state) => state.toolsState.debugState?.sourceRootPath || ""
  );

  // NDKパスを取得（Android NDK用）
  const ndkPath = useUIStore(
    (state) => state.toolsState.debugState?.ndkPath || ""
  );

  // OUTLINEからのソースジャンプリクエストを取得
  const pendingSourceJump = useUIStore(
    (state) => state.toolsState.debugState?.pendingSourceJump
  );
  const setPendingSourceJump = useUIStore(
    (state) => state.actions.setPendingSourceJump
  );

  // ソースコードキャッシュ（ファイルパス -> ソースコード行配列）
  const [sourceCodeCache, setSourceCodeCache] = useState<
    Map<string, { lines: string[]; loading: boolean; error: string | null }>
  >(new Map());

  // 選択中のソースファイルタブ（VS Codeライクなタブ管理）
  const [activeSourceTab, setActiveSourceTab] = useState<string | null>(null);
  const [openSourceTabs, setOpenSourceTabs] = useState<string[]>([]);

  // ソースファイルを読み込む（ホストOSのローカルファイルから）
  const loadSourceFile = useCallback(
    async (filePath: string, _directory: string | null) => {
      // sourceRootPathが設定されていない場合はスキップ
      if (!sourceRootPath) {
        setSourceCodeCache((prev) => {
          const next = new Map(prev);
          next.set(filePath, {
            lines: [],
            loading: false,
            error:
              "Source root path not set. Configure it in Tools → DWARF tab.",
          });
          return next;
        });
        return;
      }

      // 既にキャッシュにある場合はスキップ
      if (sourceCodeCache.has(filePath)) return;

      // ローディング状態を設定
      setSourceCodeCache((prev) => {
        const next = new Map(prev);
        next.set(filePath, { lines: [], loading: true, error: null });
        return next;
      });

      // ファイルパスの候補を構築
      const pathCandidates: string[] = [];

      // 1. ソースルートパスからの相対パス
      pathCandidates.push(`${sourceRootPath}/${filePath}`);

      // 2. NDKシステムヘッダーへのフォールバック（Android用）
      if (ndkPath) {
        // NDKヘッダーのパス例:
        // NDK/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/...
        // NDK/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/...
        const sysrootPaths = [
          `${ndkPath}/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include`,
          `${ndkPath}/toolchains/llvm/prebuilt/darwin-arm64/sysroot/usr/include`,
          `${ndkPath}/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include`,
          `${ndkPath}/toolchains/llvm/prebuilt/windows-x86_64/sysroot/usr/include`,
        ];

        // ファイルパスからヘッダー部分を抽出
        // 例: /path/to/ndk/.../sysroot/usr/include/bits/fortify/string.h
        //     -> bits/fortify/string.h
        const headerMatch = filePath.match(
          /(?:sysroot\/usr\/include\/|usr\/include\/)(.+)$/
        );
        if (headerMatch) {
          const headerPath = headerMatch[1];
          for (const sysroot of sysrootPaths) {
            pathCandidates.push(`${sysroot}/${headerPath}`);
          }
        }

        // システムヘッダーパターン（例: <string.h>, <stdio.h>）
        // DWARFのパスがNDKのsysroot内を指している場合
        if (
          filePath.includes("/sysroot/") ||
          filePath.includes("/include/") ||
          filePath.includes("\\sysroot\\") ||
          filePath.includes("\\include\\")
        ) {
          const parts = filePath.split(/[\/\\]/);
          const includeIdx = parts.lastIndexOf("include");
          if (includeIdx >= 0 && includeIdx < parts.length - 1) {
            const headerRelPath = parts.slice(includeIdx + 1).join("/");
            for (const sysroot of sysrootPaths) {
              pathCandidates.push(`${sysroot}/${headerRelPath}`);
            }
          }
        }
      }

      // 3. 絶対パスの場合はそのまま試す
      if (filePath.startsWith("/")) {
        pathCandidates.push(filePath);
      }

      // 候補を順に試す
      let lastError: string | null = null;
      for (const candidatePath of pathCandidates) {
        try {
          const content = await invoke<string>("read_local_text_file", {
            filePath: candidatePath,
          });

          const lines = content.split("\n");

          setSourceCodeCache((prev) => {
            const next = new Map(prev);
            next.set(filePath, { lines, loading: false, error: null });
            return next;
          });
          return; // 成功したら終了
        } catch (e) {
          lastError = `${e}`;
          // 次の候補を試す
        }
      }

      // 全ての候補が失敗
      console.error(`Failed to load source file: ${filePath}`, lastError);
      setSourceCodeCache((prev) => {
        const next = new Map(prev);
        next.set(filePath, {
          lines: [],
          loading: false,
          error: `Failed to load: ${lastError}`,
        });
        return next;
      });
    },
    [sourceCodeCache, sourceRootPath, ndkPath]
  );

  // ソースファイルが変わったら読み込む＆タブを開く
  // Also auto-open first file when sourceCodeLevelDebug is enabled
  useEffect(() => {
    if (
      sourceCodeLevelDebug &&
      sourceRootPath &&
      dwarfAnalysisResult?.source_files?.length > 0
    ) {
      // 最初のソースファイルを読み込む
      const firstFile = dwarfAnalysisResult.source_files[0];
      if (firstFile) {
        loadSourceFile(firstFile.path, firstFile.directory);
        // タブが開いていなければ開く
        if (!openSourceTabs.includes(firstFile.path)) {
          setOpenSourceTabs((prev) => [...prev, firstFile.path]);
        }
        // アクティブタブを設定（常に設定して初期表示を確実に）
        if (!activeSourceTab) {
          setActiveSourceTab(firstFile.path);
        }
      }
    }
  }, [
    sourceCodeLevelDebug,
    sourceRootPath,
    dwarfAnalysisResult?.source_files,
    loadSourceFile,
  ]);

  // Ensure activeSourceTab is set when openSourceTabs changes
  useEffect(() => {
    if (sourceCodeLevelDebug && openSourceTabs.length > 0 && !activeSourceTab) {
      setActiveSourceTab(openSourceTabs[0]);
    }
  }, [sourceCodeLevelDebug, openSourceTabs, activeSourceTab]);

  // ソースタブを開く
  const openSourceTab = useCallback(
    (filePath: string, directory: string | null) => {
      loadSourceFile(filePath, directory);
      if (!openSourceTabs.includes(filePath)) {
        setOpenSourceTabs((prev) => [...prev, filePath]);
      }
      setActiveSourceTab(filePath);
    },
    [loadSourceFile, openSourceTabs]
  );

  // ソースタブを閉じる
  const closeSourceTab = useCallback(
    (filePath: string) => {
      setOpenSourceTabs((prev) => {
        const newTabs = prev.filter((p) => p !== filePath);
        // 閉じたタブがアクティブだった場合、別のタブをアクティブにする
        if (activeSourceTab === filePath && newTabs.length > 0) {
          const idx = prev.indexOf(filePath);
          const newActiveIdx = Math.min(idx, newTabs.length - 1);
          setActiveSourceTab(newTabs[newActiveIdx]);
        } else if (newTabs.length === 0) {
          setActiveSourceTab(null);
        }
        return newTabs;
      });
    },
    [activeSourceTab]
  );

  // サイドバーからのソースファイル開くイベントをリッスン
  useEffect(() => {
    const handleOpenSourceFile = (
      event: CustomEvent<{ path: string; directory: string | null }>
    ) => {
      openSourceTab(event.detail.path, event.detail.directory);
    };

    window.addEventListener(
      "openSourceFile",
      handleOpenSourceFile as EventListener
    );
    return () => {
      window.removeEventListener(
        "openSourceFile",
        handleOpenSourceFile as EventListener
      );
    };
  }, [openSourceTab]);

  // Scroll target line ref for OUTLINE jump
  const pendingScrollLineRef = useRef<number | null>(null);

  // Handle pending source jump from OUTLINE click
  useEffect(() => {
    if (!pendingSourceJump || !sourceCodeLevelDebug) return;

    const { filePath, line } = pendingSourceJump;

    // Find matching file in DWARF analysis result
    const matchingFile = dwarfAnalysisResult?.source_files?.find(
      (f: any) =>
        f.path === filePath ||
        f.path.endsWith(filePath) ||
        filePath.endsWith(f.path)
    );

    if (matchingFile) {
      // Open the tab and set scroll target
      const directory = matchingFile.directory || null;
      openSourceTab(matchingFile.path, directory);
      pendingScrollLineRef.current = line;
    }

    // Clear the pending jump request
    setPendingSourceJump(null);
  }, [
    pendingSourceJump,
    sourceCodeLevelDebug,
    dwarfAnalysisResult?.source_files,
    openSourceTab,
    setPendingSourceJump,
  ]);

  // Scroll to target line when source code is loaded
  useEffect(() => {
    if (pendingScrollLineRef.current === null || !activeSourceTab) return;

    const cache = sourceCodeCache.get(activeSourceTab);
    if (!cache || cache.loading || cache.error) return;

    // Scroll to the target line
    const targetLine = pendingScrollLineRef.current;
    pendingScrollLineRef.current = null;

    // Use setTimeout to ensure DOM is updated
    setTimeout(() => {
      const lineElement = document.querySelector(
        `[data-line-number="${targetLine}"]`
      );
      if (lineElement) {
        lineElement.scrollIntoView({ behavior: "smooth", block: "center" });
        // Briefly highlight the line
        (lineElement as HTMLElement).style.backgroundColor =
          "rgba(79, 193, 255, 0.3)";
        setTimeout(() => {
          (lineElement as HTMLElement).style.backgroundColor = "";
        }, 1500);
      }
    }, 100);
  }, [activeSourceTab, sourceCodeCache]);

  const {
    formatAddressWithSymbol,
    ensureModuleSymbolsLoaded,
    loadedModuleCount,
    updateServerInfo,
  } = useSymbolCache();

  const { state: tauriState } = useTauriSystemStateSingleton();

  // Must sync server info before formatAddressWithSymbol calls loadModuleSymbolsInternal
  useEffect(() => {
    console.log(
      `[AssemblyView] tauriState check: host=${tauriState?.connectionHost}, port=${tauriState?.connectionPort}, tauriState=${tauriState ? "exists" : "null"}`
    );
    if (tauriState?.connectionHost && tauriState?.connectionPort) {
      console.log(
        `[AssemblyView] Updating server info: ${tauriState.connectionHost}:${tauriState.connectionPort}, targetOs: ${serverInfo?.target_os}`
      );
      updateServerInfo({
        ip: tauriState.connectionHost,
        port: tauriState.connectionPort,
        targetOs: serverInfo?.target_os,
      });
    }
  }, [
    tauriState?.connectionHost,
    tauriState?.connectionPort,
    serverInfo?.target_os,
    updateServerInfo,
  ]);

  // 接続情報が更新されたら、現在表示中のモジュールのシンボルをロード
  // これにより、build時の初期化タイミング問題を解消
  useEffect(() => {
    if (currentBaseAddress === 0 || !attachedModules.length) return;

    // 接続情報がない場合はスキップ
    if (!tauriState?.connectionHost || !tauriState?.connectionPort) {
      return;
    }

    const serverInfo = {
      ip: tauriState.connectionHost,
      port: tauriState.connectionPort,
    };

    // モジュールのシンボルがなければバックグラウンドでロード
    ensureModuleSymbolsLoaded(
      currentBaseAddress,
      attachedModules,
      serverInfo
    ).then((loaded) => {
      if (loaded) {
        console.log(
          `[AssemblyView] Symbol loading triggered for address 0x${currentBaseAddress.toString(16)}`
        );
      }
    });
  }, [
    currentBaseAddress,
    attachedModules,
    ensureModuleSymbolsLoaded,
    tauriState?.connectionHost,
    tauriState?.connectionPort,
  ]);

  // アドレス解決結果のキャッシュ（レンダリングパフォーマンス向上用）
  const addressResolutionCache = useRef<Map<string, string>>(new Map());

  // キャッシュをクリアするトリガー（モジュール情報やシンボルが変わったとき）
  useEffect(() => {
    addressResolutionCache.current.clear();
  }, [attachedModules, loadedModuleCount, addressDisplayFormat]);

  // Function to get module detail text for tooltip
  const getModuleDetailText = useCallback(
    (address: string): string => {
      if (!attachedModules.length) return "";

      // キャッシュをチェック
      const cached = addressResolutionCache.current.get(address);
      if (cached !== undefined) return cached;

      // アドレスを数値に変換
      let numericAddress: number;
      if (address.startsWith("0x") || address.startsWith("0X")) {
        numericAddress = parseInt(address, 16);
      } else {
        numericAddress = parseInt(address, 10);
      }

      if (isNaN(numericAddress)) {
        addressResolutionCache.current.set(address, "");
        return "";
      }

      const result = formatAddressWithSymbol(
        numericAddress,
        attachedModules,
        addressDisplayFormat
      );
      if (result) {
        addressResolutionCache.current.set(address, result);
        return result;
      }

      // フォールバック: 従来の library + offset 形式
      for (const module of attachedModules) {
        const moduleBase = module.base;
        const moduleEnd = moduleBase + module.size;

        if (numericAddress >= moduleBase && numericAddress < moduleEnd) {
          const offset = numericAddress - moduleBase;
          const fullModuleName = module.modulename || module.name || "unknown";

          // フルパスからファイル名のみを抽出
          const fileName =
            fullModuleName.split(/[\/\\]/).pop() || fullModuleName;

          const fallbackResult = `${fileName} + 0x${offset.toString(16)}`;
          addressResolutionCache.current.set(address, fallbackResult);
          return fallbackResult;
        }
      }

      // モジュール外のアドレスもキャッシュ
      addressResolutionCache.current.set(address, "");
      return "";
    },
    [
      attachedModules,
      addressDisplayFormat,
      formatAddressWithSymbol,
      loadedModuleCount,
    ]
  );

  // Function to get module detail for an address
  const getModuleDetail = useCallback(
    (address: string): React.ReactNode => {
      if (!attachedModules.length) return "";

      // アドレスを数値に変換
      let numericAddress: number;
      if (address.startsWith("0x") || address.startsWith("0X")) {
        numericAddress = parseInt(address, 16);
      } else {
        numericAddress = parseInt(address, 10);
      }

      if (isNaN(numericAddress)) return "";

      const result = formatAddressWithSymbol(
        numericAddress,
        attachedModules,
        addressDisplayFormat
      );
      if (result) {
        if (addressDisplayFormat === "function" && result.includes("@")) {
          // module@function + offset 形式
          const atIndex = result.indexOf("@");
          const plusIndex = result.indexOf(" + ");
          if (plusIndex > atIndex) {
            const modulePart = result.substring(0, atIndex);
            const funcPart = result.substring(atIndex + 1, plusIndex);
            const offsetPart = result.substring(plusIndex);
            return (
              <>
                <span className="filename">{modulePart}</span>
                <span className="function" style={{ color: "#dcdcaa" }}>
                  @{funcPart}
                </span>
                <span className="offset">{offsetPart}</span>
              </>
            );
          } else if (plusIndex === -1 && result.includes("@")) {
            // offset なし (module@function のみ)
            const modulePart = result.substring(0, atIndex);
            const funcPart = result.substring(atIndex + 1);
            return (
              <>
                <span className="filename">{modulePart}</span>
                <span className="function" style={{ color: "#dcdcaa" }}>
                  @{funcPart}
                </span>
              </>
            );
          }
        }
        // library + offset 形式
        const plusIndex = result.indexOf(" + ");
        if (plusIndex > 0) {
          const fileName = result.substring(0, plusIndex);
          const offset = result.substring(plusIndex);
          return (
            <>
              <span className="filename">{fileName}</span>
              <span className="offset">{offset}</span>
            </>
          );
        }
        return result;
      }

      // フォールバック: 従来の処理
      for (const module of attachedModules) {
        const moduleBase = module.base;
        const moduleEnd = moduleBase + module.size;

        if (numericAddress >= moduleBase && numericAddress < moduleEnd) {
          const offset = numericAddress - moduleBase;
          const fullModuleName = module.modulename || module.name || "unknown";

          // フルパスからファイル名のみを抽出
          const fileName =
            fullModuleName.split(/[\/\\]/).pop() || fullModuleName;

          // filename部分に色を付けてJSXで返す
          return (
            <>
              <span className="filename">{fileName}</span>
              <span className="offset"> + 0x{offset.toString(16)}</span>
            </>
          );
        }
      }

      return "";
    },
    [
      attachedModules,
      addressDisplayFormat,
      formatAddressWithSymbol,
      loadedModuleCount,
    ]
  );

  // Function to get library+offset or library@function+offset expression for branch target addresses
  const getBranchTargetLibraryExpression = useCallback(
    (operands: string): string | null => {
      if (!attachedModules.length) return null;

      // Extract address from operands (handle various formats)
      // Common patterns: "0x1234", "#0x1234", "0x1234 <symbol>"
      const addressMatch = operands.match(/(0x[0-9a-fA-F]+)/);
      if (!addressMatch) return null;

      const addressStr = addressMatch[1];
      const numericAddress = parseInt(addressStr, 16);

      if (isNaN(numericAddress)) return null;

      const result = formatAddressWithSymbol(
        numericAddress,
        attachedModules,
        addressDisplayFormat
      );
      if (result) return result;

      // フォールバック: 従来の library+offset 形式
      const libraryExpr = encodeAddressToLibraryExpression(
        numericAddress,
        attachedModules,
        true // prefer short filename
      );

      return libraryExpr;
    },
    [
      attachedModules,
      addressDisplayFormat,
      formatAddressWithSymbol,
      loadedModuleCount,
    ]
  );

  // Function to get formatted comment for an instruction based on address display format
  // This allows comments to dynamically update when addressDisplayFormat changes
  const getFormattedComment = useCallback(
    (instruction: Instruction): string => {
      // Function labels and special comments should be preserved as-is
      if (
        instruction.isFunction ||
        instruction.isFunctionStart ||
        instruction.isFunctionEnd
      ) {
        return instruction.comment;
      }

      // For RET/BR/BLR instructions in break state, show the predicted target address
      const opcodeLower = instruction.opcode.toLowerCase();
      if (
        isInBreakState &&
        currentBreakAddress &&
        Object.keys(registerData).length > 0
      ) {
        // Normalize addresses for comparison
        const normalizedInstrAddr = instruction.address
          .toLowerCase()
          .replace(/^0x0*/, "0x");
        const normalizedBreakAddr = currentBreakAddress
          .toLowerCase()
          .replace(/^0x0*/, "0x");

        // Only show prediction for the current break instruction
        if (normalizedInstrAddr === normalizedBreakAddr) {
          // RET instructions - use LR (X30)
          if (
            opcodeLower === "ret" ||
            opcodeLower === "retaa" ||
            opcodeLower === "retab"
          ) {
            // Get LR (X30) value from register data
            const lrValue =
              registerData["LR"] ||
              registerData["lr"] ||
              registerData["X30"] ||
              registerData["x30"];
            if (lrValue) {
              // Format the return address
              const lrAddr = lrValue.startsWith("0x")
                ? lrValue
                : `0x${lrValue}`;
              // Try to get library expression for the return address
              const libraryExpr = getBranchTargetLibraryExpression(lrAddr);
              if (libraryExpr) {
                return `return to ${libraryExpr}`;
              }
              return `return to ${lrAddr}`;
            }
          }

          // BR/BLR instructions - use the register from operand
          if (
            opcodeLower === "br" ||
            opcodeLower === "blr" ||
            opcodeLower === "braa" ||
            opcodeLower === "brab" ||
            opcodeLower === "blraa" ||
            opcodeLower === "blrab" ||
            opcodeLower === "braaz" ||
            opcodeLower === "brabz" ||
            opcodeLower === "blraaz" ||
            opcodeLower === "blrabz"
          ) {
            // Get the register name from operands
            const operandsStr = instruction.operands
              .map((op) => op.value)
              .join(", ")
              .trim();
            // Extract register name (e.g., "x8", "x16", etc.)
            const regMatch = operandsStr.match(/^(x\d+|lr)$/i);
            if (regMatch) {
              const regName = regMatch[1].toLowerCase();
              // Map lr to x30
              const lookupName = regName === "lr" ? "x30" : regName;
              const regValue =
                registerData[lookupName.toUpperCase()] ||
                registerData[lookupName];
              if (regValue) {
                const targetAddr = regValue.startsWith("0x")
                  ? regValue
                  : `0x${regValue}`;
                const libraryExpr =
                  getBranchTargetLibraryExpression(targetAddr);
                const actionWord = opcodeLower.startsWith("blr")
                  ? "call"
                  : "jump to";
                if (libraryExpr) {
                  return `${actionWord} ${libraryExpr}`;
                }
                return `${actionWord} ${targetAddr}`;
              }
            }
          }
        }
      }

      // For jump instructions, dynamically generate the comment based on current display format
      if (
        isJumpInstruction(instruction.opcode) &&
        instruction.operands.length > 0
      ) {
        const operandsStr = instruction.operands
          .map((op) => op.value)
          .join(", ");
        const libraryExpr = getBranchTargetLibraryExpression(operandsStr);
        if (libraryExpr) {
          return libraryExpr;
        }
      }

      // For other instructions, return the original comment
      return instruction.comment;
    },
    [
      getBranchTargetLibraryExpression,
      isInBreakState,
      currentBreakAddress,
      registerData,
    ]
  );

  // Function to extract branch target address from instruction operands
  // Returns the raw address string if found, null otherwise
  const getBranchTargetAddress = useCallback(
    (instruction: Instruction): string | null => {
      const opcodeLower = instruction.opcode.toLowerCase();

      // For RET/BR/BLR instructions in break state, return register value as target
      if (
        isInBreakState &&
        currentBreakAddress &&
        Object.keys(registerData).length > 0
      ) {
        // Normalize addresses for comparison
        const normalizedInstrAddr = instruction.address
          .toLowerCase()
          .replace(/^0x0*/, "0x");
        const normalizedBreakAddr = currentBreakAddress
          .toLowerCase()
          .replace(/^0x0*/, "0x");

        // Only return register value for the current break instruction
        if (normalizedInstrAddr === normalizedBreakAddr) {
          // RET instructions - use LR (X30)
          if (
            opcodeLower === "ret" ||
            opcodeLower === "retaa" ||
            opcodeLower === "retab"
          ) {
            const lrValue =
              registerData["LR"] ||
              registerData["lr"] ||
              registerData["X30"] ||
              registerData["x30"];
            if (lrValue) {
              return lrValue.startsWith("0x") ? lrValue : `0x${lrValue}`;
            }
          }

          // BR/BLR instructions - use the register from operand
          if (
            opcodeLower === "br" ||
            opcodeLower === "blr" ||
            opcodeLower === "braa" ||
            opcodeLower === "brab" ||
            opcodeLower === "blraa" ||
            opcodeLower === "blrab" ||
            opcodeLower === "braaz" ||
            opcodeLower === "brabz" ||
            opcodeLower === "blraaz" ||
            opcodeLower === "blrabz"
          ) {
            // Get the register name from operands
            const operandsStr = instruction.operands
              .map((op) => op.value)
              .join(", ")
              .trim();
            // Extract register name (e.g., "x8", "x16", etc.)
            const regMatch = operandsStr.match(/^(x\d+|lr)$/i);
            if (regMatch) {
              const regName = regMatch[1].toLowerCase();
              // Map lr to x30
              const lookupName = regName === "lr" ? "x30" : regName;
              const regValue =
                registerData[lookupName.toUpperCase()] ||
                registerData[lookupName];
              if (regValue) {
                return regValue.startsWith("0x") ? regValue : `0x${regValue}`;
              }
            }
          }
        }
      }

      // Only extract address for jump instructions
      if (
        !isJumpInstruction(instruction.opcode) ||
        instruction.operands.length === 0
      ) {
        return null;
      }

      const operandsStr = instruction.operands.map((op) => op.value).join(", ");
      // Extract address from operands (handle various formats)
      // Common patterns: "0x1234", "#0x1234", "0x1234 <symbol>"
      const addressMatch = operandsStr.match(/(0x[0-9a-fA-F]+)/);
      if (addressMatch) {
        return addressMatch[1];
      }

      return null;
    },
    [isInBreakState, currentBreakAddress, registerData]
  );

  const [focusedLineAddress, setFocusedLineAddress] = useState<string | null>(
    null
  );

  // Visibility and caching states for tab switching optimization
  const [isVisible, setIsVisible] = useState(true);
  const [cachedInstructions, setCachedInstructions] = useState<Instruction[]>(
    []
  );
  const [cachedInstructionBuffer, setCachedInstructionBuffer] = useState<
    Instruction[]
  >([]);
  const [cachedViewportStart, setCachedViewportStart] = useState<number>(0);
  const [cachedBaseAddress, setCachedBaseAddress] = useState<number>(0);
  const [previousInstructions, setPreviousInstructions] = useState<
    Instruction[]
  >([]);
  const [isTransitioning, setIsTransitioning] = useState(false);
  const [pendingNavigationAddress, setPendingNavigationAddress] = useState<
    string | null
  >(null);

  // Calculate branch arrows for visible instructions (x64dbg-style arrows)
  const branchArrows = useMemo(() => {
    const displayInstructions =
      instructions.length > 0 ? instructions : previousInstructions;
    const arrows = calculateBranchArrows(displayInstructions);

    // Add predicted next instruction arrow if in break state with register data
    if (
      isInBreakState &&
      currentBreakAddress &&
      Object.keys(registerData).length > 0
    ) {
      // Find the current instruction
      const normalizedCurrentAddr = currentBreakAddress
        .toLowerCase()
        .replace(/^0x0*/, "0x");
      const currentIndex = displayInstructions.findIndex((instr) => {
        const normalizedAddr = instr.address
          .toLowerCase()
          .replace(/^0x0*/, "0x");
        return normalizedAddr === normalizedCurrentAddr;
      });

      if (currentIndex >= 0) {
        const currentInstr = displayInstructions[currentIndex];
        const currentAddr = BigInt(
          currentInstr.address.startsWith("0x")
            ? currentInstr.address
            : `0x${currentInstr.address}`
        );

        // Convert register data to state for prediction
        const regState = convertRegistersToState(registerData);
        regState.pc = currentAddr;

        // Get operands as string
        const operandsStr =
          typeof currentInstr.operands === "string"
            ? currentInstr.operands
            : currentInstr.operands
                .map((op: any) => {
                  if (typeof op === "string") return op;
                  return op.value || "";
                })
                .join(", ");

        // Predict next instruction
        const prediction = predictNextInstruction(
          currentAddr,
          currentInstr.opcode,
          operandsStr,
          regState
        );

        // Debug logging for branch prediction
        console.log("[BranchPredictor] Prediction for:", {
          address: `0x${currentAddr.toString(16)}`,
          opcode: currentInstr.opcode,
          operands: operandsStr,
          prediction: {
            type: prediction.type,
            willBranch: prediction.willBranch,
            targetAddress: prediction.targetAddress?.toString(16),
            fallthrough: prediction.fallthrough.toString(16),
            confidence: prediction.confidence,
            reason: prediction.reason,
          },
          registerData: Object.fromEntries(
            Object.entries(registerData).filter(
              ([k]) =>
                k.toLowerCase().includes("11") ||
                k.toLowerCase() === "cpsr" ||
                k.toLowerCase() === "nzcv"
            )
          ),
        });

        // If prediction is confident and has a target, add the arrow
        if (prediction.willBranch !== null && prediction.confidence !== "low") {
          const targetAddr = prediction.willBranch
            ? prediction.targetAddress
            : prediction.fallthrough;

          if (targetAddr !== null) {
            const targetHex = `0x${targetAddr.toString(16)}`;
            const normalizedTarget = targetHex
              .toLowerCase()
              .replace(/^0x0*/, "0x");

            // Find target index
            const targetIndex = displayInstructions.findIndex((instr) => {
              const normalizedAddr = instr.address
                .toLowerCase()
                .replace(/^0x0*/, "0x");
              return normalizedAddr === normalizedTarget;
            });

            if (targetIndex >= 0 && targetIndex !== currentIndex) {
              // Target is in view - add prediction arrow
              arrows.push({
                fromIndex: currentIndex,
                toIndex: targetIndex,
                fromAddress: currentInstr.address,
                toAddress: targetHex,
                isConditional: false,
                isDownward: targetIndex > currentIndex,
                depth: 0, // Will be recalculated
                isPredictedNext: true,
              });
            } else if (targetIndex < 0) {
              // Target is out of view
              const targetNumeric = Number(targetAddr);
              const firstAddr = displayInstructions[0]?.address
                ? parseInt(
                    displayInstructions[0].address.replace(/^0x/i, ""),
                    16
                  )
                : 0;
              const lastAddr = displayInstructions[
                displayInstructions.length - 1
              ]?.address
                ? parseInt(
                    displayInstructions[
                      displayInstructions.length - 1
                    ].address.replace(/^0x/i, ""),
                    16
                  )
                : 0;

              if (targetNumeric < firstAddr) {
                arrows.push({
                  fromIndex: currentIndex,
                  toIndex: -1,
                  fromAddress: currentInstr.address,
                  toAddress: targetHex,
                  isConditional: false,
                  isDownward: false,
                  depth: 0,
                  isPredictedNext: true,
                });
              } else if (targetNumeric > lastAddr) {
                arrows.push({
                  fromIndex: currentIndex,
                  toIndex: displayInstructions.length,
                  fromAddress: currentInstr.address,
                  toAddress: targetHex,
                  isConditional: false,
                  isDownward: true,
                  depth: 0,
                  isPredictedNext: true,
                });
              }
            }
          }
        }
      }
    }

    return arrows;
  }, [
    instructions,
    previousInstructions,
    isInBreakState,
    currentBreakAddress,
    registerData,
  ]);

  // Helper function to normalize addresses for comparison
  const normalizeAddress = useCallback((addr: string) => {
    if (!addr) return "";
    // Remove 0x prefix, convert to lowercase, remove leading zeros, then add 0x back
    const cleaned =
      addr.replace(/^0x/i, "").toLowerCase().replace(/^0+/, "") || "0";
    return `0x${cleaned}`;
  }, []);

  // Handle highlight address from DecompileView click
  // If the target address is visually visible in the table, just highlight it
  // If not visible on screen, scroll to it
  useEffect(() => {
    if (!highlightAddress) return;

    const normalizedTarget = normalizeAddress(highlightAddress);

    // Check if the address exists in current instructions
    const isInInstructions = instructions.some(
      (instr) => normalizeAddress(instr.address) === normalizedTarget
    );

    if (isInInstructions) {
      // Address is in instructions - check if it's actually visible on screen
      // Find the row element by data attribute
      const rowElement = tableContainerRef.current?.querySelector(
        `[data-address="${highlightAddress}"]`
      ) as HTMLElement | null;

      if (rowElement && tableContainerRef.current) {
        const containerRect = tableContainerRef.current.getBoundingClientRect();
        const rowRect = rowElement.getBoundingClientRect();

        // Check if the row is within the visible area of the container
        const isVisibleOnScreen =
          rowRect.top >= containerRect.top &&
          rowRect.bottom <= containerRect.bottom;

        if (isVisibleOnScreen) {
          // Row is visible - just highlight without scrolling
          setFocusedLineAddress(highlightAddress);
          setTimeout(() => {
            setFocusedLineAddress(null);
          }, 3000);
        } else {
          // Row exists but is not visible on screen - scroll to it instantly
          rowElement.scrollIntoView({ behavior: "instant", block: "center" });
          setFocusedLineAddress(highlightAddress);
          setTimeout(() => {
            setFocusedLineAddress(null);
          }, 3000);
        }
      } else {
        // Row element not found - just set highlight
        setFocusedLineAddress(highlightAddress);
        setTimeout(() => {
          setFocusedLineAddress(null);
        }, 5000);
      }
    } else {
      // Address is not in current instructions - navigate to it (which will load new data and scroll)
      setAssemblyAddress(highlightAddress);
      // Set focus immediately - the address navigation handles scroll
      setFocusedLineAddress(highlightAddress);
      setTimeout(() => {
        setFocusedLineAddress(null);
      }, 3000);
    }

    // Notify parent that highlight is complete
    if (onHighlightComplete) {
      onHighlightComplete();
    }
  }, [
    highlightAddress,
    instructions,
    normalizeAddress,
    setAssemblyAddress,
    onHighlightComplete,
  ]);

  // Prefetch system for seamless scrolling
  const [prefetchBuffers, setPrefetchBuffers] = useState<
    Map<number, Instruction[]>
  >(new Map());
  const prefetchDistance = useState<number>(512)[0]; // Reduced distance for faster loading
  const containerRef = useRef<HTMLDivElement>(null);
  const tableContainerRef = useRef<HTMLDivElement>(null);
  const mountedRef = useRef(true);
  const lastProcessedBreakAddressRef = useRef<string | null>(null);

  // アンマウント時に保存するための最新値を保持するref
  const latestStateRef = useRef({
    instructions,
  });

  // 最新の状態をrefに反映
  useEffect(() => {
    latestStateRef.current = {
      instructions,
    };
  }, [instructions]);

  // Cleanup on unmount
  useEffect(() => {
    mountedRef.current = true;
    console.log("[ASSEMBLY VIEW LIFECYCLE] Component mounted");

    return () => {
      mountedRef.current = false;
      console.log("[ASSEMBLY VIEW LIFECYCLE] Component unmounted");

      // アンマウント時に現在表示中のアドレスをグローバルストアに保存（refから最新値を取得）
      const latest = latestStateRef.current;
      if (latest.instructions.length > 0) {
        // 一番上に表示されている命令のアドレスを保存
        const topVisibleAddress = latest.instructions[0]?.address || null;

        if (topVisibleAddress) {
          console.log(
            `[ASSEMBLY VIEW LIFECYCLE] Saving top visible address to global store: ${topVisibleAddress}`
          );
          setAssemblyAddress(topVisibleAddress);
        }
      }
    };
  }, [setAssemblyAddress]);

  // Tab visibility monitoring for preventing unnecessary re-renders (simplified)
  useEffect(() => {
    console.log("[VISIBILITY] Setting up visibilitychange listener");

    const handleVisibilityChange = () => {
      const visible = !document.hidden;
      console.log(
        `[VISIBILITY] Visibility changed - document.hidden: ${document.hidden}, visible: ${visible}`
      );
      setIsVisible(visible);

      if (
        visible &&
        cachedInstructions.length > 0 &&
        instructions.length === 0
      ) {
        // Tab became visible and we have cached instructions, restore them
        console.log("[VISIBILITY] Tab became visible, restoring cached state");
        console.log(
          `[VISIBILITY] Cached instructions count: ${cachedInstructions.length}`
        );
        console.log(
          `[VISIBILITY] Current instructions count: ${instructions.length}`
        );

        // Restore instructions with current breakpoint state
        const restoredInstructions = cachedInstructions.map((instruction) => ({
          ...instruction,
          breakpoint: breakpoints.has(instruction.address),
          isSoftwareBreakpoint: softwareBreakpoints.has(instruction.address),
        }));

        // Restore all scroll-related state
        setInstructions(restoredInstructions);
        if (cachedInstructionBuffer.length > 0) {
          setInstructionBuffer(cachedInstructionBuffer);
        }
        setViewportStart(cachedViewportStart);
        setCurrentBaseAddress(cachedBaseAddress);

        console.log(
          `AssemblyView: Restored state - baseAddress: 0x${cachedBaseAddress.toString(16)}, viewportStart: ${cachedViewportStart}, buffer size: ${cachedInstructionBuffer.length}`
        );
      } else if (!visible && instructions.length > 0) {
        // Tab became hidden, cache current instructions and state for later
        console.log("[VISIBILITY] Tab became hidden, caching state");
        console.log(
          `[VISIBILITY] Instructions to cache: ${instructions.length}`
        );
        console.log(
          `[VISIBILITY] Current base address: 0x${currentBaseAddress.toString(16)}`
        );
        setCachedInstructions(instructions);
        setCachedInstructionBuffer(instructionBuffer);
        setCachedViewportStart(viewportStart);
        setCachedBaseAddress(currentBaseAddress);

        console.log(
          `[VISIBILITY] Cached state - baseAddress: 0x${currentBaseAddress.toString(16)}, viewportStart: ${viewportStart}, buffer size: ${instructionBuffer.length}`
        );
      } else {
        console.log(
          `[VISIBILITY] Visibility changed but no action taken - visible: ${visible}, cachedInstructions: ${cachedInstructions.length}, instructions: ${instructions.length}`
        );
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);
    console.log("[VISIBILITY] Listener registered");

    return () => {
      console.log("[VISIBILITY] Removing listener");
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, [
    instructions,
    cachedInstructions,
    activeBreakpoints,
    instructionBuffer,
    cachedInstructionBuffer,
    viewportStart,
    cachedViewportStart,
    currentBaseAddress,
    cachedBaseAddress,
    breakpoints,
  ]);

  // Listen for navigate-to-address events from other windows (e.g., GraphView)
  useEffect(() => {
    let unlisten: (() => void) | undefined;

    const setupListener = async () => {
      unlisten = await listen<{ address: string }>(
        "navigate-to-address",
        (event) => {
          const { address } = event.payload;
          console.log(
            "[AssemblyView] Received navigate-to-address event:",
            address
          );
          setAssemblyAddress(address);
        }
      );
    };

    setupListener();

    return () => {
      if (unlisten) {
        unlisten();
      }
    };
  }, [setAssemblyAddress]);

  // Update instructions when breakpoint state changes
  useEffect(() => {
    if (instructions.length > 0) {
      // Update instructions with current breakpoint state
      const updatedInstructions = instructions.map((instruction) => ({
        ...instruction,
        breakpoint: breakpoints.has(instruction.address),
        isSoftwareBreakpoint: softwareBreakpoints.has(instruction.address),
      }));

      // Only update if there are actual changes to prevent infinite loops
      const hasChanges = updatedInstructions.some(
        (updated, index) =>
          instructions[index] &&
          updated.breakpoint !== instructions[index].breakpoint
      );

      if (hasChanges) {
        console.log(
          "AssemblyView: Updating instructions with new breakpoint state"
        );
        setInstructions(updatedInstructions);

        // Also update the instruction buffer
        if (instructionBuffer.length > 0) {
          const updatedBuffer = instructionBuffer.map((instruction) => ({
            ...instruction,
            breakpoint: breakpoints.has(instruction.address),
            isSoftwareBreakpoint: softwareBreakpoints.has(instruction.address),
          }));
          setInstructionBuffer(updatedBuffer);
        }

        // Also update cached instructions if they exist
        if (cachedInstructions.length > 0) {
          const updatedCache = cachedInstructions.map((instruction) => ({
            ...instruction,
            breakpoint: breakpoints.has(instruction.address),
            isSoftwareBreakpoint: softwareBreakpoints.has(instruction.address),
          }));
          setCachedInstructions(updatedCache);
        }
      }
    }
  }, [activeBreakpoints]); // Depend on activeBreakpoints instead of breakpoints

  // Cache previous instructions to prevent flickering during transitions
  useEffect(() => {
    if (instructions.length > 0 && !loading) {
      setPreviousInstructions(instructions);
    }
  }, [instructions, loading]);

  // Check for breakpoint hits and notify parent
  useEffect(() => {
    const breakpointHitInstruction = instructions.find(
      (instruction) => instruction.address.includes("1004") // デモ用: アドレスに1004が含まれる場合
    );

    if (breakpointHitInstruction && onBreakpointHit) {
      onBreakpointHit(breakpointHitInstruction.address);
    }
  }, [instructions, onBreakpointHit]);

  // Single step optimization - check if the break address is within current viewport
  useEffect(() => {
    if (!currentBreakAddress) {
      // Clear the last processed address when break state ends
      lastProcessedBreakAddressRef.current = null;
      return;
    }

    // Skip if we already processed this exact break address
    if (lastProcessedBreakAddressRef.current === currentBreakAddress) {
      console.log(
        `[SINGLE STEP DEBUG] Already processed break address ${currentBreakAddress}, skipping to allow free scrolling`
      );
      return;
    }

    // Use ref to get latest instructions without triggering re-render
    const currentInstructions = latestStateRef.current.instructions;

    console.log(
      `[SINGLE STEP DEBUG] AssemblyView: Break address changed to ${currentBreakAddress}, isInBreakState: ${isInBreakState}, loading: ${loading}, instructions.length: ${currentInstructions.length}`
    );

    // Skip if we're already loading to prevent infinite loops
    if (loading) {
      console.log(
        `[SINGLE STEP DEBUG] Already loading, skipping navigation for ${currentBreakAddress}`
      );
      return;
    }

    // Skip if we're already showing the correct address
    const currentFunctionAddress =
      useUIStore.getState().debuggerState.assemblyAddress;
    if (
      currentFunctionAddress &&
      normalizeAddress(currentFunctionAddress) ===
        normalizeAddress(currentBreakAddress)
    ) {
      console.log(
        `[SINGLE STEP DEBUG] Already showing correct address ${currentBreakAddress} (functionAddress: ${currentFunctionAddress}), no navigation needed`
      );
      // Still mark as processed to prevent future re-navigation
      lastProcessedBreakAddressRef.current = currentBreakAddress;
      return;
    }

    console.log(
      `[SINGLE STEP DEBUG] functionAddress: ${currentFunctionAddress}, normalized: ${currentFunctionAddress ? normalizeAddress(currentFunctionAddress) : "null"}, currentBreakAddress normalized: ${normalizeAddress(currentBreakAddress)}`
    );

    // For initial breakpoint hits or when instructions are empty, we need to navigate
    // But check if we're already close to the target address first
    if (currentInstructions.length === 0) {
      console.log(
        `[SINGLE STEP DEBUG] Initial breakpoint hit: No instructions loaded, navigating to ${currentBreakAddress}`
      );
      setAssemblyAddress(currentBreakAddress);
      lastProcessedBreakAddressRef.current = currentBreakAddress;
      return;
    }

    // Log current instruction range for debugging
    console.log(
      `[SINGLE STEP DEBUG] Current instructions range: ${currentInstructions[0]?.address} - ${currentInstructions[currentInstructions.length - 1]?.address} (${currentInstructions.length} instructions)`
    );

    // Check if we're already showing a nearby range (within reasonable distance)
    const currentBreakAddressNum = parseInt(
      currentBreakAddress.replace(/^0x/i, ""),
      16
    );
    console.log(
      `[SINGLE STEP DEBUG] Checking proximity for break address ${currentBreakAddress} (0x${currentBreakAddressNum.toString(16)})`
    );

    const isNearCurrentRange = currentInstructions.some((instruction) => {
      const instrAddressNum = parseInt(
        instruction.address.replace(/^0x/i, ""),
        16
      );
      const distance = Math.abs(instrAddressNum - currentBreakAddressNum);
      if (distance < 0x100) {
        console.log(
          `[SINGLE STEP DEBUG] Found nearby instruction ${instruction.address} (0x${instrAddressNum.toString(16)}), distance: 0x${distance.toString(16)}`
        );
        return true;
      }
      return false;
    });

    console.log(
      `Debug: Is near current range: ${isNearCurrentRange}, instructions count: ${currentInstructions.length}`
    );

    // First, always check if the exact address is within the displayed instructions
    const isAddressInCurrentView = currentInstructions.some(
      (instruction) =>
        normalizeAddress(instruction.address) ===
        normalizeAddress(currentBreakAddress)
    );

    console.log(
      `Debug: Is exact address in current view: ${isAddressInCurrentView}`
    );

    if (isAddressInCurrentView) {
      console.log(
        `Single step optimization: Break address ${currentBreakAddress} is within current view, skipping re-fetch`
      );
      // Address is in current view, no need to reload - just highlight will change automatically
      // Mark as processed so we don't keep trying to navigate to it
      lastProcessedBreakAddressRef.current = currentBreakAddress;
      // Note: Decompile view sync will be handled by a separate useEffect after syncDecompileView is defined
      return;
    }

    // If not in current view, check if it's nearby (expand range for single steps)
    if (isNearCurrentRange) {
      console.log(
        `Break address ${currentBreakAddress} is near current view but not visible, checking if we should expand view or navigate`
      );

      // For single step operations, we want to try to keep the current view if the target is very close
      // Expand the view slightly by prefetching around the current range instead of full navigation
      const shouldExpandView = currentInstructions.some((instruction) => {
        const instrAddressNum = parseInt(
          instruction.address.replace(/^0x/i, ""),
          16
        );
        const distance = Math.abs(instrAddressNum - currentBreakAddressNum);
        return distance < 0x40; // Within 64 bytes - very close, try to expand view instead of navigate
      });

      if (shouldExpandView) {
        console.log(
          `Debug: Target is very close, expanding current view instead of navigation`
        );
        // TODO: Could implement view expansion here instead of navigation
        // For now, keep current view and let the highlight system attempt to show it
        // Mark as processed to allow free scrolling
        lastProcessedBreakAddressRef.current = currentBreakAddress;
        // Note: Decompile view sync will be handled by a separate useEffect after syncDecompileView is defined
        return;
      } else {
        console.log(
          `Debug: Target is nearby but not very close, performing navigation`
        );
        setAssemblyAddress(currentBreakAddress);
        lastProcessedBreakAddressRef.current = currentBreakAddress;
        // Note: Decompile view sync will be handled by a separate useEffect after syncDecompileView is defined
      }
    } else {
      console.log(
        `Single step: Break address ${currentBreakAddress} is outside current view, need to navigate at ${new Date().toISOString()}`
      );
      // Address is outside current view, need to navigate to it
      // This will trigger the normal loading process
      setAssemblyAddress(currentBreakAddress);
      lastProcessedBreakAddressRef.current = currentBreakAddress;
      // Note: Decompile view sync will be handled by a separate useEffect after syncDecompileView is defined
    }
    // Note: intentionally not including 'instructions' in dependencies to prevent
    // re-navigation when user manually navigates to a different address during break state
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentBreakAddress, normalizeAddress, loading]);

  // Convert hex address string to number
  const parseAddress = (addressStr: string): number => {
    return parseInt(addressStr.replace("0x", ""), 16);
  };

  // Function to parse disassembly text to Instruction objects
  const parseDisassembly = (
    disassemblyText: string,
    baseAddress: number
  ): Instruction[] => {
    try {
      if (!disassemblyText || disassemblyText.trim() === "") {
        console.warn("Empty disassembly text received");
        return [];
      }

      const lines = disassemblyText.split("\n").filter((line) => line.trim());

      if (lines.length === 0) {
        console.warn("No valid lines found in disassembly text");
        return [];
      }

      const instructions: Instruction[] = [];
      
      // Track block depth for WASM structured control flow
      let blockDepth = 0;

      lines.forEach((line, index) => {
        try {
          // Check for function labels (e.g., "function_name:")
          if (line.includes(":") && !line.includes("|")) {
            const functionMatch = line.match(/^([^:]+):\s*$/);
            if (functionMatch) {
              const functionName = functionMatch[1].trim();
              // Add a special instruction for function labels
              instructions.push({
                address: `0x${(baseAddress + index * 4).toString(16)}`,
                bytes: "",
                opcode: "",
                operands: [],
                comment: `Function: ${functionName}`,
                active: false,
                breakpoint: false,
                jumpTarget: true,
                isFunction: true,
                indent: 0,
              });
              blockDepth = 0; // Reset block depth for new function
              return;
            }
          }

          // Parse format: address|bytes|mnemonic operands
          const parts = line.split("|");

          if (parts.length >= 3) {
            const address = parts[0].trim();
            const bytes = parts[1].trim();
            const instructionPart = parts[2].trim();

            // Split instruction into mnemonic and operands
            const instructionMatch = instructionPart.match(/^(\S+)\s*(.*)?$/);
            if (instructionMatch) {
              const [, opcode, operands = ""] = instructionMatch;

              // Detect function prologue patterns (disabled for cleaner display)
              const isFunctionStart = false;

              // Detect function epilogue patterns (disabled for cleaner display)
              const isFunctionEnd = false;

              // Check if this is a branch instruction and add library+offset comment
              let comment = "";
              if (isJumpInstruction(opcode) && operands) {
                const libraryExpr = getBranchTargetLibraryExpression(operands);
                if (libraryExpr) {
                  comment = libraryExpr;
                }
              }

              // Track WASM block depth for structured indentation
              // 'end' instruction decrements depth BEFORE the instruction
              const isWasmEnd = opcode === "end";
              const isWasmBlockStart = ["block", "loop", "if"].includes(opcode);
              const isWasmElse = opcode === "else";
              
              // For 'end' and 'else', decrement before assigning indent
              if (isWasmEnd && blockDepth > 0) {
                blockDepth--;
              }
              if (isWasmElse && blockDepth > 0) {
                blockDepth--;
              }
              
              const currentIndent = blockDepth;
              
              // After block/loop/if/else, increment depth for subsequent instructions
              if (isWasmBlockStart || isWasmElse) {
                blockDepth++;
              }

              const result: Instruction = {
                address,
                bytes,
                opcode,
                operands: operands
                  ? operands.split(",").map((op) => ({
                      type: "reg" as const,
                      value: op.trim(),
                    }))
                  : [],
                comment,
                active: false,
                breakpoint: false,
                jumpTarget: false,
                isFunctionStart,
                isFunctionEnd,
                indent: currentIndent,
              };
              instructions.push(result);
              return;
            }
          }

          // Fallback for old format or malformed lines
          const match = line.match(/^(0x[a-fA-F0-9]+):\s*([^\s]+)\s*(.*)?$/);
          if (match) {
            const [, address, opcode, operands = ""] = match;

            // Check if this is a branch instruction and add library+offset comment
            let comment = "";
            if (isJumpInstruction(opcode) && operands) {
              const libraryExpr = getBranchTargetLibraryExpression(operands);
              if (libraryExpr) {
                comment = libraryExpr;
              }
            }

            instructions.push({
              address,
              bytes: "",
              opcode,
              operands: operands
                ? operands.split(",").map((op) => ({
                    type: "reg" as const,
                    value: op.trim(),
                  }))
                : [],
              comment,
              active: false,
              breakpoint: false,
              jumpTarget: false,
            });
            return;
          }

          // Final fallback for unparseable lines
          instructions.push({
            address: `0x${(baseAddress + index * 4).toString(16)}`,
            bytes: "",
            opcode: "unknown",
            operands: [],
            comment: line,
            active: false,
            breakpoint: false,
            jumpTarget: false,
          });
        } catch (lineErr) {
          console.warn(
            `Failed to parse disassembly line ${index}: ${line}`,
            lineErr
          );
          // Return a safe fallback instruction
          instructions.push({
            address: `0x${(baseAddress + index * 4).toString(16)}`,
            bytes: "",
            opcode: "error",
            operands: [],
            comment: `Parse error: ${line}`,
            active: false,
            breakpoint: false,
            jumpTarget: false,
          });
        }
      });

      return instructions.filter((instruction) => instruction !== null);
    } catch (err) {
      console.error("Failed to parse disassembly text:", err);
      return [];
    }
  };

  // Load disassembly at specific address using Tauri
  const loadDisassemblyAtAddress = useCallback(
    async (address: number) => {
      if (!mountedRef.current) {
        console.log(
          "AssemblyView: Component not mounted, skipping disassembly load"
        );
        return;
      }

      // Allow new address loads even while loading (cancel previous load)
      // Only prevent duplicate loads of the exact same address
      if (loading && currentBaseAddress === address) {
        console.log(
          `AssemblyView: Already loading same address 0x${address.toString(16)}, skipping duplicate load`
        );
        return;
      }

      if (loading) {
        console.log(
          `AssemblyView: Currently loading different address, proceeding with new address 0x${address.toString(16)}`
        );
      }

      const loadStartTime = performance.now();
      console.log(
        `AssemblyView: Starting Tauri disassembly load for address 0x${address.toString(16)} at ${new Date().toISOString()}`
      );
      console.log(
        `AssemblyView: Current state - loading: ${loading}, isTransitioning: ${isTransitioning}, instructions.length: ${instructions.length}`
      );

      // Set transition state to prevent flickering
      setIsTransitioning(true);

      if (mountedRef.current) {
        setLoading(true);
        setError(null);
        // Don't clear instructions immediately to prevent flickering
        // They will be updated once new data is loaded
      }

      const timeoutId = setTimeout(() => {
        if (!mountedRef.current) return;
        console.error("AssemblyView: Request timeout after 10 seconds");
        setError("Request timeout - server may be unresponsive");
        setLoading(false);
      }, 10000);

      try {
        // Determine architecture from serverInfo, default to arm64 for iOS/macOS
        const architecture = serverInfo?.arch || "arm64";
        const memorySize = bufferSize; // Use smaller buffer for faster loading

        console.log(
          "AssemblyView: Reading optimized memory buffer first, then disassembling locally"
        );

        // First, read memory from server using API client (with ptrace for debugger)
        const apiClient = getApiClient();
        const memoryReadStart = performance.now();
        const memoryBuffer = await apiClient.readMemory(
          `0x${address.toString(16)}`,
          memorySize,
          true // use ptrace for debugger memory read
        );
        console.log(
          `AssemblyView: Memory read took ${(performance.now() - memoryReadStart).toFixed(2)}ms`
        );

        // Convert ArrayBuffer to Uint8Array, then to regular array
        const memoryData = Array.from(new Uint8Array(memoryBuffer));

        console.log(
          "AssemblyView: Memory read successful, sending to Tauri for disassembly:",
          { address, memorySize, dataLength: memoryData.length }
        );

        // Use new Tauri function that takes memory data directly
        const disasmStart = performance.now();
        const response: DisassembleResponse = await invoke(
          "disassemble_memory_direct",
          {
            memoryData,
            address,
            architecture,
          }
        );
        console.log(
          `AssemblyView: Tauri disassemble took ${(performance.now() - disasmStart).toFixed(2)}ms`
        );

        console.log(
          "AssemblyView: Received Tauri disassemble response:",
          response
        );

        if (!mountedRef.current) {
          console.log(
            "AssemblyView: Component unmounted during request, ignoring response"
          );
          return;
        }

        if (response.success && response.disassembly) {
          console.log("AssemblyView: Parsing disassembly data...");
          const parsedInstructions = parseDisassembly(
            response.disassembly,
            address
          );
          console.log(
            `AssemblyView: Parsed ${parsedInstructions.length} instructions in ${(performance.now() - loadStartTime).toFixed(2)}ms total`
          );

          if (parsedInstructions.length > 0) {
            // Find the requested address in the parsed instructions
            const requestedIndex = parsedInstructions.findIndex(
              (instr) =>
                parseInt(instr.address.replace("0x", ""), 16) === address
            );

            // Store all instructions in buffer
            setInstructionBuffer(parsedInstructions);
            setCurrentBaseAddress(
              parseInt(parsedInstructions[0].address.replace("0x", ""), 16)
            );

            // Set viewport to show requested address at the top
            if (requestedIndex !== -1) {
              setViewportStart(requestedIndex);
              const viewportInstructions = parsedInstructions.slice(
                requestedIndex,
                requestedIndex + viewportSize
              );
              setInstructions(viewportInstructions);
            } else {
              // Fallback: show from beginning
              setViewportStart(0);
              const viewportInstructions = parsedInstructions.slice(
                0,
                viewportSize
              );
              setInstructions(viewportInstructions);
            }

            setIsTransitioning(false);
            console.log(
              `AssemblyView: Loaded buffer from 0x${parsedInstructions[0].address}, showing viewport at requested 0x${address.toString(16)}`
            );
          } else {
            console.warn(
              "AssemblyView: No instructions parsed from disassembly data"
            );
            setError("No valid instructions found at this address");
            // Only clear instructions if we don't have previous ones to show
            if (instructions.length === 0) {
              setInstructions([]);
              setInstructionBuffer([]);
            }
            setIsTransitioning(false);
          }
        } else {
          console.error("AssemblyView: Tauri API failure:", response);
          setError(response.error || "Failed to disassemble memory");

          // Only clear instructions if we don't have previous ones to show
          if (instructions.length === 0) {
            setInstructions([]);
            setInstructionBuffer([]);
          }
          setIsTransitioning(false);
        }
      } catch (err) {
        console.error("AssemblyView: Tauri disassembly error:", err);

        if (!mountedRef.current) {
          console.log(
            "AssemblyView: Component unmounted during error handling"
          );
          return;
        }

        if (err instanceof Error) {
          setError(`Error: ${err.message}`);
        } else {
          setError("Unknown error occurred during disassembly");
        }

        // Only clear instructions if we don't have previous ones to show
        if (instructions.length === 0) {
          setInstructions([]);
          setInstructionBuffer([]);
        }
        setIsTransitioning(false);
      } finally {
        clearTimeout(timeoutId);

        if (mountedRef.current) {
          console.log(
            "AssemblyView: Tauri disassembly load completed, setting loading to false"
          );
          setLoading(false);
          setIsTransitioning(false);
        }
      }
    },
    [bufferSize, serverInfo, viewportSize, parseAddress]
  );

  // Prefetch memory chunks around current address for seamless scrolling
  const prefetchMemoryChunks = useCallback(
    async (centerAddress: number) => {
      // Check loading state at the time of execution
      if (!mountedRef.current) return;

      setLoading(true);

      try {
        const chunks: Array<{ address: number; instructions: Instruction[] }> =
          [];

        // Prefetch chunks above and below current address
        const addresses = [
          Math.max(0, centerAddress - prefetchDistance * 2), // Far above
          Math.max(0, centerAddress - prefetchDistance), // Near above
          centerAddress + prefetchDistance, // Near below
          centerAddress + prefetchDistance * 2, // Far below
        ];

        for (const address of addresses) {
          if (address < 0) continue;

          try {
            // Check current prefetch buffers at execution time
            setPrefetchBuffers((currentBuffers) => {
              // If we already have this chunk, skip
              if (currentBuffers.has(address)) return currentBuffers;

              // Perform async loading
              (async () => {
                try {
                  const apiClient = getApiClient();
                  const memoryBuffer = await apiClient.readMemory(
                    `0x${address.toString(16)}`,
                    bufferSize,
                    true // use ptrace for debugger memory read
                  );

                  const memoryData = Array.from(new Uint8Array(memoryBuffer));
                  const architecture = serverInfo?.arch || "arm64";

                  const response: DisassembleResponse = await invoke(
                    "disassemble_memory_direct",
                    {
                      memoryData,
                      address,
                      architecture,
                    }
                  );

                  if (response.success && response.disassembly) {
                    const parsedInstructions = parseDisassembly(
                      response.disassembly,
                      address
                    );
                    chunks.push({ address, instructions: parsedInstructions });

                    // Update buffers with new data
                    setPrefetchBuffers((prev) => {
                      const newBuffers = new Map(prev);
                      newBuffers.set(address, parsedInstructions);

                      // Limit buffer size to prevent memory bloat
                      if (newBuffers.size > 8) {
                        const entries = Array.from(newBuffers.entries());
                        entries.sort(
                          (a, b) =>
                            Math.abs(a[0] - centerAddress) -
                            Math.abs(b[0] - centerAddress)
                        );

                        const newLimitedBuffers = new Map();
                        entries.slice(0, 8).forEach(([addr, instr]) => {
                          newLimitedBuffers.set(addr, instr);
                        });

                        return newLimitedBuffers;
                      }

                      return newBuffers;
                    });
                  }
                } catch (err) {
                  console.warn(
                    `Failed to prefetch chunk at 0x${address.toString(16)}:`,
                    err
                  );
                }
              })();

              return currentBuffers;
            });
          } catch (err) {
            console.warn(
              `Failed to prefetch chunk at 0x${address.toString(16)}:`,
              err
            );
          }
        }
      } catch (err) {
        console.error("Prefetch failed:", err);
      } finally {
        setLoading(false);
      }
    },
    [prefetchDistance, bufferSize]
  );

  // Enhanced load disassembly with prefetch integration
  const loadDisassemblyAtAddressWithPrefetch = useCallback(
    async (address: number, skipPrefetch = false) => {
      // First load the main chunk
      await loadDisassemblyAtAddress(address);

      // Then prefetch surrounding chunks in background
      if (!skipPrefetch) {
        setTimeout(() => {
          prefetchMemoryChunks(address);
        }, 100); // Small delay to prioritize main loading
      }
    },
    [loadDisassemblyAtAddress, prefetchMemoryChunks]
  );

  // Enhanced smooth scroll up with prefetch buffer integration
  const scrollUp = useCallback(async () => {
    if (loading) return;

    // Use smaller scroll increment for smoother performance
    const scrollIncrement = 3; // Reduced from 5 to 3

    // Try to find prefetched data first
    if (viewportStart <= scrollIncrement && instructionBuffer.length > 0) {
      const firstInstruction = instructionBuffer[0];
      const firstAddress = parseInt(
        firstInstruction.address.replace("0x", ""),
        16
      );
      const targetAddress = Math.max(0, firstAddress - prefetchDistance);

      // Check if we have prefetched data for this address
      const prefetchedInstructions = prefetchBuffers.get(targetAddress);
      if (prefetchedInstructions && prefetchedInstructions.length > 0) {
        // Use prefetched data seamlessly
        const combinedInstructions = [
          ...prefetchedInstructions,
          ...instructionBuffer,
        ];
        setInstructionBuffer(combinedInstructions);
        const newViewportStart = prefetchedInstructions.length - 10; // Position near the transition
        setViewportStart(newViewportStart);
        const viewportInstructions = combinedInstructions.slice(
          newViewportStart,
          newViewportStart + viewportSize
        );
        setInstructions(viewportInstructions);

        // Update base address to the first instruction in combined buffer
        if (combinedInstructions.length > 0) {
          const firstInstructionAddress = parseInt(
            combinedInstructions[0].address.replace("0x", ""),
            16
          );
          setCurrentBaseAddress(firstInstructionAddress);
        }

        // Remove used prefetch data and trigger new prefetch
        setPrefetchBuffers((prev) => {
          const newBuffers = new Map(prev);
          newBuffers.delete(targetAddress);
          return newBuffers;
        });

        // Trigger new prefetch for the new position
        setTimeout(() => prefetchMemoryChunks(targetAddress), 50);
        return;
      }

      // No prefetch - load more data but maintain current position
      const newStartAddress = Math.max(0, firstAddress - bufferSize / 2);
      if (newStartAddress < firstAddress) {
        // Load data from newStartAddress, but keep firstAddress in viewport
        setLoading(true);
        try {
          const apiClient = getApiClient();
          const memoryBuffer = await apiClient.readMemory(
            `0x${newStartAddress.toString(16)}`,
            bufferSize,
            true // use ptrace for debugger memory read
          );
          const memoryData = Array.from(new Uint8Array(memoryBuffer));
          const architecture = serverInfo?.arch || "arm64";
          const response: DisassembleResponse = await invoke(
            "disassemble_memory_direct",
            { memoryData, address: newStartAddress, architecture }
          );

          if (response.success && response.disassembly) {
            const parsedInstructions = parseDisassembly(
              response.disassembly,
              newStartAddress
            );
            if (parsedInstructions.length > 0) {
              // Find where firstAddress is in the new buffer
              const firstAddressIndex = parsedInstructions.findIndex(
                (instr) =>
                  parseInt(instr.address.replace("0x", ""), 16) === firstAddress
              );

              setInstructionBuffer(parsedInstructions);
              setCurrentBaseAddress(newStartAddress);

              if (firstAddressIndex !== -1) {
                // Keep firstAddress at top of viewport
                setViewportStart(firstAddressIndex);
                const viewportInstructions = parsedInstructions.slice(
                  firstAddressIndex,
                  firstAddressIndex + viewportSize
                );
                setInstructions(viewportInstructions);
              }

              setTimeout(() => prefetchMemoryChunks(newStartAddress), 100);
            }
          }
        } catch (error) {
          // Memory read failed - continue with existing buffer if possible
          console.warn("Failed to load more data during scroll up:", error);
          // Try to scroll within existing buffer anyway
          const newViewportStart = Math.max(0, viewportStart - scrollIncrement);
          if (newViewportStart !== viewportStart) {
            setViewportStart(newViewportStart);
            const viewportInstructions = instructionBuffer.slice(
              newViewportStart,
              newViewportStart + viewportSize
            );
            setInstructions(viewportInstructions);
          }
        } finally {
          setLoading(false);
        }
        return;
      }
    }

    // Use existing buffer data for smooth scrolling
    const newViewportStart = Math.max(0, viewportStart - scrollIncrement);
    setViewportStart(newViewportStart);
    const viewportInstructions = instructionBuffer.slice(
      newViewportStart,
      newViewportStart + viewportSize
    );
    setInstructions(viewportInstructions);
  }, [
    currentBaseAddress,
    loading,
    bufferSize,
    prefetchDistance,
    prefetchBuffers,
    loadDisassemblyAtAddressWithPrefetch,
    prefetchMemoryChunks,
    setPrefetchBuffers,
    viewportStart,
    instructionBuffer,
    viewportSize,
  ]);

  // Enhanced smooth scroll down with prefetch buffer integration
  const scrollDown = useCallback(async () => {
    if (loading) return;

    const scrollIncrement = 3; // Reduced from 5 to 3 for smoother performance
    const newViewportStart = viewportStart + scrollIncrement;

    // Check if we need more data and have prefetched buffer
    if (newViewportStart + viewportSize + 10 > instructionBuffer.length) {
      const lastInstruction = instructionBuffer[instructionBuffer.length - 1];
      const lastAddress = parseInt(
        lastInstruction.address.replace("0x", ""),
        16
      );
      const targetAddress = lastAddress + prefetchDistance;

      // Check if we have prefetched data for this address
      const prefetchedInstructions = prefetchBuffers.get(targetAddress);
      if (prefetchedInstructions && prefetchedInstructions.length > 0) {
        // Use prefetched data seamlessly
        const combinedInstructions = [
          ...instructionBuffer,
          ...prefetchedInstructions,
        ];
        setInstructionBuffer(combinedInstructions);
        setViewportStart(newViewportStart);
        const viewportInstructions = combinedInstructions.slice(
          newViewportStart,
          newViewportStart + viewportSize
        );
        setInstructions(viewportInstructions);

        // Update base address to the first instruction in combined buffer
        if (combinedInstructions.length > 0) {
          const firstInstructionAddress = parseInt(
            combinedInstructions[0].address.replace("0x", ""),
            16
          );
          setCurrentBaseAddress(firstInstructionAddress);
        }

        // Remove used prefetch data and trigger new prefetch
        setPrefetchBuffers((prev) => {
          const newBuffers = new Map(prev);
          newBuffers.delete(targetAddress);
          return newBuffers;
        });

        // Trigger new prefetch for the new position
        setTimeout(() => prefetchMemoryChunks(targetAddress), 50);
        return;
      }

      // No prefetch - load more data from the end of current buffer
      const newStartAddress = lastAddress + 4; // Start from the next instruction after current buffer
      setLoading(true);
      try {
        const apiClient = getApiClient();
        const memoryBuffer = await apiClient.readMemory(
          `0x${newStartAddress.toString(16)}`,
          bufferSize,
          true // use ptrace for debugger memory read
        );
        const memoryData = Array.from(new Uint8Array(memoryBuffer));
        const architecture = serverInfo?.arch || "arm64";
        const response: DisassembleResponse = await invoke(
          "disassemble_memory_direct",
          { memoryData, address: newStartAddress, architecture }
        );

        if (response.success && response.disassembly) {
          const parsedInstructions = parseDisassembly(
            response.disassembly,
            newStartAddress
          );
          if (parsedInstructions.length > 0) {
            // Append new instructions to existing buffer instead of replacing
            const combinedInstructions = [
              ...instructionBuffer,
              ...parsedInstructions,
            ];
            setInstructionBuffer(combinedInstructions);
            // Keep the base address as the first instruction
            const firstInstructionAddress = parseInt(
              combinedInstructions[0].address.replace("0x", ""),
              16
            );
            setCurrentBaseAddress(firstInstructionAddress);
            // Now scroll down with the combined buffer
            setViewportStart(newViewportStart);
            const viewportInstructions = combinedInstructions.slice(
              newViewportStart,
              newViewportStart + viewportSize
            );
            setInstructions(viewportInstructions);

            setTimeout(() => prefetchMemoryChunks(newStartAddress), 100);
          }
        }
      } catch (error) {
        // Memory read failed - continue with existing buffer if possible
        console.warn("Failed to load more data during scroll down:", error);
        // Try to scroll within existing buffer anyway (up to the end)
        const maxViewportStart = Math.max(
          0,
          instructionBuffer.length - viewportSize
        );
        const clampedViewportStart = Math.min(
          newViewportStart,
          maxViewportStart
        );
        if (clampedViewportStart !== viewportStart) {
          setViewportStart(clampedViewportStart);
          const viewportInstructions = instructionBuffer.slice(
            clampedViewportStart,
            clampedViewportStart + viewportSize
          );
          setInstructions(viewportInstructions);
        }
      } finally {
        setLoading(false);
      }
      return;
    }

    // Use existing buffer data for smooth scrolling
    setViewportStart(newViewportStart);
    const viewportInstructions = instructionBuffer.slice(
      newViewportStart,
      newViewportStart + viewportSize
    );
    setInstructions(viewportInstructions);
  }, [
    loading,
    bufferSize,
    prefetchDistance,
    prefetchBuffers,
    loadDisassemblyAtAddressWithPrefetch,
    prefetchMemoryChunks,
    setPrefetchBuffers,
    viewportStart,
    instructionBuffer,
    viewportSize,
  ]);

  // Track the last loaded function address to prevent re-triggering on scroll
  // Removed: No longer needed as we handle address changes reactively

  // Load disassembly when function is selected or address changes
  useEffect(() => {
    console.log(
      `AssemblyView: useEffect triggered - assemblyAddress: ${assemblyAddress}, serverInfo:`,
      serverInfo,
      `mounted: ${mountedRef.current}`
    );

    if (assemblyAddress && mountedRef.current) {
      try {
        const address = parseAddress(assemblyAddress);
        if (!isNaN(address) && address > 0) {
          // If currently loading, queue this navigation for later (only in break state)
          if (loading && currentBaseAddress !== address && isInBreakState) {
            console.log(
              `[MAIN USEEFFECT] Currently loading in break state, queueing navigation to ${assemblyAddress} for after load completes`
            );
            setPendingNavigationAddress(assemblyAddress);
            return;
          }

          // Skip if already loading the same address
          if (loading && currentBaseAddress === address) {
            console.log(
              `[MAIN USEEFFECT] Already loading address ${assemblyAddress}, skipping duplicate load`
            );
            return;
          }

          console.log(
            `[MAIN USEEFFECT] Loading disassembly for address ${assemblyAddress} (0x${address.toString(16)})`
          );

          // Check if the target address is already within the current instruction buffer
          const targetAddressInBuffer = instructionBuffer.find(
            (instruction) =>
              normalizeAddress(instruction.address) ===
              normalizeAddress(assemblyAddress)
          );

          if (targetAddressInBuffer) {
            // Address is in buffer, just adjust viewport to show it
            console.log(
              `[MAIN USEEFFECT] Target address ${assemblyAddress} found in buffer, adjusting viewport`
            );
            const targetIndex = instructionBuffer.findIndex(
              (instruction) =>
                normalizeAddress(instruction.address) ===
                normalizeAddress(assemblyAddress)
            );

            if (targetIndex !== -1) {
              // Set target address at the TOP of viewport (index 0), not centered
              const newViewportStart = targetIndex;
              setViewportStart(newViewportStart);

              const viewportInstructions = instructionBuffer.slice(
                newViewportStart,
                newViewportStart + viewportSize
              );
              setInstructions(viewportInstructions);

              // Always update base address to the first instruction in buffer
              if (instructionBuffer.length > 0) {
                const firstInstructionAddress = parseInt(
                  instructionBuffer[0].address.replace("0x", ""),
                  16
                );
                setCurrentBaseAddress(firstInstructionAddress);
              }

              console.log(
                `[MAIN USEEFFECT] Viewport adjusted to show address ${assemblyAddress} at TOP (index ${targetIndex})`
              );
              return;
            }
          }

          // Target address not in buffer or buffer is empty, need to reload
          console.log(
            `[MAIN USEEFFECT] Target address ${assemblyAddress} not in buffer, reloading disassembly`
          );

          // Reset buffer and viewport when going to new address
          setInstructionBuffer([]);
          setViewportStart(0);
          setInstructions([]);
          setPrefetchBuffers(new Map()); // Clear prefetch buffers

          // Use regular loading and then prefetch
          loadDisassemblyAtAddress(address);
        } else {
          console.warn(
            `AssemblyView: Invalid function address: ${assemblyAddress}`
          );
          setError("");
          setInstructions([]);
          setInstructionBuffer([]);
          setPrefetchBuffers(new Map());
          setLoading(false);
        }
      } catch (err) {
        console.error("Address parsing error:", err);
        setError("Failed to parse function address");
        setInstructions([]);
        setInstructionBuffer([]);
        setPrefetchBuffers(new Map());
        setLoading(false);
      }
    } else {
      console.log(
        "AssemblyView: No function address provided or component not mounted, showing empty state"
      );
      setInstructions([]);
      setInstructionBuffer([]);
      setPrefetchBuffers(new Map());
      setError(null);
      setLoading(false);
    }
  }, [
    assemblyAddress, // React to address changes from global store
    assemblyNavigationTrigger, // Force re-execution for same address navigation
    serverInfo?.arch, // Only watch arch changes, not the entire serverInfo object
    isVisible, // React to visibility changes
    // Removed dependencies that cause infinite loops:
    // - normalizeAddress (useCallback, stable reference)
    // - loadDisassemblyAtAddress (useCallback, stable reference)
    // - loading (changes during effect execution, causes infinite loop)
    // - currentBaseAddress (changes during scroll/effect, causes infinite loop)
  ]);

  // Process pending navigation when loading completes (only in break state)
  useEffect(() => {
    if (
      !loading &&
      pendingNavigationAddress &&
      mountedRef.current &&
      isInBreakState
    ) {
      console.log(
        `[PENDING NAV] Loading completed in break state, processing pending navigation to ${pendingNavigationAddress}`
      );
      const pendingAddr = pendingNavigationAddress;
      setPendingNavigationAddress(null);

      try {
        const pendingAddrNum = parseAddress(pendingAddr);
        if (!isNaN(pendingAddrNum) && pendingAddrNum > 0) {
          // Trigger navigation by updating the address
          setTimeout(() => {
            setAssemblyAddress(pendingAddr);
          }, 50);
        }
      } catch (err) {
        console.error("Failed to process pending navigation:", err);
      }
    }
    // Clear pending navigation if we exit break state
    if (!isInBreakState && pendingNavigationAddress) {
      console.log(
        `[PENDING NAV] Exited break state, clearing pending navigation to ${pendingNavigationAddress}`
      );
      setPendingNavigationAddress(null);
    }
  }, [loading, pendingNavigationAddress, parseAddress, isInBreakState]);

  // Handle breakpoint toggle with improved debouncing and state management
  const toggleBreakpoint = useCallback(
    async (address: string) => {
      const timestamp = new Date().toISOString();

      // Improved debounce mechanism with shorter timeout and better state tracking
      const key = `toggle_${address}`;
      if ((window as any)[key]) {
        console.log(
          `[${timestamp}] DEBOUNCE: Ignoring duplicate toggle for ${address}`
        );
        return;
      }
      (window as any)[key] = true;
      setTimeout(() => delete (window as any)[key], 500); // Reduced from 1000ms to 500ms

      try {
        console.log(`=== TOGGLE BREAKPOINT START [${timestamp}] ===`);
        console.log("Address:", address);
        console.log("Current breakpoints state:", Array.from(breakpoints));

        const addressNum = parseInt(address.replace("0x", ""), 16);

        if (isNaN(addressNum)) {
          console.error("Invalid address format:", address);
          delete (window as any)[key];
          return;
        }

        // Get the current state snapshot to avoid race conditions
        const currentBreakpointsSnapshot = new Set(breakpoints);
        console.log(
          "Snapshot of breakpoints:",
          Array.from(currentBreakpointsSnapshot)
        );

        if (currentBreakpointsSnapshot.has(address)) {
          // Remove breakpoint - delegate to parent callback which handles API call
          console.log(
            `[${timestamp}] REMOVING breakpoint at:`,
            address,
            "numeric:",
            addressNum
          );
          // Call onBreakpointRemove callback - parent will call API
          if (onBreakpointRemove) {
            console.log(`[${timestamp}] Calling onBreakpointRemove callback`);
            onBreakpointRemove(address);
          }
        } else {
          // Set breakpoint - delegate to parent callback which handles API call
          console.log(
            `[${timestamp}] SETTING breakpoint at:`,
            address,
            "numeric:",
            addressNum,
            "isSoftware:",
            isSoftwareBreakpoint
          );
          // Call onBreakpointSet callback - parent will call API
          if (onBreakpointSet) {
            console.log(
              `[${timestamp}] Calling onBreakpointSet callback with isSoftware:`,
              isSoftwareBreakpoint
            );
            onBreakpointSet(address, isSoftwareBreakpoint);
          }
        }
        console.log(`=== TOGGLE BREAKPOINT END [${timestamp}] ===`);
      } catch (error) {
        addLog(
          "ERROR",
          "BREAKPOINT",
          `Failed to toggle breakpoint at ${address}: ${error instanceof Error ? error.message : "Unknown error"}`
        );
        console.error("Failed to toggle breakpoint:", error);
      } finally {
        // Ensure cleanup happens with a small delay
        setTimeout(() => delete (window as any)[key], 100);
      }
    },
    [onBreakpointSet, onBreakpointRemove, addLog, isSoftwareBreakpoint]
  );

  // Handle breakpoint column click with additional safeguards
  const handleBreakpointClick = useCallback(
    (address: string, event: React.MouseEvent) => {
      console.log("=== BREAKPOINT COLUMN CLICKED ===");
      console.log("Address:", address);
      console.log("Event target:", event.target);
      console.log("Event currentTarget:", event.currentTarget);
      console.log(
        "Current breakpoints before toggle:",
        Array.from(breakpoints)
      );

      // Prevent all event propagation
      event.stopPropagation();
      event.preventDefault();

      // Add a small delay to ensure UI state is stable
      setTimeout(() => {
        toggleBreakpoint(address);
      }, 50);
    },
    [toggleBreakpoint]
  );

  // Sync DecompileView for a given address (no assembly navigation)
  const syncDecompileView = useCallback(
    async (address: string) => {
      console.log(
        `[SYNC DECOMPILE] syncDecompileView called with address: ${address}`
      );

      // Notify parent about address click for DecompileView sync
      if (onAssemblyAddressClicked) {
        onAssemblyAddressClicked(address);
      }

      // If Decompile View is visible and the library is analyzed, trigger decompile for the function at this address
      console.log(
        `[SYNC DECOMPILE] isDecompileVisible: ${isDecompileVisible}, attachedModules.length: ${attachedModules.length}, onDecompileRequest: ${!!onDecompileRequest}`
      );

      if (isDecompileVisible && onDecompileRequest && attachedModules.length) {
        // Find the module for this address
        let numericAddress: number;
        if (address.startsWith("0x") || address.startsWith("0X")) {
          numericAddress = parseInt(address, 16);
        } else {
          numericAddress = parseInt(address, 10);
        }

        console.log(
          `[SYNC DECOMPILE] Parsed numeric address: 0x${numericAddress.toString(16)}`
        );

        if (!isNaN(numericAddress)) {
          for (const module of attachedModules) {
            const moduleBase = module.base;
            const moduleEnd = moduleBase + module.size;

            if (numericAddress >= moduleBase && numericAddress < moduleEnd) {
              const modulePath = module.modulename || module.name || "";
              console.log(
                `[SYNC DECOMPILE] Found module: ${modulePath}, base: 0x${moduleBase.toString(16)}`
              );

              // Check if this library is analyzed
              const analyzed = isLibraryAnalyzed(modulePath);
              console.log(`[SYNC DECOMPILE] Library analyzed: ${analyzed}`);

              if (analyzed) {
                // Get function info from the detail text
                const rawFunctionName = getModuleDetailText
                  ? getModuleDetailText(address)
                  : null;

                // Check if we're inside a function (contains @ symbol) or if library is analyzed
                // We'll let Ghidra find the function containing this address
                const clickedOffset = numericAddress - moduleBase;
                let offsetHex = `0x${clickedOffset.toString(16)}`;
                console.log(
                  `[SYNC DECOMPILE] Offset: ${offsetHex}, rawFunctionName: ${rawFunctionName}`
                );

                const moduleName =
                  modulePath.split(/[/\\]/).pop() || modulePath;
                const osKey = serverInfo?.target_os || "unknown";

                // Try to find function start from instructionBuffer for cache lookup
                if (rawFunctionName && rawFunctionName.includes("@")) {
                  const clickedIndex = instructionBuffer.findIndex(
                    (instr) =>
                      parseInt(instr.address.replace(/^0x/i, ""), 16) ===
                      numericAddress
                  );

                  console.log(
                    `[SYNC DECOMPILE] Looking for address ${numericAddress.toString(16)} in instructionBuffer (${instructionBuffer.length} entries), found at index: ${clickedIndex}`
                  );

                  if (clickedIndex >= 0) {
                    // Find the function start by scanning backward for isFunctionStart
                    let functionStartIndex = clickedIndex;
                    for (let i = clickedIndex; i >= 0; i--) {
                      if (instructionBuffer[i].isFunctionStart) {
                        functionStartIndex = i;
                        break;
                      }
                    }

                    console.log(
                      `[SYNC DECOMPILE] Function start found at index ${functionStartIndex}, address: ${instructionBuffer[functionStartIndex]?.address}`
                    );

                    const startInstruction =
                      instructionBuffer[functionStartIndex];
                    if (startInstruction) {
                      const startAddress = parseInt(
                        startInstruction.address.replace(/^0x/i, ""),
                        16
                      );
                      const functionStartOffset = startAddress - moduleBase;
                      const newOffsetHex = `0x${functionStartOffset.toString(16)}`;
                      console.log(
                        `[SYNC DECOMPILE] Calculated function start offset: ${newOffsetHex} (was ${offsetHex})`
                      );
                      offsetHex = newOffsetHex;
                    }
                  } else {
                    // Address not in instructionBuffer - use the clicked offset directly
                    // Ghidra will find the containing function
                    console.log(
                      `[SYNC DECOMPILE] Address not in buffer, using offset directly: ${offsetHex}`
                    );
                  }
                }

                // Get saved Ghidra path from localStorage
                const savedGhidraPath = localStorage.getItem(GHIDRA_PATH_KEY);
                if (!savedGhidraPath) {
                  addLog(
                    "WARN",
                    "GHIDRA",
                    "Ghidra path not configured. Please set it in the Tools tab."
                  );
                  return;
                }

                console.log(
                  `[SYNC DECOMPILE] Final offset for decompile: ${offsetHex}, checking cache...`
                );

                // Check cache first
                const cachedResult = await getDecompileFromCache(
                  osKey,
                  moduleName,
                  offsetHex
                );
                console.log(
                  `[SYNC DECOMPILE] Cache result:`,
                  cachedResult
                    ? `found (function: ${cachedResult.function_name})`
                    : "not found"
                );

                if (cachedResult?.success && cachedResult.decompiled_code) {
                  addLog(
                    "INFO",
                    "GHIDRA",
                    `Using cached decompile for: ${cachedResult.function_name || offsetHex}`
                  );
                  console.log(
                    `[SYNC DECOMPILE] Calling onDecompileRequest with cached result, offset: ${offsetHex}`
                  );
                  onDecompileRequest(
                    modulePath,
                    offsetHex,
                    cachedResult.function_name || null,
                    cachedResult.decompiled_code,
                    moduleBase,
                    cachedResult.line_mapping || null,
                    cachedResult.tokens || null
                  );
                  // Clear any previous error on success
                  onDecompileError?.(null);
                  return;
                }

                addLog(
                  "INFO",
                  "GHIDRA",
                  `Starting decompilation at offset: ${offsetHex}`
                );

                console.log(
                  `[SYNC DECOMPILE] No cache, calling decompileFunction with offset: ${offsetHex}`
                );
                const result = await decompileFunction(
                  modulePath,
                  offsetHex,
                  savedGhidraPath
                );

                console.log(
                  `[SYNC DECOMPILE] decompileFunction result:`,
                  result
                    ? `success=${result.success}, function=${result.function_name}`
                    : "null"
                );

                if (result?.success && result.decompiled_code) {
                  addLog(
                    "INFO",
                    "GHIDRA",
                    `Decompilation completed for: ${result.function_name || offsetHex}`
                  );

                  // Save to cache
                  await saveDecompileToCache(
                    osKey,
                    moduleName,
                    offsetHex,
                    result.function_name || "",
                    result.decompiled_code,
                    result.line_mapping
                  );

                  console.log(
                    `[SYNC DECOMPILE] Calling onDecompileRequest with new result, offset: ${offsetHex}, function: ${result.function_name}`
                  );
                  onDecompileRequest(
                    modulePath,
                    offsetHex,
                    result.function_name || null,
                    result.decompiled_code,
                    moduleBase,
                    result.line_mapping || null,
                    result.tokens || null
                  );
                  // Clear any previous error on success
                  onDecompileError?.(null);
                } else {
                  const errorMsg = result?.error || "Unknown error";
                  addLog("WARN", "GHIDRA", `Decompilation failed: ${errorMsg}`);
                  onDecompileError?.(errorMsg);
                }
              }
              break;
            }
          }
        }
      }
    },
    [
      onAssemblyAddressClicked,
      isDecompileVisible,
      onDecompileRequest,
      onDecompileError,
      attachedModules,
      isLibraryAnalyzed,
      getModuleDetailText,
      instructionBuffer,
      serverInfo?.target_os,
      getDecompileFromCache,
      decompileFunction,
      saveDecompileToCache,
      addLog,
    ]
  );

  // Handle click on instruction area (Bytes, Instruction columns) - sync DecompileView only, no assembly navigation
  const handleInstructionAreaClick = useCallback(
    async (address: string, event?: React.MouseEvent) => {
      if (event) {
        event.stopPropagation();
      }
      // Only sync DecompileView, don't navigate assembly
      await syncDecompileView(address);
    },
    [syncDecompileView]
  );

  // Sync decompile view when break address changes (for single step / breakpoint hit)
  // This is a separate useEffect because syncDecompileView is defined after the single step useEffect
  const lastSyncedDecompileAddressRef = useRef<string | null>(null);
  useEffect(() => {
    console.log(
      `[DECOMPILE SYNC EFFECT] currentBreakAddress: ${currentBreakAddress}, isInBreakState: ${isInBreakState}, lastSynced: ${lastSyncedDecompileAddressRef.current}`
    );

    if (!currentBreakAddress || !isInBreakState) {
      console.log(
        `[DECOMPILE SYNC EFFECT] Skipping - no break address or not in break state`
      );
      lastSyncedDecompileAddressRef.current = null;
      return;
    }

    // Skip if we already synced this address
    if (lastSyncedDecompileAddressRef.current === currentBreakAddress) {
      console.log(
        `[DECOMPILE SYNC EFFECT] Skipping - already synced this address`
      );
      return;
    }

    // Check if the break address is in an analyzed library before syncing
    // Parse address to check which module it belongs to
    let numericAddress: number;
    if (
      currentBreakAddress.startsWith("0x") ||
      currentBreakAddress.startsWith("0X")
    ) {
      numericAddress = parseInt(currentBreakAddress, 16);
    } else {
      numericAddress = parseInt(currentBreakAddress, 10);
    }

    if (isNaN(numericAddress)) {
      console.log(`[DECOMPILE SYNC EFFECT] Skipping - invalid address`);
      return;
    }

    // Find the module containing this address
    let isInAnalyzedLibrary = false;
    for (const module of attachedModules) {
      const moduleBase = module.base;
      const moduleEnd = moduleBase + module.size;

      if (numericAddress >= moduleBase && numericAddress < moduleEnd) {
        const modulePath = module.modulename || module.name || "";
        isInAnalyzedLibrary = isLibraryAnalyzed(modulePath);
        console.log(
          `[DECOMPILE SYNC EFFECT] Address is in module: ${modulePath}, analyzed: ${isInAnalyzedLibrary}`
        );
        break;
      }
    }

    if (!isInAnalyzedLibrary) {
      console.log(
        `[DECOMPILE SYNC EFFECT] Skipping - address not in analyzed library`
      );
      lastSyncedDecompileAddressRef.current = currentBreakAddress;
      return;
    }

    // Sync decompile view to the current break address (if analyzed and in a function)
    console.log(
      `[DECOMPILE SYNC] Syncing decompile view to break address: ${currentBreakAddress}`
    );
    syncDecompileView(currentBreakAddress);
    lastSyncedDecompileAddressRef.current = currentBreakAddress;
  }, [
    currentBreakAddress,
    isInBreakState,
    syncDecompileView,
    attachedModules,
    isLibraryAnalyzed,
  ]);

  const handleAddressClick = useCallback(
    async (address: string, event?: React.MouseEvent) => {
      console.log("=== ADDRESS COLUMN CLICKED ===");
      console.log("Address:", address);
      console.log("This should NOT trigger breakpoint toggle");
      // Stop event propagation to prevent double-click with instruction line
      if (event) {
        event.stopPropagation();
      }
      // Address click should navigate to that address (same as Go to Address)
      console.log("Address navigation clicked:", address);

      // Navigate to the clicked address with history tracking for Back button
      setAssemblyAddressWithHistory(address);

      // Sync DecompileView
      await syncDecompileView(address);
    },
    [setAssemblyAddressWithHistory, syncDecompileView]
  );

  // Context menu handler
  const handleContextMenu = useCallback(
    (address: string, instruction: Instruction, event: React.MouseEvent) => {
      event.preventDefault();
      setContextMenu({
        mouseX: event.clientX,
        mouseY: event.clientY,
        address,
        instruction,
      });
    },
    []
  );

  const handleContextMenuClose = useCallback(() => {
    setContextMenu(null);
  }, []);

  // Load signal configs when debugger settings dialog opens
  // Only load from server if localStorage is empty (first time)
  useEffect(() => {
    if (debuggerSettingsOpen) {
      // If we already have configs in localStorage, don't overwrite with server data
      if (signalConfigs.size > 0) {
        setLoadingSignals(false);
        return;
      }

      setLoadingSignals(true);
      const loadConfigs = async () => {
        try {
          const apiClient = getApiClient();
          const response = await apiClient.getSignalConfigs();
          console.log("Get signal configs response:", response);
          if (response.success && response.configs) {
            const configMap = new Map<
              number,
              { catch_signal: boolean; pass_signal: boolean }
            >();
            for (const cfg of response.configs) {
              configMap.set(cfg.signal, {
                catch_signal: cfg.catch_signal,
                pass_signal: cfg.pass_signal,
              });
            }
            setSignalConfigs(configMap);
          }
        } catch (error) {
          addLog(
            "ERROR",
            "SETTINGS",
            `Failed to load signal settings: ${error}`
          );
        } finally {
          setLoadingSignals(false);
        }
      };
      loadConfigs();
    }
  }, [debuggerSettingsOpen, addLog, signalConfigs.size]);

  // Helper to get config for a signal (with defaults)
  // Default: catch=false (don't stop), pass=false (suppress signal, like GDB)
  const getSignalConfig = useCallback(
    (signal: number) => {
      return (
        signalConfigs.get(signal) ?? { catch_signal: false, pass_signal: false }
      );
    },
    [signalConfigs]
  );

  const handleToggleSignalCatch = useCallback(
    async (signal: number) => {
      const current = getSignalConfig(signal);
      const newCatch = !current.catch_signal;

      try {
        const apiClient = getApiClient();
        const response = await apiClient.setSignalConfig(
          signal,
          newCatch,
          current.pass_signal
        );
        console.log("Signal config update response:", response);
        if (response.success && response.configs) {
          const configMap = new Map<
            number,
            { catch_signal: boolean; pass_signal: boolean }
          >();
          for (const cfg of response.configs) {
            configMap.set(cfg.signal, {
              catch_signal: cfg.catch_signal,
              pass_signal: cfg.pass_signal,
            });
          }
          setSignalConfigs(configMap);
          addLog(
            "INFO",
            "SETTINGS",
            `Signal ${signal}: catch=${newCatch}, pass=${current.pass_signal}`
          );
        } else if (response.success) {
          // Update local state if configs not in response
          setSignalConfigs((prev) => {
            const newMap = new Map(prev);
            newMap.set(signal, {
              catch_signal: newCatch,
              pass_signal: current.pass_signal,
            });
            return newMap;
          });
          addLog(
            "INFO",
            "SETTINGS",
            `Signal ${signal}: catch=${newCatch}, pass=${current.pass_signal}`
          );
        }
      } catch (error) {
        addLog("ERROR", "SETTINGS", `Failed to update signal: ${error}`);
      }
    },
    [getSignalConfig, addLog]
  );

  const handleToggleSignalPass = useCallback(
    async (signal: number) => {
      const current = getSignalConfig(signal);
      const newPass = !current.pass_signal;

      try {
        const apiClient = getApiClient();
        const response = await apiClient.setSignalConfig(
          signal,
          current.catch_signal,
          newPass
        );
        console.log("Signal config update response:", response);
        if (response.success && response.configs) {
          const configMap = new Map<
            number,
            { catch_signal: boolean; pass_signal: boolean }
          >();
          for (const cfg of response.configs) {
            configMap.set(cfg.signal, {
              catch_signal: cfg.catch_signal,
              pass_signal: cfg.pass_signal,
            });
          }
          setSignalConfigs(configMap);
          addLog(
            "INFO",
            "SETTINGS",
            `Signal ${signal}: catch=${current.catch_signal}, pass=${newPass}`
          );
        } else if (response.success) {
          // Update local state if configs not in response
          setSignalConfigs((prev) => {
            const newMap = new Map(prev);
            newMap.set(signal, {
              catch_signal: current.catch_signal,
              pass_signal: newPass,
            });
            return newMap;
          });
          addLog(
            "INFO",
            "SETTINGS",
            `Signal ${signal}: catch=${current.catch_signal}, pass=${newPass}`
          );
        }
      } catch (error) {
        addLog("ERROR", "SETTINGS", `Failed to update signal: ${error}`);
      }
    },
    [getSignalConfig, addLog]
  );

  // Copy address to clipboard
  const handleCopyAddress = useCallback(() => {
    if (contextMenu) {
      navigator.clipboard.writeText(contextMenu.address);
      addLog("INFO", "CLIPBOARD", `Copied address: ${contextMenu.address}`);
    }
    handleContextMenuClose();
  }, [contextMenu, addLog, handleContextMenuClose]);

  // Copy address as Module + offset format
  const handleCopyAddressWithOffset = useCallback(() => {
    if (contextMenu) {
      const address = contextMenu.address;
      let numericAddress: number;
      if (address.startsWith("0x") || address.startsWith("0X")) {
        numericAddress = parseInt(address, 16);
      } else {
        numericAddress = parseInt(address, 10);
      }

      if (!isNaN(numericAddress)) {
        for (const module of attachedModules) {
          const moduleBase = module.base;
          const moduleEnd = moduleBase + module.size;

          if (numericAddress >= moduleBase && numericAddress < moduleEnd) {
            const offset = numericAddress - moduleBase;
            const fullModuleName =
              module.modulename || module.name || "unknown";
            const fileName =
              fullModuleName.split(/[\/\\]/).pop() || fullModuleName;
            const result = `${fileName}+0x${offset.toString(16)}`;
            navigator.clipboard.writeText(result);
            addLog("INFO", "CLIPBOARD", `Copied: ${result}`);
            handleContextMenuClose();
            return;
          }
        }
      }
      // Fallback to just the address if module not found
      navigator.clipboard.writeText(address);
      addLog("INFO", "CLIPBOARD", `Copied address: ${address}`);
    }
    handleContextMenuClose();
  }, [contextMenu, attachedModules, addLog, handleContextMenuClose]);

  // Copy instruction to clipboard
  const handleCopyInstruction = useCallback(() => {
    if (contextMenu) {
      const { instruction } = contextMenu;
      const text = `${instruction.address}: ${instruction.opcode} ${formatOperands(instruction.operands)}`;
      navigator.clipboard.writeText(text);
      addLog("INFO", "CLIPBOARD", `Copied instruction: ${text}`);
    }
    handleContextMenuClose();
  }, [contextMenu, addLog, handleContextMenuClose]);

  // Copy bytecode to clipboard
  const handleCopyBytecode = useCallback(() => {
    if (contextMenu) {
      const { instruction } = contextMenu;
      // Remove spaces from bytes for clean copy
      const bytecode = instruction.bytes.replace(/\s+/g, "");
      navigator.clipboard.writeText(bytecode);
      addLog("INFO", "CLIPBOARD", `Copied bytecode: ${bytecode}`);
    }
    handleContextMenuClose();
  }, [contextMenu, addLog, handleContextMenuClose]);

  // Replace instruction with NOP
  const handleReplaceWithNop = useCallback(async () => {
    if (!contextMenu) {
      handleContextMenuClose();
      return;
    }

    const { address, instruction } = contextMenu;
    const architecture = serverInfo?.arch || "arm64";

    // Calculate instruction size from bytes
    const bytesString = instruction.bytes.replace(/\s+/g, "");
    const instructionSize = bytesString.length / 2; // Each byte is 2 hex characters

    let nopBytes: Uint8Array;
    let nopOpcode: string;
    let nopOperands: string;

    if (
      architecture === "x86_64" ||
      architecture === "x86" ||
      architecture === "i386"
    ) {
      // x86/x86_64: NOP is 0x90 (1 byte), repeat for instruction size
      nopBytes = new Uint8Array(instructionSize);
      nopBytes.fill(0x90);
      nopOpcode = "nop";
      nopOperands = "";
    } else {
      // ARM64: Use NOP instruction (0xD503201F) - 4 bytes
      nopBytes = new Uint8Array(4);
      // NOP instruction: 0x1F 0x20 0x03 0xD5 (little-endian for 0xD503201F)
      nopBytes[0] = 0x1f;
      nopBytes[1] = 0x20;
      nopBytes[2] = 0x03;
      nopBytes[3] = 0xd5;
      nopOpcode = "nop";
      nopOperands = "";
    }

    try {
      const apiClient = getApiClient();
      await apiClient.writeMemory(address, nopBytes.buffer as ArrayBuffer);

      const nopHex = Array.from(nopBytes)
        .map((b) => b.toString(16).padStart(2, "0"))
        .join(" ");
      addLog(
        "INFO",
        "PATCH",
        `Replaced instruction at ${address} with NOP: ${nopHex}`
      );

      // Create updated instruction
      const updatedInstr = {
        ...instruction,
        bytes: nopHex,
        opcode: nopOpcode,
        operands: nopOperands ? [{ type: "imm", value: nopOperands }] : [],
        comment: `; patched from: ${instruction.opcode} ${formatOperands(instruction.operands)}`,
      };

      // Update both instructionBuffer and instructions (display) state
      const updateInstructions = (prevList: Instruction[]) =>
        prevList.map((instr) =>
          instr.address === address ? updatedInstr : instr
        );

      setInstructionBuffer(updateInstructions);
      setInstructions(updateInstructions);
    } catch (error) {
      addLog(
        "ERROR",
        "PATCH",
        `Failed to replace with NOP at ${address}: ${error}`
      );
    }

    handleContextMenuClose();
  }, [contextMenu, serverInfo?.arch, addLog, handleContextMenuClose]);

  // Get current function boundaries for the context menu address
  const getContextMenuFunctionBounds = useCallback((): {
    startIndex: number;
    endIndex: number;
    functionName: string | null;
  } | null => {
    if (!contextMenu || !getModuleDetailText) return null;

    const address = contextMenu.address;
    const addressNum = parseInt(address.replace(/^0x/i, ""), 16);
    const rawFunctionName = getModuleDetailText(address);
    const functionName = rawFunctionName
      ? stripFunctionOffset(rawFunctionName)
      : null;

    // Only show function navigation if we're inside a named function (contains @)
    // e.g., "libc.so@open64" is a function, "libc.so + 0x1234" is not
    if (!functionName || !functionName.includes("@")) return null;

    const clickedIndex = instructionBuffer.findIndex(
      (instr) => parseInt(instr.address.replace(/^0x/i, ""), 16) === addressNum
    );

    if (clickedIndex === -1) return null;

    let startIndex = -1;
    let endIndex = -1;

    // Search backward for function start
    for (let i = clickedIndex; i >= 0; i--) {
      const instrFuncName = stripFunctionOffset(
        getModuleDetailText(instructionBuffer[i].address) || ""
      );
      if (instrFuncName !== functionName) {
        startIndex = i + 1;
        break;
      }
      if (i === 0) startIndex = 0;
    }

    // Search forward for function end
    for (let i = clickedIndex; i < instructionBuffer.length; i++) {
      const instrFuncName = stripFunctionOffset(
        getModuleDetailText(instructionBuffer[i].address) || ""
      );
      if (instrFuncName !== functionName) {
        endIndex = i - 1;
        break;
      }
      if (i === instructionBuffer.length - 1) endIndex = i;
    }

    if (startIndex === -1 || endIndex === -1) return null;

    return { startIndex, endIndex, functionName };
  }, [contextMenu, getModuleDetailText, instructionBuffer]);

  // Go to function start
  const handleGoToFunctionStart = useCallback(() => {
    const bounds = getContextMenuFunctionBounds();
    if (
      bounds &&
      bounds.startIndex >= 0 &&
      bounds.startIndex < instructionBuffer.length
    ) {
      const startAddr = instructionBuffer[bounds.startIndex].address;
      // Navigate to function start address
      setAssemblyAddress(startAddr);
      addLog("INFO", "NAVIGATION", `Jumped to function start: ${startAddr}`);
    }
    handleContextMenuClose();
  }, [
    getContextMenuFunctionBounds,
    instructionBuffer,
    setAssemblyAddress,
    addLog,
    handleContextMenuClose,
  ]);

  // Go to function end
  const handleGoToFunctionEnd = useCallback(() => {
    const bounds = getContextMenuFunctionBounds();
    if (
      bounds &&
      bounds.endIndex >= 0 &&
      bounds.endIndex < instructionBuffer.length
    ) {
      const endAddr = instructionBuffer[bounds.endIndex].address;
      // Navigate to function end address
      setAssemblyAddress(endAddr);
      addLog("INFO", "NAVIGATION", `Jumped to function end: ${endAddr}`);
    }
    handleContextMenuClose();
  }, [
    getContextMenuFunctionBounds,
    instructionBuffer,
    setAssemblyAddress,
    addLog,
    handleContextMenuClose,
  ]);

  // Start Code Tracing dialog - enabled for iOS
  const handleStartCodeTracing = useCallback(() => {
    if (contextMenu) {
      setPendingTraceAddress(contextMenu.address);
      setTraceCountDialogOpen(true);
    }
    handleContextMenuClose();
  }, [contextMenu, handleContextMenuClose]);

  // Helper to remove offset from function name (e.g., "libc.so@open64 + 0x38" -> "libc.so@open64")
  const stripFunctionOffset = (name: string): string => {
    if (!name) return "";
    const plusIndex = name.indexOf(" + ");
    if (plusIndex > 0) {
      return name.substring(0, plusIndex);
    }
    return name;
  };

  // Open Graph View dialog to set address range
  const handleOpenGraphView = useCallback(() => {
    if (!contextMenu) {
      handleContextMenuClose();
      return;
    }

    const address = contextMenu.address;
    const addressNum = parseInt(address.replace(/^0x/i, ""), 16);

    // Try to get function name from module detail (strip offset)
    const rawFunctionName = getModuleDetailText
      ? getModuleDetailText(address)
      : undefined;
    const functionName = rawFunctionName
      ? stripFunctionOffset(rawFunctionName)
      : undefined;

    // Find function boundaries using function name matching
    let functionStartIndex = -1;
    let functionEndIndex = -1;

    // Find the index of the clicked address in the instruction buffer
    const clickedIndex = instructionBuffer.findIndex(
      (instr) => parseInt(instr.address.replace(/^0x/i, ""), 16) === addressNum
    );

    if (clickedIndex !== -1 && functionName && getModuleDetailText) {
      // Search backward for function start by finding where function name changes or starts
      for (let i = clickedIndex; i >= 0; i--) {
        const instrFuncName = stripFunctionOffset(
          getModuleDetailText(instructionBuffer[i].address) || ""
        );
        if (instrFuncName !== functionName) {
          // Found a different function, so the next instruction is our function start
          functionStartIndex = i + 1;
          break;
        }
        // If we're at the beginning and still same function
        if (i === 0) {
          functionStartIndex = 0;
        }
      }

      // Search forward for function end by finding where function name changes
      for (let i = clickedIndex; i < instructionBuffer.length; i++) {
        const instrFuncName = stripFunctionOffset(
          getModuleDetailText(instructionBuffer[i].address) || ""
        );
        if (instrFuncName !== functionName) {
          // Found a different function, so the previous instruction is our function end
          functionEndIndex = i - 1;
          break;
        }
        // If we're at the end and still same function
        if (i === instructionBuffer.length - 1) {
          functionEndIndex = i;
        }
      }
    }

    // Fallback: if function name matching didn't work, use isFunctionStart/isFunctionEnd flags
    if (functionStartIndex === -1 && clickedIndex !== -1) {
      for (let i = clickedIndex; i >= 0; i--) {
        if (instructionBuffer[i].isFunctionStart) {
          functionStartIndex = i;
          break;
        }
      }
    }

    if (functionEndIndex === -1 && clickedIndex !== -1) {
      for (let i = clickedIndex; i < instructionBuffer.length; i++) {
        if (instructionBuffer[i].isFunctionEnd) {
          functionEndIndex = i;
          break;
        }
      }
    }

    // Final fallback: search for ret instruction
    if (functionStartIndex === -1) {
      if (clickedIndex !== -1) {
        for (let i = clickedIndex - 1; i >= 0; i--) {
          const opcode = instructionBuffer[i].opcode.toLowerCase();
          if (opcode === "ret" || opcode === "retn") {
            functionStartIndex = i + 1;
            break;
          }
        }
      }
      if (functionStartIndex === -1) functionStartIndex = 0;
    }

    if (functionEndIndex === -1) {
      if (clickedIndex !== -1) {
        for (let i = clickedIndex; i < instructionBuffer.length; i++) {
          const opcode = instructionBuffer[i].opcode.toLowerCase();
          // ret/retn for native, 'end' at indent 0 for WASM
          if (opcode === "ret" || opcode === "retn" || 
              (opcode === "end" && instructionBuffer[i].indent === 0)) {
            functionEndIndex = i;
            break;
          }
        }
      }
      if (functionEndIndex === -1)
        functionEndIndex = instructionBuffer.length - 1;
    }

    // Set default addresses for dialog
    const startAddr = instructionBuffer[functionStartIndex]?.address || address;
    const endAddr = instructionBuffer[functionEndIndex]?.address || address;

    setPendingGraphViewAddress(address);
    setPendingGraphViewFunctionName(functionName);
    setGraphViewStartAddress(startAddr);
    setGraphViewEndAddress(endAddr);
    setGraphViewDialogOpen(true);

    handleContextMenuClose();
  }, [
    contextMenu,
    handleContextMenuClose,
    getModuleDetailText,
    instructionBuffer,
  ]);

  // Execute Graph View with specified address range
  const handleExecuteGraphView = useCallback(async () => {
    const startAddrNum = parseInt(
      graphViewStartAddress.replace(/^0x/i, ""),
      16
    );
    const endAddrNum = parseInt(graphViewEndAddress.replace(/^0x/i, ""), 16);

    if (isNaN(startAddrNum) || isNaN(endAddrNum)) {
      addLog("ERROR", "GRAPH", "Invalid address format");
      return;
    }

    if (startAddrNum >= endAddrNum) {
      addLog("ERROR", "GRAPH", "Start address must be less than end address");
      return;
    }

    setGraphViewDialogOpen(false);

    addLog(
      "INFO",
      "GRAPH",
      `Opening graph view for range ${graphViewStartAddress} - ${graphViewEndAddress}`
    );

    // Filter instructions within the specified range
    const rangeInstructions = instructionBuffer.filter((instr) => {
      const instrAddr = parseInt(instr.address.replace(/^0x/i, ""), 16);
      return instrAddr >= startAddrNum && instrAddr <= endAddrNum;
    });

    if (rangeInstructions.length === 0) {
      addLog("ERROR", "GRAPH", "No instructions found in the specified range");
      return;
    }

    // Convert to GraphViewInstruction format with detail info
    const graphInstructions: GraphViewInstruction[] = rangeInstructions.map(
      (instr) => ({
        address: instr.address,
        bytes: instr.bytes,
        opcode: instr.opcode,
        operands: instr.operands.map((op) => op.value).join(", "),
        detail: getModuleDetailText
          ? getModuleDetailText(instr.address)
          : undefined,
      })
    );

    // Find module info for Ghidra CFG support
    let libraryPath: string | undefined;
    let functionOffset: string | undefined;

    if (attachedModules.length > 0) {
      for (const module of attachedModules) {
        const moduleBase = BigInt(module.base);
        const moduleSize = BigInt(module.size);
        const moduleEnd = moduleBase + moduleSize;

        if (
          BigInt(startAddrNum) >= moduleBase &&
          BigInt(startAddrNum) < moduleEnd
        ) {
          // Found the module containing this address
          libraryPath = module.path || module.modulename || module.name;
          // Calculate function offset from module base
          const offset = BigInt(startAddrNum) - moduleBase;
          functionOffset = `0x${offset.toString(16)}`;
          addLog(
            "DEBUG",
            "GRAPH",
            `Found module: ${libraryPath}, offset: ${functionOffset}`
          );
          break;
        }
      }
    }

    const graphViewData: GraphViewData = {
      address: pendingGraphViewAddress,
      functionName: pendingGraphViewFunctionName,
      instructions: graphInstructions,
      functionStartAddress: graphViewStartAddress,
      functionEndAddress: graphViewEndAddress,
      libraryPath,
      functionOffset,
      serverUrl: getApiClient().getBaseUrl(),
    };

    try {
      await openGraphViewWindow(graphViewData);
    } catch (error) {
      addLog("ERROR", "GRAPH", `Failed to open graph view: ${error}`);
    }
  }, [
    graphViewStartAddress,
    graphViewEndAddress,
    pendingGraphViewAddress,
    pendingGraphViewFunctionName,
    instructionBuffer,
    getModuleDetailText,
    addLog,
    attachedModules,
  ]);

  // Execute Code Tracing with specified count
  const handleExecuteCodeTracing = useCallback(async () => {
    const count = parseInt(traceCountInput, 10);
    if (isNaN(count) || count <= 0) {
      addLog("ERROR", "TRACING", "Invalid trace count");
      return;
    }

    // Get optional end address
    const endAddress = traceEndAddressInput.trim() || undefined;

    setTraceCountDialogOpen(false);

    if (traceToFile) {
      // Trace to file mode - show progress UI, no window
      const endAddrMsg = endAddress ? `, end: ${endAddress}` : "";
      const memCacheMsg = fullMemoryCache ? " (full memory cache)" : "";
      addLog(
        "INFO",
        "TRACING",
        `Starting file trace session for ${pendingTraceAddress} with max ${count} hits${endAddrMsg}${memCacheMsg}`
      );

      const result = await startTraceSession(
        pendingTraceAddress,
        count,
        true,
        endAddress,
        fullMemoryCache
      );

      if (!result.success) {
        addLog("ERROR", "TRACING", "Failed to start file trace session");
        return;
      }

      const filePath = result.traceFilePath || "server default";
      addLog(
        "INFO",
        "TRACING",
        `File trace session started. Output: ${filePath}`
      );

      // Set initial progress state
      setFileTraceProgress({
        isActive: true,
        current: 0,
        total: count,
        filePath: filePath,
      });

      // Poll for trace completion
      const apiClient = getApiClient();
      const targetCount = count;
      let lastKnownFilePath = filePath; // Keep track of file path
      const pollInterval = setInterval(async () => {
        try {
          const status = await apiClient.getTraceStatus();

          // Remember file path while it's available
          if (status.file_path) {
            lastKnownFilePath = status.file_path;
          }

          // Update progress
          setFileTraceProgress((prev) =>
            prev
              ? {
                  ...prev,
                  current: status.entry_count,
                  filePath: lastKnownFilePath,
                }
              : null
          );

          // Trace is complete when:
          // 1. enabled becomes false (server closed the file), or
          // 2. entry_count >= targetCount, or
          // 3. ended_by_end_address is true (reached end address)
          if (
            !status.enabled ||
            status.entry_count >= targetCount ||
            status.ended_by_end_address
          ) {
            // Trace complete
            clearInterval(pollInterval);

            const reason = status.ended_by_end_address
              ? "end address reached"
              : status.entry_count >= targetCount
                ? "target count reached"
                : "server closed file";

            addLog(
              "INFO",
              "TRACING",
              `File trace completed (${reason}) with ${status.entry_count} entries. File saved to: ${lastKnownFilePath}`
            );

            // Clear progress and show completion dialog
            setFileTraceProgress(null);
            setFileTraceCompleteDialog({
              open: true,
              entryCount: status.entry_count,
              filePath: lastKnownFilePath,
              downloaded: false,
            });
          }
        } catch (pollError) {
          console.error("Error polling trace status:", pollError);
        }
      }, 300); // Poll every 300ms for smoother progress

      // Stop polling after 5 minutes timeout
      setTimeout(
        () => {
          clearInterval(pollInterval);
          setFileTraceProgress(null);
        },
        5 * 60 * 1000
      );

      // Reset the checkbox and end address
      setTraceToFile(false);
      setTraceEndAddressInput("");
    } else {
      // Normal UI trace mode
      const endAddrMsg = endAddress ? `, end: ${endAddress}` : "";
      addLog(
        "INFO",
        "TRACING",
        `Starting trace session for ${pendingTraceAddress} with max ${count} hits${endAddrMsg}`
      );

      // Start trace session in Tauri store and set breakpoint
      const result = await startTraceSession(
        pendingTraceAddress,
        count,
        false,
        endAddress
      );

      if (!result.success) {
        addLog("ERROR", "TRACING", "Failed to start trace session");
        return;
      }

      // Open independent Code Tracing window
      openCodeTracingWindow(pendingTraceAddress, count);
      addLog(
        "INFO",
        "TRACING",
        `Opened code tracing window for ${pendingTraceAddress}`
      );

      // Reset end address
      setTraceEndAddressInput("");
    }
  }, [
    traceCountInput,
    traceEndAddressInput,
    pendingTraceAddress,
    traceToFile,
    addLog,
  ]);

  // Helper: Get module info for an address
  const getModuleForAddress = useCallback(
    (address: string): ModuleInfo | null => {
      if (!attachedModules.length) return null;

      let numericAddress: number;
      if (address.startsWith("0x") || address.startsWith("0X")) {
        numericAddress = parseInt(address, 16);
      } else {
        numericAddress = parseInt(address, 10);
      }

      if (isNaN(numericAddress)) return null;

      for (const module of attachedModules) {
        const moduleBase = module.base;
        const moduleEnd = moduleBase + module.size;

        if (numericAddress >= moduleBase && numericAddress < moduleEnd) {
          return module;
        }
      }

      return null;
    },
    [attachedModules]
  );

  // Get library path for context menu address
  const getContextMenuLibraryInfo = useCallback((): {
    path: string;
    offset: number;
    functionStartOffset: number | null; // Offset of function start (for Ghidra decompile)
    functionName: string | null;
    moduleBase: number; // Base address of the module in memory
  } | null => {
    if (!contextMenu) return null;

    const address = contextMenu.address;
    const module = getModuleForAddress(address);
    if (!module) return null;

    const numericAddress = parseInt(address.replace(/^0x/i, ""), 16);
    const offset = numericAddress - module.base;

    // Get function name
    const rawFunctionName = getModuleDetailText
      ? getModuleDetailText(address)
      : null;
    let functionName: string | null = null;

    if (rawFunctionName && rawFunctionName.includes("@")) {
      const atIndex = rawFunctionName.indexOf("@");
      const plusIndex = rawFunctionName.indexOf(" + ");
      functionName =
        plusIndex > 0
          ? rawFunctionName.substring(atIndex + 1, plusIndex)
          : rawFunctionName.substring(atIndex + 1);
    }

    // Get function start offset using getContextMenuFunctionBounds
    let functionStartOffset: number | null = null;
    const bounds = getContextMenuFunctionBounds();
    if (
      bounds &&
      bounds.startIndex >= 0 &&
      instructionBuffer[bounds.startIndex]
    ) {
      const startAddress = instructionBuffer[bounds.startIndex].address;
      const startNumericAddress = parseInt(
        startAddress.replace(/^0x/i, ""),
        16
      );
      functionStartOffset = startNumericAddress - module.base;
    }

    return {
      path: module.modulename || module.name || "",
      offset,
      functionStartOffset,
      functionName,
      moduleBase: module.base,
    };
  }, [
    contextMenu,
    getModuleForAddress,
    getModuleDetailText,
    getContextMenuFunctionBounds,
    instructionBuffer,
  ]);

  // Check if current address has library resolved
  const contextMenuHasLibrary = useMemo(() => {
    return getContextMenuLibraryInfo() !== null;
  }, [getContextMenuLibraryInfo]);

  // Check if current library is analyzed with Ghidra
  const contextMenuLibraryAnalyzed = useMemo(() => {
    const info = getContextMenuLibraryInfo();
    if (!info) return false;
    return isLibraryAnalyzed(info.path);
  }, [getContextMenuLibraryInfo, isLibraryAnalyzed]);

  // Handle Decompile with Ghidra
  const handleDecompileWithGhidra = useCallback(async () => {
    const info = getContextMenuLibraryInfo();
    if (!info) {
      addLog("ERROR", "GHIDRA", "No library found for this address");
      handleContextMenuClose();
      return;
    }

    if (!contextMenu) {
      handleContextMenuClose();
      return;
    }

    // Check if library is already analyzed
    if (!isLibraryAnalyzed(info.path)) {
      const moduleName = info.path.split(/[/\\]/).pop() || info.path;
      addLog(
        "ERROR",
        "GHIDRA",
        `Library not analyzed: ${moduleName}. Please analyze it first in the Tools tab (Ghidra section).`
      );
      handleContextMenuClose();
      return;
    }

    // Get saved Ghidra path from localStorage
    const savedGhidraPath = localStorage.getItem(GHIDRA_PATH_KEY);
    if (!savedGhidraPath) {
      addLog(
        "ERROR",
        "GHIDRA",
        "Ghidra path not configured. Please set it in the Tools tab (Ghidra section)."
      );
      handleContextMenuClose();
      return;
    }

    // Library is analyzed, proceed directly to decompile without dialog
    handleContextMenuClose();

    // Check if Ghidra server is running for this library
    const libInfo = getAnalyzedLibraryInfo(info.path);
    const isServerRunningForLib =
      serverRunning && libInfo && serverProjectPath === libInfo.projectPath;
    if (!isServerRunningForLib) {
      addLog(
        "INFO",
        "GHIDRA",
        "Ghidra server is not running. Decompilation may take longer. Start the server in Tools > Ghidra for faster results."
      );
      // Show processing snackbar for slow operation
      setProcessingSnackbar({
        open: true,
        message:
          "Decompiling... This may take a while without Ghidra server running.",
      });
    }

    // Use function start offset for decompilation
    const functionStartOffset = info.functionStartOffset;
    if (functionStartOffset === null) {
      addLog("ERROR", "GHIDRA", "Not inside a function - cannot decompile");
      return;
    }

    const offsetHex = `0x${functionStartOffset.toString(16)}`;
    const moduleName = info.path.split(/[/\\]/).pop() || info.path;
    const osKey = serverInfo?.target_os || "unknown";

    // Check cache first
    const cachedResult = await getDecompileFromCache(
      osKey,
      moduleName,
      offsetHex
    );
    if (cachedResult?.success && cachedResult.decompiled_code) {
      addLog(
        "INFO",
        "GHIDRA",
        `Using cached decompile for: ${cachedResult.function_name || offsetHex}`
      );
      if (onDecompileRequest) {
        onDecompileRequest(
          info.path,
          offsetHex,
          cachedResult.function_name || null,
          cachedResult.decompiled_code,
          info.moduleBase,
          cachedResult.line_mapping || null,
          cachedResult.tokens || null
        );
      }
      return;
    }

    addLog("INFO", "GHIDRA", `Starting decompilation at offset: ${offsetHex}`);

    const result = await decompileFunction(
      info.path,
      offsetHex,
      savedGhidraPath
    );

    // Close processing snackbar
    setProcessingSnackbar({ open: false, message: "" });

    if (result?.success) {
      addLog(
        "INFO",
        "GHIDRA",
        `Decompilation completed for: ${result.function_name || offsetHex}`
      );

      // Save to cache
      if (result.decompiled_code) {
        await saveDecompileToCache(
          osKey,
          moduleName,
          offsetHex,
          result.function_name || "",
          result.decompiled_code,
          result.line_mapping
        );
      }

      if (onDecompileRequest && result.decompiled_code) {
        onDecompileRequest(
          info.path,
          offsetHex,
          result.function_name || null,
          result.decompiled_code,
          info.moduleBase,
          result.line_mapping || null,
          result.tokens || null
        );
      }
    } else {
      addLog(
        "ERROR",
        "GHIDRA",
        `Decompilation failed: ${result?.error || "Unknown error"}`
      );
    }
  }, [
    getContextMenuLibraryInfo,
    contextMenu,
    addLog,
    handleContextMenuClose,
    isLibraryAnalyzed,
    decompileFunction,
    onDecompileRequest,
    serverInfo?.target_os,
    getDecompileFromCache,
    saveDecompileToCache,
  ]);

  // Handle Get Xrefs with Ghidra
  const handleGetXrefs = useCallback(async () => {
    const info = getContextMenuLibraryInfo();
    if (!info) {
      addLog("ERROR", "GHIDRA", "No library found for this address");
      handleContextMenuClose();
      return;
    }

    // Check if library is already analyzed
    if (!isLibraryAnalyzed(info.path)) {
      const moduleName = info.path.split(/[/\\]/).pop() || info.path;
      addLog(
        "ERROR",
        "GHIDRA",
        `Library not analyzed: ${moduleName}. Please analyze it first in the Tools tab (Ghidra section).`
      );
      handleContextMenuClose();
      return;
    }

    // Get saved Ghidra path from localStorage
    const savedGhidraPath = localStorage.getItem(GHIDRA_PATH_KEY);
    if (!savedGhidraPath) {
      addLog(
        "ERROR",
        "GHIDRA",
        "Ghidra path not configured. Please set it in the Tools tab (Ghidra section)."
      );
      handleContextMenuClose();
      return;
    }

    handleContextMenuClose();

    // Check if Ghidra server is running for this library
    const libInfo = getAnalyzedLibraryInfo(info.path);
    const isServerRunningForLib =
      serverRunning && libInfo && serverProjectPath === libInfo.projectPath;
    if (!isServerRunningForLib) {
      addLog(
        "INFO",
        "GHIDRA",
        "Ghidra server is not running. Xref lookup may take longer. Start the server in Tools > Ghidra for faster results."
      );
      // Show processing snackbar for slow operation
      setProcessingSnackbar({
        open: true,
        message:
          "Loading Xrefs... This may take a while without Ghidra server running.",
      });
    }

    // Use function start offset for xref lookup
    const functionStartOffset = info.functionStartOffset;
    if (functionStartOffset === null) {
      addLog("ERROR", "GHIDRA", "Not inside a function - cannot get xrefs");
      return;
    }

    const offsetHex = `0x${functionStartOffset.toString(16)}`;
    const moduleName = info.path.split(/[/\\]/).pop() || info.path;
    const osKey = serverInfo?.target_os || "unknown";

    // Reference types that are code references (call/jump instructions)
    const codeRefTypes = [
      "UNCONDITIONAL_CALL",
      "CONDITIONAL_CALL",
      "UNCONDITIONAL_JUMP",
      "CONDITIONAL_JUMP",
      "CALL_OVERRIDE_UNCONDITIONAL",
      "JUMP_OVERRIDE_UNCONDITIONAL",
    ];

    // Helper function to fetch instructions for code reference xrefs
    const fetchInstructionsForXrefs = async (
      xrefs: Array<{
        from_address: string;
        from_function: string | null;
        ref_type: string;
        instruction?: string | null;
      }>,
      moduleBase: number
    ) => {
      const apiClient = getApiClient();
      const architecture = serverInfo?.arch || "arm64";

      return Promise.all(
        xrefs.map(async (xref) => {
          // Only fetch instruction for code references (CALL/JUMP types)
          if (!codeRefTypes.includes(xref.ref_type)) {
            return xref;
          }

          try {
            const addressStr = xref.from_address.startsWith("0x")
              ? xref.from_address.slice(2)
              : xref.from_address;
            const offset = parseInt(addressStr, 16);
            if (isNaN(offset)) return xref;

            const realAddress = moduleBase + offset;

            const memoryBuffer = await apiClient.readMemory(
              `0x${realAddress.toString(16)}`,
              16,
              true
            );
            const memoryData = Array.from(new Uint8Array(memoryBuffer));

            const response: DisassembleResponse = await invoke(
              "disassemble_memory_direct",
              {
                memoryData,
                address: realAddress,
                architecture,
              }
            );

            if (response.success && response.disassembly) {
              const lines = response.disassembly
                .split("\n")
                .filter((line: string) => line.trim());
              if (lines.length > 0) {
                const parts = lines[0].split("|");
                if (parts.length >= 3) {
                  return { ...xref, instruction: parts[2].trim() };
                }
              }
            }
          } catch (e) {
            console.error("Failed to get instruction for xref:", e);
          }
          return xref;
        })
      );
    };

    // Check cache first
    const cachedResult = await getXrefFromCache(osKey, moduleName, offsetHex);
    if (cachedResult?.success && cachedResult.xrefs) {
      addLog(
        "INFO",
        "GHIDRA",
        `Using cached xrefs for: ${cachedResult.target_function}`
      );

      // Fetch instructions for code references
      const xrefsWithInstructions = await fetchInstructionsForXrefs(
        cachedResult.xrefs,
        info.moduleBase
      );

      setXrefData({
        targetFunction: cachedResult.target_function,
        targetAddress: cachedResult.target_address,
        moduleBase: info.moduleBase,
        moduleName: moduleName,
        xrefs: xrefsWithInstructions,
      });
      setXrefDialogOpen(true);
      return;
    }

    addLog(
      "INFO",
      "GHIDRA",
      `Getting xrefs for function at offset: ${offsetHex}`
    );

    setXrefLoading(true);
    setXrefDialogOpen(true);
    setXrefData(null);

    const result = await getXrefs(info.path, offsetHex, savedGhidraPath);

    setXrefLoading(false);
    // Close processing snackbar
    setProcessingSnackbar({ open: false, message: "" });

    if (result?.success) {
      // Fetch instructions for code references
      const xrefsWithInstructions = await fetchInstructionsForXrefs(
        result.xrefs,
        info.moduleBase
      );

      // Save to cache
      await saveXrefToCache(
        osKey,
        moduleName,
        offsetHex,
        result.target_function,
        xrefsWithInstructions
      );

      setXrefData({
        targetFunction: result.target_function,
        targetAddress: result.target_address,
        moduleBase: info.moduleBase,
        moduleName: moduleName,
        xrefs: xrefsWithInstructions,
      });
      addLog(
        "INFO",
        "GHIDRA",
        `Found ${result.xrefs.length} xrefs for: ${result.target_function}`
      );
    } else {
      addLog(
        "ERROR",
        "GHIDRA",
        `Failed to get xrefs: ${result?.error || "Unknown error"}`
      );
      setXrefDialogOpen(false);
    }
  }, [
    getContextMenuLibraryInfo,
    addLog,
    handleContextMenuClose,
    isLibraryAnalyzed,
    getXrefs,
    serverInfo?.target_os,
    serverInfo?.arch,
    getXrefFromCache,
    saveXrefToCache,
  ]);

  // Handle Ghidra settings save and execute action
  const handleSaveGhidraSettings = useCallback(async () => {
    setGhidraSettingsDialogOpen(false);
    addLog("INFO", "GHIDRA", `Ghidra path: ${ghidraPathInput}`);

    // Use saved library info instead of getContextMenuLibraryInfo
    const info = pendingGhidraLibraryInfo;
    if (!info) {
      console.log("[GHIDRA] No pending library info available");
      addLog("ERROR", "GHIDRA", "No library information available");
      setPendingGhidraAction(null);
      setPendingGhidraLibraryInfo(null);
      setPendingGhidraAddress(null);
      return;
    }

    if (pendingGhidraAction === "analyze") {
      addLog("INFO", "GHIDRA", `Starting Ghidra analysis for: ${info.path}`);
      console.log("[GHIDRA] Starting analysis with path:", ghidraPathInput);
      console.log("[GHIDRA] Library path:", info.path);
      const result = await analyzeLibrary(info.path, ghidraPathInput);
      console.log("[GHIDRA] Analysis result:", result);

      if (result?.analyzed) {
        console.log("[GHIDRA] Analysis completed successfully");
        addLog(
          "INFO",
          "GHIDRA",
          `Analysis completed successfully for: ${info.path}`
        );
      } else {
        console.log("[GHIDRA] Analysis failed:", result?.error);
        addLog(
          "ERROR",
          "GHIDRA",
          `Analysis failed: ${result?.error || "Unknown error"}`
        );
      }
    } else if (pendingGhidraAction === "decompile") {
      // Use function start offset for decompilation
      const functionStartOffset = info.functionStartOffset;
      if (functionStartOffset === null) {
        console.log("[GHIDRA] No function start offset available");
        addLog("ERROR", "GHIDRA", "Not inside a function - cannot decompile");
        setPendingGhidraAction(null);
        setPendingGhidraLibraryInfo(null);
        setPendingGhidraAddress(null);
        return;
      }

      const offsetHex = `0x${functionStartOffset.toString(16)}`;

      addLog(
        "INFO",
        "GHIDRA",
        `Starting decompilation at offset: ${offsetHex}`
      );
      console.log(
        "[GHIDRA] Starting decompilation with path:",
        ghidraPathInput
      );
      console.log("[GHIDRA] Library path:", info.path);
      console.log("[GHIDRA] Function offset:", offsetHex);
      console.log("[GHIDRA] Original address:", pendingGhidraAddress);
      const result = await decompileFunction(
        info.path,
        offsetHex,
        ghidraPathInput
      );
      console.log("[GHIDRA] Decompile result:", result);

      if (result?.success) {
        console.log("[GHIDRA] Decompilation completed successfully");
        console.log("[GHIDRA] Line mapping:", result.line_mapping);
        addLog(
          "INFO",
          "GHIDRA",
          `Decompilation completed for: ${result.function_name || offsetHex}`
        );
        // Call parent handler to show in DecompileView
        if (onDecompileRequest && result.decompiled_code) {
          onDecompileRequest(
            info.path,
            offsetHex,
            result.function_name || null,
            result.decompiled_code,
            info.moduleBase,
            result.line_mapping || null,
            result.tokens || null
          );
        }
      } else {
        addLog(
          "ERROR",
          "GHIDRA",
          `Decompilation failed: ${result?.error || "Unknown error"}`
        );
      }
    }

    setPendingGhidraAction(null);
    setPendingGhidraLibraryInfo(null);
    setPendingGhidraAddress(null);
  }, [
    ghidraPathInput,
    pendingGhidraAction,
    pendingGhidraLibraryInfo,
    pendingGhidraAddress,
    analyzeLibrary,
    decompileFunction,
    addLog,
    onDecompileRequest,
  ]);

  const handleWheelScroll = useCallback(
    (event: React.WheelEvent<HTMLDivElement>) => {
      if (loading) return;

      event.preventDefault(); // Prevent default scrolling

      // Debounce scroll events for better performance
      clearTimeout((window as any).scrollTimeout);
      (window as any).scrollTimeout = setTimeout(() => {
        // Use smaller scroll steps for smoother experience
        if (event.deltaY < 0) {
          scrollUp();
        } else {
          scrollDown();
        }
      }, 16); // ~60fps debounce
    },
    [loading, scrollUp, scrollDown]
  );

  /* Handle Decompile icon click - currently disabled, use right-click context menu instead
  const handleDecompileIconClick = useCallback(async () => {
    // First, toggle the decompile view
    if (onToggleDecompile) {
      onToggleDecompile();
    }

    // If there's a focused line and the library is analyzed, trigger decompile for that function
    if (
      focusedLineAddress &&
      isCurrentLibraryAnalyzed &&
      onDecompileRequest &&
      attachedModules.length
    ) {
      // Use handleAddressClick logic to trigger decompile
      // Find the module for this address
      let numericAddress: number;
      if (
        focusedLineAddress.startsWith("0x") ||
        focusedLineAddress.startsWith("0X")
      ) {
        numericAddress = parseInt(focusedLineAddress, 16);
      } else {
        numericAddress = parseInt(focusedLineAddress, 10);
      }

      if (!isNaN(numericAddress)) {
        for (const module of attachedModules) {
          const moduleBase = module.base;
          const moduleEnd = moduleBase + module.size;

          if (numericAddress >= moduleBase && numericAddress < moduleEnd) {
            const modulePath = module.modulename || module.name || "";

            // Check if this library is analyzed
            if (isLibraryAnalyzed(modulePath)) {
              // Get function info from the detail text
              const rawFunctionName = getModuleDetailText
                ? getModuleDetailText(focusedLineAddress)
                : null;

              // Check if we're inside a function (contains @ symbol)
              if (rawFunctionName && rawFunctionName.includes("@")) {
                // Find the function start by looking at the instruction buffer
                const clickedIndex = instructionBuffer.findIndex(
                  (instr) =>
                    parseInt(instr.address.replace(/^0x/i, ""), 16) ===
                    numericAddress
                );

                if (clickedIndex >= 0) {
                  // Find the function start by scanning backward for isFunctionStart
                  let functionStartIndex = clickedIndex;
                  for (let i = clickedIndex; i >= 0; i--) {
                    if (instructionBuffer[i].isFunctionStart) {
                      functionStartIndex = i;
                      break;
                    }
                  }

                  const startInstruction =
                    instructionBuffer[functionStartIndex];
                  if (startInstruction) {
                    const startAddress = parseInt(
                      startInstruction.address.replace(/^0x/i, ""),
                      16
                    );
                    const functionStartOffset = startAddress - moduleBase;
                    const offsetHex = `0x${functionStartOffset.toString(16)}`;
                    const moduleName =
                      modulePath.split(/[/\\]/).pop() || modulePath;
                    const osKey = serverInfo?.target_os || "unknown";

                    // Get saved Ghidra path from localStorage
                    const savedGhidraPath =
                      localStorage.getItem(GHIDRA_PATH_KEY);
                    if (!savedGhidraPath) {
                      addLog(
                        "WARN",
                        "GHIDRA",
                        "Ghidra path not configured. Please set it in the Tools tab."
                      );
                      return;
                    }

                    // Check cache first
                    const cachedResult = await getDecompileFromCache(
                      osKey,
                      moduleName,
                      offsetHex
                    );
                    if (cachedResult?.success && cachedResult.decompiled_code) {
                      addLog(
                        "INFO",
                        "GHIDRA",
                        `Using cached decompile for: ${cachedResult.function_name || offsetHex}`
                      );
                      onDecompileRequest(
                        modulePath,
                        offsetHex,
                        cachedResult.function_name || null,
                        cachedResult.decompiled_code,
                        moduleBase,
                        cachedResult.line_mapping || null,
                        cachedResult.tokens || null
                      );
                      return;
                    }

                    addLog(
                      "INFO",
                      "GHIDRA",
                      `Starting decompilation at offset: ${offsetHex}`
                    );

                    const result = await decompileFunction(
                      modulePath,
                      offsetHex,
                      savedGhidraPath
                    );

                    if (result?.success && result.decompiled_code) {
                      addLog(
                        "INFO",
                        "GHIDRA",
                        `Decompilation completed for: ${result.function_name || offsetHex}`
                      );

                      // Save to cache
                      await saveDecompileToCache(
                        osKey,
                        moduleName,
                        offsetHex,
                        result.function_name || "",
                        result.decompiled_code,
                        result.line_mapping
                      );

                      onDecompileRequest(
                        modulePath,
                        offsetHex,
                        result.function_name || null,
                        result.decompiled_code,
                        moduleBase,
                        result.line_mapping || null,
                        result.tokens || null
                      );
                    } else {
                      addLog(
                        "WARN",
                        "GHIDRA",
                        `Decompilation failed: ${result?.error || "Unknown error"}`
                      );
                    }
                  }
                }
              }
            }
            break;
          }
        }
      }
    }
  }, [
    onToggleDecompile,
    focusedLineAddress,
    isCurrentLibraryAnalyzed,
    onDecompileRequest,
    attachedModules,
    isLibraryAnalyzed,
    getModuleDetailText,
    instructionBuffer,
    serverInfo?.target_os,
    getDecompileFromCache,
    decompileFunction,
    saveDecompileToCache,
    addLog,
  ]);
  */

  return (
    <Box display="flex" flexDirection="column" height="100%">
      <DisassemblyHeader>
        <Box display="flex" alignItems="center" sx={{ flex: 1 }}>
          <DisassemblyTitle>
            <FunctionsIcon />
            {sourceCodeLevelDebug &&
            dwarfAnalysisResult?.source_files?.length > 0
              ? "Source"
              : "Assembly"}
          </DisassemblyTitle>
          {/* Source/ASM Toggle - only show when DWARF analysis has source files */}
          {dwarfAnalysisResult?.source_files?.length > 0 && (
            <Tooltip
              title={
                sourceCodeLevelDebug
                  ? "Switch to Assembly"
                  : "Switch to Source Code"
              }
              placement="top"
            >
              <Box
                onClick={toggleSourceCodeLevelDebug}
                sx={{
                  display: "flex",
                  alignItems: "center",
                  ml: 1.5,
                  px: 1,
                  py: 0.25,
                  fontSize: "10px",
                  fontWeight: 500,
                  cursor: "pointer",
                  color: sourceCodeLevelDebug ? "#4fc1ff" : "#808080",
                  backgroundColor: sourceCodeLevelDebug
                    ? "rgba(79, 193, 255, 0.15)"
                    : "#2d2d30",
                  borderRadius: 1,
                  transition: "all 0.15s ease",
                  "&:hover": { backgroundColor: "rgba(79, 193, 255, 0.25)" },
                }}
              >
                <CodeIcon sx={{ fontSize: 12, mr: 0.5 }} />
                {sourceCodeLevelDebug ? "Source" : "ASM"}
              </Box>
            </Tooltip>
          )}

          {/* Decompile icon hidden - use right-click context menu instead
          {!isDecompileVisible &&
            (hasDecompileResult || isCurrentLibraryAnalyzed) &&
            onToggleDecompile && (
              <Tooltip
                title={
                  hasDecompileResult
                    ? "Show Decompile View"
                    : "Show Decompile View (Library Analyzed)"
                }
                placement="top"
              >
                <IconButton
                  size="small"
                  onClick={handleDecompileIconClick}
                  sx={{
                    color: hasDecompileResult ? "#4fc1ff" : "#8bc34a",
                    "&:hover": { backgroundColor: "#2d2d30" },
                    ml: 2,
                  }}
                >
                  <DecompileIcon fontSize="small" />
                </IconButton>
              </Tooltip>
            )}
          */}

          {error && (
            <Box display="flex" alignItems="center" gap={1} sx={{ ml: 1 }}>
              <Typography variant="caption" color="error">
                {error}
              </Typography>
              <Tooltip title="Retry disassembly" placement="top">
                <IconButton
                  size="small"
                  onClick={() => {
                    const functionAddress =
                      useUIStore.getState().debuggerState.assemblyAddress;
                    if (functionAddress) {
                      const address = parseAddress(functionAddress);
                      loadDisassemblyAtAddress(address);
                    }
                  }}
                >
                  <RefreshIcon fontSize="small" />
                </IconButton>
              </Tooltip>
              <Tooltip title="Clear error" placement="top">
                <IconButton size="small" onClick={() => setError(null)}>
                  <ClearIcon fontSize="small" />
                </IconButton>
              </Tooltip>
            </Box>
          )}
        </Box>
        <DisassemblyActions>
          {/* Actions area - toggle moved to header */}
        </DisassemblyActions>
      </DisassemblyHeader>

      <DisassemblyContainer
        ref={containerRef}
        tabIndex={0}
        onWheel={handleWheelScroll}
      >
        <NavigationButtons>
          <Tooltip title="Scroll up (Page Up)" placement="left">
            <NavButton onClick={scrollUp} disabled={loading}>
              <ArrowUpIcon />
            </NavButton>
          </Tooltip>
          <Tooltip title="Scroll down (Page Down)" placement="left">
            <NavButton onClick={scrollDown} disabled={loading}>
              <ArrowDownIcon />
            </NavButton>
          </Tooltip>
        </NavigationButtons>

        <ScrollableContent>
          {sourceCodeLevelDebug ? (
            // Source Code View with VS Code-like tabs
            <Box
              sx={{
                height: "100%",
                display: "flex",
                flexDirection: "column",
                fontFamily: "monospace",
                fontSize: "12px",
              }}
            >
              {dwarfAnalysisResult?.source_files &&
              dwarfAnalysisResult.source_files.length > 0 ? (
                <Box
                  sx={{
                    flex: 1,
                    display: "flex",
                    flexDirection: "column",
                    overflow: "hidden",
                  }}
                >
                  {/* VS Code-like Tab Bar */}
                  <Box
                    sx={{
                      display: "flex",
                      backgroundColor: "#252526",
                      borderBottom: "1px solid #3c3c3c",
                      minHeight: "35px",
                      overflow: "hidden",
                    }}
                  >
                    {/* Tab list - scrollable horizontally */}
                    <Box
                      sx={{
                        display: "flex",
                        flex: 1,
                        overflowX: "auto",
                        overflowY: "hidden",
                        "&::-webkit-scrollbar": {
                          height: "4px",
                        },
                        "&::-webkit-scrollbar-thumb": {
                          backgroundColor: "#424242",
                          borderRadius: "2px",
                        },
                      }}
                    >
                      {openSourceTabs.map((tabPath) => {
                        const fileName =
                          tabPath.split(/[\/\\]/).pop() || tabPath;
                        const isActive = activeSourceTab === tabPath;
                        return (
                          <Box
                            key={tabPath}
                            onClick={() => setActiveSourceTab(tabPath)}
                            sx={{
                              display: "flex",
                              alignItems: "center",
                              gap: 0.5,
                              px: 1.5,
                              py: 0.5,
                              minWidth: "fit-content",
                              maxWidth: "180px",
                              cursor: "pointer",
                              backgroundColor: isActive
                                ? "#1e1e1e"
                                : "transparent",
                              borderRight: "1px solid #3c3c3c",
                              borderBottom: isActive
                                ? "1px solid #1e1e1e"
                                : "1px solid transparent",
                              marginBottom: isActive ? "-1px" : 0,
                              "&:hover": {
                                backgroundColor: isActive
                                  ? "#1e1e1e"
                                  : "#2d2d2d",
                              },
                              "&:hover .close-btn": {
                                opacity: 1,
                              },
                            }}
                          >
                            <FileIcon
                              sx={{
                                fontSize: 14,
                                color: "#4fc1ff",
                                flexShrink: 0,
                              }}
                            />
                            <Typography
                              sx={{
                                color: isActive ? "#ffffff" : "#969696",
                                fontSize: "11px",
                                overflow: "hidden",
                                textOverflow: "ellipsis",
                                whiteSpace: "nowrap",
                              }}
                              title={tabPath}
                            >
                              {fileName}
                            </Typography>
                            <IconButton
                              className="close-btn"
                              size="small"
                              onClick={(e) => {
                                e.stopPropagation();
                                closeSourceTab(tabPath);
                              }}
                              sx={{
                                p: 0.25,
                                ml: 0.5,
                                opacity: isActive ? 1 : 0,
                                color: "#808080",
                                "&:hover": {
                                  color: "#ffffff",
                                  backgroundColor: "rgba(255,255,255,0.1)",
                                },
                              }}
                            >
                              <CloseIcon sx={{ fontSize: 12 }} />
                            </IconButton>
                          </Box>
                        );
                      })}
                    </Box>
                    {/* Add file dropdown */}
                    {dwarfAnalysisResult.source_files.length >
                      openSourceTabs.length && (
                      <Box
                        sx={{
                          display: "flex",
                          alignItems: "center",
                          px: 1,
                          borderLeft: "1px solid #3c3c3c",
                        }}
                      >
                        <Tooltip title="Open file">
                          <IconButton
                            size="small"
                            onClick={() => {
                              // Open first non-opened file
                              const unopenedFile =
                                dwarfAnalysisResult.source_files.find(
                                  (f: any) => !openSourceTabs.includes(f.path)
                                );
                              if (unopenedFile) {
                                openSourceTab(
                                  unopenedFile.path,
                                  unopenedFile.directory
                                );
                              }
                            }}
                            sx={{ color: "#808080" }}
                          >
                            <RefreshIcon sx={{ fontSize: 14 }} />
                          </IconButton>
                        </Tooltip>
                      </Box>
                    )}
                  </Box>

                  {/* Active tab content */}
                  <Box
                    sx={{
                      flex: 1,
                      overflow: "auto",
                      backgroundColor: "#1e1e1e",
                    }}
                  >
                    {activeSourceTab ? (
                      (() => {
                        const file = dwarfAnalysisResult.source_files.find(
                          (f: any) => f.path === activeSourceTab
                        );
                        if (!file) return null;

                        const cached = sourceCodeCache.get(file.path);
                        const lineAddressMap = new Map<number, any>();

                        // Build line number to address mapping
                        if (file.lines) {
                          file.lines.forEach((lineInfo: any) => {
                            if (!lineAddressMap.has(lineInfo.line)) {
                              lineAddressMap.set(lineInfo.line, lineInfo);
                            }
                          });
                        }

                        return (
                          <Box sx={{ minHeight: "100%" }}>
                            {cached?.loading ? (
                              <Box sx={{ p: 2, textAlign: "center" }}>
                                <CircularProgress size={20} />
                                <Typography
                                  sx={{
                                    color: "#808080",
                                    mt: 1,
                                    fontSize: "11px",
                                  }}
                                >
                                  Loading source file...
                                </Typography>
                              </Box>
                            ) : cached?.error ? (
                              <Box sx={{ p: 2 }}>
                                <Typography
                                  sx={{ color: "#f48771", fontSize: "11px" }}
                                >
                                  {cached.error}
                                </Typography>
                                <Typography
                                  sx={{
                                    color: "#808080",
                                    fontSize: "10px",
                                    mt: 1,
                                  }}
                                >
                                  Check the source root path in Tools → DWARF
                                  tab.
                                </Typography>
                                <Button
                                  size="small"
                                  variant="outlined"
                                  onClick={() =>
                                    loadSourceFile(file.path, file.directory)
                                  }
                                  sx={{ mt: 1, fontSize: "10px" }}
                                >
                                  Retry
                                </Button>
                              </Box>
                            ) : cached &&
                              cached.lines &&
                              cached.lines.length > 0 ? (
                              cached.lines.map((codeLine, idx) => {
                                const lineNum = idx + 1;
                                const lineInfo = lineAddressMap.get(lineNum);
                                const canSetBreakpoint = !!lineInfo; // Can set BP only on lines with debug info

                                // Check if this line has a breakpoint
                                const breakpointForLine =
                                  sourceBreakpoints.find(
                                    (bp) =>
                                      bp.filePath === file.path &&
                                      bp.line === lineNum
                                  );
                                const hasBreakpoint =
                                  !!breakpointForLine &&
                                  breakpointForLine.enabled;

                                // Check if current execution is stopped at this line
                                const lineAddress = lineInfo
                                  ? (selectedModuleBase || 0) + lineInfo.address
                                  : null;
                                const isCurrentLine =
                                  lineAddress !== null &&
                                  currentHitAddress === lineAddress;

                                const handleBreakpointClick = async () => {
                                  if (
                                    !canSetBreakpoint ||
                                    !lineInfo ||
                                    !selectedModuleBase
                                  )
                                    return;

                                  const absoluteAddress =
                                    selectedModuleBase + lineInfo.address;

                                  try {
                                    const api = getApiClient();
                                    if (breakpointForLine) {
                                      // Remove existing breakpoint
                                      const result = await api.removeBreakpoint(
                                        {
                                          address: absoluteAddress,
                                        }
                                      );
                                      if (result.success) {
                                        removeSourceBreakpoint(
                                          file.path,
                                          lineNum
                                        );
                                        console.log(
                                          `[SourceView] Removed breakpoint at ${file.path}:${lineNum} (0x${absoluteAddress.toString(16)})`
                                        );
                                      } else {
                                        console.error(
                                          `[SourceView] Failed to remove breakpoint: ${result.message}`
                                        );
                                      }
                                    } else {
                                      // Add new breakpoint (hardware breakpoint)
                                      const result = await api.setBreakpoint({
                                        address: absoluteAddress,
                                        hit_count: 0, // 0 means permanent breakpoint
                                      });
                                      if (result.success) {
                                        addSourceBreakpoint({
                                          filePath: file.path,
                                          line: lineNum,
                                          address: absoluteAddress,
                                          moduleBase: selectedModuleBase,
                                          offset: lineInfo.address,
                                          enabled: true,
                                          isHit: false,
                                        });
                                        console.log(
                                          `[SourceView] Set breakpoint at ${file.path}:${lineNum} (0x${absoluteAddress.toString(16)})`
                                        );
                                      } else {
                                        console.error(
                                          `[SourceView] Failed to set breakpoint: ${result.message}`
                                        );
                                      }
                                    }
                                  } catch (err) {
                                    console.error(
                                      `[SourceView] Error setting/removing breakpoint:`,
                                      err
                                    );
                                  }
                                };

                                return (
                                  <Box
                                    key={idx}
                                    data-line-number={lineNum}
                                    sx={{
                                      display: "flex",
                                      alignItems: "flex-start",
                                      minHeight: "18px",
                                      lineHeight: "18px",
                                      backgroundColor: isCurrentLine
                                        ? "rgba(255, 204, 0, 0.2)"
                                        : hasBreakpoint
                                          ? "rgba(255, 68, 68, 0.1)"
                                          : "transparent",
                                      "&:hover": {
                                        backgroundColor: isCurrentLine
                                          ? "rgba(255, 204, 0, 0.25)"
                                          : "rgba(255, 255, 255, 0.04)",
                                      },
                                      "&:hover .bp-gutter": {
                                        opacity: canSetBreakpoint ? 1 : 0.3,
                                      },
                                    }}
                                  >
                                    {/* Breakpoint gutter */}
                                    <Box
                                      className="bp-gutter"
                                      onClick={handleBreakpointClick}
                                      sx={{
                                        minWidth: "20px",
                                        height: "18px",
                                        display: "flex",
                                        alignItems: "center",
                                        justifyContent: "center",
                                        cursor: canSetBreakpoint
                                          ? "pointer"
                                          : "default",
                                        opacity:
                                          hasBreakpoint || isCurrentLine
                                            ? 1
                                            : 0,
                                        transition: "opacity 0.1s",
                                        backgroundColor:
                                          canSetBreakpoint &&
                                          !hasBreakpoint &&
                                          !isCurrentLine
                                            ? "rgba(255, 68, 68, 0.1)"
                                            : "transparent",
                                        "&:hover":
                                          canSetBreakpoint && !hasBreakpoint
                                            ? {
                                                backgroundColor:
                                                  "rgba(255, 68, 68, 0.2)",
                                              }
                                            : {},
                                      }}
                                    >
                                      {hasBreakpoint && (
                                        <Box
                                          sx={{
                                            width: 10,
                                            height: 10,
                                            borderRadius: "50%",
                                            backgroundColor: isCurrentLine
                                              ? "#ff6666"
                                              : "#e51400",
                                            boxShadow:
                                              "0 0 2px rgba(0,0,0,0.5)",
                                          }}
                                        />
                                      )}
                                      {isCurrentLine && !hasBreakpoint && (
                                        <Box
                                          sx={{
                                            width: 0,
                                            height: 0,
                                            borderLeft: "8px solid #ffcc00",
                                            borderTop: "5px solid transparent",
                                            borderBottom:
                                              "5px solid transparent",
                                          }}
                                        />
                                      )}
                                    </Box>
                                    {/* Line number */}
                                    <Typography
                                      sx={{
                                        color: canSetBreakpoint
                                          ? "#c586c0"
                                          : "#5a5a5a",
                                        minWidth: "35px",
                                        textAlign: "right",
                                        pr: 1,
                                        fontSize: "11px",
                                        userSelect: "none",
                                        fontWeight: 400,
                                      }}
                                    >
                                      {lineNum}
                                    </Typography>
                                    {/* Source code with syntax highlighting */}
                                    <Box
                                      component="pre"
                                      sx={{
                                        fontSize: "11px",
                                        fontFamily: "monospace",
                                        m: 0,
                                        whiteSpace: "pre",
                                        flex: 1,
                                      }}
                                    >
                                      {highlightCCode(codeLine)}
                                    </Box>
                                  </Box>
                                );
                              })
                            ) : (
                              <Box sx={{ p: 2 }}>
                                <Typography
                                  sx={{ color: "#808080", fontSize: "11px" }}
                                >
                                  No content loaded yet.
                                </Typography>
                                <Button
                                  size="small"
                                  variant="outlined"
                                  onClick={() =>
                                    loadSourceFile(file.path, file.directory)
                                  }
                                  sx={{ mt: 1, fontSize: "10px" }}
                                >
                                  Load Source
                                </Button>
                              </Box>
                            )}
                          </Box>
                        );
                      })()
                    ) : (
                      <Box
                        sx={{
                          display: "flex",
                          flexDirection: "column",
                          alignItems: "center",
                          justifyContent: "center",
                          height: "100%",
                          color: "#808080",
                        }}
                      >
                        <FileIcon sx={{ fontSize: 48, opacity: 0.3, mb: 2 }} />
                        <Typography sx={{ fontSize: "12px" }}>
                          Select a file from the sidebar or open a tab
                        </Typography>
                      </Box>
                    )}
                  </Box>
                </Box>
              ) : (
                <Box
                  display="flex"
                  flexDirection="column"
                  alignItems="center"
                  justifyContent="center"
                  height="100%"
                  color="#858585"
                >
                  <CodeIcon sx={{ fontSize: "48px", mb: 2, opacity: 0.5 }} />
                  <Typography variant="body2" textAlign="center">
                    No DWARF source info available
                  </Typography>
                  <Typography
                    variant="caption"
                    color="#626262"
                    textAlign="center"
                    sx={{ mt: 1 }}
                  >
                    Analyze a module with DWARF debug info in the Tools → DWARF
                    tab
                  </Typography>
                </Box>
              )}
            </Box>
          ) : instructions.length > 0 ||
            (loading && previousInstructions.length > 0) ? (
            <AssemblyTableWrapper>
              <AssemblyTableContainer
                ref={tableContainerRef}
                onWheel={handleWheelScroll}
              >
                <AssemblyTable size="small" stickyHeader>
                  <TableHead>
                    <TableRow>
                      {/* Arrow Column Header */}
                      <TableCell
                        sx={{
                          width: `${ARROW_AREA_WIDTH}px`,
                          minWidth: `${ARROW_AREA_WIDTH}px`,
                          maxWidth: `${ARROW_AREA_WIDTH}px`,
                          padding: "4px !important",
                          backgroundColor: "#252526",
                          color: "#4fc1ff",
                          fontWeight: 600,
                          fontSize: "10px",
                          borderBottom: "none !important",
                          borderRight: "1px solid #2d2d30",
                        }}
                      ></TableCell>
                      <BreakpointTableCell
                        sx={{
                          width: `${columnResize.getColumnWidth("breakpoint")}px`,
                          minWidth: `${columnResize.getColumnWidth("breakpoint")}px`,
                          maxWidth: `${columnResize.getColumnWidth("breakpoint")}px`,
                          // Dim header in WASM mode
                          ...(isWasmMode && {
                            opacity: 0.5,
                            cursor: "not-allowed",
                          }),
                        }}
                        title={isWasmMode ? "Breakpoints not available in WASM mode" : "Breakpoint"}
                      >
                        BP
                        <ColumnResizer
                          onMouseDown={(e) =>
                            columnResize.handleResizeStart("breakpoint", e)
                          }
                          isResizing={
                            columnResize.resizingColumn === "breakpoint"
                          }
                        />
                      </BreakpointTableCell>
                      <AddressTableCell
                        sx={{
                          width: `${columnResize.getColumnWidth("address")}px`,
                          minWidth: `${columnResize.getColumnWidth("address")}px`,
                          maxWidth: `${columnResize.getColumnWidth("address")}px`,
                        }}
                      >
                        Address
                        <ColumnResizer
                          onMouseDown={(e) =>
                            columnResize.handleResizeStart("address", e)
                          }
                          isResizing={columnResize.resizingColumn === "address"}
                        />
                      </AddressTableCell>
                      <DetailTableCell
                        sx={{
                          width: `${columnResize.getColumnWidth("detail")}px`,
                          minWidth: `${columnResize.getColumnWidth("detail")}px`,
                          maxWidth: `${columnResize.getColumnWidth("detail")}px`,
                        }}
                      >
                        <Box
                          sx={{
                            display: "flex",
                            alignItems: "center",
                            gap: 0.5,
                          }}
                        >
                          Detail
                          <Tooltip
                            title={
                              addressDisplayFormat === "library"
                                ? "library + offset (click to switch to function)"
                                : "module@function + offset (click to switch to library)"
                            }
                          >
                            <IconButton
                              size="small"
                              onClick={toggleAddressDisplayFormat}
                              sx={{
                                padding: "2px",
                                color:
                                  addressDisplayFormat === "function"
                                    ? "#dcdcaa"
                                    : "#808080",
                                "&:hover": { color: "#fff" },
                              }}
                            >
                              <SwapHorizIcon sx={{ fontSize: 14 }} />
                            </IconButton>
                          </Tooltip>
                          <Tooltip
                            title={
                              assemblyDemangleEnabled
                                ? "Demangle ON (click to disable)"
                                : "Demangle OFF (click to enable)"
                            }
                          >
                            <IconButton
                              size="small"
                              onClick={toggleAssemblyDemangle}
                              sx={{
                                padding: "2px",
                                color: assemblyDemangleEnabled
                                  ? "#4ec9b0"
                                  : "#808080",
                                "&:hover": { color: "#fff" },
                              }}
                            >
                              <CodeIcon sx={{ fontSize: 14 }} />
                            </IconButton>
                          </Tooltip>
                        </Box>
                        <ColumnResizer
                          onMouseDown={(e) =>
                            columnResize.handleResizeStart("detail", e)
                          }
                          isResizing={columnResize.resizingColumn === "detail"}
                        />
                      </DetailTableCell>
                      <BytesTableCell
                        sx={{
                          width: `${columnResize.getColumnWidth("bytes")}px`,
                          minWidth: `${columnResize.getColumnWidth("bytes")}px`,
                          maxWidth: `${columnResize.getColumnWidth("bytes")}px`,
                        }}
                      >
                        Bytes
                        <ColumnResizer
                          onMouseDown={(e) =>
                            columnResize.handleResizeStart("bytes", e)
                          }
                          isResizing={columnResize.resizingColumn === "bytes"}
                        />
                      </BytesTableCell>
                      <InstructionTableCell>Instruction</InstructionTableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {(isTransitioning &&
                    previousInstructions.length > 0 &&
                    instructions.length === 0
                      ? previousInstructions
                      : instructions
                    ).map((instruction, index) => {
                      // Always update instruction breakpoint status from current breakpoints state
                      const updatedInstruction = {
                        ...instruction,
                        breakpoint: breakpoints.has(instruction.address),
                        isSoftwareBreakpoint: softwareBreakpoints.has(
                          instruction.address
                        ),
                      };

                      // Calculate arrow info for this row
                      const displayedInstructions =
                        isTransitioning &&
                        previousInstructions.length > 0 &&
                        instructions.length === 0
                          ? previousInstructions
                          : instructions;
                      const rowArrowInfo = calculateRowArrowInfo(
                        index,
                        branchArrows,
                        displayedInstructions.length
                      );

                      return (
                        <DisasmLineComponent
                          key={instruction.address} // Use address as key for better performance
                          instruction={updatedInstruction}
                          rowIndex={index}
                          rowArrowInfo={rowArrowInfo}
                          onAddressClick={(address, event) =>
                            handleAddressClick(address, event)
                          }
                          onDetailClick={(address, event) =>
                            handleInstructionAreaClick(address, event)
                          }
                          onBytesClick={(address, event) =>
                            handleInstructionAreaClick(address, event)
                          }
                          onInstructionClick={(address, event) =>
                            handleInstructionAreaClick(address, event)
                          }
                          onBreakpointClick={handleBreakpointClick}
                          onContextMenu={handleContextMenu}
                          currentBreakAddress={currentBreakAddress}
                          isFocused={focusedLineAddress === instruction.address}
                          onFocus={setFocusedLineAddress}
                          isInBreakState={isInBreakState}
                          isWasmMode={isWasmMode}
                          softwareBreakpointOriginalBytes={softwareBreakpoints.get(
                            instruction.address
                          )}
                          getModuleDetail={getModuleDetail}
                          getModuleDetailText={getModuleDetailText}
                          getFormattedComment={getFormattedComment}
                          getBranchTargetAddress={getBranchTargetAddress}
                          onCommentClick={(address) => {
                            setAssemblyAddressWithHistory(address);
                            // Also trigger decompile for the target function if available
                            syncDecompileView(address);
                          }}
                          columnWidths={columnResize.columnWidths}
                        />
                      );
                    })}
                  </TableBody>
                </AssemblyTable>
              </AssemblyTableContainer>
            </AssemblyTableWrapper>
          ) : (
            <Box
              display="flex"
              flexDirection="column"
              alignItems="center"
              justifyContent="center"
              height="100%"
              color="#858585"
              fontSize="14px"
            >
              <FunctionsIcon sx={{ fontSize: "48px", mb: 2, opacity: 0.5 }} />
              <Typography variant="body2" color="inherit" textAlign="center">
                {loading
                  ? "Loading disassembly..."
                  : error
                    ? "Failed to load disassembly"
                    : !useUIStore.getState().debuggerState.assemblyAddress
                      ? "Select a function to view disassembly"
                      : "No instructions available"}
              </Typography>
              {!loading &&
                !error &&
                !useUIStore.getState().debuggerState.assemblyAddress && (
                  <Typography
                    variant="caption"
                    color="#626262"
                    textAlign="center"
                    sx={{ mt: 1 }}
                  >
                    Choose a function from the sidebar to start debugging
                  </Typography>
                )}
            </Box>
          )}
        </ScrollableContent>
      </DisassemblyContainer>

      {/* Context Menu */}
      <Menu
        open={contextMenu !== null}
        onClose={handleContextMenuClose}
        anchorReference="anchorPosition"
        anchorPosition={
          contextMenu !== null
            ? { top: contextMenu.mouseY, left: contextMenu.mouseX }
            : undefined
        }
        sx={{
          "& .MuiPaper-root": {
            backgroundColor: "#252526",
            border: "1px solid #3c3c3c",
            minWidth: "180px",
          },
          "& .MuiMenuItem-root": {
            fontSize: "12px",
            color: "#d4d4d4",
            "&:hover": {
              backgroundColor: "#094771",
            },
          },
          "& .MuiListItemIcon-root": {
            color: "#858585",
            minWidth: "32px",
          },
        }}
      >
        <MenuItem onClick={handleCopyAddress}>
          <ListItemIcon>
            <CopyIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText>Copy Address</ListItemText>
        </MenuItem>
        <MenuItem onClick={handleCopyAddressWithOffset}>
          <ListItemIcon>
            <CopyIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText>Copy Address (Module + offset)</ListItemText>
        </MenuItem>
        <MenuItem onClick={handleCopyInstruction}>
          <ListItemIcon>
            <CopyIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText>Copy Instruction</ListItemText>
        </MenuItem>
        <MenuItem onClick={handleCopyBytecode}>
          <ListItemIcon>
            <CopyIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText>Copy Bytes</ListItemText>
        </MenuItem>
        <Divider sx={{ borderColor: "#3c3c3c" }} />
        {getContextMenuFunctionBounds() && [
          <MenuItem key="func-start" onClick={handleGoToFunctionStart}>
            <ListItemIcon>
              <FunctionStartIcon fontSize="small" sx={{ color: "#4caf50" }} />
            </ListItemIcon>
            <ListItemText>Go to Function Start</ListItemText>
          </MenuItem>,
          <MenuItem key="func-end" onClick={handleGoToFunctionEnd}>
            <ListItemIcon>
              <FunctionEndIcon fontSize="small" sx={{ color: "#ff9800" }} />
            </ListItemIcon>
            <ListItemText>Go to Function End</ListItemText>
          </MenuItem>,
          <Divider key="func-divider" sx={{ borderColor: "#3c3c3c" }} />,
        ]}
        {/* Breakpoint and NOP - hide in WASM mode (not supported) */}
        {!isWasmMode && (
          <MenuItem
            onClick={() => {
              if (contextMenu) {
                toggleBreakpoint(contextMenu.address);
              }
              handleContextMenuClose();
            }}
          >
            <ListItemIcon>
              <BreakpointIcon fontSize="small" sx={{ color: "#ff4444" }} />
            </ListItemIcon>
            <ListItemText>
              {contextMenu && breakpoints.has(contextMenu.address)
                ? "Remove Breakpoint"
                : "Set Breakpoint"}
            </ListItemText>
          </MenuItem>
        )}
        {!isWasmMode && (
          <MenuItem onClick={handleReplaceWithNop}>
            <ListItemIcon>
              <NopIcon fontSize="small" sx={{ color: "#ffa726" }} />
            </ListItemIcon>
            <ListItemText>Replace with NOP</ListItemText>
          </MenuItem>
        )}
        <Divider sx={{ borderColor: "#3c3c3c" }} />
        {/* Code Tracing menu item - enabled for iOS */}
        {serverInfo?.target_os === "ios" && (
          <MenuItem onClick={handleStartCodeTracing}>
            <ListItemIcon>
              <TimelineIcon fontSize="small" sx={{ color: "#4caf50" }} />
            </ListItemIcon>
            <ListItemText>Code Tracing</ListItemText>
          </MenuItem>
        )}
        <MenuItem onClick={handleOpenGraphView}>
          <ListItemIcon>
            <GraphIcon fontSize="small" sx={{ color: "#9c27b0" }} />
          </ListItemIcon>
          <ListItemText>Graph View</ListItemText>
        </MenuItem>
        {/* Ghidra Integration - only show when library is analyzed and inside a function */}
        {contextMenuHasLibrary &&
          contextMenuLibraryAnalyzed &&
          getContextMenuFunctionBounds() !== null && [
            <Divider key="ghidra-divider" sx={{ borderColor: "#3c3c3c" }} />,
            <MenuItem
              key="ghidra-decompile"
              onClick={handleDecompileWithGhidra}
              disabled={isDecompiling}
            >
              <ListItemIcon>
                {isDecompiling ? (
                  <CircularProgress size={16} sx={{ color: "#4fc1ff" }} />
                ) : (
                  <DecompileIcon fontSize="small" sx={{ color: "#4fc1ff" }} />
                )}
              </ListItemIcon>
              <ListItemText>
                {isDecompiling ? "Decompiling..." : "Decompile"}
              </ListItemText>
            </MenuItem>,
            <MenuItem
              key="ghidra-xrefs"
              onClick={handleGetXrefs}
              disabled={xrefLoading}
            >
              <ListItemIcon>
                {xrefLoading ? (
                  <CircularProgress size={16} sx={{ color: "#c586c0" }} />
                ) : (
                  <CallReceivedIcon
                    fontSize="small"
                    sx={{ color: "#c586c0" }}
                  />
                )}
              </ListItemIcon>
              <ListItemText>
                {xrefLoading
                  ? "Finding References..."
                  : "Find References to This Function"}
              </ListItemText>
            </MenuItem>,
          ]}
      </Menu>

      {/* Trace Count Dialog */}
      <Dialog
        open={traceCountDialogOpen}
        onClose={() => setTraceCountDialogOpen(false)}
        PaperProps={{
          sx: {
            backgroundColor: "#252526",
            border: "1px solid #3c3c3c",
            minWidth: "350px",
          },
        }}
      >
        <DialogTitle sx={{ color: "#4fc1ff", fontSize: "14px", pb: 1 }}>
          Code Tracing
        </DialogTitle>
        <DialogContent>
          <Typography
            variant="body2"
            sx={{ color: "#d4d4d4", mb: 2, fontSize: "12px" }}
          >
            Trace execution at address:{" "}
            <span style={{ color: "#4fc1ff" }}>{pendingTraceAddress}</span>
          </Typography>
          <TextField
            autoFocus
            label="Max count (stop after N hits)"
            type="number"
            fullWidth
            size="small"
            value={traceCountInput}
            onChange={(e) => setTraceCountInput(e.target.value)}
            inputProps={{ min: 1, max: 100000 }}
            sx={{
              mb: 2,
              "& .MuiInputBase-input": {
                color: "#d4d4d4",
              },
              "& .MuiInputLabel-root": {
                color: "#858585",
              },
              "& .MuiOutlinedInput-root": {
                "& fieldset": { borderColor: "#3c3c3c" },
                "&:hover fieldset": { borderColor: "#4fc1ff" },
                "&.Mui-focused fieldset": { borderColor: "#4fc1ff" },
              },
            }}
          />
          <TextField
            label="End address (optional, e.g. 0x12345678)"
            fullWidth
            size="small"
            value={traceEndAddressInput}
            onChange={(e) => setTraceEndAddressInput(e.target.value)}
            placeholder="Leave empty to trace until max count"
            sx={{
              mb: 2,
              "& .MuiInputBase-input": {
                color: "#d4d4d4",
                fontFamily: 'Consolas, "Courier New", monospace',
              },
              "& .MuiInputLabel-root": {
                color: "#858585",
              },
              "& .MuiOutlinedInput-root": {
                "& fieldset": { borderColor: "#3c3c3c" },
                "&:hover fieldset": { borderColor: "#4fc1ff" },
                "&.Mui-focused fieldset": { borderColor: "#4fc1ff" },
              },
            }}
          />
          <FormControlLabel
            control={
              <Checkbox
                checked={traceToFile}
                onChange={(e) => setTraceToFile(e.target.checked)}
                sx={{
                  color: "#858585",
                  "&.Mui-checked": { color: "#4fc1ff" },
                }}
              />
            }
            label={
              <Typography sx={{ color: "#d4d4d4", fontSize: "12px" }}>
                Save to file (includes x0-x5 memory dumps)
              </Typography>
            }
          />
          {traceToFile && (
            <Typography
              variant="caption"
              sx={{ color: "#858585", display: "block", ml: 4, mt: 0.5 }}
            >
              Trace will be saved on server. Download after completion.
            </Typography>
          )}
          <Divider sx={{ my: 2, borderColor: "#3c3c3c" }} />
          <Button
            size="small"
            onClick={async () => {
              setTraceCountDialogOpen(false);
              try {
                // Use Rust-side file dialog
                const filePath = await invoke<string | null>(
                  "open_trace_file_dialog"
                );
                if (!filePath) {
                  return; // User cancelled
                }

                // Open CodeTracingWindow with file path (localFilePath mode)
                openCodeTracingWindow("0x0", 0, false, filePath);
                addLog("INFO", "TRACING", `Loading trace file: ${filePath}`);
              } catch (err) {
                console.error("Failed to open trace file dialog:", err);
                addLog(
                  "ERROR",
                  "TRACING",
                  `Failed to open trace file dialog: ${err}`
                );
              }
            }}
            sx={{
              color: "#9cdcfe",
              fontSize: "11px",
              textTransform: "none",
            }}
          >
            Load from trace file...
          </Button>
        </DialogContent>
        <DialogActions sx={{ px: 3, pb: 2 }}>
          <Button
            onClick={() => setTraceCountDialogOpen(false)}
            sx={{ color: "#858585" }}
          >
            Cancel
          </Button>
          <Button
            onClick={handleExecuteCodeTracing}
            variant="contained"
            sx={{
              backgroundColor: "#0e639c",
              "&:hover": { backgroundColor: "#1177bb" },
            }}
          >
            Start Trace
          </Button>
        </DialogActions>
      </Dialog>

      {/* Graph View Address Range Dialog */}
      <Dialog
        open={graphViewDialogOpen}
        onClose={() => setGraphViewDialogOpen(false)}
        PaperProps={{
          sx: {
            backgroundColor: "#252526",
            border: "1px solid #3c3c3c",
            minWidth: "400px",
          },
        }}
      >
        <DialogTitle sx={{ color: "#4fc1ff", fontSize: "14px", pb: 1 }}>
          Graph View - Address Range
        </DialogTitle>
        <DialogContent>
          {pendingGraphViewFunctionName && (
            <Typography
              variant="body2"
              sx={{
                color: "#dcdcaa",
                mb: 1,
                fontSize: "12px",
                fontFamily: 'Consolas, "Courier New", monospace',
              }}
            >
              Function: {pendingGraphViewFunctionName}
            </Typography>
          )}
          <Typography
            variant="body2"
            sx={{ color: "#808080", mb: 2, fontSize: "11px" }}
          >
            Specify the address range for CFG generation. The range is
            automatically detected from function boundaries.
          </Typography>
          <TextField
            autoFocus
            label="Start Address"
            type="text"
            fullWidth
            size="small"
            value={graphViewStartAddress}
            onChange={(e) => setGraphViewStartAddress(e.target.value)}
            placeholder="0x..."
            sx={{
              mb: 2,
              "& .MuiInputBase-input": {
                color: "#d4d4d4",
                fontFamily: 'Consolas, "Courier New", monospace',
              },
              "& .MuiInputLabel-root": {
                color: "#858585",
              },
              "& .MuiOutlinedInput-root": {
                "& fieldset": { borderColor: "#3c3c3c" },
                "&:hover fieldset": { borderColor: "#4fc1ff" },
                "&.Mui-focused fieldset": { borderColor: "#4fc1ff" },
              },
            }}
          />
          <TextField
            label="End Address"
            type="text"
            fullWidth
            size="small"
            value={graphViewEndAddress}
            onChange={(e) => setGraphViewEndAddress(e.target.value)}
            placeholder="0x..."
            sx={{
              "& .MuiInputBase-input": {
                color: "#d4d4d4",
                fontFamily: 'Consolas, "Courier New", monospace',
              },
              "& .MuiInputLabel-root": {
                color: "#858585",
              },
              "& .MuiOutlinedInput-root": {
                "& fieldset": { borderColor: "#3c3c3c" },
                "&:hover fieldset": { borderColor: "#4fc1ff" },
                "&.Mui-focused fieldset": { borderColor: "#4fc1ff" },
              },
            }}
          />
        </DialogContent>
        <DialogActions sx={{ px: 3, pb: 2 }}>
          <Button
            onClick={() => setGraphViewDialogOpen(false)}
            sx={{ color: "#858585" }}
          >
            Cancel
          </Button>
          <Button
            onClick={handleExecuteGraphView}
            variant="contained"
            sx={{
              backgroundColor: "#0e639c",
              "&:hover": { backgroundColor: "#1177bb" },
            }}
          >
            Open Graph View
          </Button>
        </DialogActions>
      </Dialog>

      {/* Ghidra Settings Dialog */}
      <Dialog
        open={ghidraSettingsDialogOpen}
        onClose={() => {
          setGhidraSettingsDialogOpen(false);
          setPendingGhidraAction(null);
          setPendingGhidraLibraryInfo(null);
          setPendingGhidraAddress(null);
        }}
        PaperProps={{
          sx: {
            backgroundColor: "#252526",
            border: "1px solid #3c3c3c",
            minWidth: "500px",
          },
        }}
      >
        <DialogTitle sx={{ color: "#4fc1ff", fontSize: "14px", pb: 1 }}>
          Ghidra Configuration
        </DialogTitle>
        <DialogContent>
          <Typography
            variant="body2"
            sx={{ color: "#808080", mb: 2, fontSize: "11px" }}
          >
            Configure the path to your Ghidra installation directory. Example:
            C:\ghidra_11.0 or /opt/ghidra
          </Typography>
          <TextField
            autoFocus
            label="Ghidra Installation Path"
            type="text"
            fullWidth
            size="small"
            value={ghidraPathInput}
            onChange={(e) => setGhidraPathInput(e.target.value)}
            placeholder="C:\ghidra_11.0 or /opt/ghidra"
            sx={{
              "& .MuiInputBase-input": {
                color: "#d4d4d4",
                fontFamily: 'Consolas, "Courier New", monospace',
              },
              "& .MuiInputLabel-root": {
                color: "#858585",
              },
              "& .MuiOutlinedInput-root": {
                "& fieldset": { borderColor: "#3c3c3c" },
                "&:hover fieldset": { borderColor: "#4fc1ff" },
                "&.Mui-focused fieldset": { borderColor: "#4fc1ff" },
              },
            }}
          />
          {isAnalyzing && (
            <Box sx={{ mt: 2, display: "flex", alignItems: "center", gap: 1 }}>
              <CircularProgress size={16} sx={{ color: "#ff7043" }} />
              <Typography
                variant="body2"
                sx={{ color: "#d4d4d4", fontSize: "11px" }}
              >
                {analysisProgress}
              </Typography>
            </Box>
          )}
        </DialogContent>
        <DialogActions sx={{ px: 3, pb: 2 }}>
          <Button
            onClick={() => {
              setGhidraSettingsDialogOpen(false);
              setPendingGhidraAction(null);
              setPendingGhidraLibraryInfo(null);
              setPendingGhidraAddress(null);
            }}
            sx={{ color: "#858585" }}
          >
            Cancel
          </Button>
          <Button
            onClick={handleSaveGhidraSettings}
            variant="contained"
            disabled={!ghidraPathInput}
            sx={{
              backgroundColor: "#0e639c",
              "&:hover": { backgroundColor: "#1177bb" },
            }}
          >
            {pendingGhidraAction === "analyze"
              ? "Analyze"
              : pendingGhidraAction === "decompile"
                ? "Decompile"
                : "Run"}
          </Button>
        </DialogActions>
      </Dialog>

      {/* Xref Dialog */}
      <Dialog
        open={xrefDialogOpen}
        onClose={() => setXrefDialogOpen(false)}
        maxWidth="md"
        fullWidth
        PaperProps={{
          sx: {
            backgroundColor: "#252526",
            border: "1px solid #3c3c3c",
            maxHeight: "70vh",
          },
        }}
      >
        <DialogTitle
          sx={{
            color: "#cccccc",
            fontSize: "14px",
            display: "flex",
            alignItems: "center",
            gap: 1,
            borderBottom: "1px solid #3c3c3c",
          }}
        >
          <CallReceivedIcon sx={{ color: "#c586c0" }} />
          Cross References to{" "}
          <span style={{ color: "#dcdcaa" }}>
            {xrefData?.targetFunction || "..."}
          </span>
        </DialogTitle>
        <DialogContent sx={{ p: 0 }}>
          {xrefLoading ? (
            <Box
              sx={{
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                py: 4,
              }}
            >
              <CircularProgress size={24} sx={{ color: "#c586c0" }} />
              <Typography sx={{ ml: 2, color: "#858585" }}>
                Loading xrefs...
              </Typography>
            </Box>
          ) : xrefData === null ? (
            <Box sx={{ py: 4, textAlign: "center" }}>
              <Typography sx={{ color: "#858585" }}>Preparing...</Typography>
            </Box>
          ) : xrefData && xrefData.xrefs.length > 0 ? (
            <Table size="small" sx={{ fontFamily: "Consolas, monospace" }}>
              <TableHead>
                <TableRow>
                  <TableCell
                    sx={{
                      color: "#569cd6",
                      borderBottom: "1px solid #3c3c3c",
                      fontSize: "12px",
                      fontWeight: "bold",
                    }}
                  >
                    From Address
                  </TableCell>
                  <TableCell
                    sx={{
                      color: "#569cd6",
                      borderBottom: "1px solid #3c3c3c",
                      fontSize: "12px",
                      fontWeight: "bold",
                    }}
                  >
                    From Function
                  </TableCell>
                  <TableCell
                    sx={{
                      color: "#569cd6",
                      borderBottom: "1px solid #3c3c3c",
                      fontSize: "12px",
                      fontWeight: "bold",
                    }}
                  >
                    Type
                  </TableCell>
                  <TableCell
                    sx={{
                      color: "#569cd6",
                      borderBottom: "1px solid #3c3c3c",
                      fontSize: "12px",
                      fontWeight: "bold",
                    }}
                  >
                    Instruction
                  </TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {xrefData.xrefs.map((xref, index) => {
                  // Convert offset to real memory address
                  const offset = parseInt(xref.from_address, 16);
                  const realAddress = !isNaN(offset)
                    ? xrefData.moduleBase + offset
                    : 0;
                  const realAddressHex = `0x${realAddress.toString(16)}`;

                  return (
                    <TableRow
                      key={index}
                      sx={{
                        "&:hover": {
                          backgroundColor: "rgba(255,255,255,0.05)",
                        },
                        cursor: "pointer",
                      }}
                      onClick={() => {
                        // Jump to the real memory address (with history for Back button)
                        if (realAddress > 0) {
                          setAssemblyAddressWithHistory(realAddressHex);
                          setXrefDialogOpen(false);
                          addLog(
                            "INFO",
                            "XREF",
                            `Navigating to: ${realAddressHex} (${xref.from_function || "unknown"})`
                          );
                        } else {
                          addLog(
                            "INFO",
                            "XREF",
                            `Address: ${realAddressHex} (${xref.from_function || "unknown"})`
                          );
                        }
                      }}
                    >
                      <TableCell
                        sx={{
                          color: "#b5cea8",
                          borderBottom: "1px solid #2d2d2d",
                          fontSize: "11px",
                          fontFamily: "Consolas, monospace",
                        }}
                      >
                        {realAddressHex}
                      </TableCell>
                      <TableCell
                        sx={{
                          color: "#dcdcaa",
                          borderBottom: "1px solid #2d2d2d",
                          fontSize: "11px",
                          fontFamily: "Consolas, monospace",
                          maxWidth: "300px",
                          overflow: "hidden",
                          textOverflow: "ellipsis",
                          whiteSpace: "nowrap",
                        }}
                        title={
                          xref.from_function
                            ? `${xrefData.moduleName}@${xref.from_function}+${xref.from_function_offset || xref.from_address}`
                            : `${xrefData.moduleName}+${xref.from_address}`
                        }
                      >
                        {(() => {
                          // Truncate template arguments for readability
                          const simplify = (name: string) => {
                            let result = name;
                            let depth = 0;
                            let start = -1;
                            for (let i = 0; i < result.length; i++) {
                              if (result[i] === "<") {
                                if (depth === 0) start = i;
                                depth++;
                              } else if (result[i] === ">") {
                                depth--;
                                if (depth === 0 && start !== -1) {
                                  result =
                                    result.substring(0, start + 1) +
                                    "..." +
                                    result.substring(i);
                                  i = start + 4;
                                  start = -1;
                                }
                              }
                            }
                            return result;
                          };
                          const funcName = xref.from_function
                            ? simplify(xref.from_function)
                            : null;
                          // Use from_function_offset (offset within function) when available,
                          // otherwise fall back to from_address (module offset)
                          const offsetStr =
                            funcName && xref.from_function_offset
                              ? xref.from_function_offset
                              : xref.from_address;
                          return funcName
                            ? `${xrefData.moduleName}@${funcName}+${offsetStr}`
                            : `${xrefData.moduleName}+${xref.from_address}`;
                        })()}
                      </TableCell>
                      <TableCell
                        sx={{
                          color: "#9cdcfe",
                          borderBottom: "1px solid #2d2d2d",
                          fontSize: "11px",
                          fontFamily: "Consolas, monospace",
                        }}
                      >
                        {xref.ref_type}
                      </TableCell>
                      <TableCell
                        sx={{
                          color: "#ce9178",
                          borderBottom: "1px solid #2d2d2d",
                          fontSize: "11px",
                          fontFamily: "Consolas, monospace",
                        }}
                      >
                        {xref.instruction || "-"}
                      </TableCell>
                    </TableRow>
                  );
                })}
              </TableBody>
            </Table>
          ) : (
            <Box sx={{ py: 4, textAlign: "center" }}>
              <Typography sx={{ color: "#858585" }}>
                No cross references found
              </Typography>
            </Box>
          )}
        </DialogContent>
        <DialogActions sx={{ px: 3, py: 1.5, borderTop: "1px solid #3c3c3c" }}>
          <Typography
            variant="body2"
            sx={{ color: "#858585", fontSize: "11px", mr: "auto" }}
          >
            {xrefData ? `${xrefData.xrefs.length} reference(s) found` : ""}
          </Typography>
          <Button
            onClick={() => setXrefDialogOpen(false)}
            sx={{ color: "#858585" }}
          >
            Close
          </Button>
        </DialogActions>
      </Dialog>

      {/* Debugger Settings Dialog */}
      <Dialog
        open={debuggerSettingsOpen}
        onClose={() => setDebuggerSettingsOpen(false)}
        maxWidth="sm"
        fullWidth
        PaperProps={{
          sx: {
            backgroundColor: "#1e1e1e",
            color: "#d4d4d4",
            border: "1px solid #3c3c3c",
          },
        }}
      >
        <DialogTitle
          sx={{
            borderBottom: "1px solid #3c3c3c",
            display: "flex",
            alignItems: "center",
            gap: 1,
          }}
        >
          <SettingsIcon sx={{ fontSize: 20 }} />
          Debugger Settings
        </DialogTitle>
        <DialogContent sx={{ pt: 3 }}>
          <Typography
            variant="subtitle2"
            sx={{ color: "#858585", mt: 1, mb: 3 }}
          >
            Configure signal handling (like GDB's handle command):
            <br />• <strong>Catch</strong>: Stop debugger when signal occurs
            <br />• <strong>Pass</strong>: Deliver signal to process on continue
            <br />
            <em style={{ fontSize: "0.85em" }}>
              Default: Catch=OFF, Pass=OFF (signals suppressed silently, like
              GDB)
            </em>
          </Typography>
          {loadingSignals ? (
            <Box sx={{ display: "flex", justifyContent: "center", py: 3 }}>
              <CircularProgress size={24} sx={{ color: "#4fc1ff" }} />
            </Box>
          ) : (
            <Table size="small">
              <TableHead>
                <TableRow>
                  <TableCell
                    padding="checkbox"
                    sx={{ color: "#858585", borderBottom: "1px solid #3c3c3c" }}
                  >
                    Catch
                  </TableCell>
                  <TableCell
                    padding="checkbox"
                    sx={{ color: "#858585", borderBottom: "1px solid #3c3c3c" }}
                  >
                    Pass
                  </TableCell>
                  <TableCell
                    sx={{
                      color: "#858585",
                      borderBottom: "1px solid #3c3c3c",
                      cursor: "pointer",
                    }}
                  >
                    <TableSortLabel
                      active={signalSortField === "signal"}
                      direction={
                        signalSortField === "signal" ? signalSortOrder : "asc"
                      }
                      onClick={() => handleSignalSortChange("signal")}
                      sx={{
                        color: "#858585 !important",
                        "&.Mui-active": { color: "#4fc1ff !important" },
                        "& .MuiTableSortLabel-icon": {
                          color: "#4fc1ff !important",
                        },
                      }}
                    >
                      Signal #
                    </TableSortLabel>
                  </TableCell>
                  <TableCell
                    sx={{
                      color: "#858585",
                      borderBottom: "1px solid #3c3c3c",
                      cursor: "pointer",
                    }}
                  >
                    <TableSortLabel
                      active={signalSortField === "name"}
                      direction={
                        signalSortField === "name" ? signalSortOrder : "asc"
                      }
                      onClick={() => handleSignalSortChange("name")}
                      sx={{
                        color: "#858585 !important",
                        "&.Mui-active": { color: "#4fc1ff !important" },
                        "& .MuiTableSortLabel-icon": {
                          color: "#4fc1ff !important",
                        },
                      }}
                    >
                      Name
                    </TableSortLabel>
                  </TableCell>
                  <TableCell
                    sx={{ color: "#858585", borderBottom: "1px solid #3c3c3c" }}
                  >
                    Description
                  </TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {signalDefinitions.map((sig) => {
                  const config = getSignalConfig(sig.signal);
                  return (
                    <TableRow
                      key={sig.signal}
                      hover
                      sx={{
                        "&:hover": {
                          backgroundColor: "rgba(255, 255, 255, 0.05)",
                        },
                      }}
                    >
                      <TableCell
                        padding="checkbox"
                        sx={{ borderBottom: "1px solid #2d2d2d" }}
                      >
                        <Checkbox
                          checked={config.catch_signal}
                          onChange={() => handleToggleSignalCatch(sig.signal)}
                          size="small"
                          sx={{
                            color: "#858585",
                            "&.Mui-checked": {
                              color: "#4fc1ff",
                            },
                          }}
                        />
                      </TableCell>
                      <TableCell
                        padding="checkbox"
                        sx={{ borderBottom: "1px solid #2d2d2d" }}
                      >
                        <Checkbox
                          checked={config.pass_signal}
                          onChange={() => handleToggleSignalPass(sig.signal)}
                          size="small"
                          sx={{
                            color: "#858585",
                            "&.Mui-checked": {
                              color: "#ce9178",
                            },
                          }}
                        />
                      </TableCell>
                      <TableCell
                        sx={{
                          color: "#d4d4d4",
                          fontFamily: "monospace",
                          borderBottom: "1px solid #2d2d2d",
                        }}
                      >
                        {sig.signal}
                      </TableCell>
                      <TableCell
                        sx={{
                          color: "#4fc1ff",
                          fontFamily: "monospace",
                          fontWeight: 500,
                          borderBottom: "1px solid #2d2d2d",
                        }}
                      >
                        {sig.name}
                      </TableCell>
                      <TableCell
                        sx={{
                          color: "#858585",
                          borderBottom: "1px solid #2d2d2d",
                        }}
                      >
                        {sig.description}
                      </TableCell>
                    </TableRow>
                  );
                })}
              </TableBody>
            </Table>
          )}
        </DialogContent>
        <DialogActions sx={{ borderTop: "1px solid #3c3c3c", p: 2 }}>
          <Button
            onClick={() => setDebuggerSettingsOpen(false)}
            sx={{ color: "#858585" }}
          >
            Close
          </Button>
        </DialogActions>
      </Dialog>

      {/* File Trace Progress Snackbar */}
      <Snackbar
        open={fileTraceProgress?.isActive ?? false}
        anchorOrigin={{ vertical: "bottom", horizontal: "right" }}
      >
        <Alert
          severity="info"
          icon={<CircularProgress size={20} sx={{ color: "#4fc1ff" }} />}
          sx={{
            backgroundColor: "#2d2d30",
            color: "#d4d4d4",
            border: "1px solid #4fc1ff",
            minWidth: "300px",
            "& .MuiAlert-icon": {
              alignItems: "center",
            },
          }}
        >
          <Box>
            <Typography variant="body2" sx={{ fontWeight: "bold", mb: 0.5 }}>
              File Trace in Progress
            </Typography>
            <Typography variant="body2">
              {fileTraceProgress?.current ?? 0} /{" "}
              {fileTraceProgress?.total ?? 0} instructions
            </Typography>
            <Box
              sx={{
                width: "100%",
                height: 4,
                backgroundColor: "#3c3c3c",
                borderRadius: 2,
                mt: 1,
                overflow: "hidden",
              }}
            >
              <Box
                sx={{
                  width: `${((fileTraceProgress?.current ?? 0) / (fileTraceProgress?.total || 1)) * 100}%`,
                  height: "100%",
                  backgroundColor: "#4fc1ff",
                  transition: "width 0.2s ease",
                }}
              />
            </Box>
          </Box>
        </Alert>
      </Snackbar>

      {/* File Trace Complete Dialog */}
      <Dialog
        open={fileTraceCompleteDialog.open}
        onClose={() =>
          setFileTraceCompleteDialog({
            open: false,
            entryCount: 0,
            filePath: "",
            downloaded: false,
          })
        }
        PaperProps={{
          sx: {
            backgroundColor: "#252526",
            border: "1px solid #3c3c3c",
            minWidth: "450px",
          },
        }}
      >
        <DialogTitle
          sx={{
            color: "#4caf50",
            fontSize: "14px",
            pb: 1,
            display: "flex",
            alignItems: "center",
            gap: 1,
          }}
        >
          <CheckCircleOutlineIcon sx={{ color: "#4caf50" }} />
          File Trace Complete
        </DialogTitle>
        <DialogContent>
          <Typography variant="body2" sx={{ color: "#d4d4d4", mb: 2 }}>
            Trace completed successfully with{" "}
            <strong>{fileTraceCompleteDialog.entryCount}</strong> instructions.
          </Typography>
          <Box
            sx={{
              backgroundColor: "#1e1e1e",
              padding: "12px",
              borderRadius: "4px",
              border: "1px solid #3c3c3c",
            }}
          >
            <Typography
              variant="caption"
              sx={{ color: "#858585", display: "block", mb: 0.5 }}
            >
              {fileTraceCompleteDialog.downloaded
                ? "Downloaded to host:"
                : "File Location (on server/device):"}
            </Typography>
            <Typography
              variant="body2"
              sx={{
                color: "#9cdcfe",
                fontFamily: 'Consolas, "Courier New", monospace',
                wordBreak: "break-all",
              }}
            >
              {fileTraceCompleteDialog.filePath}
            </Typography>
          </Box>
        </DialogContent>
        <DialogActions sx={{ px: 3, pb: 2, gap: 1 }}>
          <Button
            onClick={() =>
              setFileTraceCompleteDialog({
                open: false,
                entryCount: 0,
                filePath: "",
                downloaded: false,
              })
            }
            sx={{ color: "#858585" }}
          >
            Close
          </Button>
          {!fileTraceCompleteDialog.downloaded && (
            <Button
              onClick={async () => {
                // Download file to host PC using browser download
                try {
                  const api = getApiClient();
                  const blob = await api.downloadTraceFile();

                  const fileName = `trace_${Date.now()}.dyntrace`;
                  const url = URL.createObjectURL(blob);
                  const a = document.createElement("a");
                  a.href = url;
                  a.download = fileName;
                  document.body.appendChild(a);
                  a.click();
                  document.body.removeChild(a);
                  URL.revokeObjectURL(url);

                  addLog(
                    "INFO",
                    "TRACING",
                    `Trace file downloaded: ${fileName} (check your Downloads folder)`
                  );

                  // Show success message in dialog and mark as downloaded
                  setFileTraceCompleteDialog((prev) => ({
                    ...prev,
                    filePath: `${fileName}\n(Check your browser's Downloads folder)`,
                    downloaded: true,
                  }));
                } catch (err) {
                  console.error("Failed to download trace file:", err);
                  addLog(
                    "ERROR",
                    "TRACING",
                    `Failed to download trace file: ${err}`
                  );
                  setFileTraceCompleteDialog((prev) => ({
                    ...prev,
                    filePath: `✗ Download failed: ${err}`,
                  }));
                }
              }}
              variant="outlined"
              sx={{
                borderColor: "#4fc1ff",
                color: "#4fc1ff",
                "&:hover": {
                  borderColor: "#6fd3ff",
                  backgroundColor: "rgba(79, 193, 255, 0.1)",
                },
              }}
            >
              Download
            </Button>
          )}
        </DialogActions>
      </Dialog>

      {/* Processing Snackbar for long-running Ghidra operations */}
      <Snackbar
        open={processingSnackbar.open}
        anchorOrigin={{ vertical: "bottom", horizontal: "center" }}
      >
        <Alert
          severity="info"
          icon={<CircularProgress size={20} sx={{ color: "#4fc1ff" }} />}
          sx={{
            backgroundColor: "#2d2d30",
            color: "#d4d4d4",
            border: "1px solid #4fc1ff",
            "& .MuiAlert-icon": {
              alignItems: "center",
            },
          }}
        >
          {processingSnackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};

```

`src/client/src/components/CodeTracingWindow.tsx`:

```tsx
import { WebviewWindow } from "@tauri-apps/api/webviewWindow";
import { invoke } from "@tauri-apps/api/core";
import { getApiClient } from "../lib/api";

// Trace entry representing a single instruction execution
export interface TraceEntry {
  id: number;
  address: string;
  instruction: string;
  opcode: string;
  operands: string;
  registers: Record<string, string>;
  depth: number;
  isCall: boolean;
  isReturn: boolean;
  functionName?: string;
  timestamp?: number;
  libraryExpression?: string; // Address resolved to library+offset
}

// Track opened code tracing windows
const codeTracingWindows = new Map<string, WebviewWindow>();

/**
 * Start a trace session in Tauri store and set breakpoint on server
 * This should be called from main window before opening the tracing window
 * @param address - The target address to trace (hex string)
 * @param count - Number of instructions to trace (max count)
 * @param traceToFile - If true, trace to server file instead of UI
 * @param endAddress - Optional end address (hex string) - trace stops when PC reaches this
 * @param fullMemoryCache - If true, dump initial memory and log all memory accesses during trace
 * @returns Promise<{ success: boolean; traceFilePath?: string }> - success status and file path if tracing to file
 */
export async function startTraceSession(
  address: string,
  count: number,
  traceToFile: boolean = false,
  endAddress?: string,
  fullMemoryCache: boolean = false
): Promise<{ success: boolean; traceFilePath?: string }> {
  try {
    // Start trace session in Tauri store (only if not tracing to file)
    if (!traceToFile) {
      await invoke("start_trace_session", {
        targetAddress: address,
        totalCount: count,
      });
    }

    // Set breakpoint with hit_count for tracing mode
    const apiClient = getApiClient();
    const addressNum = parseInt(address.replace(/^0x/i, ""), 16);

    if (isNaN(addressNum)) {
      console.error("Invalid address for tracing:", address);
      return { success: false };
    }

    // Parse end address if provided
    let endAddressNum: number | undefined;
    if (endAddress && endAddress.trim()) {
      endAddressNum = parseInt(endAddress.replace(/^0x/i, ""), 16);
      if (isNaN(endAddressNum)) {
        console.error("Invalid end address for tracing:", endAddress);
        endAddressNum = undefined;
      }
    }

    console.log(
      `[DEBUG] setBreakpoint request: address=0x${addressNum.toString(16)}, hit_count=${count}, end_address=${endAddressNum ? "0x" + endAddressNum.toString(16) : "undefined"}`
    );

    const response = await apiClient.setBreakpoint({
      address: addressNum,
      hit_count: count,
      trace_to_file: traceToFile,
      end_address: endAddressNum,
      full_memory_cache: fullMemoryCache,
    });

    if (!response.success) {
      console.error("Failed to set tracing breakpoint:", response.message);
      // Stop the session since breakpoint failed
      if (!traceToFile) {
        await invoke("stop_trace_session");
      }
      return { success: false };
    }

    console.log(
      `Trace session started for ${address} with ${count} hits (toFile: ${traceToFile})`
    );
    return {
      success: true,
      traceFilePath: response.trace_file_path,
    };
  } catch (error) {
    console.error("Failed to start trace session:", error);
    return { success: false };
  }
}

/**
 * Stop the active trace session
 */
export async function stopTraceSession(): Promise<void> {
  try {
    await invoke("stop_trace_session");
  } catch (error) {
    console.error("Failed to stop trace session:", error);
  }
}

/**
 * Open a new Code Tracing window as an independent Tauri window
 * @param address - The target address to trace (hex string)
 * @param count - Number of instructions to trace
 * @param loadFromFile - If true, open in file loading mode (download from server)
 * @param localFilePath - If provided, load trace from this local file path
 * @returns Promise<void>
 */
export async function openCodeTracingWindow(
  address: string,
  count: number = 100,
  loadFromFile: boolean = false,
  localFilePath: string | null = null
): Promise<void> {
  // Use unique label for file loading mode to allow multiple trace windows
  const windowLabel = localFilePath
    ? `code-tracing-file-${Date.now()}`
    : `code-tracing-${address.replace(/0x/i, "").toLowerCase()}`;

  // Check if window already exists
  if (codeTracingWindows.has(windowLabel)) {
    const existingWindow = codeTracingWindows.get(windowLabel);
    if (existingWindow) {
      try {
        await existingWindow.setFocus();
        return;
      } catch {
        // Window might be closed, remove from map
        codeTracingWindows.delete(windowLabel);
      }
    }
  }

  // Determine the base URL based on environment
  const isDev = import.meta.env.DEV;
  const baseUrl = isDev ? "http://localhost:1420" : "tauri://localhost";

  const loadFromFileParam = loadFromFile ? "&loadFromFile=true" : "";
  const localFileParam = localFilePath
    ? `&localFilePath=${encodeURIComponent(localFilePath)}`
    : "";
  const window = new WebviewWindow(windowLabel, {
    url: `${baseUrl}/#/code-tracing?address=${encodeURIComponent(address)}&count=${count}${loadFromFileParam}${localFileParam}`,
    title: localFilePath
      ? `Code Tracing - ${localFilePath.split("/").pop() || "File"}`
      : loadFromFile
        ? `Code Tracing - Download`
        : `Code Tracing - ${address}`,
    width: 1200,
    height: 700,
    minWidth: 800,
    minHeight: 500,
    resizable: true,
    maximized: false,
    decorations: true,
    alwaysOnTop: false,
    skipTaskbar: false,
    center: true,
    focus: true,
    visible: true,
    acceptFirstMouse: true,
    titleBarStyle: "visible",
    shadow: true,
  });

  codeTracingWindows.set(windowLabel, window);

  // Wait for window to be created
  await window.once("tauri://window-created", () => {
    console.log("Code Tracing window created:", windowLabel);
  });

  // Show and focus
  try {
    await window.show();
    await window.setFocus();
  } catch (error) {
    console.error("Failed to show/focus code tracing window:", error);
  }

  // Clean up when window is closed
  window.once("tauri://close-requested", () => {
    codeTracingWindows.delete(windowLabel);
    console.log("Code Tracing window closed:", windowLabel);
  });
}

/**
 * Close all code tracing windows
 */
export async function closeAllCodeTracingWindows(): Promise<void> {
  for (const [label, window] of codeTracingWindows.entries()) {
    try {
      await window.close();
      codeTracingWindows.delete(label);
    } catch (error) {
      console.error(`Failed to close window ${label}:`, error);
    }
  }
}

// Re-export TraceEntry for convenience
export type { TraceEntry as CodeTracingEntry };

```

`src/client/src/components/ColumnResizer.tsx`:

```tsx
import React from "react";
import { Box, styled } from "@mui/material";

interface ColumnResizerProps {
  onMouseDown: (e: React.MouseEvent) => void;
  isResizing?: boolean;
}

const ResizerHandle = styled(Box, {
  shouldForwardProp: (prop) => prop !== "isResizing",
})<{ isResizing?: boolean }>(({ isResizing }) => ({
  position: "absolute",
  right: 0,
  top: "4px",
  bottom: "4px",
  width: "1px",
  cursor: "col-resize",
  backgroundColor: isResizing ? "#4fc1ff" : "#3a3a3a",
  transition: "background-color 0.15s ease",
  zIndex: 10,
  "&:hover": {
    backgroundColor: "#4fc1ff",
  },
  "&::before": {
    content: '""',
    position: "absolute",
    top: "-4px",
    left: "-3px",
    width: "8px",
    height: "calc(100% + 8px)",
  },
}));

export const ColumnResizer: React.FC<ColumnResizerProps> = ({
  onMouseDown,
  isResizing = false,
}) => {
  const handleMouseDown = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    onMouseDown(e);
  };

  return (
    <ResizerHandle onMouseDown={handleMouseDown} isResizing={isResizing} />
  );
};

```

`src/client/src/components/DebuggerContent.tsx`:

```tsx
import React, { useCallback, useEffect, useState, useRef } from "react";
import { Box, Alert, Snackbar } from "@mui/material";
import { MainContent } from "../utils/constants";
import { ServerInfo, getApiClient } from "../lib/api";
import { ExceptionInfo } from "../types";
import { AssemblyView } from "./AssemblyView";
import { MemoryView } from "./MemoryView";
import { DecompileView } from "./DecompileView";
import { Resizer } from "./Resizer";
import { useGlobalDebugLogger } from "../hooks/useGlobalDebugLogger";
import { useGlobalExceptionHandler } from "../hooks/useGlobalExceptionHandler";
import { useResizable } from "../hooks/useResizable";
import { ProcessedException } from "../hooks/useExceptionHandler";
import { GhidraTokenInfo } from "../hooks/useGhidraAnalysis";

interface DebuggerContentProps {
  serverInfo?: ServerInfo;
  onBreakpointInputSet?: (address: string) => void;
  onBreakpointHit?: (address: string) => void;
  onRegisterDataUpdate?: (registerData: Record<string, string>) => void;
  setCurrentThreadId?: (threadId: number | null) => void; // Set current active thread ID
  setLastException?: (exception: ExceptionInfo | null) => void; // Set last exception info
  currentBreakAddress?: string | null; // Add break address prop
  onBreakStateChange?: (isBreaking: boolean) => void; // Add break state change callback
  lastDebugAction?: "continue" | "single_step" | "breakpoint" | null; // Add last action tracking
  isInBreakState?: boolean; // Add break state prop
  isSoftwareBreakpoint?: boolean; // Whether to set software breakpoints (from toolbar toggle)
  // Add debugger content state props
  breakpointNotification?: {
    open: boolean;
    message: string;
  };
  activeBreakpoints?: string[];
  softwareBreakpoints?: string[]; // Track which breakpoints are software
  onAssemblyAddressChange?: (address: string) => void;
  onShowBreakpointNotification?: (message: string) => void;
  onHideBreakpointNotification?: () => void;
  onAddActiveBreakpoint?: (address: string, isSoftware?: boolean) => void;
  onRemoveActiveBreakpoint?: (address: string) => void;
  registerData?: Record<string, string>;
  currentThreadId?: number | null;
  memoryAddress?: string; // Add memory address prop
  onMemoryAddressChange?: (address: string) => void; // Add callback for memory address change
  // Module information for address detail display
  attachedModules?: any[]; // ModuleInfo array from useDebuggerState
  // Function name resolution for stack view
  resolveFunctionName?: (libraryPath: string, offset: number) => string | null;
}

export const DebuggerContent: React.FC<DebuggerContentProps> = ({
  serverInfo,
  onBreakpointInputSet,
  onBreakpointHit,
  onRegisterDataUpdate: _onRegisterDataUpdate,
  setCurrentThreadId,
  setLastException,
  currentBreakAddress,
  onBreakStateChange,
  lastDebugAction: _lastDebugAction,
  isInBreakState = false,
  isSoftwareBreakpoint = false,
  // Debugger content state props
  breakpointNotification = { open: false, message: "" },
  activeBreakpoints = [],
  softwareBreakpoints = [],
  onAssemblyAddressChange,
  onHideBreakpointNotification,
  onAddActiveBreakpoint,
  onRemoveActiveBreakpoint,
  registerData = {},
  currentThreadId = null,
  onMemoryAddressChange,
  attachedModules = [],
  resolveFunctionName,
}) => {
  const { logInfo, addLog } = useGlobalDebugLogger();

  // Decompile view visibility state - temporarily hidden
  const [isDecompileVisible, setIsDecompileVisible] = useState(false);

  // Ghidra decompile result state
  const [ghidraDecompileResult, setGhidraDecompileResult] = useState<{
    libraryPath: string;
    address: string;
    functionName: string | null;
    code: string;
    moduleBase: number;
    lineMapping: Record<string, string> | null; // line number (as string) -> offset (hex string)
    tokens?: GhidraTokenInfo[] | null; // Token information from Ghidra
  } | null>(null);
  const [isGhidraLoading] = useState(false);
  const [ghidraError, setGhidraError] = useState<string | null>(null);

  // Scroll to line number in DecompileView (set from assembly click)
  const [decompileScrollToLine, setDecompileScrollToLine] = useState<
    number | null
  >(null);

  // Highlight address in AssemblyView (from DecompileView click - highlight only if visible, scroll if not)
  const [highlightAssemblyAddress, setHighlightAssemblyAddress] = useState<
    string | null
  >(null);

  // Container ref for resize calculations
  const containerRef = useRef<HTMLDivElement>(null);

  // Vertical resizer for Assembly/Decompile vs Memory split
  const assemblyMemorySplit = useResizable({
    storageKey: "debugger-assembly-memory-split",
    defaultSize: 50, // Default to 50% of height
    minSize: 20,
    maxSize: 80,
    orientation: "vertical",
    containerRef,
  });

  // Horizontal resizer for Assembly vs Decompile split (width)
  const assemblyDecompileSplit = useResizable({
    storageKey: "debugger-assembly-decompile-split",
    defaultSize: 60, // Default to 60% for Assembly
    minSize: 30,
    maxSize: 80,
    orientation: "horizontal",
    containerRef,
  });

  // Use global exception handler instead of creating a separate instance
  const {
    breakpointExceptions: exceptions,
    error: exceptionError,
    clearBreakpointExceptions: clearExceptions,
    registerBreakpointHandler: _registerBreakpointHandler,
    unregisterBreakpointHandler: _unregisterBreakpointHandler,
    registerSignalHandler,
    unregisterSignalHandler,
  } = useGlobalExceptionHandler();

  // NOTE: Breakpoint handler registration removed to avoid duplicate processing.
  // MainApp now handles all breakpoint/exception processing centrally via
  // handleGlobalBreakpointHit and systemActions.updateDebugState.
  // This prevents double processing of exceptions which was causing ~1 second UI lag.

  // Use refs to store callback functions to avoid re-registering signal handler
  const setCurrentThreadIdRef = useRef(setCurrentThreadId);
  const setLastExceptionRef = useRef(setLastException);
  const onBreakStateChangeRef = useRef(onBreakStateChange);
  const onBreakpointHitRef = useRef(onBreakpointHit);
  const addLogRef = useRef(addLog);

  // Keep refs updated
  useEffect(() => {
    setCurrentThreadIdRef.current = setCurrentThreadId;
    setLastExceptionRef.current = setLastException;
    onBreakStateChangeRef.current = onBreakStateChange;
    onBreakpointHitRef.current = onBreakpointHit;
    addLogRef.current = addLog;
  });

  // Register signal handler (SIGSEGV, SIGILL, etc.) - only once on mount
  useEffect(() => {
    console.log("[DEBUGGER_CONTENT] Registering signal handler (once)");

    const handleSignal = (exception: ProcessedException) => {
      console.log("[DEBUGGER_CONTENT] Signal handler called with:", exception);

      const signalName = exception.type.toUpperCase();
      const address = exception.address || "unknown";

      addLogRef.current(
        "WARN",
        "DEBUGGER_CONTENT",
        `Signal ${signalName} received at ${address} (thread: ${exception.thread_id})`
      );

      // Set current thread ID and exception info in debugger state
      if (setCurrentThreadIdRef.current && exception.thread_id !== undefined) {
        setCurrentThreadIdRef.current(exception.thread_id);
        logInfo(
          "DEBUGGER_CONTENT",
          `Set current thread ID to: ${exception.thread_id}`
        );
      }

      // Create ExceptionInfo object for state management
      if (setLastExceptionRef.current) {
        const exceptionInfo: ExceptionInfo = {
          index: exception.context?.index || 0,
          count: exception.context?.count || 1,
          address: exception.address,
          bytecode: exception.context?.bytecode || "unknown",
          opcode: exception.context?.opcode || "unknown",
          timestamp: exception.timestamp,
          thread_id: exception.thread_id,
          exception_type: exception.type, // Signal type (sigill, sigsegv, etc.)
          instruction: exception.instruction,
          // Copy register values - ARM64
          x0: exception.x0,
          x1: exception.x1,
          x2: exception.x2,
          x3: exception.x3,
          x4: exception.x4,
          x5: exception.x5,
          x6: exception.x6,
          x7: exception.x7,
          x8: exception.x8,
          x9: exception.x9,
          x10: exception.x10,
          x11: exception.x11,
          x12: exception.x12,
          x13: exception.x13,
          x14: exception.x14,
          x15: exception.x15,
          x16: exception.x16,
          x17: exception.x17,
          x18: exception.x18,
          x19: exception.x19,
          x20: exception.x20,
          x21: exception.x21,
          x22: exception.x22,
          x23: exception.x23,
          x24: exception.x24,
          x25: exception.x25,
          x26: exception.x26,
          x27: exception.x27,
          x28: exception.x28,
          x29: exception.x29,
          lr: exception.lr,
          fp: exception.fp,
          sp: exception.sp,
          pc: exception.pc,
          cpsr: exception.cpsr,
          // Copy register values - x86_64
          rax: exception.rax,
          rbx: exception.rbx,
          rcx: exception.rcx,
          rdx: exception.rdx,
          rsi: exception.rsi,
          rdi: exception.rdi,
          rbp: exception.rbp,
          rsp: exception.rsp,
          r8: exception.r8,
          r9: exception.r9,
          r10: exception.r10,
          r11: exception.r11,
          r12: exception.r12,
          r13: exception.r13,
          r14: exception.r14,
          r15: exception.r15,
          rip: exception.rip,
          rflags: exception.rflags,
          cs: exception.cs,
          ss: exception.ss,
          ds: exception.ds,
          es: exception.es,
          fs: exception.fs,
          gs: exception.gs,
        };
        setLastExceptionRef.current(exceptionInfo);
        logInfo("DEBUGGER_CONTENT", "Set last exception info for signal");
      }

      // Set break state to pause UI
      if (onBreakStateChangeRef.current) {
        onBreakStateChangeRef.current(true);
        logInfo("DEBUGGER_CONTENT", "Set in break state for signal");
      }

      // Navigate to the signal address (same as breakpoint)
      if (onBreakpointHitRef.current) {
        const displayAddress = address.toLowerCase().startsWith("0x")
          ? address
          : `0x${address}`;
        onBreakpointHitRef.current(displayAddress);
        logInfo(
          "DEBUGGER_CONTENT",
          `onBreakpointHit called for signal at address: ${displayAddress}`
        );
      }
    };

    console.log("[DEBUGGER_CONTENT] About to register signal handler");
    registerSignalHandler(handleSignal);
    console.log("[DEBUGGER_CONTENT] Signal handler registered successfully");

    return () => {
      console.log("[DEBUGGER_CONTENT] Unregistering signal handler");
      unregisterSignalHandler(handleSignal);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [registerSignalHandler, unregisterSignalHandler]); // Only re-register when handler functions change

  // Note: Monitoring is handled by GlobalExceptionHandlerProvider automatically
  // No need to manually start/stop monitoring here

  // Handle address change from memory view (memory view is now independent)
  const handleMemoryAddressChange = useCallback(
    (address: string) => {
      // Memory view address changes are now independent - no action needed
      addLog("INFO", "MEMORY", "Memory view address changed", {
        address,
      });

      // Call parent callback if provided
      if (onMemoryAddressChange) {
        onMemoryAddressChange(address);
      }
    },
    [onMemoryAddressChange, addLog]
  );

  // Handle breakpoint removal
  const handleBreakpointRemove = useCallback(
    async (address: string) => {
      try {
        const apiClient = getApiClient();
        const addressNum = parseInt(address.replace(/^0x/i, ""), 16);
        const response = await apiClient.removeBreakpoint({
          address: addressNum,
        });

        if (response.success) {
          addLog("INFO", "BREAKPOINT", `Breakpoint removed at ${address}`);
          // Remove from active breakpoints list
          if (onRemoveActiveBreakpoint) {
            onRemoveActiveBreakpoint(address);
          }
        } else {
          addLog(
            "ERROR",
            "BREAKPOINT",
            `Failed to remove breakpoint at ${address}: ${response.message}`
          );
        }
      } catch (error) {
        addLog(
          "ERROR",
          "BREAKPOINT",
          `Failed to remove breakpoint: ${error instanceof Error ? error.message : "Unknown error"}`
        );
      }
    },
    [onRemoveActiveBreakpoint, addLog]
  );

  // Handle breakpoint address setting
  const handleBreakpointSet = useCallback(
    async (address: string, isSoftware?: boolean) => {
      // Use passed isSoftware if provided, otherwise use the prop
      const useSoftware = isSoftware ?? isSoftwareBreakpoint;
      console.log(
        "[DebuggerContent] handleBreakpointSet:",
        address,
        "isSoftware:",
        useSoftware
      );
      try {
        const apiClient = getApiClient();
        const addressNum = parseInt(address.replace(/^0x/i, ""), 16);
        const response = await apiClient.setBreakpoint({
          address: addressNum,
          hit_count: 0,
          is_software: useSoftware,
        });

        if (response.success) {
          addLog(
            "INFO",
            "BREAKPOINT",
            `Breakpoint set at ${address} (${useSoftware ? "software" : "hardware"})`
          );
          // Update the input value
          if (onBreakpointInputSet) {
            onBreakpointInputSet(address);
          }
          // Add to active breakpoints list for exception monitoring
          if (onAddActiveBreakpoint) {
            onAddActiveBreakpoint(address, useSoftware);
          }
        } else {
          addLog(
            "ERROR",
            "BREAKPOINT",
            `Failed to set breakpoint at ${address}: ${response.message}`
          );
        }
      } catch (error) {
        addLog(
          "ERROR",
          "BREAKPOINT",
          `Failed to set breakpoint: ${error instanceof Error ? error.message : "Unknown error"}`
        );
      }
    },
    [onBreakpointInputSet, onAddActiveBreakpoint, addLog, isSoftwareBreakpoint]
  );

  // Handle decompile view toggle
  const handleDecompileToggle = useCallback(() => {
    setIsDecompileVisible((prev) => !prev);
    addLog(
      "INFO",
      "DECOMPILE",
      `Decompile view ${isDecompileVisible ? "hidden" : "shown"}`
    );
  }, [isDecompileVisible, addLog]);

  // Handle decompile line click - use line mapping to highlight assembly address
  // If address is visible, just highlight; if not visible, scroll to it
  const handleDecompileLineClick = useCallback(
    (lineNumber: number, lineText: string) => {
      console.log(
        "[DebuggerContent] Decompile line clicked:",
        lineNumber,
        lineText
      );

      if (!ghidraDecompileResult) {
        addLog("WARN", "DECOMPILE", "No decompile result available");
        return;
      }

      const { moduleBase, lineMapping } = ghidraDecompileResult;

      // First, try to use the line mapping from Ghidra
      const lineKey = String(lineNumber);
      if (lineMapping && lineMapping[lineKey]) {
        const offsetHex = lineMapping[lineKey];
        console.log(
          "[DebuggerContent] Found line mapping:",
          lineNumber,
          "->",
          offsetHex
        );

        // Parse the offset (it's already in hex format like "0x1234")
        const offset = parseInt(offsetHex.replace(/^0x/i, ""), 16);
        const absoluteAddress = moduleBase + offset;
        const hexAddress = `0x${absoluteAddress.toString(16)}`;

        console.log("[DebuggerContent] Highlighting address:", hexAddress);
        // Use highlightAssemblyAddress instead of direct navigation
        // AssemblyView will check if visible and only scroll if needed
        setHighlightAssemblyAddress(hexAddress);
        addLog(
          "INFO",
          "DECOMPILE",
          `Line ${lineNumber}: Highlight ${hexAddress} (from line mapping)`
        );
        return;
      }

      // Fallback: try to find nearest line with mapping
      if (lineMapping) {
        const mappedLines = Object.keys(lineMapping)
          .map(Number)
          .sort((a, b) => a - b);

        // Find the closest line number that is <= current line
        let nearestLine = mappedLines[0];
        for (const ln of mappedLines) {
          if (ln <= lineNumber) {
            nearestLine = ln;
          } else {
            break;
          }
        }

        const nearestLineKey = String(nearestLine);
        if (nearestLine && lineMapping[nearestLineKey]) {
          const offsetHex = lineMapping[nearestLineKey];
          console.log(
            "[DebuggerContent] Using nearest line mapping:",
            nearestLine,
            "->",
            offsetHex
          );

          const offset = parseInt(offsetHex.replace(/^0x/i, ""), 16);
          const absoluteAddress = moduleBase + offset;
          const hexAddress = `0x${absoluteAddress.toString(16)}`;

          // Use highlightAssemblyAddress instead of direct navigation
          setHighlightAssemblyAddress(hexAddress);
          addLog(
            "INFO",
            "DECOMPILE",
            `Line ${lineNumber}: Highlight ${hexAddress} (nearest mapping from line ${nearestLine})`
          );
          return;
        }
      }

      // Final fallback: look for hex address in the line text
      const hexMatch = lineText.match(/0x[0-9a-fA-F]+/);
      if (hexMatch) {
        const ghidraAddress = hexMatch[0];
        console.log(
          "[DebuggerContent] Found hex address in line:",
          ghidraAddress
        );

        const ghidraAddr = parseInt(ghidraAddress.replace(/^0x/i, ""), 16);
        const GHIDRA_IMAGE_BASE = 0x00100000;
        const offset = ghidraAddr - GHIDRA_IMAGE_BASE;
        const absoluteAddress = moduleBase + offset;
        const hexAddress = `0x${absoluteAddress.toString(16)}`;

        // Use highlightAssemblyAddress instead of direct navigation
        setHighlightAssemblyAddress(hexAddress);
        addLog(
          "INFO",
          "DECOMPILE",
          `Line ${lineNumber}: Highlight ${hexAddress} (from hex in text)`
        );
        return;
      }

      addLog(
        "INFO",
        "DECOMPILE",
        `Line ${lineNumber} clicked (no address mapping available)`
      );
    },
    [addLog, ghidraDecompileResult]
  );

  // Handle Ghidra decompile request from AssemblyView
  const handleDecompileRequest = useCallback(
    (
      libraryPath: string,
      address: string,
      functionName: string | null,
      decompiledCode: string,
      moduleBase: number,
      lineMapping: Record<string, string> | null,
      tokens?: GhidraTokenInfo[] | null
    ) => {
      console.log("[DebuggerContent] Received decompile result:", {
        libraryPath,
        address,
        functionName,
        codeLength: decompiledCode.length,
        moduleBase,
        moduleBaseHex: `0x${moduleBase.toString(16)}`,
        lineMappingCount: lineMapping ? Object.keys(lineMapping).length : 0,
        tokensCount: tokens ? tokens.length : 0,
      });
      setGhidraDecompileResult({
        libraryPath,
        address,
        functionName,
        code: decompiledCode,
        moduleBase,
        lineMapping,
        tokens,
      });
      // Auto-show decompile view when result is received
      setIsDecompileVisible(true);
      addLog("INFO", "GHIDRA", `Decompiled: ${functionName || address}`);
    },
    [addLog]
  );

  // Handle address click from DecompileView - navigate to that address in assembly
  const handleDecompileAddressClick = useCallback(
    (ghidraAddress: string) => {
      // Ghidra addresses start from 0x00100000 (image base)
      // We need to convert to module offset and then to absolute address using saved moduleBase
      console.log(
        "[DebuggerContent] Decompile address clicked:",
        ghidraAddress
      );
      console.log(
        "[DebuggerContent] ghidraDecompileResult:",
        ghidraDecompileResult
      );
      addLog("INFO", "DECOMPILE", `Address clicked: ${ghidraAddress}`);

      if (!ghidraDecompileResult) {
        console.warn("[DebuggerContent] No ghidraDecompileResult available");
        return;
      }

      // Extract the numeric value from the hex address
      const ghidraAddr = parseInt(ghidraAddress.replace(/^0x/i, ""), 16);
      console.log(
        "[DebuggerContent] Parsed ghidraAddr:",
        ghidraAddr,
        `(0x${ghidraAddr.toString(16)})`
      );

      // Ghidra uses 0x00100000 as default image base
      const GHIDRA_IMAGE_BASE = 0x00100000;
      const offset = ghidraAddr - GHIDRA_IMAGE_BASE;
      console.log(
        "[DebuggerContent] Offset from Ghidra image base:",
        offset,
        `(0x${offset.toString(16)})`
      );

      // Use the saved moduleBase from when decompilation was performed
      const moduleBase = ghidraDecompileResult.moduleBase;
      console.log(
        "[DebuggerContent] Using saved moduleBase:",
        moduleBase,
        `(0x${moduleBase.toString(16)})`
      );

      const absoluteAddress = moduleBase + offset;
      const hexAddress = `0x${absoluteAddress.toString(16)}`;
      console.log("[DebuggerContent] Calculated absolute address:", hexAddress);

      if (onAssemblyAddressChange) {
        onAssemblyAddressChange(hexAddress);
        addLog(
          "INFO",
          "DECOMPILE",
          `Navigated to ${hexAddress} (offset 0x${offset.toString(16)} from moduleBase 0x${moduleBase.toString(16)})`
        );
      }
    },
    [addLog, ghidraDecompileResult, onAssemblyAddressChange]
  );

  // Handle function click from DecompileView - decompile the clicked function
  const handleDecompileFunctionClick = useCallback(
    (functionOffset: string) => {
      console.log("[DebuggerContent] Function clicked:", functionOffset);

      if (!ghidraDecompileResult) {
        addLog(
          "WARN",
          "DECOMPILE",
          "No decompile result available to determine library"
        );
        return;
      }

      // Calculate absolute address from function offset and navigate
      const offset = parseInt(functionOffset.replace(/^0x/i, ""), 16);
      const absoluteAddress = ghidraDecompileResult.moduleBase + offset;
      const hexAddress = `0x${absoluteAddress.toString(16)}`;

      addLog(
        "INFO",
        "DECOMPILE",
        `Navigating to function at ${hexAddress} (offset ${functionOffset})`
      );

      if (onAssemblyAddressChange) {
        onAssemblyAddressChange(hexAddress);
      }
    },
    [addLog, ghidraDecompileResult, onAssemblyAddressChange]
  );

  // Handle assembly address change to scroll DecompileView to corresponding line
  const handleAssemblyToDecompileSync = useCallback(
    (absoluteAddress: string) => {
      if (!ghidraDecompileResult || !ghidraDecompileResult.lineMapping) {
        return;
      }

      const { moduleBase, lineMapping } = ghidraDecompileResult;

      // Convert absolute address to offset
      const absAddr = parseInt(absoluteAddress.replace(/^0x/i, ""), 16);
      const offset = absAddr - moduleBase;
      const offsetHex = `0x${offset.toString(16)}`;

      // Find the line number that maps to this offset
      // lineMapping is { lineNumber: offsetHex }
      // We need to reverse lookup: find line number where value matches offset
      let targetLine: number | null = null;
      let nearestLine: number | null = null;
      let nearestDistance = Infinity;

      for (const [lineStr, lineOffset] of Object.entries(lineMapping)) {
        const lineNum = parseInt(lineStr, 10);
        const mappedOffset = parseInt(lineOffset.replace(/^0x/i, ""), 16);

        if (mappedOffset === offset) {
          targetLine = lineNum;
          break;
        }

        // Track nearest line for fallback
        const distance = Math.abs(mappedOffset - offset);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestLine = lineNum;
        }
      }

      // Use exact match or nearest if within reasonable range (256 bytes)
      const lineToScroll =
        targetLine || (nearestDistance < 256 ? nearestLine : null);

      if (lineToScroll) {
        console.log(
          `[DebuggerContent] Scrolling DecompileView to line ${lineToScroll} for offset ${offsetHex}`
        );
        setDecompileScrollToLine(lineToScroll);
        // Clear after a short delay to allow re-triggering for same line
        setTimeout(() => setDecompileScrollToLine(null), 100);
      }
    },
    [ghidraDecompileResult]
  );

  // Handle AI enhancement
  const handleAIEnhance = useCallback(() => {
    addLog("INFO", "AI", "AI enhancement toggled for decompiled source");
  }, [addLog]);

  // Handle notification close
  const handleNotificationClose = useCallback(() => {
    if (onHideBreakpointNotification) {
      onHideBreakpointNotification();
    }
  }, [onHideBreakpointNotification]);

  return (
    <MainContent>
      <Box
        ref={containerRef}
        sx={{
          height: "100%",
          display: "flex",
          flexDirection: "column",
        }}
      >
        {/* Exception monitoring error notification */}
        {exceptionError && (
          <Alert
            severity="warning"
            sx={{ mb: 1 }}
            onClose={() => {
              // Clear error (monitoring is handled globally)
              clearExceptions();
            }}
          >
            Breakpoint monitoring error: {exceptionError}
          </Alert>
        )}

        {/* Assembly and Decompile Views - Top Half */}
        <Box
          sx={{
            height: `${assemblyMemorySplit.size}%`,
            minHeight: 0, // Allow flex child to shrink below content size
            borderBottom: 1,
            borderColor: "divider",
            overflow: "hidden",
            display: "flex",
            flexDirection: "row",
          }}
        >
          {/* Assembly View - Left Side */}
          <Box
            sx={{
              width: isDecompileVisible
                ? `${assemblyDecompileSplit.size}%`
                : "100%",
              minWidth: 0,
              overflow: "hidden",
              transition: isDecompileVisible ? "none" : "width 0.3s ease",
            }}
          >
            <AssemblyView
              serverInfo={serverInfo}
              onBreakpointSet={handleBreakpointSet}
              onBreakpointRemove={handleBreakpointRemove}
              onBreakpointHit={onBreakpointHit}
              currentBreakAddress={currentBreakAddress}
              isInBreakState={isInBreakState}
              activeBreakpoints={activeBreakpoints}
              softwareBreakpoints={
                new Map(softwareBreakpoints.map((addr) => [addr, ""]))
              }
              isSoftwareBreakpoint={isSoftwareBreakpoint}
              attachedModules={attachedModules}
              registerData={registerData}
              isDecompileVisible={isDecompileVisible}
              onToggleDecompile={handleDecompileToggle}
              hasDecompileResult={!!ghidraDecompileResult}
              onDecompileRequest={handleDecompileRequest}
              onDecompileError={setGhidraError}
              onAssemblyAddressClicked={handleAssemblyToDecompileSync}
              highlightAddress={highlightAssemblyAddress}
              onHighlightComplete={() => setHighlightAssemblyAddress(null)}
            />
          </Box>

          {/* Horizontal Resizer between Assembly and Decompile */}
          {isDecompileVisible && (
            <Resizer
              orientation="vertical"
              onMouseDown={assemblyDecompileSplit.handleMouseDown}
              isResizing={assemblyDecompileSplit.isResizing}
            />
          )}

          {/* Decompile View - Right Side */}
          {isDecompileVisible && (
            <Box
              sx={{
                width: `${100 - assemblyDecompileSplit.size}%`,
                minWidth: 0,
                overflow: "hidden",
                border: "1px solid #3c3c3c",
                borderRadius: "2px",
              }}
            >
              <DecompileView
                isVisible={isDecompileVisible}
                onToggleVisibility={handleDecompileToggle}
                currentBreakAddress={currentBreakAddress}
                isInBreakState={isInBreakState}
                onLineClick={handleDecompileLineClick}
                onAIEnhance={handleAIEnhance}
                functionName={ghidraDecompileResult?.functionName || undefined}
                functionAddress={ghidraDecompileResult?.address}
                libraryName={
                  ghidraDecompileResult?.libraryPath
                    ? ghidraDecompileResult.libraryPath.split(/[/\\]/).pop()
                    : undefined
                }
                ghidraCode={ghidraDecompileResult?.code}
                isGhidraLoading={isGhidraLoading}
                ghidraError={ghidraError}
                onAddressClick={handleDecompileAddressClick}
                onFunctionClick={handleDecompileFunctionClick}
                scrollToLineNumber={decompileScrollToLine}
                lineMapping={ghidraDecompileResult?.lineMapping}
                moduleBase={ghidraDecompileResult?.moduleBase}
                tokens={ghidraDecompileResult?.tokens}
                activeBreakpoints={activeBreakpoints}
                onBreakpointSet={handleBreakpointSet}
                onBreakpointRemove={handleBreakpointRemove}
              />
            </Box>
          )}
        </Box>

        {/* Vertical Resizer */}
        <Resizer
          orientation="horizontal"
          onMouseDown={assemblyMemorySplit.handleMouseDown}
          isResizing={assemblyMemorySplit.isResizing}
        />

        {/* Memory View - Bottom Half */}
        <Box
          sx={{
            height: `${100 - assemblyMemorySplit.size}%`,
            minHeight: 0, // Allow flex child to shrink below content size
            overflow: "hidden",
          }}
        >
          <MemoryView
            serverInfo={serverInfo}
            onAddressChange={handleMemoryAddressChange}
            registerData={registerData}
            isInBreakState={isInBreakState}
            currentThreadId={currentThreadId}
            attachedModules={attachedModules}
            resolveFunctionName={resolveFunctionName}
          />
        </Box>
      </Box>

      {/* Breakpoint hit notification */}
      <Snackbar
        open={breakpointNotification.open}
        autoHideDuration={4000}
        onClose={handleNotificationClose}
        anchorOrigin={{ vertical: "top", horizontal: "center" }}
      >
        <Alert
          onClose={handleNotificationClose}
          severity="info"
          variant="filled"
          sx={{ width: "100%" }}
        >
          {breakpointNotification.message}
          {exceptions.length > 0 && (
            <Box component="span" sx={{ ml: 1, fontSize: "0.85em" }}>
              (Total: {exceptions.length} hits)
            </Box>
          )}
        </Alert>
      </Snackbar>
    </MainContent>
  );
};

```

`src/client/src/components/DebuggerSidebar.tsx`:

```tsx
import React, {
  useState,
  useRef,
  useCallback,
  useEffect,
  useMemo,
} from "react";
import {
  Box,
  styled,
  Typography,
  TextField,
  InputAdornment,
  Autocomplete,
  useMediaQuery,
} from "@mui/material";
import VirtualizedTable, { ColumnDef, SortDirection } from "./VirtualizedTable";
import {
  FilterList as FilterListIcon,
  DataObject as DataObjectIcon,
  Functions as FunctionsIcon,
  Storage as StorageIcon,
  LibraryBooks as LibraryBooksIcon,
  Search as SearchIcon,
  DragHandle as DragHandleIcon,
  InsertDriveFile as FileIcon,
  FolderOpen as FolderOpenIcon,
  AccountTree as OutlineIcon,
  DataArray as DataArrayIcon,
} from "@mui/icons-material";
import SidebarPanel from "./SidebarPanel";
import { getApiClient, ModuleInfo, SymbolInfo } from "../lib/api";
import { useAppState } from "../hooks/useAppState";
import { useLocalStorage } from "../hooks/useLocalStorage";
import { useUIStore } from "../stores/uiStore";
import { invoke } from "@tauri-apps/api/core";
import {
  useGhidraAnalysis,
  GhidraFunctionEntry,
  GhidraDataItem,
} from "../hooks/useGhidraAnalysis";

// Tauri-side cache types (matching Rust structs)
// Note: Rust uses snake_case for field names
interface TauriCachedSymbol {
  address: string;
  name: string;
  size: number;
  symbol_type: string; // Rust field name
  scope: string;
  module_base: string;
  file_name?: string;
  line_number?: number;
  is_external?: boolean;
  is_private_external?: boolean;
  is_weak_def?: boolean;
  is_weak_ref?: boolean;
  is_thumb?: boolean;
  section_index?: number;
  library_ordinal?: number;
}

interface TauriCachedGhidraData {
  address: string;
  name: string | null;
  data_type: string; // Rust field name
  category: string;
  size: number;
  value: string | null;
}

interface TauriSidebarCache {
  modules: ModuleInfo[];
  symbols: TauriCachedSymbol[];
  ghidra_functions: GhidraFunctionEntry[];
  ghidra_data_items: TauriCachedGhidraData[];
  cached_process_pid: number | null;
  cached_module_path: string | null;
  last_update: number;
}

// Helper to convert Tauri cached symbol to frontend SymbolInfo
const convertCachedSymbol = (cached: TauriCachedSymbol): SymbolInfo => ({
  address: cached.address,
  name: cached.name,
  size: cached.size,
  type: cached.symbol_type, // Map symbol_type -> type
  scope: cached.scope,
  module_base: cached.module_base,
  file_name: cached.file_name,
  line_number: cached.line_number,
  is_external: cached.is_external,
  is_private_external: cached.is_private_external,
  is_weak_def: cached.is_weak_def,
  is_weak_ref: cached.is_weak_ref,
  is_thumb: cached.is_thumb,
  section_index: cached.section_index,
  library_ordinal: cached.library_ordinal,
});

// Helper to convert Tauri cached ghidra data to frontend GhidraDataItem
const convertCachedGhidraData = (
  cached: TauriCachedGhidraData
): GhidraDataItem => ({
  address: cached.address,
  name: cached.name,
  type: cached.data_type, // Map data_type -> type
  category: cached.category as GhidraDataItem["category"],
  size: cached.size,
  value: cached.value,
});

// Helper function to get display module name (same as in DebuggerContent)
const getDisplayModuleName = (moduleName: string): string => {
  if (!moduleName) return "Unknown Module";

  // For Linux/Android/Windows, extract only the module name from path
  if (moduleName.includes("/") || moduleName.includes("\\")) {
    const pathParts = moduleName.split(/[\/\\]/);
    return pathParts[pathParts.length - 1] || moduleName;
  }

  return moduleName;
};

const SidebarContainer = styled(Box)(() => ({
  gridArea: "sidebar",
  backgroundColor: "#252526",
  borderRight: "1px solid #2d2d30",
  overflow: "hidden",
  display: "flex",
  flexDirection: "column",
  position: "relative",
}));

const SidebarContent = styled(Box, {
  shouldForwardProp: (prop) => prop !== "isResizing",
})<{ isResizing?: boolean }>(({ isResizing }) => ({
  flex: 1,
  overflow: "auto",
  display: "flex",
  flexDirection: "column",
  pointerEvents: isResizing ? "none" : "auto",
}));

const ResizeHandle = styled(Box, {
  shouldForwardProp: (prop) => prop !== "isResizing",
})<{ isResizing?: boolean }>(({ isResizing }) => ({
  position: "absolute",
  top: 0,
  right: "0px",
  width: "8px",
  height: "100%",
  cursor: "col-resize",
  backgroundColor: isResizing
    ? "rgba(0, 122, 204, 0.5)"
    : "rgba(66, 66, 66, 0.2)",
  zIndex: 1001,
  pointerEvents: "auto",
  border: isResizing ? "1px solid #007acc" : "none",
  userSelect: "none",

  "&::before": {
    content: '""',
    position: "absolute",
    right: "2px",
    top: "50%",
    transform: "translateY(-50%)",
    width: "2px",
    height: "40px",
    backgroundColor: isResizing ? "#007acc" : "#424242",
    opacity: isResizing ? 1 : 0.6,
  },

  "&:hover": {
    backgroundColor: "rgba(0, 122, 204, 0.4)",

    "&::before": {
      backgroundColor: "#007acc",
      opacity: 1,
      width: "3px",
      height: "60px",
    },
  },

  "&:active": {
    backgroundColor: "rgba(0, 122, 204, 0.7)",

    "&::before": {
      backgroundColor: "#007acc",
      opacity: 1,
      width: "4px",
      height: "80px",
    },
  },
}));

// Panel height resize divider
const PanelDivider = styled(Box, {
  shouldForwardProp: (prop) => prop !== "isResizing",
})<{ isResizing?: boolean }>(({ isResizing }) => ({
  height: "6px",
  cursor: "row-resize",
  backgroundColor: isResizing ? "rgba(0, 122, 204, 0.5)" : "#2d2d30",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  transition: "background-color 0.15s ease",
  flexShrink: 0,
  "&:hover": {
    backgroundColor: "rgba(0, 122, 204, 0.4)",
  },
  "& .drag-icon": {
    fontSize: "12px",
    color: isResizing ? "#4fc1ff" : "#555",
    opacity: 0.6,
  },
  "@media (max-height: 800px)": {
    height: "4px",
    "& .drag-icon": {
      fontSize: "10px",
    },
  },
}));

const accentColors = {
  blue: "#4fc1ff",
  green: "#89d185",
  purple: "#c586c0",
  orange: "#ce9178",
  yellow: "#dcdcaa",
};

// Interface for combined functions
interface CombinedFunction {
  name: string;
  address: string;
  size: number;
  source: "symbol" | "ghidra" | "both";
}

interface DebuggerSidebarProps {
  activeFunction: string;
  onFunctionClick: (functionName: string, functionAddress?: string) => void;
  onModuleClick?: (module: any) => void;
}

export const DebuggerSidebar: React.FC<DebuggerSidebarProps> = ({
  activeFunction,
  onFunctionClick,
}) => {
  const { system, ui, uiActions } = useAppState();
  const attachedProcess = system.attachedProcess;
  const selectedModule = ui.debuggerState.selectedModule;
  const serverInfo = system.serverInfo;
  const debuggerSidebarWidth = ui.debuggerSidebarWidth;
  const setDebuggerSidebarWidth = uiActions.setDebuggerSidebarWidth;
  const setSelectedModule = uiActions.setSelectedModule;
  const setMemoryAddress = uiActions.setMemoryAddress;

  // Break state for variable value display
  const isInBreakState = system.isInBreakState;
  const currentBreakAddress = system.currentBreakAddress;
  const currentRegisterData = system.currentRegisterData;

  // Selected module base address for offset calculation (from DWARF debug state)
  const dwarfModuleBase = useUIStore(
    (state) => state.toolsState?.debugState?.selectedModuleBase
  );

  // Source code level debug state
  const sourceCodeLevelDebug = ui.debuggerState.sourceCodeLevelDebug;
  const dwarfAnalysisResult = useUIStore(
    (state) => state.toolsState?.debugState?.analysisResult
  );
  const setPendingSourceJump = useUIStore(
    (state) => state.actions.setPendingSourceJump
  );

  // Responsive: detect compact height mode
  const isCompactHeight = useMediaQuery("(max-height: 800px)");
  const compactRowHeight = isCompactHeight ? 20 : 24;

  // Local state backed by Tauri cache (survives React StrictMode re-mounts)
  const [modules, setModulesLocal] = useState<ModuleInfo[]>([]);
  const [selectedModuleSymbols, setSelectedModuleSymbolsLocal] = useState<
    SymbolInfo[]
  >([]);
  const [ghidraFunctions, setGhidraFunctionsLocal] = useState<
    GhidraFunctionEntry[]
  >([]);
  const [ghidraDataItems, setGhidraDataItemsLocal] = useState<GhidraDataItem[]>(
    []
  );
  const [cacheInitialized, setCacheInitialized] = useState(false);

  // Track cached module path and process PID
  const cachedModulePathRef = useRef<string | null>(null);
  const cachedProcessPidRef = useRef<number | null>(null);

  // Initialize from Tauri cache on mount
  useEffect(() => {
    const initFromCache = async () => {
      try {
        const cache = await invoke<TauriSidebarCache>("get_sidebar_cache");
        console.log("[DebuggerSidebar] Loaded cache from Tauri:", {
          modules: cache?.modules?.length || 0,
          symbols: cache?.symbols?.length || 0,
          cachedModulePath: cache?.cached_module_path,
          cachedProcessPid: cache?.cached_process_pid,
        });
        if (cache) {
          setModulesLocal(cache.modules || []);
          // Convert Tauri cache format to frontend format
          setSelectedModuleSymbolsLocal(
            (cache.symbols || []).map(convertCachedSymbol)
          );
          setGhidraFunctionsLocal(cache.ghidra_functions || []);
          setGhidraDataItemsLocal(
            (cache.ghidra_data_items || []).map(convertCachedGhidraData)
          );
          cachedModulePathRef.current = cache.cached_module_path;
          cachedProcessPidRef.current = cache.cached_process_pid;
          // Also update the "lastLoaded" refs so we don't re-fetch on mount
          lastLoadedProcessPidRef.current = cache.cached_process_pid;
          lastLoadedModulePathRef.current = cache.cached_module_path;
          lastLoadedSymbolsModuleRef.current = cache.cached_module_path;
          lastLoadedDataModuleRef.current = cache.cached_module_path;
        }
      } catch (e) {
        console.error("Failed to load sidebar cache from Tauri:", e);
      }
      setCacheInitialized(true);
    };
    initFromCache();
  }, []);

  // Ghidra analysis hook
  const {
    isLibraryAnalyzed,
    getCachedFunctionsAsync,
    getData,
    serverRunning,
    serverProjectPath,
    getAnalyzedLibraryInfo,
    analyzedLibraries, // Added to track when analysis completes
  } = useGhidraAnalysis();

  const [showFunctionFilter, setShowFunctionFilter] = useLocalStorage<boolean>(
    "debugger-sidebar-show-function-filter",
    false
  );
  const [showVariableFilter, setShowVariableFilter] = useLocalStorage<boolean>(
    "debugger-sidebar-show-variable-filter",
    false
  );
  const [showDataFilter, setShowDataFilter] = useLocalStorage<boolean>(
    "debugger-sidebar-show-data-filter",
    false
  );
  const [isResizing, setIsResizing] = useState(false);

  // Panel expanded states - persisted to localStorage
  const [functionsExpanded, setFunctionsExpanded] = useLocalStorage<boolean>(
    "debugger-sidebar-functions-expanded",
    true
  );
  const [variablesExpanded, setVariablesExpanded] = useLocalStorage<boolean>(
    "debugger-sidebar-variables-expanded",
    true
  );
  const [dataExpanded, setDataExpanded] = useLocalStorage<boolean>(
    "debugger-sidebar-data-expanded",
    false
  );

  // Panel heights - persisted to localStorage
  const [functionsHeight, setFunctionsHeight] = useLocalStorage<number>(
    "debugger-sidebar-functions-height",
    200
  );
  const [variablesHeight, setVariablesHeight] = useLocalStorage<number>(
    "debugger-sidebar-variables-height",
    150
  );
  const [dataHeight, setDataHeight] = useLocalStorage<number>(
    "debugger-sidebar-data-height",
    200
  );

  // Source mode panel heights - persisted to localStorage
  const [sourceFilesHeight, setSourceFilesHeight] = useLocalStorage<number>(
    "debugger-sidebar-source-files-height",
    150
  );
  const [outlineHeight, setOutlineHeight] = useLocalStorage<number>(
    "debugger-sidebar-outline-height",
    200
  );
  const [sourceVariablesHeight, setSourceVariablesHeight] =
    useLocalStorage<number>("debugger-sidebar-source-variables-height", 150);

  // Panel resize state
  const [resizingPanel, setResizingPanel] = useState<string | null>(null);
  const resizeStartRef = useRef<{ y: number; height: number }>({
    y: 0,
    height: 0,
  });

  // Filter states - persisted to localStorage
  const [functionFilter, setFunctionFilter] = useLocalStorage<string>(
    "debugger-sidebar-function-filter",
    ""
  );
  const [variableFilter, setVariableFilter] = useLocalStorage<string>(
    "debugger-sidebar-variable-filter",
    ""
  );
  const [dataNameFilter, setDataNameFilter] = useLocalStorage<string>(
    "debugger-sidebar-data-name-filter",
    ""
  );
  const [dataTypeFilter, setDataTypeFilter] = useLocalStorage<string>(
    "debugger-sidebar-data-type-filter",
    ""
  );

  // Sort states - persisted to localStorage
  type ModuleSortField = "name" | "address" | "size";
  type FunctionSortField = "name" | "address" | "size";
  type VariableSortField = "name" | "address" | "size";
  type DataSortField = "name" | "address" | "type";

  const [moduleSortField] = useLocalStorage<ModuleSortField>(
    "debugger-sidebar-module-sort-field",
    "name"
  );
  const [moduleSortDir] = useLocalStorage<SortDirection>(
    "debugger-sidebar-module-sort-dir",
    "asc"
  );
  const [functionSortField, setFunctionSortField] =
    useLocalStorage<FunctionSortField>(
      "debugger-sidebar-function-sort-field",
      "name"
    );
  const [functionSortDir, setFunctionSortDir] = useLocalStorage<SortDirection>(
    "debugger-sidebar-function-sort-dir",
    "asc"
  );
  const [variableSortField, setVariableSortField] =
    useLocalStorage<VariableSortField>(
      "debugger-sidebar-variable-sort-field",
      "name"
    );
  const [variableSortDir, setVariableSortDir] = useLocalStorage<SortDirection>(
    "debugger-sidebar-variable-sort-dir",
    "asc"
  );

  // Sort handlers
  const handleFunctionSort = (field: FunctionSortField) => {
    if (functionSortField === field) {
      setFunctionSortDir(functionSortDir === "asc" ? "desc" : "asc");
    } else {
      setFunctionSortField(field);
      setFunctionSortDir("asc");
    }
  };

  const handleVariableSort = (field: VariableSortField) => {
    if (variableSortField === field) {
      setVariableSortDir(variableSortDir === "asc" ? "desc" : "asc");
    } else {
      setVariableSortField(field);
      setVariableSortDir("asc");
    }
  };

  // Data sort states
  const [dataSortField, setDataSortField] = useLocalStorage<DataSortField>(
    "debugger-sidebar-data-sort-field",
    "address"
  );
  const [dataSortDir, setDataSortDir] = useLocalStorage<SortDirection>(
    "debugger-sidebar-data-sort-dir",
    "asc"
  );

  const handleDataSort = (field: DataSortField) => {
    if (dataSortField === field) {
      setDataSortDir(dataSortDir === "asc" ? "desc" : "asc");
    } else {
      setDataSortField(field);
      setDataSortDir("asc");
    }
  };

  // Find current function based on break address
  const currentFunction = useMemo(() => {
    if (
      !isInBreakState ||
      !currentBreakAddress ||
      !dwarfAnalysisResult?.functions ||
      !dwarfModuleBase
    ) {
      return null;
    }

    // Parse break address
    let breakAddr: number;
    if (typeof currentBreakAddress === "string") {
      breakAddr = parseInt(currentBreakAddress.replace(/^0x/i, ""), 16);
    } else {
      breakAddr = currentBreakAddress;
    }

    // Calculate offset from module base
    const offset = breakAddr - dwarfModuleBase;

    // Find function containing this offset
    for (const func of dwarfAnalysisResult.functions) {
      if (func.low_pc !== null && func.high_pc !== null) {
        if (offset >= func.low_pc && offset < func.high_pc) {
          return func;
        }
      }
    }
    return null;
  }, [
    isInBreakState,
    currentBreakAddress,
    dwarfAnalysisResult?.functions,
    dwarfModuleBase,
  ]);

  // Cache for resolved variable values (async memory reads)
  const [resolvedVariableValues, setResolvedVariableValues] = useState<
    Map<string, string>
  >(new Map());
  const pendingReadsRef = useRef<Set<string>>(new Set());

  // Helper to get type size in bytes
  const getTypeSize = useCallback((typeName: string | null): number => {
    if (!typeName) return 8; // default to pointer size
    const t = typeName.toLowerCase();
    if (t.includes("char") && !t.includes("*")) return 1;
    if (t.includes("short")) return 2;
    if (t.includes("int") && !t.includes("long")) return 4;
    if (t.includes("long long") || t.includes("int64")) return 8;
    if (t.includes("long")) return 8; // ARM64: long is 8 bytes
    if (t.includes("float") && !t.includes("double")) return 4;
    if (t.includes("double")) return 8;
    if (t.includes("*") || t.includes("ptr")) return 8; // pointer
    return 4; // default to 4 bytes
  }, []);

  // Helper to format value based on type
  const formatValueByType = useCallback(
    (bytes: Uint8Array, typeName: string | null): string => {
      const t = (typeName || "").toLowerCase();
      const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.length);

      try {
        if (t.includes("char") && !t.includes("*")) {
          const val = view.getInt8(0);
          if (val >= 32 && val < 127) {
            return `'${String.fromCharCode(val)}' (${val})`;
          }
          return `${val}`;
        }
        if (t.includes("short")) {
          return `${view.getInt16(0, true)}`;
        }
        if (
          t.includes("unsigned") &&
          t.includes("int") &&
          !t.includes("long")
        ) {
          return `${view.getUint32(0, true)}`;
        }
        if (t.includes("int") && !t.includes("long")) {
          return `${view.getInt32(0, true)}`;
        }
        if (t.includes("float") && !t.includes("double")) {
          return `${view.getFloat32(0, true).toFixed(2)}`;
        }
        if (t.includes("double")) {
          return `${view.getFloat64(0, true).toFixed(4)}`;
        }
        if (t.includes("*") || t.includes("ptr")) {
          // Pointer - show as hex
          const ptr =
            bytes.length >= 8
              ? view.getBigUint64(0, true)
              : BigInt(view.getUint32(0, true));
          return `0x${ptr.toString(16)}`;
        }
        // Default: try as signed 32-bit or 64-bit
        if (bytes.length >= 8) {
          const val = view.getBigInt64(0, true);
          if (val >= -2147483648n && val <= 2147483647n) {
            return `${val}`;
          }
          return `0x${val.toString(16)}`;
        }
        return `${view.getInt32(0, true)}`;
      } catch {
        // Fallback: hex dump
        return `0x${Array.from(bytes)
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("")}`;
      }
    },
    []
  );

  // Calculate absolute address from location expression
  const calculateAddress = useCallback(
    (
      location: string,
      moduleBase: number
    ): { address: number; source: string } | null => {
      // Helper to get register value (case-insensitive)
      const getRegValue = (name: string): string | undefined => {
        if (!currentRegisterData) return undefined;
        return (
          currentRegisterData[name] ||
          currentRegisterData[name.toUpperCase()] ||
          currentRegisterData[name.toLowerCase()]
        );
      };

      // Handle address locations (e.g., "DW_OP_addr 0x1234") - relative to module base
      const addrMatch = location.match(/DW_OP_addr\s*(0x[0-9a-fA-F]+|\d+)/);
      if (addrMatch) {
        const relativeAddr =
          parseInt(addrMatch[1], 16) || parseInt(addrMatch[1], 10);
        return { address: moduleBase + relativeAddr, source: "addr" };
      }

      // Handle register offset (e.g., "DW_OP_breg31 -8" = sp+offset)
      const bregMatch = location.match(/DW_OP_breg(\d+)\s*([-+]?\d+)/);
      if (bregMatch) {
        const regNum = parseInt(bregMatch[1], 10);
        const offset = parseInt(bregMatch[2], 10);
        // Get display name
        const regName =
          regNum === 31 ? "sp" : regNum === 29 ? "fp" : `x${regNum}`;
        // Try to get register value (case-insensitive)
        const regValue = getRegValue(regName) || getRegValue(`x${regNum}`);
        if (regValue) {
          const regAddr = parseInt(regValue.replace(/^0x/i, ""), 16);
          return {
            address: regAddr + offset,
            source: `${regName}${offset >= 0 ? "+" : ""}${offset}`,
          };
        }
        return null;
      }

      // Handle frame base relative locations (e.g., "DW_OP_fbreg -8")
      const fbregMatch = location.match(/DW_OP_fbreg\s*([-+]?\d+)/);
      if (fbregMatch) {
        const offset = parseInt(fbregMatch[1], 10);
        // Try fp, x29, or sp as frame base (case-insensitive)
        const fpValue =
          getRegValue("fp") || getRegValue("x29") || getRegValue("sp");
        if (fpValue) {
          const fpAddr = parseInt(fpValue.replace(/^0x/i, ""), 16);
          return {
            address: fpAddr + offset,
            source: `fp${offset >= 0 ? "+" : ""}${offset}`,
          };
        }
        return null;
      }

      return null;
    },
    [currentRegisterData]
  );

  // Async read variable value from memory
  useEffect(() => {
    if (!isInBreakState || !dwarfModuleBase || !dwarfAnalysisResult) {
      setResolvedVariableValues(new Map());
      pendingReadsRef.current.clear();
      return;
    }

    // Check if register data is available (not empty)
    const hasRegisterData =
      currentRegisterData && Object.keys(currentRegisterData).length > 0;

    // Log for debugging
    console.log("[Variable] useEffect triggered:", {
      isInBreakState,
      dwarfModuleBase,
      hasRegisterData,
      registerKeys: currentRegisterData
        ? Object.keys(currentRegisterData).slice(0, 5)
        : [],
    });

    // Helper to check if type is a string pointer
    const isStringPointer = (typeName: string | null): boolean => {
      if (!typeName) return false;
      const t = typeName.toLowerCase();
      return (
        t.includes("char*") ||
        t.includes("char *") ||
        t === "const char*" ||
        t === "const char *" ||
        t.includes("char const*") ||
        t.includes("char const *")
      );
    };

    // Helper to read null-terminated string from memory
    const readStringFromMemory = async (
      api: ReturnType<typeof getApiClient>,
      address: number,
      maxLength: number = 64
    ): Promise<string | null> => {
      try {
        const data = await api.readMemory(
          `0x${address.toString(16)}`,
          maxLength,
          true
        );
        const bytes = new Uint8Array(data);
        // Find null terminator
        let end = bytes.indexOf(0);
        if (end === -1) end = maxLength;
        // Convert to string (ASCII)
        const str = String.fromCharCode(...bytes.slice(0, Math.min(end, 32)));
        // Check if it looks like a valid string
        if (str.length > 0 && /^[\x20-\x7E\t\n\r]+$/.test(str)) {
          return str.length > 24 ? str.substring(0, 24) + "…" : str;
        }
        return null;
      } catch {
        return null;
      }
    };

    const readVariableValue = async (variable: any) => {
      const key = `${variable.name}:${variable.location}`;
      if (pendingReadsRef.current.has(key) || resolvedVariableValues.has(key)) {
        return;
      }

      const location = variable.location;
      if (!location) {
        // No location info - show N/A
        setResolvedVariableValues((prev) => new Map(prev).set(key, "<no loc>"));
        return;
      }

      // Handle register locations (e.g., "DW_OP_reg0" = x0) - direct register value
      const regMatch = location.match(/DW_OP_reg(\d+)/);
      if (regMatch) {
        const regNum = parseInt(regMatch[1], 10);
        const regName =
          regNum === 31 ? "sp" : regNum === 29 ? "fp" : `x${regNum}`;
        if (!currentRegisterData) {
          setResolvedVariableValues((prev) =>
            new Map(prev).set(key, `[${regName}]`)
          );
          return;
        }
        // Case-insensitive register lookup
        const value =
          currentRegisterData[regName] ||
          currentRegisterData[regName.toUpperCase()] ||
          currentRegisterData[`X${regNum}`] ||
          currentRegisterData[`x${regNum}`];
        if (value !== undefined) {
          // If it's a string pointer in a register, try to read the string
          if (isStringPointer(variable.type_name)) {
            const api = getApiClient();
            const addr = parseInt(value.replace(/^0x/i, ""), 16);
            if (addr > 0 && addr < 0xffffffffffff) {
              pendingReadsRef.current.add(key);
              const str = await readStringFromMemory(api, addr);
              pendingReadsRef.current.delete(key);
              if (str) {
                setResolvedVariableValues((prev) =>
                  new Map(prev).set(key, `"${str}"`)
                );
                return;
              }
            }
          }
          setResolvedVariableValues((prev) => new Map(prev).set(key, value));
          return;
        } else {
          // Register not found in data
          setResolvedVariableValues((prev) =>
            new Map(prev).set(key, `[${regName}?]`)
          );
          return;
        }
      }

      // Handle constant values
      const constMatch = location.match(/DW_OP_const[us]\s*(\d+)/);
      if (constMatch) {
        setResolvedVariableValues((prev) =>
          new Map(prev).set(key, constMatch[1])
        );
        return;
      }

      // Calculate address for memory read
      const addrInfo = calculateAddress(location, dwarfModuleBase);
      if (!addrInfo) {
        // Could not calculate address - show location info as fallback
        // Extract first operation for display
        const opMatch = location.match(/DW_OP_\w+/);
        if (opMatch) {
          setResolvedVariableValues((prev) =>
            new Map(prev).set(key, `[${opMatch[0]}]`)
          );
        } else {
          setResolvedVariableValues((prev) => new Map(prev).set(key, `[?]`));
        }
        return;
      }

      pendingReadsRef.current.add(key);

      try {
        const api = getApiClient();

        // For string pointers, read pointer value first, then the string
        if (isStringPointer(variable.type_name)) {
          const ptrData = await api.readMemory(
            `0x${addrInfo.address.toString(16)}`,
            8,
            true
          );
          const ptrBytes = new Uint8Array(ptrData);
          const view = new DataView(
            ptrBytes.buffer,
            ptrBytes.byteOffset,
            ptrBytes.length
          );
          const strAddr = Number(view.getBigUint64(0, true));

          if (strAddr > 0 && strAddr < 0xffffffffffff) {
            const str = await readStringFromMemory(api, strAddr);
            if (str) {
              setResolvedVariableValues((prev) =>
                new Map(prev).set(key, `"${str}"`)
              );
              return;
            }
          }
          // Fallback: show pointer value
          setResolvedVariableValues((prev) =>
            new Map(prev).set(key, `0x${strAddr.toString(16)}`)
          );
          return;
        }

        const size = getTypeSize(variable.type_name);
        const data = await api.readMemory(
          `0x${addrInfo.address.toString(16)}`,
          size,
          true
        );
        const bytes = new Uint8Array(data);
        const formatted = formatValueByType(bytes, variable.type_name);
        setResolvedVariableValues((prev) => new Map(prev).set(key, formatted));
      } catch (err) {
        console.error(`[Variable] Failed to read ${variable.name}:`, err);
        // Show address info as fallback
        setResolvedVariableValues((prev) =>
          new Map(prev).set(key, `[${addrInfo.source}]`)
        );
      } finally {
        pendingReadsRef.current.delete(key);
      }
    };

    // Collect all variables including parameters
    const globalVars = dwarfAnalysisResult.variables || [];
    const functionVars =
      dwarfAnalysisResult.functions?.flatMap((f: any) => [
        ...(f.parameters || []),
        ...(f.variables || []),
      ]) || [];
    const allVariables = [...globalVars, ...functionVars];

    // Read values for all variables (with small delay to batch)
    const timeout = setTimeout(() => {
      allVariables.forEach((v) => readVariableValue(v));
    }, 100);

    return () => clearTimeout(timeout);
  }, [
    isInBreakState,
    dwarfModuleBase,
    dwarfAnalysisResult,
    currentRegisterData,
    calculateAddress,
    getTypeSize,
    formatValueByType,
  ]);

  // Helper to get resolved value for a variable
  const getResolvedValue = useCallback(
    (variable: any): string | null => {
      if (!isInBreakState || !variable.location) return null;
      const key = `${variable.name}:${variable.location}`;
      return resolvedVariableValues.get(key) || null;
    },
    [isInBreakState, resolvedVariableValues]
  );

  // Get stable module path string for dependency tracking
  const selectedModulePath =
    selectedModule?.path || selectedModule?.modulename || null;
  const selectedModuleBase = selectedModule?.base;

  // Track the last loaded module path to avoid clearing ghidra functions on tab switch
  const lastLoadedModulePathRef = useRef<string | null>(
    cachedModulePathRef.current
  );
  // Track the last loaded symbols/data module path to avoid reloading on tab switch
  const lastLoadedSymbolsModuleRef = useRef<string | null>(
    cachedModulePathRef.current
  );
  const lastLoadedDataModuleRef = useRef<string | null>(
    cachedModulePathRef.current
  );
  // Track the last loaded process PID to avoid reloading modules on tab switch
  const lastLoadedProcessPidRef = useRef<number | null>(
    cachedProcessPidRef.current
  );
  const [loading, setLoading] = useState(false);
  const [loadingSymbols, setLoadingSymbols] = useState(false);
  const [loadingData, setLoadingData] = useState(false);

  // Functions to update both local state and Tauri cache
  const setModules = useCallback(
    (mods: ModuleInfo[]) => {
      setModulesLocal(mods);
      if (attachedProcess?.pid) {
        invoke("set_sidebar_modules", {
          modules: mods.map((m) => ({
            modulename: m.modulename,
            base: m.base,
            size: m.size,
            path: m.path,
            is_64bit: m.is_64bit,
          })),
          processPid: attachedProcess.pid,
        }).catch((e) =>
          console.error("Failed to save modules to Tauri cache:", e)
        );
        lastLoadedProcessPidRef.current = attachedProcess.pid;
        cachedProcessPidRef.current = attachedProcess.pid;
      }
    },
    [attachedProcess?.pid]
  );

  const setSelectedModuleSymbols = useCallback(
    (symbols: SymbolInfo[]) => {
      setSelectedModuleSymbolsLocal(symbols);
      if (selectedModulePath) {
        invoke("set_sidebar_symbols", {
          symbols: symbols.map((s) => ({
            address: s.address,
            name: s.name,
            size: s.size,
            symbol_type: s.type,
            scope: s.scope,
            module_base: s.module_base,
            file_name: s.file_name,
            line_number: s.line_number,
            is_external: s.is_external,
            is_private_external: s.is_private_external,
            is_weak_def: s.is_weak_def,
            is_weak_ref: s.is_weak_ref,
            is_thumb: s.is_thumb,
            section_index: s.section_index,
            library_ordinal: s.library_ordinal,
          })),
          modulePath: selectedModulePath,
        }).catch((e) =>
          console.error("Failed to save symbols to Tauri cache:", e)
        );
        lastLoadedSymbolsModuleRef.current = selectedModulePath;
        cachedModulePathRef.current = selectedModulePath;
      }
    },
    [selectedModulePath]
  );

  const setGhidraFunctions = useCallback(
    (functions: GhidraFunctionEntry[]) => {
      setGhidraFunctionsLocal(functions);
      if (selectedModulePath) {
        invoke("set_sidebar_ghidra_functions", {
          functions: functions.map((f) => ({
            name: f.name,
            address: f.address,
            size: f.size,
          })),
          modulePath: selectedModulePath,
        }).catch((e) =>
          console.error("Failed to save ghidra functions to Tauri cache:", e)
        );
        lastLoadedModulePathRef.current = selectedModulePath;
        cachedModulePathRef.current = selectedModulePath;
      }
    },
    [selectedModulePath]
  );

  const setGhidraDataItems = useCallback(
    (items: GhidraDataItem[]) => {
      setGhidraDataItemsLocal(items);
      if (selectedModulePath) {
        invoke("set_sidebar_ghidra_data", {
          dataItems: items.map((d) => ({
            address: d.address,
            name: d.name,
            data_type: d.type,
            category: d.category,
            size: d.size,
            value: d.value,
          })),
          modulePath: selectedModulePath,
        }).catch((e) =>
          console.error("Failed to save ghidra data to Tauri cache:", e)
        );
        lastLoadedDataModuleRef.current = selectedModulePath;
        cachedModulePathRef.current = selectedModulePath;
      }
    },
    [selectedModulePath]
  );

  const clearSidebarCache = useCallback(async () => {
    setModulesLocal([]);
    setSelectedModuleSymbolsLocal([]);
    setGhidraFunctionsLocal([]);
    setGhidraDataItemsLocal([]);
    cachedModulePathRef.current = null;
    cachedProcessPidRef.current = null;
    lastLoadedModulePathRef.current = null;
    lastLoadedSymbolsModuleRef.current = null;
    lastLoadedDataModuleRef.current = null;
    lastLoadedProcessPidRef.current = null;
    try {
      await invoke("clear_sidebar_cache");
    } catch (e) {
      console.error("Failed to clear Tauri sidebar cache:", e);
    }
  }, []);

  const sidebarRef = useRef<HTMLDivElement>(null);

  const [dragState, setDragState] = useState<{
    isDragging: boolean;
    startX: number;
    startWidth: number;
  }>({ isDragging: false, startX: 0, startWidth: 0 });

  // Load modules when process is attached
  useEffect(() => {
    // Wait for cache to be initialized from Tauri
    if (!cacheInitialized) return;

    const loadModules = async () => {
      if (!attachedProcess) {
        setModulesLocal([]);
        setSelectedModuleSymbolsLocal([]);
        return;
      }

      // Check if we already have cached modules for this process using ref
      if (lastLoadedProcessPidRef.current === attachedProcess.pid) {
        // Already loaded for this process, skip
        return;
      }

      // Clear cache if process changed
      if (
        lastLoadedProcessPidRef.current !== null &&
        lastLoadedProcessPidRef.current !== attachedProcess.pid
      ) {
        await clearSidebarCache();
      }

      try {
        setLoading(true);
        const apiClient = getApiClient();
        const response = await apiClient.enumerateModules();
        if (response.data) {
          setModules(response.data.modules);
        }
      } catch (error) {
        console.error("Failed to load modules:", error);
        setModulesLocal([]);
      } finally {
        setLoading(false);
      }
    };

    loadModules();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [attachedProcess?.pid, cacheInitialized]);

  // Clear cached data when module actually changes (different path)
  // Only run after cache is initialized to avoid clearing restored data
  useEffect(() => {
    if (!cacheInitialized) return;

    if (
      selectedModulePath &&
      lastLoadedSymbolsModuleRef.current !== null &&
      lastLoadedSymbolsModuleRef.current !== selectedModulePath
    ) {
      // Module changed - clear old data (local state only, don't persist empty)
      setSelectedModuleSymbolsLocal([]);
      setGhidraFunctionsLocal([]);
      setGhidraDataItemsLocal([]);
      lastLoadedSymbolsModuleRef.current = null;
      lastLoadedDataModuleRef.current = null;
      lastLoadedModulePathRef.current = null;
    }
  }, [selectedModulePath, cacheInitialized]);

  // Load symbols when module is selected
  useEffect(() => {
    // Wait for cache to be initialized from Tauri
    if (!cacheInitialized) return;

    const loadSymbols = async () => {
      console.log("[DebuggerSidebar] loadSymbols check:", {
        selectedModulePath,
        lastLoadedSymbolsModuleRef: lastLoadedSymbolsModuleRef.current,
        hasSelectedModule: !!selectedModule,
      });

      if (!selectedModule || !selectedModulePath) {
        // Don't clear data when module becomes null (tab switch)
        // The data will be maintained in Tauri cache until a new module is explicitly selected
        console.log("[DebuggerSidebar] loadSymbols: no module, skipping");
        return;
      }

      // Skip if this module's symbols are already loaded
      if (lastLoadedSymbolsModuleRef.current === selectedModulePath) {
        console.log("[DebuggerSidebar] loadSymbols: already loaded, skipping");
        return;
      }

      console.log("[DebuggerSidebar] loadSymbols: fetching from API");
      const currentModulePath = selectedModulePath;

      // If module changed, clear ghidra functions (local only)
      if (lastLoadedModulePathRef.current !== currentModulePath) {
        setGhidraFunctionsLocal([]);
        lastLoadedModulePathRef.current = currentModulePath;
      }

      try {
        setLoadingSymbols(true);
        const apiClient = getApiClient();
        const symbols =
          await apiClient.enumerateSymbolsForModule(selectedModule);
        setSelectedModuleSymbols(symbols);

        // Also load Ghidra functions if library is analyzed
        if (currentModulePath && isLibraryAnalyzed(currentModulePath)) {
          const ghidraFuncs = await getCachedFunctionsAsync(currentModulePath);
          if (ghidraFuncs) {
            setGhidraFunctions(ghidraFuncs);
          }
          // Don't set to empty if getCachedFunctionsAsync returns null - keep previous
        }
        // Don't clear ghidra functions if not analyzed - keep previous from cache
      } catch (error) {
        console.error(
          "Failed to load symbols for module:",
          selectedModule.name,
          error
        );
        // Don't clear data on error - keep previous from cache
      } finally {
        setLoadingSymbols(false);
      }
    };

    loadSymbols();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    selectedModulePath,
    selectedModuleBase,
    analyzedLibraries,
    cacheInitialized,
  ]);

  // Load Ghidra data items when module is selected and server is running
  useEffect(() => {
    // Wait for cache to be initialized from Tauri
    if (!cacheInitialized) return;

    const loadDataItems = async () => {
      if (!selectedModule || !selectedModulePath) {
        // Don't clear data when module becomes null (tab switch)
        return;
      }

      const modulePath = selectedModulePath;
      if (!isLibraryAnalyzed(modulePath)) {
        // Not analyzed, keep any existing data
        return;
      }

      // Skip if this module's data is already loaded
      if (lastLoadedDataModuleRef.current === modulePath) {
        return;
      }

      // Check if Ghidra server is running for this library
      const libInfo = getAnalyzedLibraryInfo(modulePath);
      if (
        !libInfo ||
        !serverRunning ||
        serverProjectPath !== libInfo.projectPath
      ) {
        // Server not running or project mismatch, keep existing data
        return;
      }

      try {
        setLoadingData(true);
        const result = await getData(modulePath);
        if (result && result.success && result.data) {
          setGhidraDataItems(result.data);
          lastLoadedDataModuleRef.current = modulePath;
        }
        // Don't clear on failure - keep previous data
      } catch (error) {
        console.error("Failed to load data items:", error);
        // Don't clear on error - keep previous data
      } finally {
        setLoadingData(false);
      }
    };

    loadDataItems();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedModulePath, serverRunning, serverProjectPath, cacheInitialized]);

  // Filter functions and variables from symbols
  // Darwin (iOS/macOS): type is "SECT", "ABS", etc., use scope and name heuristics
  // Linux/Android: type is "Function", "Public", "Object", etc.
  // Detect Darwin by serverInfo OR by symbol type (SECT is Darwin-specific)
  const isDarwin = useMemo(() => {
    // First check serverInfo
    if (serverInfo?.target_os === "ios" || serverInfo?.target_os === "macos") {
      return true;
    }
    // Fallback: detect from symbol types (SECT is Darwin-specific)
    if (selectedModuleSymbols.length > 0) {
      const hasDarwinSymbols = selectedModuleSymbols.some(
        (s) => s.type === "SECT" || s.type === "ABS" || s.type === "INDR"
      );
      return hasDarwinSymbols;
    }
    return false;
  }, [serverInfo?.target_os, selectedModuleSymbols]);

  const symbolFunctions = useMemo(() => {
    const result = selectedModuleSymbols.filter((symbol) => {
      if (!symbol.name) return false;

      if (isDarwin) {
        // Darwin: Functions typically have "SECT" type and names starting with underscore
        // Exclude symbols that look like data (ending with common data suffixes)
        const name = symbol.name;

        // These are likely data, not functions
        const isLikelyData =
          name.startsWith("_OBJC_CLASS_$") ||
          name.startsWith("_OBJC_METACLASS_$") ||
          name.startsWith("_OBJC_IVAR_$") ||
          name.startsWith("__OBJC_$_") ||
          name.startsWith("__OBJC_LABEL_") ||
          name.includes("_$classMetadata") ||
          name.includes("_$nominal") ||
          name.includes("_$type_metadata") ||
          name.endsWith("Wvd") || // Swift witness table
          name.endsWith("WV") || // Swift value witness
          (name.endsWith("N") && name.includes("_$s")); // Swift type metadata

        if (isLikelyData) return false;

        // Functions are typically in SECT type with Global, Local, or Private scope
        return (
          symbol.type === "SECT" &&
          (symbol.scope === "Global" ||
            symbol.scope === "Local" ||
            symbol.scope === "Private")
        );
      } else {
        // Linux/Android: Use explicit type field
        return symbol.type === "Function" || symbol.type === "Public";
      }
    });

    return result;
  }, [selectedModuleSymbols, isDarwin]);

  const variables = useMemo(() => {
    return selectedModuleSymbols.filter(
      (symbol) => symbol.name && !symbolFunctions.includes(symbol)
    );
  }, [selectedModuleSymbols, symbolFunctions]);

  // Combined functions: symbol functions + ghidra functions (deduplicated)
  const combinedFunctions = useMemo((): CombinedFunction[] => {
    const result: CombinedFunction[] = [];
    const addressMap = new Map<string, CombinedFunction>();

    // Add symbol functions
    for (const func of symbolFunctions) {
      const normalizedAddr = func.address.toLowerCase();
      addressMap.set(normalizedAddr, {
        name: func.name,
        address: func.address,
        size: func.size || 0,
        source: "symbol",
      });
    }

    // Add/merge Ghidra functions
    const moduleBase = selectedModule?.base || 0;
    for (const gFunc of ghidraFunctions) {
      // Ghidra address is offset from base, convert to absolute
      const absoluteAddr =
        moduleBase + parseInt(gFunc.address.replace("0x", ""), 16);
      const addrHex = `0x${absoluteAddr.toString(16).toUpperCase()}`;
      const normalizedAddr = addrHex.toLowerCase();

      const existing = addressMap.get(normalizedAddr);
      if (existing) {
        // Function exists in both sources
        existing.source = "both";
        // Prefer Ghidra name if different (usually more meaningful)
        if (gFunc.name !== existing.name && !gFunc.name.startsWith("FUN_")) {
          existing.name = gFunc.name;
        }
        // Use Ghidra size if available and larger
        if (gFunc.size > existing.size) {
          existing.size = gFunc.size;
        }
      } else {
        addressMap.set(normalizedAddr, {
          name: gFunc.name,
          address: addrHex,
          size: gFunc.size || 0,
          source: "ghidra",
        });
      }
    }

    result.push(...addressMap.values());
    return result;
  }, [symbolFunctions, ghidraFunctions, selectedModule?.base]);

  // Filtered and sorted modules
  const filteredModules = useMemo(() => {
    let result = [...modules];

    // Apply sort by field
    result.sort((a, b) => {
      let cmp = 0;
      if (moduleSortField === "name") {
        const nameA = getDisplayModuleName(a.modulename).toLowerCase();
        const nameB = getDisplayModuleName(b.modulename).toLowerCase();
        cmp = nameA.localeCompare(nameB);
      } else if (moduleSortField === "address") {
        const addrA = (a.base_address || "").toLowerCase();
        const addrB = (b.base_address || "").toLowerCase();
        cmp = addrA.localeCompare(addrB);
      } else {
        cmp = (a.size || 0) - (b.size || 0);
      }
      return moduleSortDir === "asc" ? cmp : -cmp;
    });

    return result;
  }, [modules, moduleSortField, moduleSortDir]);

  // Filtered and sorted functions
  const filteredFunctions = useMemo(() => {
    let result = [...combinedFunctions];

    // Apply filter
    if (functionFilter.trim()) {
      const filter = functionFilter.toLowerCase();
      result = result.filter(
        (f) =>
          f.name.toLowerCase().includes(filter) ||
          f.address.toLowerCase().includes(filter)
      );
    }

    // Apply sort
    result.sort((a, b) => {
      let cmp = 0;
      if (functionSortField === "name") {
        cmp = a.name.toLowerCase().localeCompare(b.name.toLowerCase());
      } else if (functionSortField === "address") {
        // Sort by address numerically
        const addrA = parseInt(a.address.replace("0x", ""), 16);
        const addrB = parseInt(b.address.replace("0x", ""), 16);
        cmp = addrA - addrB;
      } else {
        // Sort by size
        cmp = (a.size || 0) - (b.size || 0);
      }
      return functionSortDir === "asc" ? cmp : -cmp;
    });

    return result;
  }, [combinedFunctions, functionFilter, functionSortField, functionSortDir]);

  // Filtered and sorted variables
  const filteredVariables = useMemo(() => {
    let result = [...variables];

    // Apply filter
    if (variableFilter.trim()) {
      const filter = variableFilter.toLowerCase();
      result = result.filter(
        (v) =>
          v.name.toLowerCase().includes(filter) ||
          v.address.toLowerCase().includes(filter)
      );
    }

    // Apply sort
    result.sort((a, b) => {
      let cmp = 0;
      if (variableSortField === "name") {
        cmp = a.name.toLowerCase().localeCompare(b.name.toLowerCase());
      } else if (variableSortField === "address") {
        // Sort by address numerically
        const addrA = parseInt(a.address.replace("0x", ""), 16);
        const addrB = parseInt(b.address.replace("0x", ""), 16);
        cmp = addrA - addrB;
      } else {
        // Sort by size
        cmp = (a.size || 0) - (b.size || 0);
      }
      return variableSortDir === "asc" ? cmp : -cmp;
    });

    return result;
  }, [variables, variableFilter, variableSortField, variableSortDir]);

  // Unique data types for dropdown filter
  const uniqueDataTypes = useMemo(() => {
    const types = new Set<string>();
    ghidraDataItems.forEach((d) => {
      if (d.type) types.add(d.type);
    });
    return Array.from(types).sort();
  }, [ghidraDataItems]);

  // Filtered and sorted data items (limit to 50000 items)
  const filteredDataItems = useMemo(() => {
    let result = [...ghidraDataItems].slice(0, 50000);

    // Apply name filter
    if (dataNameFilter.trim()) {
      const filter = dataNameFilter.toLowerCase();
      result = result.filter(
        (d) => d.name && d.name.toLowerCase().includes(filter)
      );
    }

    // Apply type filter (exact match for dropdown)
    if (dataTypeFilter) {
      result = result.filter((d) => d.type === dataTypeFilter);
    }

    // Apply sort
    result.sort((a, b) => {
      let cmp = 0;
      if (dataSortField === "name") {
        const nameA = (a.name || a.address).toLowerCase();
        const nameB = (b.name || b.address).toLowerCase();
        cmp = nameA.localeCompare(nameB);
      } else if (dataSortField === "address") {
        // Sort by address numerically
        const addrA = parseInt(a.address.replace("0x", ""), 16);
        const addrB = parseInt(b.address.replace("0x", ""), 16);
        cmp = addrA - addrB;
      } else {
        // Sort by type
        cmp = a.type.toLowerCase().localeCompare(b.type.toLowerCase());
      }
      return dataSortDir === "asc" ? cmp : -cmp;
    });

    return result;
  }, [
    ghidraDataItems,
    dataNameFilter,
    dataTypeFilter,
    dataSortField,
    dataSortDir,
  ]);

  // Column definitions for VirtualizedTable
  const functionColumns = useMemo(
    (): ColumnDef<CombinedFunction>[] => [
      {
        key: "name",
        label: "Name",
        width: 50,
        render: (f: CombinedFunction) => f.name,
        getCellStyle: (f: CombinedFunction) => ({
          color: f.source === "ghidra" ? accentColors.blue : accentColors.green,
        }),
      },
      {
        key: "address",
        label: "Address",
        width: 30,
        render: (f: CombinedFunction) => f.address,
        getCellStyle: () => ({
          fontFamily: 'Consolas, "Courier New", monospace',
          color: "#9cdcfe",
        }),
      },
      {
        key: "size",
        label: "Size",
        width: 20,
        align: "right",
        render: (f: CombinedFunction) =>
          f.size > 0
            ? f.size >= 1024
              ? `${(f.size / 1024).toFixed(1)}KB`
              : `${f.size}B`
            : "-",
        getCellStyle: () => ({ color: "#b5cea8" }),
      },
    ],
    []
  );

  const variableColumns = useMemo(
    (): ColumnDef<SymbolInfo>[] => [
      {
        key: "name",
        label: "Name",
        width: 50,
        render: (v: SymbolInfo) => v.name,
        getCellStyle: () => ({ color: accentColors.orange }),
      },
      {
        key: "address",
        label: "Address",
        width: 30,
        render: (v: SymbolInfo) => v.address,
        getCellStyle: () => ({
          fontFamily: 'Consolas, "Courier New", monospace',
          color: "#9cdcfe",
        }),
      },
      {
        key: "size",
        label: "Size",
        width: 20,
        align: "right",
        render: (v: SymbolInfo) =>
          v.size
            ? v.size >= 1024
              ? `${(v.size / 1024).toFixed(1)}KB`
              : `${v.size}B`
            : "-",
        getCellStyle: () => ({ color: "#b5cea8" }),
      },
    ],
    []
  );

  // Helper function to convert Ghidra offset to absolute address
  const getAbsoluteDataAddress = useCallback(
    (offset: string): string => {
      const moduleBase = selectedModule?.base || 0;
      const offsetValue = parseInt(offset.replace(/0x/i, ""), 16);
      const absoluteAddr = moduleBase + offsetValue;
      return `0x${absoluteAddr.toString(16).toUpperCase()}`;
    },
    [selectedModule?.base]
  );

  const dataColumns = useMemo(
    (): ColumnDef<GhidraDataItem>[] => [
      {
        key: "name",
        label: "Name",
        width: 40,
        render: (d: GhidraDataItem) =>
          d.name ||
          (d.value
            ? `"${d.value.substring(0, 20)}${d.value.length > 20 ? "..." : ""}"`
            : `DAT_${d.address}`),
        getCellStyle: (d: GhidraDataItem) => ({
          color:
            d.category === "string"
              ? accentColors.green
              : d.category === "pointer"
                ? accentColors.purple
                : accentColors.yellow,
          fontStyle: d.name ? "normal" : "italic",
        }),
      },
      {
        key: "address",
        label: "Address",
        width: 30,
        render: (d: GhidraDataItem) => getAbsoluteDataAddress(d.address),
        getCellStyle: () => ({
          fontFamily: 'Consolas, "Courier New", monospace',
          color: "#9cdcfe",
        }),
      },
      {
        key: "type",
        label: "Type",
        width: 30,
        render: (d: GhidraDataItem) => d.type,
        getCellStyle: (d: GhidraDataItem) => ({
          color:
            d.category === "string"
              ? "#ce9178"
              : d.category === "pointer"
                ? "#c586c0"
                : "#4ec9b0",
        }),
      },
    ],
    []
  );

  const handleMouseDown = useCallback(
    (e: React.MouseEvent) => {
      e.preventDefault();
      e.stopPropagation();
      console.log(
        "DebuggerSidebar: Mouse down on resize handle, current width:",
        debuggerSidebarWidth
      );

      const startX = e.clientX;
      const startWidth = debuggerSidebarWidth;

      setDragState({ isDragging: true, startX, startWidth });
      setIsResizing(true);

      console.log(
        `DebuggerSidebar: Starting resize - startX: ${startX}, startWidth: ${startWidth}`
      );
    },
    [debuggerSidebarWidth]
  );

  // Global mouse event handlers
  useEffect(() => {
    if (!dragState.isDragging) return;

    const handleMouseMove = (e: MouseEvent) => {
      e.preventDefault();

      const deltaX = e.clientX - dragState.startX;
      const newWidth = dragState.startWidth + deltaX;
      const minWidth = 200;
      const maxWidth = 800;

      console.log(
        `DebuggerSidebar: Mouse move - clientX: ${e.clientX}, deltaX: ${deltaX}, newWidth: ${newWidth}`
      );

      if (newWidth >= minWidth && newWidth <= maxWidth) {
        setDebuggerSidebarWidth(newWidth);
        console.log(`DebuggerSidebar: Setting sidebar width to ${newWidth}`);
      } else {
        console.log(
          `DebuggerSidebar: Width ${newWidth} outside bounds (${minWidth}-${maxWidth})`
        );
      }
    };

    const handleMouseUp = (e: MouseEvent) => {
      e.preventDefault();
      console.log("DebuggerSidebar: Mouse up, ending resize");
      setDragState({ isDragging: false, startX: 0, startWidth: 0 });
      setIsResizing(false);
    };

    document.addEventListener("mousemove", handleMouseMove, { passive: false });
    document.addEventListener("mouseup", handleMouseUp, { passive: false });
    document.body.style.cursor = "col-resize";
    document.body.style.userSelect = "none";

    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    };
  }, [dragState, setDebuggerSidebarWidth]);

  // Panel height resize handlers
  const handlePanelResizeStart = useCallback(
    (panelName: string, currentHeight: number) => (e: React.MouseEvent) => {
      e.preventDefault();
      e.stopPropagation();
      setResizingPanel(panelName);
      resizeStartRef.current = { y: e.clientY, height: currentHeight };
    },
    []
  );

  useEffect(() => {
    if (!resizingPanel) return;

    const handleMouseMove = (e: MouseEvent) => {
      e.preventDefault();
      const deltaY = e.clientY - resizeStartRef.current.y;

      // Calculate available height for all panels
      // Fixed elements: Modules (~80px), panel headers (~32px each for expanded), dividers (~6px each)
      const sidebarHeight = sidebarRef.current?.clientHeight || 600;

      // Calculate fixed height based on which panels are expanded
      // Modules section height depends on compact mode
      const modulesHeight = isCompactHeight ? 60 : 80;
      const headerHeight = isCompactHeight ? 28 : 32;
      const dividerHeight = isCompactHeight ? 4 : 6;
      const minPanelHeight = isCompactHeight ? 30 : 50;

      // Count expanded panels and their headers
      const numHeaders = 3; // Functions, Variables, Data always have headers
      const numDividers =
        (functionsExpanded ? 1 : 0) + (variablesExpanded ? 1 : 0);

      const fixedHeight =
        modulesHeight + numHeaders * headerHeight + numDividers * dividerHeight;
      const availableHeight = sidebarHeight - fixedHeight;

      // Only subtract heights of OTHER expanded panels
      let maxHeight: number;
      switch (resizingPanel) {
        case "functions":
          // Max height = available - (other expanded panels' heights)
          maxHeight = Math.max(
            minPanelHeight,
            availableHeight -
              (variablesExpanded ? variablesHeight : 0) -
              (dataExpanded ? dataHeight : 0)
          );
          break;
        case "variables":
          // Max height = available - (other expanded panels' heights)
          maxHeight = Math.max(
            minPanelHeight,
            availableHeight -
              (functionsExpanded ? functionsHeight : 0) -
              (dataExpanded ? dataHeight : 0)
          );
          break;
        case "data":
          // Max height = available - (other expanded panels' heights)
          maxHeight = Math.max(
            minPanelHeight,
            availableHeight -
              (functionsExpanded ? functionsHeight : 0) -
              (variablesExpanded ? variablesHeight : 0)
          );
          break;
        case "sourceFiles":
          maxHeight = Math.max(
            minPanelHeight,
            availableHeight - outlineHeight - sourceVariablesHeight
          );
          break;
        case "outline":
          maxHeight = Math.max(
            minPanelHeight,
            availableHeight - sourceFilesHeight - sourceVariablesHeight
          );
          break;
        case "sourceVariables":
          maxHeight = Math.max(
            minPanelHeight,
            availableHeight - sourceFilesHeight - outlineHeight
          );
          break;
        default:
          maxHeight = 500;
      }

      const newHeight = Math.max(
        minPanelHeight,
        Math.min(maxHeight, resizeStartRef.current.height + deltaY)
      );

      switch (resizingPanel) {
        case "functions":
          setFunctionsHeight(newHeight);
          break;
        case "variables":
          setVariablesHeight(newHeight);
          break;
        case "data":
          setDataHeight(newHeight);
          break;
        case "sourceFiles":
          setSourceFilesHeight(newHeight);
          break;
        case "outline":
          setOutlineHeight(newHeight);
          break;
        case "sourceVariables":
          setSourceVariablesHeight(newHeight);
          break;
      }
    };

    const handleMouseUp = () => {
      setResizingPanel(null);
    };

    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    document.body.style.cursor = "row-resize";
    document.body.style.userSelect = "none";

    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    };
  }, [
    resizingPanel,
    setFunctionsHeight,
    setVariablesHeight,
    setDataHeight,
    setSourceFilesHeight,
    setOutlineHeight,
    setSourceVariablesHeight,
    functionsHeight,
    variablesHeight,
    dataHeight,
    sourceFilesHeight,
    outlineHeight,
    sourceVariablesHeight,
    functionsExpanded,
    variablesExpanded,
    dataExpanded,
    isCompactHeight,
  ]);

  const handleFunctionClick = (
    functionName: string,
    functionAddress?: string
  ) => {
    console.log(
      `DebuggerSidebar: Function clicked - name: ${functionName}, address: ${functionAddress}`
    );
    onFunctionClick(functionName, functionAddress);
  };

  return (
    <SidebarContainer ref={sidebarRef}>
      <SidebarContent isResizing={isResizing || !!resizingPanel}>
        {sourceCodeLevelDebug ? (
          // Source Code Level Debug Mode - Show Files & Outline & Variables
          <>
            {/* Source Files Panel */}
            <Box
              sx={{
                display: "flex",
                alignItems: "center",
                padding: "4px 8px",
                backgroundColor: "#252526",
                borderBottom: "1px solid #2d2d30",
                minHeight: "24px",
                fontWeight: 600,
                fontSize: "10px",
                color: "#4ec9b0",
                textTransform: "uppercase",
                letterSpacing: "0.5px",
                gap: 0.75,
                flexShrink: 0,
                "@media (max-height: 800px)": {
                  padding: "3px 8px",
                  minHeight: "20px",
                  fontSize: "9px",
                },
              }}
            >
              <FolderOpenIcon
                sx={{
                  fontSize: 12,
                  color: "#4ec9b0",
                  "@media (max-height: 800px)": {
                    fontSize: 10,
                  },
                }}
              />
              <span style={{ flex: 1 }}>Source Files</span>
              {dwarfAnalysisResult?.source_files?.length > 0 && (
                <Box
                  component="span"
                  sx={{
                    backgroundColor: "rgba(78, 201, 176, 0.15)",
                    color: "#4ec9b0",
                    borderRadius: "4px",
                    padding: "0px 4px",
                    fontSize: "9px",
                    fontWeight: 600,
                    ml: 1,
                    "@media (max-height: 800px)": {
                      fontSize: "8px",
                      padding: "0px 3px",
                    },
                  }}
                >
                  {dwarfAnalysisResult.source_files.length}
                </Box>
              )}
            </Box>
            <Box
              sx={{
                height: `${sourceFilesHeight}px`,
                overflow: "auto",
                backgroundColor: "#1e1e1e",
                flexShrink: 0,
              }}
            >
              {dwarfAnalysisResult?.source_files?.length > 0 ? (
                dwarfAnalysisResult.source_files.map(
                  (file: any, idx: number) => {
                    const fileName = file.path.split("/").pop() || file.path;
                    return (
                      <Box
                        key={idx}
                        onClick={() => {
                          window.dispatchEvent(
                            new CustomEvent("openSourceFile", {
                              detail: {
                                path: file.path,
                                directory: file.directory,
                              },
                            })
                          );
                        }}
                        sx={{
                          display: "flex",
                          alignItems: "center",
                          gap: 1,
                          px: 1.5,
                          py: 0.5,
                          cursor: "pointer",
                          "&:hover": {
                            backgroundColor: "rgba(255, 255, 255, 0.05)",
                          },
                        }}
                      >
                        <FileIcon sx={{ fontSize: 14, color: "#4fc1ff" }} />
                        <Typography
                          sx={{
                            color: "#d4d4d4",
                            fontSize: "11px",
                            overflow: "hidden",
                            textOverflow: "ellipsis",
                            whiteSpace: "nowrap",
                            flex: 1,
                          }}
                        >
                          {fileName}
                        </Typography>
                      </Box>
                    );
                  }
                )
              ) : (
                <Box sx={{ p: 2 }}>
                  <Typography
                    sx={{
                      color: "#808080",
                      fontSize: "11px",
                      textAlign: "center",
                    }}
                  >
                    No source files available
                  </Typography>
                </Box>
              )}
            </Box>
            {/* Source Files Resize Handle */}
            <Box
              onMouseDown={(e) => {
                e.preventDefault();
                setResizingPanel("sourceFiles");
                resizeStartRef.current = {
                  y: e.clientY,
                  height: sourceFilesHeight,
                };
              }}
              sx={{
                height: "4px",
                backgroundColor: "#2d2d30",
                cursor: "row-resize",
                "&:hover": {
                  backgroundColor: "#007acc",
                },
                flexShrink: 0,
              }}
            />

            {/* Outline Panel - Show DWARF functions */}
            <Box
              sx={{
                display: "flex",
                alignItems: "center",
                padding: "4px 8px",
                backgroundColor: "#252526",
                borderBottom: "1px solid #2d2d30",
                minHeight: "24px",
                fontWeight: 600,
                fontSize: "10px",
                color: "#dcdcaa",
                textTransform: "uppercase",
                letterSpacing: "0.5px",
                gap: 0.75,
                flexShrink: 0,
                "@media (max-height: 800px)": {
                  padding: "3px 8px",
                  minHeight: "20px",
                  fontSize: "9px",
                },
              }}
            >
              <OutlineIcon
                sx={{
                  fontSize: 12,
                  color: "#dcdcaa",
                  "@media (max-height: 800px)": {
                    fontSize: 10,
                  },
                }}
              />
              <span style={{ flex: 1 }}>Outline</span>
              {dwarfAnalysisResult?.functions?.length > 0 && (
                <Box
                  component="span"
                  sx={{
                    backgroundColor: "rgba(220, 220, 170, 0.15)",
                    color: "#dcdcaa",
                    borderRadius: "4px",
                    padding: "0px 4px",
                    fontSize: "9px",
                    fontWeight: 600,
                    ml: 1,
                    "@media (max-height: 800px)": {
                      fontSize: "8px",
                      padding: "0px 3px",
                    },
                  }}
                >
                  {dwarfAnalysisResult.functions.length}
                </Box>
              )}
            </Box>
            <Box
              sx={{
                height: `${outlineHeight}px`,
                overflow: "auto",
                backgroundColor: "#1e1e1e",
                flexShrink: 0,
              }}
            >
              {dwarfAnalysisResult?.functions?.length > 0 ? (
                dwarfAnalysisResult.functions.map((func: any, idx: number) => {
                  const isCurrentFunc =
                    isInBreakState && currentFunction?.name === func.name;

                  return (
                    <Box
                      key={idx}
                      onClick={() => {
                        // If function has decl_file and decl_line, jump to source code line
                        if (func.decl_file && func.decl_line) {
                          // Request jump to source line
                          setPendingSourceJump({
                            filePath: func.decl_file,
                            line: func.decl_line,
                          });
                        } else if (func.low_pc) {
                          // Fallback to disasm if no source info
                          onFunctionClick(
                            func.name,
                            `0x${func.low_pc.toString(16)}`
                          );
                        }
                      }}
                      sx={{
                        display: "flex",
                        alignItems: "center",
                        gap: 1,
                        px: 1.5,
                        py: 0.5,
                        cursor: func.low_pc ? "pointer" : "default",
                        opacity: func.low_pc ? 1 : 0.5,
                        backgroundColor: isCurrentFunc
                          ? "rgba(255, 204, 0, 0.15)"
                          : "transparent",
                        borderLeft: isCurrentFunc
                          ? "2px solid #ffcc00"
                          : "2px solid transparent",
                        "&:hover": {
                          backgroundColor: isCurrentFunc
                            ? "rgba(255, 204, 0, 0.2)"
                            : func.low_pc
                              ? "rgba(255, 255, 255, 0.05)"
                              : "transparent",
                        },
                      }}
                    >
                      {/* Current function indicator */}
                      {isCurrentFunc && (
                        <Box
                          sx={{
                            width: 6,
                            height: 6,
                            borderRadius: "50%",
                            backgroundColor: "#ffcc00",
                            flexShrink: 0,
                          }}
                        />
                      )}
                      <FunctionsIcon
                        sx={{
                          fontSize: 14,
                          color: isCurrentFunc ? "#ffcc00" : "#dcdcaa",
                        }}
                      />
                      <Typography
                        sx={{
                          color: isCurrentFunc
                            ? "#ffcc00"
                            : activeFunction === func.name
                              ? "#4fc1ff"
                              : "#d4d4d4",
                          fontSize: "11px",
                          fontFamily: "monospace",
                          overflow: "hidden",
                          textOverflow: "ellipsis",
                          whiteSpace: "nowrap",
                          flex: 1,
                          fontWeight: isCurrentFunc ? 600 : 400,
                        }}
                      >
                        {func.name}
                      </Typography>
                      {/* Show current line if in break state */}
                      {isCurrentFunc && func.decl_line && (
                        <Typography
                          sx={{
                            color: "#808080",
                            fontSize: "9px",
                            fontFamily: "monospace",
                            flexShrink: 0,
                          }}
                        >
                          :{func.decl_line}
                        </Typography>
                      )}
                    </Box>
                  );
                })
              ) : (
                <Box sx={{ p: 2 }}>
                  <Typography
                    sx={{
                      color: "#808080",
                      fontSize: "11px",
                      textAlign: "center",
                    }}
                  >
                    No functions found
                  </Typography>
                </Box>
              )}
            </Box>
            {/* Outline Resize Handle */}
            <Box
              onMouseDown={(e) => {
                e.preventDefault();
                setResizingPanel("outline");
                resizeStartRef.current = {
                  y: e.clientY,
                  height: outlineHeight,
                };
              }}
              sx={{
                height: "4px",
                backgroundColor: "#2d2d30",
                cursor: "row-resize",
                "&:hover": {
                  backgroundColor: "#007acc",
                },
                flexShrink: 0,
              }}
            />

            {/* Call Stack / Current Location Panel - Show when in break state */}
            {isInBreakState && currentFunction && (
              <Box
                sx={{
                  backgroundColor: "rgba(255, 204, 0, 0.1)",
                  borderBottom: "1px solid rgba(255, 204, 0, 0.3)",
                  px: 1.5,
                  py: 1,
                  flexShrink: 0,
                }}
              >
                <Box
                  sx={{
                    display: "flex",
                    alignItems: "center",
                    gap: 1,
                    mb: 0.5,
                  }}
                >
                  <Box
                    sx={{
                      width: 8,
                      height: 8,
                      borderRadius: "50%",
                      backgroundColor: "#ffcc00",
                      animation: "pulse 1.5s infinite",
                      "@keyframes pulse": {
                        "0%": { opacity: 1 },
                        "50%": { opacity: 0.5 },
                        "100%": { opacity: 1 },
                      },
                    }}
                  />
                  <Typography
                    sx={{
                      color: "#ffcc00",
                      fontSize: "10px",
                      fontWeight: 600,
                      textTransform: "uppercase",
                      letterSpacing: "0.5px",
                    }}
                  >
                    Paused
                  </Typography>
                </Box>
                <Typography
                  sx={{
                    color: "#dcdcaa",
                    fontSize: "11px",
                    fontFamily: "monospace",
                    overflow: "hidden",
                    textOverflow: "ellipsis",
                    whiteSpace: "nowrap",
                  }}
                  title={currentFunction.name}
                >
                  {currentFunction.name}()
                </Typography>
                {currentBreakAddress && dwarfModuleBase && (
                  <Typography
                    sx={{
                      color: "#808080",
                      fontSize: "10px",
                      fontFamily: "monospace",
                      mt: 0.25,
                    }}
                  >
                    {(() => {
                      const addr =
                        typeof currentBreakAddress === "string"
                          ? parseInt(
                              currentBreakAddress.replace(/^0x/i, ""),
                              16
                            )
                          : currentBreakAddress;
                      const offset = addr - dwarfModuleBase;
                      const funcOffset =
                        currentFunction.low_pc !== null
                          ? offset - currentFunction.low_pc
                          : 0;
                      return `+0x${funcOffset.toString(16)} (0x${offset.toString(16)})`;
                    })()}
                  </Typography>
                )}
                {currentFunction.decl_file && currentFunction.decl_line && (
                  <Typography
                    sx={{
                      color: "#6a9955",
                      fontSize: "10px",
                      fontFamily: "monospace",
                      mt: 0.25,
                      overflow: "hidden",
                      textOverflow: "ellipsis",
                      whiteSpace: "nowrap",
                    }}
                    title={currentFunction.decl_file}
                  >
                    {currentFunction.decl_file.split("/").pop()}:
                    {currentFunction.decl_line}
                  </Typography>
                )}
              </Box>
            )}

            {/* Variables Panel - Show DWARF variables (names only) */}
            <Box
              sx={{
                display: "flex",
                alignItems: "center",
                padding: "4px 8px",
                backgroundColor: "#252526",
                borderBottom: "1px solid #2d2d30",
                minHeight: "24px",
                fontWeight: 600,
                fontSize: "10px",
                color: "#9cdcfe",
                textTransform: "uppercase",
                letterSpacing: "0.5px",
                gap: 0.75,
                flexShrink: 0,
                "@media (max-height: 800px)": {
                  padding: "3px 8px",
                  minHeight: "20px",
                  fontSize: "9px",
                },
              }}
            >
              <DataArrayIcon
                sx={{
                  fontSize: 12,
                  color: "#9cdcfe",
                  "@media (max-height: 800px)": {
                    fontSize: 10,
                  },
                }}
              />
              <span style={{ flex: 1 }}>Variables</span>
              {(() => {
                const allVariables = [
                  ...(dwarfAnalysisResult?.variables || []),
                  ...(dwarfAnalysisResult?.functions?.flatMap((f: any) => [
                    ...(f.parameters || []),
                    ...(f.variables || []),
                  ]) || []),
                ];
                return allVariables.length > 0 ? (
                  <Box
                    component="span"
                    sx={{
                      backgroundColor: "rgba(156, 220, 254, 0.15)",
                      color: "#9cdcfe",
                      borderRadius: "4px",
                      padding: "0px 4px",
                      fontSize: "9px",
                      fontWeight: 600,
                      ml: 1,
                      "@media (max-height: 800px)": {
                        fontSize: "8px",
                        padding: "0px 3px",
                      },
                    }}
                  >
                    {allVariables.length}
                  </Box>
                ) : null;
              })()}
            </Box>
            <Box
              sx={{
                height: `${sourceVariablesHeight}px`,
                overflow: "auto",
                backgroundColor: "#1e1e1e",
                flexShrink: 0,
              }}
            >
              {(() => {
                const globalVars = (dwarfAnalysisResult?.variables || []).map(
                  (v: any) => ({
                    ...v,
                    scope: null,
                    isCurrentScope: false,
                    isParameter: false,
                  })
                );
                const functionVars =
                  dwarfAnalysisResult?.functions?.flatMap((f: any) => [
                    ...(f.parameters || []).map((v: any) => ({
                      ...v,
                      scope: f.name,
                      isCurrentScope: currentFunction?.name === f.name,
                      isParameter: true,
                    })),
                    ...(f.variables || []).map((v: any) => ({
                      ...v,
                      scope: f.name,
                      isCurrentScope: currentFunction?.name === f.name,
                      isParameter: false,
                    })),
                  ]) || [];

                // Sort: current scope first, then others
                const allVariables = [...globalVars, ...functionVars].sort(
                  (a, b) => {
                    if (a.isCurrentScope && !b.isCurrentScope) return -1;
                    if (!a.isCurrentScope && b.isCurrentScope) return 1;
                    return 0;
                  }
                );

                return allVariables.length > 0 ? (
                  allVariables.map((variable: any, idx: number) => {
                    const resolvedValue = getResolvedValue(variable);
                    const isInScope =
                      variable.isCurrentScope || !variable.scope;

                    return (
                      <Box
                        key={idx}
                        sx={{
                          display: "flex",
                          alignItems: "flex-start",
                          gap: 0.5,
                          px: 1.5,
                          py: 0.5,
                          backgroundColor:
                            variable.isCurrentScope && isInBreakState
                              ? "rgba(79, 193, 255, 0.1)"
                              : "transparent",
                          opacity: isInBreakState && !isInScope ? 0.5 : 1,
                          "&:hover": {
                            backgroundColor:
                              variable.isCurrentScope && isInBreakState
                                ? "rgba(79, 193, 255, 0.15)"
                                : "rgba(255, 255, 255, 0.05)",
                          },
                        }}
                      >
                        {/* Scope badge: P=Parameter, L=Local, G=Global */}
                        <Box
                          sx={{
                            width: 14,
                            height: 14,
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            fontSize: "9px",
                            fontWeight: 600,
                            color: variable.isParameter
                              ? "#dcdcaa"
                              : variable.scope
                                ? "#4ec9b0"
                                : "#9cdcfe",
                            backgroundColor: variable.isParameter
                              ? "rgba(220, 220, 170, 0.15)"
                              : variable.scope
                                ? "rgba(78, 201, 176, 0.15)"
                                : "rgba(156, 220, 254, 0.15)",
                            borderRadius: "2px",
                            flexShrink: 0,
                            mt: "2px",
                          }}
                        >
                          {variable.isParameter
                            ? "P"
                            : variable.scope
                              ? "L"
                              : "G"}
                        </Box>
                        {/* Variable info container */}
                        <Box
                          sx={{
                            display: "flex",
                            flexDirection: "column",
                            flex: 1,
                            minWidth: 0,
                          }}
                        >
                          {/* Name and value row */}
                          <Box
                            sx={{
                              display: "flex",
                              alignItems: "center",
                              gap: 0.5,
                            }}
                          >
                            <Typography
                              sx={{
                                color:
                                  variable.isCurrentScope && isInBreakState
                                    ? "#4fc1ff"
                                    : "#9cdcfe",
                                fontSize: "11px",
                                fontFamily: "monospace",
                                overflow: "hidden",
                                textOverflow: "ellipsis",
                                whiteSpace: "nowrap",
                              }}
                              title={`${variable.name}${variable.type_name ? `: ${variable.type_name}` : ""}${variable.location ? ` (${variable.location})` : ""}`}
                            >
                              {variable.name}
                            </Typography>
                            {/* Show value when in break state and can resolve */}
                            {isInBreakState && resolvedValue && (
                              <Typography
                                sx={{
                                  color: "#ce9178",
                                  fontSize: "10px",
                                  fontFamily: "monospace",
                                  flexShrink: 0,
                                  maxWidth: "100px",
                                  overflow: "hidden",
                                  textOverflow: "ellipsis",
                                  whiteSpace: "nowrap",
                                }}
                                title={resolvedValue}
                              >
                                = {resolvedValue}
                              </Typography>
                            )}
                          </Box>
                          {/* Type row - always show if available */}
                          {variable.type_name && (
                            <Typography
                              sx={{
                                color: "#4ec9b0",
                                fontSize: "9px",
                                fontFamily: "monospace",
                                opacity: 0.8,
                                overflow: "hidden",
                                textOverflow: "ellipsis",
                                whiteSpace: "nowrap",
                              }}
                              title={variable.type_name}
                            >
                              {variable.type_name.length > 25
                                ? variable.type_name.substring(0, 23) + "…"
                                : variable.type_name}
                            </Typography>
                          )}
                        </Box>
                      </Box>
                    );
                  })
                ) : (
                  <Box sx={{ p: 2 }}>
                    <Typography
                      sx={{
                        color: "#808080",
                        fontSize: "11px",
                        textAlign: "center",
                      }}
                    >
                      No variables found
                    </Typography>
                  </Box>
                );
              })()}
            </Box>
            {/* Variables Resize Handle */}
            <Box
              onMouseDown={(e) => {
                e.preventDefault();
                setResizingPanel("sourceVariables");
                resizeStartRef.current = {
                  y: e.clientY,
                  height: sourceVariablesHeight,
                };
              }}
              sx={{
                height: "4px",
                backgroundColor: "#2d2d30",
                cursor: "row-resize",
                "&:hover": {
                  backgroundColor: "#007acc",
                },
                flexShrink: 0,
              }}
            />
            {/* Spacer */}
            <Box sx={{ flex: 1 }} />
          </>
        ) : (
          // Assembly Mode - Show Modules/Functions/Variables/Data
          <>
            {/* Module Selector (SidebarPanel風ヘッダー) */}
            <Box
              sx={{
                display: "flex",
                alignItems: "center",
                padding: "4px 8px",
                backgroundColor: "#252526",
                borderBottom: "1px solid #2d2d30",
                minHeight: "24px",
                fontWeight: 600,
                fontSize: "10px",
                color: "#4fc1ff",
                textTransform: "uppercase",
                letterSpacing: "0.5px",
                gap: 0.75,
                flexShrink: 0,
                "@media (max-height: 800px)": {
                  padding: "3px 8px",
                  minHeight: "20px",
                  fontSize: "9px",
                },
              }}
            >
              <LibraryBooksIcon
                sx={{
                  fontSize: 12,
                  color: "#4fc1ff",
                  "@media (max-height: 800px)": {
                    fontSize: 10,
                  },
                }}
              />
              <span style={{ flex: 1 }}>Modules</span>
              {modules.length > 0 && (
                <Box
                  component="span"
                  sx={{
                    backgroundColor: "rgba(79, 193, 255, 0.15)",
                    color: "#4fc1ff",
                    borderRadius: "4px",
                    padding: "0px 4px",
                    fontSize: "9px",
                    fontWeight: 600,
                    ml: 1,
                    "@media (max-height: 800px)": {
                      fontSize: "8px",
                      padding: "0px 3px",
                    },
                  }}
                >
                  {modules.length}
                </Box>
              )}
            </Box>
            <Box
              sx={{
                p: 1,
                flexShrink: 0,
                "@media (max-height: 800px)": {
                  p: 0.5,
                },
              }}
            >
              {!attachedProcess ? (
                <Typography
                  variant="body2"
                  color="text.secondary"
                  sx={{
                    fontSize: "11px",
                    "@media (max-height: 800px)": {
                      fontSize: "10px",
                    },
                  }}
                >
                  Attach to a process to view modules
                </Typography>
              ) : loading ? (
                <Typography
                  variant="body2"
                  color="text.secondary"
                  sx={{
                    fontSize: "11px",
                    "@media (max-height: 800px)": {
                      fontSize: "10px",
                    },
                  }}
                >
                  Loading modules...
                </Typography>
              ) : (
                <Autocomplete
                  size="small"
                  options={filteredModules}
                  value={selectedModule}
                  onChange={(_event, newValue) => {
                    setSelectedModule(newValue);
                  }}
                  getOptionLabel={(option) =>
                    getDisplayModuleName(option.modulename)
                  }
                  isOptionEqualToValue={(option, value) =>
                    option.base === value.base
                  }
                  filterOptions={(options, { inputValue }) => {
                    if (!inputValue) return options;
                    const filter = inputValue.toLowerCase();
                    return options.filter(
                      (m) =>
                        m.modulename?.toLowerCase().includes(filter) ||
                        m.path?.toLowerCase().includes(filter)
                    );
                  }}
                  renderInput={(params) => (
                    <TextField
                      {...params}
                      placeholder="Select module..."
                      sx={{
                        "& .MuiOutlinedInput-root": {
                          fontSize: "11px",
                          backgroundColor: "#252526",
                          "& fieldset": { borderColor: "#3c3c3c" },
                          "&:hover fieldset": { borderColor: "#4fc1ff" },
                          "&.Mui-focused fieldset": { borderColor: "#4fc1ff" },
                          "@media (max-height: 800px)": {
                            fontSize: "10px",
                            minHeight: "28px",
                          },
                        },
                        "& .MuiInputBase-input": { color: "#d4d4d4" },
                      }}
                    />
                  )}
                  renderOption={(props, option) => {
                    const fileName = getDisplayModuleName(option.modulename);
                    const sizeStr =
                      option.size >= 1024 * 1024
                        ? `${(option.size / (1024 * 1024)).toFixed(1)}MB`
                        : `${(option.size / 1024).toFixed(1)}KB`;

                    return (
                      <li
                        {...props}
                        key={option.base}
                        style={{
                          ...props.style,
                          fontSize: isCompactHeight ? "10px" : "11px",
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "space-between",
                          padding: isCompactHeight ? "2px 6px" : "4px 8px",
                        }}
                      >
                        <span style={{ color: accentColors.purple, flex: 1 }}>
                          {fileName}
                        </span>
                        <span
                          style={{
                            color: "#858585",
                            fontSize: isCompactHeight ? "9px" : "10px",
                            marginLeft: isCompactHeight ? 4 : 8,
                          }}
                        >
                          {sizeStr}
                        </span>
                      </li>
                    );
                  }}
                  sx={{
                    "& .MuiAutocomplete-popupIndicator": { color: "#858585" },
                    "& .MuiAutocomplete-clearIndicator": { color: "#858585" },
                  }}
                  slotProps={{
                    listbox: {
                      sx: {
                        "@media (max-height: 800px)": {
                          "& .MuiAutocomplete-option": {
                            minHeight: "24px",
                            fontSize: "10px",
                            padding: "2px 6px",
                          },
                        },
                      },
                    },
                  }}
                />
              )}
            </Box>

            {/* Functions Panel */}
            <SidebarPanel
              title="Functions"
              icon={FunctionsIcon}
              badge={filteredFunctions.length.toString()}
              actions={[
                {
                  icon: <FilterListIcon fontSize="small" />,
                  tooltip: showFunctionFilter
                    ? "Hide filter"
                    : "Filter functions",
                  onClick: () => setShowFunctionFilter(!showFunctionFilter),
                },
              ]}
              expanded={functionsExpanded}
              onExpandedChange={setFunctionsExpanded}
              height={functionsExpanded ? functionsHeight : undefined}
            >
              {showFunctionFilter && (
                <Box
                  sx={{
                    px: isCompactHeight ? 0.5 : 1,
                    pb: isCompactHeight ? 0.5 : 1,
                  }}
                >
                  <TextField
                    size="small"
                    placeholder="Filter functions..."
                    value={functionFilter}
                    onChange={(e) => setFunctionFilter(e.target.value)}
                    fullWidth
                    InputProps={{
                      startAdornment: (
                        <InputAdornment position="start">
                          <SearchIcon
                            sx={{
                              fontSize: isCompactHeight ? 12 : 14,
                              color: "#858585",
                            }}
                          />
                        </InputAdornment>
                      ),
                      sx: {
                        fontSize: isCompactHeight ? "10px" : "11px",
                        height: isCompactHeight ? 20 : 24,
                        "& input": { padding: "2px 0" },
                      },
                    }}
                  />
                </Box>
              )}
              {!selectedModule ? (
                <Typography
                  variant="body2"
                  color="text.secondary"
                  sx={{
                    fontSize: isCompactHeight ? "10px" : "11px",
                    p: isCompactHeight ? 1 : 2,
                  }}
                >
                  Select a module to view functions
                </Typography>
              ) : loadingSymbols ? (
                <Box
                  sx={{
                    p: isCompactHeight ? 1 : 2,
                    display: "flex",
                    alignItems: "center",
                    gap: 1,
                  }}
                >
                  <Typography
                    variant="body2"
                    color="text.secondary"
                    sx={{ fontSize: isCompactHeight ? "10px" : "11px" }}
                  >
                    Loading symbols for{" "}
                    {getDisplayModuleName(selectedModule.modulename)}...
                  </Typography>
                </Box>
              ) : filteredFunctions.length === 0 ? (
                <Typography
                  variant="body2"
                  color="text.secondary"
                  sx={{
                    fontSize: isCompactHeight ? "10px" : "11px",
                    p: isCompactHeight ? 1 : 2,
                  }}
                >
                  {combinedFunctions.length === 0
                    ? "No functions found"
                    : "No matching functions"}
                </Typography>
              ) : (
                <VirtualizedTable<CombinedFunction>
                  data={filteredFunctions}
                  columns={functionColumns}
                  sortField={functionSortField}
                  sortDirection={functionSortDir}
                  maxHeight={functionsHeight - (isCompactHeight ? 8 : 12)}
                  rowHeight={compactRowHeight}
                  onSort={(field: string) =>
                    handleFunctionSort(field as FunctionSortField)
                  }
                  onRowClick={(func: CombinedFunction) =>
                    handleFunctionClick(func.name, func.address)
                  }
                  isRowActive={(f: CombinedFunction) =>
                    activeFunction === f.name
                  }
                  getRowColor={(f: CombinedFunction) =>
                    f.source === "ghidra"
                      ? accentColors.blue
                      : accentColors.green
                  }
                  getRowKey={(f: CombinedFunction) => f.address}
                />
              )}
            </SidebarPanel>
            {/* Functions-Variables Resize Divider */}
            {functionsExpanded && (
              <PanelDivider
                isResizing={resizingPanel === "functions"}
                onMouseDown={handlePanelResizeStart(
                  "functions",
                  functionsHeight
                )}
              >
                <DragHandleIcon className="drag-icon" />
              </PanelDivider>
            )}

            {/* Variables Panel */}
            <SidebarPanel
              title="Variables"
              icon={DataObjectIcon}
              badge={filteredVariables.length.toString()}
              actions={[
                {
                  icon: <FilterListIcon fontSize="small" />,
                  tooltip: showVariableFilter
                    ? "Hide filter"
                    : "Filter variables",
                  onClick: () => setShowVariableFilter(!showVariableFilter),
                },
              ]}
              expanded={variablesExpanded}
              onExpandedChange={setVariablesExpanded}
              height={variablesExpanded ? variablesHeight : undefined}
            >
              {showVariableFilter && (
                <Box
                  sx={{
                    px: isCompactHeight ? 0.5 : 1,
                    pb: isCompactHeight ? 0.5 : 1,
                  }}
                >
                  <TextField
                    size="small"
                    placeholder="Filter variables..."
                    value={variableFilter}
                    onChange={(e) => setVariableFilter(e.target.value)}
                    fullWidth
                    InputProps={{
                      startAdornment: (
                        <InputAdornment position="start">
                          <SearchIcon
                            sx={{
                              fontSize: isCompactHeight ? 12 : 14,
                              color: "#858585",
                            }}
                          />
                        </InputAdornment>
                      ),
                      sx: {
                        fontSize: isCompactHeight ? "10px" : "11px",
                        height: isCompactHeight ? 20 : 24,
                        "& input": { padding: "2px 0" },
                      },
                    }}
                  />
                </Box>
              )}
              {!selectedModule ? (
                <Typography
                  variant="body2"
                  color="text.secondary"
                  sx={{
                    fontSize: isCompactHeight ? "10px" : "11px",
                    p: isCompactHeight ? 1 : 2,
                  }}
                >
                  Select a module to view variables
                </Typography>
              ) : loadingSymbols ? (
                <Box
                  sx={{
                    p: isCompactHeight ? 1 : 2,
                    display: "flex",
                    alignItems: "center",
                    gap: 1,
                  }}
                >
                  <Typography
                    variant="body2"
                    color="text.secondary"
                    sx={{ fontSize: isCompactHeight ? "10px" : "11px" }}
                  >
                    Loading symbols for{" "}
                    {getDisplayModuleName(selectedModule.modulename)}...
                  </Typography>
                </Box>
              ) : filteredVariables.length === 0 ? (
                <Typography
                  variant="body2"
                  color="text.secondary"
                  sx={{
                    fontSize: isCompactHeight ? "10px" : "11px",
                    p: isCompactHeight ? 1 : 2,
                  }}
                >
                  {variables.length === 0
                    ? "No variables found"
                    : "No matching variables"}
                </Typography>
              ) : (
                <VirtualizedTable<SymbolInfo>
                  data={filteredVariables}
                  columns={variableColumns}
                  sortField={variableSortField}
                  sortDirection={variableSortDir}
                  maxHeight={variablesHeight - (isCompactHeight ? 8 : 12)}
                  rowHeight={compactRowHeight}
                  onSort={(field: string) =>
                    handleVariableSort(field as VariableSortField)
                  }
                  onRowClick={(v: SymbolInfo) => {
                    // Navigate to variable address in memory view
                    if (v.address) {
                      setMemoryAddress(v.address);
                    }
                  }}
                  getRowColor={() => accentColors.orange}
                  getRowKey={(v: SymbolInfo) => v.address}
                />
              )}
            </SidebarPanel>
            {/* Variables-Data Resize Divider */}
            {variablesExpanded && (
              <PanelDivider
                isResizing={resizingPanel === "variables"}
                onMouseDown={handlePanelResizeStart(
                  "variables",
                  variablesHeight
                )}
              >
                <DragHandleIcon className="drag-icon" />
              </PanelDivider>
            )}

            {/* Data Panel */}
            <SidebarPanel
              title="Data"
              icon={StorageIcon}
              badge={filteredDataItems.length.toString()}
              actions={[
                {
                  icon: <FilterListIcon fontSize="small" />,
                  tooltip: showDataFilter ? "Hide filter" : "Filter data",
                  onClick: () => setShowDataFilter(!showDataFilter),
                },
              ]}
              expanded={dataExpanded}
              onExpandedChange={setDataExpanded}
              height={dataExpanded ? dataHeight : undefined}
            >
              {showDataFilter && (
                <Box
                  sx={{
                    px: isCompactHeight ? 0.5 : 1,
                    pb: isCompactHeight ? 0.5 : 1,
                    display: "flex",
                    gap: isCompactHeight ? 0.5 : 1,
                  }}
                >
                  <TextField
                    size="small"
                    placeholder="Name..."
                    value={dataNameFilter}
                    onChange={(e) => setDataNameFilter(e.target.value)}
                    sx={{ flex: 1 }}
                    InputProps={{
                      startAdornment: (
                        <InputAdornment position="start">
                          <SearchIcon
                            sx={{
                              fontSize: isCompactHeight ? 12 : 14,
                              color: "#858585",
                            }}
                          />
                        </InputAdornment>
                      ),
                      sx: {
                        fontSize: isCompactHeight ? "10px" : "11px",
                        height: isCompactHeight ? 20 : 24,
                        "& input": { padding: "2px 0" },
                      },
                    }}
                  />
                  <Autocomplete
                    size="small"
                    options={uniqueDataTypes}
                    value={dataTypeFilter || null}
                    onChange={(_event, newValue) => {
                      setDataTypeFilter(newValue || "");
                    }}
                    sx={{ flex: 1 }}
                    renderInput={(params) => (
                      <TextField
                        {...params}
                        placeholder="Type..."
                        sx={{
                          "& .MuiOutlinedInput-root": {
                            fontSize: isCompactHeight ? "10px" : "11px",
                            height: isCompactHeight ? 20 : 24,
                            padding: "0 8px !important",
                            "& fieldset": { borderColor: "#3c3c3c" },
                            "&:hover fieldset": { borderColor: "#4fc1ff" },
                            "&.Mui-focused fieldset": {
                              borderColor: "#4fc1ff",
                            },
                          },
                          "& .MuiInputBase-input": {
                            color: "#d4d4d4",
                            padding: "2px 0 !important",
                          },
                        }}
                      />
                    )}
                    componentsProps={{
                      popupIndicator: { sx: { padding: 0 } },
                      clearIndicator: { sx: { padding: 0 } },
                    }}
                  />
                </Box>
              )}
              {!selectedModule ? (
                <Typography
                  variant="body2"
                  color="text.secondary"
                  sx={{
                    fontSize: isCompactHeight ? "10px" : "11px",
                    p: isCompactHeight ? 1 : 2,
                  }}
                >
                  Select a module to view data definitions
                </Typography>
              ) : !isLibraryAnalyzed(
                  selectedModule.path || selectedModule.modulename
                ) ? (
                <Typography
                  variant="body2"
                  color="text.secondary"
                  sx={{
                    fontSize: isCompactHeight ? "10px" : "11px",
                    p: isCompactHeight ? 1 : 2,
                  }}
                >
                  Analyze module with Ghidra to view data
                </Typography>
              ) : !serverRunning ? (
                <Typography
                  variant="body2"
                  color="text.secondary"
                  sx={{
                    fontSize: isCompactHeight ? "10px" : "11px",
                    p: isCompactHeight ? 1 : 2,
                  }}
                >
                  Start Ghidra server to view data definitions
                </Typography>
              ) : loadingData ? (
                <Box
                  sx={{
                    p: isCompactHeight ? 1 : 2,
                    display: "flex",
                    alignItems: "center",
                    gap: 1,
                  }}
                >
                  <Typography
                    variant="body2"
                    color="text.secondary"
                    sx={{ fontSize: isCompactHeight ? "10px" : "11px" }}
                  >
                    Loading data items...
                  </Typography>
                </Box>
              ) : filteredDataItems.length === 0 ? (
                <Typography
                  variant="body2"
                  color="text.secondary"
                  sx={{
                    fontSize: isCompactHeight ? "10px" : "11px",
                    p: isCompactHeight ? 1 : 2,
                  }}
                >
                  {ghidraDataItems.length === 0
                    ? "No data items found"
                    : "No matching data items"}
                </Typography>
              ) : (
                <VirtualizedTable<GhidraDataItem>
                  data={filteredDataItems}
                  columns={dataColumns}
                  sortField={dataSortField}
                  sortDirection={dataSortDir}
                  maxHeight={dataHeight - (isCompactHeight ? 8 : 12)}
                  rowHeight={compactRowHeight}
                  onSort={(field: string) =>
                    handleDataSort(field as DataSortField)
                  }
                  onRowClick={(d: GhidraDataItem) => {
                    // Navigate to data address in memory view
                    const absoluteAddr = getAbsoluteDataAddress(d.address);
                    setMemoryAddress(absoluteAddr);
                  }}
                  getRowColor={(d: GhidraDataItem) => {
                    if (d.category === "string") return accentColors.green;
                    if (d.category === "pointer") return accentColors.purple;
                    if (d.category === "struct") return accentColors.yellow;
                    return accentColors.blue;
                  }}
                  getRowKey={(d: GhidraDataItem, i: number) =>
                    `${d.address}-${i}`
                  }
                />
              )}
            </SidebarPanel>
          </>
        )}
      </SidebarContent>

      <ResizeHandle isResizing={isResizing} onMouseDown={handleMouseDown} />
    </SidebarContainer>
  );
};

```

`src/client/src/components/DebuggerToolbar.tsx`:

```tsx
import React, { useState, useCallback, useEffect, useMemo } from "react";
import {
  Box,
  TextField,
  IconButton,
  Tooltip,
  Stack,
  Divider,
  Chip,
  Typography,
  Alert,
  Snackbar,
  Autocomplete,
  Paper,
  Popover,
  List,
  ListItem,
  ListItemButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Checkbox,
} from "@mui/material";
import { Delete as DeleteIcon } from "@mui/icons-material";
import {
  PlayArrow,
  FiberManualRecord,
  MyLocation,
  SwapHoriz,
  SkipNext,
  ArrowBack,
  ViewSidebar,
  Settings as SettingsIcon,
} from "@mui/icons-material";
import { getApiClient, ModuleInfo } from "../lib/api";
import { useGlobalDebugLogger } from "../hooks/useGlobalDebugLogger";
import { useGlobalExceptionHandler } from "../hooks/useGlobalExceptionHandler";
import { useUIActions } from "../stores/uiStore";
import { useUIStore } from "../stores/uiStore";
import {
  normalizeAddressString,
  normalizeAddressStringAsync,
  isLibraryExpression,
} from "../utils/addressEncoder";
import { useSymbolCache } from "../hooks/useSymbolCache";

// LocalStorage key for Go to history
const GOTO_HISTORY_KEY = "debugger_goto_history";
const MAX_HISTORY_ITEMS = 5;

// Stopped thread info for thread switching
export interface StoppedThreadInfo {
  threadId: number;
  address: string;
  instruction: string;
  timestamp: Date;
  isCurrent: boolean;
  exceptionType: string; // "breakpoint", "watchpoint", "singlestep"
}

export interface DebuggerToolbarProps {
  debuggerConnected: boolean;
  debuggerState: "idle" | "attached" | "debugging";
  visible: boolean;
  showRegisters?: boolean;
  showSidebar?: boolean;
  attachedProcess?: {
    pid: number;
    name: string;
  };
  isInBreakState?: boolean;
  currentThreadId?: number | null; // Current active thread for debugging operations
  onToggleRegisters?: () => void;
  onToggleSidebar?: () => void;
  onGoToAddress?: (address: string) => void;
  onSetBreakpoint?: (address: string, isSoftware?: boolean) => void;
  onRemoveBreakpoint?: (address: string) => void;
  onRemoveBreakpoints?: (addresses: string[]) => void; // Bulk delete
  breakpoints?: string[];
  softwareBreakpoints?: string[]; // Track which breakpoints are software
  breakpointInputValue?: string;
  onBreakpointInputChange?: (value: string) => void;
  isSoftwareBreakpoint?: boolean; // Current breakpoint type toggle state
  onBreakpointTypeChange?: (isSoftware: boolean) => void; // Callback for breakpoint type change
  onBreakStateChange?: (isBreaking: boolean) => void;
  onLastActionChange?: (
    action: "continue" | "single_step" | "breakpoint" | null
  ) => void;
  onSwitchThread?: (threadId: number, exception: any) => void; // Switch to another stopped thread
  attachedModules?: ModuleInfo[]; // Add attached modules for library+offset parsing
  connectionHost?: string; // Server connection host for symbol loading
  connectionPort?: number; // Server connection port for symbol loading
  targetOs?: string; // Target OS (e.g., "ios", "macos", "android")
}

export const DebuggerToolbar: React.FC<DebuggerToolbarProps> = ({
  debuggerConnected,
  visible,
  attachedProcess,
  isInBreakState = false,
  showSidebar = false,
  currentThreadId, // Extract currentThreadId from props
  onGoToAddress,
  onSetBreakpoint,
  onRemoveBreakpoint,
  onRemoveBreakpoints,
  breakpoints = [],
  softwareBreakpoints = [],
  breakpointInputValue = "",
  onBreakpointInputChange,
  isSoftwareBreakpoint = false,
  onBreakpointTypeChange,
  onBreakStateChange,
  onLastActionChange,
  onSwitchThread, // Thread switching callback
  onToggleSidebar,
  attachedModules = [], // Extract attached modules
  connectionHost,
  connectionPort,
  targetOs,
}) => {
  const { logInfo, logError, logDebug, logWarn } = useGlobalDebugLogger();
  const { allStoppedThreads, clearAllStoppedThreads, checkNow } =
    useGlobalExceptionHandler();
  const uiActions = useUIActions();
  const gotoAddress = useUIStore((state) => state.debuggerState.gotoAddress);
  const assemblyNavigationHistory = useUIStore(
    (state) => state.debuggerState.assemblyNavigationHistory
  );
  const [snackbar, setSnackbar] = useState<{
    open: boolean;
    message: string;
    severity: "success" | "error" | "info";
  }>({ open: false, message: "", severity: "info" });

  // Thread list popover anchor
  const [threadPopoverAnchor, setThreadPopoverAnchor] =
    useState<HTMLElement | null>(null);
  const threadPopoverOpen = Boolean(threadPopoverAnchor);

  // Address display format toggle (true = detail with symbol, false = raw hex)
  const [showDetailFormat, setShowDetailFormat] = useState(true);

  // Breakpoint list dialog state
  const [breakpointListOpen, setBreakpointListOpen] = useState(false);
  const [selectedBreakpoints, setSelectedBreakpoints] = useState<Set<string>>(
    new Set()
  );

  // Symbol cache for address formatting
  const { formatAddressWithSymbol } = useSymbolCache();

  // Build stopped threads list from allStoppedThreads map
  const stoppedThreads = useMemo((): StoppedThreadInfo[] => {
    const threads: StoppedThreadInfo[] = [];

    // Build list from allStoppedThreads map
    allStoppedThreads.forEach((exception, threadId) => {
      threads.push({
        threadId,
        address: exception.address || "unknown",
        instruction: exception.instruction || "unknown",
        timestamp: exception.timestamp,
        isCurrent: threadId === currentThreadId,
        exceptionType: exception.type || "unknown",
      });
    });

    // Sort by thread ID (ascending)
    threads.sort((a, b) => a.threadId - b.threadId);

    return threads;
  }, [allStoppedThreads, currentThreadId]);

  // Format address based on display mode
  const formatThreadAddress = useCallback(
    (address: string): string => {
      if (!showDetailFormat) {
        return address;
      }

      // Try to convert to module@function+offset format
      try {
        // Handle addresses with leading 0x or without
        const cleanAddress =
          address.replace(/^0x/i, "").replace(/^0+/, "") || "0";
        const numericAddress = parseInt(cleanAddress, 16);
        if (!isNaN(numericAddress) && attachedModules.length > 0) {
          // Use formatAddressWithSymbol for module@function+offset format
          const symbolExpr = formatAddressWithSymbol(
            numericAddress,
            attachedModules,
            "function" // Use function format for symbol names
          );
          if (symbolExpr) {
            return symbolExpr;
          }
        }
      } catch (e) {
        // Fallback to original address
      }
      return address;
    },
    [showDetailFormat, attachedModules, formatAddressWithSymbol]
  );

  // Convert number to circled number (①②③...)
  const toCircledNumber = (n: number): string => {
    const circledNumbers = [
      "①",
      "②",
      "③",
      "④",
      "⑤",
      "⑥",
      "⑦",
      "⑧",
      "⑨",
      "⑩",
      "⑪",
      "⑫",
      "⑬",
      "⑭",
      "⑮",
      "⑯",
      "⑰",
      "⑱",
      "⑲",
      "⑳",
    ];
    if (n >= 1 && n <= 20) {
      return circledNumbers[n - 1];
    }
    return `(${n})`;
  };

  // Get exception type display string
  const getExceptionTypeLabel = (type: string): string => {
    switch (type.toLowerCase()) {
      case "breakpoint":
        return "BREAKPOINT";
      case "watchpoint":
        return "WATCHPOINT";
      case "singlestep":
        return "SINGLE STEP";
      default:
        return type.toUpperCase();
    }
  };

  // Handle thread chip click to open popover
  const handleThreadChipClick = (event: React.MouseEvent<HTMLElement>) => {
    if (stoppedThreads.length > 1) {
      setThreadPopoverAnchor(event.currentTarget);
    }
  };

  // Handle thread switch
  const handleThreadSwitch = (threadId: number) => {
    // Find the exception for this thread from allStoppedThreads
    const exception = allStoppedThreads.get(threadId);

    if (exception && onSwitchThread) {
      logInfo("DEBUGGER_TOOLBAR", `Switching to thread ${threadId}`);
      onSwitchThread(threadId, exception);
    }

    setThreadPopoverAnchor(null);
  };

  // Go to address history
  const [gotoHistory, setGotoHistory] = useState<string[]>([]);

  // Load history from localStorage on mount
  useEffect(() => {
    try {
      const saved = localStorage.getItem(GOTO_HISTORY_KEY);
      if (saved) {
        setGotoHistory(JSON.parse(saved));
      }
    } catch (e) {
      console.error("Failed to load goto history:", e);
    }
  }, []);

  // Save history to localStorage
  const saveHistory = useCallback((history: string[]) => {
    try {
      localStorage.setItem(GOTO_HISTORY_KEY, JSON.stringify(history));
    } catch (e) {
      console.error("Failed to save goto history:", e);
    }
  }, []);

  // Add address to history
  const addToHistory = useCallback(
    (address: string) => {
      setGotoHistory((prev) => {
        // Remove if already exists, then add to front
        const filtered = prev.filter(
          (a) => a.toLowerCase() !== address.toLowerCase()
        );
        const newHistory = [address, ...filtered].slice(0, MAX_HISTORY_ITEMS);
        saveHistory(newHistory);
        return newHistory;
      });
    },
    [saveHistory]
  );

  const apiClient = getApiClient();

  // Get setCurrentHitAddress for source-level debugging
  const setCurrentHitAddress = useUIStore(
    (state) => state.actions.setCurrentHitAddress
  );

  // Use controlled input for breakpoint if provided, otherwise use local state
  const [localBreakpointInput, setLocalBreakpointInput] = useState("");
  const breakpointInput =
    breakpointInputValue !== undefined
      ? breakpointInputValue
      : localBreakpointInput;
  const setBreakpointInput = onBreakpointInputChange || setLocalBreakpointInput;

  // Handle continue execution
  const handleContinue = useCallback(async () => {
    try {
      // Get all stopped thread IDs
      const stoppedThreadIds = Array.from(allStoppedThreads.keys());

      logInfo(
        "DEBUGGER_TOOLBAR",
        `Continuing ${stoppedThreadIds.length} stopped thread(s)`,
        {
          threadIds: stoppedThreadIds,
          currentThreadId,
        }
      );

      // Threads at active breakpoints need single-step first
      const threadsNeedingSingleStep: number[] = [];
      const threadsForDirectContinue: number[] = [];

      for (const threadId of stoppedThreadIds) {
        const exception = allStoppedThreads.get(threadId);
        const isBreakpointHit = exception?.type === "breakpoint";
        const threadAddress = exception?.address;
        const breakpointStillExists =
          threadAddress &&
          breakpoints.some(
            (bp) => bp.toLowerCase() === threadAddress.toLowerCase()
          );

        if (isBreakpointHit && breakpointStillExists) {
          threadsNeedingSingleStep.push(threadId);
        } else {
          threadsForDirectContinue.push(threadId);
        }
      }

      // シングルステップが必要なスレッドを先に処理
      for (const threadId of threadsNeedingSingleStep) {
        logInfo(
          "DEBUGGER_TOOLBAR",
          "Breakpoint hit detected and still exists - executing single step before continue",
          { threadId }
        );
        const stepResponse = await apiClient.singleStep(threadId);
        if (!stepResponse.success) {
          logError(
            "DEBUGGER_TOOLBAR",
            `Failed to single step thread ${threadId}: ${stepResponse.message}`
          );
        }
      }

      // 全スレッドを一括でcontinue（シングルステップ後のスレッドも含む）
      logInfo(
        "DEBUGGER_TOOLBAR",
        `Continuing all ${stoppedThreadIds.length} threads in single API call`,
        { threadIds: stoppedThreadIds }
      );

      const response =
        await apiClient.continueExecutionMultiple(stoppedThreadIds);
      if (!response.success) {
        logError("DEBUGGER_TOOLBAR", `Continue failed: ${response.message}`);
        if (response.results) {
          for (const result of response.results) {
            if (!result.success) {
              logError(
                "DEBUGGER_TOOLBAR",
                `Thread ${result.thread_id} failed: ${result.message}`
              );
            }
          }
        }
      } else {
        logDebug(
          "DEBUGGER_TOOLBAR",
          `All threads continued: ${response.message}`
        );
      }

      // Clear all stopped threads after continuing all
      clearAllStoppedThreads();
      logDebug("DEBUGGER_TOOLBAR", "Cleared all stopped threads on continue");

      // Clear current hit address for source-level debugging
      setCurrentHitAddress(null);

      // Set break state to false immediately after continue command
      logDebug(
        "DEBUGGER_TOOLBAR",
        "Setting break state to false after continue",
        {
          threadIds: stoppedThreadIds,
        }
      );
      if (onBreakStateChange) {
        onBreakStateChange(false);
        logDebug("DEBUGGER_TOOLBAR", "Break state set to false successfully");
      } else {
        logWarn(
          "DEBUGGER_TOOLBAR",
          "onBreakStateChange callback is not available"
        );
      }
      // Record that continue action was performed
      if (onLastActionChange) {
        onLastActionChange("continue");
      }
      // Trigger immediate exception check after continue with slight delay
      setTimeout(() => {
        if ((window as any).forceExceptionCheck) {
          (window as any).forceExceptionCheck();
        }
      }, 100);
    } catch (error) {
      console.error("Continue execution failed:", error);
      setSnackbar({
        open: true,
        message:
          error instanceof Error
            ? error.message
            : "Failed to continue execution",
        severity: "error",
      });
    }
  }, [
    apiClient,
    currentThreadId,
    onBreakStateChange,
    onLastActionChange,
    clearAllStoppedThreads,
    allStoppedThreads,
    breakpoints,
    logInfo,
    logError,
    logDebug,
    setCurrentHitAddress,
  ]);

  // Handle single step
  const handleSingleStep = useCallback(async () => {
    const startTime = performance.now();
    console.log(`[SINGLE_STEP] Button clicked at ${new Date().toISOString()}`);
    try {
      logInfo("DEBUGGER_TOOLBAR", "Executing single step command", {
        threadId: currentThreadId,
        action: "single_step",
      });
      console.log(
        `[SINGLE_STEP] About to call API, elapsed: ${(performance.now() - startTime).toFixed(2)}ms`
      );
      const response = await apiClient.singleStep(currentThreadId || undefined);
      console.log(
        `[SINGLE_STEP] API response received, elapsed: ${(performance.now() - startTime).toFixed(2)}ms`
      );
      logDebug("DEBUGGER_TOOLBAR", "Single step server response", response);

      if (response.success) {
        logInfo("DEBUGGER_TOOLBAR", "Single step successful", {
          threadId: currentThreadId,
          action: "single_step",
        });
        // Record that single step action was performed
        if (onLastActionChange) {
          onLastActionChange("single_step");
        }
        // Immediately check for exceptions instead of waiting for polling
        console.log(`[SINGLE_STEP] Triggering immediate exception check`);
        checkNow();
      } else {
        logError("DEBUGGER_TOOLBAR", "Single step failed", {
          message: response.message,
          threadId: currentThreadId,
        });
        throw new Error(response.message || "Failed to single step");
      }
    } catch (error) {
      logError("DEBUGGER_TOOLBAR", "Single step execution failed", {
        error: error instanceof Error ? error.message : String(error),
        threadId: currentThreadId,
      });
      setSnackbar({
        open: true,
        message:
          error instanceof Error ? error.message : "Failed to single step",
        severity: "error",
      });
    }
  }, [apiClient, currentThreadId, onLastActionChange, checkNow]);

  // Handle go to address
  const handleGoToAddress = useCallback(async () => {
    if (gotoAddress.trim()) {
      // Check if it's a library+offset expression
      const isLibExpr = isLibraryExpression(gotoAddress);

      if (isLibExpr) {
        // Check if we have connection info for async symbol loading
        const serverInfo =
          connectionHost && connectionPort
            ? {
                ip: connectionHost,
                port: connectionPort,
              }
            : null;

        if (serverInfo && attachedModules.length > 0) {
          // Use async version that can load symbols on-demand
          const normalizedAddress = await normalizeAddressStringAsync(
            gotoAddress,
            attachedModules,
            serverInfo
          );

          if (normalizedAddress) {
            console.log(
              `Parsed library+offset expression "${gotoAddress}" to address ${normalizedAddress}`
            );
            addToHistory(gotoAddress);
            // Use setAssemblyAddressWithHistory to track navigation for Back button
            uiActions.setAssemblyAddressWithHistory(normalizedAddress);
            if (onGoToAddress) {
              onGoToAddress(normalizedAddress);
            }
          } else {
            setSnackbar({
              open: true,
              message: `Failed to parse library+offset expression: ${gotoAddress}. Make sure the module is loaded.`,
              severity: "error",
            });
            console.error(
              `Failed to parse library+offset expression: ${gotoAddress}`
            );
          }
        } else {
          // Fallback to sync version (library+offset only, no function lookup)
          const normalizedAddress = normalizeAddressString(
            gotoAddress,
            attachedModules
          );

          if (normalizedAddress) {
            console.log(
              `Parsed library+offset expression "${gotoAddress}" to address ${normalizedAddress}`
            );
            addToHistory(gotoAddress);
            // Use setAssemblyAddressWithHistory to track navigation for Back button
            uiActions.setAssemblyAddressWithHistory(normalizedAddress);
            if (onGoToAddress) {
              onGoToAddress(normalizedAddress);
            }
          } else {
            setSnackbar({
              open: true,
              message: `Failed to parse library+offset expression: ${gotoAddress}. Make sure the module is loaded.`,
              severity: "error",
            });
            console.error(
              `Failed to parse library+offset expression: ${gotoAddress}`
            );
          }
        }
      } else {
        // Direct address - normalize and navigate
        const normalizedAddress = normalizeAddressString(gotoAddress);

        if (normalizedAddress) {
          addToHistory(gotoAddress); // Add to history
          // Use setAssemblyAddressWithHistory to track navigation for Back button
          uiActions.setAssemblyAddressWithHistory(normalizedAddress);
          if (onGoToAddress) {
            onGoToAddress(normalizedAddress);
          }
        } else {
          // Show error for invalid address format
          setSnackbar({
            open: true,
            message: `Invalid address format: ${gotoAddress}`,
            severity: "error",
          });
          console.error(`Invalid address format: ${gotoAddress}`);
        }
      }
    }
  }, [
    gotoAddress,
    onGoToAddress,
    attachedModules,
    addToHistory,
    connectionHost,
    connectionPort,
    uiActions,
  ]);

  // Handle set breakpoint
  const handleSetBreakpoint = useCallback(async () => {
    if (breakpointInput.trim() && onSetBreakpoint) {
      // Check if it's a library+offset expression
      const isLibExpr = isLibraryExpression(breakpointInput);

      if (isLibExpr) {
        // Check if we have connection info for async symbol loading
        const serverInfo =
          connectionHost && connectionPort
            ? {
                ip: connectionHost,
                port: connectionPort,
              }
            : null;

        if (serverInfo && attachedModules.length > 0) {
          // Use async version that can load symbols on-demand
          const normalizedAddress = await normalizeAddressStringAsync(
            breakpointInput,
            attachedModules,
            serverInfo
          );

          if (normalizedAddress) {
            console.log(
              `Parsed breakpoint library+offset expression "${breakpointInput}" to address ${normalizedAddress} (software: ${isSoftwareBreakpoint})`
            );
            onSetBreakpoint(normalizedAddress, isSoftwareBreakpoint);
            setBreakpointInput("");
          } else {
            setSnackbar({
              open: true,
              message: `Failed to parse library+offset expression: ${breakpointInput}. Make sure the module is loaded.`,
              severity: "error",
            });
            console.error(
              `Failed to parse library+offset expression: ${breakpointInput}`
            );
          }
        } else {
          // Fallback to sync version
          const normalizedAddress = normalizeAddressString(
            breakpointInput,
            attachedModules
          );

          if (normalizedAddress) {
            console.log(
              `Parsed breakpoint library+offset expression "${breakpointInput}" to address ${normalizedAddress} (software: ${isSoftwareBreakpoint})`
            );
            onSetBreakpoint(normalizedAddress, isSoftwareBreakpoint);
            setBreakpointInput("");
          } else {
            setSnackbar({
              open: true,
              message: `Failed to parse library+offset expression: ${breakpointInput}. Make sure the module is loaded.`,
              severity: "error",
            });
            console.error(
              `Failed to parse library+offset expression: ${breakpointInput}`
            );
          }
        }
      } else {
        // Direct address - normalize and set breakpoint
        const normalizedAddress = normalizeAddressString(breakpointInput);

        if (normalizedAddress) {
          console.log(
            "[BP SET] Direct address, isSoftwareBreakpoint:",
            isSoftwareBreakpoint
          );
          onSetBreakpoint(normalizedAddress, isSoftwareBreakpoint);
          setBreakpointInput(""); // Clear input after setting
        } else {
          // Show error for invalid address format
          setSnackbar({
            open: true,
            message: `Invalid address format: ${breakpointInput}`,
            severity: "error",
          });
          console.error(`Invalid address format: ${breakpointInput}`);
        }
      }
    }
  }, [
    breakpointInput,
    onSetBreakpoint,
    isSoftwareBreakpoint,
    attachedModules,
    connectionHost,
    connectionPort,
  ]);

  // Handle remove breakpoint
  const handleRemoveBreakpoint = useCallback(
    (address: string) => {
      if (onRemoveBreakpoint) {
        onRemoveBreakpoint(address);
      }
    },
    [onRemoveBreakpoint]
  );

  // Handle navigate to breakpoint address
  const handleNavigateToBreakpoint = useCallback(
    (address: string) => {
      if (onGoToAddress) {
        onGoToAddress(address);
      }
    },
    [onGoToAddress]
  );

  if (!visible) return null;

  return (
    <Box
      sx={{
        display: "flex",
        alignItems: "center",
        gap: 1,
        p: 1,
        borderBottom: 1,
        borderColor: "divider",
        backgroundColor: "background.paper",
        minHeight: 48,
        flexWrap: "wrap",
        "@media (max-height: 800px)": {
          gap: 0.5,
          p: 0.5,
          minHeight: 36,
        },
      }}
    >
      {/* Debugger Settings Button - Hidden on iOS */}
      {targetOs !== "ios" && (
        <Tooltip title="Debugger Settings">
          <IconButton
            size="small"
            onClick={() => uiActions.setDebuggerSettingsOpen(true)}
            sx={{
              color: "#858585",
              "&:hover": { backgroundColor: "#2d2d30", color: "#4fc1ff" },
              "@media (max-height: 800px)": {
                padding: 0.25,
                "& .MuiSvgIcon-root": { fontSize: "18px" },
              },
            }}
          >
            <SettingsIcon fontSize="small" />
          </IconButton>
        </Tooltip>
      )}

      {/* Sidebar Toggle Button */}
      <Tooltip title={showSidebar ? "Hide Sidebar" : "Show Sidebar"}>
        <IconButton
          size="small"
          onClick={onToggleSidebar}
          color={showSidebar ? "primary" : "default"}
          sx={{
            backgroundColor: showSidebar
              ? "rgba(33, 150, 243, 0.15)"
              : "transparent",
            "&:hover": {
              backgroundColor: showSidebar
                ? "rgba(33, 150, 243, 0.25)"
                : "rgba(255, 255, 255, 0.08)",
            },
            "@media (max-height: 800px)": {
              padding: 0.25,
              "& .MuiSvgIcon-root": { fontSize: "18px" },
            },
          }}
        >
          <ViewSidebar fontSize="small" />
        </IconButton>
      </Tooltip>

      <Divider orientation="vertical" flexItem sx={{ mx: 0.5 }} />

      {/* Debug Control Buttons */}
      <Stack
        direction="row"
        spacing={0.5}
        alignItems="center"
        sx={{
          "@media (max-height: 800px)": {
            spacing: 0.25,
          },
        }}
      >
        {/* Break State Controls - Only show when in break state */}
        {isInBreakState && (
          <>
            <Tooltip title="Continue Execution (F5)">
              <span>
                <IconButton
                  size="small"
                  onClick={handleContinue}
                  disabled={!debuggerConnected || !attachedProcess}
                  color="success"
                  sx={{
                    backgroundColor: "rgba(76, 175, 80, 0.1)",
                    "&:hover": { backgroundColor: "rgba(76, 175, 80, 0.2)" },
                    "@media (max-height: 800px)": {
                      padding: 0.25,
                      "& .MuiSvgIcon-root": { fontSize: "18px" },
                    },
                  }}
                >
                  <PlayArrow fontSize="small" />
                </IconButton>
              </span>
            </Tooltip>

            <Tooltip title="Step Into (F10)">
              <span>
                <IconButton
                  size="small"
                  onClick={handleSingleStep}
                  disabled={!debuggerConnected || !attachedProcess}
                  color="primary"
                  sx={{
                    backgroundColor: "rgba(33, 150, 243, 0.1)",
                    "&:hover": { backgroundColor: "rgba(33, 150, 243, 0.2)" },
                    "@media (max-height: 800px)": {
                      padding: 0.25,
                      "& .MuiSvgIcon-root": { fontSize: "18px" },
                    },
                  }}
                >
                  <SkipNext fontSize="small" />
                </IconButton>
              </span>
            </Tooltip>

            {/* Thread ID Display - Clickable to show thread list */}
            {currentThreadId !== null && currentThreadId !== undefined && (
              <Tooltip
                title={
                  stoppedThreads.length > 1
                    ? "Click to switch threads"
                    : `Thread ${currentThreadId}`
                }
              >
                <Chip
                  icon={
                    stoppedThreads.length > 1 ? (
                      <SwapHoriz sx={{ fontSize: "14px !important" }} />
                    ) : undefined
                  }
                  label={`Thread:${currentThreadId}${stoppedThreads.length > 1 ? ` ${toCircledNumber(stoppedThreads.length)}` : ""}`}
                  size="small"
                  variant="outlined"
                  color="info"
                  onClick={handleThreadChipClick}
                  sx={{
                    ml: 1,
                    height: 24,
                    fontSize: "10px",
                    fontFamily: "monospace",
                    fontWeight: 600,
                    cursor: stoppedThreads.length > 1 ? "pointer" : "default",
                    "& .MuiChip-label": {
                      px: 1,
                    },
                    "&:hover":
                      stoppedThreads.length > 1
                        ? {
                            backgroundColor: "rgba(33, 150, 243, 0.1)",
                          }
                        : {},
                    "@media (max-height: 800px)": {
                      height: 20,
                      fontSize: "9px",
                      "& .MuiChip-label": { px: 0.5 },
                    },
                  }}
                />
              </Tooltip>
            )}

            {/* Thread Switcher Popover */}
            <Popover
              open={threadPopoverOpen}
              anchorEl={threadPopoverAnchor}
              onClose={() => setThreadPopoverAnchor(null)}
              anchorOrigin={{
                vertical: "bottom",
                horizontal: "left",
              }}
              transformOrigin={{
                vertical: "top",
                horizontal: "left",
              }}
            >
              <Paper sx={{ minWidth: 220, maxHeight: 300, overflow: "auto" }}>
                <Box
                  sx={{
                    px: 1,
                    py: 0.5,
                    borderBottom: 1,
                    borderColor: "divider",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "space-between",
                  }}
                >
                  <Typography
                    variant="caption"
                    sx={{ fontWeight: 600, fontSize: "10px" }}
                  >
                    Stopped Threads ({stoppedThreads.length})
                  </Typography>
                  <Tooltip
                    title={
                      showDetailFormat
                        ? "Show raw address"
                        : "Show detailed (module@symbol+offset)"
                    }
                  >
                    <Typography
                      variant="caption"
                      onClick={() => setShowDetailFormat(!showDetailFormat)}
                      sx={{
                        fontSize: "9px",
                        color: "primary.main",
                        cursor: "pointer",
                        "&:hover": { textDecoration: "underline" },
                      }}
                    >
                      {showDetailFormat ? "[detail]" : "[raw]"}
                    </Typography>
                  </Tooltip>
                </Box>
                <List dense disablePadding>
                  {stoppedThreads.map((thread, index) => (
                    <ListItem
                      key={thread.threadId}
                      disablePadding
                      sx={{
                        borderBottom:
                          index < stoppedThreads.length - 1
                            ? "1px solid"
                            : "none",
                        borderColor: "divider",
                      }}
                    >
                      <ListItemButton
                        selected={thread.isCurrent}
                        onClick={() =>
                          !thread.isCurrent &&
                          handleThreadSwitch(thread.threadId)
                        }
                        disabled={thread.isCurrent}
                        sx={{ py: 0.5, px: 1 }}
                      >
                        <Box
                          sx={{
                            display: "flex",
                            flexDirection: "column",
                            width: "100%",
                          }}
                        >
                          <Box
                            sx={{
                              display: "flex",
                              alignItems: "center",
                              gap: 0.5,
                            }}
                          >
                            <Typography
                              variant="body2"
                              sx={{
                                fontFamily: "monospace",
                                fontSize: "11px",
                                fontWeight: thread.isCurrent ? 600 : 400,
                              }}
                            >
                              {toCircledNumber(index + 1)} {thread.threadId}
                            </Typography>
                            <Typography
                              variant="caption"
                              sx={{
                                fontSize: "9px",
                                color: "text.secondary",
                              }}
                            >
                              {getExceptionTypeLabel(thread.exceptionType)}
                            </Typography>
                            {thread.isCurrent && (
                              <Typography
                                variant="caption"
                                sx={{
                                  fontSize: "9px",
                                  color: "info.main",
                                  fontWeight: 600,
                                }}
                              >
                                *
                              </Typography>
                            )}
                          </Box>
                          <Tooltip title={thread.address} placement="right">
                            <Typography
                              variant="caption"
                              sx={{
                                fontFamily: "monospace",
                                fontSize: "9px",
                                color: "text.secondary",
                                overflow: "hidden",
                                textOverflow: "ellipsis",
                                whiteSpace: "nowrap",
                                maxWidth: 200,
                                cursor: "help",
                              }}
                            >
                              {formatThreadAddress(thread.address)}
                            </Typography>
                          </Tooltip>
                        </Box>
                      </ListItemButton>
                    </ListItem>
                  ))}
                </List>
              </Paper>
            </Popover>

            <Divider orientation="vertical" flexItem sx={{ mx: 1 }} />
          </>
        )}
      </Stack>

      {/* Disassembly Navigation - Only show when stopped */}
      <Stack direction="row" spacing={1} alignItems="center">
        <Autocomplete
          freeSolo
          options={gotoHistory}
          inputValue={gotoAddress}
          onInputChange={(_, value) => uiActions.setGotoAddress(value)}
          onChange={(_, value) => {
            if (value) {
              uiActions.setGotoAddress(value);
            }
          }}
          PaperComponent={({ children, ...props }) => (
            <Paper {...props} sx={{ backgroundColor: "#2d2d2d" }}>
              {children}
            </Paper>
          )}
          renderOption={(props, option) => {
            const { key, ...restProps } = props as any;
            return (
              <Box
                key={key}
                component="li"
                {...restProps}
                onMouseDown={(e: React.MouseEvent) => {
                  e.preventDefault();
                  uiActions.setGotoAddress(option);
                }}
                sx={{
                  fontFamily: "monospace",
                  fontSize: "11px",
                  cursor: "pointer",
                  padding: "6px 12px",
                  "&:hover": { backgroundColor: "rgba(255,255,255,0.1)" },
                }}
              >
                {option}
              </Box>
            );
          }}
          renderInput={(params) => (
            <TextField
              {...params}
              label="Go to Address"
              placeholder="0x400000, lib.so+0x120, lib.so@func"
              InputLabelProps={{ shrink: true }}
              onKeyPress={(e) => {
                if (e.key === "Enter") {
                  handleGoToAddress();
                }
              }}
              size="small"
              variant="outlined"
              sx={{
                width: 280,
                "& .MuiInputBase-input": {
                  fontSize: "11px",
                  fontFamily: "monospace",
                  py: 0.5,
                },
                "@media (max-height: 800px)": {
                  width: 220,
                  "& .MuiInputBase-input": {
                    fontSize: "9px",
                    py: 0.25,
                  },
                },
              }}
            />
          )}
          sx={{
            width: 280,
            "& .MuiOutlinedInput-root": {
              height: "32px",
            },
            "@media (max-height: 800px)": {
              width: 220,
              "& .MuiOutlinedInput-root": {
                height: "24px",
              },
            },
          }}
        />
        <Tooltip title="Go to Address">
          <span>
            <IconButton
              size="small"
              onClick={handleGoToAddress}
              disabled={!gotoAddress.trim()}
              sx={{
                "@media (max-height: 800px)": {
                  padding: 0.25,
                  "& .MuiSvgIcon-root": { fontSize: "18px" },
                },
              }}
            >
              <MyLocation fontSize="small" />
            </IconButton>
          </span>
        </Tooltip>
        <Tooltip title="Go Back">
          <span>
            <IconButton
              size="small"
              onClick={() => uiActions.goBackAssemblyNavigation()}
              disabled={assemblyNavigationHistory.length === 0}
              sx={{
                "@media (max-height: 800px)": {
                  padding: 0.25,
                  "& .MuiSvgIcon-root": { fontSize: "18px" },
                },
              }}
            >
              <ArrowBack fontSize="small" />
            </IconButton>
          </span>
        </Tooltip>
      </Stack>

      <Divider orientation="vertical" flexItem sx={{ mx: 1 }} />

      {/* Breakpoint Management - Always show */}
      <Stack direction="row" spacing={1} alignItems="center">
        <TextField
          label="Set Breakpoint"
          placeholder=""
          InputLabelProps={{ shrink: true }}
          value={breakpointInput}
          onChange={(e) => setBreakpointInput(e.target.value)}
          onKeyPress={(e) => {
            if (e.key === "Enter") {
              handleSetBreakpoint();
            }
          }}
          size="small"
          variant="outlined"
          sx={{
            width: 210,
            "& .MuiOutlinedInput-root": {
              height: "32px",
            },
            "& .MuiInputBase-input": {
              fontSize: "11px",
              fontFamily: "monospace",
              py: 0.5,
            },
            "@media (max-height: 800px)": {
              width: 165,
              "& .MuiOutlinedInput-root": {
                height: "24px",
              },
              "& .MuiInputBase-input": {
                fontSize: "9px",
                py: 0.25,
              },
            },
          }}
        />
        <Tooltip title="Set Breakpoint">
          <span>
            <IconButton
              size="small"
              onClick={handleSetBreakpoint}
              disabled={!breakpointInput.trim()}
              color="error"
              sx={{
                "@media (max-height: 800px)": {
                  padding: 0.25,
                  "& .MuiSvgIcon-root": { fontSize: "18px" },
                },
              }}
            >
              <FiberManualRecord fontSize="small" />
            </IconButton>
          </span>
        </Tooltip>
        {/* Software/Hardware Breakpoint Toggle */}
        <Tooltip
          title={
            isSoftwareBreakpoint
              ? "Software Breakpoint (click for Hardware)"
              : "Hardware Breakpoint (click for Software)"
          }
        >
          <Chip
            size="small"
            label={isSoftwareBreakpoint ? "SW" : "HW"}
            onClick={() => {
              console.log(
                "[BP TYPE] Toggle clicked, current:",
                isSoftwareBreakpoint,
                "-> new:",
                !isSoftwareBreakpoint
              );
              onBreakpointTypeChange?.(!isSoftwareBreakpoint);
            }}
            color={isSoftwareBreakpoint ? "warning" : "primary"}
            variant="outlined"
            sx={{
              minWidth: 36,
              height: 24,
              fontSize: "10px",
              fontWeight: 600,
              cursor: "pointer",
              "@media (max-height: 800px)": {
                height: 20,
                fontSize: "8px",
                minWidth: 28,
              },
            }}
          />
        </Tooltip>
      </Stack>

      {/* Active Breakpoints Display - Always show when breakpoints exist */}
      {breakpoints.length > 0 && (
        <>
          <Divider
            orientation="vertical"
            flexItem
            sx={{
              mx: 1,
              "@media (max-height: 800px)": { mx: 0.5 },
            }}
          />
          <Stack
            direction="row"
            spacing={0.5}
            alignItems="center"
            sx={{
              maxWidth: 300,
              overflow: "hidden",
              "@media (max-height: 800px)": {
                maxWidth: 200,
                spacing: 0.25,
              },
            }}
          >
            <Typography
              variant="body2"
              sx={{
                fontSize: "10px",
                fontWeight: 600,
                color: "text.secondary",
                "@media (max-height: 800px)": {
                  fontSize: "8px",
                },
              }}
            >
              Active:
            </Typography>
            <Box
              sx={{
                display: "flex",
                gap: 0.5,
                flexWrap: "wrap",
                overflow: "auto",
                "@media (max-height: 800px)": {
                  gap: 0.25,
                },
              }}
            >
              {breakpoints.slice(0, 3).map((bp) => (
                <Chip
                  key={bp}
                  label={bp}
                  size="small"
                  variant="outlined"
                  color="error"
                  onClick={() => handleNavigateToBreakpoint(bp)}
                  onDelete={() => handleRemoveBreakpoint(bp)}
                  sx={{
                    height: 22,
                    fontSize: "9px",
                    fontFamily: "monospace",
                    cursor: "pointer",
                    "& .MuiChip-label": {
                      px: 0.5,
                      py: 0,
                      lineHeight: 1.2,
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      height: "100%",
                    },
                    "& .MuiChip-deleteIcon": { fontSize: "12px" },
                    "&:hover": {
                      backgroundColor: "rgba(244, 67, 54, 0.1)",
                    },
                    "@media (max-height: 800px)": {
                      height: 18,
                      fontSize: "8px",
                      "& .MuiChip-label": { px: 0.25 },
                      "& .MuiChip-deleteIcon": { fontSize: "10px" },
                    },
                  }}
                />
              ))}
              {breakpoints.length > 3 && (
                <Chip
                  size="small"
                  label={`+${breakpoints.length - 3}`}
                  onClick={() => setBreakpointListOpen(true)}
                  variant="outlined"
                  color="default"
                  sx={{
                    height: 22,
                    fontSize: "9px",
                    cursor: "pointer",
                    "& .MuiChip-label": {
                      px: 0.5,
                    },
                    "&:hover": {
                      backgroundColor: "rgba(255, 255, 255, 0.1)",
                    },
                    "@media (max-height: 800px)": {
                      height: 18,
                      fontSize: "7px",
                    },
                  }}
                />
              )}
            </Box>
          </Stack>
        </>
      )}

      <Box sx={{ flex: 1 }} />

      {/* Right side controls */}
      <Stack direction="row" spacing={0.5} alignItems="center"></Stack>

      {/* Snackbar for notifications */}
      <Snackbar
        open={snackbar.open}
        autoHideDuration={3000}
        onClose={() => setSnackbar({ ...snackbar, open: false })}
        anchorOrigin={{ vertical: "top", horizontal: "center" }}
      >
        <Alert
          onClose={() => setSnackbar({ ...snackbar, open: false })}
          severity={snackbar.severity}
          sx={{ width: "100%" }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>

      {/* Breakpoint List Dialog */}
      <Dialog
        open={breakpointListOpen}
        onClose={() => {
          setBreakpointListOpen(false);
          setSelectedBreakpoints(new Set());
        }}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle
          sx={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
          }}
        >
          <span>Active Breakpoints ({breakpoints.length})</span>
          {selectedBreakpoints.size > 0 && (
            <Button
              size="small"
              color="error"
              variant="contained"
              startIcon={<DeleteIcon />}
              onClick={() => {
                if (onRemoveBreakpoints) {
                  onRemoveBreakpoints(Array.from(selectedBreakpoints));
                } else {
                  // Fallback: remove one by one
                  selectedBreakpoints.forEach((bp) =>
                    handleRemoveBreakpoint(bp)
                  );
                }
                setSelectedBreakpoints(new Set());
              }}
            >
              Delete Selected ({selectedBreakpoints.size})
            </Button>
          )}
        </DialogTitle>
        <DialogContent dividers sx={{ p: 0 }}>
          {breakpoints.length === 0 ? (
            <Typography
              color="text.secondary"
              sx={{ py: 4, textAlign: "center" }}
            >
              No breakpoints set
            </Typography>
          ) : (
            <TableContainer sx={{ maxHeight: 400 }}>
              <Table size="small" stickyHeader>
                <TableHead>
                  <TableRow>
                    <TableCell padding="checkbox">
                      <Checkbox
                        indeterminate={
                          selectedBreakpoints.size > 0 &&
                          selectedBreakpoints.size < breakpoints.length
                        }
                        checked={
                          breakpoints.length > 0 &&
                          selectedBreakpoints.size === breakpoints.length
                        }
                        onChange={(e) => {
                          if (e.target.checked) {
                            setSelectedBreakpoints(new Set(breakpoints));
                          } else {
                            setSelectedBreakpoints(new Set());
                          }
                        }}
                      />
                    </TableCell>
                    <TableCell sx={{ fontWeight: "bold" }}>#</TableCell>
                    <TableCell sx={{ fontWeight: "bold" }}>Address</TableCell>
                    <TableCell sx={{ fontWeight: "bold" }}>Detail</TableCell>
                    <TableCell sx={{ fontWeight: "bold", width: 80 }}>
                      Type
                    </TableCell>
                    <TableCell
                      sx={{ fontWeight: "bold", width: 60 }}
                      align="center"
                    >
                      Delete
                    </TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {breakpoints.map((bp, index) => {
                    const isSoftware = softwareBreakpoints.includes(bp);
                    return (
                      <TableRow
                        key={bp}
                        hover
                        sx={{
                          "&:hover": { backgroundColor: "action.hover" },
                        }}
                      >
                        <TableCell padding="checkbox">
                          <Checkbox
                            checked={selectedBreakpoints.has(bp)}
                            onChange={(e) => {
                              const newSelected = new Set(selectedBreakpoints);
                              if (e.target.checked) {
                                newSelected.add(bp);
                              } else {
                                newSelected.delete(bp);
                              }
                              setSelectedBreakpoints(newSelected);
                            }}
                          />
                        </TableCell>
                        <TableCell
                          sx={{ fontFamily: "monospace", fontSize: "12px" }}
                        >
                          {index + 1}
                        </TableCell>
                        <TableCell>
                          <Typography
                            component="span"
                            sx={{
                              fontFamily: "monospace",
                              fontSize: "13px",
                              cursor: "pointer",
                              "&:hover": {
                                color: "primary.main",
                                textDecoration: "underline",
                              },
                            }}
                            onClick={() => {
                              handleNavigateToBreakpoint(bp);
                              setBreakpointListOpen(false);
                            }}
                          >
                            {bp}
                          </Typography>
                        </TableCell>
                        <TableCell>
                          <Typography
                            component="span"
                            sx={{
                              fontFamily: "monospace",
                              fontSize: "12px",
                              color: "text.secondary",
                            }}
                          >
                            {(() => {
                              try {
                                const addr = parseInt(
                                  bp.replace(/^0x/i, ""),
                                  16
                                );
                                if (!isNaN(addr)) {
                                  const detail = formatAddressWithSymbol(
                                    addr,
                                    attachedModules,
                                    "function"
                                  );
                                  // Only show if it's different from the raw address
                                  if (
                                    detail &&
                                    detail !== bp &&
                                    !detail.startsWith("0x")
                                  ) {
                                    return detail;
                                  }
                                }
                                return "-";
                              } catch {
                                return "-";
                              }
                            })()}
                          </Typography>
                        </TableCell>
                        <TableCell>
                          <Chip
                            label={isSoftware ? "SW" : "HW"}
                            size="small"
                            sx={{
                              backgroundColor: isSoftware
                                ? "#4caf50"
                                : "#f44336",
                              color: "white",
                              fontWeight: "bold",
                              fontSize: "10px",
                              height: "20px",
                            }}
                          />
                        </TableCell>
                        <TableCell align="center">
                          <IconButton
                            size="small"
                            onClick={() => handleRemoveBreakpoint(bp)}
                            sx={{ color: "error.main" }}
                          >
                            <DeleteIcon fontSize="small" />
                          </IconButton>
                        </TableCell>
                      </TableRow>
                    );
                  })}
                </TableBody>
              </Table>
            </TableContainer>
          )}
        </DialogContent>
        <DialogActions>
          <Button
            onClick={() => {
              setBreakpointListOpen(false);
              setSelectedBreakpoints(new Set());
            }}
          >
            Close
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

```

`src/client/src/components/DecompileView.tsx`:

```tsx
import React, {
  useState,
  useEffect,
  useCallback,
  useRef,
  useMemo,
} from "react";
import {
  Box,
  Typography,
  IconButton,
  Tooltip,
  styled,
  CircularProgress,
} from "@mui/material";
import { GhidraTokenInfo } from "../hooks/useGhidraAnalysis";
import {
  ToggleOn,
  ToggleOff,
  Code as CodeIcon,
  Transform as AIIcon,
  Refresh as RefreshIcon,
} from "@mui/icons-material";

interface DecompileViewProps {
  functionName?: string;
  functionAddress?: string;
  libraryName?: string; // Library name (e.g., libc.so.6)
  isVisible?: boolean;
  onToggleVisibility?: () => void;
  currentBreakAddress?: string | null;
  isInBreakState?: boolean;
  onLineClick?: (lineNumber: number, lineText: string) => void;
  onAIEnhance?: () => void;
  // Ghidra integration props
  ghidraCode?: string | null;
  ghidraError?: string | null; // Error message from Ghidra
  isGhidraLoading?: boolean;
  onRefreshDecompile?: () => void;
  // Address click handler for navigation to assembly
  onAddressClick?: (address: string) => void;
  // Function click handler - called when FUN_xxx is clicked in decompile code
  onFunctionClick?: (functionOffset: string) => void;
  // Line number to scroll to and highlight (set from assembly view)
  scrollToLineNumber?: number | null;
  // Line mapping from Ghidra (line number as string -> offset)
  lineMapping?: Record<string, string> | null;
  // Module base address for calculating absolute addresses
  moduleBase?: number;
  // Token information from Ghidra for accurate syntax highlighting
  tokens?: GhidraTokenInfo[] | null;
  // Breakpoint support
  activeBreakpoints?: string[]; // List of active breakpoint addresses
  onBreakpointSet?: (address: string) => void;
  onBreakpointRemove?: (address: string) => void;
}

const DecompileContainer = styled(Box)(() => ({
  height: "100%",
  backgroundColor: "#1e1e1e",
  position: "relative",
  overflow: "hidden",
  display: "flex",
  flexDirection: "column",
}));

const DecompileHeader = styled(Box)(() => ({
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  padding: "6px 12px",
  backgroundColor: "#252526",
  borderBottom: "1px solid #2d2d30",
  minHeight: "40px",
  height: "40px",
  "@media (max-height: 800px)": {
    padding: "4px 8px",
    minHeight: "30px",
    height: "30px",
  },
}));

const DecompileTitle = styled(Typography)(() => ({
  fontSize: "12px",
  fontWeight: "bold",
  color: "#4fc1ff",
  display: "flex",
  alignItems: "center",
  "& .MuiSvgIcon-root": {
    fontSize: "16px",
    marginRight: "4px",
    "@media (max-height: 800px)": {
      fontSize: "12px",
      marginRight: "2px",
    },
  },
  "@media (max-height: 800px)": {
    fontSize: "10px",
  },
}));

const DecompileContent = styled(Box)(() => ({
  flex: 1,
  overflow: "auto", // Both vertical and horizontal scroll
  padding: "8px",
  fontFamily: 'Consolas, "Courier New", monospace',
  fontSize: "12px",
  lineHeight: "18px",
  overflowX: "auto", // Explicit horizontal scroll
  "@media (max-height: 800px)": {
    padding: "4px",
    fontSize: "10px",
    lineHeight: "14px",
  },
  "&::-webkit-scrollbar": {
    width: "8px",
    height: "8px", // For horizontal scrollbar
  },
  "&::-webkit-scrollbar-track": {
    background: "#1e1e1e",
  },
  "&::-webkit-scrollbar-thumb": {
    background: "#424242",
    borderRadius: "4px",
  },
  "&::-webkit-scrollbar-thumb:hover": {
    background: "#5a5a5e",
  },
}));

const SourceLine = styled(Box, {
  shouldForwardProp: (prop) =>
    prop !== "isHighlighted" &&
    prop !== "isClickable" &&
    prop !== "hasBreakpoint" &&
    prop !== "isCurrentBreak",
})<{
  isHighlighted?: boolean;
  isClickable?: boolean;
  hasBreakpoint?: boolean;
  isCurrentBreak?: boolean;
}>(({ isHighlighted, isClickable, hasBreakpoint, isCurrentBreak }) => ({
  display: "flex",
  alignItems: "center",
  padding: "2px 8px",
  cursor: isClickable ? "pointer" : "default",
  backgroundColor: isCurrentBreak
    ? "rgba(76, 175, 80, 0.2)" // Green for current break line (same as AssemblyView)
    : hasBreakpoint
      ? "rgba(229, 20, 0, 0.15)"
      : isHighlighted
        ? "rgba(79, 193, 255, 0.15)" // Cyan for selected line (distinct from green)
        : "transparent",
  borderLeft: isCurrentBreak
    ? "3px solid #4CAF50" // Green border for current break line (same as AssemblyView)
    : hasBreakpoint
      ? "3px solid #e51400"
      : isHighlighted
        ? "3px solid #4fc1ff" // Cyan border for selected line
        : "3px solid transparent",
  whiteSpace: "nowrap", // Prevent line wrapping
  minWidth: "fit-content", // Allow line to extend beyond container
  "&:hover": {
    backgroundColor: isClickable
      ? isCurrentBreak
        ? "rgba(76, 175, 80, 0.3)" // Green hover for current break
        : hasBreakpoint
          ? "rgba(229, 20, 0, 0.25)"
          : isHighlighted
            ? "rgba(79, 193, 255, 0.25)"
            : "rgba(79, 193, 255, 0.1)"
      : isCurrentBreak
        ? "rgba(76, 175, 80, 0.2)" // Green for current break
        : hasBreakpoint
          ? "rgba(229, 20, 0, 0.15)"
          : isHighlighted
            ? "rgba(79, 193, 255, 0.15)"
            : "transparent",
  },
  transition: "background-color 0.15s ease, border-color 0.15s ease",
}));

// Code content wrapper - preserves whitespace and enables horizontal scroll
const CodeContent = styled("span")({
  flex: 1,
  whiteSpace: "pre", // Preserve whitespace including indentation
  overflow: "visible", // Allow horizontal scroll at container level
  minWidth: 0,
});

const LineNumber = styled("span")(() => ({
  color: "#858585",
  marginRight: "8px",
  minWidth: "30px",
  display: "inline-block",
  textAlign: "right",
}));

// Breakpoint gutter area (left of line numbers)
const BreakpointGutter = styled("span")<{
  hasBreakpoint?: boolean;
  hasMapping?: boolean;
}>(({ hasBreakpoint, hasMapping }) => ({
  width: "20px",
  minWidth: "20px",
  height: "18px",
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  marginRight: "4px",
  cursor: hasMapping ? "pointer" : "default",
  backgroundColor: hasBreakpoint ? "rgba(244, 135, 113, 0.15)" : "transparent",
  "&:hover": hasMapping
    ? {
        backgroundColor: hasBreakpoint
          ? "rgba(244, 135, 113, 0.25)"
          : "rgba(136, 136, 136, 0.15)",
        "& .breakpoint-dot": {
          opacity: 1,
          transform: "scale(1.1)",
        },
      }
    : {},
  "& .breakpoint-dot": {
    width: "10px",
    height: "10px",
    borderRadius: "50%",
    backgroundColor: hasBreakpoint ? "#e51400" : "#666",
    opacity: hasBreakpoint ? 1 : 0,
    transition:
      "opacity 0.15s ease, transform 0.15s ease, background-color 0.15s ease",
    boxShadow: hasBreakpoint ? "0 0 4px rgba(229, 20, 0, 0.5)" : "none",
  },
}));

const KeywordSpan = styled("span")(() => ({
  color: "#569cd6", // Blue for keywords
  fontWeight: "bold",
}));

const TypeSpan = styled("span")(() => ({
  color: "#4ec9b0", // Teal for types
}));

const StringSpan = styled("span")(() => ({
  color: "#ce9178", // Orange for strings
}));

const CommentSpan = styled("span")(() => ({
  color: "#6a9955", // Green for comments
  fontStyle: "italic",
}));

// NumberSpan - disabled per user request (no number highlighting)
// const NumberSpan = styled("span")(() => ({
//   color: "#b5cea8", // Light green for numbers
// }));

// AddressSpan - reserved for future use
// const AddressSpan = styled("span")(() => ({
//   color: "#dcdcaa", // Yellow for addresses
//   cursor: "pointer",
//   textDecoration: "underline",
//   textDecorationStyle: "dotted",
//   "&:hover": {
//     color: "#ffcc00",
//     textDecoration: "underline",
//     textDecorationStyle: "solid",
//   },
// }));

const FunctionCallSpan = styled("span")(() => ({
  color: "#dcdcaa", // Yellow for function calls
}));

// ClickableFunctionSpan - reserved for future use
// const ClickableFunctionSpan = styled("span")(() => ({
//   color: "#dcdcaa", // Yellow for function calls
//   cursor: "pointer",
//   textDecoration: "underline",
//   textDecorationStyle: "dotted",
//   "&:hover": {
//     color: "#ffcc00",
//     textDecoration: "underline",
//     textDecorationStyle: "solid",
//   },
// }));

const VariableSpan = styled("span")(() => ({
  color: "#9cdcfe", // Light blue for variables (VS Code style)
}));

// ParameterSpan - reserved for future use
// const ParameterSpan = styled("span")(() => ({
//   color: "#9cdcfe", // Light blue for parameters
// }));

const WarningSpan = styled("span")(() => ({
  color: "#ff8c00", // Orange for warnings
  fontStyle: "italic",
}));

// インデントを追加する関数（行番号を保持）
// Add indentation to decompiled C++ code without changing line numbers
const addIndentation = (lines: string[]): string[] => {
  let indentLevel = 0;
  const indentStr = "    "; // 4 spaces per indent level

  return lines.map((line) => {
    const trimmed = line.trim();

    // Skip empty lines - preserve them as empty
    if (trimmed === "") {
      return "";
    }

    // Count braces, ignoring those inside strings/chars
    let openCount = 0;
    let closeCount = 0;
    let inString = false;
    let inChar = false;
    let escape = false;

    for (let i = 0; i < trimmed.length; i++) {
      const char = trimmed[i];

      if (escape) {
        escape = false;
        continue;
      }

      if (char === "\\") {
        escape = true;
        continue;
      }

      if (!inChar && char === '"') {
        inString = !inString;
        continue;
      }

      if (!inString && char === "'") {
        inChar = !inChar;
        continue;
      }

      if (!inString && !inChar) {
        if (char === "{") {
          openCount++;
        } else if (char === "}") {
          closeCount++;
        }
      }
    }

    // Determine indent level for this line
    // If line starts with }, decrease indent before printing this line
    let lineIndent = indentLevel;

    // Count leading close braces to determine how much to decrease for this line
    let leadingCloses = 0;
    for (const char of trimmed) {
      if (char === "}") {
        leadingCloses++;
      } else if (char !== " " && char !== "\t") {
        break;
      }
    }

    // Decrease indent for leading close braces
    lineIndent = Math.max(0, lineIndent - leadingCloses);

    // Apply current indent
    const indented = indentStr.repeat(lineIndent) + trimmed;

    // Update indent level for next line
    // Net effect: +opens, -closes (but leading closes already applied to this line)
    indentLevel = Math.max(0, indentLevel + openCount - closeCount);

    return indented;
  });
};

// シンタックスハイライト機能
const highlightSyntax = (
  line: string,
  onAddressClick?: (address: string) => void,
  onFunctionClick?: (functionOffset: string) => void,
  lineFunctionTokens?: Map<string, GhidraTokenInfo>
): React.ReactNode => {
  // C/C++キーワード
  const keywords = [
    "int",
    "void",
    "char",
    "float",
    "double",
    "if",
    "else",
    "while",
    "for",
    "return",
    "break",
    "continue",
    "sizeof",
    "struct",
    "union",
    "enum",
    "const",
    "static",
    "extern",
    "auto",
    "register",
    "volatile",
    "unsigned",
    "signed",
    "long",
    "short",
    "typedef",
    "include",
    "define",
  ];

  const numberPattern = /\b\d+\b/g;
  const stringPattern = /"[^"]*"/g;
  const commentPattern = /\/\/.*$/;

  const result: React.ReactNode[] = [];

  const commentMatch = line.match(commentPattern);
  if (commentMatch) {
    const commentStart = commentMatch.index!;
    const beforeComment = line.substring(0, commentStart);
    const comment = line.substring(commentStart);

    // WARNINGコメントの特別処理
    if (comment.includes("WARNING")) {
      result.push(
        ...processSyntax(
          beforeComment,
          keywords,
          numberPattern,
          stringPattern,
          onAddressClick,
          onFunctionClick,
          lineFunctionTokens
        )
      );
      result.push(
        <WarningSpan key={`warning-${commentStart}`}>{comment}</WarningSpan>
      );
      return result;
    }

    result.push(
      ...processSyntax(
        beforeComment,
        keywords,
        numberPattern,
        stringPattern,
        onAddressClick,
        onFunctionClick,
        lineFunctionTokens
      )
    );
    result.push(
      <CommentSpan key={`comment-${commentStart}`}>{comment}</CommentSpan>
    );

    return result;
  }

  return processSyntax(
    line,
    keywords,
    numberPattern,
    stringPattern,
    onAddressClick,
    onFunctionClick,
    lineFunctionTokens
  );
};

const processSyntax = (
  text: string,
  keywords: string[],
  _numberPattern: RegExp,
  stringPattern: RegExp,
  onAddressClick?: (address: string) => void,
  onFunctionClick?: (functionOffset: string) => void,
  lineFunctionTokens?: Map<string, GhidraTokenInfo>
): React.ReactNode[] => {
  const result: React.ReactNode[] = [];
  let lastIndex = 0;

  // 文字列を先に処理
  const stringMatches = Array.from(text.matchAll(stringPattern));

  stringMatches.forEach((match, index) => {
    const start = match.index!;
    const end = start + match[0].length;

    // 文字列の前の部分を処理
    if (start > lastIndex) {
      const beforeString = text.substring(lastIndex, start);
      result.push(
        ...processKeywordsAndNumbers(
          beforeString,
          keywords,
          onAddressClick,
          onFunctionClick,
          lineFunctionTokens
        )
      );
    }

    // 文字列部分
    result.push(<StringSpan key={`string-${index}`}>{match[0]}</StringSpan>);
    lastIndex = end;
  });

  // 残りの部分を処理
  if (lastIndex < text.length) {
    const remaining = text.substring(lastIndex);
    result.push(
      ...processKeywordsAndNumbers(
        remaining,
        keywords,
        onAddressClick,
        onFunctionClick,
        lineFunctionTokens
      )
    );
  }

  return result;
};

// Variable naming patterns (common prefixes/suffixes used by Ghidra)
const VARIABLE_PATTERNS = [
  /^local_[a-zA-Z0-9_]+$/, // local_10, local_var, etc.
  /^param_\d+$/, // param_1, param_2, etc.
  /^p[A-Z][a-zA-Z0-9]*$/, // pVar1, pContext, etc.
  /^[a-z][A-Z][a-zA-Z0-9]*$/, // iVar1, uVar2, etc.
  /^[a-z]+Var\d*$/, // local var patterns
  /^DAT_[0-9a-fA-F]+$/, // DAT_00100000, etc.
  /^PTR_[0-9a-fA-F]+$/, // PTR_00100000, etc.
  /^s_[a-zA-Z0-9_]+$/, // String references
];

const isVariableName = (word: string): boolean => {
  return VARIABLE_PATTERNS.some((pattern) => pattern.test(word));
};

const processKeywordsAndNumbers = (
  text: string,
  keywords: string[],
  _onAddressClick?: (address: string) => void,
  _onFunctionClick?: (functionOffset: string) => void,
  lineFunctionTokens?: Map<string, GhidraTokenInfo> // token text -> token info for this line
): React.ReactNode[] => {
  const result: React.ReactNode[] = [];
  // Split on whitespace, punctuation, operators, and hex addresses
  // Keep delimiters in the result for proper reconstruction
  const tokens = text.split(/(\s+|[{}();,\[\]=*&<>+\-/|!~%^]|0x[0-9a-fA-F]+)/);

  tokens.forEach((token, index) => {
    if (!token) return; // Skip empty tokens

    if (keywords.includes(token)) {
      result.push(<KeywordSpan key={`keyword-${index}`}>{token}</KeywordSpan>);
    } else if (/^0x[0-9a-fA-F]+$/.test(token)) {
      // Hex address - just display as plain text (no click handler for constants)
      result.push(<span key={`addr-${index}`}>{token}</span>);
    } else if (/^\d+$/.test(token)) {
      // Numbers - just display as plain text (no special highlighting)
      result.push(<span key={`number-${index}`}>{token}</span>);
    } else if (
      token.match(/^[A-Z][a-z]+$/) ||
      token.match(
        /^(uint|int|char|void|long|short|float|double|size_t|ssize_t|bool|ulong|uchar|ushort|undefined\d*)$/
      )
    ) {
      // Type names (capitalized words or common C types)
      result.push(<TypeSpan key={`type-${index}`}>{token}</TypeSpan>);
    } else {
      // Check if this token is a function based only on Ghidra token info
      const ghidraTokenInfo = lineFunctionTokens?.get(token);

      // Token is a function only if Ghidra says it's a function token
      const isFunction =
        ghidraTokenInfo && ghidraTokenInfo.token_type === "function";

      if (isFunction) {
        // Display as function (non-clickable for now)
        result.push(
          <FunctionCallSpan key={`func-${index}`}>{token}</FunctionCallSpan>
        );
      } else if (isVariableName(token)) {
        // Variable names
        result.push(<VariableSpan key={`var-${index}`}>{token}</VariableSpan>);
      } else {
        result.push(<span key={`text-${index}`}>{token}</span>);
      }
    }
  });

  return result;
};

export const DecompileView: React.FC<DecompileViewProps> = ({
  functionName,
  functionAddress,
  libraryName,
  isVisible = true,
  onToggleVisibility,
  currentBreakAddress,
  isInBreakState = false,
  onLineClick,
  onAIEnhance,
  ghidraCode,
  ghidraError,
  isGhidraLoading = false,
  onRefreshDecompile,
  onAddressClick,
  onFunctionClick,
  scrollToLineNumber,
  lineMapping,
  moduleBase,
  tokens,
  activeBreakpoints = [],
  onBreakpointSet,
  onBreakpointRemove,
}) => {
  const [sourceLines, setSourceLines] = useState<string[]>([]);
  const [highlightedLine, setHighlightedLine] = useState<number | null>(null);
  const [isAIEnhanced, setIsAIEnhanced] = useState(false);
  const [isAIProcessing, setIsAIProcessing] = useState(false);
  const contentRef = useRef<HTMLDivElement>(null);
  const lineRefs = useRef<Map<number, HTMLDivElement>>(new Map());

  // Build a map of function tokens per line for efficient lookup
  const functionTokensByLine = useMemo(() => {
    const map = new Map<number, Map<string, GhidraTokenInfo>>();
    if (tokens) {
      for (const token of tokens) {
        // Include all function tokens, not just those with target_offset
        // This ensures functions like Game::getTotalStages are highlighted
        if (token.token_type === "function") {
          if (!map.has(token.line)) {
            map.set(token.line, new Map());
          }
          const lineMap = map.get(token.line)!;
          // Register the token text as-is
          lineMap.set(token.text, token);
          // Also register without trailing () if present (e.g., "__stack_chk_fail()" -> "__stack_chk_fail")
          if (token.text.endsWith("()")) {
            lineMap.set(token.text.slice(0, -2), token);
          }
          // Also register without trailing () and any namespace prefix stripped won't be needed
          // since we split on :: during tokenization anyway
        }
      }
    }
    return map;
  }, [tokens]);

  // Use Ghidra code if available, otherwise show empty (no pseudo code)
  useEffect(() => {
    if (ghidraCode) {
      // Split Ghidra decompiled code into lines and add proper indentation
      const rawLines = ghidraCode.split("\n");
      const indentedLines = addIndentation(rawLines);
      setSourceLines(indentedLines);
    } else {
      // Don't show pseudo-decompiled code - just show empty or placeholder
      setSourceLines([]);
    }
  }, [functionName, functionAddress, isAIEnhanced, ghidraCode]);

  // Highlight line corresponding to currentBreakAddress when in break state
  useEffect(() => {
    if (
      !isInBreakState ||
      !currentBreakAddress ||
      !lineMapping ||
      moduleBase === undefined
    ) {
      return;
    }

    // Convert currentBreakAddress (absolute) to offset
    const breakAddr = parseInt(currentBreakAddress.replace(/^0x/i, ""), 16);
    const offset = breakAddr - moduleBase;
    const offsetHex = `0x${offset.toString(16)}`;

    // Find the line that maps to this offset (or nearest line before it)
    let targetLine: number | null = null;
    let bestOffset = -Infinity;

    for (const [lineStr, mappedOffset] of Object.entries(lineMapping)) {
      const mappedOffsetNum = parseInt(mappedOffset.replace(/^0x/i, ""), 16);
      // Find the line with the largest offset that is <= our target offset
      if (mappedOffsetNum <= offset && mappedOffsetNum > bestOffset) {
        bestOffset = mappedOffsetNum;
        targetLine = parseInt(lineStr, 10);
      }
    }

    if (targetLine !== null) {
      console.log(
        `[DecompileView] Break at ${currentBreakAddress} (offset ${offsetHex}) -> line ${targetLine}`
      );
      setHighlightedLine(targetLine);

      // Scroll to the line if not visible
      const lineElement = lineRefs.current.get(targetLine);
      if (lineElement && contentRef.current) {
        const container = contentRef.current;
        const lineRect = lineElement.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();

        const isVisible =
          lineRect.top >= containerRect.top &&
          lineRect.bottom <= containerRect.bottom;

        if (!isVisible) {
          lineElement.scrollIntoView({ behavior: "instant", block: "center" });
        }
      }
    }
  }, [isInBreakState, currentBreakAddress, lineMapping, moduleBase]);

  // Scroll to line when scrollToLineNumber changes - only scroll if not visible
  const lastScrolledLineRef = useRef<number | null>(null);
  useEffect(() => {
    if (scrollToLineNumber && scrollToLineNumber > 0) {
      // Skip if same line (prevent flicker on rapid updates)
      if (lastScrolledLineRef.current === scrollToLineNumber) {
        return;
      }
      lastScrolledLineRef.current = scrollToLineNumber;

      const lineElement = lineRefs.current.get(scrollToLineNumber);
      if (lineElement && contentRef.current) {
        // Check if the line is already visible in the viewport
        const container = contentRef.current;
        const lineRect = lineElement.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();

        const isVisible =
          lineRect.top >= containerRect.top &&
          lineRect.bottom <= containerRect.bottom;

        // Only scroll if not already visible - instant scroll for auto navigation
        if (!isVisible) {
          lineElement.scrollIntoView({ behavior: "instant", block: "center" });
        }

        // Always highlight the line
        setHighlightedLine(scrollToLineNumber);
      }
    }
  }, [scrollToLineNumber]);

  // AI補完ハンドラー
  const handleAIEnhance = useCallback(async () => {
    setIsAIProcessing(true);

    // Simulate AI processing delay
    await new Promise((resolve) => setTimeout(resolve, 1500));

    setIsAIEnhanced((prev) => !prev);
    setIsAIProcessing(false);

    if (onAIEnhance) {
      onAIEnhance();
    }
  }, [onAIEnhance]);

  // Clear highlight when break state ends
  useEffect(() => {
    if (!isInBreakState) {
      setHighlightedLine(null);
    }
  }, [isInBreakState]);

  const handleLineClick = useCallback(
    (lineNumber: number, lineText: string) => {
      console.log(`Decompile view: Line ${lineNumber} clicked:`, lineText);

      // 行クリック時に行のテキストを親コンポーネントに渡す
      if (onLineClick) {
        onLineClick(lineNumber, lineText);
      }

      // Break中はクリックでハイライトを変更しない（BPハイライトを維持）
      if (isInBreakState) {
        return;
      }

      setHighlightedLine(lineNumber);
      setTimeout(() => {
        setHighlightedLine(null);
      }, 1000);
    },
    [onLineClick, isInBreakState]
  );

  // Handle breakpoint gutter click - toggle breakpoint
  const handleBreakpointClick = useCallback(
    (lineNumber: number, e: React.MouseEvent) => {
      e.stopPropagation(); // Prevent line click handler

      // Check if this line has a mapping to an address
      const lineKey = String(lineNumber);
      if (!lineMapping || !lineMapping[lineKey]) {
        console.log(
          `[DecompileView] Line ${lineNumber} has no address mapping, cannot set breakpoint`
        );
        return;
      }

      const offset = lineMapping[lineKey];
      // Calculate absolute address from module base + offset
      if (moduleBase === undefined) {
        console.log(`[DecompileView] No module base, cannot set breakpoint`);
        return;
      }

      const offsetNum = parseInt(offset.replace(/^0x/i, ""), 16);
      const absoluteAddress = moduleBase + offsetNum;
      const addressHex = `0x${absoluteAddress.toString(16)}`;

      console.log(
        `[DecompileView] Breakpoint click: line ${lineNumber}, offset ${offset}, absolute ${addressHex}`
      );

      // Check if breakpoint already exists at this address
      const hasBreakpoint = activeBreakpoints.some((bp) => {
        const bpNum = parseInt(bp.replace(/^0x/i, ""), 16);
        return bpNum === absoluteAddress;
      });

      if (hasBreakpoint) {
        // Remove breakpoint
        if (onBreakpointRemove) {
          onBreakpointRemove(addressHex);
        }
      } else {
        // Set breakpoint
        if (onBreakpointSet) {
          onBreakpointSet(addressHex);
        }
      }
    },
    [
      lineMapping,
      moduleBase,
      activeBreakpoints,
      onBreakpointSet,
      onBreakpointRemove,
    ]
  );

  // Helper to check if a line has an active breakpoint
  const lineHasBreakpoint = useCallback(
    (lineNumber: number): boolean => {
      const lineKey = String(lineNumber);
      if (!lineMapping || !lineMapping[lineKey] || moduleBase === undefined) {
        return false;
      }
      const offset = lineMapping[lineKey];
      const offsetNum = parseInt(offset.replace(/^0x/i, ""), 16);
      const absoluteAddress = moduleBase + offsetNum;

      return activeBreakpoints.some((bp) => {
        const bpNum = parseInt(bp.replace(/^0x/i, ""), 16);
        return bpNum === absoluteAddress;
      });
    },
    [lineMapping, moduleBase, activeBreakpoints]
  );

  if (!isVisible) {
    return null;
  }

  return (
    <DecompileContainer>
      <DecompileHeader>
        <DecompileTitle>
          <CodeIcon />
          {ghidraCode
            ? `Decompile: ${functionName || "Decompiled"}${libraryName ? ` - (${libraryName})` : ""}`
            : functionName
              ? `Decompiled: ${functionName}`
              : "Decompiled Source"}
          {isGhidraLoading && (
            <CircularProgress size={12} sx={{ color: "#4fc1ff", ml: 1 }} />
          )}
        </DecompileTitle>
        <Box display="flex" alignItems="center" gap={1}>
          {/* Refresh button for Ghidra decompilation */}
          {onRefreshDecompile && ghidraCode && (
            <Tooltip title="Refresh decompilation">
              <IconButton
                size="small"
                onClick={onRefreshDecompile}
                disabled={isGhidraLoading}
                sx={{
                  color: "#cccccc",
                  "&:hover": { backgroundColor: "#3c3c3c" },
                }}
              >
                <RefreshIcon fontSize="small" />
              </IconButton>
            </Tooltip>
          )}

          {/* AI functionality temporarily hidden */}
          {false && (
            <Tooltip
              title={
                isAIEnhanced
                  ? "Disable AI enhancements"
                  : "Enable AI enhancements"
              }
            >
              <IconButton
                size="small"
                onClick={handleAIEnhance}
                disabled={isAIProcessing}
                sx={{
                  color: isAIEnhanced ? "#4fc1ff" : "#cccccc",
                  "&:hover": { backgroundColor: "#3c3c3c" },
                  ml: 1, // Add margin-left for spacing from title
                }}
              >
                {isAIProcessing ? (
                  <CircularProgress size={16} sx={{ color: "#4fc1ff" }} />
                ) : (
                  <AIIcon fontSize="small" />
                )}
              </IconButton>
            </Tooltip>
          )}

          {onToggleVisibility && (
            <Tooltip title="Toggle decompile view">
              <IconButton
                size="small"
                onClick={onToggleVisibility}
                sx={{
                  color: isVisible ? "#4fc1ff" : "#cccccc",
                  "&:hover": { backgroundColor: "#3c3c3c" },
                }}
              >
                {isVisible ? (
                  <ToggleOn fontSize="small" />
                ) : (
                  <ToggleOff fontSize="small" />
                )}
              </IconButton>
            </Tooltip>
          )}
        </Box>
      </DecompileHeader>

      {/* Error display */}
      {ghidraError && !isGhidraLoading && (
        <Box
          sx={{
            padding: "12px 16px",
            backgroundColor: "#3c1f1f",
            borderBottom: "1px solid #5c2f2f",
            color: "#f48771",
            fontSize: "12px",
            fontFamily: "monospace",
            whiteSpace: "pre-wrap",
            wordBreak: "break-word",
            maxHeight: "150px",
            overflow: "auto",
          }}
        >
          <Typography
            variant="caption"
            sx={{
              color: "#ff6b6b",
              fontWeight: "bold",
              display: "block",
              mb: 0.5,
            }}
          >
            Decompile Error:
          </Typography>
          {ghidraError}
        </Box>
      )}

      <DecompileContent ref={contentRef}>
        {sourceLines.map((line, index) => {
          const lineNumber = index + 1;
          const isCurrentBreak =
            isInBreakState && highlightedLine === lineNumber;
          const isClickable = line.trim() !== "" && !line.startsWith("//");
          // Check if this line has a mapping (clickable to navigate to assembly)
          const lineKey = String(lineNumber);
          const hasMapping = lineMapping && lineMapping[lineKey];
          // Get function tokens for this line
          const lineFunctionTokens = functionTokensByLine.get(lineNumber);
          const hasBp = lineHasBreakpoint(lineNumber);

          return (
            <SourceLine
              key={lineNumber}
              ref={(el: HTMLDivElement | null) => {
                if (el) {
                  lineRefs.current.set(lineNumber, el);
                } else {
                  lineRefs.current.delete(lineNumber);
                }
              }}
              isHighlighted={false}
              isClickable={isClickable || !!hasMapping}
              hasBreakpoint={hasBp && !isCurrentBreak}
              isCurrentBreak={isCurrentBreak}
              onClick={() => isClickable && handleLineClick(lineNumber, line)}
            >
              <BreakpointGutter
                hasBreakpoint={lineHasBreakpoint(lineNumber)}
                hasMapping={!!hasMapping}
                onClick={(e) =>
                  hasMapping && handleBreakpointClick(lineNumber, e)
                }
              >
                <span className="breakpoint-dot" />
              </BreakpointGutter>
              <LineNumber>{lineNumber}</LineNumber>
              <CodeContent>
                {highlightSyntax(
                  line,
                  onAddressClick,
                  onFunctionClick,
                  lineFunctionTokens
                )}
              </CodeContent>
            </SourceLine>
          );
        })}
      </DecompileContent>
    </DecompileContainer>
  );
};

```

`src/client/src/components/DocumentationContent.tsx`:

```tsx
import React from "react";
import {
  Box,
  Typography,
  Card,
  CardContent,
  CardActionArea,
  Stack,
  Chip,
  alpha,
  useMediaQuery,
} from "@mui/material";
import {
  MenuBook as MenuBookIcon,
  Apple as AppleIcon,
  BugReport as BugReportIcon,
  Launch as LaunchIcon,
  Description as DescriptionIcon,
} from "@mui/icons-material";
import { openUrl } from "@tauri-apps/plugin-opener";

interface DocumentItem {
  title: string;
  description: string;
  url: string;
  icon: React.ReactNode;
  tags: string[];
  type: "pdf" | "article" | "video";
}

const documents: DocumentItem[] = [
  {
    title: "Creating a GUI-based macOS & iOS ARM64 Debugger",
    description:
      "Technical documentation explaining the architecture and implementation details of DynaDbg's macOS and iOS ARM64 debugging capabilities. This document covers the low-level debugging mechanisms, Mach API interactions, and GUI integration.",
    url: "https://github.com/DoranekoSystems/DynaDbg/blob/main/doc/Creating%20a%20GUI-based%20macOS%26iOS%20ARM64%20Debugger.pdf",
    icon: <AppleIcon sx={{ fontSize: 48 }} />,
    tags: ["macOS", "iOS", "ARM64", "Technical"],
    type: "pdf",
  },
];

export const DocumentationContent: React.FC = () => {
  // Compact mode for height < 800px
  const isCompactHeight = useMediaQuery("(max-height: 800px)");

  const handleDocumentClick = async (url: string) => {
    try {
      await openUrl(url);
    } catch (error) {
      console.error("Failed to open URL:", error);
      // Fallback to window.open
      window.open(url, "_blank", "noopener,noreferrer");
    }
  };

  return (
    <Box
      sx={{
        height: "100%",
        overflow: "auto",
        backgroundColor: "#0f0f0f",
        p: isCompactHeight ? 2 : 4,
        "&::-webkit-scrollbar": {
          width: "8px",
        },
        "&::-webkit-scrollbar-track": {
          background: "#1a1a1a",
        },
        "&::-webkit-scrollbar-thumb": {
          background: "#3a3a3a",
          borderRadius: "4px",
          "&:hover": {
            background: "#4a4a4a",
          },
        },
      }}
    >
      {/* Header Section */}
      <Box sx={{ mb: isCompactHeight ? 2 : 4, textAlign: "center" }}>
        <Stack
          direction="row"
          justifyContent="center"
          alignItems="center"
          spacing={2}
          sx={{ mb: isCompactHeight ? 1 : 2 }}
        >
          <MenuBookIcon
            sx={{ fontSize: isCompactHeight ? 28 : 40, color: "#3b82f6" }}
          />
          <Typography
            variant={isCompactHeight ? "h5" : "h4"}
            sx={{
              fontWeight: 600,
              background: "linear-gradient(135deg, #3b82f6, #8b5cf6)",
              backgroundClip: "text",
              WebkitBackgroundClip: "text",
              WebkitTextFillColor: "transparent",
            }}
          >
            Documentation
          </Typography>
        </Stack>
        <Typography variant="body1" color="text.secondary">
          Technical documents and resources for DynaDbg
        </Typography>
      </Box>

      {/* Documents Grid */}
      <Box sx={{ maxWidth: 1000, mx: "auto" }}>
        <Typography
          variant="h6"
          sx={{
            mb: isCompactHeight ? 2 : 3,
            color: "#e5e7eb",
            display: "flex",
            alignItems: "center",
            gap: 1,
          }}
        >
          <BugReportIcon sx={{ color: "#3b82f6" }} />
          Technical Documents
        </Typography>

        <Stack spacing={isCompactHeight ? 2 : 3}>
          {documents.map((doc, index) => (
            <Card
              key={index}
              sx={{
                backgroundColor: alpha("#1a1a1a", 0.8),
                border: "1px solid #2d2d2d",
                borderRadius: 2,
                transition: "all 0.3s ease",
                "&:hover": {
                  borderColor: "#3b82f6",
                  transform: "translateY(-2px)",
                  boxShadow: `0 8px 30px ${alpha("#3b82f6", 0.15)}`,
                },
              }}
            >
              <CardActionArea onClick={() => handleDocumentClick(doc.url)}>
                <CardContent sx={{ p: isCompactHeight ? 2 : 3 }}>
                  <Stack
                    direction={{ xs: "column", sm: "row" }}
                    spacing={isCompactHeight ? 2 : 3}
                  >
                    {/* Icon Section */}
                    <Box
                      sx={{
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                        width: { xs: "100%", sm: isCompactHeight ? 80 : 120 },
                        height: {
                          xs: isCompactHeight ? 60 : 80,
                          sm: isCompactHeight ? 80 : 120,
                        },
                        backgroundColor: alpha("#3b82f6", 0.1),
                        borderRadius: 2,
                        flexShrink: 0,
                      }}
                    >
                      <Box
                        sx={{
                          color: "#3b82f6",
                          display: "flex",
                          flexDirection: "column",
                          alignItems: "center",
                          gap: 1,
                        }}
                      >
                        {doc.icon}
                        <Chip
                          label={doc.type.toUpperCase()}
                          size="small"
                          sx={{
                            height: 20,
                            fontSize: "10px",
                            fontWeight: 600,
                            backgroundColor:
                              doc.type === "pdf"
                                ? alpha("#ef4444", 0.2)
                                : alpha("#3b82f6", 0.2),
                            color: doc.type === "pdf" ? "#f87171" : "#60a5fa",
                            border: "none",
                          }}
                        />
                      </Box>
                    </Box>

                    {/* Content Section */}
                    <Box sx={{ flex: 1 }}>
                      <Stack
                        direction="row"
                        alignItems="center"
                        spacing={1}
                        sx={{ mb: 1 }}
                      >
                        <Typography
                          variant="h6"
                          sx={{
                            color: "#fff",
                            fontWeight: 500,
                            fontSize: "1.1rem",
                          }}
                        >
                          {doc.title}
                        </Typography>
                        <LaunchIcon sx={{ fontSize: 16, color: "#6b7280" }} />
                      </Stack>

                      <Typography
                        variant="body2"
                        sx={{
                          color: "#9ca3af",
                          mb: 2,
                          lineHeight: 1.7,
                        }}
                      >
                        {doc.description}
                      </Typography>

                      <Stack
                        direction="row"
                        spacing={1}
                        flexWrap="wrap"
                        useFlexGap
                      >
                        {doc.tags.map((tag, tagIndex) => (
                          <Chip
                            key={tagIndex}
                            label={tag}
                            size="small"
                            sx={{
                              height: 24,
                              fontSize: "11px",
                              backgroundColor: alpha("#3b82f6", 0.1),
                              color: "#60a5fa",
                              border: "none",
                            }}
                          />
                        ))}
                      </Stack>
                    </Box>
                  </Stack>
                </CardContent>
              </CardActionArea>
            </Card>
          ))}
        </Stack>

        {/* Coming Soon Section */}
        <Box
          sx={{
            mt: isCompactHeight ? 3 : 6,
            p: isCompactHeight ? 2 : 4,
            backgroundColor: alpha("#1a1a1a", 0.5),
            borderRadius: 2,
            border: "1px dashed #3d3d3d",
            textAlign: "center",
          }}
        >
          <DescriptionIcon
            sx={{
              fontSize: isCompactHeight ? 32 : 48,
              color: "#4b5563",
              mb: isCompactHeight ? 1 : 2,
            }}
          />
          <Typography variant="h6" sx={{ mb: 1, color: "#6b7280" }}>
            More Documentation Coming Soon
          </Typography>
          <Typography variant="body2" color="text.secondary">
            Additional technical documents, tutorials, and API references will
            be added in future updates.
          </Typography>
        </Box>
      </Box>
    </Box>
  );
};

```

`src/client/src/components/ExceptionMonitor.tsx`:

```tsx
import React, { useState, useEffect, useCallback } from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Typography,
  Box,
  Chip,
  IconButton,
  Tooltip,
  Alert,
} from "@mui/material";
import {
  PlayArrow,
  Pause,
  Clear,
  Refresh,
  BugReport,
} from "@mui/icons-material";
import { ExceptionInfo } from "../types";
import { getApiClient } from "../lib/api";

interface ExceptionMonitorProps {
  watchpoint: WatchpointInfo; // Single watchpoint instead of array
  onClose: () => void; // Simplified close handler
  open: boolean; // Add open prop to control dialog visibility
}

import { WatchpointInfo } from "../types";

export const ExceptionMonitor: React.FC<ExceptionMonitorProps> = ({
  watchpoint,
  onClose,
  open,
}) => {
  const [exceptions, setExceptions] = useState<ExceptionInfo[]>([]);
  const [isPolling, setIsPolling] = useState(false);
  const [pollingInterval, setPollingInterval] = useState<number | null>(null);
  const [error, setError] = useState<string | null>(null);

  // Parse instruction field to extract address, bytecode, and opcode
  const parseInstruction = useCallback((instruction: string) => {
    try {
      const parts = instruction.split("|");
      if (parts.length >= 3) {
        const address = parts[0]; // e.g., "0x107ab7920"
        const bytecode = parts[1]; // e.g., "13 00 40 B9"
        const opcodeInfo = parts[2].split("\n")[0]; // e.g., "ldr w19, [x0]"

        return {
          address,
          bytecode,
          opcode: opcodeInfo,
        };
      }
    } catch (error) {
      console.error("Failed to parse instruction:", error);
    }

    return {
      address: "unknown",
      bytecode: "unknown",
      opcode: "unknown",
    };
  }, []);

  // Fetch exception information
  const fetchExceptions = useCallback(async () => {
    try {
      const apiClient = getApiClient();
      const response = await apiClient.getExceptionInfo();

      if (response.success) {
        // response.exceptions is already the flat array we need
        const parsedExceptions = response.exceptions.map(
          (exception: ExceptionInfo, index: number) => {
            // If the exception already has parsed data, use it
            if (exception.address && exception.bytecode && exception.opcode) {
              return exception;
            }

            // Otherwise, try to parse from raw data if available
            const rawData = exception as any;
            if (rawData.instruction) {
              const instructionInfo = parseInstruction(rawData.instruction);
              return {
                ...exception,
                address: instructionInfo.address,
                bytecode: instructionInfo.bytecode,
                opcode: instructionInfo.opcode,
                index: exception.index || index,
                count: exception.count || 1,
                timestamp: exception.timestamp || new Date(),
              };
            }

            return exception;
          }
        );

        // Filter exceptions to only show those related to current watchpoint
        const filteredExceptions = parsedExceptions.filter(
          (exception: ExceptionInfo) => {
            if (!exception.address) return false;

            const exceptionAddr = parseInt(exception.address, 16);
            const watchpointAddr =
              typeof watchpoint.address === "string"
                ? parseInt(watchpoint.address, 16)
                : watchpoint.address;
            return exceptionAddr === watchpointAddr;
          }
        );

        setExceptions(filteredExceptions);
        setError(null);
      } else {
        setError(response.message || "Failed to fetch exception information");
      }
    } catch (error) {
      console.error("Error fetching exceptions:", error);
      setError("Failed to connect to server");
    }
  }, [parseInstruction, watchpoint]);

  // Start polling
  const startPolling = useCallback(() => {
    if (pollingInterval) return;

    setIsPolling(true);
    const interval = setInterval(fetchExceptions, 100); // Poll every 100ms for faster updates
    setPollingInterval(interval);
  }, [fetchExceptions, pollingInterval]);

  // Stop polling
  const stopPolling = useCallback(() => {
    if (pollingInterval) {
      clearInterval(pollingInterval);
      setPollingInterval(null);
    }
    setIsPolling(false);
  }, [pollingInterval]);

  // Clear exceptions
  const clearExceptions = useCallback(() => {
    setExceptions([]);
    setError(null);
  }, []);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (pollingInterval) {
        clearInterval(pollingInterval);
      }
    };
  }, [pollingInterval]);

  // Auto-start polling when dialog opens
  useEffect(() => {
    if (open && !isPolling) {
      startPolling();
    }
  }, [open, isPolling, startPolling]);

  // Stop polling when dialog closes
  useEffect(() => {
    if (!open && isPolling) {
      stopPolling();
    }
  }, [open, isPolling, stopPolling]);

  return (
    <Dialog
      open={open}
      onClose={onClose}
      maxWidth="lg"
      fullWidth
      PaperProps={{
        sx: {
          height: "80vh",
          maxHeight: "800px",
        },
      }}
    >
      <DialogTitle>
        <Box display="flex" alignItems="center" justifyContent="space-between">
          <Box display="flex" alignItems="center" gap={1}>
            <BugReport color="warning" />
            <Typography variant="h6">Watchpoint Exception Monitor</Typography>
            <Chip
              label={isPolling ? "Monitoring" : "Stopped"}
              color={isPolling ? "success" : "default"}
              size="small"
            />
            <Chip
              label="Single watchpoint"
              color="primary"
              size="small"
              variant="outlined"
            />
          </Box>
          <Box display="flex" gap={1}>
            <Tooltip title={isPolling ? "Stop Monitoring" : "Start Monitoring"}>
              <IconButton
                onClick={isPolling ? stopPolling : startPolling}
                color={isPolling ? "error" : "primary"}
              >
                {isPolling ? <Pause /> : <PlayArrow />}
              </IconButton>
            </Tooltip>
            <Tooltip title="Refresh Now">
              <IconButton onClick={fetchExceptions} disabled={isPolling}>
                <Refresh />
              </IconButton>
            </Tooltip>
            <Tooltip title="Clear All">
              <IconButton onClick={clearExceptions} color="warning">
                <Clear />
              </IconButton>
            </Tooltip>
          </Box>
        </Box>
      </DialogTitle>

      <DialogContent dividers>
        {error && (
          <Alert severity="error" sx={{ mb: 2 }}>
            {error}
          </Alert>
        )}

        <TableContainer component={Paper} sx={{ height: "100%" }}>
          <Table stickyHeader size="small">
            <TableHead>
              <TableRow>
                <TableCell>Index</TableCell>
                <TableCell>Count</TableCell>
                <TableCell>Address</TableCell>
                <TableCell>Bytecode</TableCell>
                <TableCell>Opcode</TableCell>
                <TableCell>Timestamp</TableCell>
                <TableCell>Watchpoint ID</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {exceptions.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={7} align="center">
                    <Typography variant="body2" color="text.secondary">
                      {isPolling
                        ? "Monitoring for exceptions..."
                        : "No exceptions found"}
                    </Typography>
                  </TableCell>
                </TableRow>
              ) : (
                exceptions.map((exception) => (
                  <TableRow key={`${exception.index}-${exception.address}`}>
                    <TableCell>
                      <Typography variant="body2" fontFamily="monospace">
                        {exception.index}
                      </Typography>
                    </TableCell>
                    <TableCell>
                      <Typography variant="body2" fontFamily="monospace">
                        {exception.count}
                      </Typography>
                    </TableCell>
                    <TableCell>
                      <Typography
                        variant="body2"
                        fontFamily="monospace"
                        color="primary"
                      >
                        {exception.address}
                      </Typography>
                    </TableCell>
                    <TableCell>
                      <Typography
                        variant="body2"
                        fontFamily="monospace"
                        fontSize="0.8rem"
                      >
                        {exception.bytecode}
                      </Typography>
                    </TableCell>
                    <TableCell>
                      <Typography
                        variant="body2"
                        fontFamily="monospace"
                        fontWeight="bold"
                      >
                        {exception.opcode || "Loading..."}
                      </Typography>
                    </TableCell>
                    <TableCell>
                      <Typography variant="body2" color="text.secondary">
                        {new Date(exception.timestamp).toLocaleTimeString()}
                      </Typography>
                    </TableCell>
                    <TableCell>
                      {exception.watchpointId ? (
                        <Typography
                          variant="body2"
                          color="primary"
                          fontFamily="monospace"
                        >
                          {exception.watchpointId}
                        </Typography>
                      ) : (
                        // Check if this exception matches our current watchpoint
                        (() => {
                          const exceptionAddr = parseInt(exception.address, 16);
                          const watchpointAddr =
                            typeof watchpoint.address === "string"
                              ? parseInt(watchpoint.address, 16)
                              : watchpoint.address;

                          const isMatch = exceptionAddr === watchpointAddr;

                          return isMatch ? (
                            <Box>
                              <Typography
                                variant="body2"
                                color="success.main"
                                fontFamily="monospace"
                                fontSize="0.8rem"
                              >
                                {watchpoint.id}
                              </Typography>
                              <Typography
                                variant="caption"
                                color="text.secondary"
                              >
                                {watchpoint.accessType} ({watchpoint.size}B)
                              </Typography>
                            </Box>
                          ) : (
                            <Typography variant="body2" color="text.secondary">
                              -
                            </Typography>
                          );
                        })()
                      )}
                    </TableCell>
                  </TableRow>
                ))
              )}
            </TableBody>
          </Table>
        </TableContainer>
      </DialogContent>

      <DialogActions>
        <Typography
          variant="caption"
          color="text.secondary"
          sx={{ mr: "auto" }}
        >
          {exceptions.length} exception{exceptions.length !== 1 ? "s" : ""}{" "}
          found
        </Typography>
        <Button onClick={onClose}>Close</Button>
      </DialogActions>
    </Dialog>
  );
};

```

`src/client/src/components/ExpandableTreeItem.tsx`:

```tsx
import React from "react";
import { Box, styled } from "@mui/material";
import TreeItem from "./TreeItem";

interface ChipData {
  label: string;
  color?:
    | "default"
    | "primary"
    | "secondary"
    | "error"
    | "info"
    | "success"
    | "warning";
  variant?: "filled" | "outlined";
}

interface ExpandableTreeItemProps {
  children: React.ReactNode;
  icon?: React.ComponentType;
  color?: string;
  active?: boolean;
  highlighted?: boolean;
  onClick?: () => void;
  chips?: ChipData[];
  expanded?: boolean;
  onToggle?: () => void;
}

const ExpandableContainer = styled(Box)(() => ({
  position: "relative",
}));

export default function ExpandableTreeItem({
  children,
  icon,
  color,
  active,
  highlighted,
  onClick,
  chips = [],
  onToggle,
}: ExpandableTreeItemProps) {
  const handleClick = () => {
    if (onToggle) {
      onToggle();
    }
    if (onClick) {
      onClick();
    }
  };

  return (
    <ExpandableContainer>
      <TreeItem
        icon={icon}
        color={color}
        active={active}
        highlighted={highlighted}
        onClick={handleClick}
        chips={chips}
      >
        {children}
      </TreeItem>
    </ExpandableContainer>
  );
}

```

`src/client/src/components/Footer.tsx`:

```tsx
import React from "react";
import {
  Box,
  Container,
  Typography,
  Stack,
  IconButton,
  Divider,
  useTheme,
} from "@mui/material";
import { GitHub } from "@mui/icons-material";

const TwitterIcon = (props: any) => (
  <svg viewBox="0 0 24 24" {...props}>
    <path
      fill="currentColor"
      d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"
    />
  </svg>
);

interface FooterProps {
  onAboutClick?: () => void;
}

export const Footer: React.FC<FooterProps> = ({ onAboutClick }) => {
  const theme = useTheme();

  return (
    <Box
      sx={{
        backgroundColor: theme.palette.background.paper,
        py: 4,
        mt: 8,
        borderTop: 1,
        borderColor: "divider",
      }}
    >
      <Container maxWidth="lg">
        <Stack spacing={3} alignItems="center">
          <Typography variant="body2" color="text.secondary" fontWeight="500">
            Created by Kenjiro Ichise
          </Typography>

          <Stack direction="row" spacing={3}>
            <IconButton
              component="a"
              href="https://twitter.com/DoranekoSystems"
              target="_blank"
              rel="noopener noreferrer"
              color="inherit"
              sx={{
                color: "text.secondary",
                "&:hover": {
                  color: "primary.main",
                  transform: "translateY(-2px)",
                },
                transition: "all 0.2s",
              }}
            >
              <TwitterIcon width={20} height={20} />
            </IconButton>

            <IconButton
              component="a"
              href="https://github.com/DoranekoSystems"
              target="_blank"
              rel="noopener noreferrer"
              color="inherit"
              sx={{
                color: "text.secondary",
                "&:hover": {
                  color: "primary.main",
                  transform: "translateY(-2px)",
                },
                transition: "all 0.2s",
              }}
            >
              <GitHub />
            </IconButton>
          </Stack>

          <Divider sx={{ width: "100%" }} />

          <Stack
            direction={{ xs: "column", sm: "row" }}
            justifyContent="space-between"
            alignItems="center"
            width="100%"
            spacing={2}
          >
            <Typography variant="caption" color="text.disabled">
              © 2025{" "}
              <Typography
                component="span"
                variant="caption"
                sx={{
                  cursor: "pointer",
                  color: "text.disabled",
                  "&:hover": { color: "primary.main" },
                  transition: "color 0.2s",
                }}
                onClick={onAboutClick}
              >
                DoranekoSystems
              </Typography>
              . All rights reserved.
            </Typography>
            <Stack direction="row" spacing={3}>
              <Typography
                variant="caption"
                color="text.disabled"
                sx={{
                  cursor: "pointer",
                  "&:hover": { color: "text.secondary" },
                  transition: "color 0.2s",
                }}
              >
                Privacy Policy
              </Typography>
              <Typography
                variant="caption"
                color="text.disabled"
                sx={{
                  cursor: "pointer",
                  "&:hover": { color: "text.secondary" },
                  transition: "color 0.2s",
                }}
              >
                Terms of Service
              </Typography>
              <Typography
                variant="caption"
                color="text.disabled"
                sx={{
                  cursor: "pointer",
                  "&:hover": { color: "text.secondary" },
                  transition: "color 0.2s",
                }}
              >
                Documentation
              </Typography>
            </Stack>
          </Stack>
        </Stack>
      </Container>
    </Box>
  );
};

```

`src/client/src/components/FunctionTreeItem.tsx`:

```tsx
import React from "react";
import TreeItem from "./TreeItem";

interface ChipData {
  label: string;
  color?:
    | "default"
    | "primary"
    | "secondary"
    | "error"
    | "info"
    | "success"
    | "warning";
  variant?: "filled" | "outlined";
}

interface FunctionTreeItemProps {
  children: React.ReactNode;
  functionAddress?: string;
  icon?: React.ComponentType;
  color?: string;
  active?: boolean;
  highlighted?: boolean;
  onClick?: () => void;
  chips?: ChipData[];
}

export default function FunctionTreeItem({
  children,
  functionAddress,
  icon,
  color,
  active,
  highlighted,
  onClick,
  chips = [],
}: FunctionTreeItemProps) {
  return (
    <TreeItem
      icon={icon}
      color={color}
      active={active}
      highlighted={highlighted}
      onClick={onClick}
      chips={chips}
      details={functionAddress}
    >
      {children}
    </TreeItem>
  );
}

```

`src/client/src/components/GhidraAnalyzer.tsx`:

```tsx
import React, {
  useState,
  useCallback,
  useEffect,
  useMemo,
  useRef,
} from "react";
import {
  Box,
  Typography,
  TextField,
  Button,
  Paper,
  Alert,
  LinearProgress,
  IconButton,
  Tooltip,
  InputAdornment,
  Chip,
  CircularProgress,
  Autocomplete,
} from "@mui/material";
import {
  Settings as SettingsIcon,
  PlayArrow as PlayArrowIcon,
  Check as CheckIcon,
  Error as ErrorIcon,
  Info as InfoIcon,
  Refresh as RefreshIcon,
  Extension as ExtensionIcon,
  Folder as FolderIcon,
} from "@mui/icons-material";
import { invoke } from "@tauri-apps/api/core";
import { getApiClient, ModuleInfo } from "../lib/api";
import { useUIStore } from "../stores/uiStore";

// LocalStorage keys
const GHIDRA_PATH_KEY = "dynadbg_ghidra_path";
const GHIDRA_ANALYZED_LIBS_KEY = "dynadbg_analyzed_libraries";

interface GhidraAnalyzerProps {
  serverConnected: boolean;
  targetOs?: string;
}

interface AnalysisLog {
  timestamp: number;
  type: "info" | "error" | "success" | "output";
  message: string;
}

interface AnalyzedLibrary {
  libraryPath: string;
  localPath: string;
  projectPath: string;
  analyzedAt: number;
  functions?: Array<{ name: string; address: string; size: number }>;
}

interface GhidraAnalysisStatus {
  library_path: string;
  analyzed: boolean;
  project_path: string | null;
  error: string | null;
}

// Helper function to get module path - use path field, or modulename if it looks like a path
const getModulePath = (module: ModuleInfo): string | null => {
  if (module.path) {
    return module.path;
  }
  // Check if modulename looks like a path (starts with / or contains path separators)
  const modulename = module.modulename || module.name || "";
  if (
    modulename.startsWith("/") ||
    modulename.includes("/") ||
    modulename.includes("\\")
  ) {
    return modulename;
  }
  return null;
};

export const GhidraAnalyzer: React.FC<GhidraAnalyzerProps> = ({
  serverConnected,
  targetOs,
}) => {
  // Get persisted state from uiStore
  const toolsState = useUIStore((state) => state.toolsState);
  const updateToolsState = useUIStore(
    (state) => state.actions.updateToolsState
  );

  // Ghidra path settings - use uiStore for persistence
  const [ghidraPath, setGhidraPath] = useState<string>(() => {
    return toolsState.ghidraPath || localStorage.getItem(GHIDRA_PATH_KEY) || "";
  });
  const [ghidraPathInput, setGhidraPathInput] = useState<string>(ghidraPath);
  const [isPathValid, setIsPathValid] = useState<boolean | null>(null);

  // Ghidra project name - for organizing analyzed libraries
  const GHIDRA_PROJECT_NAME_KEY = "dynadbg_ghidra_project_name";
  const [projectName, setProjectName] = useState<string>(() => {
    return (
      toolsState.ghidraProjectName ||
      localStorage.getItem(GHIDRA_PROJECT_NAME_KEY) ||
      ""
    );
  });
  const [projectNameInput, setProjectNameInput] = useState<string>(projectName);

  // Module list - use uiStore for persistence
  const modules = toolsState.ghidraModules || [];
  const setModules = useCallback(
    (newModules: ModuleInfo[]) => {
      updateToolsState({ ghidraModules: newModules });
    },
    [updateToolsState]
  );
  const [moduleFilter] = useState<string>(toolsState.ghidraModuleFilter || "");
  const [selectedModule, setSelectedModule] = useState<ModuleInfo | null>(null);
  const [isLoadingModules, setIsLoadingModules] = useState(false);

  // Analysis state - use uiStore for persistence
  const [isAnalyzing, setIsAnalyzing] = useState(
    toolsState.ghidraIsAnalyzing || false
  );

  // Ghidra server state - use uiStore for persistence across tab switches
  const serverStatus = toolsState.ghidraServerStatus || "stopped";
  const serverPort = toolsState.ghidraServerPort;
  const serverProjectPath = toolsState.ghidraServerProjectPath;

  const setServerStatus = useCallback(
    (status: "stopped" | "starting" | "running" | "stopping") => {
      updateToolsState({ ghidraServerStatus: status });
    },
    [updateToolsState]
  );

  const setServerPort = useCallback(
    (port: number | null) => {
      updateToolsState({ ghidraServerPort: port });
    },
    [updateToolsState]
  );

  const setServerProjectPath = useCallback(
    (path: string | null) => {
      updateToolsState({ ghidraServerProjectPath: path });
    },
    [updateToolsState]
  );

  const [analysisProgress, setAnalysisProgress] = useState<string>(
    toolsState.ghidraAnalysisProgress || ""
  );
  const [analysisLogs, setAnalysisLogs] = useState<AnalysisLog[]>(
    toolsState.ghidraAnalysisLogs || []
  );
  const [analyzedLibraries, setAnalyzedLibraries] = useState<
    Map<string, AnalyzedLibrary>
  >(() => {
    try {
      const saved = localStorage.getItem(GHIDRA_ANALYZED_LIBS_KEY);
      if (saved) {
        const libs: AnalyzedLibrary[] = JSON.parse(saved);
        const map = new Map<string, AnalyzedLibrary>();
        libs.forEach((lib) => map.set(lib.libraryPath, lib));
        return map;
      }
    } catch (e) {
      console.error("Failed to load analyzed libraries:", e);
    }
    return new Map();
  });

  // Log output ref for auto-scroll
  const logContainerRef = useRef<HTMLDivElement>(null);

  // Sync state to uiStore when it changes
  useEffect(() => {
    updateToolsState({
      ghidraModuleFilter: moduleFilter,
      ghidraAnalysisLogs: analysisLogs,
      ghidraAnalysisProgress: analysisProgress,
      ghidraIsAnalyzing: isAnalyzing,
      ghidraSelectedModuleBase: selectedModule?.base || null,
    });
  }, [
    moduleFilter,
    analysisLogs,
    analysisProgress,
    isAnalyzing,
    selectedModule,
    updateToolsState,
  ]);

  // Restore selected module from uiStore when modules are loaded
  useEffect(() => {
    if (modules.length > 0 && toolsState.ghidraSelectedModuleBase !== null) {
      const savedModule = modules.find(
        (m) => m.base === toolsState.ghidraSelectedModuleBase
      );
      if (savedModule && !selectedModule) {
        setSelectedModule(savedModule);
      }
    }
  }, [modules, toolsState.ghidraSelectedModuleBase]);

  // Add log entry
  const addLog = useCallback((type: AnalysisLog["type"], message: string) => {
    setAnalysisLogs((prev) => [
      ...prev,
      { timestamp: Date.now(), type, message },
    ]);
  }, []);

  // Clear logs
  const clearLogs = useCallback(() => {
    setAnalysisLogs([]);
  }, []);

  // Validate Ghidra path
  const pathValidationLoggedRef = useRef<string | null>(null);
  const initialPathValidationDoneRef = useRef(false);
  const validateGhidraPath = useCallback(
    async (path: string, silent: boolean = false) => {
      if (!path) {
        setIsPathValid(null);
        return;
      }

      try {
        // Check if analyzeHeadless exists
        const isWindows = navigator.platform.toLowerCase().includes("win");
        const analyzerPath = isWindows
          ? `${path}/support/analyzeHeadless.bat`
          : `${path}/support/analyzeHeadless`;

        const exists = await invoke<boolean>("path_exists", {
          path: analyzerPath,
        });
        setIsPathValid(exists);

        // Only log once per path to avoid duplicates, and skip success log if silent
        if (pathValidationLoggedRef.current !== path) {
          pathValidationLoggedRef.current = path;
          if (!exists) {
            addLog(
              "error",
              `Ghidra analyzeHeadless not found at: ${analyzerPath}`
            );
          } else if (!silent) {
            addLog("info", `Ghidra path validated successfully`);
          }
        }
      } catch (e) {
        setIsPathValid(false);
        if (pathValidationLoggedRef.current !== path) {
          pathValidationLoggedRef.current = path;
          addLog("error", `Failed to validate Ghidra path: ${e}`);
        }
      }
    },
    [addLog]
  );

  // Save Ghidra path to localStorage and uiStore
  const saveGhidraPath = useCallback(() => {
    localStorage.setItem(GHIDRA_PATH_KEY, ghidraPathInput);
    setGhidraPath(ghidraPathInput);
    updateToolsState({ ghidraPath: ghidraPathInput });
    // Note: addLog will be called after validation
    validateGhidraPath(ghidraPathInput);
  }, [ghidraPathInput, updateToolsState, validateGhidraPath]);

  // Save project name to localStorage and uiStore
  const saveProjectName = useCallback(() => {
    const name = projectNameInput.trim();
    if (!name) {
      addLog("error", "Project name cannot be empty");
      return;
    }
    // Validate project name (alphanumeric, underscores, hyphens only)
    if (!/^[a-zA-Z0-9_-]+$/.test(name)) {
      addLog(
        "error",
        "Project name can only contain letters, numbers, underscores, and hyphens"
      );
      return;
    }
    localStorage.setItem(GHIDRA_PROJECT_NAME_KEY, name);
    setProjectName(name);
    updateToolsState({ ghidraProjectName: name });
    addLog("success", `Project name saved: ${name}`);
  }, [projectNameInput, updateToolsState, addLog]);

  // Note: Directory browser not available - user needs to manually input path

  // Auto-scroll logs
  useEffect(() => {
    if (logContainerRef.current) {
      logContainerRef.current.scrollTop = logContainerRef.current.scrollHeight;
    }
  }, [analysisLogs]);

  // Load modules from server
  const loadModules = useCallback(async () => {
    if (!serverConnected) {
      setModules([]);
      return;
    }

    setIsLoadingModules(true);
    try {
      const api = getApiClient();
      const result = await api.enumerateModules();
      if (result.success && result.data?.modules) {
        setModules(result.data.modules);
        addLog("info", `Loaded ${result.data.modules.length} modules`);
      }
    } catch (e) {
      console.error("Failed to load modules:", e);
      addLog("error", `Failed to load modules: ${e}`);
    } finally {
      setIsLoadingModules(false);
    }
  }, [serverConnected, addLog]);

  // Load modules only when explicitly requested (via Refresh button)
  // Removed auto-load on server connection

  // Auto-load modules when server is connected and modules list is empty
  useEffect(() => {
    if (serverConnected && modules.length === 0) {
      loadModules();
    }
  }, [serverConnected, modules.length, loadModules]);

  // Validate path on initial load (silent to avoid log spam on every tab switch)
  useEffect(() => {
    if (ghidraPath && !initialPathValidationDoneRef.current) {
      initialPathValidationDoneRef.current = true;
      validateGhidraPath(ghidraPath, true);
    }
  }, [ghidraPath, validateGhidraPath]);

  // Check if module is an iOS system module (dyld_shared_cache)
  const isIosSystemModule = useCallback(
    (module: ModuleInfo): boolean => {
      if (targetOs !== "ios" && targetOs !== "iOS") return false;
      const path = getModulePath(module);
      if (!path) return false;
      // iOS system libraries from dyld_shared_cache typically have paths like:
      // /usr/lib/..., /System/Library/..., or no actual file on disk
      return (
        path.startsWith("/usr/lib/") ||
        path.startsWith("/System/Library/") ||
        path.startsWith("/Developer/") ||
        // Libraries in shared cache often have these patterns
        path.includes("/PrivateFrameworks/") ||
        (path.startsWith("/") &&
          !path.includes("/var/") &&
          !path.includes("/private/"))
      );
    },
    [targetOs]
  );

  // Check if a module has server running (moved before filteredModules)
  const getModuleServerStatus = useCallback(
    (modulePath: string): { running: boolean; port: number | null } => {
      if (serverStatus !== "running" || !serverProjectPath) {
        return { running: false, port: null };
      }
      const libInfo = analyzedLibraries.get(modulePath);
      if (libInfo?.projectPath === serverProjectPath) {
        return { running: true, port: serverPort };
      }
      return { running: false, port: null };
    },
    [serverStatus, serverProjectPath, serverPort, analyzedLibraries]
  );

  // Check if module is already analyzed
  const isModuleAnalyzed = useCallback(
    (modulePath: string): boolean => {
      const normalizedPath = modulePath.replace(/\\/g, "/").toLowerCase();
      for (const [key] of analyzedLibraries) {
        if (key.replace(/\\/g, "/").toLowerCase() === normalizedPath) {
          return true;
        }
      }
      return false;
    },
    [analyzedLibraries]
  );

  // Filter and sort modules
  // Sorting priority: 1. Server running, 2. Analyzed, 3. Others
  const filteredModules = useMemo(() => {
    let result = modules;

    // Apply filter
    if (moduleFilter) {
      const filter = moduleFilter.toLowerCase();
      result = result.filter(
        (m) =>
          m.modulename?.toLowerCase().includes(filter) ||
          m.path?.toLowerCase().includes(filter)
      );
    }

    // Sort: server running > analyzed > others
    return [...result].sort((a, b) => {
      const pathA = getModulePath(a);
      const pathB = getModulePath(b);

      const serverA = pathA ? getModuleServerStatus(pathA).running : false;
      const serverB = pathB ? getModuleServerStatus(pathB).running : false;
      const analyzedA = pathA ? isModuleAnalyzed(pathA) : false;
      const analyzedB = pathB ? isModuleAnalyzed(pathB) : false;

      // Server running modules first
      if (serverA && !serverB) return -1;
      if (!serverA && serverB) return 1;

      // Then analyzed modules
      if (analyzedA && !analyzedB) return -1;
      if (!analyzedA && analyzedB) return 1;

      // Then by name
      const nameA = (a.modulename || a.name || "").toLowerCase();
      const nameB = (b.modulename || b.name || "").toLowerCase();
      return nameA.localeCompare(nameB);
    });
  }, [modules, moduleFilter, getModuleServerStatus, isModuleAnalyzed]);

  // Check if selected module is a WASM module (Ghidra doesn't support WASM)
  const isSelectedModuleWasm = useMemo(() => {
    if (!selectedModule) return false;
    const modulePath = getModulePath(selectedModule);
    if (!modulePath) return false;
    return modulePath.toLowerCase() === "wasm" || 
           selectedModule.modulename?.toLowerCase().includes("wasm") ||
           modulePath.toLowerCase().endsWith(".wasm");
  }, [selectedModule]);

  // Save analyzed libraries
  const saveAnalyzedLibraries = useCallback(
    (libs: Map<string, AnalyzedLibrary>) => {
      const libsArray = Array.from(libs.values());
      localStorage.setItem(GHIDRA_ANALYZED_LIBS_KEY, JSON.stringify(libsArray));
      setAnalyzedLibraries(libs);
    },
    []
  );

  // Analyze selected module with Ghidra
  const analyzeModule = useCallback(async () => {
    const modulePath = selectedModule ? getModulePath(selectedModule) : null;
    if (!selectedModule || !modulePath) {
      addLog("error", "No module selected or module has no path");
      return;
    }

    if (!ghidraPath) {
      addLog("error", "Ghidra path not configured");
      return;
    }

    setIsAnalyzing(true);
    clearLogs();
    addLog("info", `Starting analysis of: ${selectedModule.modulename}`);
    addLog("info", `Library path: ${modulePath}`);
    addLog("info", `Ghidra path: ${ghidraPath}`);

    try {
      let localPath: string;

      // Check if this is a WASM module (path is "wasm" or modulename contains "wasm")
      const isWasmModule = modulePath.toLowerCase() === "wasm" || 
                           selectedModule.modulename?.toLowerCase().includes("wasm");

      if (isWasmModule) {
        // WASM mode: Download binary from Chrome extension via /api/wasm/dump
        setAnalysisProgress("Downloading WASM binary from browser...");
        addLog("info", "Fetching WASM binary from Chrome extension...");

        const apiClient = getApiClient();
        const wasmBinary = await apiClient.dumpWasmBinary();
        
        if (!wasmBinary || wasmBinary.byteLength === 0) {
          throw new Error("Failed to download WASM binary - no data received");
        }

        addLog("success", `Downloaded WASM binary: ${wasmBinary.byteLength} bytes`);

        // Verify WASM magic number
        const header = new Uint8Array(wasmBinary.slice(0, 4));
        const isValidWasm = header[0] === 0x00 && header[1] === 0x61 && 
                           header[2] === 0x73 && header[3] === 0x6d; // \0asm
        if (!isValidWasm) {
          addLog("info", `Warning: Binary doesn't have WASM magic number (got: ${Array.from(header).map(b => b.toString(16).padStart(2, '0')).join(' ')})`);
        } else {
          addLog("info", "Valid WASM binary (magic: \\0asm)");
        }

        // Save WASM binary to local file (same location as native libraries)
        setAnalysisProgress("Saving WASM binary to disk...");
        const binaryArray = Array.from(new Uint8Array(wasmBinary));
        localPath = await invoke<string>("save_wasm_binary", {
          binaryData: binaryArray,
          moduleName: selectedModule.modulename || "wasm_module",
          projectName: projectName || null,
        });

        addLog("success", `Saved to: ${localPath}`);
      } else {
        // Native mode: Download library from server
        setAnalysisProgress("Downloading library from server...");
        addLog("info", "Downloading library from server...");

        localPath = await invoke<string>("download_library_file", {
          libraryPath: modulePath,
          projectName: projectName || null,
        });

        addLog("success", `Downloaded to: ${localPath}`);
      }

      // Step 2: Run Ghidra analysis
      setAnalysisProgress(
        "Running Ghidra analysis (this may take several minutes)..."
      );
      addLog("info", "Starting Ghidra headless analysis...");
      addLog(
        "info",
        "This process may take several minutes depending on library size."
      );
      addLog("info", `Project: ${projectName}`);

      // Start the analysis with project name
      const result = await invoke<GhidraAnalysisStatus>("analyze_with_ghidra", {
        localLibraryPath: localPath,
        ghidraPath: ghidraPath,
        projectName: projectName || null,
      });

      if (result.analyzed && result.project_path) {
        addLog("success", "Analysis completed successfully!");
        addLog("info", `Project path: ${result.project_path}`);

        // Step 3: Get function list from the analyzed library
        setAnalysisProgress("Fetching function list...");
        addLog("info", "Fetching function list from Ghidra...");

        // Use localPath (the actual analyzed file) for library name, not modulePath
        // This is important for WASM mode where localPath is the actual .wasm file
        const pathParts = localPath.split(/[/\\]/);
        const libraryName = pathParts[pathParts.length - 1];

        let functions: Array<{ name: string; address: string; size: number }> =
          [];
        try {
          const funcResult = await invoke<{
            success: boolean;
            functions: Array<{ name: string; address: string; size: number }>;
            error: string | null;
          }>("ghidra_get_functions", {
            projectPath: result.project_path,
            libraryName: libraryName,
            ghidraPath: ghidraPath,
          });

          if (funcResult.success) {
            functions = funcResult.functions;
            addLog("success", `Found ${functions.length} functions`);

            // Save functions to SQLite database
            try {
              const osKey = targetOs || "unknown";
              await invoke("save_ghidra_functions", {
                targetOs: osKey,
                moduleName: libraryName,
                functionsJson: JSON.stringify(functions),
              });
              addLog("info", `Functions saved to database (OS: ${osKey})`);
            } catch (dbError) {
              addLog("info", `Could not save to database: ${dbError}`);
            }
          } else {
            addLog("info", `Could not fetch functions: ${funcResult.error}`);
          }
        } catch (funcError) {
          addLog("info", `Could not fetch functions: ${funcError}`);
        }

        // Save to analyzed libraries with functions
        const newLibs = new Map(analyzedLibraries);
        newLibs.set(modulePath, {
          libraryPath: modulePath,
          localPath: localPath,
          projectPath: result.project_path,
          analyzedAt: Date.now(),
          functions: functions,
        });
        saveAnalyzedLibraries(newLibs);

        setAnalysisProgress("Analysis completed!");
      } else {
        addLog("error", `Analysis failed: ${result.error || "Unknown error"}`);
        setAnalysisProgress("Analysis failed");
      }
    } catch (e) {
      addLog("error", `Analysis error: ${e}`);
      setAnalysisProgress("Analysis failed");
    } finally {
      setIsAnalyzing(false);
    }
  }, [
    selectedModule,
    ghidraPath,
    addLog,
    clearLogs,
    analyzedLibraries,
    saveAnalyzedLibraries,
    targetOs,
  ]);

  // Start Ghidra HTTP server for fast decompile/xref (based on selected module)
  const startServer = useCallback(async () => {
    if (!ghidraPath) {
      addLog("error", "Ghidra path not configured");
      return;
    }

    if (!selectedModule) {
      addLog("error", "No module selected");
      return;
    }

    const modulePath = getModulePath(selectedModule);
    if (!modulePath) {
      addLog("error", "Module has no path");
      return;
    }

    const libInfo = analyzedLibraries.get(modulePath);
    if (!libInfo?.projectPath) {
      addLog("error", "Module not analyzed. Please analyze first.");
      return;
    }

    // If a different server is already running, stop it first
    if (serverProjectPath && serverProjectPath !== libInfo.projectPath) {
      addLog("info", "Stopping existing Ghidra server...");
      try {
        await invoke<boolean>("stop_ghidra_server", {
          projectPath: serverProjectPath,
        });
        setServerPort(null);
        setServerProjectPath(null);
        addLog("success", "Previous server stopped");
      } catch (e) {
        addLog("error", `Failed to stop existing server: ${e}`);
        // Continue anyway
      }
    }

    const pathParts = modulePath.split(/[/\\]/);
    const libraryName = pathParts[pathParts.length - 1];

    setServerStatus("starting");
    addLog("info", `Starting Ghidra HTTP server for: ${libraryName}`);
    addLog("info", "Loading Ghidra project... This may take 30-60 seconds.");

    try {
      const port = 18462;
      const result = await invoke<boolean>("start_ghidra_server", {
        projectPath: libInfo.projectPath,
        libraryName: libraryName,
        ghidraPath: ghidraPath,
        port: port,
      });

      if (result) {
        // Wait for server to be ready (poll for up to 120 seconds)
        let ready = false;
        let lastLogCount = 0;
        for (let i = 0; i < 600; i++) {
          await new Promise((resolve) => setTimeout(resolve, 1000));
          if (i % 10 === 0 && i > 0) {
            addLog("info", `Still waiting for server... (${i}s)`);
            // Fetch and display new server logs periodically
            try {
              const logs = await invoke<string[]>("get_ghidra_server_logs", {
                projectPath: libInfo.projectPath,
              });
              if (logs && logs.length > lastLogCount) {
                const newLogs = logs.slice(lastLogCount);
                newLogs.forEach((log) => addLog("output", log));
                lastLogCount = logs.length;
              }
            } catch {
              // Ignore log fetch errors
            }
          }
          try {
            const portCheck = await invoke<number | null>(
              "check_ghidra_server",
              {
                projectPath: libInfo.projectPath,
              }
            );
            if (portCheck !== null) {
              ready = true;
              setServerPort(portCheck);
              break;
            }
          } catch {
            // Server not ready yet, keep waiting
          }
        }

        if (ready) {
          setServerStatus("running");
          setServerProjectPath(libInfo.projectPath);
          addLog("success", `Ghidra server started on port ${port}`);
          addLog("info", "Fast decompile/xref is now available!");
        } else {
          setServerStatus("stopped");
          addLog("error", "Server failed to start within timeout (600s)");
          addLog(
            "info",
            "Try checking the Ghidra project or restart the application."
          );
          // Fetch and display server logs for debugging
          try {
            const logs = await invoke<string[]>("get_ghidra_server_logs", {
              projectPath: libInfo.projectPath,
            });
            if (logs && logs.length > 0) {
              addLog("info", "--- Ghidra Server Logs ---");
              const lastLogs = logs.slice(-20); // Show last 20 lines
              lastLogs.forEach((log) => addLog("output", log));
              addLog("info", "--- End of Logs ---");
            }
          } catch (logError) {
            addLog("error", `Failed to retrieve server logs: ${logError}`);
          }
        }
      } else {
        setServerStatus("stopped");
        addLog("error", "Failed to start Ghidra server");
      }
    } catch (e) {
      setServerStatus("stopped");
      addLog("error", `Failed to start server: ${e}`);
    }
  }, [ghidraPath, selectedModule, analyzedLibraries, addLog]);

  // Stop Ghidra server
  const stopServer = useCallback(async () => {
    if (!serverProjectPath) return;

    setServerStatus("stopping");
    addLog("info", "Stopping Ghidra server...");

    try {
      await invoke<boolean>("stop_ghidra_server", {
        projectPath: serverProjectPath,
      });
      setServerStatus("stopped");
      setServerPort(null);
      setServerProjectPath(null);
      addLog("success", "Ghidra server stopped");
    } catch (e) {
      addLog("error", `Failed to stop server: ${e}`);
      setServerStatus("stopped");
    }
  }, [serverProjectPath, addLog]);

  // Check if selected module is analyzed
  const isSelectedModuleAnalyzed = useMemo(() => {
    if (!selectedModule) return false;
    const modulePath = getModulePath(selectedModule);
    if (!modulePath) return false;
    const libInfo = analyzedLibraries.get(modulePath);
    return libInfo?.functions && libInfo.functions.length > 0;
  }, [selectedModule, analyzedLibraries]);

  // Check if selected module has server running
  const isSelectedModuleServerRunning = useMemo(() => {
    if (!selectedModule) return false;
    const modulePath = getModulePath(selectedModule);
    if (!modulePath) return false;
    return getModuleServerStatus(modulePath).running;
  }, [selectedModule, getModuleServerStatus]);

  // Get Ghidra projects directory
  const getGhidraProjectsDir = useCallback((): string => {
    // This should match the path in lib.rs: LocalAppData/DynaDbg/ghidra_projects
    const platform = navigator.platform.toLowerCase();
    const userAgent = navigator.userAgent.toLowerCase();

    if (platform.includes("win")) {
      return "%LOCALAPPDATA%\\DynaDbg\\ghidra_projects";
    } else if (platform.includes("linux") || userAgent.includes("linux")) {
      return "~/.local/share/DynaDbg/ghidra_projects";
    } else {
      return "~/Library/Application Support/DynaDbg/ghidra_projects";
    }
  }, []);

  return (
    <Box
      sx={{
        flex: 1,
        display: "flex",
        flexDirection: "column",
        height: "100%",
        overflow: "auto",
        minHeight: 0,
        p: 2,
        gap: 2,
        "@media (max-height: 800px)": {
          p: 0.75,
          gap: 0.75,
        },
        "&::-webkit-scrollbar": {
          width: "8px",
        },
        "&::-webkit-scrollbar-track": {
          background: "#1e1e1e",
        },
        "&::-webkit-scrollbar-thumb": {
          background: "#3e3e42",
          borderRadius: "4px",
          "&:hover": {
            background: "#5a5a5e",
          },
        },
      }}
    >
      {/* Settings Section */}
      <Paper
        sx={{
          p: 2,
          backgroundColor: "background.default",
          flexShrink: 0,
          "@media (max-height: 800px)": {
            p: 0.75,
          },
        }}
      >
        <Box
          sx={{
            display: "flex",
            alignItems: "center",
            gap: 1,
            mb: 2,
            "@media (max-height: 800px)": {
              mb: 0.75,
            },
          }}
        >
          <SettingsIcon
            sx={{
              fontSize: 18,
              color: "primary.main",
              "@media (max-height: 800px)": { fontSize: 14 },
            }}
          />
          <Typography
            variant="subtitle2"
            sx={{
              fontWeight: 600,
              "@media (max-height: 800px)": { fontSize: "11px" },
            }}
          >
            Ghidra Settings
          </Typography>
        </Box>

        {/* Ghidra Path Input */}
        <Box
          sx={{
            display: "flex",
            alignItems: "center",
            gap: 1,
            mb: 2,
            "@media (max-height: 800px)": { mb: 0.75, gap: 0.5 },
          }}
        >
          <TextField
            size="small"
            label="Ghidra Installation Path"
            placeholder="e.g., C:\\ghidra_11.2.1_PUBLIC or /opt/ghidra"
            value={ghidraPathInput}
            onChange={(e) => setGhidraPathInput(e.target.value)}
            fullWidth
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <ExtensionIcon
                    sx={{ fontSize: 16, color: "text.secondary" }}
                  />
                </InputAdornment>
              ),
              endAdornment: isPathValid !== null && (
                <InputAdornment position="end">
                  {isPathValid ? (
                    <CheckIcon sx={{ fontSize: 16, color: "success.main" }} />
                  ) : (
                    <ErrorIcon sx={{ fontSize: 16, color: "error.main" }} />
                  )}
                </InputAdornment>
              ),
            }}
            sx={{
              flex: 1,
              "@media (max-height: 800px)": {
                "& .MuiInputBase-root": { height: 28 },
                "& .MuiInputLabel-root": { fontSize: "11px" },
                "& .MuiInputBase-input": { fontSize: "11px" },
              },
            }}
          />
          <Button
            variant="contained"
            size="small"
            onClick={saveGhidraPath}
            disabled={!ghidraPathInput}
            sx={{
              "@media (max-height: 800px)": {
                fontSize: "10px",
                py: 0.25,
                px: 1,
                minWidth: "auto",
              },
            }}
          >
            Save
          </Button>
        </Box>

        {/* Project Name Input */}
        <Box
          sx={{
            display: "flex",
            alignItems: "center",
            gap: 1,
            mb: 2,
            "@media (max-height: 800px)": { mb: 0.75, gap: 0.5 },
          }}
        >
          <TextField
            size="small"
            label="Project Name"
            placeholder="e.g., my_ios_app, android_ctf"
            value={projectNameInput}
            onChange={(e) => setProjectNameInput(e.target.value)}
            fullWidth
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <FolderIcon sx={{ fontSize: 16, color: "text.secondary" }} />
                </InputAdornment>
              ),
              endAdornment: projectName && (
                <InputAdornment position="end">
                  <CheckIcon sx={{ fontSize: 16, color: "success.main" }} />
                </InputAdornment>
              ),
            }}
            helperText="Unique name for this project. Libraries will be stored under this folder."
            sx={{
              flex: 1,
              "@media (max-height: 800px)": {
                "& .MuiInputBase-root": { height: 28 },
                "& .MuiInputLabel-root": { fontSize: "11px" },
                "& .MuiInputBase-input": { fontSize: "11px" },
                "& .MuiFormHelperText-root": { fontSize: "9px", mt: 0.25 },
              },
            }}
          />
          <Button
            variant="contained"
            size="small"
            onClick={saveProjectName}
            disabled={!projectNameInput.trim()}
            sx={{
              "@media (max-height: 800px)": {
                fontSize: "10px",
                py: 0.25,
                px: 1,
                minWidth: "auto",
              },
            }}
          >
            Save
          </Button>
        </Box>

        {/* Warning if project name is not set */}
        {!projectName && (
          <Alert
            severity="warning"
            sx={{
              py: 0.5,
              mb: 2,
              "& .MuiAlert-message": { fontSize: "11px" },
              "@media (max-height: 800px)": {
                py: 0.25,
                mb: 0.75,
                "& .MuiAlert-message": { fontSize: "9px" },
              },
            }}
          >
            <Typography variant="caption">
              Please set a project name before analyzing modules. This helps
              organize files from different targets.
            </Typography>
          </Alert>
        )}

        {/* Info about file storage location */}
        <Alert
          severity="info"
          sx={{
            py: 0.5,
            "& .MuiAlert-message": { fontSize: "11px" },
          }}
          icon={<InfoIcon sx={{ fontSize: 16 }} />}
        >
          <Typography variant="caption">
            <strong>Data Storage Location:</strong> Ghidra project files and
            downloaded libraries are stored in:
            <br />
            <code
              style={{
                backgroundColor: "rgba(0,0,0,0.1)",
                padding: "2px 6px",
                borderRadius: 4,
                fontSize: "10px",
              }}
            >
              {getGhidraProjectsDir()}
            </code>
          </Typography>
        </Alert>
      </Paper>

      {/* Module Selection Section */}
      <Paper
        sx={{
          p: 1.5,
          display: "flex",
          flexDirection: "column",
          gap: 1.5,
          backgroundColor: "background.default",
        }}
      >
        <Box
          sx={{
            display: "flex",
            alignItems: "center",
            gap: 1,
          }}
        >
          <Typography variant="subtitle2" sx={{ fontWeight: 600 }}>
            Select Module
          </Typography>
          <Tooltip title="Refresh modules">
            <IconButton
              onClick={loadModules}
              disabled={isLoadingModules || !serverConnected}
              size="small"
            >
              <RefreshIcon sx={{ fontSize: 18 }} />
            </IconButton>
          </Tooltip>
          {isLoadingModules && <CircularProgress size={16} />}
        </Box>

        {/* iOS system module explanation */}
        {(targetOs === "ios" || targetOs === "iOS") && (
          <Alert
            severity="info"
            sx={{
              py: 0.25,
              "& .MuiAlert-message": { fontSize: "10px" },
            }}
            icon={<InfoIcon sx={{ fontSize: 14 }} />}
          >
            <Typography variant="caption">
              Grayed-out modules are iOS system libraries stored in
              dyld_shared_cache. These cannot be analyzed as they don't exist as
              individual files on disk.
            </Typography>
          </Alert>
        )}

        {!serverConnected ? (
          <Alert severity="warning" sx={{ py: 0.5 }}>
            Not connected to server. Please connect to a server first.
          </Alert>
        ) : (
          <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
            <Autocomplete
              size="small"
              options={filteredModules}
              value={selectedModule}
              onChange={(_event, newValue) => {
                if (newValue && !isIosSystemModule(newValue)) {
                  setSelectedModule(newValue);
                }
              }}
              getOptionLabel={(option) => {
                const moduleName =
                  option.modulename || option.name || "Unknown";
                return moduleName.split("/").pop() || moduleName;
              }}
              getOptionDisabled={(option) => isIosSystemModule(option)}
              isOptionEqualToValue={(option, value) =>
                option.base === value.base
              }
              filterOptions={(options, { inputValue }) => {
                if (!inputValue) return options;
                const filter = inputValue.toLowerCase();
                return options.filter(
                  (m) =>
                    m.modulename?.toLowerCase().includes(filter) ||
                    m.path?.toLowerCase().includes(filter)
                );
              }}
              renderInput={(params) => (
                <TextField
                  {...params}
                  placeholder="Select Module..."
                  sx={{
                    "& .MuiOutlinedInput-root": {
                      fontSize: "12px",
                    },
                  }}
                />
              )}
              renderOption={(props, option) => {
                const moduleName =
                  option.modulename || option.name || "Unknown";
                const fileName = moduleName.split("/").pop() || moduleName;
                const modulePath = getModulePath(option);
                const isAnalyzed = modulePath
                  ? isModuleAnalyzed(modulePath)
                  : false;
                const moduleServerStatus = modulePath
                  ? getModuleServerStatus(modulePath)
                  : { running: false, port: null };
                const isSystemModule = isIosSystemModule(option);

                return (
                  <li
                    {...props}
                    key={option.base}
                    style={{
                      ...props.style,
                      opacity: isSystemModule ? 0.5 : 1,
                      fontSize: "12px",
                      display: "flex",
                      alignItems: "center",
                      gap: 8,
                    }}
                  >
                    <span style={{ flex: 1 }}>{fileName}</span>
                    {moduleServerStatus.running && (
                      <Chip
                        label={`Server :${moduleServerStatus.port}`}
                        size="small"
                        color="primary"
                        sx={{
                          height: 16,
                          fontSize: 9,
                          "& .MuiChip-label": { px: 0.5 },
                        }}
                      />
                    )}
                    {isAnalyzed && !moduleServerStatus.running && (
                      <Chip
                        label="Analyzed"
                        size="small"
                        color="success"
                        sx={{
                          height: 16,
                          fontSize: 9,
                          "& .MuiChip-label": { px: 0.5 },
                        }}
                      />
                    )}
                    {isSystemModule && (
                      <Chip
                        label="System"
                        size="small"
                        sx={{
                          height: 16,
                          fontSize: 9,
                          backgroundColor: "rgba(128,128,128,0.3)",
                          color: "text.disabled",
                          "& .MuiChip-label": { px: 0.5 },
                        }}
                      />
                    )}
                    {option.size && (
                      <span style={{ fontSize: 9, color: "#888" }}>
                        {(option.size / 1024).toFixed(0)}K
                      </span>
                    )}
                  </li>
                );
              }}
              sx={{ flex: 1, minWidth: 250 }}
              noOptionsText={
                modules.length === 0
                  ? "No modules. Click refresh to load."
                  : "No modules match."
              }
            />
            {selectedModule && (
              <>
                {(() => {
                  const modulePath = getModulePath(selectedModule);
                  const moduleServerStatus = modulePath
                    ? getModuleServerStatus(modulePath)
                    : { running: false, port: null };
                  const isAnalyzed = modulePath
                    ? isModuleAnalyzed(modulePath)
                    : false;

                  return (
                    <>
                      {moduleServerStatus.running && (
                        <Chip
                          label={`Server Running :${moduleServerStatus.port}`}
                          size="small"
                          color="primary"
                          sx={{ height: 20, fontSize: 10 }}
                        />
                      )}
                      {isAnalyzed && !moduleServerStatus.running && (
                        <Chip
                          label="Analyzed"
                          size="small"
                          color="success"
                          sx={{ height: 20, fontSize: 10 }}
                        />
                      )}
                    </>
                  );
                })()}
              </>
            )}
          </Box>
        )}

        {/* Analyze Button */}
        <Box
          sx={{
            display: "flex",
            alignItems: "center",
            gap: 1,
            backgroundColor: "background.paper",
            flexWrap: "wrap",
          }}
        >
          <Tooltip
            title={
              isSelectedModuleWasm
                ? "Ghidra does not support WebAssembly analysis"
                : !selectedModule
                ? "Select a module to analyze"
                : !ghidraPath
                ? "Configure Ghidra path first"
                : !projectName
                ? "Enter a project name"
                : !serverConnected
                ? "Connect to server first"
                : ""
            }
            arrow
          >
            <span>
              <Button
                variant="contained"
                color="primary"
                startIcon={<PlayArrowIcon />}
                onClick={analyzeModule}
                disabled={
                  !selectedModule ||
                  !getModulePath(selectedModule) ||
                  !ghidraPath ||
                  !projectName ||
                  isAnalyzing ||
                  !serverConnected ||
                  isSelectedModuleWasm
                }
                sx={{ 
                  minWidth: 120,
                  ...(isSelectedModuleWasm && {
                    opacity: 0.5,
                  }),
                }}
              >
                {isAnalyzing ? "Analyzing..." : isSelectedModuleWasm ? "Not Supported" : "Analyze"}
              </Button>
            </span>
          </Tooltip>
          {/* Start/Stop Server button - only show for analyzed modules */}
          {isSelectedModuleAnalyzed &&
            (isSelectedModuleServerRunning ? (
              <Button
                variant="outlined"
                color="error"
                onClick={stopServer}
                disabled={serverStatus === "stopping"}
                sx={{ minWidth: 120 }}
              >
                {serverStatus === "stopping" ? "Stopping..." : "Stop Server"}
              </Button>
            ) : (
              <Button
                variant="outlined"
                color="primary"
                onClick={startServer}
                disabled={
                  serverStatus === "starting" ||
                  serverStatus === "running" ||
                  isAnalyzing
                }
                sx={{ minWidth: 120 }}
                startIcon={
                  serverStatus === "starting" ? (
                    <CircularProgress size={14} color="inherit" />
                  ) : null
                }
              >
                {serverStatus === "starting" ? "Starting..." : "Start Server"}
              </Button>
            ))}
          {selectedModule && (
            <Typography
              variant="caption"
              sx={{
                color: getModulePath(selectedModule)
                  ? "text.secondary"
                  : "warning.main",
                flex: 1,
              }}
            >
              Selected: {selectedModule.modulename || selectedModule.name}
              {!getModulePath(selectedModule) &&
                " (no path available - cannot analyze)"}
            </Typography>
          )}
          {/* Warning when module is analyzed but server not running */}
          {isSelectedModuleAnalyzed && !isSelectedModuleServerRunning && (
            <Box
              sx={{
                display: "flex",
                alignItems: "center",
                gap: 0.5,
                backgroundColor: "rgba(255, 152, 0, 0.1)",
                border: "1px solid rgba(255, 152, 0, 0.3)",
                borderRadius: 1,
                px: 1.5,
                py: 0.5,
              }}
            >
              <Typography
                variant="caption"
                sx={{
                  color: "warning.main",
                  fontWeight: 500,
                }}
              >
                ⚠ Server not running - Decompile/Xref will be slow. Click
                "Start Server" for faster analysis.
              </Typography>
            </Box>
          )}
        </Box>
      </Paper>

      {/* Analysis Output Section */}
      <Paper
        sx={{
          height: 350,
          display: "flex",
          flexDirection: "column",
          overflow: "hidden",
          backgroundColor: "background.default",
        }}
      >
        <Box
          sx={{
            p: 1,
            borderBottom: "1px solid",
            borderColor: "divider",
            display: "flex",
            alignItems: "center",
            gap: 1,
          }}
        >
          <Typography variant="subtitle2" sx={{ fontWeight: 600, flex: 1 }}>
            Analysis Output
          </Typography>
          {isAnalyzing && (
            <Box sx={{ flex: 1, mx: 2 }}>
              <LinearProgress variant="indeterminate" />
            </Box>
          )}
          <Typography variant="caption" sx={{ color: "text.secondary" }}>
            {analysisProgress}
          </Typography>
          <Button size="small" onClick={clearLogs}>
            Clear
          </Button>
        </Box>

        <Box
          ref={logContainerRef}
          sx={{
            flex: 1,
            overflow: "auto",
            p: 1,
            fontFamily: "monospace",
            fontSize: "11px",
            backgroundColor: "#1a1a1a",
            minHeight: 0,
            "&::-webkit-scrollbar": {
              width: "8px",
            },
            "&::-webkit-scrollbar-track": {
              background: "#1e1e1e",
            },
            "&::-webkit-scrollbar-thumb": {
              background: "#3e3e42",
              borderRadius: "4px",
              "&:hover": {
                background: "#5a5a5e",
              },
            },
          }}
        >
          {analysisLogs.map((log, index) => (
            <Box
              key={index}
              sx={{
                display: "flex",
                gap: 1,
                mb: 0.5,
                color:
                  log.type === "error"
                    ? "#f44336"
                    : log.type === "success"
                      ? "#4caf50"
                      : log.type === "output"
                        ? "#90caf9"
                        : "#e0e0e0",
              }}
            >
              <Typography
                variant="caption"
                sx={{ color: "text.disabled", fontFamily: "monospace" }}
              >
                [{new Date(log.timestamp).toLocaleTimeString()}]
              </Typography>
              <Typography
                variant="caption"
                sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap" }}
              >
                {log.message}
              </Typography>
            </Box>
          ))}
          {analysisLogs.length === 0 && (
            <Typography
              variant="caption"
              sx={{ color: "text.disabled", fontStyle: "italic" }}
            >
              Analysis output will appear here...
            </Typography>
          )}
        </Box>
      </Paper>
    </Box>
  );
};

export default GhidraAnalyzer;

```

`src/client/src/components/GraphViewWindow.tsx`:

```tsx
import { WebviewWindow } from "@tauri-apps/api/webviewWindow";
import { invoke } from "@tauri-apps/api/core";

// Instruction data for graph view
export interface GraphViewInstruction {
  address: string;
  bytes: string;
  opcode: string;
  operands: string;
  detail?: string; // Module detail info (e.g., "libc.so@open64 + 0x10")
}

// Data passed to graph view window
export interface GraphViewData {
  address: string;
  functionName?: string;
  instructions: GraphViewInstruction[];
  functionStartAddress: string;
  functionEndAddress: string;
  // Ghidra CFG mode fields (optional)
  libraryPath?: string;
  functionOffset?: string; // Offset from image base (for Ghidra CFG)
  // dbgsrv URL for Z3 reachability analysis
  serverUrl?: string;
}

// Track opened graph view windows
const graphViewWindows = new Map<string, WebviewWindow>();

/**
 * Store graph view data in Tauri state for the new window to retrieve
 */
async function storeGraphViewData(data: GraphViewData): Promise<void> {
  try {
    await invoke("store_graph_view_data", {
      address: data.address,
      functionName: data.functionName || "",
      instructions: JSON.stringify(data.instructions),
      functionStartAddress: data.functionStartAddress,
      functionEndAddress: data.functionEndAddress,
      libraryPath: data.libraryPath || "",
      functionOffset: data.functionOffset || "",
      serverUrl: data.serverUrl || "",
    });
  } catch (error) {
    console.error("Failed to store graph view data:", error);
    throw error;
  }
}

/**
 * Open a new Graph View window as an independent Tauri window
 * @param data - Graph view data including instructions
 * @returns Promise<void>
 */
export async function openGraphViewWindow(data: GraphViewData): Promise<void> {
  const windowLabel = `graph-view-${data.address.replace(/0x/i, "").toLowerCase()}`;

  // Check if window already exists
  if (graphViewWindows.has(windowLabel)) {
    const existingWindow = graphViewWindows.get(windowLabel);
    if (existingWindow) {
      try {
        await existingWindow.setFocus();
        return;
      } catch {
        // Window might be closed, remove from map
        graphViewWindows.delete(windowLabel);
      }
    }
  }

  // Store data in Tauri state before opening window
  await storeGraphViewData(data);

  // Determine the base URL based on environment
  const isDev = import.meta.env.DEV;
  const baseUrl = isDev ? "http://localhost:1420" : "tauri://localhost";

  // Format title: "Graph View - module@function" (without offset)
  let title = `Graph View - ${data.address}`;
  if (data.functionName) {
    // Remove offset part if present (e.g., "libc.so@open64 + 0x10" -> "libc.so@open64")
    const plusIndex = data.functionName.indexOf(" + ");
    if (plusIndex > 0) {
      title = `Graph View - ${data.functionName.substring(0, plusIndex)}`;
    } else {
      title = `Graph View - ${data.functionName}`;
    }
  }

  const window = new WebviewWindow(windowLabel, {
    url: `${baseUrl}/#/graph-view?address=${encodeURIComponent(data.address)}`,
    title,
    width: 1400,
    height: 900,
    minWidth: 800,
    minHeight: 600,
    resizable: true,
    maximized: false,
    decorations: true,
    alwaysOnTop: false,
    skipTaskbar: false,
    center: true,
    focus: true,
    visible: true,
    acceptFirstMouse: true,
    titleBarStyle: "visible",
    shadow: true,
  });

  graphViewWindows.set(windowLabel, window);

  // Wait for window to be created
  await window.once("tauri://window-created", () => {
    console.log("Graph View window created:", windowLabel);
  });

  // Show and focus
  try {
    await window.show();
    await window.setFocus();
  } catch (error) {
    console.error("Failed to show/focus graph view window:", error);
  }

  // Clean up when window is closed
  window.once("tauri://close-requested", () => {
    graphViewWindows.delete(windowLabel);
    console.log("Graph View window closed:", windowLabel);
  });
}

/**
 * Close all graph view windows
 */
export async function closeAllGraphViewWindows(): Promise<void> {
  for (const [label, window] of graphViewWindows.entries()) {
    try {
      await window.close();
      graphViewWindows.delete(label);
    } catch (error) {
      console.error(`Failed to close window ${label}:`, error);
    }
  }
}

```

`src/client/src/components/Header.tsx`:

```tsx
import React, { useState } from "react";
import { Tooltip, Chip, Box, CircularProgress } from "@mui/material";
import {
  BugReport,
  Computer,
  CheckCircle,
  Error,
  Android,
  Apple,
  DesktopWindows,
  Terminal,
  Memory,
  Search,
  Home,
  Info,
  NetworkCheck,
  Dashboard,
  PlayArrow as ResumeIcon,
  Pause as PauseIcon,
  Build as BuildIcon,
} from "@mui/icons-material";
import {
  Header as HeaderContainer,
  HeaderLeft,
  HeaderRight,
  Logo,
  ToolbarButton,
} from "../utils/constants";
import { ServerInfo, ProcessInfo, AppInfo, getApiClient } from "../lib/api";
import { Mode } from "../stores/uiStore";

interface HeaderProps {
  currentMode: Mode;
  debuggerConnected?: boolean;
  debuggerState?: string;
  serverConnected: boolean;
  serverInfo?: ServerInfo;
  attachedProcess?: ProcessInfo;
  attachedAppInfo?: AppInfo;
  spawnSuspended?: boolean;
  isInBreakState?: boolean;
  onModeChange?: (mode: Mode) => void;
  onLogoClick?: () => void;
  onResumeApp?: () => void;
  showLogsTab?: boolean;
  showNetworkTab?: boolean;
  showStateTab?: boolean;
}

export const Header: React.FC<HeaderProps> = ({
  currentMode,
  serverConnected,
  serverInfo,
  attachedProcess,
  spawnSuspended = false,
  isInBreakState = false,
  onModeChange,
  onLogoClick,
  onResumeApp,
  showLogsTab = false,
  showNetworkTab = false,
  showStateTab = false,
}) => {
  const [isResuming, setIsResuming] = useState(false);

  // Android process suspend/resume state
  const [isProcessSuspended, setIsProcessSuspended] = useState(false);
  const [isProcessStateChanging, setIsProcessStateChanging] = useState(false);

  // Handle resume button click
  const handleResume = async () => {
    if (!attachedProcess?.pid || !onResumeApp) return;

    setIsResuming(true);
    try {
      const client = getApiClient();
      const response = await client.resumeApp(attachedProcess.pid);

      if (response.success && response.data?.success) {
        // Call the callback to update state
        onResumeApp();
      } else {
        console.error(
          "Failed to resume app:",
          response.message || response.data
        );
      }
    } catch (error) {
      console.error("Failed to resume app:", error);
    } finally {
      setIsResuming(false);
    }
  };

  // Handle Android process suspend/resume toggle
  const handleProcessStateToggle = async () => {
    // Prevent multiple clicks while processing
    if (!attachedProcess?.pid || isInBreakState || isProcessStateChanging)
      return;

    setIsProcessStateChanging(true);
    try {
      const client = getApiClient();
      // doPlay: true = resume, false = suspend
      const response = await client.changeProcessState(isProcessSuspended);

      if (response.success) {
        setIsProcessSuspended(!isProcessSuspended);
      } else {
        console.error("Failed to change process state:", response.message);
      }
    } catch (error) {
      console.error("Failed to change process state:", error);
    } finally {
      // Add 1 second cooldown after state change
      setTimeout(() => {
        setIsProcessStateChanging(false);
      }, 400);
    }
  };

  // Determine OS icon based on server info
  const getOSIcon = () => {
    if (!serverInfo) return <BugReport />;

    const os = serverInfo.target_os.toLowerCase();
    if (os.includes("windows")) return <DesktopWindows />;
    if (os.includes("android")) return <Android />;
    if (os.includes("ios") || os.includes("darwin") || os.includes("macos"))
      return <Apple />;
    if (os.includes("linux")) return <Terminal />;
    return <BugReport />; // Default
  };

  return (
    <HeaderContainer>
      <HeaderLeft>
        <Logo
          onClick={onLogoClick}
          sx={{
            cursor: onLogoClick ? "pointer" : "default",
            "&:hover": onLogoClick
              ? {
                  opacity: 0.8,
                }
              : {},
            transition: "opacity 0.2s",
          }}
        >
          {getOSIcon()}
          DynaDbg
        </Logo>

        {/* Mode Selection */}
        <Tooltip title="Home" placement="bottom">
          <ToolbarButton
            onClick={() => onModeChange && onModeChange("home")}
            className={currentMode === "home" ? "active" : ""}
          >
            <Home fontSize="small" sx={{ mr: 0.5 }} />
            Home
          </ToolbarButton>
        </Tooltip>
        <Tooltip title="Server Management" placement="bottom">
          <ToolbarButton
            onClick={() => onModeChange && onModeChange("server")}
            className={currentMode === "server" ? "active" : ""}
            sx={{ ml: 0.5 }}
          >
            <Computer fontSize="small" sx={{ mr: 0.5 }} />
            Server
          </ToolbarButton>
        </Tooltip>
        {
          <Tooltip
            title={
              !attachedProcess
                ? serverConnected
                  ? "Attach to a process first"
                  : "Connect to server first"
                : "Debugger Mode"
            }
            placement="bottom"
          >
            <span>
              <ToolbarButton
                onClick={() => onModeChange && onModeChange("debugger")}
                className={currentMode === "debugger" ? "active" : ""}
                disabled={!serverConnected || !attachedProcess}
                sx={{
                  ml: 0.5,
                  ...((!serverConnected || !attachedProcess) && {
                    opacity: 0.5,
                    pointerEvents: "none",
                    color: "text.disabled",
                  }),
                }}
              >
                <BugReport fontSize="small" sx={{ mr: 0.5 }} />
                Debugger
              </ToolbarButton>
            </span>
          </Tooltip>
        }
        <Tooltip
          title={
            !attachedProcess
              ? serverConnected
                ? "Attach to a process first"
                : "Connect to server first"
              : "Memory Scanner"
          }
          placement="bottom"
        >
          <span>
            <ToolbarButton
              onClick={() => onModeChange && onModeChange("scanner")}
              className={currentMode === "scanner" ? "active" : ""}
              disabled={!serverConnected || !attachedProcess}
              sx={{
                ml: 0.5,
                ...((!serverConnected || !attachedProcess) && {
                  opacity: 0.5,
                  pointerEvents: "none",
                  color: "text.disabled",
                }),
              }}
            >
              <Search fontSize="small" sx={{ mr: 0.5 }} />
              Scanner
            </ToolbarButton>
          </span>
        </Tooltip>
        <Tooltip
          title={
            !attachedProcess
              ? serverConnected
                ? "Attach to a process first"
                : "Connect to server first"
              : "Information"
          }
          placement="bottom"
        >
          <span>
            <ToolbarButton
              onClick={() => onModeChange && onModeChange("information")}
              className={currentMode === "information" ? "active" : ""}
              disabled={!serverConnected || !attachedProcess}
              sx={{
                ml: 0.5,
                ...((!serverConnected || !attachedProcess) && {
                  opacity: 0.5,
                  pointerEvents: "none",
                  color: "text.disabled",
                }),
              }}
            >
              <Info fontSize="small" sx={{ mr: 0.5 }} />
              Information
            </ToolbarButton>
          </span>
        </Tooltip>
        <Tooltip
          title={
            !attachedProcess
              ? serverConnected
                ? "Attach to a process first"
                : "Connect to server first"
              : "Tools & Analyzers"
          }
          placement="bottom"
        >
          <span>
            <ToolbarButton
              onClick={() => onModeChange && onModeChange("tools")}
              className={currentMode === "tools" ? "active" : ""}
              disabled={!serverConnected || !attachedProcess}
              sx={{
                ml: 0.5,
                ...((!serverConnected || !attachedProcess) && {
                  opacity: 0.5,
                  pointerEvents: "none",
                  color: "text.disabled",
                }),
              }}
            >
              <BuildIcon fontSize="small" sx={{ mr: 0.5 }} />
              Tools
            </ToolbarButton>
          </span>
        </Tooltip>
        {showNetworkTab && (
          <Tooltip title="Network Requests" placement="bottom">
            <ToolbarButton
              onClick={() => onModeChange && onModeChange("network")}
              className={currentMode === "network" ? "active" : ""}
              sx={{ ml: 0.5 }}
            >
              <NetworkCheck fontSize="small" sx={{ mr: 0.5 }} />
              Network
            </ToolbarButton>
          </Tooltip>
        )}
        {showLogsTab && (
          <Tooltip title="Development Logs" placement="bottom">
            <ToolbarButton
              onClick={() => onModeChange && onModeChange("logs")}
              className={currentMode === "logs" ? "active" : ""}
              sx={{ ml: 0.5 }}
            >
              <Terminal fontSize="small" sx={{ mr: 0.5 }} />
              Logs
            </ToolbarButton>
          </Tooltip>
        )}
        {showStateTab && (
          <Tooltip title="Real-time State Monitor" placement="bottom">
            <ToolbarButton
              onClick={() => onModeChange && onModeChange("state")}
              className={currentMode === "state" ? "active" : ""}
              sx={{ ml: 0.5 }}
            >
              <Dashboard fontSize="small" sx={{ mr: 0.5 }} />
              State
            </ToolbarButton>
          </Tooltip>
        )}
      </HeaderLeft>

      <HeaderRight>
        {/* Resume Button - only show when spawn suspended */}
        {spawnSuspended && attachedProcess && (
          <Tooltip title="Resume suspended app" placement="bottom">
            <Chip
              size="small"
              icon={
                isResuming ? (
                  <CircularProgress size={12} color="inherit" />
                ) : (
                  <ResumeIcon sx={{ fontSize: "14px" }} />
                )
              }
              label={isResuming ? "Resuming..." : "Resume"}
              color="success"
              variant="outlined"
              onClick={handleResume}
              disabled={isResuming}
              sx={{
                fontSize: "10px",
                height: "22px",
                mr: 1,
                cursor: "pointer",
                "&:hover": {
                  backgroundColor: "rgba(76, 175, 80, 0.1)",
                },
              }}
            />
          </Tooltip>
        )}

        {/* Android Process Suspend/Resume Toggle - only show for Android when attached and not in break state */}
        {serverInfo?.target_os?.toLowerCase() === "android" &&
          attachedProcess &&
          !spawnSuspended && (
            <Tooltip
              title={
                isInBreakState
                  ? "Cannot change process state while in break state"
                  : isProcessSuspended
                    ? "Resume process"
                    : "Suspend process"
              }
              placement="bottom"
            >
              <span>
                <Chip
                  size="small"
                  icon={
                    isProcessStateChanging ? (
                      <CircularProgress size={12} color="inherit" />
                    ) : isProcessSuspended ? (
                      <ResumeIcon sx={{ fontSize: "14px" }} />
                    ) : (
                      <PauseIcon sx={{ fontSize: "14px" }} />
                    )
                  }
                  label={
                    isProcessStateChanging
                      ? "Changing..."
                      : isProcessSuspended
                        ? "Resume"
                        : "Suspend"
                  }
                  color={isProcessSuspended ? "success" : "warning"}
                  variant="outlined"
                  onClick={handleProcessStateToggle}
                  disabled={isProcessStateChanging || isInBreakState}
                  sx={{
                    fontSize: "10px",
                    height: "22px",
                    mr: 1,
                    cursor: isInBreakState ? "not-allowed" : "pointer",
                    opacity: isInBreakState ? 0.5 : 1,
                    "&:hover": {
                      backgroundColor: isInBreakState
                        ? "transparent"
                        : isProcessSuspended
                          ? "rgba(76, 175, 80, 0.1)"
                          : "rgba(255, 152, 0, 0.1)",
                    },
                  }}
                />
              </span>
            </Tooltip>
          )}

        {/* Server Info - always displayed when connected */}
        {serverConnected && serverInfo && (
          <Box sx={{ display: "flex", alignItems: "center", mr: 1 }}>
            <Chip
              size="small"
              icon={getOSIcon()}
              label={`${serverInfo.target_os} ${serverInfo.arch}`}
              color="info"
              variant="outlined"
              sx={{ fontSize: "10px", height: "22px", mr: 1 }}
            />
          </Box>
        )}

        {/* Process Info - displayed when attached (hide for WASM mode) */}
        {attachedProcess && attachedProcess.pid !== 0 && (
          <Box sx={{ display: "flex", alignItems: "center", mr: 1 }}>
            <Chip
              size="small"
              icon={<Memory />}
              label={`PID: ${attachedProcess.pid} - ${
                attachedProcess.processname || "Unknown"
              }`}
              color="warning"
              variant="outlined"
              sx={{ fontSize: "10px", height: "22px" }}
            />
          </Box>
        )}

        <Chip
          size="small"
          icon={serverConnected ? <CheckCircle /> : <Error />}
          label={serverConnected ? "Server Connected" : "Server Disconnected"}
          color={serverConnected ? "success" : "error"}
          variant="outlined"
          sx={{ fontSize: "11px", height: "24px" }}
        />
      </HeaderRight>
    </HeaderContainer>
  );
};

```

`src/client/src/components/HelpContent.tsx`:

```tsx
import React from "react";
import {
  Box,
  Typography,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Chip,
  Stack,
  alpha,
  useMediaQuery,
} from "@mui/material";
import {
  ExpandMore as ExpandMoreIcon,
  QuestionAnswer as QuestionAnswerIcon,
  Code as CodeIcon,
  Devices as DevicesIcon,
  Security as SecurityIcon,
  Favorite as FavoriteIcon,
} from "@mui/icons-material";

interface FAQItem {
  question: string;
  answer: string | React.ReactNode;
  icon?: React.ReactNode;
  tags?: string[];
}

const faqItems: FAQItem[] = [
  {
    question: "Is this project open source?",
    answer:
      "Yes! This project has been open source since January 7, 2026 under the GPL v3 license. ",
    icon: <CodeIcon />,
    tags: ["Open Source", "License"],
  },
  {
    question: "What platforms and architectures are supported?",
    answer: (
      <Box>
        <Typography variant="body2" sx={{ mb: 2 }}>
          I plan to cover all major operating systems: Windows, Linux, macOS,
          Android, and iOS.
        </Typography>
        <Typography variant="body2">
          Major CPU architectures including x86, x86_64, and ARM64 are supported
          or planned.
        </Typography>
      </Box>
    ),
    icon: <DevicesIcon />,
    tags: ["Platform", "Architecture"],
  },
  {
    question: "Does DynaDbg depend on Frida, LLDB, or GDB?",
    answer: (
      <Box>
        <Typography variant="body2" sx={{ mb: 2 }}>
          <strong>No</strong>, DynaDbg is a completely independent tool. It does
          not rely on Frida, LLDB, GDB, or any other external debugging
          framework.
        </Typography>
        <Typography variant="body2">
          However, I may implement integration features with these tools in the
          future to enhance functionality and interoperability.
        </Typography>
      </Box>
    ),
    icon: <SecurityIcon />,
    tags: ["Independence", "Integration"],
  },
  {
    question: "How can I support the development?",
    answer: (
      <Box>
        <Typography variant="body2" sx={{ mb: 2 }}>
          Please check out the{" "}
          <Box
            component="a"
            href="https://github.com/DoranekoSystems"
            target="_blank"
            rel="noopener noreferrer"
            sx={{
              color: "#3b82f6",
              textDecoration: "none",
              fontWeight: 500,
              "&:hover": {
                textDecoration: "underline",
              },
            }}
          >
            GitHub page
          </Box>
          .
        </Typography>
        <Typography variant="body2">
          Your support helps me continue developing and improving DynaDbg.
        </Typography>
      </Box>
    ),
    icon: <FavoriteIcon />,
    tags: ["Support", "GitHub"],
  },
];

export const HelpContent: React.FC = () => {
  const [expanded, setExpanded] = React.useState<string | false>("panel0");

  // Compact mode for height < 800px
  const isCompactHeight = useMediaQuery("(max-height: 800px)");

  const handleChange =
    (panel: string) => (_event: React.SyntheticEvent, isExpanded: boolean) => {
      setExpanded(isExpanded ? panel : false);
    };

  return (
    <Box
      sx={{
        height: "100%",
        overflow: "auto",
        backgroundColor: "#0f0f0f",
        p: isCompactHeight ? 2 : 4,
        "&::-webkit-scrollbar": {
          width: "8px",
        },
        "&::-webkit-scrollbar-track": {
          background: "#1a1a1a",
        },
        "&::-webkit-scrollbar-thumb": {
          background: "#3a3a3a",
          borderRadius: "4px",
          "&:hover": {
            background: "#4a4a4a",
          },
        },
      }}
    >
      {/* Header Section */}
      <Box sx={{ mb: isCompactHeight ? 2 : 4, textAlign: "center" }}>
        <Stack
          direction="row"
          justifyContent="center"
          alignItems="center"
          spacing={2}
          sx={{ mb: isCompactHeight ? 1 : 2 }}
        >
          <QuestionAnswerIcon
            sx={{ fontSize: isCompactHeight ? 28 : 40, color: "#3b82f6" }}
          />
          <Typography
            variant={isCompactHeight ? "h5" : "h4"}
            sx={{
              fontWeight: 600,
              background: "linear-gradient(135deg, #3b82f6, #8b5cf6)",
              backgroundClip: "text",
              WebkitBackgroundClip: "text",
              WebkitTextFillColor: "transparent",
            }}
          >
            Frequently Asked Questions
          </Typography>
        </Stack>
        <Typography variant="body1" color="text.secondary">
          Find answers to common questions about DynaDbg
        </Typography>
      </Box>

      {/* FAQ Section */}
      <Box sx={{ maxWidth: 800, mx: "auto" }}>
        {faqItems.map((item, index) => (
          <Accordion
            key={index}
            expanded={expanded === `panel${index}`}
            onChange={handleChange(`panel${index}`)}
            sx={{
              backgroundColor: alpha("#1a1a1a", 0.8),
              border: "1px solid",
              borderColor: expanded === `panel${index}` ? "#3b82f6" : "#2d2d2d",
              borderRadius: "8px !important",
              mb: isCompactHeight ? 1 : 2,
              "&:before": {
                display: "none",
              },
              transition: "all 0.3s ease",
              "&:hover": {
                borderColor:
                  expanded === `panel${index}` ? "#3b82f6" : "#4a4a4a",
              },
            }}
          >
            <AccordionSummary
              expandIcon={<ExpandMoreIcon sx={{ color: "#9ca3af" }} />}
              sx={{
                "& .MuiAccordionSummary-content": {
                  alignItems: "center",
                },
                py: 1,
              }}
            >
              <Stack
                direction="row"
                spacing={2}
                alignItems="center"
                sx={{ width: "100%" }}
              >
                <Box
                  sx={{
                    color: "#3b82f6",
                    display: "flex",
                    alignItems: "center",
                  }}
                >
                  {item.icon}
                </Box>
                <Box sx={{ flex: 1 }}>
                  <Typography
                    variant="subtitle1"
                    sx={{
                      fontWeight: 500,
                      color: expanded === `panel${index}` ? "#fff" : "#e5e7eb",
                    }}
                  >
                    {item.question}
                  </Typography>
                  {item.tags && (
                    <Stack direction="row" spacing={0.5} sx={{ mt: 0.5 }}>
                      {item.tags.map((tag, tagIndex) => (
                        <Chip
                          key={tagIndex}
                          label={tag}
                          size="small"
                          sx={{
                            height: 20,
                            fontSize: "10px",
                            backgroundColor: alpha("#3b82f6", 0.1),
                            color: "#60a5fa",
                            border: "none",
                          }}
                        />
                      ))}
                    </Stack>
                  )}
                </Box>
              </Stack>
            </AccordionSummary>
            <AccordionDetails
              sx={{
                backgroundColor: alpha("#0f0f0f", 0.5),
                borderTop: "1px solid #2d2d2d",
                pt: 2,
              }}
            >
              {typeof item.answer === "string" ? (
                <Typography
                  variant="body2"
                  color="text.secondary"
                  sx={{ lineHeight: 1.8 }}
                >
                  {item.answer}
                </Typography>
              ) : (
                item.answer
              )}
            </AccordionDetails>
          </Accordion>
        ))}
      </Box>

      {/* Contact Section */}
      <Box
        sx={{
          mt: isCompactHeight ? 3 : 6,
          p: isCompactHeight ? 2 : 3,
          maxWidth: 800,
          mx: "auto",
          backgroundColor: alpha("#1a1a1a", 0.5),
          borderRadius: 2,
          border: "1px solid #2d2d2d",
          textAlign: "center",
        }}
      >
        <Typography variant="h6" sx={{ mb: 1, color: "#e5e7eb" }}>
          Still have questions?
        </Typography>
        <Typography variant="body2" color="text.secondary">
          Feel free to open an issue on{" "}
          <Box
            component="a"
            href="https://github.com/DoranekoSystems/DynaDbg"
            target="_blank"
            rel="noopener noreferrer"
            sx={{
              color: "#3b82f6",
              textDecoration: "none",
              "&:hover": {
                textDecoration: "underline",
              },
            }}
          >
            GitHub
          </Box>
          .
        </Typography>
      </Box>
    </Box>
  );
};

```

`src/client/src/components/HomePage.tsx`:

```tsx
import React, { useRef, useEffect, useState } from "react";
import {
  Box,
  Typography,
  Button,
  Chip,
  styled,
  alpha,
  Container,
  Stack,
  IconButton,
  useMediaQuery,
} from "@mui/material";
import {
  Check as CheckIcon,
  NetworkCheck as NetworkIcon,
  PlayArrow as PlayArrowIcon,
  GitHub as GitHubIcon,
  Public as PublicIcon,
} from "@mui/icons-material";
import { openUrl } from "@tauri-apps/plugin-opener";
import { ServerInfo, ProcessInfo, AppInfo } from "../lib/api";

import topImage from "../assets/top-img.png";
import demoVideo from "../assets/dynadbg-demo.mp4";

const TwitterIcon = (props: any) => (
  <svg viewBox="0 0 24 24" {...props}>
    <path
      fill="currentColor"
      d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"
    />
  </svg>
);

const HeroSection = styled(Box)(({ theme }) => ({
  background: "linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%)",
  flex: 1,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  textAlign: "center",
  padding: theme.spacing(2),
  position: "relative",
  overflow: "hidden",
  "&::before": {
    content: '""',
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    background:
      "radial-gradient(circle at 30% 20%, rgba(59, 130, 246, 0.1) 0%, transparent 50%), radial-gradient(circle at 70% 80%, rgba(139, 92, 246, 0.1) 0%, transparent 50%)",
    pointerEvents: "none",
  },
}));

const GradientButton = styled(Button)(({ theme }) => ({
  background: "linear-gradient(135deg, #3b82f6, #1d4ed8)",
  color: "white",
  fontWeight: 300,
  borderRadius: theme.spacing(2),
  padding: theme.spacing(1.5, 4),
  textTransform: "none",
  fontSize: "1.1rem",
  "&:hover": {
    background: "linear-gradient(135deg, #1d4ed8, #1e40af)",
    transform: "translateY(-2px)",
    boxShadow: "0 8px 25px rgba(59, 130, 246, 0.3)",
  },
  transition: "all 0.3s ease",
}));

interface HomePageProps {
  serverConnected: boolean;
  serverInfo?: ServerInfo;
  attachedProcess?: ProcessInfo;
  attachedAppInfo?: AppInfo;
  onModeChange: (mode: "server" | "debugger" | "scanner") => void;
  onConnect?: () => void;
  onAttachProcess?: () => void;
  onDetachProcess?: () => void;
  onAboutClick?: () => void;
  connectionHost: string;
  connectionPort: number;
  isConnecting?: boolean;
}

export const HomePage: React.FC<HomePageProps> = ({
  serverConnected,
  onConnect,
  onAboutClick,
}) => {
  const videoRef = useRef<HTMLVideoElement>(null);
  const [playCount, setPlayCount] = useState(0);
  const [videoError, setVideoError] = useState(false);
  const [isManuallyPaused, setIsManuallyPaused] = useState(false);
  const playPromiseRef = useRef<Promise<void> | null>(null);

  // Media query for height threshold - hide content when height is less than 600px
  const isCompactHeight = useMediaQuery("(max-height: 800px)");

  const handleVideoClick = async () => {
    const video = videoRef.current;
    if (!video || videoError) return;

    if (video.paused) {
      setIsManuallyPaused(false);

      if (playPromiseRef.current) {
        try {
          await playPromiseRef.current;
        } catch (e) {
          /* ignore */
        }
      }

      try {
        playPromiseRef.current = video.play();
        await playPromiseRef.current;
      } catch (error: any) {
        if (error.name !== "AbortError") {
          console.error("Manual video play failed:", error);
        }
      } finally {
        playPromiseRef.current = null;
      }
    } else {
      setIsManuallyPaused(true);

      if (playPromiseRef.current) {
        try {
          await playPromiseRef.current;
        } catch (e) {
          /* ignore */
        }
        playPromiseRef.current = null;
      }

      video.pause();
    }
  };

  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    video.playbackRate = 0.7;
    video.volume = 0;
    video.muted = true;

    const handleEnded = () => {
      setPlayCount((prev) => {
        const newCount = prev + 1;
        if (newCount < 2) {
          setTimeout(() => {
            video.currentTime = 0;
            if (!playPromiseRef.current) {
              playPromiseRef.current = video.play().catch((error) => {
                console.error("Video replay failed:", error);
                setVideoError(true);
              });
              if (playPromiseRef.current) {
                playPromiseRef.current.finally(() => {
                  playPromiseRef.current = null;
                });
              }
            }
          }, 500);
        }
        return newCount;
      });
    };

    const handleCanPlay = () => {
      if (playCount < 2 && !videoError) {
        setTimeout(() => {
          if (!playPromiseRef.current) {
            playPromiseRef.current = video.play().catch((error) => {
              console.error("Video play failed:", error);
              setVideoError(true);
            });
            if (playPromiseRef.current) {
              playPromiseRef.current.finally(() => {
                playPromiseRef.current = null;
              });
            }
          }
        }, 100);
      }
    };

    const handleLoadedData = () => {
      if (playCount < 2 && !videoError) {
        if (!playPromiseRef.current) {
          playPromiseRef.current = video.play().catch((error) => {
            console.error("Video play from loadeddata failed:", error);
            setVideoError(true);
          });
          if (playPromiseRef.current) {
            playPromiseRef.current.finally(() => {
              playPromiseRef.current = null;
            });
          }
        }
      }
    };

    const handleError = (event: Event) => {
      console.error("Video loading error:", event);
      setVideoError(true);
    };

    const handleLoadedMetadata = () => {};

    const handlePlay = () => {};

    const handlePause = () => {};

    video.addEventListener("ended", handleEnded);
    video.addEventListener("canplay", handleCanPlay);
    video.addEventListener("loadeddata", handleLoadedData);
    video.addEventListener("error", handleError);
    video.addEventListener("loadedmetadata", handleLoadedMetadata);
    video.addEventListener("play", handlePlay);
    video.addEventListener("pause", handlePause);

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (
            entry.isIntersecting &&
            playCount < 2 &&
            !videoError &&
            !isManuallyPaused
          ) {
            if (video.readyState >= 2 && !playPromiseRef.current) {
              playPromiseRef.current = video.play().catch((error) => {
                console.error("Video play from intersection failed:", error);
                setVideoError(true);
              });
              if (playPromiseRef.current) {
                playPromiseRef.current.finally(() => {
                  playPromiseRef.current = null;
                });
              }
            }
          } else if (
            !entry.isIntersecting &&
            !isManuallyPaused &&
            !playPromiseRef.current
          ) {
            video.pause();
          }
        });
      },
      {
        root: null,
        rootMargin: "50px",
        threshold: 0.3,
      }
    );

    observer.observe(video);

    setTimeout(() => {
      if (
        playCount === 0 &&
        !videoError &&
        video.readyState >= 2 &&
        !playPromiseRef.current
      ) {
        playPromiseRef.current = video.play().catch(() => {
          setVideoError(true);
        });
        if (playPromiseRef.current) {
          playPromiseRef.current.finally(() => {
            playPromiseRef.current = null;
          });
        }
      }
    }, 500);

    return () => {
      video.removeEventListener("ended", handleEnded);
      video.removeEventListener("canplay", handleCanPlay);
      video.removeEventListener("loadeddata", handleLoadedData);
      video.removeEventListener("error", handleError);
      video.removeEventListener("loadedmetadata", handleLoadedMetadata);
      video.removeEventListener("play", handlePlay);
      video.removeEventListener("pause", handlePause);
      observer.disconnect();
    };
  }, [playCount, videoError, isManuallyPaused]);

  const handleOpenDynaDbgWebsite = async () => {
    try {
      await openUrl("https://dynadbg.com");
    } catch (error) {
      console.error("Failed to open dynadbg.com:", error);
    }
  };

  const getStatusChip = () => {
    return (
      <Chip
        icon={<PublicIcon sx={{ fontSize: "16px" }} />}
        label="Remote Dynamic Analysis Platform"
        color="primary"
        variant="outlined"
        onClick={handleOpenDynaDbgWebsite}
        sx={{
          cursor: "pointer",
          transition: "all 0.2s ease",
          "&:hover": {
            backgroundColor: "rgba(59, 130, 246, 0.15)",
            borderColor: "primary.light",
            transform: "scale(1.02)",
          },
        }}
      />
    );
  };

  const getMainDescription = () => {
    return (
      "Perform comprehensive dynamic analysis on remote systems with real-time monitoring,\n" +
      "memory inspection, and vulnerability scanning from anywhere."
    );
  };
  const getActionButton = () => {
    if (!serverConnected) {
      return (
        <GradientButton startIcon={<NetworkIcon />} onClick={onConnect}>
          Connect to Target
        </GradientButton>
      );
    }
  };

  return (
    <Box
      sx={{
        height: "100vh",
        bgcolor: "#0f0f0f",
        color: "white",
        overflow: "hidden",
        display: "flex",
        flexDirection: "column",
      }}
    >
      {/* Hero Section */}
      <HeroSection>
        <Box
          sx={{ position: "relative", zIndex: 1, maxWidth: "4xl", mx: "auto" }}
        >
          <Box sx={{ mb: 2 }}>{getStatusChip()}</Box>

          <Typography
            variant="h1"
            sx={{
              fontSize: { xs: "2.5rem", md: "3.5rem" },
              fontWeight: 100,
              letterSpacing: "wide",
              mb: 2,
              background: "linear-gradient(135deg, #ffffff, #a1a1aa)",
              backgroundClip: "text",
              WebkitBackgroundClip: "text",
              color: "transparent",
            }}
          >
            DynaDbg
          </Typography>

          <Typography
            variant="h3"
            sx={{
              fontSize: { xs: "1.2rem", md: "1.6rem" },
              fontWeight: 300,
              letterSpacing: "wide",
              mb: 3,
              color: "#a1a1aa",
            }}
          >
            Next-Generation Remote Analysis Suite
          </Typography>

          <Box
            sx={{
              width: 100,
              height: 2,
              bgcolor: "#3b82f6",
              mx: "auto",
              mb: 3,
            }}
          />

          <Typography
            variant="h6"
            sx={{
              fontSize: { xs: "1rem", md: "1.1rem" },
              fontWeight: 300,
              lineHeight: 1.6,
              maxWidth: "2xl",
              mx: "auto",
              mb: 4,
              color: "#d1d5db",
              whiteSpace: "pre-line",
            }}
          >
            {getMainDescription()}
          </Typography>

          {getActionButton()}
        </Box>
      </HeroSection>

      {/* Remote Analysis Features - Hidden on compact height */}
      {!isCompactHeight && (
        <Box sx={{ py: 3, px: 3, bgcolor: "#1a1a1a", flexShrink: 0 }}>
          <Box sx={{ maxWidth: "7xl", mx: "auto" }}>
            <Box
              sx={{
                display: "grid",
                gridTemplateColumns: { xs: "1fr", lg: "1fr 1fr" },
                gap: 4,
                alignItems: "center",
              }}
            >
              <Box>
                <Typography
                  variant="h2"
                  sx={{
                    fontSize: { xs: "1.8rem", md: "2.5rem" },
                    fontWeight: 300,
                    letterSpacing: "wide",
                    mb: 2,
                    color: "white",
                  }}
                >
                  Advanced Remote Analysis
                </Typography>
                <Typography
                  variant="h6"
                  sx={{
                    fontSize: "1.1rem",
                    fontWeight: 300,
                    lineHeight: 1.6,
                    mb: 3,
                    color: "#d1d5db",
                  }}
                >
                  Break through the barriers of traditional debugging. Analyze
                  systems across networks with robust security and real-time
                  performance.
                </Typography>
                <Box
                  sx={{ display: "flex", flexDirection: "column", gap: 1.5 }}
                >
                  {[
                    "High-speed memory scanning",
                    "Cross-platform remote debugging",
                    "Multi-target simultaneous analysis",
                    "Fully native debugger independent of gdb/lldb",
                  ].map((feature, index) => (
                    <Box
                      key={index}
                      sx={{ display: "flex", alignItems: "center", gap: 2 }}
                    >
                      <CheckIcon sx={{ color: "#3b82f6" }} />
                      <Typography sx={{ color: "#d1d5db", fontWeight: 300 }}>
                        {feature}
                      </Typography>
                    </Box>
                  ))}
                </Box>
              </Box>

              <Box
                sx={{
                  width: "100%",
                  height: 300,
                  borderRadius: 3,
                  border: "1px solid",
                  borderColor: alpha("#3b82f6", 0.2),
                  overflow: "hidden",
                  bgcolor: "#1e1e1e",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  boxShadow: "0 20px 40px rgba(0, 0, 0, 0.3)",
                }}
              >
                {playCount >= 1 || videoError ? (
                  <Box
                    component="img"
                    src={topImage}
                    alt="DynaDbg Screenshot"
                    onClick={() => {
                      setPlayCount(0);
                      setVideoError(false);
                      setIsManuallyPaused(false);
                    }}
                    sx={{
                      width: "100%",
                      height: "100%",
                      objectFit: "cover",
                      cursor: "pointer",
                    }}
                  />
                ) : (
                  <Box
                    component="video"
                    ref={videoRef}
                    onClick={handleVideoClick}
                    sx={{
                      width: "100%",
                      height: "100%",
                      objectFit: "cover",
                      cursor: "pointer",
                    }}
                    muted
                    playsInline
                    preload="auto"
                    loop={false}
                    controls={false}
                    autoPlay={false}
                  >
                    <source src={demoVideo} type="video/mp4" />
                    <Box
                      sx={{
                        width: "100%",
                        height: "100%",
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                        flexDirection: "column",
                        gap: 2,
                        color: "#d1d5db",
                      }}
                    >
                      <PlayArrowIcon sx={{ fontSize: 64, color: "#3b82f6" }} />
                      <Typography variant="h6" sx={{ fontWeight: 500 }}>
                        DynaDbg Demo Video
                      </Typography>
                      <Typography variant="body2" sx={{ color: "#6b7280" }}>
                        Your browser doesn't support video playback
                      </Typography>
                    </Box>
                  </Box>
                )}
              </Box>
            </Box>
          </Box>
        </Box>
      )}

      {/* Footer Section */}
      <Box
        sx={{
          py: 1.5,
          px: 3,
          mt: "auto",
          borderTop: "1px solid #374151",
          bgcolor: "#1a1a1a",
          flexShrink: 0,
          minHeight: "120px",
        }}
      >
        <Container maxWidth="md">
          <Stack spacing={0.5} alignItems="center">
            <Typography variant="body2" color="#d1d5db" fontWeight="500">
              Created by{" "}
              <Typography
                component="span"
                variant="body2"
                sx={{
                  cursor: "pointer",
                  fontWeight: 500,
                  color: "#d1d5db",
                  "&:hover": {
                    color: "#3b82f6",
                    textDecoration: "underline",
                    textUnderlineOffset: "2px",
                  },
                  transition: "color 0.2s",
                }}
                onClick={onAboutClick}
              >
                DoranekoSystems
              </Typography>
            </Typography>

            <Stack direction="row" spacing={3} sx={{ py: 0 }}>
              <IconButton
                component="a"
                href="https://twitter.com/DoranekoSystems"
                target="_blank"
                rel="noopener noreferrer"
                sx={{
                  color: "#d1d5db",
                  width: 36,
                  height: 36,
                  "&:hover": {
                    color: "#3b82f6",
                    transform: "translateY(-2px)",
                  },
                  transition: "all 0.2s",
                }}
              >
                <TwitterIcon width={20} height={20} />
              </IconButton>

              <IconButton
                component="a"
                href="https://github.com/DoranekoSystems"
                target="_blank"
                rel="noopener noreferrer"
                sx={{
                  color: "#d1d5db",
                  width: 36,
                  height: 36,
                  "&:hover": {
                    color: "#3b82f6",
                    transform: "translateY(-2px)",
                  },
                  transition: "all 0.2s",
                }}
              >
                <GitHubIcon sx={{ fontSize: 20 }} />
              </IconButton>
            </Stack>
          </Stack>
        </Container>
      </Box>
    </Box>
  );
};

```

`src/client/src/components/HomeSidebar.tsx`:

```tsx
import React, { useState, useEffect } from "react";
import {
  Box,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  ListItemButton,
  Badge,
  Typography,
  Stack,
  IconButton,
  Tooltip,
  Avatar,
} from "@mui/material";
import {
  MenuBook,
  Help,
  Newspaper,
  Settings,
  Favorite as SponsorIcon,
} from "@mui/icons-material";
import { openUrl } from "@tauri-apps/plugin-opener";

interface Sponsor {
  id: string;
  name: string;
  icon_url: string;
  url: string;
}

interface SponsorResponse {
  sponsors: Sponsor[];
}

export type HomeSubPage =
  | "home"
  | "help"
  | "documentation"
  | "about"
  | "news"
  | "settings";

interface HomeSidebarProps {
  currentSubPage?: HomeSubPage;
  onSubPageChange?: (subPage: HomeSubPage) => void;
  unreadNewsCount?: number;
}

export const HomeSidebar: React.FC<HomeSidebarProps> = ({
  currentSubPage = "home",
  onSubPageChange,
  unreadNewsCount = 0,
}) => {
  const [sponsors, setSponsors] = useState<Sponsor[]>([]);

  // Fetch sponsors on mount
  useEffect(() => {
    const fetchSponsors = async () => {
      try {
        const response = await fetch(
          "https://sponsors.dynadbg.com/public/sponsors.json",
          {
            method: "GET",
            headers: {
              Accept: "application/json",
            },
          }
        );
        if (response.ok) {
          const data: SponsorResponse = await response.json();
          setSponsors(data.sponsors.slice(0, 5));
        } else {
          // Fetch failed - hide sponsors section
          setSponsors([]);
        }
      } catch (error) {
        console.log("Failed to fetch sponsors:", error);
        // Fetch failed - hide sponsors section (no fallback)
        setSponsors([]);
      }
    };
    fetchSponsors();
  }, []);

  const handleSponsorClick = async (url: string) => {
    try {
      await openUrl(url);
    } catch (error) {
      console.error("Failed to open sponsor URL:", error);
    }
  };

  return (
    <Box
      sx={{
        height: "100%",
        backgroundColor: "background.paper",
        borderRight: 1,
        borderColor: "divider",
        display: "flex",
        flexDirection: "column",
        px: 1,
        pt: 2,
        pb: 0,
      }}
    >
      {/* Main navigation items */}
      <List sx={{ p: 0 }}>
        <ListItem disablePadding>
          <ListItemButton
            selected={currentSubPage === "news"}
            onClick={() => onSubPageChange?.("news")}
            sx={{
              borderRadius: 1,
              mb: 0.5,
              py: 1,
              px: 2,
              "&:hover": { backgroundColor: "action.hover" },
              "&.Mui-selected": {
                backgroundColor: "primary.main",
                color: "primary.contrastText",
                "&:hover": {
                  backgroundColor: "primary.dark",
                },
                "& .MuiListItemIcon-root": {
                  color: "primary.contrastText",
                },
              },
            }}
          >
            <ListItemIcon>
              <Badge
                badgeContent={unreadNewsCount}
                color="error"
                sx={{
                  "& .MuiBadge-badge": {
                    fontSize: "0.65rem",
                    minWidth: 16,
                    height: 16,
                  },
                }}
              >
                <Newspaper />
              </Badge>
            </ListItemIcon>
            <ListItemText primary="News" />
          </ListItemButton>
        </ListItem>

        <ListItem disablePadding>
          <ListItemButton
            selected={currentSubPage === "documentation"}
            onClick={() => onSubPageChange?.("documentation")}
            sx={{
              borderRadius: 1,
              mb: 0.5,
              py: 1,
              px: 2,
              "&:hover": { backgroundColor: "action.hover" },
              "&.Mui-selected": {
                backgroundColor: "primary.main",
                color: "primary.contrastText",
                "&:hover": {
                  backgroundColor: "primary.dark",
                },
                "& .MuiListItemIcon-root": {
                  color: "primary.contrastText",
                },
              },
            }}
          >
            <ListItemIcon>
              <MenuBook />
            </ListItemIcon>
            <ListItemText primary="Documentation" />
          </ListItemButton>
        </ListItem>

        <ListItem disablePadding>
          <ListItemButton
            selected={currentSubPage === "settings"}
            onClick={() => onSubPageChange?.("settings")}
            sx={{
              borderRadius: 1,
              mb: 0.5,
              py: 1,
              px: 2,
              "&:hover": { backgroundColor: "action.hover" },
              "&.Mui-selected": {
                backgroundColor: "primary.main",
                color: "primary.contrastText",
                "&:hover": {
                  backgroundColor: "primary.dark",
                },
                "& .MuiListItemIcon-root": {
                  color: "primary.contrastText",
                },
              },
            }}
          >
            <ListItemIcon>
              <Settings />
            </ListItemIcon>
            <ListItemText primary="Settings" />
          </ListItemButton>
        </ListItem>

        <ListItem disablePadding>
          <ListItemButton
            selected={currentSubPage === "help"}
            onClick={() => onSubPageChange?.("help")}
            sx={{
              borderRadius: 1,
              py: 1,
              px: 2,
              "&:hover": { backgroundColor: "action.hover" },
              "&.Mui-selected": {
                backgroundColor: "primary.main",
                color: "primary.contrastText",
                "&:hover": {
                  backgroundColor: "primary.dark",
                },
                "& .MuiListItemIcon-root": {
                  color: "primary.contrastText",
                },
              },
            }}
          >
            <ListItemIcon>
              <Help />
            </ListItemIcon>
            <ListItemText primary="Help" />
          </ListItemButton>
        </ListItem>
      </List>

      {/* Spacer */}
      <Box sx={{ flex: 1, minHeight: 0 }} />

      {/* Sponsors Section - matches HomePage Footer height when on home, compact otherwise */}
      {sponsors.length > 0 && (
        <Box
          sx={{
            flexShrink: 0,
            ...(currentSubPage === "home" && {
              minHeight: "120px",
              display: "flex",
              flexDirection: "column",
              justifyContent: "flex-start",
            }),
            borderTop: "1px solid #374151",
            py: currentSubPage === "home" ? 1.5 : 1,
            px: 1,
          }}
        >
          <Typography
            variant="caption"
            sx={{
              display: "flex",
              alignItems: "center",
              gap: 0.5,
              fontSize: "10px",
              fontWeight: 600,
              color: "text.secondary",
              mb: 1,
              px: 1,
            }}
          >
            <SponsorIcon sx={{ fontSize: "14px", color: "error.main" }} />
            Sponsors
          </Typography>
          <Stack
            direction="row"
            spacing={0.5}
            sx={{
              flexWrap: "wrap",
              justifyContent: "flex-start",
              px: 0.5,
              gap: 0.5,
            }}
          >
            {sponsors.map((sponsor) => (
              <Tooltip key={sponsor.id} title={sponsor.name} placement="top">
                <IconButton
                  size="small"
                  onClick={() => handleSponsorClick(sponsor.url)}
                  sx={{
                    p: 0.25,
                    "&:hover": {
                      backgroundColor: "action.hover",
                      transform: "scale(1.1)",
                    },
                    transition: "transform 0.2s ease",
                  }}
                >
                  <Avatar
                    src={sponsor.icon_url}
                    alt={sponsor.name}
                    sx={{
                      width: 24,
                      height: 24,
                      border: "1px solid",
                      borderColor: "divider",
                    }}
                  />
                </IconButton>
              </Tooltip>
            ))}
          </Stack>
        </Box>
      )}
    </Box>
  );
};

```

`src/client/src/components/InformationContent.tsx`:

```tsx
import React, {
  useState,
  useEffect,
  useMemo,
  useCallback,
  useRef,
} from "react";
import {
  Box,
  Tabs,
  Tab,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Typography,
  TextField,
  InputAdornment,
  TableSortLabel,
  IconButton,
  Tooltip,
  Chip,
  CircularProgress,
  Autocomplete,
  ToggleButton,
  Select,
  MenuItem,
  FormControl,
  Menu,
  ListItemIcon,
} from "@mui/material";
import { ContentCopy } from "@mui/icons-material";
import {
  ViewModule,
  Search,
  Refresh as RefreshIcon,
  AccountTree,
  Memory,
  Functions,
  Code,
} from "@mui/icons-material";
import { List } from "react-window";
import { invoke } from "@tauri-apps/api/core";
import { ModuleInfo, SymbolInfo, getApiClient, ServerInfo } from "../lib/api";
import { encodeAddressToLibraryExpression } from "../utils/addressEncoder";
import { useUIStore, RegionInfo } from "../stores/uiStore";
import { ColumnResizer } from "./ColumnResizer";
import { useGhidraAnalysis } from "../hooks/useGhidraAnalysis";

interface InformationContentProps {
  attachedModules?: ModuleInfo[];
  currentTab?: number;
  onTabChange?: (tab: number) => void;
  onRefreshModules?: () => void;
  nameFilter?: string;
  onNameFilterChange?: (filter: string) => void;
  sortField?: "baseAddress" | "size" | null;
  sortDirection?: "asc" | "desc";
  onSortChange?: (
    field: "baseAddress" | "size" | null,
    direction: "asc" | "desc"
  ) => void;
  serverInfo?: ServerInfo;
}

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function TabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`info-tabpanel-${index}`}
      aria-labelledby={`info-tab-${index}`}
      {...other}
    >
      {value === index && (
        <Paper
          sx={{
            p: 2,
            backgroundColor: "background.paper",
            borderRadius: "0 4px 4px 4px",
            border: "1px solid",
            borderColor: "divider",
            borderTop: "none",
          }}
        >
          {children}
        </Paper>
      )}
    </div>
  );
}

// Row data interface for virtualized regions list
interface RegionRowData {
  regions: RegionInfo[];
  formatFileSize: (bytes: number) => string;
  onContextMenu: (event: React.MouseEvent, region: RegionInfo) => void;
  columnWidths: {
    start: number;
    end: number;
    size: number;
    protection: number;
    path: number;
  };
}

// Row data interface for virtualized symbols list
interface SymbolRowData {
  symbols: SymbolInfo[];
  formatFileSize: (bytes: number) => string;
  demangleEnabled: boolean;
  demangledNames: Map<string, string>;
  columnWidths: {
    name: number;
    address: number;
    size: number;
    type: number;
    scope: number;
    flags: number;
  };
  isMachoTarget: boolean; // true for iOS/macOS
  moduleName: string; // Module name for Copy Address (Module + offset)
  moduleBase: number | null; // Module base address for offset calculation
}

// Virtualized row component for symbols
const SYMBOL_ROW_HEIGHT = 32;

function SymbolRow({
  index,
  style,
  ...rowProps
}: {
  index: number;
  style: React.CSSProperties;
  data: SymbolRowData;
}) {
  const data = rowProps.data as SymbolRowData;
  const {
    symbols,
    formatFileSize,
    demangleEnabled,
    demangledNames,
    columnWidths,
    moduleName,
    moduleBase,
  } = data;
  const symbol = symbols[index];

  // Context menu state
  const [contextMenu, setContextMenu] = React.useState<{
    mouseX: number;
    mouseY: number;
  } | null>(null);

  const handleContextMenu = (event: React.MouseEvent) => {
    event.preventDefault();
    setContextMenu(
      contextMenu === null
        ? { mouseX: event.clientX + 2, mouseY: event.clientY - 6 }
        : null
    );
  };

  const handleCloseContextMenu = () => {
    setContextMenu(null);
  };

  const handleCopyAddress = () => {
    const address = symbol.address.startsWith("0x")
      ? symbol.address
      : `0x${symbol.address}`;
    navigator.clipboard.writeText(address);
    handleCloseContextMenu();
  };

  const handleCopyAddressWithOffset = () => {
    // Calculate offset from module base (use selected module base, fallback to symbol.module_base)
    const addressNum = parseInt(symbol.address.replace(/^0x/i, ""), 16);
    const moduleBaseNum =
      moduleBase !== null
        ? moduleBase
        : symbol.module_base
          ? parseInt(symbol.module_base.replace(/^0x/i, ""), 16)
          : 0;
    const offset = addressNum - moduleBaseNum;
    const result = `${moduleName}+0x${offset.toString(16)}`;
    navigator.clipboard.writeText(result);
    handleCloseContextMenu();
  };

  const handleCopyName = () => {
    const nameToCopy = demangleEnabled
      ? demangledNames.get(symbol.name) || symbol.name
      : symbol.name;
    navigator.clipboard.writeText(nameToCopy);
    handleCloseContextMenu();
  };

  const getTypeColor = (type: string) => {
    switch (type) {
      case "Function":
        return { bg: "rgba(76, 175, 80, 0.15)", color: "#4caf50" };
      case "Object":
        return { bg: "rgba(33, 150, 243, 0.15)", color: "#2196f3" };
      default:
        return { bg: "rgba(156, 39, 176, 0.15)", color: "#9c27b0" };
    }
  };

  const typeColors = getTypeColor(symbol.type);
  const displayName = demangleEnabled
    ? demangledNames.get(symbol.name) || symbol.name
    : symbol.name;

  return (
    <Box
      style={style}
      onContextMenu={handleContextMenu}
      sx={{
        display: "flex",
        alignItems: "center",
        borderBottom: "1px solid",
        borderColor: "divider",
        cursor: "default",
        "&:hover": {
          backgroundColor: "action.hover",
        },
      }}
    >
      {/* Context Menu */}
      <Menu
        open={contextMenu !== null}
        onClose={handleCloseContextMenu}
        anchorReference="anchorPosition"
        anchorPosition={
          contextMenu !== null
            ? { top: contextMenu.mouseY, left: contextMenu.mouseX }
            : undefined
        }
        sx={{
          "& .MuiPaper-root": {
            backgroundColor: "#252526",
            border: "1px solid #3c3c3c",
            minWidth: "150px",
          },
        }}
      >
        <MenuItem onClick={handleCopyName} sx={{ fontSize: "12px", py: 0.5 }}>
          <ListItemIcon sx={{ minWidth: "28px" }}>
            <ContentCopy sx={{ fontSize: 14 }} />
          </ListItemIcon>
          Copy Name
        </MenuItem>
        <MenuItem
          onClick={handleCopyAddress}
          sx={{ fontSize: "12px", py: 0.5 }}
        >
          <ListItemIcon sx={{ minWidth: "28px" }}>
            <ContentCopy sx={{ fontSize: 14 }} />
          </ListItemIcon>
          Copy Address
        </MenuItem>
        <MenuItem
          onClick={handleCopyAddressWithOffset}
          sx={{ fontSize: "12px", py: 0.5 }}
        >
          <ListItemIcon sx={{ minWidth: "28px" }}>
            <ContentCopy sx={{ fontSize: 14 }} />
          </ListItemIcon>
          Copy Address (Module + offset)
        </MenuItem>
      </Menu>
      {/* Name */}
      <Box
        sx={{
          width: `${columnWidths.name}px`,
          minWidth: `${columnWidths.name}px`,
          px: 1,
          py: "4px",
        }}
      >
        <Typography
          sx={{
            fontFamily: "monospace",
            fontSize: "11px",
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap",
            maxWidth: "100%",
            color:
              demangleEnabled && displayName !== symbol.name
                ? "#dcdcaa"
                : "inherit",
          }}
          title={
            demangleEnabled
              ? `${displayName}\n(mangled: ${symbol.name})`
              : symbol.name
          }
        >
          {displayName}
        </Typography>
      </Box>
      {/* Address */}
      <Box
        sx={{
          width: `${columnWidths.address}px`,
          minWidth: `${columnWidths.address}px`,
          px: 1,
          py: "4px",
        }}
      >
        <Typography
          sx={{
            fontFamily: "monospace",
            fontSize: "11px",
            color: "#4fc1ff",
          }}
        >
          {symbol.address.startsWith("0x")
            ? `0x${symbol.address.slice(2).toUpperCase()}`
            : `0x${symbol.address.toUpperCase()}`}
        </Typography>
      </Box>
      {/* Size */}
      <Box
        sx={{
          width: `${columnWidths.size}px`,
          minWidth: `${columnWidths.size}px`,
          px: 1,
          py: "4px",
        }}
      >
        <Typography
          sx={{
            fontFamily: "monospace",
            fontSize: "11px",
          }}
        >
          {symbol.size > 0 ? formatFileSize(symbol.size) : "-"}
        </Typography>
      </Box>
      {/* Type */}
      <Box
        sx={{
          width: `${columnWidths.type}px`,
          minWidth: `${columnWidths.type}px`,
          px: 1,
          py: "4px",
        }}
      >
        <Chip
          label={symbol.type}
          size="small"
          sx={{
            height: "18px",
            fontSize: "9px",
            backgroundColor: typeColors.bg,
            color: typeColors.color,
          }}
        />
      </Box>
      {/* Scope */}
      <Box
        sx={{
          width: `${columnWidths.scope}px`,
          minWidth: `${columnWidths.scope}px`,
          px: 1,
          py: "4px",
          display: "flex",
          alignItems: "center",
          gap: 0.5,
        }}
      >
        {symbol.scope === "Ghidra" ? (
          <Chip
            label="Ghidra"
            size="small"
            sx={{
              height: "18px",
              fontSize: "9px",
              backgroundColor: "rgba(129, 199, 132, 0.15)",
              color: "#81c784",
              fontWeight: 500,
            }}
          />
        ) : (
          <Typography
            sx={{
              fontSize: "11px",
              color: symbol.scope === "Global" ? "#ce9178" : "text.secondary",
            }}
          >
            {symbol.scope || "-"}
          </Typography>
        )}
      </Box>
      {/* Flags (iOS/macOS only) */}
      {data.isMachoTarget && (
        <Box
          sx={{
            width: `${columnWidths.flags}px`,
            minWidth: `${columnWidths.flags}px`,
            px: 1,
            py: "4px",
            display: "flex",
            gap: 0.5,
            flexWrap: "wrap",
            alignItems: "center",
          }}
        >
          {symbol.is_external && (
            <Chip
              label="EXT"
              size="small"
              sx={{
                height: "16px",
                fontSize: "8px",
                backgroundColor: "rgba(76, 175, 80, 0.2)",
                color: "#4caf50",
              }}
            />
          )}
          {symbol.is_weak_def && (
            <Chip
              label="WEAK"
              size="small"
              sx={{
                height: "16px",
                fontSize: "8px",
                backgroundColor: "rgba(255, 152, 0, 0.2)",
                color: "#ff9800",
              }}
            />
          )}
          {symbol.is_thumb && (
            <Chip
              label="THUMB"
              size="small"
              sx={{
                height: "16px",
                fontSize: "8px",
                backgroundColor: "rgba(33, 150, 243, 0.2)",
                color: "#2196f3",
              }}
            />
          )}
          {symbol.source === "export_trie" && (
            <Chip
              label="EXPORT"
              size="small"
              sx={{
                height: "16px",
                fontSize: "8px",
                backgroundColor: "rgba(156, 39, 176, 0.2)",
                color: "#9c27b0",
              }}
            />
          )}
        </Box>
      )}
    </Box>
  );
}

// Virtualized row component for regions
const REGION_ROW_HEIGHT = 32;

function RegionRow({
  index,
  style,
  ...rowProps
}: {
  index: number;
  style: React.CSSProperties;
  data: RegionRowData;
}) {
  const data = rowProps.data as RegionRowData;
  const { regions, formatFileSize, onContextMenu, columnWidths } = data;
  const region = regions[index];

  // Calculate size from hex addresses
  let size = 0n;
  try {
    const startAddr = BigInt("0x" + region.start_address);
    const endAddr = BigInt("0x" + region.end_address);
    size = endAddr - startAddr;
  } catch {
    // If parsing fails, show 0
  }

  return (
    <Box
      style={style}
      onContextMenu={(e) => onContextMenu(e, region)}
      sx={{
        display: "flex",
        alignItems: "center",
        borderBottom: "1px solid",
        borderColor: "divider",
        cursor: "default",
        "&:hover": {
          backgroundColor: "action.hover",
        },
      }}
    >
      {/* Start Address */}
      <Box
        sx={{
          width: `${columnWidths.start}px`,
          minWidth: `${columnWidths.start}px`,
          px: 1,
          py: "4px",
        }}
      >
        <Typography
          sx={{
            fontFamily: "monospace",
            fontSize: "11px",
            color: "#4fc1ff",
          }}
        >
          0x{region.start_address}
        </Typography>
      </Box>
      {/* End Address */}
      <Box
        sx={{
          width: `${columnWidths.end}px`,
          minWidth: `${columnWidths.end}px`,
          px: 1,
          py: "4px",
        }}
      >
        <Typography
          sx={{
            fontFamily: "monospace",
            fontSize: "11px",
            color: "#4fc1ff",
          }}
        >
          0x{region.end_address}
        </Typography>
      </Box>
      {/* Size */}
      <Box
        sx={{
          width: `${columnWidths.size}px`,
          minWidth: `${columnWidths.size}px`,
          px: 1,
          py: "4px",
        }}
      >
        <Typography
          sx={{
            fontFamily: "monospace",
            fontSize: "11px",
          }}
        >
          {formatFileSize(Number(size))}
        </Typography>
      </Box>
      {/* Protection */}
      <Box
        sx={{
          width: `${columnWidths.protection}px`,
          minWidth: `${columnWidths.protection}px`,
          px: 1,
          py: "4px",
          textAlign: "center",
        }}
      >
        <Chip
          label={region.protection}
          size="small"
          sx={{
            height: "18px",
            fontSize: "10px",
            fontFamily: "monospace",
            backgroundColor: "rgba(76, 175, 80, 0.15)",
            color: "#4caf50",
          }}
        />
      </Box>
      {/* File Path */}
      <Box
        sx={{
          width: `${columnWidths.path}px`,
          minWidth: `${columnWidths.path}px`,
          flex: 1,
          px: 1,
          py: "4px",
        }}
      >
        <Typography
          sx={{
            fontSize: "11px",
            color: "text.secondary",
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap",
          }}
          title={region.file_path || ""}
        >
          {region.file_path || "-"}
        </Typography>
      </Box>
    </Box>
  );
}

export const InformationContent: React.FC<InformationContentProps> = ({
  attachedModules = [],
  currentTab = 0,
  onTabChange,
  onRefreshModules,
  nameFilter = "",
  onNameFilterChange,
  sortField: propSortField = null,
  sortDirection: propSortDirection = "asc",
  onSortChange,
  serverInfo,
}) => {
  // Check if platform is iOS/macOS (Mach-O based)
  const isIOS = serverInfo?.target_os?.toLowerCase() === "ios";
  const isMacOS = serverInfo?.target_os?.toLowerCase() === "macos";
  const isMachoTarget = isIOS || isMacOS;

  // Ghidra analysis hook for function resolution
  const { getCachedFunctions, loadFunctionsFromDb } = useGhidraAnalysis();

  // State for Ghidra functions loaded from SQLite
  const [ghidraFunctions, setGhidraFunctions] = useState<
    Array<{ name: string; address: string; size: number }>
  >([]);
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const [_isLoadingGhidraFunctions, setIsLoadingGhidraFunctions] =
    useState(false);

  const [internalTab, setInternalTab] = useState(currentTab);
  const [isRefreshing, setIsRefreshing] = useState(false);

  // Thread and Region state from UI Store
  const {
    threads,
    threadFilter,
    regions,
    regionFilter,
    regionProtectionFilter,
    networkConnections,
    networkFilter,
  } = useUIStore((state) => state.informationState);
  const uiActions = useUIStore((state) => state.actions);
  const [isLoadingThreads, setIsLoadingThreads] = useState(false);
  const [isLoadingRegions, setIsLoadingRegions] = useState(false);
  const [isLoadingNetwork, setIsLoadingNetwork] = useState(false);

  // Context menu state for Modules
  const [moduleContextMenu, setModuleContextMenu] = useState<{
    mouseX: number;
    mouseY: number;
    module: ModuleInfo | null;
  } | null>(null);

  // Context menu state for Regions
  const [regionContextMenu, setRegionContextMenu] = useState<{
    mouseX: number;
    mouseY: number;
    region: RegionInfo | null;
  } | null>(null);

  // Context menu state for Threads
  const [threadContextMenu, setThreadContextMenu] = useState<{
    mouseX: number;
    mouseY: number;
    thread: { thread_id: number; name: string } | null;
  } | null>(null);

  // Symbols state from UI Store (persisted)
  const {
    selectedModuleBase,
    symbols: storedSymbols,
    symbolFilter,
    symbolDemangleEnabled,
    symbolSortField,
    symbolSortDirection,
    symbolTypeFilter,
    symbolScopeFilter,
    symbolColumnWidths,
    moduleColumnWidths,
    regionColumnWidths,
    threadColumnWidths,
  } = useUIStore((state) => state.informationState);

  // Column resize state
  const [resizingColumn, setResizingColumn] = useState<string | null>(null);
  const [resizingTable, setResizingTable] = useState<
    "symbol" | "module" | "region" | "thread" | null
  >(null);
  const resizeStartX = useRef(0);
  const resizeStartWidth = useRef(0);

  // Sort state for Modules table
  const [moduleSortField, setModuleSortField] = useState<
    "name" | "size" | "arch" | "path" | null
  >(null);
  const [moduleSortDirection, setModuleSortDirection] = useState<
    "asc" | "desc"
  >("asc");

  // Sort state for Regions table
  const [regionSortField, setRegionSortField] = useState<
    "start" | "end" | "size" | "path" | null
  >(null);
  const [regionSortDirection, setRegionSortDirection] = useState<
    "asc" | "desc"
  >("asc");

  // Sort state for Threads table
  const [threadSortField, setThreadSortField] = useState<"id" | "name" | null>(
    null
  );
  const [threadSortDirection, setThreadSortDirection] = useState<
    "asc" | "desc"
  >("asc");

  // Local symbols state
  const [symbols, setSymbols] = useState<SymbolInfo[]>(
    storedSymbols as SymbolInfo[]
  );
  const [isLoadingSymbols, setIsLoadingSymbols] = useState(false);

  // Demangled names cache
  const [demangledNames, setDemangledNames] = useState<Map<string, string>>(
    new Map()
  );
  const [isDemanglingInProgress, setIsDemanglingInProgress] = useState(false);

  // Find selected module from attachedModules using stored base
  const selectedModuleForSymbols = useMemo(() => {
    if (selectedModuleBase === null) return null;
    return attachedModules.find((m) => m.base === selectedModuleBase) || null;
  }, [attachedModules, selectedModuleBase]);

  // Load Ghidra functions from SQLite when module is selected
  useEffect(() => {
    console.log(
      `[InformationContent] useEffect triggered - selectedModuleForSymbols:`,
      selectedModuleForSymbols,
      `selectedModuleBase:`,
      selectedModuleBase
    );

    const loadGhidraFunctions = async () => {
      if (!selectedModuleForSymbols) {
        console.log(
          `[InformationContent] No module selected, clearing ghidraFunctions`
        );
        setGhidraFunctions([]);
        return;
      }

      // Use path, name, or modulename (the API returns modulename)
      const modulePath =
        selectedModuleForSymbols.path ||
        selectedModuleForSymbols.name ||
        selectedModuleForSymbols.modulename ||
        "";
      console.log(`[InformationContent] modulePath: ${modulePath}`);
      if (!modulePath) {
        setGhidraFunctions([]);
        return;
      }

      // First check in-memory cache
      const cachedFunctions = getCachedFunctions(modulePath);
      if (cachedFunctions && cachedFunctions.length > 0) {
        setGhidraFunctions(cachedFunctions);
        return;
      }

      // Then try loading from SQLite
      setIsLoadingGhidraFunctions(true);
      try {
        const pathParts = modulePath.split(/[/\\]/);
        const libraryName = pathParts[pathParts.length - 1];

        // Try multiple targetOs variations to handle case sensitivity
        const targetOs = serverInfo?.target_os || "unknown";
        const targetOsLower = targetOs.toLowerCase();

        console.log(
          `[InformationContent] Loading Ghidra functions - modulePath: ${modulePath}, libraryName: ${libraryName}, targetOs: ${targetOs}`
        );

        // Try with lowercase first (as saved by GhidraAnalyzer), then original case, then "unknown"
        let functions = await loadFunctionsFromDb(targetOsLower, libraryName);
        if (!functions || functions.length === 0) {
          functions = await loadFunctionsFromDb(targetOs, libraryName);
        }
        if (!functions || functions.length === 0) {
          functions = await loadFunctionsFromDb("unknown", libraryName);
        }

        if (functions && functions.length > 0) {
          console.log(
            `[InformationContent] Loaded ${functions.length} Ghidra functions for ${libraryName}`
          );
          setGhidraFunctions(functions);
        } else {
          console.log(
            `[InformationContent] No Ghidra functions found for ${libraryName} (tried targetOs: ${targetOs}, ${targetOsLower}, unknown)`
          );
          setGhidraFunctions([]);
        }
      } catch (e) {
        console.error("Failed to load Ghidra functions from SQLite:", e);
        setGhidraFunctions([]);
      } finally {
        setIsLoadingGhidraFunctions(false);
      }
    };

    loadGhidraFunctions();
  }, [
    selectedModuleForSymbols,
    serverInfo?.target_os,
    getCachedFunctions,
    loadFunctionsFromDb,
  ]);

  // Sync symbols from store on mount
  useEffect(() => {
    if (storedSymbols.length > 0 && symbols.length === 0) {
      setSymbols(storedSymbols as SymbolInfo[]);
    }
  }, [storedSymbols, symbols.length]);

  // Demangle symbols using Tauri when symbols change or demangle is enabled
  useEffect(() => {
    if (!symbolDemangleEnabled || symbols.length === 0) {
      return;
    }

    // Get names that need demangling (not already in cache)
    const namesToDemangle = symbols
      .map((s) => s.name)
      .filter((name) => !demangledNames.has(name));

    if (namesToDemangle.length === 0) {
      return;
    }

    setIsDemanglingInProgress(true);

    // Call Tauri demangle command
    invoke<string[]>("demangle_symbols", { names: namesToDemangle })
      .then((demangled) => {
        const newCache = new Map(demangledNames);
        namesToDemangle.forEach((name, index) => {
          newCache.set(name, demangled[index]);
        });
        setDemangledNames(newCache);
      })
      .catch((error) => {
        console.error("Failed to demangle symbols:", error);
      })
      .finally(() => {
        setIsDemanglingInProgress(false);
      });
  }, [symbols, symbolDemangleEnabled, demangledNames]);

  // Use local state as fallback if props not provided
  const [localNameFilter, setLocalNameFilter] = useState("");
  const [localSortField, setLocalSortField] = useState<
    "baseAddress" | "size" | null
  >(null);
  const [localSortDirection, setLocalSortDirection] = useState<"asc" | "desc">(
    "asc"
  );

  // Use props if provided, otherwise use local state
  const currentNameFilter = onNameFilterChange ? nameFilter : localNameFilter;
  const currentSortField = onSortChange ? propSortField : localSortField;
  const currentSortDirection = onSortChange
    ? propSortDirection
    : localSortDirection;

  // Sync internal tab with external tab
  useEffect(() => {
    setInternalTab(currentTab);
  }, [currentTab]);

  const handleTabChange = (_event: React.SyntheticEvent, newValue: number) => {
    setInternalTab(newValue);
    if (onTabChange) {
      onTabChange(newValue);
    }
    // Load modules when switching to modules tab
    if (newValue === 0) {
      handleRefreshModules();
    }
    // Symbols tab (index 1) - no auto-load, wait for module selection
    // Load regions when switching to regions tab
    if (newValue === 2) {
      loadRegions();
    }
    // Load threads when switching to threads tab
    if (newValue === 3) {
      loadThreads();
    }
    // Load network connections when switching to network tab
    if (newValue === 4) {
      loadNetworkConnections();
    }
  };

  const handleSort = (field: "baseAddress" | "size") => {
    const isAsc = currentSortField === field && currentSortDirection === "asc";
    const newDirection: "asc" | "desc" = isAsc ? "desc" : "asc";

    if (onSortChange) {
      onSortChange(field, newDirection);
    } else {
      setLocalSortDirection(newDirection);
      setLocalSortField(field);
    }
  };

  const handleRefreshModules = async () => {
    if (!onRefreshModules || isRefreshing) return;

    setIsRefreshing(true);
    try {
      await onRefreshModules();
    } finally {
      setIsRefreshing(false);
    }
  };

  const loadThreads = useCallback(async () => {
    setIsLoadingThreads(true);
    try {
      const client = getApiClient();
      const response = await client.enumerateThreads();
      if (response.success && response.data?.threads) {
        uiActions.setInformationThreads(response.data.threads);
      } else {
        uiActions.setInformationThreads([]);
      }
    } catch (error) {
      console.error("Failed to load threads:", error);
      uiActions.setInformationThreads([]);
    } finally {
      setIsLoadingThreads(false);
    }
  }, [uiActions]);

  const handleRefreshThreads = async () => {
    await loadThreads();
  };

  const loadRegions = useCallback(async () => {
    setIsLoadingRegions(true);
    try {
      const client = getApiClient();
      const response = await client.enumerateRegions();
      if (response.regions) {
        uiActions.setInformationRegions(response.regions);
      } else {
        uiActions.setInformationRegions([]);
      }
    } catch (error) {
      console.error("Failed to load regions:", error);
      uiActions.setInformationRegions([]);
    } finally {
      setIsLoadingRegions(false);
    }
  }, [uiActions]);

  const handleRefreshRegions = async () => {
    await loadRegions();
  };

  // Network connections loading
  const loadNetworkConnections = useCallback(async () => {
    setIsLoadingNetwork(true);
    try {
      const client = getApiClient();
      const response = await client.enumerateNetwork();
      console.log("Network API response:", response);
      if (response.success && response.data?.connections) {
        console.log(
          "Network connections found:",
          response.data.connections.length
        );
        uiActions.setNetworkConnections(response.data.connections);
      } else {
        console.log("No network connections in response:", response);
        uiActions.setNetworkConnections([]);
      }
    } catch (error) {
      console.error("Failed to load network connections:", error);
      uiActions.setNetworkConnections([]);
    } finally {
      setIsLoadingNetwork(false);
    }
  }, [uiActions]);

  const handleRefreshNetwork = async () => {
    await loadNetworkConnections();
  };

  // Column resize handlers for symbols table
  const handleSymbolColumnResizeStart = useCallback(
    (column: keyof typeof symbolColumnWidths) => (e: React.MouseEvent) => {
      e.preventDefault();
      setResizingColumn(column);
      setResizingTable("symbol");
      resizeStartX.current = e.clientX;
      resizeStartWidth.current = symbolColumnWidths[column];

      const handleMouseMove = (moveEvent: MouseEvent) => {
        const delta = moveEvent.clientX - resizeStartX.current;
        const newWidth = Math.max(50, resizeStartWidth.current + delta);
        uiActions.setSymbolColumnWidth(column, newWidth);
      };

      const handleMouseUp = () => {
        setResizingColumn(null);
        setResizingTable(null);
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
      };

      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
    },
    [symbolColumnWidths, uiActions]
  );

  // Column resize handlers for modules table
  const handleModuleColumnResizeStart = useCallback(
    (column: keyof typeof moduleColumnWidths) => (e: React.MouseEvent) => {
      e.preventDefault();
      setResizingColumn(column);
      setResizingTable("module");
      resizeStartX.current = e.clientX;
      resizeStartWidth.current = moduleColumnWidths[column];

      const handleMouseMove = (moveEvent: MouseEvent) => {
        const delta = moveEvent.clientX - resizeStartX.current;
        const newWidth = Math.max(50, resizeStartWidth.current + delta);
        uiActions.setModuleColumnWidth(column, newWidth);
      };

      const handleMouseUp = () => {
        setResizingColumn(null);
        setResizingTable(null);
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
      };

      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
    },
    [moduleColumnWidths, uiActions]
  );

  // Column resize handlers for regions table
  const handleRegionColumnResizeStart = useCallback(
    (column: keyof typeof regionColumnWidths) => (e: React.MouseEvent) => {
      e.preventDefault();
      setResizingColumn(column);
      setResizingTable("region");
      resizeStartX.current = e.clientX;
      resizeStartWidth.current = regionColumnWidths[column];

      const handleMouseMove = (moveEvent: MouseEvent) => {
        const delta = moveEvent.clientX - resizeStartX.current;
        const newWidth = Math.max(50, resizeStartWidth.current + delta);
        uiActions.setRegionColumnWidth(column, newWidth);
      };

      const handleMouseUp = () => {
        setResizingColumn(null);
        setResizingTable(null);
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
      };

      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
    },
    [regionColumnWidths, uiActions]
  );

  // Column resize handlers for threads table
  const handleThreadColumnResizeStart = useCallback(
    (column: keyof typeof threadColumnWidths) => (e: React.MouseEvent) => {
      e.preventDefault();
      setResizingColumn(column);
      setResizingTable("thread");
      resizeStartX.current = e.clientX;
      resizeStartWidth.current = threadColumnWidths[column];

      const handleMouseMove = (moveEvent: MouseEvent) => {
        const delta = moveEvent.clientX - resizeStartX.current;
        const newWidth = Math.max(50, resizeStartWidth.current + delta);
        uiActions.setThreadColumnWidth(column, newWidth);
      };

      const handleMouseUp = () => {
        setResizingColumn(null);
        setResizingTable(null);
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
      };

      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
    },
    [threadColumnWidths, uiActions]
  );

  // Load symbols for selected module
  const loadSymbols = useCallback(
    async (module: ModuleInfo) => {
      setIsLoadingSymbols(true);
      uiActions.setSymbolsSelectedModule(module.base);
      // Clear demangle cache when loading new module
      setDemangledNames(new Map());
      // Reset filter when loading new module
      uiActions.setSymbolFilter("");
      try {
        const client = getApiClient();
        const symbolsData = await client.enumerateSymbolsForModule(module);
        setSymbols(symbolsData);
        // Store symbols in uiStore for persistence
        uiActions.setSymbols(
          symbolsData.map((s) => ({
            name: s.name,
            address: s.address,
            size: s.size,
            type: s.type,
            scope: s.scope,
          }))
        );
      } catch (error) {
        console.error("Failed to load symbols:", error);
        setSymbols([]);
        uiActions.setSymbols([]);
      } finally {
        setIsLoadingSymbols(false);
      }
    },
    [uiActions]
  );

  const handleModuleSelectForSymbols = (
    _event: React.SyntheticEvent,
    module: ModuleInfo | null
  ) => {
    if (module) {
      loadSymbols(module);
    } else {
      uiActions.setSymbolsSelectedModule(null);
      uiActions.setSymbolFilter("");
      setSymbols([]);
      uiActions.setSymbols([]);
    }
  };

  // Filter and sort symbols
  const filteredSymbols = useMemo(() => {
    // First, deduplicate symbols by name and address
    // If duplicates exist, prefer the one with size > 0
    const symbolMap = new Map<
      string,
      SymbolInfo & { isGhidraAnalyzed?: boolean }
    >();
    for (const symbol of symbols) {
      const key = `${symbol.name}_${symbol.address}`;
      const existing = symbolMap.get(key);
      if (!existing) {
        symbolMap.set(key, symbol);
      } else if (symbol.size > 0 && existing.size === 0) {
        // Prefer symbol with size information
        symbolMap.set(key, symbol);
      }
    }

    // Add Ghidra analyzed functions for selected module (loaded from SQLite)
    if (selectedModuleForSymbols && ghidraFunctions.length > 0) {
      const moduleBase = selectedModuleForSymbols.base || 0;
      for (const func of ghidraFunctions) {
        // Convert offset to absolute address by adding module base
        const offsetHex = func.address.startsWith("0x")
          ? func.address
          : `0x${func.address}`;
        const offset = parseInt(offsetHex, 16);
        const absoluteAddress = (BigInt(moduleBase) + BigInt(offset)).toString(
          16
        );
        const absoluteAddressFormatted = `0x${absoluteAddress}`;

        const key = `${func.name}_${absoluteAddressFormatted}`;
        if (!symbolMap.has(key)) {
          // Add as a new symbol with Ghidra marker
          symbolMap.set(key, {
            name: func.name,
            address: absoluteAddressFormatted,
            size: func.size,
            type: "Function",
            scope: "Ghidra",
            module_base: moduleBase.toString(16),
            isGhidraAnalyzed: true,
          });
        }
      }
    }

    let result = Array.from(symbolMap.values());

    // Apply type filter
    if (symbolTypeFilter !== "all") {
      result = result.filter((symbol) => symbol.type === symbolTypeFilter);
    }

    // Apply scope filter
    if (symbolScopeFilter !== "all") {
      result = result.filter((symbol) => symbol.scope === symbolScopeFilter);
    }

    // Apply name/address filter
    if (symbolFilter.trim()) {
      const lowerFilter = symbolFilter.toLowerCase();
      result = result.filter(
        (symbol) =>
          symbol.name.toLowerCase().includes(lowerFilter) ||
          symbol.type.toLowerCase().includes(lowerFilter) ||
          symbol.address.toLowerCase().includes(lowerFilter)
      );
    }

    // Sort by selected field
    result = [...result].sort((a, b) => {
      let comparison = 0;
      if (symbolSortField === "name") {
        comparison = a.name.localeCompare(b.name);
      } else if (symbolSortField === "address") {
        const addrA = BigInt(
          a.address.startsWith("0x") ? a.address : `0x${a.address}`
        );
        const addrB = BigInt(
          b.address.startsWith("0x") ? b.address : `0x${b.address}`
        );
        comparison = addrA < addrB ? -1 : addrA > addrB ? 1 : 0;
      } else if (symbolSortField === "size") {
        comparison = a.size - b.size;
      } else if (symbolSortField === "type") {
        comparison = a.type.localeCompare(b.type);
      } else if (symbolSortField === "scope") {
        comparison = (a.scope || "").localeCompare(b.scope || "");
      }
      return symbolSortDirection === "asc" ? comparison : -comparison;
    });

    return result;
  }, [
    symbols,
    symbolFilter,
    symbolTypeFilter,
    symbolScopeFilter,
    symbolSortField,
    symbolSortDirection,
    selectedModuleForSymbols,
    ghidraFunctions,
  ]);

  // Get unique symbol types for filter dropdown
  const symbolTypes = useMemo(() => {
    const types = new Set(symbols.map((s) => s.type));
    return Array.from(types).sort();
  }, [symbols]);

  // Get unique symbol scopes for filter dropdown
  const symbolScopes = useMemo(() => {
    const scopes = new Set(symbols.map((s) => s.scope).filter(Boolean));
    // Add "Ghidra" scope if we have analyzed functions
    if (selectedModuleForSymbols && ghidraFunctions.length > 0) {
      scopes.add("Ghidra");
    }
    return Array.from(scopes).sort();
  }, [symbols, selectedModuleForSymbols, ghidraFunctions]);

  // Filter and sort regions by protection
  const filteredRegions = useMemo(() => {
    let result = regions.filter((region) => {
      const protection = region.protection || "";
      const hasR = protection.includes("r");
      const hasW = protection.includes("w");
      const hasX = protection.includes("x");
      const hasP = protection.includes("p");

      // Check each filter - null means "don't care"
      if (
        regionProtectionFilter.readable !== null &&
        regionProtectionFilter.readable !== hasR
      ) {
        return false;
      }
      if (
        regionProtectionFilter.writable !== null &&
        regionProtectionFilter.writable !== hasW
      ) {
        return false;
      }
      if (
        regionProtectionFilter.executable !== null &&
        regionProtectionFilter.executable !== hasX
      ) {
        return false;
      }
      if (
        regionProtectionFilter.private !== null &&
        regionProtectionFilter.private !== hasP
      ) {
        return false;
      }

      // Apply file path filter
      if (regionFilter.trim()) {
        const filePath = region.file_path || "";
        if (!filePath.toLowerCase().includes(regionFilter.toLowerCase())) {
          return false;
        }
      }

      return true;
    });

    // Apply sorting
    if (regionSortField) {
      result = [...result].sort((a, b) => {
        let comparison = 0;
        switch (regionSortField) {
          case "start":
            try {
              const startA = BigInt("0x" + a.start_address);
              const startB = BigInt("0x" + b.start_address);
              comparison = startA < startB ? -1 : startA > startB ? 1 : 0;
            } catch {
              comparison = 0;
            }
            break;
          case "end":
            try {
              const endA = BigInt("0x" + a.end_address);
              const endB = BigInt("0x" + b.end_address);
              comparison = endA < endB ? -1 : endA > endB ? 1 : 0;
            } catch {
              comparison = 0;
            }
            break;
          case "size":
            try {
              const sizeA =
                BigInt("0x" + a.end_address) - BigInt("0x" + a.start_address);
              const sizeB =
                BigInt("0x" + b.end_address) - BigInt("0x" + b.start_address);
              comparison = sizeA < sizeB ? -1 : sizeA > sizeB ? 1 : 0;
            } catch {
              comparison = 0;
            }
            break;
          case "path":
            comparison = (a.file_path || "").localeCompare(b.file_path || "");
            break;
        }
        return regionSortDirection === "asc" ? comparison : -comparison;
      });
    }

    return result;
  }, [
    regions,
    regionProtectionFilter,
    regionFilter,
    regionSortField,
    regionSortDirection,
  ]);

  const formatFileSize = (bytes: number): string => {
    const sizes = ["B", "KB", "MB", "GB"];
    if (bytes === 0) return "0 B";
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    return `${Math.round((bytes / Math.pow(1024, i)) * 100) / 100} ${sizes[i]}`;
  };

  // Filter and sort modules
  const filteredAndSortedModules = useMemo(() => {
    let filtered = attachedModules;

    // Apply name filter
    if (currentNameFilter.trim()) {
      filtered = attachedModules.filter((module) => {
        const moduleName = module.modulename || module.name || "Unknown";
        const fileName = moduleName.split(/[\/\\]/).pop() || moduleName;
        return fileName.toLowerCase().includes(currentNameFilter.toLowerCase());
      });
    }

    // Apply sorting - first check new local sort, then fallback to prop-based sort
    const sortField = moduleSortField || currentSortField;
    const sortDirection = moduleSortField
      ? moduleSortDirection
      : currentSortDirection;

    if (sortField) {
      return [...filtered].sort((a, b) => {
        let comparison = 0;
        const moduleNameA = a.modulename || a.name || "";
        const moduleNameB = b.modulename || b.name || "";
        const fileNameA = moduleNameA.split(/[\/\\]/).pop() || moduleNameA;
        const fileNameB = moduleNameB.split(/[\/\\]/).pop() || moduleNameB;

        switch (sortField) {
          case "name":
            comparison = fileNameA.localeCompare(fileNameB);
            break;
          case "baseAddress":
            comparison = a.base - b.base;
            break;
          case "size":
            comparison = a.size - b.size;
            break;
          case "arch":
            // Sort by is_64bit boolean
            comparison = (a.is_64bit ? 1 : 0) - (b.is_64bit ? 1 : 0);
            break;
          case "path":
            comparison = moduleNameA.localeCompare(moduleNameB);
            break;
        }

        return sortDirection === "asc" ? comparison : -comparison;
      });
    }

    return filtered;
  }, [
    attachedModules,
    currentNameFilter,
    currentSortField,
    currentSortDirection,
    moduleSortField,
    moduleSortDirection,
  ]);

  // Filter threads
  const filteredThreads = useMemo(() => {
    let result = threads;

    // Apply filter
    if (threadFilter.trim()) {
      result = threads.filter((thread) => {
        const searchLower = threadFilter.toLowerCase();
        return (
          thread.name.toLowerCase().includes(searchLower) ||
          thread.thread_id.toString().includes(searchLower) ||
          thread.pc.toLowerCase().includes(searchLower) ||
          thread.state.toLowerCase().includes(searchLower)
        );
      });
    }

    // Apply sorting
    if (threadSortField) {
      result = [...result].sort((a, b) => {
        let comparison = 0;
        switch (threadSortField) {
          case "id":
            comparison = a.thread_id - b.thread_id;
            break;
          case "name":
            comparison = a.name.localeCompare(b.name);
            break;
        }
        return threadSortDirection === "asc" ? comparison : -comparison;
      });
    }

    return result;
  }, [threads, threadFilter, threadSortField, threadSortDirection]);

  const getStateColor = (state: string) => {
    switch (state) {
      case "Running":
        return "#4caf50";
      case "Waiting":
        return "#5c6bc0"; // 落ち着いた青紫色
      case "Stopped":
        return "#f44336";
      case "Halted":
        return "#9e9e9e";
      default:
        return "#78909c";
    }
  };

  return (
    <Box sx={{ width: "100%", height: "100%", p: 2 }}>
      {/* Chrome-style tabs */}
      <Box sx={{ display: "flex", alignItems: "flex-end" }}>
        <Tabs
          value={internalTab}
          onChange={handleTabChange}
          aria-label="information tabs"
          sx={{
            minHeight: "28px",
            "& .MuiTabs-indicator": {
              display: "none",
            },
            "& .MuiTab-root": {
              minHeight: "28px",
              minWidth: "80px",
              fontSize: "11px",
              textTransform: "none",
              fontWeight: 500,
              px: 1.5,
              py: 0.5,
              borderTopLeftRadius: "6px",
              borderTopRightRadius: "6px",
              border: "1px solid",
              borderBottom: "none",
              borderColor: "divider",
              backgroundColor: "action.hover",
              color: "text.secondary",
              marginRight: "2px",
              "&.Mui-selected": {
                backgroundColor: "background.paper",
                color: "primary.main",
                fontWeight: 600,
              },
            },
          }}
        >
          <Tab
            icon={<ViewModule sx={{ fontSize: "12px" }} />}
            iconPosition="start"
            label="Modules"
            id="info-tab-0"
            aria-controls="info-tabpanel-0"
            sx={{ gap: 0.5 }}
          />
          <Tab
            icon={<Functions sx={{ fontSize: "12px" }} />}
            iconPosition="start"
            label="Symbols"
            id="info-tab-1"
            aria-controls="info-tabpanel-1"
            sx={{ gap: 0.5 }}
          />
          <Tab
            icon={<Memory sx={{ fontSize: "12px" }} />}
            iconPosition="start"
            label="Regions"
            id="info-tab-2"
            aria-controls="info-tabpanel-2"
            sx={{ gap: 0.5 }}
          />
          <Tab
            icon={<AccountTree sx={{ fontSize: "12px" }} />}
            iconPosition="start"
            label="Threads"
            id="info-tab-3"
            aria-controls="info-tabpanel-3"
            sx={{ gap: 0.5 }}
          />
          {/* Network tab hidden for now
          <Tab
            icon={<NetworkIcon sx={{ fontSize: "12px" }} />}
            iconPosition="start"
            label="Network"
            id="info-tab-4"
            aria-controls="info-tabpanel-4"
            sx={{ gap: 0.5 }}
          />
          */}
        </Tabs>
      </Box>

      {/* Content area with top border connecting to tabs */}
      <Box
        sx={{
          borderTop: "1px solid",
          borderColor: "divider",
          mt: "-1px",
        }}
      >
        {/* Modules Tab */}
        <TabPanel value={internalTab} index={0}>
          <Box
            sx={{
              mb: 2,
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
            }}
          >
            <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
              <Typography variant="h6" sx={{ fontSize: "14px" }}>
                Modules
              </Typography>
              {isRefreshing ? (
                <CircularProgress size={16} />
              ) : (
                <Chip
                  label={attachedModules.length}
                  size="small"
                  sx={{ height: "20px", fontSize: "11px" }}
                />
              )}
              <Tooltip title="Refresh modules">
                <IconButton
                  size="small"
                  onClick={handleRefreshModules}
                  disabled={!onRefreshModules || isRefreshing}
                >
                  <RefreshIcon sx={{ fontSize: "16px" }} />
                </IconButton>
              </Tooltip>
            </Box>
            <TextField
              size="small"
              placeholder="Filter by name..."
              value={currentNameFilter}
              onChange={(e) => {
                if (onNameFilterChange) {
                  onNameFilterChange(e.target.value);
                } else {
                  setLocalNameFilter(e.target.value);
                }
              }}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <Search sx={{ fontSize: "16px" }} />
                  </InputAdornment>
                ),
              }}
              sx={{
                width: "250px",
                "& .MuiOutlinedInput-root": {
                  fontSize: "12px",
                },
              }}
            />
          </Box>
          <TableContainer
            component={Paper}
            sx={{
              maxHeight: "calc(100vh - 200px)",
              "&::-webkit-scrollbar": {
                width: "10px",
                height: "10px",
              },
              "&::-webkit-scrollbar-track": {
                background: "#1e1e1e",
              },
              "&::-webkit-scrollbar-thumb": {
                background: "#3e3e42",
                borderRadius: "4px",
                "&:hover": {
                  background: "#5a5a5e",
                },
              },
              "&::-webkit-scrollbar-corner": {
                background: "#1e1e1e",
              },
            }}
          >
            <Table stickyHeader size="small">
              <TableHead>
                <TableRow>
                  <TableCell
                    sx={{
                      fontSize: "11px",
                      fontWeight: 600,
                      width: `${moduleColumnWidths.name}px`,
                      minWidth: `${moduleColumnWidths.name}px`,
                      position: "relative",
                    }}
                  >
                    <TableSortLabel
                      active={moduleSortField === "name"}
                      direction={
                        moduleSortField === "name" ? moduleSortDirection : "asc"
                      }
                      onClick={() => {
                        const isAsc =
                          moduleSortField === "name" &&
                          moduleSortDirection === "asc";
                        setModuleSortDirection(isAsc ? "desc" : "asc");
                        setModuleSortField("name");
                      }}
                      sx={{
                        fontSize: "11px",
                        "& .MuiTableSortLabel-icon": {
                          opacity: moduleSortField === "name" ? 1 : 0,
                        },
                        "&:hover .MuiTableSortLabel-icon": {
                          opacity: 0.5,
                        },
                        "&.Mui-active .MuiTableSortLabel-icon": {
                          opacity: 1,
                        },
                      }}
                    >
                      Name
                    </TableSortLabel>
                    <ColumnResizer
                      onMouseDown={handleModuleColumnResizeStart("name")}
                      isResizing={
                        resizingColumn === "name" && resizingTable === "module"
                      }
                    />
                  </TableCell>
                  <TableCell
                    sx={{
                      fontSize: "11px",
                      fontWeight: 600,
                      width: `${moduleColumnWidths.base}px`,
                      minWidth: `${moduleColumnWidths.base}px`,
                      position: "relative",
                    }}
                  >
                    <TableSortLabel
                      active={currentSortField === "baseAddress"}
                      direction={
                        currentSortField === "baseAddress"
                          ? currentSortDirection
                          : "asc"
                      }
                      onClick={() => handleSort("baseAddress")}
                      sx={{
                        fontSize: "11px",
                        "& .MuiTableSortLabel-icon": {
                          opacity: currentSortField === "baseAddress" ? 1 : 0,
                        },
                        "&:hover .MuiTableSortLabel-icon": {
                          opacity: 0.5,
                        },
                        "&.Mui-active .MuiTableSortLabel-icon": {
                          opacity: 1,
                        },
                      }}
                    >
                      Base Address
                    </TableSortLabel>
                    <ColumnResizer
                      onMouseDown={handleModuleColumnResizeStart("base")}
                      isResizing={
                        resizingColumn === "base" && resizingTable === "module"
                      }
                    />
                  </TableCell>
                  <TableCell
                    sx={{
                      fontSize: "11px",
                      fontWeight: 600,
                      width: `${moduleColumnWidths.size}px`,
                      minWidth: `${moduleColumnWidths.size}px`,
                      position: "relative",
                    }}
                  >
                    <TableSortLabel
                      active={moduleSortField === "size"}
                      direction={
                        moduleSortField === "size" ? moduleSortDirection : "asc"
                      }
                      onClick={() => {
                        const isAsc =
                          moduleSortField === "size" &&
                          moduleSortDirection === "asc";
                        setModuleSortDirection(isAsc ? "desc" : "asc");
                        setModuleSortField("size");
                      }}
                      sx={{
                        fontSize: "11px",
                        "& .MuiTableSortLabel-icon": {
                          opacity: moduleSortField === "size" ? 1 : 0,
                        },
                        "&:hover .MuiTableSortLabel-icon": {
                          opacity: 0.5,
                        },
                        "&.Mui-active .MuiTableSortLabel-icon": {
                          opacity: 1,
                        },
                      }}
                    >
                      Size
                    </TableSortLabel>
                    <ColumnResizer
                      onMouseDown={handleModuleColumnResizeStart("size")}
                      isResizing={
                        resizingColumn === "size" && resizingTable === "module"
                      }
                    />
                  </TableCell>
                  <TableCell
                    sx={{
                      fontSize: "11px",
                      fontWeight: 600,
                      width: `${moduleColumnWidths.arch}px`,
                      minWidth: `${moduleColumnWidths.arch}px`,
                      textAlign: "center",
                      position: "relative",
                    }}
                  >
                    <TableSortLabel
                      active={moduleSortField === "arch"}
                      direction={
                        moduleSortField === "arch" ? moduleSortDirection : "asc"
                      }
                      onClick={() => {
                        const isAsc =
                          moduleSortField === "arch" &&
                          moduleSortDirection === "asc";
                        setModuleSortDirection(isAsc ? "desc" : "asc");
                        setModuleSortField("arch");
                      }}
                      sx={{
                        fontSize: "11px",
                        "& .MuiTableSortLabel-icon": {
                          opacity: moduleSortField === "arch" ? 1 : 0,
                        },
                        "&:hover .MuiTableSortLabel-icon": {
                          opacity: 0.5,
                        },
                        "&.Mui-active .MuiTableSortLabel-icon": {
                          opacity: 1,
                        },
                      }}
                    >
                      Architecture
                    </TableSortLabel>
                    <ColumnResizer
                      onMouseDown={handleModuleColumnResizeStart("arch")}
                      isResizing={
                        resizingColumn === "arch" && resizingTable === "module"
                      }
                    />
                  </TableCell>
                  <TableCell
                    sx={{
                      fontSize: "11px",
                      fontWeight: 600,
                      width: `${moduleColumnWidths.path}px`,
                      minWidth: `${moduleColumnWidths.path}px`,
                      position: "relative",
                    }}
                  >
                    <TableSortLabel
                      active={moduleSortField === "path"}
                      direction={
                        moduleSortField === "path" ? moduleSortDirection : "asc"
                      }
                      onClick={() => {
                        const isAsc =
                          moduleSortField === "path" &&
                          moduleSortDirection === "asc";
                        setModuleSortDirection(isAsc ? "desc" : "asc");
                        setModuleSortField("path");
                      }}
                      sx={{
                        fontSize: "11px",
                        "& .MuiTableSortLabel-icon": {
                          opacity: moduleSortField === "path" ? 1 : 0,
                        },
                        "&:hover .MuiTableSortLabel-icon": {
                          opacity: 0.5,
                        },
                        "&.Mui-active .MuiTableSortLabel-icon": {
                          opacity: 1,
                        },
                      }}
                    >
                      Path
                    </TableSortLabel>
                    <ColumnResizer
                      onMouseDown={handleModuleColumnResizeStart("path")}
                      isResizing={
                        resizingColumn === "path" && resizingTable === "module"
                      }
                    />
                  </TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {filteredAndSortedModules.map((module, index) => {
                  const moduleName =
                    module.modulename || module.name || "Unknown";
                  const fileName =
                    moduleName.split(/[\/\\]/).pop() || moduleName;
                  const baseAddress = `0x${module.base.toString(16).toUpperCase()}`;

                  return (
                    <TableRow
                      key={`${module.base}-${index}`}
                      hover
                      onContextMenu={(e) => {
                        e.preventDefault();
                        setModuleContextMenu({
                          mouseX: e.clientX + 2,
                          mouseY: e.clientY - 6,
                          module,
                        });
                      }}
                      sx={{ cursor: "default" }}
                    >
                      <TableCell
                        sx={{
                          fontSize: "11px",
                          fontFamily: "monospace",
                          width: `${moduleColumnWidths.name}px`,
                          minWidth: `${moduleColumnWidths.name}px`,
                          overflow: "hidden",
                          textOverflow: "ellipsis",
                          whiteSpace: "nowrap",
                        }}
                      >
                        <Typography
                          variant="body2"
                          sx={{
                            fontSize: "11px",
                            overflow: "hidden",
                            textOverflow: "ellipsis",
                            whiteSpace: "nowrap",
                            display: "block",
                          }}
                          title={fileName}
                        >
                          {fileName}
                        </Typography>
                      </TableCell>
                      <TableCell
                        sx={{
                          fontSize: "11px",
                          fontFamily: "monospace",
                          color: "#4fc1ff",
                          width: `${moduleColumnWidths.base}px`,
                          minWidth: `${moduleColumnWidths.base}px`,
                          overflow: "hidden",
                          textOverflow: "ellipsis",
                          whiteSpace: "nowrap",
                        }}
                      >
                        <Typography
                          variant="body2"
                          sx={{
                            fontSize: "11px",
                            overflow: "hidden",
                            textOverflow: "ellipsis",
                            whiteSpace: "nowrap",
                            display: "block",
                          }}
                          title={baseAddress}
                        >
                          {baseAddress}
                        </Typography>
                      </TableCell>
                      <TableCell
                        sx={{
                          fontSize: "11px",
                          width: `${moduleColumnWidths.size}px`,
                          minWidth: `${moduleColumnWidths.size}px`,
                          overflow: "hidden",
                          textOverflow: "ellipsis",
                          whiteSpace: "nowrap",
                        }}
                      >
                        <Typography
                          variant="body2"
                          sx={{
                            fontSize: "11px",
                            overflow: "hidden",
                            textOverflow: "ellipsis",
                            whiteSpace: "nowrap",
                            display: "block",
                          }}
                          title={formatFileSize(module.size)}
                        >
                          {formatFileSize(module.size)}
                        </Typography>
                      </TableCell>
                      <TableCell
                        sx={{
                          fontSize: "11px",
                          width: `${moduleColumnWidths.arch}px`,
                          minWidth: `${moduleColumnWidths.arch}px`,
                          overflow: "hidden",
                          textOverflow: "ellipsis",
                          whiteSpace: "nowrap",
                          textAlign: "center",
                        }}
                      >
                        <Typography
                          variant="body2"
                          sx={{
                            fontSize: "11px",
                            overflow: "hidden",
                            textOverflow: "ellipsis",
                            whiteSpace: "nowrap",
                            display: "block",
                            textAlign: "center",
                            color: "#ce9178",
                            fontWeight: 500,
                          }}
                          title={module.is_64bit ? "64-bit" : "32-bit"}
                        >
                          {module.is_64bit ? "64-bit" : "32-bit"}
                        </Typography>
                      </TableCell>
                      <TableCell
                        sx={{
                          fontSize: "11px",
                          width: `${moduleColumnWidths.path}px`,
                          minWidth: `${moduleColumnWidths.path}px`,
                          overflow: "hidden",
                          textOverflow: "ellipsis",
                          whiteSpace: "nowrap",
                        }}
                      >
                        <Typography
                          variant="body2"
                          sx={{
                            fontSize: "11px",
                            overflow: "hidden",
                            textOverflow: "ellipsis",
                            whiteSpace: "nowrap",
                            display: "block",
                          }}
                          title={module.path || moduleName}
                        >
                          {module.path || moduleName}
                        </Typography>
                      </TableCell>
                    </TableRow>
                  );
                })}
              </TableBody>
            </Table>
          </TableContainer>
          {/* Module Context Menu */}
          <Menu
            open={moduleContextMenu !== null}
            onClose={() => setModuleContextMenu(null)}
            anchorReference="anchorPosition"
            anchorPosition={
              moduleContextMenu !== null
                ? {
                    top: moduleContextMenu.mouseY,
                    left: moduleContextMenu.mouseX,
                  }
                : undefined
            }
            sx={{
              "& .MuiPaper-root": {
                backgroundColor: "#252526",
                border: "1px solid #3c3c3c",
                minWidth: "160px",
              },
            }}
          >
            <MenuItem
              onClick={() => {
                if (moduleContextMenu?.module) {
                  const name =
                    moduleContextMenu.module.modulename ||
                    moduleContextMenu.module.name ||
                    "";
                  const fileName = name.split("/").pop() || name;
                  navigator.clipboard.writeText(fileName);
                }
                setModuleContextMenu(null);
              }}
              sx={{ fontSize: "12px", py: 0.5 }}
            >
              <ListItemIcon sx={{ minWidth: "28px" }}>
                <ContentCopy sx={{ fontSize: 14 }} />
              </ListItemIcon>
              Copy Name
            </MenuItem>
            <MenuItem
              onClick={() => {
                if (moduleContextMenu?.module) {
                  const addr = `0x${moduleContextMenu.module.base.toString(16).toUpperCase()}`;
                  navigator.clipboard.writeText(addr);
                }
                setModuleContextMenu(null);
              }}
              sx={{ fontSize: "12px", py: 0.5 }}
            >
              <ListItemIcon sx={{ minWidth: "28px" }}>
                <ContentCopy sx={{ fontSize: 14 }} />
              </ListItemIcon>
              Copy Base Address
            </MenuItem>
            <MenuItem
              onClick={() => {
                if (moduleContextMenu?.module) {
                  const path =
                    moduleContextMenu.module.path ||
                    moduleContextMenu.module.modulename ||
                    moduleContextMenu.module.name ||
                    "";
                  navigator.clipboard.writeText(path);
                }
                setModuleContextMenu(null);
              }}
              sx={{ fontSize: "12px", py: 0.5 }}
            >
              <ListItemIcon sx={{ minWidth: "28px" }}>
                <ContentCopy sx={{ fontSize: 14 }} />
              </ListItemIcon>
              Copy Path
            </MenuItem>
          </Menu>
        </TabPanel>

        {/* Regions Tab */}
        <TabPanel value={internalTab} index={2}>
          <Box
            sx={{
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              mb: 2,
            }}
          >
            <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
              <Typography variant="h6" sx={{ fontSize: "14px" }}>
                Regions
              </Typography>
              {isLoadingRegions ? (
                <CircularProgress size={16} />
              ) : (
                <Chip
                  label={filteredRegions.length}
                  size="small"
                  sx={{ height: "20px", fontSize: "11px" }}
                />
              )}
              <Tooltip title="Refresh regions">
                <IconButton
                  size="small"
                  onClick={handleRefreshRegions}
                  disabled={isLoadingRegions}
                >
                  <RefreshIcon sx={{ fontSize: "16px" }} />
                </IconButton>
              </Tooltip>
            </Box>
            {/* Protection Filter */}
            <Box sx={{ display: "flex", alignItems: "center", gap: 0.5 }}>
              <Typography
                variant="caption"
                sx={{ color: "text.secondary", mr: 0.5 }}
              >
                Protection:
              </Typography>
              {(
                [
                  "readable",
                  "writable",
                  "executable",
                  ...(isIOS ? [] : ["private" as const]),
                ] as const
              ).map((perm) => {
                const label =
                  perm === "readable"
                    ? "R"
                    : perm === "writable"
                      ? "W"
                      : perm === "executable"
                        ? "X"
                        : "P";
                const value = regionProtectionFilter[perm];
                const color =
                  value === true
                    ? "#4caf50"
                    : value === false
                      ? "#f44336"
                      : "text.secondary";
                return (
                  <Tooltip
                    key={perm}
                    title={`${label}: ${value === null ? "Any" : value ? "Yes" : "No"} (Click to toggle)`}
                  >
                    <Chip
                      label={label}
                      size="small"
                      onClick={() => {
                        // Cycle: null -> true -> false -> null
                        const newValue =
                          value === null ? true : value === true ? false : null;
                        uiActions.setRegionProtectionFilter({
                          ...regionProtectionFilter,
                          [perm]: newValue,
                        });
                      }}
                      sx={{
                        height: "22px",
                        fontSize: "11px",
                        fontWeight: 600,
                        minWidth: "28px",
                        cursor: "pointer",
                        backgroundColor:
                          value === null
                            ? "transparent"
                            : value
                              ? "rgba(76, 175, 80, 0.15)"
                              : "rgba(244, 67, 54, 0.15)",
                        color: color,
                        border: "1px solid",
                        borderColor:
                          value === null ? "rgba(255,255,255,0.23)" : color,
                        "&:hover": {
                          backgroundColor:
                            value === null
                              ? "rgba(255,255,255,0.08)"
                              : value
                                ? "rgba(76, 175, 80, 0.25)"
                                : "rgba(244, 67, 54, 0.25)",
                        },
                      }}
                    />
                  </Tooltip>
                );
              })}
              {/* File Path Filter */}
              <TextField
                size="small"
                placeholder="Filter by file path..."
                value={regionFilter}
                onChange={(e) =>
                  uiActions.setInformationRegionFilter(e.target.value)
                }
                InputProps={{
                  startAdornment: (
                    <InputAdornment position="start">
                      <Search sx={{ fontSize: "16px" }} />
                    </InputAdornment>
                  ),
                }}
                sx={{
                  width: "200px",
                  ml: 2,
                  "& .MuiOutlinedInput-root": {
                    fontSize: "12px",
                  },
                }}
              />
            </Box>
          </Box>
          {isLoadingRegions ? (
            <Box sx={{ display: "flex", justifyContent: "center", py: 4 }}>
              <CircularProgress />
            </Box>
          ) : filteredRegions.length === 0 ? (
            <Box
              sx={{
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                justifyContent: "center",
                py: 4,
                color: "text.secondary",
              }}
            >
              <Memory sx={{ fontSize: 48, mb: 1, opacity: 0.5 }} />
              <Typography variant="body2">No memory regions found</Typography>
            </Box>
          ) : (
            <Paper
              sx={{
                height: "calc(100vh - 280px)",
                overflow: "hidden",
                "&::-webkit-scrollbar": {
                  width: "10px",
                  height: "10px",
                },
                "&::-webkit-scrollbar-track": {
                  background: "#1e1e1e",
                },
                "&::-webkit-scrollbar-thumb": {
                  background: "#3e3e42",
                  borderRadius: "4px",
                  "&:hover": {
                    background: "#5a5a5e",
                  },
                },
                "&::-webkit-scrollbar-corner": {
                  background: "#1e1e1e",
                },
              }}
            >
              {/* Virtualized Table Header */}
              <Box
                sx={{
                  display: "flex",
                  alignItems: "center",
                  borderBottom: "1px solid",
                  borderColor: "divider",
                  backgroundColor: "background.paper",
                  position: "sticky",
                  top: 0,
                  zIndex: 1,
                }}
              >
                <Box
                  sx={{
                    width: `${regionColumnWidths.start}px`,
                    minWidth: `${regionColumnWidths.start}px`,
                    px: 1,
                    py: 1,
                    fontSize: "11px",
                    fontWeight: 600,
                    position: "relative",
                  }}
                >
                  <TableSortLabel
                    active={regionSortField === "start"}
                    direction={
                      regionSortField === "start" ? regionSortDirection : "asc"
                    }
                    onClick={() => {
                      const isAsc =
                        regionSortField === "start" &&
                        regionSortDirection === "asc";
                      setRegionSortDirection(isAsc ? "desc" : "asc");
                      setRegionSortField("start");
                    }}
                    sx={{
                      fontSize: "11px",
                      "& .MuiTableSortLabel-icon": {
                        opacity: regionSortField === "start" ? 1 : 0,
                      },
                      "&:hover .MuiTableSortLabel-icon": {
                        opacity: 0.5,
                      },
                      "&.Mui-active .MuiTableSortLabel-icon": {
                        opacity: 1,
                      },
                    }}
                  >
                    Start Address
                  </TableSortLabel>
                  <ColumnResizer
                    onMouseDown={handleRegionColumnResizeStart("start")}
                    isResizing={resizingTable === "region"}
                  />
                </Box>
                <Box
                  sx={{
                    width: `${regionColumnWidths.end}px`,
                    minWidth: `${regionColumnWidths.end}px`,
                    px: 1,
                    py: 1,
                    fontSize: "11px",
                    fontWeight: 600,
                    position: "relative",
                  }}
                >
                  <TableSortLabel
                    active={regionSortField === "end"}
                    direction={
                      regionSortField === "end" ? regionSortDirection : "asc"
                    }
                    onClick={() => {
                      const isAsc =
                        regionSortField === "end" &&
                        regionSortDirection === "asc";
                      setRegionSortDirection(isAsc ? "desc" : "asc");
                      setRegionSortField("end");
                    }}
                    sx={{
                      fontSize: "11px",
                      "& .MuiTableSortLabel-icon": {
                        opacity: regionSortField === "end" ? 1 : 0,
                      },
                      "&:hover .MuiTableSortLabel-icon": {
                        opacity: 0.5,
                      },
                      "&.Mui-active .MuiTableSortLabel-icon": {
                        opacity: 1,
                      },
                    }}
                  >
                    End Address
                  </TableSortLabel>
                  <ColumnResizer
                    onMouseDown={handleRegionColumnResizeStart("end")}
                    isResizing={resizingTable === "region"}
                  />
                </Box>
                <Box
                  sx={{
                    width: `${regionColumnWidths.size}px`,
                    minWidth: `${regionColumnWidths.size}px`,
                    px: 1,
                    py: 1,
                    fontSize: "11px",
                    fontWeight: 600,
                    position: "relative",
                  }}
                >
                  <TableSortLabel
                    active={regionSortField === "size"}
                    direction={
                      regionSortField === "size" ? regionSortDirection : "asc"
                    }
                    onClick={() => {
                      const isAsc =
                        regionSortField === "size" &&
                        regionSortDirection === "asc";
                      setRegionSortDirection(isAsc ? "desc" : "asc");
                      setRegionSortField("size");
                    }}
                    sx={{
                      fontSize: "11px",
                      "& .MuiTableSortLabel-icon": {
                        opacity: regionSortField === "size" ? 1 : 0,
                      },
                      "&:hover .MuiTableSortLabel-icon": {
                        opacity: 0.5,
                      },
                      "&.Mui-active .MuiTableSortLabel-icon": {
                        opacity: 1,
                      },
                    }}
                  >
                    Size
                  </TableSortLabel>
                  <ColumnResizer
                    onMouseDown={handleRegionColumnResizeStart("size")}
                    isResizing={resizingTable === "region"}
                  />
                </Box>
                <Box
                  sx={{
                    width: `${regionColumnWidths.protection}px`,
                    minWidth: `${regionColumnWidths.protection}px`,
                    px: 1,
                    py: 1,
                    fontSize: "11px",
                    fontWeight: 600,
                    textAlign: "center",
                    position: "relative",
                  }}
                >
                  Protection
                  <ColumnResizer
                    onMouseDown={handleRegionColumnResizeStart("protection")}
                    isResizing={resizingTable === "region"}
                  />
                </Box>
                <Box
                  sx={{
                    width: `${regionColumnWidths.path}px`,
                    minWidth: `${regionColumnWidths.path}px`,
                    flex: 1,
                    px: 1,
                    py: 1,
                    fontSize: "11px",
                    fontWeight: 600,
                  }}
                >
                  <TableSortLabel
                    active={regionSortField === "path"}
                    direction={
                      regionSortField === "path" ? regionSortDirection : "asc"
                    }
                    onClick={() => {
                      const isAsc =
                        regionSortField === "path" &&
                        regionSortDirection === "asc";
                      setRegionSortDirection(isAsc ? "desc" : "asc");
                      setRegionSortField("path");
                    }}
                    sx={{
                      fontSize: "11px",
                      "& .MuiTableSortLabel-icon": {
                        opacity: regionSortField === "path" ? 1 : 0,
                      },
                      "&:hover .MuiTableSortLabel-icon": {
                        opacity: 0.5,
                      },
                      "&.Mui-active .MuiTableSortLabel-icon": {
                        opacity: 1,
                      },
                    }}
                  >
                    File Path
                  </TableSortLabel>
                </Box>
              </Box>
              {/* Virtualized List Body */}
              <List
                style={{
                  height: Math.min(
                    filteredRegions.length * REGION_ROW_HEIGHT,
                    window.innerHeight - 350
                  ),
                }}
                rowCount={filteredRegions.length}
                rowHeight={REGION_ROW_HEIGHT}
                rowProps={{
                  data: {
                    regions: filteredRegions,
                    formatFileSize,
                    onContextMenu: (
                      e: React.MouseEvent,
                      region: RegionInfo
                    ) => {
                      e.preventDefault();
                      setRegionContextMenu({
                        mouseX: e.clientX + 2,
                        mouseY: e.clientY - 6,
                        region,
                      });
                    },
                    columnWidths: regionColumnWidths,
                  },
                }}
                rowComponent={RegionRow as any}
              />
            </Paper>
          )}
          {/* Region Context Menu */}
          <Menu
            open={regionContextMenu !== null}
            onClose={() => setRegionContextMenu(null)}
            anchorReference="anchorPosition"
            anchorPosition={
              regionContextMenu !== null
                ? {
                    top: regionContextMenu.mouseY,
                    left: regionContextMenu.mouseX,
                  }
                : undefined
            }
            sx={{
              "& .MuiPaper-root": {
                backgroundColor: "#252526",
                border: "1px solid #3c3c3c",
                minWidth: "160px",
              },
            }}
          >
            <MenuItem
              onClick={() => {
                if (regionContextMenu?.region) {
                  navigator.clipboard.writeText(
                    `0x${regionContextMenu.region.start_address}`
                  );
                }
                setRegionContextMenu(null);
              }}
              sx={{ fontSize: "12px", py: 0.5 }}
            >
              <ListItemIcon sx={{ minWidth: "28px" }}>
                <ContentCopy sx={{ fontSize: 14 }} />
              </ListItemIcon>
              Copy Start Address
            </MenuItem>
            <MenuItem
              onClick={() => {
                if (regionContextMenu?.region) {
                  navigator.clipboard.writeText(
                    `0x${regionContextMenu.region.end_address}`
                  );
                }
                setRegionContextMenu(null);
              }}
              sx={{ fontSize: "12px", py: 0.5 }}
            >
              <ListItemIcon sx={{ minWidth: "28px" }}>
                <ContentCopy sx={{ fontSize: 14 }} />
              </ListItemIcon>
              Copy End Address
            </MenuItem>
            <MenuItem
              onClick={() => {
                if (regionContextMenu?.region) {
                  navigator.clipboard.writeText(
                    regionContextMenu.region.file_path || ""
                  );
                }
                setRegionContextMenu(null);
              }}
              sx={{ fontSize: "12px", py: 0.5 }}
            >
              <ListItemIcon sx={{ minWidth: "28px" }}>
                <ContentCopy sx={{ fontSize: 14 }} />
              </ListItemIcon>
              Copy File Path
            </MenuItem>
          </Menu>
        </TabPanel>

        {/* Threads Tab */}
        <TabPanel value={internalTab} index={3}>
          <Box
            sx={{
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              mb: 2,
            }}
          >
            <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
              <Typography variant="h6" sx={{ fontSize: "14px" }}>
                Threads
              </Typography>
              {isLoadingThreads ? (
                <CircularProgress size={16} />
              ) : (
                <Chip
                  label={threads.length}
                  size="small"
                  sx={{ height: "20px", fontSize: "11px" }}
                />
              )}
              <Tooltip title="Refresh threads">
                <IconButton
                  size="small"
                  onClick={handleRefreshThreads}
                  disabled={isLoadingThreads}
                >
                  <RefreshIcon sx={{ fontSize: "16px" }} />
                </IconButton>
              </Tooltip>
            </Box>
            <TextField
              size="small"
              placeholder="Filter threads..."
              value={threadFilter}
              onChange={(e) =>
                uiActions.setInformationThreadFilter(e.target.value)
              }
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <Search sx={{ fontSize: "16px" }} />
                  </InputAdornment>
                ),
              }}
              sx={{
                width: "250px",
                "& .MuiOutlinedInput-root": {
                  fontSize: "12px",
                },
              }}
            />
          </Box>

          {isLoadingThreads ? (
            <Box sx={{ display: "flex", justifyContent: "center", p: 4 }}>
              <CircularProgress />
            </Box>
          ) : filteredThreads.length === 0 ? (
            <Box sx={{ textAlign: "center", p: 4, color: "text.secondary" }}>
              <Typography variant="body2">
                {threads.length === 0
                  ? "No threads found"
                  : "No threads match the filter"}
              </Typography>
            </Box>
          ) : (
            <TableContainer
              component={Paper}
              sx={{
                maxHeight: "calc(100vh - 200px)",
                "&::-webkit-scrollbar": {
                  width: "10px",
                  height: "10px",
                },
                "&::-webkit-scrollbar-track": {
                  background: "#1e1e1e",
                },
                "&::-webkit-scrollbar-thumb": {
                  background: "#3e3e42",
                  borderRadius: "4px",
                  "&:hover": {
                    background: "#5a5a5e",
                  },
                },
                "&::-webkit-scrollbar-corner": {
                  background: "#1e1e1e",
                },
              }}
            >
              <Table stickyHeader size="small">
                <TableHead>
                  <TableRow>
                    <TableCell
                      sx={{
                        fontSize: "11px",
                        fontWeight: 600,
                        width: `${threadColumnWidths.id}px`,
                        minWidth: `${threadColumnWidths.id}px`,
                        position: "relative",
                      }}
                    >
                      <TableSortLabel
                        active={threadSortField === "id"}
                        direction={
                          threadSortField === "id" ? threadSortDirection : "asc"
                        }
                        onClick={() => {
                          const isAsc =
                            threadSortField === "id" &&
                            threadSortDirection === "asc";
                          setThreadSortDirection(isAsc ? "desc" : "asc");
                          setThreadSortField("id");
                        }}
                        sx={{
                          fontSize: "11px",
                          "& .MuiTableSortLabel-icon": {
                            opacity: threadSortField === "id" ? 1 : 0,
                          },
                          "&:hover .MuiTableSortLabel-icon": {
                            opacity: 0.5,
                          },
                          "&.Mui-active .MuiTableSortLabel-icon": {
                            opacity: 1,
                          },
                        }}
                      >
                        Thread ID
                      </TableSortLabel>
                      <ColumnResizer
                        onMouseDown={handleThreadColumnResizeStart("id")}
                        isResizing={resizingTable === "thread"}
                      />
                    </TableCell>
                    <TableCell
                      sx={{
                        fontSize: "11px",
                        fontWeight: 600,
                        width: `${threadColumnWidths.name}px`,
                        minWidth: `${threadColumnWidths.name}px`,
                        position: "relative",
                      }}
                    >
                      <TableSortLabel
                        active={threadSortField === "name"}
                        direction={
                          threadSortField === "name"
                            ? threadSortDirection
                            : "asc"
                        }
                        onClick={() => {
                          const isAsc =
                            threadSortField === "name" &&
                            threadSortDirection === "asc";
                          setThreadSortDirection(isAsc ? "desc" : "asc");
                          setThreadSortField("name");
                        }}
                        sx={{
                          fontSize: "11px",
                          "& .MuiTableSortLabel-icon": {
                            opacity: threadSortField === "name" ? 1 : 0,
                          },
                          "&:hover .MuiTableSortLabel-icon": {
                            opacity: 0.5,
                          },
                          "&.Mui-active .MuiTableSortLabel-icon": {
                            opacity: 1,
                          },
                        }}
                      >
                        Name
                      </TableSortLabel>
                      <ColumnResizer
                        onMouseDown={handleThreadColumnResizeStart("name")}
                        isResizing={resizingTable === "thread"}
                      />
                    </TableCell>
                    <TableCell
                      sx={{
                        fontSize: "11px",
                        fontWeight: 600,
                        width: `${threadColumnWidths.address}px`,
                        minWidth: `${threadColumnWidths.address}px`,
                        position: "relative",
                      }}
                    >
                      Address
                      <ColumnResizer
                        onMouseDown={handleThreadColumnResizeStart("address")}
                        isResizing={resizingTable === "thread"}
                      />
                    </TableCell>
                    <TableCell
                      sx={{
                        fontSize: "11px",
                        fontWeight: 600,
                        width: `${threadColumnWidths.detail}px`,
                        minWidth: `${threadColumnWidths.detail}px`,
                        position: "relative",
                      }}
                    >
                      Detail
                      <ColumnResizer
                        onMouseDown={handleThreadColumnResizeStart("detail")}
                        isResizing={resizingTable === "thread"}
                      />
                    </TableCell>
                    <TableCell
                      sx={{
                        fontSize: "11px",
                        fontWeight: 600,
                        width: `${threadColumnWidths.state}px`,
                        minWidth: `${threadColumnWidths.state}px`,
                      }}
                    >
                      State
                    </TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {filteredThreads.map((thread) => (
                    <TableRow
                      key={thread.thread_id}
                      hover
                      onContextMenu={(e) => {
                        e.preventDefault();
                        setThreadContextMenu({
                          mouseX: e.clientX + 2,
                          mouseY: e.clientY - 6,
                          thread: {
                            thread_id: thread.thread_id,
                            name: thread.name,
                          },
                        });
                      }}
                      sx={{ cursor: "default" }}
                    >
                      <TableCell
                        sx={{
                          fontSize: "11px",
                          fontFamily: "monospace",
                          color: "#ce9178",
                          width: `${threadColumnWidths.id}px`,
                          minWidth: `${threadColumnWidths.id}px`,
                        }}
                      >
                        {thread.thread_id}
                      </TableCell>
                      <TableCell
                        sx={{
                          fontSize: "11px",
                          fontFamily: "monospace",
                          width: `${threadColumnWidths.name}px`,
                          minWidth: `${threadColumnWidths.name}px`,
                          maxWidth: `${threadColumnWidths.name}px`,
                          overflow: "hidden",
                          textOverflow: "ellipsis",
                          whiteSpace: "nowrap",
                        }}
                        title={thread.name}
                      >
                        {thread.name || "(unnamed)"}
                      </TableCell>
                      <TableCell
                        sx={{
                          fontSize: "11px",
                          fontFamily: "monospace",
                          color: "#4fc1ff",
                          width: `${threadColumnWidths.address}px`,
                          minWidth: `${threadColumnWidths.address}px`,
                        }}
                      >
                        {thread.pc === "0x0" || thread.pc === "0"
                          ? "?"
                          : thread.pc}
                      </TableCell>
                      <TableCell
                        sx={{
                          fontSize: "11px",
                          fontFamily: "monospace",
                          color: "#4ec9b0",
                          width: `${threadColumnWidths.detail}px`,
                          minWidth: `${threadColumnWidths.detail}px`,
                        }}
                      >
                        {(() => {
                          const pcValue = parseInt(
                            thread.pc.replace("0x", ""),
                            16
                          );
                          if (
                            pcValue === 0 ||
                            isNaN(pcValue) ||
                            !attachedModules ||
                            attachedModules.length === 0
                          ) {
                            return "-";
                          }
                          const detail = encodeAddressToLibraryExpression(
                            pcValue,
                            attachedModules,
                            true
                          );
                          return detail || "-";
                        })()}
                      </TableCell>
                      <TableCell
                        sx={{
                          fontSize: "11px",
                          width: `${threadColumnWidths.state}px`,
                          minWidth: `${threadColumnWidths.state}px`,
                        }}
                      >
                        <Chip
                          label={thread.state}
                          size="small"
                          variant="outlined"
                          sx={{
                            height: "18px",
                            fontSize: "9px",
                            borderColor: getStateColor(thread.state),
                            color: getStateColor(thread.state),
                          }}
                        />
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>
          )}
          {/* Thread Context Menu */}
          <Menu
            open={threadContextMenu !== null}
            onClose={() => setThreadContextMenu(null)}
            anchorReference="anchorPosition"
            anchorPosition={
              threadContextMenu !== null
                ? {
                    top: threadContextMenu.mouseY,
                    left: threadContextMenu.mouseX,
                  }
                : undefined
            }
            sx={{
              "& .MuiPaper-root": {
                backgroundColor: "#252526",
                border: "1px solid #3c3c3c",
                minWidth: "160px",
              },
            }}
          >
            <MenuItem
              onClick={() => {
                if (threadContextMenu?.thread) {
                  navigator.clipboard.writeText(
                    threadContextMenu.thread.thread_id.toString()
                  );
                }
                setThreadContextMenu(null);
              }}
              sx={{ fontSize: "12px", py: 0.5 }}
            >
              <ListItemIcon sx={{ minWidth: "28px" }}>
                <ContentCopy sx={{ fontSize: 14 }} />
              </ListItemIcon>
              Copy Thread ID
            </MenuItem>
            <MenuItem
              onClick={() => {
                if (threadContextMenu?.thread) {
                  navigator.clipboard.writeText(
                    threadContextMenu.thread.name || ""
                  );
                }
                setThreadContextMenu(null);
              }}
              sx={{ fontSize: "12px", py: 0.5 }}
            >
              <ListItemIcon sx={{ minWidth: "28px" }}>
                <ContentCopy sx={{ fontSize: 14 }} />
              </ListItemIcon>
              Copy Name
            </MenuItem>
          </Menu>
        </TabPanel>

        {/* Network Tab */}
        <TabPanel value={internalTab} index={4}>
          <Box
            sx={{
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              mb: 2,
            }}
          >
            <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
              <Typography variant="h6" sx={{ fontSize: "14px" }}>
                Network Connections
              </Typography>
              {isLoadingNetwork ? (
                <CircularProgress size={16} />
              ) : (
                <Chip
                  label={networkConnections.length}
                  size="small"
                  sx={{ height: "20px", fontSize: "11px" }}
                />
              )}
              <Tooltip title="Refresh network connections">
                <IconButton
                  size="small"
                  onClick={handleRefreshNetwork}
                  disabled={isLoadingNetwork}
                >
                  <RefreshIcon sx={{ fontSize: "16px" }} />
                </IconButton>
              </Tooltip>
            </Box>
            <TextField
              size="small"
              placeholder="Filter connections..."
              value={networkFilter}
              onChange={(e) => uiActions.setNetworkFilter(e.target.value)}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <Search sx={{ fontSize: "16px" }} />
                  </InputAdornment>
                ),
              }}
              sx={{
                width: "250px",
                "& .MuiOutlinedInput-root": {
                  fontSize: "12px",
                },
              }}
            />
          </Box>

          {isLoadingNetwork ? (
            <Box sx={{ display: "flex", justifyContent: "center", p: 4 }}>
              <CircularProgress />
            </Box>
          ) : networkConnections.length === 0 ? (
            <Box sx={{ textAlign: "center", p: 4, color: "text.secondary" }}>
              <Typography variant="body2">
                No network connections found
              </Typography>
              <Typography
                variant="caption"
                sx={{ color: "text.disabled", mt: 1, display: "block" }}
              >
                Note: This feature is only supported on Linux targets
              </Typography>
            </Box>
          ) : (
            <TableContainer
              component={Paper}
              sx={{
                maxHeight: "calc(100vh - 200px)",
                "&::-webkit-scrollbar": {
                  width: "10px",
                  height: "10px",
                },
                "&::-webkit-scrollbar-track": {
                  background: "#1e1e1e",
                },
                "&::-webkit-scrollbar-thumb": {
                  background: "#3e3e42",
                  borderRadius: "4px",
                  "&:hover": {
                    background: "#5a5a5e",
                  },
                },
              }}
            >
              <Table stickyHeader size="small">
                <TableHead>
                  <TableRow>
                    <TableCell
                      sx={{ fontSize: "11px", fontWeight: 600, width: "80px" }}
                    >
                      Protocol
                    </TableCell>
                    <TableCell
                      sx={{ fontSize: "11px", fontWeight: 600, width: "180px" }}
                    >
                      Local Address
                    </TableCell>
                    <TableCell
                      sx={{ fontSize: "11px", fontWeight: 600, width: "80px" }}
                    >
                      Local Port
                    </TableCell>
                    <TableCell
                      sx={{ fontSize: "11px", fontWeight: 600, width: "180px" }}
                    >
                      Remote Address
                    </TableCell>
                    <TableCell
                      sx={{ fontSize: "11px", fontWeight: 600, width: "80px" }}
                    >
                      Remote Port
                    </TableCell>
                    <TableCell
                      sx={{ fontSize: "11px", fontWeight: 600, width: "120px" }}
                    >
                      State
                    </TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {networkConnections
                    .filter((conn) => {
                      if (!networkFilter) return true;
                      const filter = networkFilter.toLowerCase();
                      return (
                        conn.protocol.toLowerCase().includes(filter) ||
                        conn.local_address.toLowerCase().includes(filter) ||
                        conn.remote_address.toLowerCase().includes(filter) ||
                        conn.state.toLowerCase().includes(filter) ||
                        conn.local_port.toString().includes(filter) ||
                        conn.remote_port.toString().includes(filter)
                      );
                    })
                    .map((conn, index) => (
                      <TableRow
                        key={`${conn.protocol}-${conn.local_port}-${index}`}
                        hover
                      >
                        <TableCell
                          sx={{ fontSize: "11px", fontFamily: "monospace" }}
                        >
                          <Chip
                            label={conn.protocol}
                            size="small"
                            sx={{
                              height: "18px",
                              fontSize: "9px",
                              backgroundColor: conn.protocol.startsWith("TCP")
                                ? "#1e3a5f"
                                : "#3d2f1f",
                              color: conn.protocol.startsWith("TCP")
                                ? "#4fc1ff"
                                : "#daa520",
                            }}
                          />
                        </TableCell>
                        <TableCell
                          sx={{
                            fontSize: "11px",
                            fontFamily: "monospace",
                            color: "#4fc1ff",
                          }}
                        >
                          {conn.local_address}
                        </TableCell>
                        <TableCell
                          sx={{
                            fontSize: "11px",
                            fontFamily: "monospace",
                            color: "#ce9178",
                          }}
                        >
                          {conn.local_port}
                        </TableCell>
                        <TableCell
                          sx={{
                            fontSize: "11px",
                            fontFamily: "monospace",
                            color: "#4ec9b0",
                          }}
                        >
                          {conn.remote_address === "0.0.0.0" ||
                          conn.remote_address === "::"
                            ? "-"
                            : conn.remote_address}
                        </TableCell>
                        <TableCell
                          sx={{
                            fontSize: "11px",
                            fontFamily: "monospace",
                            color: "#ce9178",
                          }}
                        >
                          {conn.remote_port === 0 ? "-" : conn.remote_port}
                        </TableCell>
                        <TableCell sx={{ fontSize: "11px" }}>
                          <Chip
                            label={conn.state}
                            size="small"
                            variant="outlined"
                            sx={{
                              height: "18px",
                              fontSize: "9px",
                              borderColor:
                                conn.state === "LISTEN"
                                  ? "#4caf50"
                                  : conn.state === "ESTABLISHED"
                                    ? "#2196f3"
                                    : conn.state === "TIME_WAIT"
                                      ? "#ff9800"
                                      : conn.state === "CLOSE_WAIT"
                                        ? "#f44336"
                                        : "#9e9e9e",
                              color:
                                conn.state === "LISTEN"
                                  ? "#4caf50"
                                  : conn.state === "ESTABLISHED"
                                    ? "#2196f3"
                                    : conn.state === "TIME_WAIT"
                                      ? "#ff9800"
                                      : conn.state === "CLOSE_WAIT"
                                        ? "#f44336"
                                        : "#9e9e9e",
                            }}
                          />
                        </TableCell>
                      </TableRow>
                    ))}
                </TableBody>
              </Table>
            </TableContainer>
          )}
        </TabPanel>

        {/* Symbols Tab */}
        <TabPanel value={internalTab} index={1}>
          <Box
            sx={{
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              mb: 2,
            }}
          >
            <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
              <Typography variant="h6" sx={{ fontSize: "14px" }}>
                Symbols
              </Typography>
              <Autocomplete
                size="small"
                options={attachedModules}
                value={selectedModuleForSymbols}
                onChange={handleModuleSelectForSymbols}
                getOptionLabel={(option) => {
                  const moduleName =
                    option.modulename || option.name || "Unknown";
                  return moduleName.split(/[\/\\]/).pop() || moduleName;
                }}
                isOptionEqualToValue={(option, value) =>
                  option.base === value.base
                }
                renderInput={(params) => (
                  <TextField
                    {...params}
                    placeholder="Select Module..."
                    sx={{
                      "& .MuiOutlinedInput-root": {
                        fontSize: "12px",
                      },
                    }}
                  />
                )}
                renderOption={(props, option) => {
                  const moduleName =
                    option.modulename || option.name || "Unknown";
                  const fileName =
                    moduleName.split(/[\/\\]/).pop() || moduleName;
                  return (
                    <li
                      {...props}
                      key={option.base}
                      style={{ fontSize: "12px" }}
                    >
                      {fileName}
                    </li>
                  );
                }}
                sx={{ width: 300 }}
              />
              {isLoadingSymbols ? (
                <CircularProgress size={16} />
              ) : selectedModuleForSymbols ? (
                <>
                  <Chip
                    label={filteredSymbols.length}
                    size="small"
                    sx={{ height: "20px", fontSize: "11px" }}
                  />
                  {isDemanglingInProgress && (
                    <Tooltip title="Demangling symbols...">
                      <CircularProgress size={12} sx={{ ml: 0.5 }} />
                    </Tooltip>
                  )}
                </>
              ) : null}
            </Box>
            <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
              {/* Type Filter */}
              <FormControl size="small" sx={{ minWidth: 100 }}>
                <Select
                  value={symbolTypeFilter}
                  onChange={(e) =>
                    uiActions.setSymbolTypeFilter(e.target.value)
                  }
                  displayEmpty
                  sx={{
                    fontSize: "12px",
                    "& .MuiSelect-select": { py: 0.5 },
                  }}
                >
                  <MenuItem value="all" sx={{ fontSize: "12px" }}>
                    All Types
                  </MenuItem>
                  {symbolTypes.map((type) => (
                    <MenuItem key={type} value={type} sx={{ fontSize: "12px" }}>
                      {type}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
              {/* Scope Filter */}
              <FormControl size="small" sx={{ minWidth: 90 }}>
                <Select
                  value={symbolScopeFilter}
                  onChange={(e) =>
                    uiActions.setSymbolScopeFilter(e.target.value)
                  }
                  displayEmpty
                  sx={{
                    fontSize: "12px",
                    "& .MuiSelect-select": { py: 0.5 },
                  }}
                >
                  <MenuItem value="all" sx={{ fontSize: "12px" }}>
                    All Scopes
                  </MenuItem>
                  {symbolScopes.map((scope) => (
                    <MenuItem
                      key={scope}
                      value={scope}
                      sx={{ fontSize: "12px" }}
                    >
                      {scope}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
              {/* Demangle Toggle */}
              <Tooltip
                title={
                  symbolDemangleEnabled ? "Disable demangle" : "Enable demangle"
                }
              >
                <ToggleButton
                  value="demangle"
                  selected={symbolDemangleEnabled}
                  onChange={() =>
                    uiActions.setSymbolDemangleEnabled(!symbolDemangleEnabled)
                  }
                  size="small"
                  sx={{
                    px: 1,
                    py: 0.5,
                    fontSize: "11px",
                    textTransform: "none",
                    borderColor: symbolDemangleEnabled ? "#4caf50" : "divider",
                    color: symbolDemangleEnabled ? "#4caf50" : "text.secondary",
                    backgroundColor: symbolDemangleEnabled
                      ? "rgba(76, 175, 80, 0.1)"
                      : "transparent",
                    "&.Mui-selected": {
                      backgroundColor: "rgba(76, 175, 80, 0.15)",
                      color: "#4caf50",
                      borderColor: "#4caf50",
                      "&:hover": {
                        backgroundColor: "rgba(76, 175, 80, 0.2)",
                      },
                    },
                    "&:hover": {
                      backgroundColor: symbolDemangleEnabled
                        ? "rgba(76, 175, 80, 0.2)"
                        : "rgba(255, 255, 255, 0.05)",
                    },
                  }}
                >
                  <Code sx={{ fontSize: "14px", mr: 0.5 }} />
                  Demangle
                </ToggleButton>
              </Tooltip>
              {/* Symbol Filter */}
              <TextField
                size="small"
                placeholder="Filter symbols..."
                value={symbolFilter}
                onChange={(e) => uiActions.setSymbolFilter(e.target.value)}
                InputProps={{
                  startAdornment: (
                    <InputAdornment position="start">
                      <Search sx={{ fontSize: "16px" }} />
                    </InputAdornment>
                  ),
                }}
                sx={{
                  width: "200px",
                  "& .MuiOutlinedInput-root": {
                    fontSize: "12px",
                  },
                }}
              />
            </Box>
          </Box>

          {!selectedModuleForSymbols ? (
            <Box
              sx={{
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                justifyContent: "center",
                py: 4,
                color: "text.secondary",
              }}
            >
              <Functions sx={{ fontSize: 48, mb: 1, opacity: 0.5 }} />
              <Typography variant="body2">
                Select a module to view its symbols
              </Typography>
            </Box>
          ) : isLoadingSymbols ? (
            <Box sx={{ display: "flex", justifyContent: "center", p: 4 }}>
              <CircularProgress />
            </Box>
          ) : filteredSymbols.length === 0 ? (
            <Box sx={{ textAlign: "center", p: 4, color: "text.secondary" }}>
              <Typography variant="body2">
                {symbols.length === 0
                  ? "No symbols found in this module"
                  : "No symbols match the filter"}
              </Typography>
            </Box>
          ) : (
            <Paper
              sx={{
                height: "calc(100vh - 280px)",
                overflow: "hidden",
                "&::-webkit-scrollbar": {
                  width: "10px",
                  height: "10px",
                },
                "&::-webkit-scrollbar-track": {
                  background: "#1e1e1e",
                },
                "&::-webkit-scrollbar-thumb": {
                  background: "#3e3e42",
                  borderRadius: "4px",
                  "&:hover": {
                    background: "#5a5a5e",
                  },
                },
                "&::-webkit-scrollbar-corner": {
                  background: "#1e1e1e",
                },
              }}
            >
              {/* Virtualized Table Header */}
              <Box
                sx={{
                  display: "flex",
                  alignItems: "center",
                  borderBottom: "1px solid",
                  borderColor: "divider",
                  backgroundColor: "background.paper",
                  position: "sticky",
                  top: 0,
                  zIndex: 1,
                }}
              >
                {/* Name Column Header */}
                <Box
                  sx={{
                    width: `${symbolColumnWidths.name}px`,
                    minWidth: `${symbolColumnWidths.name}px`,
                    px: 1,
                    py: 0.5,
                    fontSize: "11px",
                    fontWeight: 600,
                    cursor: "pointer",
                    display: "flex",
                    alignItems: "center",
                    position: "relative",
                  }}
                  onClick={() => {
                    if (symbolSortField === "name") {
                      uiActions.setSymbolSortDirection(
                        symbolSortDirection === "asc" ? "desc" : "asc"
                      );
                    } else {
                      uiActions.setSymbolSortField("name");
                      uiActions.setSymbolSortDirection("asc");
                    }
                  }}
                >
                  <TableSortLabel
                    active={symbolSortField === "name"}
                    direction={
                      symbolSortField === "name" ? symbolSortDirection : "asc"
                    }
                    sx={{
                      fontSize: "11px",
                      "& .MuiTableSortLabel-icon": {
                        opacity: symbolSortField === "name" ? 1 : 0,
                      },
                      "&:hover .MuiTableSortLabel-icon": {
                        opacity: 0.5,
                      },
                      "&.Mui-active .MuiTableSortLabel-icon": {
                        opacity: 1,
                      },
                    }}
                  >
                    Name
                  </TableSortLabel>
                  <ColumnResizer
                    onMouseDown={handleSymbolColumnResizeStart("name")}
                    isResizing={resizingColumn === "name"}
                  />
                </Box>
                {/* Address Column Header */}
                <Box
                  sx={{
                    width: `${symbolColumnWidths.address}px`,
                    minWidth: `${symbolColumnWidths.address}px`,
                    px: 1,
                    py: 0.5,
                    fontSize: "11px",
                    fontWeight: 600,
                    cursor: "pointer",
                    display: "flex",
                    alignItems: "center",
                    position: "relative",
                  }}
                  onClick={() => {
                    if (symbolSortField === "address") {
                      uiActions.setSymbolSortDirection(
                        symbolSortDirection === "asc" ? "desc" : "asc"
                      );
                    } else {
                      uiActions.setSymbolSortField("address");
                      uiActions.setSymbolSortDirection("asc");
                    }
                  }}
                >
                  <TableSortLabel
                    active={symbolSortField === "address"}
                    direction={
                      symbolSortField === "address"
                        ? symbolSortDirection
                        : "asc"
                    }
                    sx={{
                      fontSize: "11px",
                      "& .MuiTableSortLabel-icon": {
                        opacity: symbolSortField === "address" ? 1 : 0,
                      },
                      "&:hover .MuiTableSortLabel-icon": {
                        opacity: 0.5,
                      },
                      "&.Mui-active .MuiTableSortLabel-icon": {
                        opacity: 1,
                      },
                    }}
                  >
                    Address
                  </TableSortLabel>
                  <ColumnResizer
                    onMouseDown={handleSymbolColumnResizeStart("address")}
                    isResizing={resizingColumn === "address"}
                  />
                </Box>
                {/* Size Column Header */}
                <Box
                  sx={{
                    width: `${symbolColumnWidths.size}px`,
                    minWidth: `${symbolColumnWidths.size}px`,
                    px: 1,
                    py: 0.5,
                    fontSize: "11px",
                    fontWeight: 600,
                    cursor: "pointer",
                    display: "flex",
                    alignItems: "center",
                    position: "relative",
                  }}
                  onClick={() => {
                    if (symbolSortField === "size") {
                      uiActions.setSymbolSortDirection(
                        symbolSortDirection === "asc" ? "desc" : "asc"
                      );
                    } else {
                      uiActions.setSymbolSortField("size");
                      uiActions.setSymbolSortDirection("desc");
                    }
                  }}
                >
                  <TableSortLabel
                    active={symbolSortField === "size"}
                    direction={
                      symbolSortField === "size" ? symbolSortDirection : "asc"
                    }
                    sx={{
                      fontSize: "11px",
                      "& .MuiTableSortLabel-icon": {
                        opacity: symbolSortField === "size" ? 1 : 0,
                      },
                      "&:hover .MuiTableSortLabel-icon": {
                        opacity: 0.5,
                      },
                      "&.Mui-active .MuiTableSortLabel-icon": {
                        opacity: 1,
                      },
                    }}
                  >
                    Size
                  </TableSortLabel>
                  <ColumnResizer
                    onMouseDown={handleSymbolColumnResizeStart("size")}
                    isResizing={resizingColumn === "size"}
                  />
                </Box>
                {/* Type Column Header */}
                <Box
                  sx={{
                    width: `${symbolColumnWidths.type}px`,
                    minWidth: `${symbolColumnWidths.type}px`,
                    px: 1,
                    py: 1,
                    fontSize: "11px",
                    fontWeight: 600,
                    position: "relative",
                  }}
                >
                  <TableSortLabel
                    active={symbolSortField === "type"}
                    direction={
                      symbolSortField === "type" ? symbolSortDirection : "asc"
                    }
                    onClick={() => {
                      const isAsc =
                        symbolSortField === "type" &&
                        symbolSortDirection === "asc";
                      uiActions.setSymbolSortDirection(isAsc ? "desc" : "asc");
                      uiActions.setSymbolSortField("type");
                    }}
                    sx={{
                      fontSize: "11px",
                      "& .MuiTableSortLabel-icon": {
                        opacity: symbolSortField === "type" ? 1 : 0,
                      },
                      "&:hover .MuiTableSortLabel-icon": {
                        opacity: 0.5,
                      },
                      "&.Mui-active .MuiTableSortLabel-icon": {
                        opacity: 1,
                      },
                    }}
                  >
                    Type
                  </TableSortLabel>
                  <ColumnResizer
                    onMouseDown={handleSymbolColumnResizeStart("type")}
                    isResizing={resizingColumn === "type"}
                  />
                </Box>
                {/* Scope Column Header */}
                <Box
                  sx={{
                    width: `${symbolColumnWidths.scope}px`,
                    minWidth: `${symbolColumnWidths.scope}px`,
                    px: 1,
                    py: 1,
                    fontSize: "11px",
                    fontWeight: 600,
                    position: "relative",
                  }}
                >
                  <TableSortLabel
                    active={symbolSortField === "scope"}
                    direction={
                      symbolSortField === "scope" ? symbolSortDirection : "asc"
                    }
                    onClick={() => {
                      const isAsc =
                        symbolSortField === "scope" &&
                        symbolSortDirection === "asc";
                      uiActions.setSymbolSortDirection(isAsc ? "desc" : "asc");
                      uiActions.setSymbolSortField("scope");
                    }}
                    sx={{
                      fontSize: "11px",
                      "& .MuiTableSortLabel-icon": {
                        opacity: symbolSortField === "scope" ? 1 : 0,
                      },
                      "&:hover .MuiTableSortLabel-icon": {
                        opacity: 0.5,
                      },
                      "&.Mui-active .MuiTableSortLabel-icon": {
                        opacity: 1,
                      },
                    }}
                  >
                    Scope
                  </TableSortLabel>
                  <ColumnResizer
                    onMouseDown={handleSymbolColumnResizeStart("scope")}
                    isResizing={resizingColumn === "scope"}
                  />
                </Box>
                {/* Flags Column Header (iOS/macOS only) */}
                {isMachoTarget && (
                  <Box
                    sx={{
                      width: `${symbolColumnWidths.flags}px`,
                      minWidth: `${symbolColumnWidths.flags}px`,
                      px: 1,
                      py: 1,
                      fontSize: "11px",
                      fontWeight: 600,
                      position: "relative",
                    }}
                  >
                    <Typography sx={{ fontSize: "11px", fontWeight: 600 }}>
                      Flags
                    </Typography>
                    <ColumnResizer
                      onMouseDown={handleSymbolColumnResizeStart("flags")}
                      isResizing={resizingColumn === "flags"}
                    />
                  </Box>
                )}
              </Box>
              {/* Virtualized List Body */}
              <List
                style={{
                  height: Math.min(
                    filteredSymbols.length * SYMBOL_ROW_HEIGHT,
                    window.innerHeight - 350
                  ),
                }}
                rowCount={filteredSymbols.length}
                rowHeight={SYMBOL_ROW_HEIGHT}
                rowProps={{
                  data: {
                    symbols: filteredSymbols,
                    formatFileSize,
                    demangleEnabled: symbolDemangleEnabled,
                    demangledNames,
                    columnWidths: symbolColumnWidths,
                    isMachoTarget,
                    moduleName: (() => {
                      const fullPath =
                        selectedModuleForSymbols?.modulename ||
                        selectedModuleForSymbols?.name ||
                        "";
                      return (
                        fullPath.split("/").pop()?.split("\\").pop() || fullPath
                      );
                    })(),
                    moduleBase: selectedModuleBase,
                  },
                }}
                rowComponent={SymbolRow as any}
              />
            </Paper>
          )}
        </TabPanel>
      </Box>
    </Box>
  );
};

```

`src/client/src/components/LicenseAgreementDialog.tsx`:

```tsx
import React from "react";
import { Box, Typography, Button, alpha, Stack } from "@mui/material";
import {
  Security as SecurityIcon,
  CheckCircleOutline as CheckIcon,
  Block as BlockIcon,
  Info as InfoIcon,
} from "@mui/icons-material";
import dynadbgIcon from "../assets/dynadbg-icon.png";

interface LicenseAgreementDialogProps {
  open: boolean;
  onAgree: () => void;
  onDisagree: () => void;
}

export const LicenseAgreementDialog: React.FC<LicenseAgreementDialogProps> = ({
  open,
  onAgree,
  onDisagree,
}) => {
  if (!open) return null;

  return (
    <Box
      sx={{
        position: "fixed",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        background: "#0a0a0a",
        zIndex: 9999,
      }}
    >
      {/* Background grid */}
      <Box
        sx={{
          position: "absolute",
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          backgroundImage: `
            linear-gradient(rgba(59, 130, 246, 0.02) 1px, transparent 1px),
            linear-gradient(90deg, rgba(59, 130, 246, 0.02) 1px, transparent 1px)
          `,
          backgroundSize: "40px 40px",
        }}
      />

      {/* Glowing orbs */}
      <Box
        sx={{
          position: "absolute",
          top: "15%",
          left: "10%",
          width: 300,
          height: 300,
          borderRadius: "50%",
          background:
            "radial-gradient(circle, rgba(59, 130, 246, 0.08) 0%, transparent 70%)",
          filter: "blur(60px)",
        }}
      />
      <Box
        sx={{
          position: "absolute",
          bottom: "10%",
          right: "10%",
          width: 250,
          height: 250,
          borderRadius: "50%",
          background:
            "radial-gradient(circle, rgba(139, 92, 246, 0.08) 0%, transparent 70%)",
          filter: "blur(60px)",
        }}
      />

      {/* Main content */}
      <Box
        sx={{
          position: "relative",
          zIndex: 1,
          width: "100%",
          maxWidth: 560,
          mx: 3,
        }}
      >
        {/* Card */}
        <Box
          sx={{
            background:
              "linear-gradient(145deg, rgba(26, 26, 26, 0.95) 0%, rgba(15, 15, 15, 0.98) 100%)",
            borderRadius: 3,
            border: "1px solid",
            borderColor: alpha("#3b82f6", 0.15),
            overflow: "hidden",
            boxShadow: `
              0 0 0 1px ${alpha("#000", 0.5)},
              0 20px 50px ${alpha("#000", 0.5)},
              0 0 100px ${alpha("#3b82f6", 0.1)}
            `,
          }}
        >
          {/* Header */}
          <Box
            sx={{
              px: 4,
              py: 3,
              display: "flex",
              alignItems: "center",
              gap: 2,
              borderBottom: "1px solid",
              borderColor: alpha("#fff", 0.06),
              background: `linear-gradient(90deg, ${alpha("#3b82f6", 0.05)} 0%, transparent 100%)`,
            }}
          >
            <Box
              component="img"
              src={dynadbgIcon}
              alt="DynaDbg"
              sx={{
                width: 40,
                height: 40,
                filter: "drop-shadow(0 0 10px rgba(59, 130, 246, 0.3))",
              }}
            />
            <Box>
              <Typography
                variant="h6"
                sx={{
                  fontWeight: 600,
                  color: "#fff",
                  letterSpacing: "0.02em",
                }}
              >
                End User License Agreement
              </Typography>
              <Typography
                variant="caption"
                sx={{
                  color: alpha("#fff", 0.4),
                  letterSpacing: "0.05em",
                }}
              >
                Please read before continuing
              </Typography>
            </Box>
          </Box>

          {/* Content */}
          <Box sx={{ px: 4, py: 3 }}>
            <Stack spacing={2.5}>
              {/* Item 1 */}
              <Box
                sx={{
                  display: "flex",
                  gap: 2,
                  p: 2,
                  borderRadius: 2,
                  background: alpha("#3b82f6", 0.05),
                  border: "1px solid",
                  borderColor: alpha("#3b82f6", 0.1),
                }}
              >
                <SecurityIcon
                  sx={{
                    color: "#3b82f6",
                    fontSize: 22,
                    mt: 0.25,
                  }}
                />
                <Typography
                  variant="body2"
                  sx={{
                    color: alpha("#fff", 0.85),
                    lineHeight: 1.7,
                    fontSize: "0.875rem",
                  }}
                >
                  This software is intended solely for{" "}
                  <strong style={{ color: "#3b82f6" }}>
                    security research
                  </strong>
                  , debugging, education, and authorized system diagnostics.
                </Typography>
              </Box>

              {/* Item 2 */}
              <Box
                sx={{
                  display: "flex",
                  gap: 2,
                  p: 2,
                  borderRadius: 2,
                  background: alpha("#ef4444", 0.05),
                  border: "1px solid",
                  borderColor: alpha("#ef4444", 0.1),
                }}
              >
                <BlockIcon
                  sx={{
                    color: "#ef4444",
                    fontSize: 22,
                    mt: 0.25,
                  }}
                />
                <Typography
                  variant="body2"
                  sx={{
                    color: alpha("#fff", 0.85),
                    lineHeight: 1.7,
                    fontSize: "0.875rem",
                  }}
                >
                  The use of this software to{" "}
                  <strong style={{ color: "#ef4444" }}>
                    infringe upon the rights of others
                  </strong>{" "}
                  (including copyright infringement, unauthorized access, etc.)
                  is strictly prohibited.
                </Typography>
              </Box>

              {/* Item 3 */}
              <Box
                sx={{
                  display: "flex",
                  gap: 2,
                  p: 2,
                  borderRadius: 2,
                  background: alpha("#f59e0b", 0.05),
                  border: "1px solid",
                  borderColor: alpha("#f59e0b", 0.1),
                }}
              >
                <InfoIcon
                  sx={{
                    color: "#f59e0b",
                    fontSize: 22,
                    mt: 0.25,
                  }}
                />
                <Typography
                  variant="body2"
                  sx={{
                    color: alpha("#fff", 0.85),
                    lineHeight: 1.7,
                    fontSize: "0.875rem",
                  }}
                >
                  The developer assumes{" "}
                  <strong style={{ color: "#f59e0b" }}>
                    no responsibility
                  </strong>{" "}
                  for any damages arising from the use of this software.
                </Typography>
              </Box>
            </Stack>
          </Box>

          {/* Footer */}
          <Box
            sx={{
              px: 4,
              py: 3,
              display: "flex",
              gap: 2,
              borderTop: "1px solid",
              borderColor: alpha("#fff", 0.06),
              background: alpha("#000", 0.2),
            }}
          >
            <Button
              onClick={onDisagree}
              fullWidth
              sx={{
                py: 1.5,
                color: alpha("#fff", 0.6),
                borderRadius: 2,
                border: "1px solid",
                borderColor: alpha("#fff", 0.1),
                background: "transparent",
                textTransform: "none",
                fontWeight: 500,
                "&:hover": {
                  borderColor: alpha("#fff", 0.2),
                  background: alpha("#fff", 0.03),
                },
              }}
            >
              Decline
            </Button>
            <Button
              onClick={onAgree}
              fullWidth
              startIcon={<CheckIcon />}
              sx={{
                py: 1.5,
                color: "#fff",
                borderRadius: 2,
                background: "linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%)",
                textTransform: "none",
                fontWeight: 600,
                boxShadow: `0 4px 20px ${alpha("#3b82f6", 0.3)}`,
                "&:hover": {
                  background:
                    "linear-gradient(135deg, #2563eb 0%, #1e40af 100%)",
                  boxShadow: `0 6px 25px ${alpha("#3b82f6", 0.4)}`,
                },
              }}
            >
              I Agree
            </Button>
          </Box>
        </Box>

        {/* Version */}
        <Typography
          variant="caption"
          sx={{
            display: "block",
            textAlign: "center",
            mt: 3,
            color: alpha("#fff", 0.25),
            fontSize: "0.7rem",
          }}
        >
          DynaDbg © 2025 DoranekoSystems
        </Typography>
      </Box>
    </Box>
  );
};

```

`src/client/src/components/LinuxSpawnManager.tsx`:

```tsx
import { useState, useCallback } from "react";
import {
  Typography,
  TextField,
  Box,
  Paper,
  Stack,
  CircularProgress,
  Button,
  useMediaQuery,
  FormControlLabel,
  Checkbox,
} from "@mui/material";
import {
  PlayArrow as SpawnIcon,
  Terminal as TerminalIcon,
} from "@mui/icons-material";
import { WebviewWindow } from "@tauri-apps/api/webviewWindow";

import { getApiClient, ModuleInfo } from "../lib/api";
import { useGlobalDebugLogger } from "../hooks/useGlobalDebugLogger";
import { useAppState } from "../hooks/useAppState";

interface LinuxSpawnManagerProps {
  onModulesUpdate?: (modules: ModuleInfo[]) => void;
}

// Open terminal in a separate Tauri window
const openTerminalWindow = async (
  ptyFd: number,
  pid: number,
  processName: string,
  serverUrl: string
) => {
  const windowLabel = `terminal-${pid}`;
  const params = new URLSearchParams({
    pty_fd: String(ptyFd),
    pid: String(pid),
    process_name: processName,
    server_url: serverUrl,
  });

  const webview = new WebviewWindow(windowLabel, {
    url: `index.html#/terminal?${params.toString()}`,
    title: `Terminal: ${processName} (PID: ${pid})`,
    width: 800,
    height: 500,
    minWidth: 800,
    minHeight: 500,
    resizable: true,
    center: true,
  });

  // Handle window creation errors
  webview.once("tauri://error", (e) => {
    console.error("Failed to create terminal window:", e);
  });
};

export function LinuxSpawnManager({ onModulesUpdate }: LinuxSpawnManagerProps) {
  const { system, systemActions } = useAppState();
  const connected = system.serverConnected;
  const attachedProcess = system.attachedProcess;
  const { addLog } = useGlobalDebugLogger();

  const [executablePath, setExecutablePath] = useState("");
  const [args, setArgs] = useState("");
  const [spawning, setSpawning] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const usePty = true; // PTY is always enabled

  const isCompactHeight = useMediaQuery("(max-height: 800px)");

  const handleSpawn = useCallback(async () => {
    if (!executablePath.trim()) {
      setError("Please enter an executable path");
      return;
    }

    setSpawning(true);
    setError(null);

    try {
      const client = getApiClient();

      // Parse arguments
      const argList = args.trim() ? args.split(/\s+/) : [];
      const processName = executablePath.split("/").pop() || executablePath;

      // Use PTY spawn if enabled
      if (usePty) {
        const result = await client.spawnProcessWithPty(
          executablePath.trim(),
          argList
        );
        console.log("PTY Spawn API result:", JSON.stringify(result, null, 2));

        if (
          result.success &&
          result.data?.pid &&
          result.data?.pty_fd !== undefined
        ) {
          const { pid, pty_fd } = result.data;
          addLog(
            "INFO",
            "SPAWN",
            `Process spawned with PTY - PID: ${pid}, PTY FD: ${pty_fd}`
          );

          // Open terminal in a separate window
          const serverUrl = client.getBaseUrl();
          openTerminalWindow(pty_fd, pid, processName, serverUrl);

          // Update system state
          await systemActions.updateProcessState({
            pid: pid,
            processname: processName,
          });

          // Fetch modules
          try {
            const modulesResult = await client.enumerateModules();
            if (modulesResult.data?.modules) {
              systemActions.updateModules(modulesResult.data.modules);
              if (onModulesUpdate) {
                onModulesUpdate(modulesResult.data.modules);
              }
            }
          } catch (e) {
            console.error("Failed to fetch modules:", e);
          }

          // Sync signal configurations to server on attach (skip for iOS)
          // Default: catch=false, pass=false (suppress signals, like GDB)
          const targetOs = system.serverInfo?.target_os;
          if (targetOs !== "ios") {
            try {
              const defaultSignalConfigs = [
                { signal: 4, catch_signal: false, pass_signal: false }, // SIGILL
                { signal: 6, catch_signal: false, pass_signal: false }, // SIGABRT
                { signal: 7, catch_signal: false, pass_signal: false }, // SIGBUS
                { signal: 8, catch_signal: false, pass_signal: false }, // SIGFPE
                { signal: 11, catch_signal: false, pass_signal: false }, // SIGSEGV
              ];
              await client.setAllSignalConfigs(defaultSignalConfigs);
              addLog(
                "INFO",
                "SIGNALS",
                "Synced default signal configurations to server"
              );
            } catch (signalError) {
              console.error(
                "Failed to sync signal configurations:",
                signalError
              );
              addLog(
                "WARN",
                "SIGNALS",
                "Failed to sync signal configurations to server"
              );
            }
          }
        } else {
          const errorMsg =
            (result as any).message || "Failed to spawn process with PTY";
          setError(errorMsg);
          addLog("ERROR", "SPAWN", errorMsg);
        }
      } else {
        // Regular spawn without PTY
        const result = await client.spawnProcess(
          executablePath.trim(),
          argList
        );
        console.log("Spawn API result:", JSON.stringify(result, null, 2));

        if (result.success && result.data?.pid) {
          const pid = result.data.pid;
          addLog("INFO", "SPAWN", `Process spawned with PID: ${pid}`);

          await systemActions.updateProcessState({
            pid: pid,
            processname: processName,
          });

          try {
            const modulesResult = await client.enumerateModules();
            if (modulesResult.data?.modules) {
              systemActions.updateModules(modulesResult.data.modules);
              if (onModulesUpdate) {
                onModulesUpdate(modulesResult.data.modules);
              }
            }
          } catch (e) {
            console.error("Failed to fetch modules:", e);
          }

          // Sync signal configurations to server on attach (skip for iOS)
          // Default: catch=false, pass=false (suppress signals, like GDB)
          const targetOs = system.serverInfo?.target_os;
          if (targetOs !== "ios") {
            try {
              const defaultSignalConfigs = [
                { signal: 4, catch_signal: false, pass_signal: false }, // SIGILL
                { signal: 6, catch_signal: false, pass_signal: false }, // SIGABRT
                { signal: 7, catch_signal: false, pass_signal: false }, // SIGBUS
                { signal: 8, catch_signal: false, pass_signal: false }, // SIGFPE
                { signal: 11, catch_signal: false, pass_signal: false }, // SIGSEGV
              ];
              await client.setAllSignalConfigs(defaultSignalConfigs);
              addLog(
                "INFO",
                "SIGNALS",
                "Synced default signal configurations to server"
              );
            } catch (signalError) {
              console.error(
                "Failed to sync signal configurations:",
                signalError
              );
              addLog(
                "WARN",
                "SIGNALS",
                "Failed to sync signal configurations to server"
              );
            }
          }
        } else {
          const errorMsg = (result as any).message || "Failed to spawn process";
          setError(errorMsg);
          addLog("ERROR", "SPAWN", errorMsg);
        }
      }
    } catch (e) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      setError(errorMsg);
      addLog("ERROR", "SPAWN", `Spawn failed: ${errorMsg}`);
    } finally {
      setSpawning(false);
    }
  }, [executablePath, args, usePty, addLog, systemActions, onModulesUpdate]);

  if (!connected) {
    return (
      <Paper
        sx={{
          p: isCompactHeight ? 1.5 : 2,
          border: "1px solid",
          borderColor: "divider",
          backgroundColor: "background.paper",
          borderTopLeftRadius: 0,
        }}
      >
        <Typography
          variant="body2"
          color="text.secondary"
          sx={{
            fontSize: isCompactHeight ? "10px" : "11px",
            textAlign: "center",
          }}
        >
          Connect to a server to spawn processes
        </Typography>
      </Paper>
    );
  }

  if (attachedProcess) {
    return (
      <Paper
        sx={{
          p: isCompactHeight ? 1.5 : 2,
          border: "1px solid",
          borderColor: "divider",
          backgroundColor: "background.paper",
          borderTopLeftRadius: 0,
        }}
      >
        <Stack spacing={isCompactHeight ? 0.5 : 1}>
          <Typography
            variant="body2"
            color="text.secondary"
            sx={{ fontSize: isCompactHeight ? "10px" : "11px" }}
          >
            Already attached to process: {attachedProcess.processname} (PID:{" "}
            {attachedProcess.pid})
          </Typography>
          <Typography
            variant="body2"
            color="text.secondary"
            sx={{ fontSize: isCompactHeight ? "9px" : "10px" }}
          >
            Detach from the current process to spawn a new one.
          </Typography>
        </Stack>
      </Paper>
    );
  }

  return (
    <>
      <Paper
        sx={{
          p: isCompactHeight ? 1.5 : 2,
          border: "1px solid",
          borderColor: "divider",
          backgroundColor: "background.paper",
          borderTopLeftRadius: 0,
        }}
      >
        <Stack spacing={isCompactHeight ? 1.5 : 2}>
          <Box
            display="flex"
            justifyContent="space-between"
            alignItems="center"
          >
            <Typography
              variant="subtitle1"
              sx={{
                display: "flex",
                alignItems: "center",
                gap: 1,
                fontSize: isCompactHeight ? "11px" : "12px",
                fontWeight: 600,
                color: "primary.main",
              }}
            >
              <TerminalIcon
                sx={{ fontSize: isCompactHeight ? "14px" : "16px" }}
              />
              Spawn Manager
            </Typography>
          </Box>

          {/* Executable Path Input */}
          <Box>
            <Typography
              variant="body2"
              sx={{
                fontSize: isCompactHeight ? "9px" : "10px",
                fontWeight: 600,
                mb: isCompactHeight ? 0.5 : 1,
              }}
            >
              Executable Path
            </Typography>
            <TextField
              fullWidth
              size="small"
              placeholder="/path/to/executable"
              value={executablePath}
              onChange={(e) => setExecutablePath(e.target.value)}
              disabled={spawning}
              sx={{
                "& .MuiInputLabel-root": {
                  fontSize: isCompactHeight ? "10px" : "11px",
                },
                "& .MuiInputBase-input": {
                  fontSize: isCompactHeight ? "10px" : "11px",
                  fontFamily: "monospace",
                },
                ...(isCompactHeight && {
                  "& .MuiInputBase-root": {
                    minHeight: "20px",
                    fontSize: "11px",
                  },
                  "& .MuiInputBase-input": {
                    paddingTop: "4px",
                    paddingBottom: "4px",
                    fontSize: "11px",
                  },
                }),
              }}
            />
          </Box>

          {/* Arguments Input */}
          <Box>
            <Typography
              variant="body2"
              sx={{
                fontSize: isCompactHeight ? "9px" : "10px",
                fontWeight: 600,
                mb: isCompactHeight ? 0.5 : 1,
              }}
            >
              Arguments (space-separated)
            </Typography>
            <TextField
              fullWidth
              size="small"
              placeholder="arg1 arg2 arg3"
              value={args}
              onChange={(e) => setArgs(e.target.value)}
              disabled={spawning}
              sx={{
                "& .MuiInputLabel-root": {
                  fontSize: isCompactHeight ? "10px" : "11px",
                },
                "& .MuiInputBase-input": {
                  fontSize: isCompactHeight ? "10px" : "11px",
                  fontFamily: "monospace",
                },
                ...(isCompactHeight && {
                  "& .MuiInputBase-root": {
                    minHeight: "20px",
                    fontSize: "11px",
                  },
                  "& .MuiInputBase-input": {
                    paddingTop: "4px",
                    paddingBottom: "4px",
                    fontSize: "11px",
                  },
                }),
              }}
            />
          </Box>

          {/* PTY Option */}
          <FormControlLabel
            control={
              <Checkbox
                checked={true}
                disabled={true}
                size="small"
                sx={{
                  py: 0,
                  "& .MuiSvgIcon-root": {
                    fontSize: isCompactHeight ? 16 : 18,
                  },
                }}
              />
            }
            label={
              <Typography
                variant="body2"
                sx={{ fontSize: isCompactHeight ? "10px" : "11px" }}
              >
                Enable Terminal I/O (PTY)
              </Typography>
            }
            sx={{ ml: 0, mt: isCompactHeight ? -0.5 : 0 }}
          />

          {/* Error Message */}
          {error && (
            <Typography
              variant="body2"
              sx={{
                fontSize: isCompactHeight ? "9px" : "10px",
                color: "error.main",
              }}
            >
              {error}
            </Typography>
          )}

          {/* Spawn Button */}
          <Button
            variant="contained"
            startIcon={
              spawning ? (
                <CircularProgress
                  size={isCompactHeight ? 12 : 14}
                  sx={{ color: "inherit" }}
                />
              ) : (
                <SpawnIcon
                  sx={{ fontSize: isCompactHeight ? "14px" : "16px" }}
                />
              )
            }
            onClick={handleSpawn}
            disabled={spawning || !executablePath.trim()}
            sx={{
              textTransform: "none",
              fontSize: isCompactHeight ? "10px" : "11px",
              py: isCompactHeight ? 0.5 : 0.75,
              px: isCompactHeight ? 1.5 : 2,
              minWidth: "auto",
            }}
          >
            {spawning ? "Spawning..." : "Spawn Process"}
          </Button>

          {/* Info */}
          <Paper
            sx={{
              p: isCompactHeight ? 1 : 1.5,
              backgroundColor: "action.hover",
              borderRadius: 1,
              border: "1px solid",
              borderColor: "divider",
            }}
          >
            <Typography
              variant="body2"
              sx={{
                fontSize: isCompactHeight ? "9px" : "10px",
                color: "text.secondary",
              }}
            >
              {usePty
                ? "Terminal I/O enabled: A terminal window will open for stdin/stdout interaction."
                : "The process will be spawned in a suspended state (stopped at the entry point)."}
            </Typography>
          </Paper>
        </Stack>
      </Paper>
    </>
  );
}

```

`src/client/src/components/MainApp.tsx`:

```tsx
import React, { useCallback, useState, useEffect, useRef } from "react";
import { ThemeProvider, CssBaseline, Snackbar, Alert } from "@mui/material";
import { AppGrid, ToolbarArea } from "../utils/constants";
import { darkTheme } from "../utils/theme";
import { Header } from "../components/Header";
import { HomePage } from "../components/HomePage";
import { HomeSidebar, HomeSubPage } from "../components/HomeSidebar";
import { HelpContent } from "../components/HelpContent";
import { DocumentationContent } from "../components/DocumentationContent";
import { NewsContent, useUnreadNewsCount } from "../components/NewsContent";
import { AboutContent } from "../components/AboutContent";
import { SettingsContent } from "../components/SettingsContent";
import { DebuggerContent } from "../components/DebuggerContent";
import { DebuggerToolbar } from "../components/DebuggerToolbar";
import { DebuggerSidebar } from "../components/DebuggerSidebar";
import { RegisterView } from "../components/RegisterView";
import { InformationContent } from "../components/InformationContent";
import { ServerContent } from "../components/ServerContent";
import { ScannerSidebar } from "../components/ScannerSidebar";
import { ScannerContent } from "../components/ScannerContent";
import { ScannerToolbar } from "../components/ScannerToolbar";
import { ToolsContent } from "../components/ToolsContent";
import { StatusBarComponent } from "../components/StatusBar";
import { StatePanel } from "../components/StatePanel";
import { DebugLoggerProvider } from "../hooks/useGlobalDebugLogger";
import {} from "../hooks/useGlobalNetworkLogger";
import { GlobalExceptionHandlerProvider } from "../hooks/useGlobalExceptionHandler";

import { useScannerGlobalState } from "../hooks/useScannerGlobalState";
import { useScannerState } from "../hooks/useScannerState";
import { useSymbolCache } from "../hooks/useSymbolCache";
import {
  useWatchpointHandler,
  useBreakpointHandler,
} from "../hooks/useGlobalExceptionHandler";
import type { ScriptBreakpointEvent } from "../hooks/useExceptionHandler";
import { getApiClient } from "../lib/api";
import type {
  WatchpointInfo,
  WatchpointSize,
  WatchpointAccessType,
  ScanHistoryItem,
  ScanSettings,
} from "../types";
import type { ProcessInfo } from "../lib/api";
import { WebviewWindow } from "@tauri-apps/api/webviewWindow";
import { useAppState } from "../hooks/useAppState";
import { useLocalStorage } from "../hooks/useLocalStorage";
import { useGhidraAnalysis } from "../hooks/useGhidraAnalysis";

// Props interface for AppContent when it needs to pass state to parent
interface AppContentProps {
  onConnectionStateChange?: (
    serverConnected: boolean,
    debuggerConnected: boolean,
    attachedProcess?: ProcessInfo
  ) => void;
  onBreakpointHit?: any; // Exception data instead of callback
  onBreakpointStateChange?: (hasActiveBreakpoints: boolean) => void;
  // onWatchpointStateChange is no longer needed - use system.watchpoints directly
  onBreakpointHandler?: (handler: (exception: any) => void) => void; // Add this to pass handler up
}

// Main Application Component
const AppContent: React.FC<AppContentProps> = ({
  onConnectionStateChange,
  onBreakpointHit: _onBreakpointHit,
  onBreakpointStateChange,
}) => {
  const { system, ui, systemActions, uiActions } = useAppState();

  // RegisterView width from localStorage (shared with RegisterView component)
  const [registerWidth, setRegisterWidth] = useLocalStorage<number>(
    "register-view-width",
    300
  );

  // Debugger sidebar visibility state (persisted)
  const [showDebuggerSidebar, setShowDebuggerSidebar] =
    useLocalStorage<boolean>("show-debugger-sidebar", false);

  // Toggle debugger sidebar visibility
  const handleToggleDebuggerSidebar = useCallback(() => {
    setShowDebuggerSidebar(!showDebuggerSidebar);
  }, [showDebuggerSidebar, setShowDebuggerSidebar]);

  // Development mode check
  const isDevelopment = false; //import.meta.env.DEV;

  const {
    serverConnected,
    debuggerConnected,
    connectionHost,
    connectionPort,
    attachedProcess,
    serverInfo,
    attachedAppInfo,
    attachedModules,
    isInBreakState,
    currentThreadId,
    currentBreakAddress,
    currentRegisterData,
    activeBreakpoints,
    softwareBreakpoints,
    watchpoints,
    spawnSuspended,
  } = system;

  const {
    currentMode,
    sidebarWidth,
    debuggerSidebarWidth,
    scannerSidebarWidth,
    showRegisters,
    showToolbar,
    debuggerState,
  } = ui;

  // Ghidra analysis hook for function name resolution
  const { resolveFunctionName } = useGhidraAnalysis();

  const handleModeChange = useCallback(
    (mode: any) => {
      uiActions.setCurrentMode(mode);

      // Clear inline styles when switching modes (removes sidebar resize effect)
      const gridElement = document.querySelector(
        "[data-sidebar-grid]"
      ) as HTMLElement;
      if (gridElement) {
        gridElement.style.gridTemplateColumns = "";
      }
    },
    [uiActions]
  );

  const handleToggleRegisters = useCallback(() => {
    uiActions.setShowRegisters(!showRegisters);
  }, [uiActions, showRegisters]);

  const updateCurrentRegisterData = useCallback(
    (data: Record<string, string>) => {
      systemActions.updateDebugState(undefined, undefined, undefined, data);
    },
    [systemActions]
  );

  const [lastDebugAction, setLastDebugAction] = useState<
    "continue" | "single_step" | "breakpoint" | null
  >(null);

  // Software/Hardware breakpoint toggle state
  const [isSoftwareBreakpoint, setIsSoftwareBreakpoint] = useState(false);

  // Debug: log when breakpoint type changes
  useEffect(() => {
    console.log(
      "[MainApp] isSoftwareBreakpoint changed to:",
      isSoftwareBreakpoint
    );
  }, [isSoftwareBreakpoint]);

  // Snackbar state for notifications
  const [snackbar, setSnackbar] = useState<{
    open: boolean;
    message: string;
    severity: "error" | "warning" | "info" | "success";
  }>({
    open: false,
    message: "",
    severity: "info",
  });

  // Home page sub-navigation state
  const [homeSubPage, setHomeSubPage] = useState<HomeSubPage>("home");
  const [unreadNewsCount, setUnreadNewsCount] = useState(0);

  // Get initial unread news count
  const initialUnreadCount = useUnreadNewsCount();
  useEffect(() => {
    setUnreadNewsCount(initialUnreadCount);
  }, [initialUnreadCount]);

  // Reset homeSubPage when leaving home mode
  useEffect(() => {
    if (currentMode !== "home") {
      setHomeSubPage("home");
    }
  }, [currentMode]);

  // sidebarWidthは既にグローバルストアから取得しているので、追加処理は不要

  // Notify parent about connection state changes
  useEffect(() => {
    if (onConnectionStateChange) {
      onConnectionStateChange(
        serverConnected,
        debuggerConnected,
        attachedProcess
      );
    }
  }, [
    serverConnected,
    debuggerConnected,
    attachedProcess,
    onConnectionStateChange,
  ]);

  // Test logging
  useEffect(() => {
    if (isDevelopment) {
      console.log(
        "MainApp: Development mode detected, test logs should appear"
      );
    }
  }, [isDevelopment]);

  // Scanner state from legacy hooks (for compatibility)
  // Use global scanner state
  const {
    scannerState,
    scanResults,
    scanHistory: globalScanHistory,
    bookmarks,
    scanSettings,
    updateFullScanSettings,
    removeBookmark,
    updateBookmark,
    addManualBookmark,
    isAddressBookmarked,
    handleResultBookmark,
  } = useScannerGlobalState();

  // New scanner state hook with full implementation
  const {
    memoryRegionsLoaded,
    updateScanSettings,
    performFirstScan,
    performNextScan,
    performNewScan,
    handleResultEdit,
    handleResultDelete,
    stopScan,
    clearScan,
    onSelectHistory,
    onRemoveHistoryItem,
    onClearHistory,
    updateBookmarkAddressesFromModules,
  } = useScannerState();

  const { updateServerInfo, clearCache: clearSymbolCache } = useSymbolCache();

  useEffect(() => {
    if (connectionHost && connectionPort) {
      updateServerInfo({ ip: connectionHost, port: connectionPort });
    } else {
      updateServerInfo(null);
    }
  }, [connectionHost, connectionPort, updateServerInfo]);

  // Handle module updates - must be after useScannerState to use updateBookmarkAddressesFromModules
  const handleModulesUpdate = useCallback(
    (modules: any[]) => {
      systemActions.updateModules(modules);
      // Update bookmark addresses when modules are reloaded
      updateBookmarkAddressesFromModules(modules);
    },
    [systemActions, updateBookmarkAddressesFromModules]
  );

  // Track previous mode to only refresh on actual mode change
  const prevModeRef = useRef<string | null>(null);

  // Auto-refresh modules when switching to debugger or scanner mode
  useEffect(() => {
    const prevMode = prevModeRef.current;
    prevModeRef.current = currentMode;

    // Only refresh if mode actually changed (not on initial render or same mode)
    if (
      prevMode !== null &&
      prevMode !== currentMode &&
      (currentMode === "debugger" || currentMode === "scanner") &&
      attachedProcess
    ) {
      const refreshModules = async () => {
        try {
          const apiClient = getApiClient();
          const response = await apiClient.enumerateModules();
          if (response.data?.modules) {
            console.log(
              `[MainApp] Auto-refreshed modules on ${currentMode} mode switch:`,
              response.data.modules.length
            );
            handleModulesUpdate(response.data.modules);
          }
        } catch (error) {
          console.error("[MainApp] Failed to auto-refresh modules:", error);
        }
      };
      refreshModules();
    }
  }, [currentMode, attachedProcess, handleModulesUpdate]);

  // Enhanced history selection handler that ensures global state is updated
  const handleSelectHistory = useCallback(
    (item: ScanHistoryItem) => {
      // First call the original handler
      if (onSelectHistory) {
        onSelectHistory(item);
      }

      // Also ensure global state is updated with all settings from history
      const newSettings: ScanSettings = {
        // Start with current base settings
        ...scanSettings,
        // Apply all settings from the history item including permissions, ranges, alignment
        ...item.scanSettings,
        // Explicitly set the core search parameters
        valueType: item.valueType,
        scanType: item.scanType,
        value: item.value,
      };
      if (updateFullScanSettings) {
        updateFullScanSettings(newSettings);
      }
    },
    [onSelectHistory, scanSettings, updateFullScanSettings]
  );

  // Create a wrapper for scan settings update to match expected signature
  const handleScanSettingsChange = useCallback(
    (settings: ScanSettings) => {
      if (updateFullScanSettings) {
        updateFullScanSettings(settings);
      }
      if (updateScanSettings) {
        updateScanSettings(settings); // Also update the original hook for compatibility
      }
      return true;
    },
    [updateFullScanSettings, updateScanSettings]
  );

  // Debugger content state - now using UI store
  const { breakpointNotification, breakpointInputValue, memoryAddress } =
    debuggerState;

  const updateAssemblyAddress = uiActions.setAssemblyAddress;
  const showBreakpointNotification = uiActions.showBreakpointNotification;
  const hideBreakpointNotification = uiActions.hideBreakpointNotification;
  const updateBreakpointInputValue = uiActions.setBreakpointInputValue;
  const updateMemoryAddress = uiActions.setMemoryAddress;

  const addActiveBreakpoint = (address: string, isSoftware?: boolean) =>
    systemActions.addBreakpoint(address, isSoftware);
  const removeActiveBreakpoint = (address: string) =>
    systemActions.removeBreakpoint(address);

  // Scanner tab state
  const [scannerCurrentTab, setScannerCurrentTab] = useState(0);

  // Information state from UI store
  const {
    currentTab: informationCurrentTab,
    nameFilter: modulesNameFilter,
    sortField: modulesSortField,
    sortDirection: modulesSortDirection,
  } = ui.informationState;

  const setInformationCurrentTab = uiActions.setInformationTab;
  const setModulesNameFilter = uiActions.setInformationNameFilter;
  const handleModulesSortChange = (
    field: "baseAddress" | "size" | null,
    direction: "asc" | "desc"
  ) => {
    uiActions.setInformationSort(field || "name", direction);
  };

  // Notify parent about breakpoint state changes
  const lastBreakpointCount = React.useRef(0);
  useEffect(() => {
    const currentCount = activeBreakpoints.length;
    console.log("[BREAKPOINT STATE] Count changed:", {
      currentCount,
      lastCount: lastBreakpointCount.current,
      activeBreakpoints,
      hasCallback: !!onBreakpointStateChange,
    });

    if (
      onBreakpointStateChange &&
      lastBreakpointCount.current !== currentCount
    ) {
      const hasBreakpoints = currentCount > 0;
      lastBreakpointCount.current = currentCount;
      console.log("[BREAKPOINT STATE] Calling onBreakpointStateChange:", {
        hasBreakpoints,
        currentCount,
      });
      onBreakpointStateChange(hasBreakpoints);
    }
  }, [activeBreakpoints.length, onBreakpointStateChange]);

  // Legacy state for compatibility
  const [lastHealthCheck] = useState<{
    latency: number;
    timestamp: string;
  } | null>(null);

  // Use global watchpoint handler for watchpoint windows (independent of debugger tab)
  useWatchpointHandler((exception) => {
    console.log(`[WATCHPOINT] Watchpoint exception received:`, exception);

    // Find matching watchpoint from state based on memory_address
    const memoryAddress = exception.memory_address;
    if (!memoryAddress) {
      console.warn(
        "[WATCHPOINT] No memory_address in exception, cannot determine watchpoint"
      );
      return;
    }

    // Find the watchpoint that covers this memory address
    const matchingWatchpoint = watchpoints.find((wp) => {
      const wpAddr =
        typeof wp.address === "string" ? parseInt(wp.address, 16) : wp.address;
      return memoryAddress >= wpAddr && memoryAddress < wpAddr + wp.size;
    });

    if (!matchingWatchpoint) {
      console.warn(
        `[WATCHPOINT] No matching watchpoint found for memory address 0x${memoryAddress.toString(16)}`
      );
      return;
    }

    console.log(
      `[WATCHPOINT] Matched watchpoint ${matchingWatchpoint.id} for address ${exception.address}`
    );

    // Check if window is already opened or has been closed for this watchpoint
    const windowLabel = `watchpoint_${matchingWatchpoint.id}`;
    if (
      watchpointWindowsRef.current.has(windowLabel) ||
      closedWatchpointWindowsRef.current.has(windowLabel)
    ) {
      console.log(
        `[WATCHPOINT] Window already exists or was closed for watchpoint: ${windowLabel}`
      );
      return;
    }

    // Create watchpoint window using the matched watchpoint info
    // Convert to WatchpointInfo type (createdAt string to Date)
    const watchpointInfo: WatchpointInfo = {
      ...matchingWatchpoint,
      accessType: matchingWatchpoint.accessType as "r" | "w" | "rw",
      createdAt: new Date(matchingWatchpoint.createdAt),
    };
    createWatchpointWindow(watchpointInfo);
  });

  // Handle register data update from exception handler
  const handleRegisterDataUpdate = useCallback(
    (registerData: Record<string, string>) => {
      console.log(
        "[REGISTER DEBUG] MainApp: Received register data:",
        registerData
      );
      updateCurrentRegisterData(registerData);
    },
    [updateCurrentRegisterData]
  );

  // Track processed exception timestamps to prevent duplicate processing
  const processedExceptionTimestampRef = useRef<number>(0);

  // Handle breakpoint hit from global exception handler - full exception processing
  const handleGlobalBreakpointHit = useCallback(
    (exception: any) => {
      console.log(
        `[SINGLE_STEP] Exception received at ${new Date().toISOString()}, type: ${exception.type}`
      );

      // Prevent duplicate processing of the same exception
      const exceptionTimestamp = exception.timestamp?.getTime?.() || Date.now();
      if (processedExceptionTimestampRef.current === exceptionTimestamp) {
        console.log(
          `[MAINAPP BREAK DEBUG] Skipping duplicate exception processing for timestamp ${exceptionTimestamp}`
        );
        return;
      }
      processedExceptionTimestampRef.current = exceptionTimestamp;

      // Detect architecture based on available registers
      const isX86_64 =
        (exception as any).rax !== undefined ||
        (exception as any).rip !== undefined;

      // Get the program counter address based on architecture
      // For x86_64: use RIP, for ARM64: use PC or address field
      let address = exception.address || "unknown";
      if (isX86_64 && (exception as any).rip !== undefined) {
        const rip = (exception as any).rip;
        address =
          typeof rip === "number"
            ? `0x${rip.toString(16)}`
            : typeof rip === "string"
              ? rip
              : address;
      } else if (!isX86_64 && (exception as any).pc !== undefined) {
        const pc = (exception as any).pc;
        address =
          typeof pc === "number"
            ? `0x${pc.toString(16)}`
            : typeof pc === "string"
              ? pc
              : address;
      }

      console.log(
        `[MAINAPP BREAK DEBUG] Breakpoint hit at address: ${address} (isX86_64: ${isX86_64})`
      );

      // Record breakpoint hit time to prevent interference from onBreakStateChange
      (window as any).__lastBreakpointHitTime = Date.now();

      // Switch to debugger mode when breakpoint is hit
      uiActions.setCurrentMode("debugger");

      // Process register data from exception first (before updating state)
      const registerData: Record<string, string> = {};

      // Extract register fields from the exception object based on architecture
      const registerFields = isX86_64
        ? [
            // x86_64 registers
            "rax",
            "rbx",
            "rcx",
            "rdx",
            "rsi",
            "rdi",
            "rbp",
            "rsp",
            "r8",
            "r9",
            "r10",
            "r11",
            "r12",
            "r13",
            "r14",
            "r15",
            "rip",
            "rflags",
            "cs",
            "ss",
            "ds",
            "es",
            "fs",
            "gs",
          ]
        : [
            // ARM64 registers
            "x0",
            "x1",
            "x2",
            "x3",
            "x4",
            "x5",
            "x6",
            "x7",
            "x8",
            "x9",
            "x10",
            "x11",
            "x12",
            "x13",
            "x14",
            "x15",
            "x16",
            "x17",
            "x18",
            "x19",
            "x20",
            "x21",
            "x22",
            "x23",
            "x24",
            "x25",
            "x26",
            "x27",
            "x28",
            "x29",
            "lr",
            "fp",
            "sp",
            "pc",
            "cpsr",
          ];

      registerFields.forEach((field) => {
        const value = (exception as any)[field];
        if (value !== undefined && value !== null) {
          if (typeof value === "number") {
            registerData[field.toUpperCase()] =
              `0x${value.toString(16).padStart(16, "0")}`;
          } else if (typeof value === "string") {
            registerData[field.toUpperCase()] = value;
          }
        }
      });

      console.log(
        "[REGISTER DEBUG] MainApp: Extracted register data from exception:",
        registerData
      );

      // Update all debug state atomically through Tauri in a single batch
      // This includes register data to avoid multiple round-trips
      systemActions.updateDebugState(
        true, // isInBreakState
        exception.thread_id || undefined, // currentThreadId
        address, // currentBreakAddress
        Object.keys(registerData).length > 0 ? registerData : undefined // registerData in same batch
      );
    },
    [systemActions, uiActions]
  );

  // NOTE: onBreakpointHit prop is no longer used for processing - useBreakpointHandler handles all breakpoints
  // The prop may still be passed for legacy compatibility but is not processed here to avoid duplicates

  // Use global breakpoint handler for breakpoint processing
  const breakpointHandler = useCallback(
    (exception: any) => {
      handleGlobalBreakpointHit(exception);
    },
    [handleGlobalBreakpointHit]
  );

  useBreakpointHandler(breakpointHandler);

  // Handle breakpoint hit from DebuggerContent - just address string
  const handleBreakpointHit = useCallback((_address: string) => {
    // This is called from DebuggerContent and just provides the address
    // The main processing is already done by handleGlobalBreakpointHit
  }, []);

  // Watchpoint exception windows state (use ref for immediate tracking)
  const watchpointWindowsRef = React.useRef<Set<string>>(new Set());
  // Track closed watchpoint windows to prevent re-opening
  const closedWatchpointWindowsRef = React.useRef<Set<string>>(new Set());

  // Create new window for watchpoint exception monitoring
  const createWatchpointWindow = useCallback(
    async (watchpoint: WatchpointInfo) => {
      try {
        const windowLabel = `watchpoint_${watchpoint.id}`;

        // Check if window already exists (check Ref for immediate status)
        if (watchpointWindowsRef.current.has(windowLabel)) {
          console.log(
            "Window already exists for watchpoint (ref check):",
            windowLabel
          );
          return;
        }

        // Add to ref immediately to prevent race conditions
        watchpointWindowsRef.current.add(windowLabel);

        console.log("Creating watchpoint window:", windowLabel);
        console.log("Watchpoint data:", watchpoint);

        // **IMPORTANT: Save watchpoint state to Tauri state BEFORE creating window**
        console.log(
          "Saving watchpoint to Tauri state before window creation..."
        );

        // First, ensure the watchpoint is saved to the system state
        const watchpointForState = {
          id: watchpoint.id,
          address: watchpoint.address,
          size: watchpoint.size,
          accessType: watchpoint.accessType,
          hitCount: watchpoint.hitCount || 0,
          createdAt: watchpoint.createdAt.toISOString(),
          description: watchpoint.description,
        };

        // Add watchpoint to system state immediately
        systemActions.addWatchpoint(watchpointForState);
        console.log("Watchpoint saved to system state:", watchpointForState);

        // Wait for state to be persisted (allow React state updates to complete)
        await new Promise((resolve) => setTimeout(resolve, 50));

        // Verify the watchpoint is in the state before proceeding
        const currentWatchpoints = watchpoints;
        const isWatchpointSaved = currentWatchpoints.some(
          (w) => w.id === watchpoint.id
        );
        if (!isWatchpointSaved) {
          console.warn(
            "Watchpoint not found in state after save, proceeding anyway..."
          );
        } else {
          console.log(
            "Watchpoint confirmed in state, proceeding with window creation"
          );
        }

        // Determine the base URL based on environment
        // In development: use localhost:1420 (Vite dev server)
        // In production: use tauri://localhost (bundled assets)
        const isDev = import.meta.env.DEV;
        const baseUrl = isDev ? "http://localhost:1420" : "tauri://localhost";

        const window = new WebviewWindow(windowLabel, {
          url: `${baseUrl}/#/watchpoint-exception/${watchpoint.id}`,
          title: `Watchpoint Exception Monitor`,
          width: 1000,
          height: 600,
          minWidth: 800,
          minHeight: 400,
          resizable: true,
          maximized: false,
          decorations: true,
          alwaysOnTop: true, // Make window always on top for initial visibility
          skipTaskbar: false,
          center: true,
          focus: true,
          visible: true,
          // Add additional properties for debugging
          acceptFirstMouse: true,
          titleBarStyle: "visible",
          shadow: true,
        });

        console.log("Window created successfully:", windowLabel);

        // Wait for window to be fully loaded
        await window.once("tauri://window-created", () => {
          console.log("Window fully created event received:", windowLabel);
        });

        // Show the window explicitly
        try {
          await window.show();
          console.log("Window show() called successfully:", windowLabel);
        } catch (showError) {
          console.error("Failed to show window:", showError);
        }

        // Focus the window
        try {
          await window.setFocus();
          console.log("Window focus set successfully:", windowLabel);

          // Disable always on top after showing the window
          setTimeout(async () => {
            try {
              await window.setAlwaysOnTop(false);
              console.log("Always on top disabled for:", windowLabel);
            } catch (alwaysOnTopError) {
              console.error(
                "Failed to disable always on top:",
                alwaysOnTopError
              );
            }
          }, 2000); // Wait 2 seconds before disabling always on top
        } catch (focusError) {
          console.error("Failed to focus window:", focusError);
        }

        // Listen for window close event
        window.once("tauri://close-requested", async () => {
          console.log("Window close requested:", windowLabel);

          try {
            // Remove from tracking first
            watchpointWindowsRef.current.delete(windowLabel);
            // Add to closed windows to prevent re-opening
            closedWatchpointWindowsRef.current.add(windowLabel);

            // **IMPORTANT: Remove from Tauri state when window closes**
            console.log("Removing watchpoint from Tauri state:", watchpoint.id);
            systemActions.removeWatchpoint(watchpoint.id);

            // Remove watchpoint from server
            try {
              console.log(
                "Removing watchpoint from server:",
                watchpoint.address
              );
              const apiClient = getApiClient();
              const addressNum = parseInt(watchpoint.address, 16);
              await apiClient.removeWatchpoint({ address: addressNum });
              console.log("Watchpoint removed from server successfully");
            } catch (error) {
              console.error("Failed to remove watchpoint from server:", error);
            }

            // Close the window immediately
            await window.close();
          } catch (error) {
            console.error("Error during window close process:", error);
          }
        });

        // Listen for additional window events for debugging
        window.once("tauri://destroyed", () => {
          console.log("Window destroyed:", windowLabel);
        });
      } catch (error) {
        console.error("Failed to create watchpoint window:", error);
        const errorMessage =
          error instanceof Error ? error.message : String(error);
        const errorStack = error instanceof Error ? error.stack : undefined;
        console.error("Error details:", {
          message: errorMessage,
          stack: errorStack,
          watchpoint: watchpoint,
        });

        // **IMPORTANT: Clean up Tauri state if window creation failed**
        console.log(
          "Cleaning up watchpoint from Tauri state due to window creation failure"
        );
        systemActions.removeWatchpoint(watchpoint.id);

        // Remove from tracking if creation failed
        const windowLabel = `watchpoint_${watchpoint.id}`;
        watchpointWindowsRef.current.delete(windowLabel);
      }
    },
    [systemActions, watchpoints] // Remove watchpointWindows from dependencies, use ref instead
  );

  // Watchpoint handlers
  const handleSetWatchpoint = useCallback(
    async (
      address: string,
      size: WatchpointSize,
      accessType: WatchpointAccessType,
      description?: string
    ): Promise<boolean> => {
      try {
        // **STEP 0: Check watchpoint limit BEFORE calling API**
        const currentWatchpoints = watchpoints || [];
        const targetOs = system.serverInfo?.target_os;
        const MAX_WATCHPOINTS_ANDROID = 1;

        if (
          (targetOs === "android" || targetOs === "linux") &&
          currentWatchpoints.length >= MAX_WATCHPOINTS_ANDROID
        ) {
          setSnackbar({
            open: true,
            message: `Watchpoint limit reached: Currently limited to ${MAX_WATCHPOINTS_ANDROID} watchpoint(s) for ${targetOs} due to a stability issue under investigation. Please remove the existing watchpoint first.`,
            severity: "warning",
          });
          return false;
        }

        const apiClient = getApiClient();

        // Convert hex address to number for API call
        const addressNum = parseInt(address, 16);

        const response = await apiClient.setWatchpoint({
          address: addressNum,
          size,
          _type: accessType,
        });

        if (response.success && response.watchpoint_id) {
          // **IMPORTANT: Prepare watchpoint data for Tauri state BEFORE window creation**
          console.log(
            "Preparing watchpoint for Tauri state before window creation..."
          );

          // Create watchpoint objects for both system state and window creation
          const watchpointForState = {
            id: response.watchpoint_id,
            address: address, // Keep as string for consistency with types
            size,
            accessType: accessType,
            hitCount: 0,
            createdAt: new Date().toISOString(), // Convert to string for system state
            description,
          };

          const watchpointForWindow: WatchpointInfo = {
            id: response.watchpoint_id,
            address: address,
            size,
            accessType: accessType,
            hitCount: 0,
            createdAt: new Date(), // Keep as Date object for window creation
            description,
          };

          // **STEP 1: Add watchpoint to Tauri state FIRST**
          console.log("Adding watchpoint to Tauri state:", watchpointForState);
          const addResult =
            await systemActions.addWatchpoint(watchpointForState);

          if (!addResult.success && addResult.error) {
            setSnackbar({
              open: true,
              message: addResult.error,
              severity: "warning",
            });
            return false;
          }

          // **STEP 2: Wait for state to be persisted**
          await new Promise((resolve) => setTimeout(resolve, 100));

          // **STEP 3: Create window with watchpoint info**
          console.log("Creating watchpoint window with saved state...");
          await createWatchpointWindow(watchpointForWindow);

          return true;
        }
        return false;
      } catch (error) {
        console.error(`Failed to set watchpoint at ${address}:`, error);
        setSnackbar({
          open: true,
          message: `Failed to set watchpoint: ${error}`,
          severity: "error",
        });
        return false;
      }
    },
    [
      createWatchpointWindow,
      systemActions,
      watchpoints,
      system.serverInfo?.target_os,
    ]
  );

  const handleRemoveWatchpoint = useCallback(
    async (address: string): Promise<boolean> => {
      try {
        // Convert hex address to number for API call
        const addressNum = parseInt(address, 16);

        const apiClient = getApiClient();
        const response = await apiClient.removeWatchpoint({
          address: addressNum,
        });

        if (response.success) {
          // Remove from state (compare addresses as strings)
          const watchpointToRemove = watchpoints.find(
            (w) => w.address === address
          );
          if (watchpointToRemove) {
            console.log(
              "[WATCHPOINT] Removing watchpoint from state:",
              watchpointToRemove
            );
            systemActions.removeWatchpoint(watchpointToRemove.id);
          } else {
            console.warn(
              "[WATCHPOINT] Watchpoint not found in state for address:",
              address
            );
          }
          return true;
        }
        return false;
      } catch (error) {
        console.error(`Failed to remove watchpoint at ${address}:`, error);
        return false;
      }
    },
    [watchpoints, systemActions]
  );

  // Handle history selection with execution (for search icon)
  const handleExecuteHistorySearch = useCallback(
    async (item: ScanHistoryItem) => {
      // First, select the history item to update settings (same as clicking on history)
      handleSelectHistory(item);

      // Create a new settings object with the history item's settings
      // Ensure all settings from history are applied including permissions, ranges, alignment
      const newSettings: ScanSettings = {
        // Start with current base settings
        ...scanSettings,
        // Apply all settings from the history item
        ...item.scanSettings,
        // Explicitly set the core search parameters
        valueType: item.valueType,
        scanType: item.scanType,
        value: item.value,
      };

      // Update settings immediately
      updateFullScanSettings(newSettings);
      updateScanSettings(newSettings);

      // Wait briefly for state to settle
      await new Promise((resolve) => setTimeout(resolve, 100));

      // Execute scan using the updated settings from global store
      await performFirstScan();
    },
    [
      handleSelectHistory,
      scanSettings,
      updateFullScanSettings,
      updateScanSettings,
      performFirstScan,
    ]
  );

  // Memory read handler using API client
  const handleMemoryRead = useCallback(
    async (address: string, size: number): Promise<ArrayBuffer> => {
      try {
        const apiClient = getApiClient();
        return await apiClient.readMemory(address, size);
      } catch (error) {
        console.error(`Failed to read memory at ${address}:`, error);
        throw error;
      }
    },
    []
  );

  return (
    <ThemeProvider theme={darkTheme}>
      <CssBaseline />
      <AppGrid
        sidebarWidth={
          currentMode === "debugger"
            ? showDebuggerSidebar
              ? debuggerSidebarWidth
              : 0
            : currentMode === "scanner"
              ? scannerSidebarWidth
              : currentMode === "home"
                ? sidebarWidth
                : 0
        }
        showRegisters={isInBreakState && currentMode === "debugger"}
        registerWidth={registerWidth}
        data-sidebar-grid
      >
        {/* Header */}
        <Header
          currentMode={currentMode}
          debuggerConnected={debuggerConnected}
          debuggerState={debuggerConnected ? "connected" : "disconnected"}
          serverConnected={serverConnected}
          serverInfo={serverInfo}
          attachedProcess={attachedProcess}
          attachedAppInfo={attachedAppInfo}
          spawnSuspended={spawnSuspended}
          isInBreakState={isInBreakState}
          onModeChange={(mode) => {
            // Update mode using UI actions
            uiActions.setCurrentMode(mode);
            // Also call legacy handler for compatibility
            handleModeChange(mode);
          }}
          onLogoClick={() => {
            // Navigate to Home top page
            uiActions.setCurrentMode("home");
            handleModeChange("home");
            setHomeSubPage("home");
          }}
          onResumeApp={() => {
            // Clear spawnSuspended flag when app is resumed
            systemActions.updateField("spawnSuspended", false);
            console.log("App resumed, spawnSuspended flag cleared");
          }}
          showLogsTab={isDevelopment}
          showNetworkTab={isDevelopment}
          showStateTab={isDevelopment}
        />

        {/* Toolbar Area */}
        <ToolbarArea>
          {currentMode === "debugger" && (
            <DebuggerToolbar
              debuggerConnected={debuggerConnected}
              debuggerState={
                isInBreakState
                  ? "debugging"
                  : attachedProcess
                    ? "attached"
                    : "idle"
              }
              visible={showToolbar}
              showRegisters={showRegisters}
              showSidebar={showDebuggerSidebar}
              isInBreakState={isInBreakState}
              currentThreadId={currentThreadId}
              onToggleRegisters={handleToggleRegisters}
              onToggleSidebar={handleToggleDebuggerSidebar}
              onBreakStateChange={(isBreaking: boolean) => {
                const stackTrace = new Error().stack;
                console.log(
                  `[MAINAPP] DebuggerToolbar onBreakStateChange: ${isBreaking}`
                );
                console.log(
                  `[MAINAPP] DebuggerToolbar call from:`,
                  stackTrace?.split("\n")[2]?.trim()
                );
                systemActions.updateDebugState(
                  isBreaking,
                  currentThreadId || undefined,
                  isBreaking ? currentBreakAddress || undefined : undefined
                );
              }}
              attachedProcess={
                attachedProcess
                  ? {
                      pid: attachedProcess.pid,
                      name: attachedProcess.processname || "Unknown Process",
                    }
                  : undefined
              }
              attachedModules={attachedModules} // Pass attached modules for library+offset parsing
              connectionHost={connectionHost || undefined}
              connectionPort={connectionPort || undefined}
              targetOs={serverInfo?.target_os}
              breakpointInputValue={breakpointInputValue}
              onBreakpointInputChange={updateBreakpointInputValue}
              isSoftwareBreakpoint={isSoftwareBreakpoint}
              onBreakpointTypeChange={setIsSoftwareBreakpoint}
              onLastActionChange={setLastDebugAction}
              onGoToAddress={(address) => {
                // Navigate to address in assembly view
                console.log("Navigate to address:", address);
                // Directly update assembly address
                updateAssemblyAddress(address);
              }}
              onSetBreakpoint={async (address, isSoftware) => {
                try {
                  const apiClient = getApiClient();
                  const addressNum = parseInt(address.replace("0x", ""), 16);

                  if (isNaN(addressNum)) {
                    console.error("Invalid address format:", address);
                    return;
                  }

                  console.log(
                    "TOOLBAR: Setting breakpoint at:",
                    address,
                    "software:",
                    isSoftware
                  );
                  const response = await apiClient.setBreakpoint({
                    address: addressNum,
                    hit_count: 0,
                    is_software: isSoftware ?? false,
                  });

                  if (response.success) {
                    console.log("Breakpoint set successfully at:", address);
                    // Add to active breakpoints list with type info
                    addActiveBreakpoint(address, isSoftware ?? false);
                  } else {
                    console.error(
                      "Failed to set breakpoint:",
                      response.message
                    );
                  }
                } catch (error) {
                  console.error("Error setting breakpoint:", error);
                }
              }}
              onRemoveBreakpoint={async (address) => {
                try {
                  const apiClient = getApiClient();
                  const addressNum = parseInt(address.replace("0x", ""), 16);

                  if (isNaN(addressNum)) {
                    console.error("Invalid address format:", address);
                    return;
                  }

                  console.log("TOOLBAR: Removing breakpoint at:", address);
                  const response = await apiClient.removeBreakpoint({
                    address: addressNum,
                  });

                  if (response.success) {
                    console.log("Breakpoint removed successfully at:", address);
                    // Remove from active breakpoints list
                    removeActiveBreakpoint(address);
                  } else {
                    console.error(
                      "Failed to remove breakpoint:",
                      response.message
                    );
                  }
                } catch (error) {
                  console.error("Error removing breakpoint:", error);
                }
              }}
              onRemoveBreakpoints={async (addresses) => {
                try {
                  const apiClient = getApiClient();
                  for (const address of addresses) {
                    const addressNum = parseInt(address.replace("0x", ""), 16);
                    if (!isNaN(addressNum)) {
                      const response = await apiClient.removeBreakpoint({
                        address: addressNum,
                      });
                      if (response.success) {
                        removeActiveBreakpoint(address);
                      }
                    }
                  }
                  console.log(`Bulk removed ${addresses.length} breakpoints`);
                } catch (error) {
                  console.error("Error bulk removing breakpoints:", error);
                }
              }}
              breakpoints={activeBreakpoints}
              softwareBreakpoints={softwareBreakpoints ?? []}
              onSwitchThread={(threadId, exception) => {
                console.log(
                  `[MAINAPP] Switching to thread ${threadId}`,
                  exception
                );

                // Update the current thread ID
                systemActions.updateDebugState(
                  true, // Stay in break state
                  threadId, // New thread ID
                  exception.address || undefined
                );

                // Update register data from the exception
                if (exception) {
                  const registerData: Record<string, string> = {};

                  // Detect architecture based on available registers
                  const isX86_64 =
                    (exception as any).rax !== undefined ||
                    (exception as any).rip !== undefined;

                  const registerFields = isX86_64
                    ? [
                        // x86_64 registers
                        "rax",
                        "rbx",
                        "rcx",
                        "rdx",
                        "rsi",
                        "rdi",
                        "rbp",
                        "rsp",
                        "r8",
                        "r9",
                        "r10",
                        "r11",
                        "r12",
                        "r13",
                        "r14",
                        "r15",
                        "rip",
                        "rflags",
                        "cs",
                        "ss",
                        "ds",
                        "es",
                        "fs",
                        "gs",
                      ]
                    : [
                        // ARM64 registers
                        "x0",
                        "x1",
                        "x2",
                        "x3",
                        "x4",
                        "x5",
                        "x6",
                        "x7",
                        "x8",
                        "x9",
                        "x10",
                        "x11",
                        "x12",
                        "x13",
                        "x14",
                        "x15",
                        "x16",
                        "x17",
                        "x18",
                        "x19",
                        "x20",
                        "x21",
                        "x22",
                        "x23",
                        "x24",
                        "x25",
                        "x26",
                        "x27",
                        "x28",
                        "x29",
                        "lr",
                        "fp",
                        "sp",
                        "pc",
                        "cpsr",
                      ];

                  registerFields.forEach((field) => {
                    const value = (exception as any)[field];
                    if (value !== undefined && value !== null) {
                      if (typeof value === "number") {
                        registerData[field.toUpperCase()] =
                          `0x${value.toString(16).padStart(16, "0")}`;
                      } else if (typeof value === "string") {
                        registerData[field.toUpperCase()] = value;
                      }
                    }
                  });

                  if (Object.keys(registerData).length > 0) {
                    systemActions.updateDebugState(
                      true,
                      threadId,
                      exception.address,
                      registerData
                    );
                  }
                }

                // Navigate assembly view to the exception address
                if (exception.address && exception.address !== "unknown") {
                  const address = exception.address.startsWith("0x")
                    ? exception.address
                    : `0x${exception.address}`;
                  updateAssemblyAddress(address);
                }

                console.log(`[MAINAPP] Thread switch complete to ${threadId}`);
              }}
            />
          )}
          {currentMode === "scanner" && (
            <ScannerToolbar
              visible={showToolbar}
              onFirstScan={performFirstScan}
            />
          )}
        </ToolbarArea>

        {/* Main Content Area */}
        {currentMode === "home" ? (
          <>
            {/* Home Page with Sidebar */}
            <HomeSidebar
              currentSubPage={homeSubPage}
              onSubPageChange={setHomeSubPage}
              unreadNewsCount={unreadNewsCount}
            />
            {homeSubPage === "help" ? (
              <HelpContent />
            ) : homeSubPage === "news" ? (
              <NewsContent onUnreadCountChange={setUnreadNewsCount} />
            ) : homeSubPage === "documentation" ? (
              <DocumentationContent />
            ) : homeSubPage === "about" ? (
              <AboutContent />
            ) : homeSubPage === "settings" ? (
              <SettingsContent />
            ) : (
              <HomePage
                serverConnected={serverConnected}
                serverInfo={serverInfo}
                attachedProcess={attachedProcess}
                onModeChange={handleModeChange}
                onConnect={() => handleModeChange("server")}
                onAttachProcess={() => handleModeChange("server")}
                onAboutClick={() => setHomeSubPage("about")}
                onDetachProcess={() => {
                  // Clear process state (explicitly set to null)
                  systemActions.updateField("attachedProcess", null);
                  systemActions.updateField("attachedAppInfo", null);

                  // Clear debug state when detaching from process
                  systemActions.updateField("isInBreakState", false);
                  systemActions.updateField("currentThreadId", null);
                  systemActions.updateField("currentBreakAddress", null);
                  systemActions.updateField("currentRegisterData", {});

                  // Clear breakpoints and watchpoints when detaching from process
                  systemActions.updateField("activeBreakpoints", []);
                  systemActions.updateField("softwareBreakpoints", []);
                  systemActions.updateField("watchpoints", []);

                  // Clear modules
                  systemActions.updateField("attachedModules", []);

                  // Clear symbol cache
                  clearSymbolCache();

                  console.log(
                    "All debug state cleared due to process detach from HomePage"
                  );

                  handleModeChange("server");
                }}
                connectionHost={connectionHost || "localhost"}
                connectionPort={connectionPort || 8080}
                isConnecting={false}
              />
            )}
          </>
        ) : isDevelopment && currentMode === "state" ? (
          <>
            {/* Development State Monitor Mode Layout */}
            <StatePanel />
          </>
        ) : currentMode === "debugger" ? (
          <>
            {/* Debugger Mode Layout - With Optional Sidebar */}
            {showDebuggerSidebar && (
              <DebuggerSidebar
                activeFunction=""
                onFunctionClick={(functionName, functionAddress) => {
                  console.log(
                    `Function clicked: ${functionName} at ${functionAddress}`
                  );
                  if (functionAddress) {
                    updateAssemblyAddress(functionAddress);
                  }
                }}
                onModuleClick={(module) => {
                  console.log("Module clicked:", module);
                }}
              />
            )}
            <DebuggerContent
              serverInfo={serverInfo}
              onBreakpointInputSet={(address) => {
                // Only set input value, don't add to active breakpoints automatically
                updateBreakpointInputValue(address);
                console.log("Breakpoint input value set to:", address);
              }}
              onBreakpointHit={handleBreakpointHit}
              onRegisterDataUpdate={handleRegisterDataUpdate}
              setCurrentThreadId={(threadId: number | null) => {
                systemActions.updateDebugState(
                  isInBreakState,
                  threadId || undefined
                );
              }}
              currentBreakAddress={currentBreakAddress}
              onBreakStateChange={(isBreaking: boolean) => {
                const stackTrace = new Error().stack;
                console.log(
                  `[MAINAPP] DebuggerContent onBreakStateChange called with: ${isBreaking}`
                );
                console.log(
                  `[MAINAPP] Call from:`,
                  stackTrace?.split("\n")[2]?.trim()
                );
                console.log(
                  `[MAINAPP] Current isInBreakState before: ${isInBreakState}`
                );

                // Don't override break state if we just hit a breakpoint
                // Check if this is called shortly after a breakpoint hit
                const now = Date.now();
                const timeSinceLastBreakpoint =
                  now - (window as any).__lastBreakpointHitTime || 0;

                if (isBreaking === false && timeSinceLastBreakpoint < 1000) {
                  console.log(
                    `[MAINAPP] Ignoring onBreakStateChange(false) - recent breakpoint hit (${timeSinceLastBreakpoint}ms ago)`
                  );
                  return;
                }

                // Update debug state through Tauri instead of direct local state
                console.log(
                  `[MAINAPP] Updating debug state through Tauri: isInBreakState=${isBreaking}`
                );
                systemActions.updateDebugState(
                  isBreaking,
                  currentThreadId || undefined,
                  isBreaking ? currentBreakAddress || undefined : undefined
                );

                // Add a small delay to check if state actually updated
                setTimeout(() => {
                  console.log(
                    `[MAINAPP] isInBreakState after update (delayed check): ${isInBreakState}`
                  );
                }, 100);
              }}
              lastDebugAction={lastDebugAction}
              isInBreakState={isInBreakState}
              isSoftwareBreakpoint={isSoftwareBreakpoint}
              breakpointNotification={breakpointNotification}
              activeBreakpoints={activeBreakpoints}
              softwareBreakpoints={softwareBreakpoints ?? []}
              onAssemblyAddressChange={updateAssemblyAddress}
              onShowBreakpointNotification={showBreakpointNotification}
              onHideBreakpointNotification={hideBreakpointNotification}
              onAddActiveBreakpoint={addActiveBreakpoint}
              onRemoveActiveBreakpoint={removeActiveBreakpoint}
              registerData={currentRegisterData}
              currentThreadId={currentThreadId}
              memoryAddress={memoryAddress}
              onMemoryAddressChange={updateMemoryAddress}
              attachedModules={attachedModules}
              resolveFunctionName={resolveFunctionName}
            />
          </>
        ) : currentMode === "information" ? (
          <>
            {/* Information Mode Layout - Full width like server mode */}
            <InformationContent
              attachedModules={attachedModules}
              currentTab={informationCurrentTab}
              onTabChange={setInformationCurrentTab}
              nameFilter={modulesNameFilter}
              onNameFilterChange={setModulesNameFilter}
              sortField={modulesSortField as "baseAddress" | "size" | null}
              sortDirection={modulesSortDirection}
              onSortChange={handleModulesSortChange}
              serverInfo={serverInfo}
              onRefreshModules={async () => {
                if (attachedProcess) {
                  try {
                    const apiClient = getApiClient();
                    const response = await apiClient.enumerateModules();
                    if (response.data?.modules) {
                      console.log("Refreshed modules:", response.data.modules);
                      handleModulesUpdate(response.data.modules);
                    }
                  } catch (error) {
                    console.error("Failed to refresh modules:", error);
                  }
                }
              }}
            />
          </>
        ) : currentMode === "scanner" ? (
          <>
            {/* Scanner Mode Layout */}
            <ScannerSidebar
              memoryRegionsLoaded={memoryRegionsLoaded}
              onScanSettingsChange={handleScanSettingsChange}
              onFirstScan={performFirstScan}
              onNextScan={performNextScan}
              onNewScan={performNewScan}
              onClearScan={clearScan}
            />
            <ScannerContent
              scanResults={scanResults}
              isScanning={scannerState.isScanning}
              scanProgress={scannerState.scanProgress}
              totalResults={scannerState.totalResults}
              scannedBytes={scannerState.scannedBytes}
              totalBytes={scannerState.totalBytes}
              currentRegion={scannerState.currentRegion || undefined}
              currentScanId={scannerState.scanId || undefined}
              onResultEdit={handleResultEdit}
              onResultDelete={handleResultDelete}
              onResultBookmark={handleResultBookmark}
              onStopScan={stopScan}
              onMemoryRead={handleMemoryRead}
              bookmarks={bookmarks}
              onAddManualBookmark={addManualBookmark}
              onUpdateBookmark={updateBookmark}
              onRemoveBookmark={removeBookmark}
              isAddressBookmarked={isAddressBookmarked}
              attachedModules={attachedModules}
              onSetWatchpoint={handleSetWatchpoint}
              onRemoveWatchpoint={handleRemoveWatchpoint}
              scanHistory={globalScanHistory}
              onSelectHistory={handleSelectHistory}
              onRemoveHistoryItem={onRemoveHistoryItem}
              onClearHistory={onClearHistory}
              currentTab={scannerCurrentTab}
              onTabChange={setScannerCurrentTab}
              onExecuteHistorySearch={handleExecuteHistorySearch}
            />
          </>
        ) : currentMode === "tools" ? (
          <>
            {/* Tools Mode Layout */}
            <ToolsContent
              serverConnected={serverConnected}
              serverInfo={serverInfo}
            />
          </>
        ) : (
          <>
            {/* Server Mode Layout - spans full width */}
            <ServerContent onModulesUpdate={handleModulesUpdate} />
          </>
        )}

        {/* Register Panel - Only show in debugger mode when in break state */}
        {React.useMemo(() => {
          const shouldShow = isInBreakState && currentMode === "debugger";

          return shouldShow ? (
            <RegisterView
              open={isInBreakState}
              registerData={currentRegisterData}
              isInBreakState={isInBreakState}
              currentThreadId={currentThreadId}
              onWidthChange={setRegisterWidth}
            />
          ) : null;
        }, [
          isInBreakState,
          currentMode,
          currentRegisterData,
          currentThreadId,
          setRegisterWidth,
        ])}

        {/* Status Bar */}
        <StatusBarComponent
          currentMode={currentMode}
          debuggerConnected={debuggerConnected}
          serverConnected={serverConnected}
          connectionHost={connectionHost || undefined}
          connectionPort={connectionPort || undefined}
          lastHealthCheck={lastHealthCheck}
          attachedProcess={attachedProcess}
          attachedAppInfo={attachedAppInfo}
          currentBreakAddress={currentBreakAddress}
          isInBreakState={isInBreakState}
        />

        {/* Snackbar for notifications */}
        <Snackbar
          open={snackbar.open}
          autoHideDuration={6000}
          onClose={() => setSnackbar({ ...snackbar, open: false })}
          anchorOrigin={{ vertical: "bottom", horizontal: "center" }}
        >
          <Alert
            onClose={() => setSnackbar({ ...snackbar, open: false })}
            severity={snackbar.severity}
            variant="filled"
            sx={{ width: "100%" }}
          >
            {snackbar.message}
          </Alert>
        </Snackbar>
      </AppGrid>
    </ThemeProvider>
  );
};

// Main App component wrapped with DebugLoggerProvider
// Main App component wrapped with providers
export const MainApp: React.FC = () => {
  return (
    <DebugLoggerProvider>
      <AppWithExceptionHandler />
    </DebugLoggerProvider>
  );
};

// Wrapper component to provide connection state to global exception handler
const AppWithExceptionHandler: React.FC = () => {
  // Use the new integrated state management (Tauri singleton)
  const { system, systemActions } = useAppState();

  const { serverConnected, debuggerConnected, attachedProcess, watchpoints } =
    system;

  // State bridge for breakpoint handling
  const [lastBreakpointException, setLastBreakpointException] =
    React.useState<any>(null);

  // Handle connection state changes from AppContent
  const handleConnectionStateChange = React.useCallback(
    (connected: boolean, debuggerConn: boolean, process?: ProcessInfo) => {
      // No longer need to update global store directly since we have the new state management
      console.log("Connection state changed:", {
        connected,
        debuggerConn,
        process,
      });
    },
    []
  );

  // Handle breakpoint state changes from AppContent
  const handleBreakpointStateChange = React.useCallback(
    (hasBreakpoints: boolean) => {
      console.log("[EXCEPTION HANDLER] Breakpoint state change:", {
        hasBreakpoints,
      });
      setHasActiveBreakpoints((prev) => {
        if (prev !== hasBreakpoints) {
          console.log("[EXCEPTION HANDLER] Updating hasActiveBreakpoints:", {
            from: prev,
            to: hasBreakpoints,
          });
          return hasBreakpoints;
        }
        return prev;
      });
    },
    []
  );

  // Calculate derived connection states
  const isConnected = serverConnected && debuggerConnected;
  const isProcessAttached = !!attachedProcess;

  // Handle breakpoint hit from global exception handler - moved here from AppContent
  const handleGlobalBreakpointHit = React.useCallback((exception: any) => {
    console.log("[GLOBAL BREAKPOINT] Breakpoint hit:", exception);
    // Set the exception data so AppContent can process it
    setLastBreakpointException(exception);
  }, []);

  // Handle script breakpoint events (from Lua scripts Debug.set_breakpoint/remove_breakpoint)
  const handleScriptBreakpoint = React.useCallback(
    (event: ScriptBreakpointEvent) => {
      const addressHex = `0x${event.address.toString(16)}`;
      console.log(
        `[AppWithExceptionHandler] Script breakpoint ${event.action}: ${addressHex}`,
        event
      );

      try {
        if (event.action === "set") {
          // Add breakpoint to UI state using React state management
          const isSoftware = event.bp_type === "soft";
          systemActions.addBreakpoint(addressHex, isSoftware);
          console.log(
            `[AppWithExceptionHandler] Added script breakpoint at ${addressHex} (${event.bp_type})`
          );
        } else if (event.action === "remove") {
          // Remove breakpoint from UI state using React state management
          systemActions.removeBreakpoint(addressHex);
          console.log(
            `[AppWithExceptionHandler] Removed script breakpoint at ${addressHex}`
          );
        }
      } catch (error) {
        console.error(
          "[AppWithExceptionHandler] Failed to update breakpoint:",
          error
        );
      }
    },
    [systemActions]
  );

  // Debug logging for connection state (reduced frequency)
  useEffect(() => {
    console.log("AppWithExceptionHandler: Connection state changed", {
      serverConnected,
      debuggerConnected,
      isConnected,
      attachedProcess: !!attachedProcess,
      isProcessAttached,
      timestamp: new Date().toISOString(),
    });
  }, [serverConnected, debuggerConnected, isConnected, isProcessAttached]);

  // Track active breakpoints dynamically
  const [hasActiveBreakpoints, setHasActiveBreakpoints] = React.useState(false);

  // Calculate hasActiveWatchpoints directly from system.watchpoints
  const hasActiveWatchpoints = (watchpoints?.length ?? 0) > 0;

  // Create options object that will be recreated when dependencies change
  const options = React.useMemo(
    () => ({
      autoStart: true, // 常に自動開始
      isConnected, // serverConnected && debuggerConnectedを使用
      isProcessAttached, // attachedProcessの存在をチェック
      hasActiveWatchpoints, // 動的に追跡
      hasActiveBreakpoints, // ハードウェアブレークポイントは常に監視（サーバー側で管理されているため）
      pollingInterval: 100, // シングルステップ検出を高速化
      enableWatchpoints: true,
      enableBreakpoints: true,
      onBreakpointHit: handleGlobalBreakpointHit,
      onScriptBreakpoint: handleScriptBreakpoint,
    }),
    [
      isConnected,
      isProcessAttached,
      hasActiveWatchpoints,
      hasActiveBreakpoints,
      handleGlobalBreakpointHit,
      handleScriptBreakpoint,
    ]
  );

  return (
    <GlobalExceptionHandlerProvider options={options}>
      <AppContent
        onConnectionStateChange={handleConnectionStateChange}
        onBreakpointHit={lastBreakpointException}
        onBreakpointStateChange={handleBreakpointStateChange}
      />
    </GlobalExceptionHandlerProvider>
  );
};

```

`src/client/src/components/MemoryView.tsx`:

```tsx
import React, {
  useState,
  useEffect,
  useCallback,
  useMemo,
  useRef,
} from "react";
import {
  Box,
  Typography,
  TextField,
  IconButton,
  Tooltip,
  styled,
  Chip,
  Table,
  TableHead,
  TableBody,
  TableRow,
  TableCell,
  Autocomplete,
  Paper,
  Select,
  MenuItem,
} from "@mui/material";
import {
  Refresh,
  ViewInAr as MemoryIcon,
  MyLocation,
} from "@mui/icons-material";
import { getApiClient, ServerInfo, ModuleInfo } from "../lib/api";
import { StackView } from "./StackView";
import { Resizer } from "./Resizer";
import { useAppState } from "../hooks/useAppState";
import { useResizable } from "../hooks/useResizable";
import {
  normalizeAddressString,
  isLibraryExpression,
} from "../utils/addressEncoder";

// Styled components for modern design
const MainContainer = styled(Box)(() => ({
  height: "100%",
  display: "flex",
  flexDirection: "row",
  backgroundColor: "#1e1e1e",
  position: "relative",
}));

const MemoryViewContainer = styled(Box)(() => ({
  height: "100%",
  display: "flex",
  flexDirection: "column",
  backgroundColor: "#1e1e1e",
  position: "relative",
  overflow: "hidden",
}));

const MemoryHeader = styled(Box)(() => ({
  display: "flex",
  alignItems: "center",
  gap: "8px",
  padding: "8px 12px",
  backgroundColor: "#252526",
  borderBottom: "1px solid #2d2d30",
  minHeight: "48px",
  height: "48px", // 固定の高さを設定（ラベル用に高さを確保）
  "@media (max-height: 800px)": {
    padding: "4px 8px",
    minHeight: "36px",
    height: "36px",
    gap: "4px",
  },
}));

const MemoryTable = styled(Table)(() => ({
  backgroundColor: "#1a1a1a",
  tableLayout: "auto", // 自動レイアウトで内部要素に合わせる
  width: "fit-content", // テーブル幅を内部要素に合わせる
  "& .MuiTableCell-root": {
    borderBottom: "1px solid #2d2d30",
    padding: "2px 4px",
    fontSize: "11px",
    fontFamily: "monospace",
    color: "#d4d4d4",
  },
  "& .MuiTableHead-root .MuiTableCell-root": {
    backgroundColor: "#252526",
    color: "#4fc1ff", // ヘッダーを青色に
    fontWeight: 600,
    fontSize: "10px",
    padding: "4px",
    position: "sticky",
    top: 0,
    zIndex: 1,
    borderBottom: "1px solid #2d2d30",
  },
  // 右上角丸（ヘッダーの最後のセル）
  "& .MuiTableHead-root .MuiTableRow-root .MuiTableCell-root:last-child": {
    borderTopRightRadius: "4px",
  },
  // 右下角丸（最後の行の最後のセル）
  "& .MuiTableBody-root .MuiTableRow-root:last-child .MuiTableCell-root:last-child":
    {
      borderBottomRightRadius: "4px",
    },
  "& .MuiTableBody-root .MuiTableRow-root": {
    minHeight: "18px", // 行の最小高さを設定
    "&:hover": {
      backgroundColor: "rgba(79, 193, 255, 0.08)", // ホバー色を調整
    },
    "& .MuiTableCell-root": {
      padding: "1px 4px", // セル内のパディングをコンパクトに
    },
  },
  "@media (max-height: 800px)": {
    "& .MuiTableCell-root": {
      padding: "1px 2px",
      fontSize: "9px",
    },
    "& .MuiTableHead-root .MuiTableCell-root": {
      fontSize: "8px",
      padding: "2px",
    },
    "& .MuiTableBody-root .MuiTableRow-root": {
      minHeight: "14px",
      "& .MuiTableCell-root": {
        padding: "0px 2px",
      },
    },
  },
}));

const MemoryTableWrapper = styled(Box)(() => ({
  margin: "8px",
  backgroundColor: "#1a1a1a",
  border: "1px solid #2d2d30",
  borderRadius: "4px",
  height: "calc(100% - 16px)",
  overflow: "hidden",
  display: "flex",
  flexDirection: "column",
  "@media (max-height: 800px)": {
    margin: "4px",
    height: "calc(100% - 8px)",
  },
}));

const MemoryTableContainer = styled(Box)(() => ({
  flex: 1,
  overflow: "hidden", // スクロールバーを完全に無効化
}));

const AddressCell = styled(TableCell)(() => ({
  width: "fit-content",
  fontWeight: "normal",
  padding: "2px 12px 2px 4px", // 右側に間隔を追加
  borderRight: "1px solid #2d2d30",
  // ヘッダーとデータ行で色を分ける
  "&.MuiTableCell-head": {
    color: "#4fc1ff", // ヘッダーは青色
  },
  "&.MuiTableCell-body": {
    color: "#4fc1ff", // データ行のアドレスも青色
  },
}));

const HexCell = styled(TableCell)(() => ({
  width: "fit-content",
  padding: "2px 8px 2px 0px", // 右側に間隔を追加
  borderRight: "1px solid #2d2d30",
  "@media (max-height: 800px)": {
    padding: "1px 6px 1px 0px",
  },
}));

const HexByte = styled(Box, {
  shouldForwardProp: (prop) => prop !== "isZero",
})<{ isZero?: boolean }>(({ isZero }) => ({
  display: "inline-block",
  width: "22px", // 少し幅を広げて余裕を持たせる
  textAlign: "center",
  color: isZero ? "#555" : "#dcdcaa",
  cursor: "pointer",
  padding: "1px 1px",
  borderRadius: "2px",
  transition: "background-color 0.1s ease",
  marginRight: "0px",
  "&:hover": {
    backgroundColor: "rgba(255, 255, 255, 0.1)",
  },
  "@media (max-height: 800px)": {
    width: "16px",
    padding: "0px 0px",
    marginRight: "0px",
  },
}));

const AsciiCell = styled(TableCell)(() => ({
  minWidth: "120px", // 16 characters for monospace
  width: "120px",
  color: "#ce9178",
  fontFamily: "monospace",
  whiteSpace: "pre",
  backgroundColor: "rgba(206, 145, 120, 0.05)",
  padding: "2px 0px 2px 2px",
  "@media (max-height: 800px)": {
    padding: "1px 0px 1px 0px",
  },
}));

const StatusChip = styled(Chip)<{ active?: boolean }>(({ active }) => ({
  height: "20px",
  fontSize: "9px",
  fontWeight: 600,
  cursor: "pointer",
  backgroundColor: active
    ? "rgba(76, 175, 80, 0.15)"
    : "rgba(158, 158, 158, 0.15)",
  color: active ? "#4caf50" : "#9e9e9e",
  border: active
    ? "1px solid rgba(76, 175, 80, 0.3)"
    : "1px solid rgba(158, 158, 158, 0.3)",
  "&:hover": {
    backgroundColor: active
      ? "rgba(76, 175, 80, 0.25)"
      : "rgba(158, 158, 158, 0.25)",
  },
  "& .MuiChip-label": {
    padding: "0 6px",
  },
}));

// LocalStorage key for Go to history
const MEMORY_GOTO_HISTORY_KEY = "memory_view_goto_history";
const MEMORY_DISPLAY_MODE_KEY = "memory_view_display_mode";
const MAX_HISTORY_ITEMS = 5;

// Display mode types
type MemoryDisplayMode =
  | "hex"
  | "uint8"
  | "int8"
  | "uint16"
  | "int16"
  | "uint32"
  | "int32"
  | "uint64"
  | "int64"
  | "float32"
  | "float64";

// Display mode configuration
const DISPLAY_MODE_CONFIG: Record<
  MemoryDisplayMode,
  { label: string; bytesPerValue: number; maxWidth: string }
> = {
  hex: { label: "Hex", bytesPerValue: 1, maxWidth: "22px" },
  uint8: { label: "U8", bytesPerValue: 1, maxWidth: "32px" },
  int8: { label: "I8", bytesPerValue: 1, maxWidth: "36px" },
  uint16: { label: "U16", bytesPerValue: 2, maxWidth: "52px" },
  int16: { label: "I16", bytesPerValue: 2, maxWidth: "56px" },
  uint32: { label: "U32", bytesPerValue: 4, maxWidth: "96px" },
  int32: { label: "I32", bytesPerValue: 4, maxWidth: "100px" },
  uint64: { label: "U64", bytesPerValue: 8, maxWidth: "180px" },
  int64: { label: "I64", bytesPerValue: 8, maxWidth: "180px" },
  float32: { label: "F32", bytesPerValue: 4, maxWidth: "110px" },
  float64: { label: "F64", bytesPerValue: 8, maxWidth: "180px" },
};

// Global memory cache to persist across tab switches
const globalMemoryCache = new Map<string, ArrayBuffer>();
let globalAutoRefresh = true;

interface MemoryViewProps {
  serverInfo?: ServerInfo;
  onAddressChange?: (address: string) => void;
  // StackViewに渡すための追加props
  registerData?: Record<string, string>; // レジスタデータ
  isInBreakState?: boolean; // ブレーク状態
  currentThreadId?: number | null; // 現在のスレッドID
  attachedModules?: ModuleInfo[]; // モジュール情報（library+offset解析用）
  resolveFunctionName?: (libraryPath: string, offset: number) => string | null; // 関数名解決
}

export const MemoryView: React.FC<MemoryViewProps> = ({
  onAddressChange,
  registerData = {},
  isInBreakState = false,
  currentThreadId = null,
  attachedModules = [],
  resolveFunctionName,
}) => {
  // Container ref for resize calculations
  const containerRef = useRef<HTMLDivElement>(null);

  // Horizontal resizer for Memory vs Stack split
  const memoryStackSplit = useResizable({
    storageKey: "memory-stack-split",
    defaultSize: 55, // Default to 55% for memory, 45% for stack
    minSize: 30,
    maxSize: 55, // Memory テーブル幅に合わせて制限（広がりすぎないように）
    orientation: "horizontal",
    containerRef,
  });

  // Use the new app state for persistent state across tab switches
  const { ui, uiActions } = useAppState();

  // Memory view uses app state
  const [currentAddress, setCurrentAddress] = useState(
    ui.debuggerState.memoryCurrentAddress
  );
  const [inputAddress, setInputAddress] = useState(
    ui.debuggerState.memoryInputAddress
  );
  const [memoryData, setMemoryData] = useState<ArrayBuffer | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [autoRefresh, setAutoRefresh] = useState(globalAutoRefresh);
  const [gotoHistory, setGotoHistory] = useState<string[]>([]);
  const [displayMode, setDisplayMode] = useState<MemoryDisplayMode>(() => {
    try {
      const saved = localStorage.getItem(MEMORY_DISPLAY_MODE_KEY);
      return (saved as MemoryDisplayMode) || "hex";
    } catch {
      return "hex";
    }
  });
  const refreshIntervalRef = useRef<number | null>(null);

  // Save display mode to localStorage
  useEffect(() => {
    try {
      localStorage.setItem(MEMORY_DISPLAY_MODE_KEY, displayMode);
    } catch (e) {
      console.error("Failed to save display mode:", e);
    }
  }, [displayMode]);

  // Load history from localStorage on mount
  useEffect(() => {
    try {
      const saved = localStorage.getItem(MEMORY_GOTO_HISTORY_KEY);
      if (saved) {
        setGotoHistory(JSON.parse(saved));
      }
    } catch (e) {
      console.error("Failed to load memory goto history:", e);
    }
  }, []);

  // Save history to localStorage
  const saveHistory = useCallback((history: string[]) => {
    try {
      localStorage.setItem(MEMORY_GOTO_HISTORY_KEY, JSON.stringify(history));
    } catch (e) {
      console.error("Failed to save memory goto history:", e);
    }
  }, []);

  // Add address to history
  const addToHistory = useCallback(
    (address: string) => {
      setGotoHistory((prev) => {
        const filtered = prev.filter(
          (a) => a.toLowerCase() !== address.toLowerCase()
        );
        const newHistory = [address, ...filtered].slice(0, MAX_HISTORY_ITEMS);
        saveHistory(newHistory);
        return newHistory;
      });
    },
    [saveHistory]
  );

  const scrollTimeoutRef = useRef<number | null>(null);
  const scrollContainerRef = useRef<HTMLDivElement | null>(null);
  const lastScrollTop = useRef<number>(0);

  // Number of bytes to read per row (16 bytes = x64dbg style)
  const BYTES_PER_ROW = 16;
  const TOTAL_ROWS = 32; // Show 32 rows = 512 bytes
  const TOTAL_BYTES = BYTES_PER_ROW * TOTAL_ROWS;

  // Load memory data from server with caching
  const loadMemory = useCallback(
    async (addr: string, isAutoRefresh = false) => {
      if (!addr) return; // 空文字のみをチェック、0x0は有効なアドレス

      const cacheKey = `${addr}_${TOTAL_BYTES}`;

      // For auto-refresh, always fetch fresh data
      if (isAutoRefresh) {
        try {
          // Save scroll position before updating data
          if (scrollContainerRef.current) {
            lastScrollTop.current = scrollContainerRef.current.scrollTop;
          }

          const apiClient = getApiClient();
          const buffer = await apiClient.readMemory(addr, TOTAL_BYTES);
          setMemoryData(buffer);

          // Update global cache with fresh data
          globalMemoryCache.set(cacheKey, buffer);

          // Restore scroll position after DOM update
          setTimeout(() => {
            if (scrollContainerRef.current) {
              scrollContainerRef.current.scrollTop = lastScrollTop.current;
            }
          }, 0);
        } catch (err) {
          console.error("Failed to read memory during auto-refresh:", err);
        }
        return;
      }

      // Check global cache first for smooth scrolling
      if (globalMemoryCache.has(cacheKey)) {
        const cachedData = globalMemoryCache.get(cacheKey);
        if (cachedData) {
          setMemoryData(cachedData);
          return;
        }
      }

      try {
        // Don't clear existing data immediately to prevent flickering
        // setLoading(true); // Skip loading state for smoother experience
        setError(null);

        const apiClient = getApiClient();
        const buffer = await apiClient.readMemory(addr, TOTAL_BYTES);

        // Update memory data and force refresh
        setMemoryData(buffer);

        // Update global cache
        globalMemoryCache.set(cacheKey, buffer);

        // Keep cache size manageable (max 50 entries for better coverage)
        if (globalMemoryCache.size > 50) {
          const firstKey = globalMemoryCache.keys().next().value;
          if (firstKey) {
            globalMemoryCache.delete(firstKey);
          }
        }
      } catch (err) {
        console.error("Failed to read memory:", err);
        setError(err instanceof Error ? err.message : "Failed to read memory");
        // Don't clear memoryData on error to maintain display
      } finally {
        setLoading(false);
      }
    },
    [TOTAL_BYTES]
  );

  // Prefetch adjacent memory blocks for smooth scrolling
  const prefetchAdjacentMemory = useCallback(
    async (addr: string) => {
      if (!addr) return; // 空文字のみをチェック、0x0は有効なアドレス

      const currentAddr = parseInt(addr, 16);

      // Prefetch more blocks for smoother large movements
      const prefetchAddresses = [];

      // Prefetch 5 blocks in each direction for better coverage
      for (let i = 1; i <= 5; i++) {
        const prevAddr = Math.max(0, currentAddr - TOTAL_BYTES * i);
        const nextAddr = currentAddr + TOTAL_BYTES * i;
        prefetchAddresses.push(prevAddr, nextAddr);
      }

      for (const prefetchAddr of prefetchAddresses) {
        const prefetchAddrStr = `0x${prefetchAddr
          .toString(16)
          .toUpperCase()
          .padStart(16, "0")}`;
        const cacheKey = `${prefetchAddrStr}_${TOTAL_BYTES}`;

        if (!globalMemoryCache.has(cacheKey)) {
          try {
            const apiClient = getApiClient();
            const buffer = await apiClient.readMemory(
              prefetchAddrStr,
              TOTAL_BYTES
            );

            globalMemoryCache.set(cacheKey, buffer);

            // Increase cache limit for better coverage
            if (globalMemoryCache.size > 100) {
              const firstKey = globalMemoryCache.keys().next().value;
              if (firstKey) {
                globalMemoryCache.delete(firstKey);
              }
            }
          } catch (err) {
            // Ignore prefetch errors
            console.warn("Prefetch failed for address:", prefetchAddrStr);
          }
        }
      }
    },
    [TOTAL_BYTES]
  );

  // Load memory when address changes
  useEffect(() => {
    loadMemory(currentAddress);
    // Prefetch adjacent blocks for smooth scrolling
    prefetchAdjacentMemory(currentAddress);
  }, [currentAddress, loadMemory, prefetchAdjacentMemory]);

  // Sync occurs only on component unmount/mount (tab switches)
  // The initial values are set from globalStore in useState initialization

  // Auto-refresh functionality
  useEffect(() => {
    // Clear any existing interval
    if (refreshIntervalRef.current) {
      clearInterval(refreshIntervalRef.current);
      refreshIntervalRef.current = null;
    }

    if (autoRefresh && currentAddress) {
      const interval = setInterval(() => {
        // Only skip auto-refresh if user is actively scrolling (more lenient condition)
        // Note: isScrolling will be false most of the time, allowing normal auto-refresh
        // Remove scrolling check temporarily to test if this is the issue
        // if (isScrolling) {
        //   console.log("Skipping auto-refresh due to scrolling");
        //   return;
        // }

        // Clear cache for current address to force fresh data
        const cacheKey = `${currentAddress}_${TOTAL_BYTES}`;
        globalMemoryCache.delete(cacheKey);

        // Load fresh memory data

        loadMemory(currentAddress, true); // Pass true to indicate auto-refresh
      }, 500); // Refresh every 0.5 seconds

      refreshIntervalRef.current = interval;
    }

    // Cleanup function
    return () => {
      if (refreshIntervalRef.current) {
        clearInterval(refreshIntervalRef.current);
        refreshIntervalRef.current = null;
      }
    };
  }, [autoRefresh, currentAddress, loadMemory, TOTAL_BYTES]); // Remove isScrolling from dependency array

  // Scroll up by one row (16 bytes)
  const scrollUp = useCallback(() => {
    const currentAddr = parseInt(currentAddress, 16);
    const newAddr = Math.max(0, currentAddr - BYTES_PER_ROW);
    const newAddressStr = `0x${newAddr
      .toString(16)
      .toUpperCase()
      .padStart(16, "0")}`;

    // Check if data is already cached for immediate display
    const cacheKey = `${newAddressStr}_${TOTAL_BYTES}`;
    const cachedData = globalMemoryCache.get(cacheKey);

    // Only update current address for memory display, keep input address unchanged
    setCurrentAddress(newAddressStr);
    uiActions.setMemoryCurrentAddress(newAddressStr);

    // If cached, update memory data immediately to prevent any flickering
    if (cachedData) {
      setMemoryData(cachedData);
    }
  }, [currentAddress, BYTES_PER_ROW, TOTAL_BYTES, uiActions]);

  // Scroll down by one row (16 bytes)
  const scrollDown = useCallback(() => {
    const currentAddr = parseInt(currentAddress, 16);
    const newAddr = currentAddr + BYTES_PER_ROW;
    const newAddressStr = `0x${newAddr
      .toString(16)
      .toUpperCase()
      .padStart(16, "0")}`;

    // Check if data is already cached for immediate display
    const cacheKey = `${newAddressStr}_${TOTAL_BYTES}`;
    const cachedData = globalMemoryCache.get(cacheKey);

    // Only update current address for memory display, keep input address unchanged
    setCurrentAddress(newAddressStr);
    uiActions.setMemoryCurrentAddress(newAddressStr);

    // If cached, update memory data immediately to prevent any flickering
    if (cachedData) {
      setMemoryData(cachedData);
    }
  }, [currentAddress, BYTES_PER_ROW, TOTAL_BYTES, uiActions]);

  // Page scroll functions for Page Up/Down keys
  const pageScrollUp = useCallback(() => {
    const currentAddr = parseInt(currentAddress, 16);
    const newAddr = Math.max(0, currentAddr - TOTAL_BYTES);
    const newAddressStr = `0x${newAddr
      .toString(16)
      .toUpperCase()
      .padStart(16, "0")}`;

    // Check if data is already cached for immediate display
    const cacheKey = `${newAddressStr}_${TOTAL_BYTES}`;
    const cachedData = globalMemoryCache.get(cacheKey);

    // If cached, update memory data immediately to prevent flickering
    if (cachedData) {
      setMemoryData(cachedData);
    }

    // Only update current address for memory display, keep input address unchanged
    setCurrentAddress(newAddressStr);
    uiActions.setMemoryCurrentAddress(newAddressStr);
  }, [currentAddress, TOTAL_BYTES, uiActions]);

  const pageScrollDown = useCallback(() => {
    const currentAddr = parseInt(currentAddress, 16);
    const newAddr = currentAddr + TOTAL_BYTES;
    const newAddressStr = `0x${newAddr
      .toString(16)
      .toUpperCase()
      .padStart(16, "0")}`;

    // Check if data is already cached for immediate display
    const cacheKey = `${newAddressStr}_${TOTAL_BYTES}`;
    const cachedData = globalMemoryCache.get(cacheKey);

    // If cached, update memory data immediately to prevent flickering
    if (cachedData) {
      setMemoryData(cachedData);
    }

    // Only update current address for memory display, keep input address unchanged
    setCurrentAddress(newAddressStr);
    uiActions.setMemoryCurrentAddress(newAddressStr);
  }, [currentAddress, TOTAL_BYTES, uiActions]);

  // Add keyboard navigation
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.target instanceof HTMLInputElement) {
        // Don't handle keys when input field is focused
        return;
      }

      let isNavigationKey = false;

      if (e.key === "ArrowUp") {
        e.preventDefault();
        scrollUp();
        isNavigationKey = true;
      } else if (e.key === "ArrowDown") {
        e.preventDefault();
        scrollDown();
        isNavigationKey = true;
      } else if (e.key === "PageUp") {
        e.preventDefault();
        pageScrollUp();
        isNavigationKey = true;
      } else if (e.key === "PageDown") {
        e.preventDefault();
        pageScrollDown();
        isNavigationKey = true;
      }

      // Navigation key was pressed - no additional action needed
      if (isNavigationKey) {
        // Navigation handled by individual functions above
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      // Clean up scroll timeout on unmount
      if (scrollTimeoutRef.current) {
        clearTimeout(scrollTimeoutRef.current);
      }
    };
  }, [scrollUp, scrollDown, pageScrollUp, pageScrollDown]);

  // Handle address input change
  const handleAddressChange = useCallback(
    async (newAddress: string) => {
      try {
        let normalizedAddress: string | null;

        // Check if it's a library+offset expression
        if (isLibraryExpression(newAddress)) {
          // Parse library+offset expression
          normalizedAddress = normalizeAddressString(
            newAddress,
            attachedModules
          );

          if (!normalizedAddress) {
            console.warn(
              "Failed to parse library+offset expression:",
              newAddress
            );
            setError(
              "Failed to parse library+offset expression. Make sure the module is loaded."
            );
            return;
          }

          console.log(
            "[MemoryView] Parsed library+offset:",
            newAddress,
            "->",
            normalizedAddress
          );
        } else {
          // Direct address - normalize
          normalizedAddress = normalizeAddressString(newAddress);

          if (!normalizedAddress) {
            console.warn("Invalid address format:", newAddress);
            setError("Invalid address format");
            return;
          }
        }

        // Ensure uppercase format for consistency
        const addressValue = parseInt(
          normalizedAddress.replace(/^0x/i, ""),
          16
        );
        const formattedAddress = `0x${addressValue.toString(16).toUpperCase().padStart(8, "0")}`;

        console.log(
          "[MemoryView] Address changed:",
          newAddress,
          "->",
          formattedAddress
        );

        // Clear any previous errors
        setError(null);

        // Update both input field and current address to keep them in sync
        setInputAddress(formattedAddress);
        setCurrentAddress(formattedAddress);
        uiActions.setMemoryCurrentAddress(formattedAddress);
        uiActions.setMemoryInputAddress(formattedAddress);
        onAddressChange?.(formattedAddress);

        // Clear cache for new address to force fresh data
        const cacheKey = `${formattedAddress}_${TOTAL_BYTES}`;
        globalMemoryCache.delete(cacheKey);

        // Immediately load memory data for the new address (don't wait for useEffect)
        // This ensures immediate rendering when switching tabs
        await loadMemory(formattedAddress);
      } catch (error) {
        console.error("Error processing address:", newAddress, error);
        setError("Failed to process address");
      }
    },
    [onAddressChange, TOTAL_BYTES, loadMemory, uiActions, attachedModules]
  );

  // Monitor external memory address changes from RegisterView (both props and UI store)
  useEffect(() => {
    // Only handle non-empty addresses
    const handleExternalAddressChange = async () => {
      if (
        ui.debuggerState.memoryAddress &&
        ui.debuggerState.memoryAddress.trim()
      ) {
        console.log(
          "[MemoryView] External address change detected:",
          ui.debuggerState.memoryAddress
        );
        await handleAddressChange(ui.debuggerState.memoryAddress);
        // Clear the external address to avoid repeated triggers
        uiActions.setMemoryAddress("");
      }
    };

    handleExternalAddressChange();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [ui.debuggerState.memoryAddress]); // handleAddressChange is stable, uiActions too

  // Sync autoRefresh state with global
  useEffect(() => {
    globalAutoRefresh = autoRefresh;
  }, [autoRefresh]);

  // Note: inputAddress sync is handled manually in handleAddressChange to avoid infinite loops

  // Handle auto-refresh toggle
  const handleAutoRefreshToggle = useCallback(() => {
    const newAutoRefresh = !autoRefresh;
    setAutoRefresh(newAutoRefresh);
    globalAutoRefresh = newAutoRefresh;
  }, [autoRefresh]);

  const handleWheel = useCallback(
    (e: React.WheelEvent) => {
      e.preventDefault();
      e.stopPropagation();

      // より細かいスクロール制御
      const scrollThreshold = 50; // ピクセル単位でのスクロール閾値

      if (Math.abs(e.deltaY) > scrollThreshold) {
        if (e.deltaY > 0) {
          scrollDown();
        } else {
          scrollUp();
        }
      } else {
        // 小さなスクロールの場合は複数行をスクロール
        if (e.deltaY > 0) {
          scrollDown();
        } else {
          scrollUp();
        }
      }
    },
    [scrollUp, scrollDown]
  );

  // Convert buffer to hex and ASCII display data with memoization
  const displayData = useMemo(() => {
    if (!memoryData) return [];

    const uint8Array = new Uint8Array(memoryData);
    const dataView = new DataView(memoryData);
    const rows = [];
    const baseAddr = parseInt(currentAddress, 16);
    const config = DISPLAY_MODE_CONFIG[displayMode];
    const valuesPerRow = Math.floor(BYTES_PER_ROW / config.bytesPerValue);

    for (let i = 0; i < TOTAL_ROWS; i++) {
      const rowOffset = i * BYTES_PER_ROW;
      const rowAddress = baseAddr + rowOffset;
      const rowBytes = Array.from(
        uint8Array.slice(rowOffset, rowOffset + BYTES_PER_ROW)
      );

      // Generate hex representation (always needed for fallback)
      const hexBytes = rowBytes.map((byte) =>
        byte.toString(16).padStart(2, "0").toUpperCase()
      );

      // Generate values based on display mode
      const values: string[] = [];
      for (let j = 0; j < valuesPerRow; j++) {
        const offset = rowOffset + j * config.bytesPerValue;
        if (offset + config.bytesPerValue > uint8Array.length) break;

        try {
          let value: string;
          switch (displayMode) {
            case "hex":
              value =
                rowBytes[j]?.toString(16).padStart(2, "0").toUpperCase() ||
                "--";
              break;
            case "uint8":
              value = uint8Array[offset].toString();
              break;
            case "int8":
              value = (
                uint8Array[offset] > 127
                  ? uint8Array[offset] - 256
                  : uint8Array[offset]
              ).toString();
              break;
            case "uint16":
              value = dataView.getUint16(offset, true).toString();
              break;
            case "int16":
              value = dataView.getInt16(offset, true).toString();
              break;
            case "uint32":
              value = dataView.getUint32(offset, true).toString();
              break;
            case "int32":
              value = dataView.getInt32(offset, true).toString();
              break;
            case "uint64":
              value = dataView.getBigUint64(offset, true).toString();
              break;
            case "int64":
              value = dataView.getBigInt64(offset, true).toString();
              break;
            case "float32":
              const f32 = dataView.getFloat32(offset, true);
              value = isNaN(f32) || !isFinite(f32) ? "NaN" : f32.toPrecision(6);
              break;
            case "float64":
              const f64 = dataView.getFloat64(offset, true);
              value =
                isNaN(f64) || !isFinite(f64) ? "NaN" : f64.toPrecision(10);
              break;
            default:
              value = "--";
          }
          values.push(value);
        } catch {
          values.push("--");
        }
      }

      // Generate ASCII representation
      const asciiChars = rowBytes.map((byte) => {
        // Show printable ASCII characters, otherwise show '.'
        return byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : ".";
      });

      rows.push({
        address: `0x${rowAddress.toString(16).toUpperCase().padStart(16, "0")}`,
        hexBytes,
        values,
        asciiString: asciiChars.join(""),
        rawBytes: rowBytes,
      });
    }

    return rows;
  }, [memoryData, currentAddress, BYTES_PER_ROW, TOTAL_ROWS, displayMode]);

  return (
    <MainContainer ref={containerRef}>
      <MemoryViewContainer sx={{ width: `${memoryStackSplit.size}%` }}>
        {/* Memory Address Input */}
        <MemoryHeader>
          <Box
            sx={{
              display: "flex",
              alignItems: "center",
              gap: 0.5,
              height: "100%",
            }}
          >
            <MemoryIcon
              sx={{
                fontSize: "16px",
                color: "#4fc1ff",
                "@media (max-height: 800px)": {
                  fontSize: "12px",
                },
              }}
            />
            <Typography
              variant="body2"
              sx={{
                fontSize: "12px",
                fontWeight: 600,
                color: "#4fc1ff",
                lineHeight: 1,
                "@media (max-height: 800px)": {
                  fontSize: "10px",
                },
              }}
            >
              Memory
            </Typography>
          </Box>

          {/* Spacer for input box positioning */}
          <Box
            sx={{
              width: "5px",
              "@media (max-height: 800px)": {
                width: "2px",
              },
            }}
          />

          {/* Address Input Field with History */}
          <Autocomplete
            freeSolo
            options={gotoHistory}
            inputValue={inputAddress}
            onInputChange={(_, value) => setInputAddress(value)}
            onChange={(_, value) => {
              if (value) {
                setInputAddress(value);
              }
            }}
            PaperComponent={({ children, ...props }) => (
              <Paper {...props} sx={{ backgroundColor: "#2d2d2d" }}>
                {children}
              </Paper>
            )}
            renderOption={(props, option) => {
              const { key, ...restProps } = props as any;
              return (
                <Box
                  key={key}
                  component="li"
                  {...restProps}
                  onMouseDown={(e: React.MouseEvent) => {
                    e.preventDefault();
                    setInputAddress(option);
                  }}
                  sx={{
                    fontFamily: "monospace",
                    fontSize: "11px",
                    cursor: "pointer",
                    padding: "6px 12px",
                    "&:hover": { backgroundColor: "rgba(255,255,255,0.1)" },
                  }}
                >
                  {option}
                </Box>
              );
            }}
            renderInput={(params) => (
              <TextField
                {...params}
                label="Go to Address"
                placeholder=""
                InputLabelProps={{ shrink: true }}
                onKeyDown={(e) => {
                  if (e.key === "Enter" && inputAddress.trim()) {
                    e.preventDefault();
                    addToHistory(inputAddress.trim());
                    handleAddressChange(inputAddress.trim());
                    (e.target as HTMLInputElement).select();
                  }
                }}
                size="small"
                variant="outlined"
                sx={{
                  "& .MuiInputBase-input": {
                    fontSize: "11px",
                    fontFamily: "monospace",
                    py: 0.5,
                  },
                  "@media (max-height: 800px)": {
                    "& .MuiInputBase-input": {
                      fontSize: "9px",
                      py: 0.25,
                    },
                  },
                }}
              />
            )}
            sx={{
              flex: 1,
              maxWidth: 280,
              "& .MuiOutlinedInput-root": {
                height: "32px",
              },
              "@media (max-height: 800px)": {
                "& .MuiOutlinedInput-root": {
                  height: "24px",
                },
              },
            }}
          />

          <Tooltip title="Go to Address">
            <IconButton
              size="small"
              onClick={() => {
                if (inputAddress.trim()) {
                  addToHistory(inputAddress.trim());
                  handleAddressChange(inputAddress.trim());
                }
              }}
              sx={{
                "@media (max-height: 800px)": {
                  padding: 0.25,
                  "& .MuiSvgIcon-root": { fontSize: "18px" },
                },
              }}
            >
              <MyLocation fontSize="small" />
            </IconButton>
          </Tooltip>

          <Tooltip title="Refresh Memory">
            <IconButton
              size="small"
              onClick={() => {
                // Clear cache and force refresh memory at current address
                const cacheKey = `${currentAddress}_${TOTAL_BYTES}`;
                globalMemoryCache.delete(cacheKey);
                loadMemory(currentAddress);
              }}
              disabled={loading}
              sx={{
                color: "#9cdcfe",
                "&:hover": { backgroundColor: "rgba(79, 193, 255, 0.1)" },
              }}
            >
              <Refresh fontSize="small" />
            </IconButton>
          </Tooltip>

          <Tooltip title="Toggle Auto-refresh">
            <StatusChip
              label={autoRefresh ? "Auto-refresh: 0.5s" : "Auto-refresh: OFF"}
              active={autoRefresh}
              size="small"
              onClick={handleAutoRefreshToggle}
            />
          </Tooltip>

          {/* Display Mode Selector */}
          <Select
            value={displayMode}
            onChange={(e) =>
              setDisplayMode(e.target.value as MemoryDisplayMode)
            }
            size="small"
            sx={{
              minWidth: 80,
              height: 24,
              fontSize: "11px",
              fontFamily: "monospace",
              color: "#9cdcfe",
              "& .MuiSelect-select": {
                py: 0.25,
                px: 1,
              },
              "& .MuiOutlinedInput-notchedOutline": {
                borderColor: "rgba(156, 220, 254, 0.3)",
              },
              "&:hover .MuiOutlinedInput-notchedOutline": {
                borderColor: "rgba(156, 220, 254, 0.5)",
              },
              "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
                borderColor: "#4fc1ff",
              },
              "& .MuiSvgIcon-root": {
                color: "#9cdcfe",
                fontSize: "16px",
              },
            }}
            MenuProps={{
              PaperProps: {
                sx: {
                  backgroundColor: "#2d2d2d",
                  "& .MuiMenuItem-root": {
                    fontSize: "11px",
                    fontFamily: "monospace",
                    py: 0.5,
                    "&:hover": {
                      backgroundColor: "rgba(79, 193, 255, 0.1)",
                    },
                    "&.Mui-selected": {
                      backgroundColor: "rgba(79, 193, 255, 0.2)",
                    },
                  },
                },
              },
            }}
          >
            <MenuItem value="hex">Hex</MenuItem>
            <MenuItem value="uint8">U8</MenuItem>
            <MenuItem value="int8">I8</MenuItem>
            <MenuItem value="uint16">U16</MenuItem>
            <MenuItem value="int16">I16</MenuItem>
            <MenuItem value="uint32">U32</MenuItem>
            <MenuItem value="int32">I32</MenuItem>
            <MenuItem value="uint64">U64</MenuItem>
            <MenuItem value="int64">I64</MenuItem>
            <MenuItem value="float32">F32</MenuItem>
            <MenuItem value="float64">F64</MenuItem>
          </Select>
        </MemoryHeader>

        {/* Memory Content */}
        <Box
          sx={{
            flex: 1,
            overflow: "hidden",
            display: "flex",
            flexDirection: "column",
          }}
        >
          {loading && (
            <Box sx={{ p: 2, textAlign: "center" }}>
              <Typography
                variant="body2"
                sx={{ color: "#9b9b9b", fontSize: "12px" }}
              >
                Loading memory...
              </Typography>
            </Box>
          )}

          {error && (
            <Box sx={{ p: 2, textAlign: "center" }}>
              <Typography
                variant="body2"
                sx={{ color: "#f44747", fontSize: "12px" }}
              >
                Error: {error}
              </Typography>
            </Box>
          )}

          {!loading && !error && displayData.length === 0 && (
            <Box sx={{ p: 2, textAlign: "center" }}>
              <Typography
                variant="body2"
                sx={{ color: "#9b9b9b", fontSize: "12px" }}
              >
                No memory data available
              </Typography>
            </Box>
          )}

          {!loading && !error && displayData.length > 0 && (
            <MemoryTableWrapper>
              <MemoryTableContainer
                ref={scrollContainerRef}
                onWheel={handleWheel}
                onScroll={() => {
                  // Track scroll position for restoration
                  if (scrollContainerRef.current) {
                    lastScrollTop.current =
                      scrollContainerRef.current.scrollTop;
                  }
                }}
              >
                <MemoryTable size="small" stickyHeader>
                  <TableHead>
                    <TableRow>
                      <AddressCell>Address</AddressCell>
                      <HexCell>
                        {displayMode === "hex" ? (
                          <Box
                            sx={{
                              display: "flex",
                              justifyContent: "flex-start",
                              alignItems: "center",
                            }}
                          >
                            {Array.from({ length: 16 }, (_, i) => (
                              <Box
                                key={i}
                                sx={{
                                  width: "22px",
                                  textAlign: "center",
                                  fontSize: "10px",
                                  color: "#9b9b9b",
                                  marginRight: "0px",
                                  "@media (max-height: 800px)": {
                                    width: "16px",
                                    marginRight: "0px",
                                  },
                                }}
                              >
                                {i.toString(16).toUpperCase().padStart(2, "0")}
                              </Box>
                            ))}
                          </Box>
                        ) : (
                          <Box
                            sx={{
                              display: "flex",
                              justifyContent: "flex-start",
                              alignItems: "center",
                              gap: 1,
                            }}
                          >
                            {(() => {
                              const config = DISPLAY_MODE_CONFIG[displayMode];
                              const valuesPerRow = Math.floor(
                                16 / config.bytesPerValue
                              );
                              // Match body widths: 150px for 64-bit, 100px for float64, 60px for 32-bit, 40px for 16-bit, 24px for 8-bit
                              const cellWidth =
                                displayMode === "uint64" ||
                                displayMode === "int64"
                                  ? "150px"
                                  : displayMode === "float64"
                                    ? "120px"
                                    : displayMode === "float32"
                                      ? "100px"
                                      : displayMode.includes("32")
                                        ? "80px"
                                        : displayMode.includes("16")
                                          ? "50px"
                                          : "28px";
                              return Array.from(
                                { length: valuesPerRow },
                                (_, i) => (
                                  <Typography
                                    key={i}
                                    sx={{
                                      fontSize: "10px",
                                      color: "#9b9b9b",
                                      width: cellWidth,
                                      textAlign: "right",
                                    }}
                                  >
                                    {(i * config.bytesPerValue).toString()}
                                  </Typography>
                                )
                              );
                            })()}
                          </Box>
                        )}
                      </HexCell>
                      <AsciiCell>ASCII</AsciiCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {displayData.map((row) => (
                      <TableRow key={row.address}>
                        {/* Address */}
                        <AddressCell>{row.address}</AddressCell>

                        {/* Hex Bytes or Decimal Values */}
                        <HexCell>
                          {displayMode === "hex" ? (
                            <Box
                              sx={{
                                display: "flex",
                                justifyContent: "flex-start",
                                alignItems: "center",
                              }}
                            >
                              {row.hexBytes.map((byte, byteIndex) => (
                                <HexByte
                                  key={byteIndex}
                                  isZero={parseInt(byte, 16) === 0}
                                >
                                  {byte}
                                </HexByte>
                              ))}
                              {/* Fill empty bytes if row is incomplete */}
                              {Array.from(
                                { length: BYTES_PER_ROW - row.hexBytes.length },
                                (_, i) => (
                                  <HexByte key={`empty-${i}`} isZero>
                                    --
                                  </HexByte>
                                )
                              )}
                            </Box>
                          ) : (
                            <Box
                              sx={{
                                display: "flex",
                                justifyContent: "flex-start",
                                alignItems: "center",
                                gap: 1,
                              }}
                            >
                              {row.values.map((value, idx) => (
                                <Typography
                                  key={idx}
                                  sx={{
                                    fontSize: "11px",
                                    fontFamily: "monospace",
                                    color:
                                      value === "0" || value === "0.00000"
                                        ? "#6a6a6a"
                                        : "#d4d4d4",
                                    width:
                                      displayMode === "uint64" ||
                                      displayMode === "int64"
                                        ? "150px"
                                        : displayMode === "float64"
                                          ? "120px"
                                          : displayMode === "float32"
                                            ? "100px"
                                            : displayMode.includes("32")
                                              ? "80px"
                                              : displayMode.includes("16")
                                                ? "50px"
                                                : "28px",
                                    textAlign: "right",
                                    "@media (max-height: 800px)": {
                                      fontSize: "9px",
                                    },
                                  }}
                                >
                                  {value}
                                </Typography>
                              ))}
                            </Box>
                          )}
                        </HexCell>

                        {/* ASCII */}
                        <AsciiCell>
                          {row.asciiString}
                          {/* Fill empty ASCII chars if row is incomplete */}
                          {row.hexBytes.length < BYTES_PER_ROW &&
                            ".".repeat(BYTES_PER_ROW - row.hexBytes.length)}
                        </AsciiCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </MemoryTable>
              </MemoryTableContainer>
            </MemoryTableWrapper>
          )}
        </Box>
      </MemoryViewContainer>

      {/* Horizontal Resizer */}
      <Resizer
        orientation="vertical"
        onMouseDown={memoryStackSplit.handleMouseDown}
        isResizing={memoryStackSplit.isResizing}
      />

      {/* Stack View */}
      <Box
        sx={{
          flex: 1,
          overflow: "hidden",
        }}
      >
        <StackView
          spRegister={
            registerData?.SP ||
            registerData?.sp ||
            registerData?.RSP ||
            registerData?.rsp ||
            null
          }
          isInBreakState={isInBreakState}
          currentThreadId={currentThreadId}
          attachedModules={attachedModules}
          resolveFunctionName={resolveFunctionName}
          onNavigateToAddress={(address) => {
            // Navigate to assembly view with the clicked address
            uiActions.setAssemblyAddress(address);
          }}
        />
      </Box>
    </MainContainer>
  );
};

```

`src/client/src/components/NewsContent.tsx`:

```tsx
import React, { useEffect, useState, useCallback } from "react";
import {
  Box,
  Typography,
  Card,
  CardContent,
  Stack,
  Chip,
  alpha,
  useMediaQuery,
  CircularProgress,
  IconButton,
  Tooltip,
} from "@mui/material";
import {
  Newspaper as NewsIcon,
  NewReleases as UpdateIcon,
  Info as InfoIcon,
  Warning as WarningIcon,
  Campaign as AnnouncementIcon,
  Launch as LaunchIcon,
  Refresh as RefreshIcon,
  CheckCircle as ReadIcon,
} from "@mui/icons-material";
import { openUrl } from "@tauri-apps/plugin-opener";
import { NewsItem, NewsResponse } from "../lib/api";

const NEWS_READ_KEY = "dynadbg_news_read_ids";

// Hardcoded welcome news - always shown at the bottom
const WELCOME_NEWS: NewsItem = {
  id: "welcome-dynadbg",
  date: "2024-01-01",
  title: "Thanks for trying DynaDbg!",
  body: "Hi there! I hope this tool helps enhance your security research and learning journey.",
  type: "info",
  link: "",
};

const getTypeIcon = (type: NewsItem["type"]) => {
  switch (type) {
    case "update":
      return <UpdateIcon sx={{ fontSize: 24 }} />;
    case "warning":
      return <WarningIcon sx={{ fontSize: 24 }} />;
    case "announcement":
      return <AnnouncementIcon sx={{ fontSize: 24 }} />;
    case "info":
    default:
      return <InfoIcon sx={{ fontSize: 24 }} />;
  }
};

const getTypeColor = (type: NewsItem["type"]) => {
  switch (type) {
    case "update":
      return "#3b82f6"; // blue
    case "warning":
      return "#f59e0b"; // amber
    case "announcement":
      return "#8b5cf6"; // purple
    case "info":
    default:
      return "#10b981"; // green
  }
};

const getTypeLabel = (type: NewsItem["type"]) => {
  switch (type) {
    case "update":
      return "Update";
    case "warning":
      return "Warning";
    case "announcement":
      return "Announcement";
    case "info":
    default:
      return "Info";
  }
};

interface NewsContentProps {
  onUnreadCountChange?: (count: number) => void;
}

export const NewsContent: React.FC<NewsContentProps> = ({
  onUnreadCountChange,
}) => {
  const [newsData, setNewsData] = useState<NewsResponse | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [readIds, setReadIds] = useState<Set<string>>(new Set());

  const isCompactHeight = useMediaQuery("(max-height: 800px)");

  // Load read news IDs from localStorage
  useEffect(() => {
    try {
      const stored = localStorage.getItem(NEWS_READ_KEY);
      if (stored) {
        setReadIds(new Set(JSON.parse(stored)));
      }
    } catch (e) {
      console.error("Failed to load read news IDs:", e);
    }
  }, []);

  // Fetch news data
  const fetchNews = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const response = await fetch("https://news.dynadbg.com/public/news.json");
      if (!response.ok) {
        throw new Error(`HTTP error: ${response.status}`);
      }
      const data: NewsResponse = await response.json();
      setNewsData(data);
    } catch (e) {
      // On error, still show welcome news with empty fetched news
      setNewsData({
        latest_version: "1.0.0",
        force_update: false,
        news: [],
      });
      console.error("Failed to fetch news:", e);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchNews();
  }, [fetchNews]);

  // Mark all news as read when component mounts
  useEffect(() => {
    if (newsData?.news) {
      const allIds = new Set(newsData.news.map((item) => item.id));
      const newReadIds = new Set([...readIds, ...allIds]);
      setReadIds(newReadIds);
      localStorage.setItem(NEWS_READ_KEY, JSON.stringify([...newReadIds]));
    }
  }, [newsData]);

  // Calculate unread count and notify parent
  useEffect(() => {
    if (newsData?.news && onUnreadCountChange) {
      const unreadCount = newsData.news.filter(
        (item) => !readIds.has(item.id)
      ).length;
      onUnreadCountChange(unreadCount);
    }
  }, [newsData, readIds, onUnreadCountChange]);

  const handleLinkClick = async (url: string) => {
    if (!url) return;
    try {
      await openUrl(url);
    } catch (error) {
      console.error("Failed to open URL:", error);
      window.open(url, "_blank", "noopener,noreferrer");
    }
  };

  const formatDate = (dateStr: string) => {
    const date = new Date(dateStr);
    return date.toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
    });
  };

  return (
    <Box
      sx={{
        height: "100%",
        overflow: "auto",
        backgroundColor: "#0f0f0f",
        p: isCompactHeight ? 2 : 4,
        "&::-webkit-scrollbar": {
          width: "8px",
        },
        "&::-webkit-scrollbar-track": {
          background: "#1a1a1a",
        },
        "&::-webkit-scrollbar-thumb": {
          background: "#3a3a3a",
          borderRadius: "4px",
          "&:hover": {
            background: "#4a4a4a",
          },
        },
      }}
    >
      {/* Header Section */}
      <Box
        sx={{
          mb: isCompactHeight ? 2 : 4,
          textAlign: "center",
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
        }}
      >
        <Stack
          direction="row"
          justifyContent="center"
          alignItems="center"
          spacing={1.5}
          sx={{ mb: 1 }}
        >
          <NewsIcon sx={{ fontSize: 32, color: "#3b82f6" }} />
          <Typography
            variant="h4"
            sx={{
              fontWeight: 700,
              background: "linear-gradient(135deg, #3b82f6, #8b5cf6)",
              backgroundClip: "text",
              WebkitBackgroundClip: "text",
              WebkitTextFillColor: "transparent",
            }}
          >
            News & Updates
          </Typography>
          <Tooltip title="Refresh">
            <IconButton
              onClick={fetchNews}
              disabled={loading}
              sx={{
                color: alpha("#fff", 0.5),
                "&:hover": { color: "#3b82f6" },
              }}
            >
              <RefreshIcon />
            </IconButton>
          </Tooltip>
        </Stack>
        <Typography
          variant="body2"
          sx={{
            color: alpha("#fff", 0.6),
            maxWidth: 500,
          }}
        >
          Stay updated with the latest news, updates, and announcements
        </Typography>
      </Box>

      {/* Loading State */}
      {loading && (
        <Box
          sx={{
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            py: 8,
          }}
        >
          <CircularProgress size={40} sx={{ color: "#3b82f6" }} />
        </Box>
      )}

      {/* Error State */}
      {error && !loading && (
        <Box
          sx={{
            textAlign: "center",
            py: 8,
          }}
        >
          <Typography color="error">{error}</Typography>
        </Box>
      )}

      {/* News List */}
      {!loading && newsData && (
        <Stack spacing={2}>
          {/* Fetched news from server */}
          {newsData.news.map((item) => {
            const color = getTypeColor(item.type);
            const isRead = readIds.has(item.id);

            return (
              <Card
                key={item.id}
                sx={{
                  backgroundColor: alpha("#1a1a1a", 0.8),
                  backgroundImage: "none",
                  border: "1px solid",
                  borderColor: alpha(color, 0.2),
                  borderRadius: 2,
                  transition: "all 0.2s ease",
                  position: "relative",
                  "&:hover": {
                    borderColor: alpha(color, 0.4),
                    transform: "translateY(-2px)",
                    boxShadow: `0 8px 24px ${alpha(color, 0.15)}`,
                  },
                }}
              >
                <CardContent sx={{ p: isCompactHeight ? 2 : 3 }}>
                  <Stack spacing={1.5}>
                    {/* Header */}
                    <Stack
                      direction="row"
                      alignItems="flex-start"
                      justifyContent="space-between"
                    >
                      <Stack direction="row" spacing={2} alignItems="center">
                        <Box
                          sx={{
                            width: 44,
                            height: 44,
                            borderRadius: 2,
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            backgroundColor: alpha(color, 0.15),
                            color: color,
                          }}
                        >
                          {getTypeIcon(item.type)}
                        </Box>
                        <Box>
                          <Typography
                            variant="h6"
                            sx={{
                              fontWeight: 600,
                              color: "#fff",
                              fontSize: "1rem",
                            }}
                          >
                            {item.title}
                          </Typography>
                          <Stack
                            direction="row"
                            spacing={1}
                            alignItems="center"
                            sx={{ mt: 0.5 }}
                          >
                            <Chip
                              label={getTypeLabel(item.type)}
                              size="small"
                              sx={{
                                backgroundColor: alpha(color, 0.15),
                                color: color,
                                fontWeight: 500,
                                fontSize: "0.7rem",
                                height: 20,
                              }}
                            />
                            <Typography
                              variant="caption"
                              sx={{ color: alpha("#fff", 0.5) }}
                            >
                              {formatDate(item.date)}
                            </Typography>
                            {isRead && (
                              <Tooltip title="Read">
                                <ReadIcon
                                  sx={{
                                    fontSize: 14,
                                    color: alpha("#fff", 0.3),
                                  }}
                                />
                              </Tooltip>
                            )}
                          </Stack>
                        </Box>
                      </Stack>

                      {item.link && (
                        <Tooltip title="Open link">
                          <IconButton
                            onClick={() => handleLinkClick(item.link)}
                            sx={{
                              color: alpha("#fff", 0.5),
                              "&:hover": { color: color },
                            }}
                          >
                            <LaunchIcon fontSize="small" />
                          </IconButton>
                        </Tooltip>
                      )}
                    </Stack>

                    {/* Body */}
                    <Typography
                      variant="body2"
                      sx={{
                        color: alpha("#fff", 0.7),
                        lineHeight: 1.7,
                        pl: 7,
                      }}
                    >
                      {item.body}
                    </Typography>
                  </Stack>
                </CardContent>
              </Card>
            );
          })}

          {/* Hardcoded Welcome News - always shown at the bottom */}
          {(() => {
            const color = getTypeColor(WELCOME_NEWS.type);
            return (
              <Card
                key={WELCOME_NEWS.id}
                sx={{
                  backgroundColor: alpha("#1a1a1a", 0.8),
                  backgroundImage: "none",
                  border: "1px solid",
                  borderColor: alpha(color, 0.2),
                  borderRadius: 2,
                  transition: "all 0.2s ease",
                  position: "relative",
                  "&:hover": {
                    borderColor: alpha(color, 0.4),
                    transform: "translateY(-2px)",
                    boxShadow: `0 8px 24px ${alpha(color, 0.15)}`,
                  },
                }}
              >
                <CardContent sx={{ p: isCompactHeight ? 2 : 3 }}>
                  <Stack spacing={1.5}>
                    <Stack
                      direction="row"
                      alignItems="flex-start"
                      justifyContent="space-between"
                    >
                      <Stack direction="row" spacing={2} alignItems="center">
                        <Box
                          sx={{
                            width: 44,
                            height: 44,
                            borderRadius: 2,
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            backgroundColor: alpha(color, 0.15),
                            color: color,
                          }}
                        >
                          {getTypeIcon(WELCOME_NEWS.type)}
                        </Box>
                        <Box>
                          <Typography
                            variant="h6"
                            sx={{
                              fontWeight: 600,
                              color: "#fff",
                              fontSize: "1rem",
                            }}
                          >
                            {WELCOME_NEWS.title}
                          </Typography>
                          <Stack
                            direction="row"
                            spacing={1}
                            alignItems="center"
                            sx={{ mt: 0.5 }}
                          >
                            <Chip
                              label={getTypeLabel(WELCOME_NEWS.type)}
                              size="small"
                              sx={{
                                backgroundColor: alpha(color, 0.15),
                                color: color,
                                fontWeight: 500,
                                fontSize: "0.7rem",
                                height: 20,
                              }}
                            />
                          </Stack>
                        </Box>
                      </Stack>
                    </Stack>

                    <Typography
                      variant="body2"
                      sx={{
                        color: alpha("#fff", 0.7),
                        lineHeight: 1.7,
                        pl: 7,
                      }}
                    >
                      {WELCOME_NEWS.body}
                    </Typography>
                  </Stack>
                </CardContent>
              </Card>
            );
          })()}
        </Stack>
      )}
    </Box>
  );
};

// Helper hook to get unread news count
export const useUnreadNewsCount = (): number => {
  const [unreadCount, setUnreadCount] = useState(0);

  useEffect(() => {
    const checkUnread = async () => {
      try {
        const response = await fetch(
          "https://news.dynadbg.com/public/news.json"
        );
        if (!response.ok) {
          setUnreadCount(0);
          return;
        }
        const data: NewsResponse = await response.json();
        const stored = localStorage.getItem(NEWS_READ_KEY);
        const readIds = stored ? new Set(JSON.parse(stored)) : new Set();
        const count = data.news.filter(
          (item: NewsItem) => !readIds.has(item.id)
        ).length;
        setUnreadCount(count);
      } catch (e) {
        console.error("Failed to check unread news:", e);
        setUnreadCount(0);
      }
    };

    checkUnread();
  }, []);

  return unreadCount;
};

```

`src/client/src/components/ProcessManager.tsx`:

```tsx
import { useState, useEffect, useCallback, useMemo } from "react";
import {
  Typography,
  Button,
  TextField,
  Box,
  IconButton,
  Tooltip,
  Paper,
  Stack,
  CircularProgress,
  useMediaQuery,
  Autocomplete,
} from "@mui/material";
import {
  Refresh as RefreshIcon,
  Link as AttachIcon,
  Memory as ProcessIcon,
  ArrowUpward as ArrowUpIcon,
  ArrowDownward as ArrowDownIcon,
} from "@mui/icons-material";
import { List } from "react-window";

import {
  getApiClient,
  ProcessInfo,
  ProcessState,
  AppInfo,
  ModuleInfo,
} from "../lib/api";
import { useGlobalDebugLogger } from "../hooks/useGlobalDebugLogger";
import { useAppState } from "../hooks/useAppState";

// LocalStorage key for filter history
const PROCESS_FILTER_HISTORY_KEY = "process_manager_filter_history";
const MAX_HISTORY_ITEMS = 5;

interface ProcessManagerProps {
  // Legacy props for backward compatibility, but we'll use global store instead
  onModulesUpdate?: (modules: ModuleInfo[]) => void;
}

// Row data interface for virtualized list
interface ProcessRowData {
  processes: ProcessInfo[];
  attachingPid: number | null;
  selectedPid: number | undefined;
  isCompactHeight: boolean;
  onAttach: (process: ProcessInfo) => void;
}

// Virtualized row component for react-window v2
function ProcessRow({
  index,
  style,
  ...rowProps
}: {
  index: number;
  style: React.CSSProperties;
  data: ProcessRowData;
}) {
  const data = rowProps.data as ProcessRowData;
  const { processes, attachingPid, selectedPid, isCompactHeight, onAttach } =
    data;
  const process = processes[index];
  const isSelected = selectedPid === process.pid;
  const isAttaching = attachingPid === process.pid;

  return (
    <Box
      style={style}
      sx={{
        display: "flex",
        alignItems: "center",
        px: 1,
        borderBottom: "1px solid",
        borderColor: "divider",
        backgroundColor: isSelected ? "action.selected" : "transparent",
        "&:hover": {
          backgroundColor: isSelected ? "action.selected" : "action.hover",
        },
        cursor: "pointer",
      }}
      onClick={() => !isAttaching && !isSelected && onAttach(process)}
    >
      <Box
        sx={{
          width: "60px",
          fontSize: isCompactHeight ? "9px" : "10px",
          flexShrink: 0,
        }}
      >
        {process.pid}
      </Box>
      <Box
        sx={{
          flex: 1,
          fontSize: isCompactHeight ? "10px" : "11px",
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap",
        }}
      >
        {process.processname}
      </Box>
      <Box
        sx={{
          width: "50px",
          display: "flex",
          justifyContent: "flex-end",
        }}
      >
        <Tooltip title="Attach to process">
          <span>
            <IconButton
              size="small"
              onClick={(e) => {
                e.stopPropagation();
                onAttach(process);
              }}
              disabled={isAttaching || isSelected}
              sx={{
                color: "primary.main",
                padding: "2px",
                "&:hover": { backgroundColor: "action.hover" },
                "&:disabled": { color: "text.disabled" },
              }}
            >
              {isAttaching ? (
                <CircularProgress size={isCompactHeight ? 12 : 14} />
              ) : (
                <AttachIcon
                  sx={{
                    fontSize: isCompactHeight ? "12px" : "14px",
                  }}
                />
              )}
            </IconButton>
          </span>
        </Tooltip>
      </Box>
    </Box>
  );
}

export function ProcessManager({ onModulesUpdate }: ProcessManagerProps) {
  // Use new app state system
  const { system, systemActions } = useAppState();
  const connected = system.serverConnected;
  const attachedProcess = system.attachedProcess;
  const attachedAppInfo = system.attachedAppInfo;
  const serverInfo = system.serverInfo;
  const isWasmMode = serverInfo?.mode === "wasm";

  const isCompactHeight = useMediaQuery("(max-height: 800px)");
  const [processes, setProcesses] = useState<ProcessInfo[]>([]);
  const [filteredProcesses, setFilteredProcesses] = useState<ProcessInfo[]>([]);
  const [loading, setLoading] = useState(false);
  const [attachingPid, setAttachingPid] = useState<number | null>(null);
  const [nameFilter, setNameFilter] = useState("");
  const [sortOrder, setSortOrder] = useState<"asc" | "desc">("asc");
  const [filterHistory, setFilterHistory] = useState<string[]>([]);

  // Load filter history from localStorage on mount
  useEffect(() => {
    try {
      const saved = localStorage.getItem(PROCESS_FILTER_HISTORY_KEY);
      if (saved) {
        setFilterHistory(JSON.parse(saved));
      }
    } catch (e) {
      console.error("Failed to load filter history:", e);
    }
  }, []);

  // Save history to localStorage
  const saveFilterHistory = useCallback((history: string[]) => {
    try {
      localStorage.setItem(PROCESS_FILTER_HISTORY_KEY, JSON.stringify(history));
    } catch (e) {
      console.error("Failed to save filter history:", e);
    }
  }, []);

  // Add filter to history
  const addToFilterHistory = useCallback(
    (filter: string) => {
      if (!filter.trim()) return;
      setFilterHistory((prev) => {
        const filtered = prev.filter(
          (f) => f.toLowerCase() !== filter.toLowerCase()
        );
        const newHistory = [filter, ...filtered].slice(0, MAX_HISTORY_ITEMS);
        saveFilterHistory(newHistory);
        return newHistory;
      });
    },
    [saveFilterHistory]
  );

  // デバッグログ機能
  const { addLog, logInfo } = useGlobalDebugLogger();

  // Derive process state from global state (useMemoで最適化)
  const processState: ProcessState = useMemo(
    () => ({
      attached: !!attachedProcess,
      processInfo: attachedProcess,
      appInfo: attachedAppInfo,
    }),
    [attachedProcess, attachedAppInfo]
  );

  // Handle process attach using app state
  const handleProcessAttach = useCallback(
    (process?: ProcessInfo, appInfo?: AppInfo) => {
      const attachedProcess = process
        ? {
            pid: process.pid,
            processname: process.processname,
          }
        : undefined;

      systemActions.updateProcessState(attachedProcess, appInfo);
    },
    [systemActions.updateProcessState]
  );

  // Debug logging - processStateの作成を避けて直接ログ出力
  useEffect(() => {
    console.log("ProcessManager - attachedProcess:", attachedProcess);
    console.log("ProcessManager - attachedAppInfo:", attachedAppInfo);
  }, [attachedProcess, attachedAppInfo]);

  const loadProcesses = useCallback(async () => {
    if (!connected) return;

    setLoading(true);
    try {
      const client = getApiClient();
      const processList = await client.enumerateProcesses();
      setProcesses(processList);
    } catch (error) {
      console.error("Failed to load processes:", error);
    } finally {
      setLoading(false);
    }
  }, [connected]);

  // Filter and sort processes
  useEffect(() => {
    let filtered = processes.filter((process) =>
      process.processname.toLowerCase().includes(nameFilter.toLowerCase())
    );

    // Sort by PID
    filtered = filtered.sort((a, b) => {
      return sortOrder === "asc" ? a.pid - b.pid : b.pid - a.pid;
    });

    setFilteredProcesses(filtered);
  }, [processes, nameFilter, sortOrder]);

  const handleSortToggle = () => {
    setSortOrder((prev) => (prev === "asc" ? "desc" : "asc"));
  };

  const handleAttachProcess = async (process: ProcessInfo) => {
    setAttachingPid(process.pid);
    try {
      const client = getApiClient();
      await client.attachProcess(process.pid);

      // Get additional process information
      const appInfoResponse = await client.getProcessInfo();
      const modulesResponse = await client.enumerateModules();

      // Extract app info from API response
      const appInfo: AppInfo = appInfoResponse.data
        ? {
            ...appInfoResponse.data,
            pid: process.pid,
          }
        : {
            name: process.processname,
            pid: process.pid,
          };

      // プロセスアタッチ成功をログに記録
      logInfo(
        "PROCESS",
        `Successfully attached to process: ${process.processname} (PID: ${process.pid})`
      );

      // モジュール情報を取得してログに出力
      if (modulesResponse.data?.modules) {
        const modules = modulesResponse.data.modules;
        logInfo(
          "MODULES",
          `Loaded ${modules.length} modules for process ${process.processname}`
        );

        // 各モジュール情報をログに出力
        modules.forEach((module, index) => {
          const moduleName = module.modulename || module.name || "Unknown";
          const baseAddress =
            module.base_address || `0x${module.base.toString(16)}`;
          const size = module.size;
          const path = module.path || "Unknown path";

          addLog("INFO", "MODULE", `Module ${index + 1}: ${moduleName}`, {
            name: moduleName,
            baseAddress: baseAddress,
            size: size,
            path: path,
            is64bit: module.is_64bit,
          });
        });

        // 一番上のモジュール（最初のモジュール）のシンボル情報を取得
        if (modules.length > 0) {
          const firstModule = modules[0];
          const moduleName =
            firstModule.modulename || firstModule.name || "Unknown";

          logInfo("SYMBOLS", `Loading symbols for first module: ${moduleName}`);

          try {
            const symbols = await client.enumerateSymbolsForModule(firstModule);
            logInfo(
              "SYMBOLS",
              `Loaded ${symbols.length} symbols for module: ${moduleName}`
            );

            // 最初の10個のシンボルをログに出力
            const symbolsToLog = symbols.slice(0, 10);
            symbolsToLog.forEach((symbol, index) => {
              addLog("INFO", "SYMBOL", `Symbol ${index + 1}: ${symbol.name}`, {
                address: symbol.address,
                name: symbol.name,
                size: symbol.size,
                type: symbol.type,
                scope: symbol.scope,
                moduleBase: symbol.module_base,
                fileName: symbol.file_name,
                lineNumber: symbol.line_number,
              });
            });

            if (symbols.length > 10) {
              logInfo("SYMBOLS", `... and ${symbols.length - 10} more symbols`);
            }
          } catch (symbolError) {
            console.error(
              "Failed to load symbols for first module:",
              symbolError
            );
            addLog(
              "ERROR",
              "SYMBOLS",
              `Failed to load symbols for module: ${moduleName}`,
              {
                error:
                  symbolError instanceof Error
                    ? symbolError.message
                    : "Unknown error",
              }
            );
          }
        }
      }

      handleProcessAttach(process, appInfo);

      // アタッチ成功時にモジュール一覧を更新
      if (onModulesUpdate && modulesResponse.data?.modules) {
        onModulesUpdate(modulesResponse.data.modules);
      }

      // Sync signal configurations to server on attach (skip for iOS)
      // Default: catch=false, pass=false (suppress signals, like GDB)
      const targetOs = system.serverInfo?.target_os;
      if (targetOs !== "ios") {
        try {
          const defaultSignalConfigs = [
            { signal: 4, catch_signal: false, pass_signal: false }, // SIGILL
            { signal: 6, catch_signal: false, pass_signal: false }, // SIGABRT
            { signal: 7, catch_signal: false, pass_signal: false }, // SIGBUS
            { signal: 8, catch_signal: false, pass_signal: false }, // SIGFPE
            { signal: 11, catch_signal: false, pass_signal: false }, // SIGSEGV
          ];
          await client.setAllSignalConfigs(defaultSignalConfigs);
          logInfo("SIGNALS", "Synced default signal configurations to server");
        } catch (signalError) {
          console.error("Failed to sync signal configurations:", signalError);
          addLog(
            "WARN",
            "SIGNALS",
            "Failed to sync signal configurations to server"
          );
        }
      }
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error";
      console.error("Failed to attach to process:", error);
      addLog(
        "ERROR",
        "PROCESS",
        `Failed to attach to process: ${process.processname} (PID: ${process.pid})`,
        {
          error: errorMessage,
        }
      );
    } finally {
      setAttachingPid(null);
    }
  };

  const handleDetachProcess = () => {
    if (attachedProcess) {
      logInfo(
        "PROCESS",
        `Detached from process: ${attachedProcess.processname} (PID: ${attachedProcess.pid})`
      );
    }

    // Clear process state (explicitly set to null)
    systemActions.updateField("attachedProcess", null);
    systemActions.updateField("attachedAppInfo", null);

    // Clear debug state when detaching from process
    systemActions.updateField("isInBreakState", false);
    systemActions.updateField("currentThreadId", null);
    systemActions.updateField("currentBreakAddress", null);
    systemActions.updateField("currentRegisterData", {});

    // Clear breakpoints and watchpoints when detaching from process
    systemActions.updateField("activeBreakpoints", []);
    systemActions.updateField("softwareBreakpoints", []);
    systemActions.updateField("watchpoints", []);

    // Clear modules
    systemActions.updateField("attachedModules", []);

    console.log("All debug state cleared due to process detach");
  };

  // Auto-load processes on connect (skip in WASM mode)
  useEffect(() => {
    if (isWasmMode) {
      // WASM mode - no process list needed
      setProcesses([]);
      setFilteredProcesses([]);
      return;
    }
    if (connected) {
      loadProcesses();
    } else {
      setProcesses([]);
      setFilteredProcesses([]);
      // 接続が切れた時のみプロセスのアタッチを解除 (explicitly set to null)
      // 注意: サーバーページを開いただけでは既存のattach状態を保持する
      if (!connected && (attachedProcess || attachedAppInfo)) {
        console.log("[ProcessManager] Connection lost, clearing attach state");
        systemActions.updateField("attachedProcess", null);
        systemActions.updateField("attachedAppInfo", null);
      }
      setNameFilter("");
    }
  }, [connected, loadProcesses, isWasmMode]); // systemActionsを依存配列から削除

  // WASM Mode - show simplified attached view
  if (isWasmMode && connected) {
    return (
      <Paper
        sx={{
          p: isCompactHeight ? 1.5 : 2,
          border: "1px solid",
          borderColor: "divider",
          backgroundColor: "background.paper",
          borderTopLeftRadius: 0,
        }}
      >
        <Stack spacing={isCompactHeight ? 1.5 : 2}>
          <Box display="flex" justifyContent="space-between" alignItems="center">
            <Typography
              variant="subtitle1"
              sx={{
                display: "flex",
                alignItems: "center",
                gap: 1,
                fontSize: isCompactHeight ? "11px" : "12px",
                fontWeight: 600,
                color: "primary.main",
              }}
            >
              <ProcessIcon sx={{ fontSize: isCompactHeight ? "14px" : "16px" }} />
              WebAssembly Mode
            </Typography>
          </Box>

          <Paper
            sx={{
              p: isCompactHeight ? 1 : 1.5,
              backgroundColor: "success.dark",
              borderRadius: 1,
              border: "1px solid",
              borderColor: "success.main",
            }}
          >
            <Typography
              variant="body2"
              sx={{
                fontSize: isCompactHeight ? "10px" : "11px",
                fontWeight: 600,
                mb: isCompactHeight ? 0.5 : 1,
                color: "success.contrastText",
              }}
            >
              ✓ Connected to WebAssembly Runtime
            </Typography>
            <Stack spacing={isCompactHeight ? 0.25 : 0.5}>
              <Typography
                variant="body2"
                sx={{ fontSize: isCompactHeight ? "9px" : "10px", color: "success.contrastText" }}
              >
                Target: Browser WebAssembly
              </Typography>
              <Typography
                variant="body2"
                sx={{ fontSize: isCompactHeight ? "9px" : "10px", color: "success.contrastText" }}
              >
                Connection: WebSocket Bridge
              </Typography>
              {system.attachedModules && system.attachedModules.length > 0 && (
                <Typography
                  variant="body2"
                  sx={{ fontSize: isCompactHeight ? "9px" : "10px", color: "success.contrastText" }}
                >
                  Modules: {system.attachedModules.length}
                </Typography>
              )}
            </Stack>
          </Paper>

          <Typography
            variant="body2"
            color="text.secondary"
            align="center"
            sx={{
              fontSize: isCompactHeight ? "9px" : "10px",
              fontStyle: "italic",
            }}
          >
            Memory read/write via Chrome Extension
          </Typography>
        </Stack>
      </Paper>
    );
  }

  return (
    <Paper
      sx={{
        p: isCompactHeight ? 1.5 : 2,
        border: "1px solid",
        borderColor: "divider",
        backgroundColor: "background.paper",
        borderTopLeftRadius: 0,
      }}
    >
      <Stack spacing={isCompactHeight ? 1.5 : 2}>
        <Box display="flex" justifyContent="space-between" alignItems="center">
          <Typography
            variant="subtitle1"
            sx={{
              display: "flex",
              alignItems: "center",
              gap: 1,
              fontSize: isCompactHeight ? "11px" : "12px",
              fontWeight: 600,
              color: "primary.main",
            }}
          >
            <ProcessIcon sx={{ fontSize: isCompactHeight ? "14px" : "16px" }} />
            Process Manager
          </Typography>
          <Tooltip title="Refresh process list">
            <IconButton
              onClick={loadProcesses}
              disabled={!connected || loading}
              size="small"
              sx={{
                color: "primary.main",
                "&:hover": { backgroundColor: "action.hover" },
              }}
            >
              <RefreshIcon
                sx={{ fontSize: isCompactHeight ? "14px" : "16px" }}
              />
            </IconButton>
          </Tooltip>
        </Box>

        {/* Attached Process Info */}
        {processState.attached && processState.processInfo && (
          <Paper
            sx={{
              p: isCompactHeight ? 1 : 1.5,
              backgroundColor: "action.hover",
              borderRadius: 1,
              border: "1px solid",
              borderColor: "divider",
            }}
          >
            <Typography
              variant="body2"
              sx={{
                fontSize: isCompactHeight ? "10px" : "11px",
                fontWeight: 600,
                mb: isCompactHeight ? 0.5 : 1,
              }}
            >
              Process Information
            </Typography>
            <Stack spacing={isCompactHeight ? 0.25 : 0.5}>
              <Typography
                variant="body2"
                sx={{ fontSize: isCompactHeight ? "9px" : "10px" }}
              >
                Name: {processState.processInfo.processname}
              </Typography>
              <Typography
                variant="body2"
                sx={{ fontSize: isCompactHeight ? "9px" : "10px" }}
              >
                PID: {processState.processInfo.pid}
              </Typography>
              {processState.appInfo && (
                <Typography
                  variant="body2"
                  sx={{
                    fontSize: isCompactHeight ? "9px" : "10px",
                    wordBreak: "break-all",
                    fontFamily: "monospace",
                  }}
                >
                  Path: {processState.appInfo.name || "Unknown"}
                </Typography>
              )}
            </Stack>
            <Button
              variant="outlined"
              size="small"
              color="warning"
              onClick={handleDetachProcess}
              sx={{
                mt: isCompactHeight ? 0.5 : 1,
                fontSize: isCompactHeight ? "9px" : "10px",
                py: 0.25,
                px: 1,
                minWidth: "auto",
                "&:hover": {
                  backgroundColor: "warning.light",
                  color: "warning.contrastText",
                },
              }}
            >
              Detach
            </Button>
          </Paper>
        )}

        {/* Filter and Controls */}
        {connected && (
          <Stack direction="row" spacing={1} alignItems="center">
            <Autocomplete
              freeSolo
              options={filterHistory}
              inputValue={nameFilter}
              onInputChange={(_, value) => setNameFilter(value)}
              onChange={(_, value) => {
                if (value) {
                  setNameFilter(value);
                }
              }}
              onKeyDown={(e) => {
                if (e.key === "Enter" && nameFilter.trim()) {
                  addToFilterHistory(nameFilter.trim());
                }
              }}
              PaperComponent={({ children, ...props }) => (
                <Paper {...props} sx={{ backgroundColor: "#2d2d2d" }}>
                  {children}
                </Paper>
              )}
              renderOption={(props, option) => {
                const { key, ...restProps } = props as any;
                return (
                  <Box
                    key={key}
                    component="li"
                    {...restProps}
                    onMouseDown={(e: React.MouseEvent) => {
                      e.preventDefault();
                      setNameFilter(option);
                    }}
                    sx={{
                      fontSize: "11px",
                      cursor: "pointer",
                      padding: "6px 12px",
                      "&:hover": { backgroundColor: "rgba(255,255,255,0.1)" },
                    }}
                  >
                    {option}
                  </Box>
                );
              }}
              renderInput={(params) => (
                <TextField
                  {...params}
                  label="Filter by name"
                  size="small"
                  sx={{
                    "& .MuiInputLabel-root": {
                      fontSize: isCompactHeight ? "10px" : "11px",
                    },
                    "& .MuiInputBase-input": {
                      fontSize: isCompactHeight ? "10px" : "11px",
                    },
                    ...(isCompactHeight && {
                      "& .MuiInputBase-root": {
                        minHeight: "20px",
                        fontSize: "11px",
                      },
                      "& .MuiInputBase-input": {
                        paddingTop: "4px",
                        paddingBottom: "4px",
                        fontSize: "11px",
                      },
                      "& .MuiInputLabel-root": {
                        fontSize: "11px",
                        transform: "translate(14px, 6px) scale(1)",
                        "&.MuiInputLabel-shrink": {
                          transform: "translate(14px, -6px) scale(0.75)",
                        },
                      },
                    }),
                  }}
                />
              )}
              sx={{ flex: 1 }}
            />
            <Tooltip
              title={`Sort by PID (${sortOrder === "asc" ? "Low to High" : "High to Low"})`}
            >
              <IconButton
                onClick={handleSortToggle}
                size="small"
                sx={{
                  color: "primary.main",
                  "&:hover": { backgroundColor: "action.hover" },
                }}
              >
                {sortOrder === "asc" ? (
                  <ArrowUpIcon
                    sx={{ fontSize: isCompactHeight ? "14px" : "16px" }}
                  />
                ) : (
                  <ArrowDownIcon
                    sx={{ fontSize: isCompactHeight ? "14px" : "16px" }}
                  />
                )}
              </IconButton>
            </Tooltip>
          </Stack>
        )}

        {/* Process List - Virtualized */}
        <Paper
          sx={{
            border: "1px solid",
            borderColor: "divider",
            overflow: "hidden",
          }}
        >
          {/* Header */}
          <Box
            sx={{
              display: "flex",
              alignItems: "center",
              borderBottom: "1px solid",
              borderColor: "divider",
              backgroundColor: "background.paper",
              px: 1,
              py: isCompactHeight ? 0.5 : 1,
            }}
          >
            <Box
              sx={{
                width: "60px",
                fontSize: isCompactHeight ? "10px" : "11px",
                fontWeight: 600,
                flexShrink: 0,
              }}
            >
              PID
            </Box>
            <Box
              sx={{
                flex: 1,
                fontSize: isCompactHeight ? "10px" : "11px",
                fontWeight: 600,
              }}
            >
              Name
            </Box>
            <Box
              sx={{
                width: "50px",
                fontSize: isCompactHeight ? "10px" : "11px",
                fontWeight: 600,
                textAlign: "right",
              }}
            >
              Actions
            </Box>
          </Box>

          {/* Virtualized List */}
          {loading ? (
            <Box
              sx={{
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                py: 2,
                height: isCompactHeight ? 300 : 400,
              }}
            >
              <CircularProgress size={24} />
            </Box>
          ) : filteredProcesses.length === 0 ? (
            <Box
              sx={{
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                py: 2,
                height: 100,
              }}
            >
              <Typography
                variant="body2"
                color="text.secondary"
                sx={{ fontSize: isCompactHeight ? "10px" : "11px" }}
              >
                No processes found
              </Typography>
            </Box>
          ) : (
            <List
              style={{ height: isCompactHeight ? 300 : 400 }}
              rowCount={filteredProcesses.length}
              rowHeight={isCompactHeight ? 28 : 32}
              rowProps={{
                data: {
                  processes: filteredProcesses,
                  attachingPid,
                  selectedPid: processState.processInfo?.pid,
                  isCompactHeight,
                  onAttach: handleAttachProcess,
                },
              }}
              rowComponent={ProcessRow as any}
            />
          )}
        </Paper>

        {!connected && (
          <Typography
            variant="body2"
            color="text.secondary"
            align="center"
            sx={{
              mt: 2,
              fontSize: isCompactHeight ? "10px" : "11px",
            }}
          >
            Connect to server to view processes
          </Typography>
        )}
      </Stack>
    </Paper>
  );
}

```

`src/client/src/components/RealtimeStateDisplay.tsx`:

```tsx
import React from 'react';
import { Box, Typography, Chip, Paper } from '@mui/material';
import { useAppState } from '../hooks/useAppState';

/**
 * Real-time state display component for debugging
 */
export const RealtimeStateDisplay: React.FC = () => {
  // Monitor state with new unified system
  const { system, ui } = useAppState();
  
  const serverConnected = system.serverConnected;
  const debuggerConnected = system.debuggerConnected;
  const attachedProcess = system.attachedProcess?.processname || 'None';
  const isInBreakState = system.isInBreakState;
  const currentThreadId = system.currentThreadId;
  const activeBreakpointsCount = system.activeBreakpoints.length;
  const watchpointsCount = system.watchpoints.length;
  const currentMode = ui.currentMode;
  const lastUpdate = new Date(Math.max(system.lastUpdate, ui.lastUpdate)).toLocaleTimeString();

  return (
    <Paper 
      elevation={2} 
      sx={{ 
        p: 2, 
        mb: 2, 
        backgroundColor: 'rgba(0, 0, 0, 0.7)',
        border: '1px solid #333'
      }}
    >
      <Typography variant="h6" gutterBottom color="primary">
        Real-time State Monitor
      </Typography>
      
      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mb: 2 }}>
        <Chip 
          label={`Server: ${serverConnected ? 'CONNECTED' : 'DISCONNECTED'}`}
          color={serverConnected ? 'success' : 'error'}
          size="small"
        />
        <Chip 
          label={`Debugger: ${debuggerConnected ? 'CONNECTED' : 'DISCONNECTED'}`}
          color={debuggerConnected ? 'success' : 'error'}
          size="small"
        />
        <Chip 
          label={`Process: ${attachedProcess}`}
          color={attachedProcess !== 'None' ? 'info' : 'default'}
          size="small"
        />
      </Box>

      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mb: 2 }}>
        <Chip 
          label={`Break State: ${isInBreakState ? 'ACTIVE' : 'INACTIVE'}`}
          color={isInBreakState ? 'warning' : 'default'}
          size="small"
        />
        <Chip 
          label={`Thread ID: ${currentThreadId || 'N/A'}`}
          color="info"
          size="small"
        />
        <Chip 
          label={`Breakpoints: ${activeBreakpointsCount}`}
          color="secondary"
          size="small"
        />
        <Chip 
          label={`Watchpoints: ${watchpointsCount}`}
          color="secondary"
          size="small"
        />
      </Box>

      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
        <Typography variant="body2" color="text.secondary">
          Mode: <strong>{currentMode}</strong>
        </Typography>
        <Typography variant="body2" color="text.secondary">
          Last Update: {lastUpdate}
        </Typography>
      </Box>
    </Paper>
  );
};

```

`src/client/src/components/RegisterView.tsx`:

```tsx
import React, { useState, useEffect, useCallback, useRef } from "react";
import {
  Box,
  Typography,
  TextField,
  IconButton,
  Tooltip,
  Snackbar,
  Alert,
  Menu,
  MenuItem,
  styled,
} from "@mui/material";
import {
  Check,
  Close,
  Refresh,
  Memory,
  OpenInNew,
  ContentCopy,
} from "@mui/icons-material";
import { getApiClient } from "../lib/api";
import { useAppState } from "../hooks/useAppState";
import { useLocalStorage } from "../hooks/useLocalStorage";

// Vertical resizer styled component for left edge
const VerticalResizer = styled(Box, {
  shouldForwardProp: (prop) => prop !== "isResizing",
})<{ isResizing?: boolean }>(({ isResizing }) => ({
  width: "4px",
  height: "100%",
  backgroundColor: isResizing ? "#4fc1ff" : "transparent",
  cursor: "ew-resize",
  position: "absolute",
  left: 0,
  top: 0,
  transition: "background-color 0.15s ease",
  zIndex: 20,
  "&:hover": {
    backgroundColor: "#4fc1ff",
  },
  "&::before": {
    content: '""',
    position: "absolute",
    top: 0,
    left: "-2px",
    width: "8px",
    height: "100%",
  },
}));

interface RegisterViewProps {
  open: boolean;
  registerData?: Record<string, string>; // Register values from exception data
  isInBreakState?: boolean;
  currentThreadId?: number | null; // Current active thread for register operations
  onWidthChange?: (width: number) => void; // Callback when width changes
}

interface Register {
  name: string;
  value: string;
  type: "general" | "special";
  editable?: boolean;
}

// Format hex value to uppercase (0x000abc -> 0x000ABC)
const formatHexValue = (value: string): string => {
  if (!value) return value;
  // Check if it starts with 0x or 0X
  if (value.toLowerCase().startsWith("0x")) {
    return "0x" + value.slice(2).toUpperCase();
  }
  return value.toUpperCase();
};

export const RegisterView: React.FC<RegisterViewProps> = ({
  open,
  registerData = {},
  isInBreakState = false,
  currentThreadId, // Extract currentThreadId from props
  onWidthChange,
}) => {
  const { uiActions, system } = useAppState();
  const { serverInfo } = system;
  const [registers, setRegisters] = useState<Register[]>([]);
  const [editingRegister, setEditingRegister] = useState<string | null>(null);
  const [editValue, setEditValue] = useState<string>("");
  const [previousRegisterData, setPreviousRegisterData] = useState<
    Record<string, string>
  >({});
  const [changedRegisters, setChangedRegisters] = useState<Set<string>>(
    new Set()
  );
  const [snackbar, setSnackbar] = useState<{
    open: boolean;
    message: string;
    severity: "success" | "error" | "info";
  }>({ open: false, message: "", severity: "info" });

  // Resizable width state with localStorage persistence
  const [panelWidth, setPanelWidth] = useLocalStorage<number>(
    "register-view-width",
    300
  );
  const [isResizing, setIsResizing] = useState(false);
  const resizeStartXRef = useRef<number>(0);
  const resizeStartWidthRef = useRef<number>(0);

  // Handle resize mouse down
  const handleResizeMouseDown = useCallback(
    (e: React.MouseEvent) => {
      e.preventDefault();
      setIsResizing(true);
      resizeStartXRef.current = e.clientX;
      resizeStartWidthRef.current = panelWidth;
    },
    [panelWidth]
  );

  // Handle resize mouse move and mouse up
  useEffect(() => {
    if (!isResizing) return;

    const handleMouseMove = (e: MouseEvent) => {
      // Since resizer is on left edge, moving left increases width
      const deltaX = resizeStartXRef.current - e.clientX;
      const newWidth = Math.max(
        200,
        Math.min(600, resizeStartWidthRef.current + deltaX)
      );
      setPanelWidth(newWidth);
      // Notify parent about width change for grid update
      if (onWidthChange) {
        onWidthChange(newWidth);
      }
    };

    const handleMouseUp = () => {
      setIsResizing(false);
    };

    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    document.body.style.userSelect = "none";
    document.body.style.cursor = "ew-resize";

    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
      document.body.style.userSelect = "";
      document.body.style.cursor = "";
    };
  }, [isResizing, setPanelWidth, onWidthChange]);

  // Ref to track thread switching - skip change detection during thread switch
  const isThreadSwitchingRef = useRef(false);
  const previousThreadIdRef = useRef<number | null | undefined>(
    currentThreadId
  );

  const apiClient = getApiClient();

  // Detect architecture based on register data or serverInfo
  const detectArchitecture = useCallback((): "arm64" | "x86_64" => {
    const keys = Object.keys(registerData);
    const keysLower = keys.map((k) => k.toLowerCase());

    // Check for x86_64 specific registers in registerData
    if (
      keysLower.includes("rax") ||
      keysLower.includes("rip") ||
      keysLower.includes("rbx") ||
      keysLower.includes("rcx")
    ) {
      console.log(
        "[RegisterView] Detected x86_64 architecture from register keys:",
        keys.slice(0, 5)
      );
      return "x86_64";
    }
    // Check for ARM64 specific registers in registerData
    if (
      keysLower.includes("x0") ||
      keysLower.includes("cpsr") ||
      keysLower.includes("x1")
    ) {
      console.log(
        "[RegisterView] Detected ARM64 architecture from register keys:",
        keys.slice(0, 5)
      );
      return "arm64";
    }

    // Fallback: use serverInfo.arch if registerData is empty or inconclusive
    if (serverInfo?.arch) {
      const arch = serverInfo.arch.toLowerCase();
      if (arch === "x86_64" || arch === "amd64" || arch === "x64") {
        console.log(
          "[RegisterView] Using x86_64 architecture from serverInfo:",
          serverInfo.arch
        );
        return "x86_64";
      }
      if (arch === "arm64" || arch === "aarch64") {
        console.log(
          "[RegisterView] Using ARM64 architecture from serverInfo:",
          serverInfo.arch
        );
        return "arm64";
      }
    }

    // Default to arm64 if can't determine
    console.log(
      "[RegisterView] Could not detect architecture, keys:",
      keys,
      "serverInfo:",
      serverInfo?.arch,
      "defaulting to arm64"
    );
    return "arm64";
  }, [registerData, serverInfo]);

  // Initialize registers with both static and dynamic data
  const initializeRegisters = useCallback(() => {
    const startTime = performance.now();
    const arch = detectArchitecture();
    console.log(
      "[RegisterView] Initializing registers for architecture:",
      arch,
      "registerData keys:",
      Object.keys(registerData),
      `time: ${new Date().toISOString()}`
    );

    let baseRegisters: Register[];

    if (arch === "x86_64") {
      // x86_64 registers
      baseRegisters = [
        // General Purpose Registers
        {
          name: "RAX",
          value:
            registerData["rax"] || registerData["RAX"] || "0x0000000000000000",
          type: "general",
          editable: true,
        },
        {
          name: "RBX",
          value:
            registerData["rbx"] || registerData["RBX"] || "0x0000000000000000",
          type: "general",
          editable: true,
        },
        {
          name: "RCX",
          value:
            registerData["rcx"] || registerData["RCX"] || "0x0000000000000000",
          type: "general",
          editable: true,
        },
        {
          name: "RDX",
          value:
            registerData["rdx"] || registerData["RDX"] || "0x0000000000000000",
          type: "general",
          editable: true,
        },
        {
          name: "RSI",
          value:
            registerData["rsi"] || registerData["RSI"] || "0x0000000000000000",
          type: "general",
          editable: true,
        },
        {
          name: "RDI",
          value:
            registerData["rdi"] || registerData["RDI"] || "0x0000000000000000",
          type: "general",
          editable: true,
        },
        {
          name: "RBP",
          value:
            registerData["rbp"] || registerData["RBP"] || "0x0000000000000000",
          type: "general",
          editable: true,
        },
        {
          name: "RSP",
          value:
            registerData["rsp"] || registerData["RSP"] || "0x0000000000000000",
          type: "special",
          editable: true,
        },
        {
          name: "R8",
          value:
            registerData["r8"] || registerData["R8"] || "0x0000000000000000",
          type: "general",
          editable: true,
        },
        {
          name: "R9",
          value:
            registerData["r9"] || registerData["R9"] || "0x0000000000000000",
          type: "general",
          editable: true,
        },
        {
          name: "R10",
          value:
            registerData["r10"] || registerData["R10"] || "0x0000000000000000",
          type: "general",
          editable: true,
        },
        {
          name: "R11",
          value:
            registerData["r11"] || registerData["R11"] || "0x0000000000000000",
          type: "general",
          editable: true,
        },
        {
          name: "R12",
          value:
            registerData["r12"] || registerData["R12"] || "0x0000000000000000",
          type: "general",
          editable: true,
        },
        {
          name: "R13",
          value:
            registerData["r13"] || registerData["R13"] || "0x0000000000000000",
          type: "general",
          editable: true,
        },
        {
          name: "R14",
          value:
            registerData["r14"] || registerData["R14"] || "0x0000000000000000",
          type: "general",
          editable: true,
        },
        {
          name: "R15",
          value:
            registerData["r15"] || registerData["R15"] || "0x0000000000000000",
          type: "general",
          editable: true,
        },
        // Special Registers
        {
          name: "RIP",
          value:
            registerData["rip"] || registerData["RIP"] || "0x0000000000000000",
          type: "special",
          editable: true,
        },
        {
          name: "RFLAGS",
          value:
            registerData["rflags"] ||
            registerData["RFLAGS"] ||
            "0x0000000000000000",
          type: "special",
          editable: true,
        },
        // Segment Registers
        {
          name: "CS",
          value: registerData["cs"] || registerData["CS"] || "0x0000",
          type: "special",
          editable: false,
        },
        {
          name: "SS",
          value: registerData["ss"] || registerData["SS"] || "0x0000",
          type: "special",
          editable: false,
        },
        {
          name: "DS",
          value: registerData["ds"] || registerData["DS"] || "0x0000",
          type: "special",
          editable: false,
        },
        {
          name: "ES",
          value: registerData["es"] || registerData["ES"] || "0x0000",
          type: "special",
          editable: false,
        },
        {
          name: "FS",
          value: registerData["fs"] || registerData["FS"] || "0x0000",
          type: "special",
          editable: false,
        },
        {
          name: "GS",
          value: registerData["gs"] || registerData["GS"] || "0x0000",
          type: "special",
          editable: false,
        },
      ];
    } else {
      // ARM64 registers
      baseRegisters = [
        // ARM64 General Purpose Registers (X0-X29)
        ...Array.from({ length: 30 }, (_, i) => ({
          name: `X${i}`,
          value:
            registerData[`x${i}`] ||
            registerData[`X${i}`] ||
            "0x0000000000000000",
          type: "general" as const,
          editable: true,
        })),
        // Special Registers
        {
          name: "SP",
          value:
            registerData["sp"] || registerData["SP"] || "0x00007FF7BFEFF000",
          type: "special",
          editable: true,
        },
        {
          name: "PC",
          value:
            registerData["pc"] || registerData["PC"] || "0x0000000100001000",
          type: "special",
          editable: true,
        },
        {
          name: "LR",
          value:
            registerData["lr"] || registerData["LR"] || "0x0000000100001020",
          type: "special",
          editable: true,
        },
        {
          name: "FP",
          value:
            registerData["fp"] || registerData["FP"] || "0x00007FF7BFEFEFE0",
          type: "special",
          editable: true,
        },
        {
          name: "CPSR",
          value: registerData["cpsr"] || registerData["CPSR"] || "0x60000000",
          type: "special",
          editable: true,
        },
      ];
    }

    // Format all register values to uppercase hex
    const formattedRegisters = baseRegisters.map((reg) => ({
      ...reg,
      value: formatHexValue(reg.value),
    }));
    setRegisters(formattedRegisters);
    console.log(
      `[RegisterView] initializeRegisters completed in ${(performance.now() - startTime).toFixed(2)}ms at ${new Date().toISOString()}`
    );
  }, [registerData, detectArchitecture]);

  useEffect(() => {
    initializeRegisters();
  }, [initializeRegisters]);

  // Reset previous register data when thread changes (to avoid highlighting all registers)
  useEffect(() => {
    // Detect thread switch
    if (previousThreadIdRef.current !== currentThreadId) {
      console.log(
        `[RegisterView] Thread switched from ${previousThreadIdRef.current} to ${currentThreadId}, disabling change detection temporarily`
      );
      // Set flag to skip change detection for the next registerData update
      isThreadSwitchingRef.current = true;
      previousThreadIdRef.current = currentThreadId;
    }

    if (currentThreadId !== undefined && currentThreadId !== null) {
      console.log(
        `[RegisterView] Thread changed to ${currentThreadId}, resetting previous register data`
      );
      // Reset to current register data so no registers appear as "changed"
      setPreviousRegisterData(
        Object.keys(registerData).reduce(
          (acc, key) => {
            acc[key.toLowerCase()] = registerData[key];
            return acc;
          },
          {} as Record<string, string>
        )
      );
      setChangedRegisters(new Set());
    }
  }, [currentThreadId]); // Only depend on currentThreadId, not registerData

  // Detect changed registers separately
  useEffect(() => {
    // Skip change detection during thread switching
    if (isThreadSwitchingRef.current) {
      console.log(
        `[RegisterView] Skipping change detection due to thread switch`
      );
      isThreadSwitchingRef.current = false;
      // Update previous register data without highlighting changes
      setPreviousRegisterData(
        Object.keys(registerData).reduce(
          (acc, key) => {
            acc[key.toLowerCase()] = registerData[key];
            return acc;
          },
          {} as Record<string, string>
        )
      );
      return;
    }

    // Skip if previousRegisterData is empty (first render)
    if (Object.keys(previousRegisterData).length === 0) {
      setPreviousRegisterData(
        Object.keys(registerData).reduce(
          (acc, key) => {
            acc[key.toLowerCase()] = registerData[key];
            return acc;
          },
          {} as Record<string, string>
        )
      );
      return;
    }

    const newChangedRegisters = new Set<string>();
    Object.keys(registerData).forEach((key) => {
      const normalizedKey = key.toLowerCase();
      const prevValue = previousRegisterData[normalizedKey];
      const currentValue = registerData[key];

      if (prevValue && prevValue !== currentValue) {
        newChangedRegisters.add(normalizedKey);
        console.log(`[RegisterView] Register ${normalizedKey} changed:`, {
          prev: prevValue,
          current: currentValue,
        });
      }
    });

    setChangedRegisters(newChangedRegisters);
    setPreviousRegisterData(
      Object.keys(registerData).reduce(
        (acc, key) => {
          acc[key.toLowerCase()] = registerData[key];
          return acc;
        },
        {} as Record<string, string>
      )
    );

    // Clear changed registers after 3 seconds
    if (newChangedRegisters.size > 0) {
      const timer = setTimeout(() => {
        setChangedRegisters(new Set());
      }, 3000);
      return () => clearTimeout(timer);
    }
  }, [registerData]);

  // Load register values from server when in break state
  const loadRegisterValues = useCallback(async () => {
    if (!isInBreakState) return;

    try {
      const arch = detectArchitecture();
      const registerNames =
        arch === "x86_64"
          ? [
              // x86_64 registers
              "rax",
              "rbx",
              "rcx",
              "rdx",
              "rsi",
              "rdi",
              "rbp",
              "rsp",
              "r8",
              "r9",
              "r10",
              "r11",
              "r12",
              "r13",
              "r14",
              "r15",
              "rip",
              "rflags",
              "cs",
              "ss",
              "ds",
              "es",
              "fs",
              "gs",
            ]
          : [
              // ARM64 registers
              "pc",
              "lr",
              "fp",
              "sp",
              "cpsr",
              ...Array.from({ length: 30 }, (_, i) => `x${i}`),
            ];
      const updatedRegisters = [...registers];

      for (const regName of registerNames) {
        try {
          const response = await apiClient.readRegister(
            regName,
            currentThreadId || undefined
          );
          if (response.success && response.value !== undefined) {
            const regIndex = updatedRegisters.findIndex(
              (r) => r.name.toLowerCase() === regName.toLowerCase()
            );
            if (regIndex >= 0) {
              // Use appropriate padding based on architecture and register type
              const isSegmentReg = [
                "cs",
                "ss",
                "ds",
                "es",
                "fs",
                "gs",
              ].includes(regName.toLowerCase());
              const padLength = isSegmentReg ? 4 : 16;
              updatedRegisters[regIndex].value =
                `0x${response.value.toString(16).padStart(padLength, "0").toUpperCase()}`;
            }
          }
        } catch (error) {
          console.error(`Failed to read register ${regName}:`, error);
        }
      }

      setRegisters(updatedRegisters);
    } catch (error) {
      console.error("Failed to load register values:", error);
      setSnackbar({
        open: true,
        message: "Failed to load register values",
        severity: "error",
      });
    }
  }, [
    isInBreakState,
    registers,
    apiClient,
    currentThreadId,
    detectArchitecture,
  ]);

  // Handle register edit
  const handleEditStart = (registerName: string, currentValue: string) => {
    if (!isInBreakState) return;
    setEditingRegister(registerName);
    setEditValue(currentValue);
  };

  const handleEditCancel = () => {
    setEditingRegister(null);
    setEditValue("");
  };

  const handleEditSave = async (registerName: string) => {
    try {
      // Validate hex value
      let numericValue: number;
      if (editValue.startsWith("0x") || editValue.startsWith("0X")) {
        numericValue = parseInt(editValue, 16);
      } else {
        numericValue = parseInt(editValue, 10);
      }

      if (isNaN(numericValue)) {
        throw new Error("Invalid value format");
      }

      if (!currentThreadId) {
        throw new Error("No thread selected - cannot write register");
      }

      const response = await apiClient.writeRegister(
        registerName.toLowerCase(),
        numericValue,
        currentThreadId
      );

      if (response.success) {
        // Update local state immediately for responsiveness
        setRegisters((prev) =>
          prev.map((reg) =>
            reg.name === registerName
              ? {
                  ...reg,
                  value: `0x${numericValue.toString(16).padStart(16, "0").toUpperCase()}`,
                }
              : reg
          )
        );

        setSnackbar({
          open: true,
          message: `Register ${registerName} updated successfully`,
          severity: "success",
        });

        // Reload register values from server to confirm the write
        setTimeout(() => loadRegisterValues(), 100);
      } else {
        throw new Error(response.message || "Failed to write register");
      }
    } catch (error) {
      console.error("Failed to write register:", error);
      setSnackbar({
        open: true,
        message:
          error instanceof Error ? error.message : "Failed to write register",
        severity: "error",
      });
    } finally {
      setEditingRegister(null);
      setEditValue("");
    }
  };

  const handleRefresh = () => {
    loadRegisterValues();
  };

  if (!open) return null;

  return (
    <Box
      sx={{
        gridArea: "registers",
        backgroundColor: "#1e1e1e",
        borderLeft: "1px solid #2d2d30",
        width: `${panelWidth}px`,
        minWidth: "200px",
        maxWidth: "600px",
        overflow: "auto",
        display: "flex",
        flexDirection: "column",
        position: "relative",
        zIndex: 10,
        "&::-webkit-scrollbar": {
          width: "8px",
        },
        "&::-webkit-scrollbar-track": {
          background: "#1e1e1e",
        },
        "&::-webkit-scrollbar-thumb": {
          background: "#404040",
          borderRadius: "4px",
        },
        "&::-webkit-scrollbar-thumb:hover": {
          background: "#5a5a5e",
        },
      }}
    >
      {/* Resizer handle on left edge */}
      <VerticalResizer
        onMouseDown={handleResizeMouseDown}
        isResizing={isResizing}
      />

      <Box
        sx={{
          display: "flex",
          alignItems: "center",
          justifyContent: "space-between",
          padding: "6px 12px",
          borderBottom: "1px solid #2d2d30",
          backgroundColor: "#252526",
          position: "sticky",
          top: 0,
          zIndex: 1,
          minHeight: "40px",
          height: "40px",
          "@media (max-height: 800px)": {
            padding: "4px 8px",
            minHeight: "30px",
            height: "30px",
          },
        }}
      >
        <Box sx={{ display: "flex", alignItems: "center", gap: 0.5 }}>
          <Memory
            sx={{ fontSize: "14px", color: "#4fc1ff", marginTop: "-1px" }}
          />
          <Typography
            sx={{
              fontSize: "12px",
              fontWeight: "bold",
              color: "#4fc1ff",
              lineHeight: 1,
              "@media (max-height: 800px)": {
                fontSize: "10px",
              },
            }}
          >
            Registers
          </Typography>
        </Box>

        <Box sx={{ display: "flex", alignItems: "center", gap: 0.5 }}>
          {isInBreakState && (
            <Tooltip title="Refresh register values">
              <IconButton
                size="small"
                onClick={handleRefresh}
                sx={{
                  color: "#9cdcfe",
                  "&:hover": { backgroundColor: "#2d2d30" },
                }}
              >
                <Refresh fontSize="small" />
              </IconButton>
            </Tooltip>
          )}
          <Tooltip title="Copy all registers as JSON">
            <IconButton
              size="small"
              onClick={() => {
                // Build JSON object from current register data
                const jsonData: Record<string, string> = {};
                registers.forEach((reg) => {
                  jsonData[reg.name] = reg.value;
                });
                const jsonStr = JSON.stringify(jsonData, null, 2);
                navigator.clipboard.writeText(jsonStr);
                setSnackbar({
                  open: true,
                  message: "Registers copied to clipboard as JSON",
                  severity: "success",
                });
              }}
              sx={{
                color: "#9cdcfe",
                "&:hover": { backgroundColor: "#2d2d30" },
              }}
            >
              <ContentCopy sx={{ fontSize: "16px" }} />
            </IconButton>
          </Tooltip>
        </Box>
      </Box>

      <Box
        sx={{
          p: 1,
          pt: 0.5,
          "@media (max-height: 800px)": {
            p: 0.5,
            pt: 0.25,
          },
        }}
      >
        {/* General Purpose Registers Section */}
        <Typography
          sx={{
            fontSize: "10px",
            fontWeight: "bold",
            color: "#9cdcfe",
            mb: 0.5,
            mt: 0.5,
          }}
        >
          General Purpose Registers
        </Typography>

        {registers
          .filter((reg) => reg.type === "general")
          .map((register) => (
            <RegisterRow
              key={register.name}
              register={register}
              isEditing={editingRegister === register.name}
              editValue={editValue}
              onEditValueChange={setEditValue}
              onEditStart={handleEditStart}
              onEditSave={handleEditSave}
              onEditCancel={handleEditCancel}
              onMemoryNavigate={(address) => {
                console.log(
                  "[RegisterView] Navigate to memory address (General):",
                  register.name,
                  address
                );
                uiActions.setMemoryAddress(address);
              }}
              canEdit={isInBreakState}
              isChanged={changedRegisters.has(register.name.toLowerCase())}
            />
          ))}

        {/* Special Registers Section */}
        <Typography
          sx={{
            fontSize: "10px",
            fontWeight: "bold",
            color: "#dcdcaa",
            mb: 0.5,
            mt: 1,
            pt: 0.5,
            borderTop: "1px solid #2d2d30",
          }}
        >
          Special Registers
        </Typography>

        {registers
          .filter((reg) => reg.type === "special")
          .map((register) => (
            <RegisterRow
              key={register.name}
              register={register}
              isEditing={editingRegister === register.name}
              editValue={editValue}
              onEditValueChange={setEditValue}
              onEditStart={handleEditStart}
              onEditSave={handleEditSave}
              onEditCancel={handleEditCancel}
              onMemoryNavigate={(address) => {
                console.log(
                  "[RegisterView] Navigate to memory address (Special):",
                  register.name,
                  address
                );
                uiActions.setMemoryAddress(address);
              }}
              canEdit={isInBreakState}
              isSpecial
              isChanged={changedRegisters.has(register.name.toLowerCase())}
            />
          ))}
      </Box>

      <Snackbar
        open={snackbar.open}
        autoHideDuration={3000}
        onClose={() => setSnackbar({ ...snackbar, open: false })}
        anchorOrigin={{ vertical: "top", horizontal: "center" }}
      >
        <Alert
          onClose={() => setSnackbar({ ...snackbar, open: false })}
          severity={snackbar.severity}
          sx={{ width: "100%" }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};

interface RegisterRowProps {
  register: Register;
  isEditing: boolean;
  editValue: string;
  onEditValueChange: (value: string) => void;
  onEditStart: (name: string, value: string) => void;
  onEditSave: (name: string) => void;
  onEditCancel: () => void;
  onMemoryNavigate: (address: string) => void;
  canEdit: boolean;
  isSpecial?: boolean;
  isChanged?: boolean;
}

const RegisterRow: React.FC<RegisterRowProps> = ({
  register,
  isEditing,
  editValue,
  onEditValueChange,
  onEditStart,
  onEditSave,
  onEditCancel,
  onMemoryNavigate,
  canEdit,
  isSpecial = false,
  isChanged = false,
}) => {
  const [contextMenu, setContextMenu] = useState<{
    mouseX: number;
    mouseY: number;
  } | null>(null);

  const handleContextMenu = (event: React.MouseEvent) => {
    event.preventDefault();
    event.stopPropagation();
    setContextMenu({
      mouseX: event.clientX,
      mouseY: event.clientY,
    });
  };

  const handleCloseContextMenu = () => {
    setContextMenu(null);
  };

  const handleCopyValue = () => {
    navigator.clipboard.writeText(register.value);
    handleCloseContextMenu();
  };

  const nameColor = isSpecial ? "#dcdcaa" : "#9cdcfe";
  // Changed registers: orange-red (#f48771)
  // Special registers (unchanged): blue (#4fc1ff)
  // General registers (unchanged): orange (#ce9178)
  const valueColor = isChanged ? "#f48771" : isSpecial ? "#4fc1ff" : "#ce9178";

  if (isEditing) {
    return (
      <Box
        sx={{
          display: "flex",
          alignItems: "center",
          py: 0.1,
          px: 0.5,
          fontSize: "11px",
          fontFamily: "monospace",
          borderRadius: "2px",
          backgroundColor: "#2d2d30",
          "@media (max-height: 800px)": {
            fontSize: "9px",
            py: 0,
            px: 0.25,
          },
        }}
      >
        <Typography
          sx={{
            color: nameColor,
            fontSize: "inherit",
            fontFamily: "inherit",
            fontWeight: "bold",
            minWidth: "40px",
            mr: 1,
          }}
        >
          {register.name}
        </Typography>
        <TextField
          size="small"
          value={editValue}
          onChange={(e) => onEditValueChange(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === "Enter") {
              onEditSave(register.name);
            } else if (e.key === "Escape") {
              onEditCancel();
            }
          }}
          sx={{
            flex: 1,
            "& .MuiInputBase-input": {
              fontSize: "11px",
              fontFamily: "monospace",
              color: valueColor,
              py: 0.25,
              px: 0.5,
            },
            "& .MuiOutlinedInput-root": {
              "& fieldset": {
                borderColor: "#404040",
              },
              "&:hover fieldset": {
                borderColor: "#5a5a5e",
              },
              "&.Mui-focused fieldset": {
                borderColor: "#007acc",
              },
            },
          }}
        />
        <IconButton
          size="small"
          onClick={() => onEditSave(register.name)}
          sx={{ ml: 0.5, color: "#4fc1ff", minWidth: "auto", p: 0.25 }}
        >
          <Check fontSize="small" />
        </IconButton>
        <IconButton
          size="small"
          onClick={onEditCancel}
          sx={{ color: "#f48771", minWidth: "auto", p: 0.25 }}
        >
          <Close fontSize="small" />
        </IconButton>
      </Box>
    );
  }

  return (
    <Box
      sx={{
        display: "flex",
        alignItems: "center",
        py: 0.1,
        px: 0.5,
        fontSize: "11px",
        fontFamily: "monospace",
        borderRadius: "2px",
        "&:hover": {
          backgroundColor: canEdit ? "#2d2d30" : "transparent",
          "& .view-icon": {
            opacity: 1,
          },
        },
        cursor: canEdit ? "pointer" : "default",
        "@media (max-height: 800px)": {
          fontSize: "9px",
          py: 0,
          px: 0.25,
        },
      }}
      onClick={(e) => {
        // Don't trigger edit if context menu is open or clicking on the view icon
        if (
          contextMenu !== null ||
          !canEdit ||
          !register.editable ||
          (e.target as HTMLElement).closest(".view-icon-button")
        ) {
          return;
        }
        onEditStart(register.name, register.value);
      }}
      onContextMenu={handleContextMenu}
    >
      <Typography
        sx={{
          color: nameColor,
          fontSize: "inherit",
          fontFamily: "inherit",
          fontWeight: "bold",
          minWidth: "40px",
        }}
      >
        {register.name}
      </Typography>

      <Box
        sx={{
          flex: 1,
          display: "flex",
          alignItems: "center",
          justifyContent: "flex-end",
          gap: 0.5,
        }}
      >
        {/* View Icon */}
        <IconButton
          className="view-icon-button view-icon"
          size="small"
          onClick={(e) => {
            e.stopPropagation();
            console.log(
              "[RegisterView] Navigate to memory address:",
              register.name,
              register.value
            );
            onMemoryNavigate(register.value);
          }}
          sx={{
            opacity: 0,
            transition: "opacity 0.2s",
            color: "#9cdcfe",
            minWidth: "auto",
            p: 0.25,
            "&:hover": {
              backgroundColor: "#3c3c3c",
            },
          }}
        >
          <OpenInNew sx={{ fontSize: "11px" }} />
        </IconButton>

        <Typography
          sx={{
            color: valueColor,
            fontSize: "inherit",
            fontFamily: "inherit",
            letterSpacing: "0.5px",
            cursor: canEdit && register.editable ? "pointer" : "default",
            backgroundColor: isChanged
              ? "rgba(244, 135, 113, 0.2)"
              : "transparent",
            "&:hover": {
              backgroundColor:
                canEdit && register.editable
                  ? "rgba(76, 175, 80, 0.1)"
                  : isChanged
                    ? "rgba(244, 135, 113, 0.25)"
                    : "transparent",
            },
            borderRadius: "2px",
            px: 0.5,
            py: 0.1, // Reduced from 0.25 to 0.1 to match row spacing
            transition: "background-color 0.3s ease",
          }}
          onClick={(e) => {
            e.stopPropagation();
            // Don't trigger edit if context menu is open
            if (contextMenu !== null || !canEdit || !register.editable) {
              return;
            }
            onEditStart(register.name, register.value);
          }}
        >
          {register.value}
        </Typography>
      </Box>

      {/* Context Menu */}
      <Menu
        open={contextMenu !== null}
        onClose={handleCloseContextMenu}
        anchorReference="anchorPosition"
        anchorPosition={
          contextMenu !== null
            ? { top: contextMenu.mouseY, left: contextMenu.mouseX }
            : undefined
        }
      >
        <MenuItem onClick={handleCopyValue}>Copy Value</MenuItem>
      </Menu>
    </Box>
  );
};

```

`src/client/src/components/Resizer.tsx`:

```tsx
import React from "react";
import { Box, styled } from "@mui/material";

interface ResizerProps {
  orientation?: "horizontal" | "vertical";
  onMouseDown: (e: React.MouseEvent) => void;
  isResizing?: boolean;
}

const HorizontalResizer = styled(Box, {
  shouldForwardProp: (prop) => prop !== "isResizing",
})<{ isResizing?: boolean }>(({ isResizing }) => ({
  width: "100%",
  height: "4px",
  backgroundColor: isResizing ? "#4fc1ff" : "transparent",
  cursor: "ns-resize",
  position: "relative",
  transition: "background-color 0.15s ease",
  zIndex: 10,
  "&:hover": {
    backgroundColor: "#4fc1ff",
  },
  "&::before": {
    content: '""',
    position: "absolute",
    top: "-2px",
    left: 0,
    right: 0,
    height: "8px",
  },
}));

const VerticalResizer = styled(Box, {
  shouldForwardProp: (prop) => prop !== "isResizing",
})<{ isResizing?: boolean }>(({ isResizing }) => ({
  width: "4px",
  height: "100%",
  backgroundColor: isResizing ? "#4fc1ff" : "transparent",
  cursor: "ew-resize",
  position: "relative",
  transition: "background-color 0.15s ease",
  zIndex: 10,
  "&:hover": {
    backgroundColor: "#4fc1ff",
  },
  "&::before": {
    content: '""',
    position: "absolute",
    top: 0,
    left: "-2px",
    width: "8px",
    height: "100%",
  },
}));

export const Resizer: React.FC<ResizerProps> = ({
  orientation = "vertical",
  onMouseDown,
  isResizing = false,
}) => {
  if (orientation === "horizontal") {
    return (
      <HorizontalResizer onMouseDown={onMouseDown} isResizing={isResizing} />
    );
  }

  return <VerticalResizer onMouseDown={onMouseDown} isResizing={isResizing} />;
};

```

`src/client/src/components/ScannerContent.tsx`:

```tsx
import React, {
  useState,
  useCallback,
  useMemo,
  useRef,
  useEffect,
} from "react";
import {
  Box,
  Typography,
  LinearProgress,
  Tabs,
  Tab,
  TextField,
  IconButton,
  Menu,
  MenuItem,
  Stack,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  InputLabel,
  Select,
  useMediaQuery,
  Paper,
  Popover,
  ListSubheader,
  Divider,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  FormControlLabel,
  Radio,
  RadioGroup,
} from "@mui/material";
import {
  MoreVert,
  Edit,
  Delete,
  Bookmark,
  Storage,
  BookmarkBorderOutlined,
  Add as AddIcon,
  Stop,
  BugReport,
  History,
  Search,
  FilterList,
  ArrowUpward,
  ArrowDownward,
  Map as MapIcon,
} from "@mui/icons-material";
import { borderColors } from "../utils/theme";
import { MainContent, TabContent, TabPanelProps } from "../utils/constants";
import { useAppState } from "../hooks/useAppState";
import { useColumnResize } from "../hooks/useColumnResize";
import { useLocalStorage } from "../hooks/useLocalStorage";
import { ColumnResizer } from "./ColumnResizer";
import { getApiClient } from "../lib/api";
import {
  normalizeAddressString,
  isLibraryExpression,
  encodeAddressToLibraryExpression,
} from "../utils/addressEncoder";
import {
  ScanResult,
  ScanValueType,
  BookmarkItem,
  WatchpointAccessType,
  WatchpointSize,
  ScanHistoryItem,
} from "../types/index";

// Helper function to format bytes to human readable format
function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

// Tab Panel Component
function TabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`scanner-tabpanel-${index}`}
      aria-labelledby={`scanner-tab-${index}`}
      {...other}
    >
      {value === index && (
        <Paper
          sx={{
            height: "100%",
            display: "flex",
            flexDirection: "column",
            minHeight: 0,
            p: 2,
            backgroundColor: "background.paper",
            borderRadius: "0 4px 4px 4px",
            border: "1px solid",
            borderColor: "divider",
            borderTop: "none",
          }}
        >
          {children}
        </Paper>
      )}
    </div>
  );
}

/**
 * ScannerContent Component
 *
 * フィルタの進捗監視とサーバー側の整合性チェックの実装例:
 *
 * const handleFilter = async (filterParams) => {
 *   setIsFiltering(true);
 *   setFilterProgress(0);
 *
 *   try {
 *     // 1. フィルタ操作を開始
 *     const response = await api.memoryFilter(filterParams);
 *     if (!response.success) {
 *       throw new Error(response.message || 'Filter failed');
 *     }
 *
 *     const filterId = response.data.filter_id;
 *
 *     // 2. 進捗を監視するポーリング
 *     const pollInterval = setInterval(async () => {
 *       try {
 *         const progressResponse = await api.getFilterProgress(filterId);
 *         if (!progressResponse.success) {
 *           throw new Error('Failed to get filter progress');
 *         }
 *
 *         const {
 *           progress_percentage,
 *           is_filtering,
 *           processed_results,
 *           total_results
 *         } = progressResponse.data;
 *
 *         setFilterProgress(progress_percentage);
 *
 *         // 3. フィルタが完了したかチェック
 *         if (!is_filtering && progress_percentage >= 100) {
 *           clearInterval(pollInterval);
 *           setIsFiltering(false);
 *
 *           // 4. 結果が準備できてからfetch
 *           if (total_results > 0 || processed_results >= 0) {
 *             await fetchFilteredResults(filterId);
 *           }
 *         }
 *       } catch (error) {
 *         console.error('Progress polling error:', error);
 *         clearInterval(pollInterval);
 *         setIsFiltering(false);
 *       }
 *     }, 200); // 200msごとにポーリング
 *
 *     // 5. タイムアウト処理 (30秒)
 *     setTimeout(() => {
 *       if (isFiltering) {
 *         clearInterval(pollInterval);
 *         setIsFiltering(false);
 *         console.error('Filter timeout');
 *       }
 *     }, 30000);
 *
 *   } catch (error) {
 *     console.error('Filter error:', error);
 *     setIsFiltering(false);
 *   }
 * };
 *
 * // サーバー側レスポンスフォーマット例:
 * // {
 * //   "success": true,
 * //   "data": {
 * //     "filter_id": "scan_1753605446953_z7uq124ap",
 * //     "progress_percentage": 75,
 * //     "processed_results": 1500,
 * //     "total_results": 2000,
 * //     "is_filtering": true,
 * //     "current_region": "heap"
 * //   }
 * // }
 */

interface ScannerContentProps {
  // Legacy props for backward compatibility - now optional
  scanResults?: ScanResult[];
  isScanning?: boolean;
  isFiltering?: boolean;
  filterProgress?: number;
  scanProgress?: number;
  totalResults?: number;
  scannedBytes?: number;
  totalBytes?: number;
  currentRegion?: string;
  currentScanId?: string;

  // Required callback props
  onResultEdit: (
    address: string,
    newValue: string,
    valueType: ScanValueType,
    inputFormat?: "dec" | "hex"
  ) => void;
  onResultDelete: (address: string) => void;
  onResultBookmark: (address: string, bookmarked: boolean) => void;
  onMemoryRead?: (address: string, size: number) => Promise<ArrayBuffer>;
  onStopScan?: () => Promise<void>;

  // Bookmark props
  bookmarks?: BookmarkItem[];
  onAddManualBookmark?: (
    address: string,
    valueType: ScanValueType,
    description?: string,
    libraryExpression?: string,
    size?: number,
    displayFormat?: "dec" | "hex",
    ptrValueType?: Exclude<ScanValueType, "ptr" | "string" | "bytes" | "regex">
  ) => Promise<boolean>;
  onUpdateBookmark?: (bookmarkId: string, updates: Partial<BookmarkItem>) => void;
  onRemoveBookmark?: (bookmarkId: string) => void;
  isAddressBookmarked?: (address: string) => boolean;
  attachedModules?: any[]; // ModuleInfo array for library+offset parsing

  // Watchpoint props
  onSetWatchpoint?: (
    address: string,
    size: WatchpointSize,
    accessType: WatchpointAccessType,
    description?: string
  ) => Promise<boolean>;
  onRemoveWatchpoint?: (address: string) => Promise<boolean>;
  // watchpoints?: WatchpointInfo[]; // Now using global state
  // isAddressWatched?: (address: string) => boolean; // Now using global state

  // History props
  scanHistory?: ScanHistoryItem[];
  onSelectHistory?: (item: ScanHistoryItem) => void;
  onRemoveHistoryItem?: (id: string) => void;
  onClearHistory?: () => void;

  // Tab control
  currentTab?: number;
  onTabChange?: (tabIndex: number) => void;

  // History search with execution
  onExecuteHistorySearch?: (item: ScanHistoryItem) => void;
}

// Virtual table constants
const ROW_HEIGHT = 32;
const COMPACT_ROW_HEIGHT = 24;
const HEADER_HEIGHT = 36;
const COMPACT_HEADER_HEIGHT = 28;

export const ScannerContent: React.FC<ScannerContentProps> = ({
  // Legacy props (now optional)
  scanResults: propsScanResults,
  isScanning: propsIsScanning,
  isFiltering: propsIsFiltering = false,
  filterProgress: propsFilterProgress = 0,
  scanProgress: propsScanProgress = 0,
  totalResults: propsTotalResults,
  scannedBytes: propsScannedBytes = 0,
  totalBytes: propsTotalBytes = 0,
  currentRegion: propsCurrentRegion,
  currentScanId: propsCurrentScanId,

  // Required callback props
  onResultEdit,
  onResultDelete,
  onResultBookmark,
  onMemoryRead,
  onStopScan,

  // Bookmark props
  bookmarks = [],
  onAddManualBookmark,
  onUpdateBookmark,
  onRemoveBookmark,
  isAddressBookmarked,
  attachedModules = [],
  // Watchpoint props
  onSetWatchpoint,
  // onRemoveWatchpoint, // Not used in this component
  // watchpoints = [], // Now using global state
  // isAddressWatched, // Now using global state
  // History props
  scanHistory = [],
  onSelectHistory,
  onRemoveHistoryItem,
  onClearHistory,
  // Tab control
  currentTab: externalCurrentTab,
  onTabChange,
  // History search with execution
  onExecuteHistorySearch,
}) => {
  // Use global app state
  const { ui, system } = useAppState();

  // Get watchpoints from global state
  const watchpoints = system.watchpoints || [];

  // Helper function to normalize address for comparison (remove 0x prefix, lowercase)
  const normalizeAddress = useCallback((addr: string): string => {
    const stripped = addr.toLowerCase().replace(/^0x/, "");
    return stripped;
  }, []);

  // Helper function to format pointer expression for display
  // Converts [[base+0x10]+0x18] to "base → [+0x10] → [+0x18]"
  const _formatPointerExpressionForDisplay = useCallback((expr: string): string => {
    // Extract all parts by matching the pattern
    const fullPattern = /([A-Za-z0-9_.\-]+\+0x[0-9A-Fa-f]+|\+0x[0-9A-Fa-f]+)/g;
    const matches = expr.match(fullPattern);
    
    if (!matches || matches.length === 0) {
      return expr;
    }
    
    // First match is the base, rest are offsets
    const base = matches[0];
    const offsets = matches.slice(1);
    
    // Build readable format: base → [+0x10] → [+0x18]
    let result = base;
    for (const offset of offsets) {
      result += ` → [${offset}]`;
    }
    
    return result;
  }, []);
  void _formatPointerExpressionForDisplay; // Reserved for future use

  // Helper function to check if an address is watched
  const isAddressWatched = useCallback(
    (address: string): boolean => {
      const normalizedInput = normalizeAddress(address);
      return watchpoints.some(
        (w) => normalizeAddress(String(w.address)) === normalizedInput
      );
    },
    [watchpoints, normalizeAddress]
  );

  // Use app state with fallback to props (for backward compatibility)
  const scanResults = ui.scannerState.scanResults || propsScanResults || [];
  const isScanning = ui.scannerState.isScanning ?? propsIsScanning ?? false;
  const isFiltering = propsIsFiltering; // UI state doesn't have isFiltering yet
  const filterProgress = propsFilterProgress;
  const scanProgress = ui.scannerState.scanProgress ?? propsScanProgress ?? 0;
  const totalResults = ui.scannerState.totalResults ?? propsTotalResults ?? 0;
  const scannedBytes = propsScannedBytes;
  const totalBytes = propsTotalBytes;
  const currentRegion = ui.scannerState.currentRegion ?? propsCurrentRegion;
  const currentScanId = ui.scannerState.scanId ?? propsCurrentScanId;
  const scanSettings = ui.scannerState.scanSettings;
  const unknownScanId = ui.scannerState.unknownScanId;
  
  // Check if this is PTR scan mode
  const isPtrScanMode = (scanSettings as { searchMode?: string })?.searchMode === "ptr";

  // Check if this is an unknown scan that hasn't been narrowed down yet
  // totalResults === -1 means unknown scan with too many results to display
  const isUnknownScanPending = unknownScanId && totalResults === -1;

  const isCompactHeight = useMediaQuery("(max-height: 800px)");
  const [selectedRows, setSelectedRows] = useState<Set<string>>(new Set());
  const [editingRow, setEditingRow] = useState<string | null>(null);
  const [editValue, setEditValue] = useState("");
  const [currentTab, setCurrentTab] = useState(0);
  const [contextMenu, setContextMenu] = useState<{
    mouseX: number;
    mouseY: number;
    address: string;
  } | null>(null);

  // Bookmark context menu state
  const [bookmarkContextMenu, setBookmarkContextMenu] = useState<{
    mouseX: number;
    mouseY: number;
    bookmark: BookmarkItem;
  } | null>(null);

  // Use external tab control if provided, otherwise use internal state
  const activeTab =
    externalCurrentTab !== undefined ? externalCurrentTab : currentTab;

  const handleTabChange = useCallback(
    (newValue: number) => {
      if (onTabChange) {
        onTabChange(newValue);
      } else {
        setCurrentTab(newValue);
      }
    },
    [onTabChange]
  );

  // Edit dialog state
  const [editDialog, setEditDialog] = useState<{
    open: boolean;
    address: string;
    currentValue: string; // Formatted display value
    rawValue: string; // Raw decimal value for conversions
    valueType: ScanValueType | null;
    ptrValueType?: Exclude<ScanValueType, "ptr" | "string" | "bytes" | "regex">; // For ptr type: the underlying value type
    newValue: string;
    inputFormat: "dec" | "hex";
    bookmarkId?: string; // For updating bookmark type without writing value
  }>({
    open: false,
    address: "",
    currentValue: "",
    rawValue: "",
    valueType: null,
    ptrValueType: "int32",
    newValue: "",
    inputFormat: "dec",
    bookmarkId: undefined,
  });

  // Manual bookmark dialog state
  const [manualBookmarkDialog, setManualBookmarkDialog] = useState<{
    open: boolean;
    address: string;
    valueType: ScanValueType;
    ptrValueType: Exclude<ScanValueType, "ptr" | "string" | "bytes" | "regex">; // For ptr type: the underlying value type
    size: number;
    description: string;
    displayFormat: "dec" | "hex";
  }>({
    open: false,
    address: "",
    valueType: "int32",
    ptrValueType: "int32",
    size: 4,
    description: "",
    displayFormat: "dec",
  });

  // Watchpoint dialog state
  const [watchpointDialog, setWatchpointDialog] = useState<{
    open: boolean;
    address: string;
    size: WatchpointSize;
    accessType: WatchpointAccessType;
    description: string;
  }>({
    open: false,
    address: "",
    size: 4,
    accessType: "rw",
    description: "",
  });

  // PointerMap generation state
  const [isGeneratingPointerMap, setIsGeneratingPointerMap] = useState(false);
  const [pointerMapStatus, setPointerMapStatus] = useState<{
    message: string;
    type: "info" | "success" | "error";
  } | null>(null);

  // Filter state for Scan Results (persisted in localStorage)
  const [moduleFilter, setModuleFilter] = useLocalStorage<string>(
    "scanResultsModuleFilter",
    ""
  );

  // Sort state for Address column (persisted in localStorage): "asc" | "desc" | "" (default order)
  const [addressSortOrder, setAddressSortOrder] = useLocalStorage<
    "asc" | "desc" | ""
  >("scanResultsAddressSortOrder", "");

  // Popover state for module filter
  const [filterAnchorEl, setFilterAnchorEl] = useState<HTMLElement | null>(
    null
  );
  const filterPopoverOpen = Boolean(filterAnchorEl);

  // Column resize state for Scan Results table
  const scanResultsColumnResize = useColumnResize({
    storageKey: "scanResultsColumnWidths",
    defaultWidths: {
      address: 140,
      detail: 200,
      value: 100,
      description: 200,
    },
    minWidth: 40,
    maxWidth: 600,
  });

  // Memory update state
  const [updatedValues, setUpdatedValues] = useState<Map<string, string>>(
    new Map()
  );
  // Bookmark memory update state
  const [updatedBookmarkValues, setUpdatedBookmarkValues] = useState<
    Map<string, string>
  >(new Map());
  const updatedBookmarkValuesRef = useRef<Map<string, string>>(new Map());
  const memoryUpdateInterval = useRef<number | null>(null);

  // Keep ref in sync with state
  useEffect(() => {
    updatedBookmarkValuesRef.current = updatedBookmarkValues;
  }, [updatedBookmarkValues]);

  // Force re-fetch when bookmark ptrValueType changes
  const bookmarkTypesKey = useMemo(() => {
    return bookmarks.map(b => `${b.id}:${b.ptrValueType || ''}:${b.type}`).join(',');
  }, [bookmarks]);

  // Track last update time to avoid too frequent re-renders
  const lastBookmarkUpdateRef = useRef<number>(0);

  // Compute library+offset expressions for all scan results (needed for filtering)
  const addressDetails = useMemo(() => {
    const detailsMap = new Map<string, string>();
    if (!attachedModules || attachedModules.length === 0) {
      return detailsMap;
    }

    scanResults.forEach((result) => {
      const addressNum = parseInt(result.address.replace("0x", ""), 16);
      if (isNaN(addressNum)) return;

      const libraryExpr = encodeAddressToLibraryExpression(
        addressNum,
        attachedModules,
        true // prefer short filename
      );

      if (libraryExpr) {
        detailsMap.set(result.address, libraryExpr);
      }
    });

    return detailsMap;
  }, [scanResults, attachedModules]);

  // Get unique module names that appear in scan results for filter dropdown
  const availableModules = useMemo(() => {
    const moduleNames = new Set<string>();
    addressDetails.forEach((detail) => {
      // Extract module name from detail (e.g., "libfoo.dylib + 0x1234" -> "libfoo.dylib")
      const moduleName = detail.split(" + ")[0].trim();
      if (moduleName) {
        moduleNames.add(moduleName);
      }
    });
    return Array.from(moduleNames).sort();
  }, [addressDetails]);

  // Filter scan results based on selected module
  const filteredScanResults = useMemo(() => {
    if (!moduleFilter) {
      return scanResults;
    }

    if (moduleFilter === "__within_modules__") {
      // Show only addresses within any module
      return scanResults.filter((result) => {
        return addressDetails.has(result.address);
      });
    }

    if (moduleFilter === "__outside_modules__") {
      // Show only addresses outside all modules
      return scanResults.filter((result) => {
        return !addressDetails.has(result.address);
      });
    }

    // Filter by specific module name
    return scanResults.filter((result) => {
      const detail = addressDetails.get(result.address);
      if (!detail) return false;
      // Extract module name from detail (e.g., "libfoo.dylib + 0x1234" -> "libfoo.dylib")
      const moduleName = detail.split(" + ")[0].trim();
      return moduleName === moduleFilter;
    });
  }, [scanResults, moduleFilter, addressDetails]);

  // Sort filtered results by address if sort order is set
  const sortedScanResults = useMemo(() => {
    if (!addressSortOrder) {
      return filteredScanResults;
    }

    return [...filteredScanResults].sort((a, b) => {
      const addrA = parseInt(a.address.replace("0x", ""), 16);
      const addrB = parseInt(b.address.replace("0x", ""), 16);
      return addressSortOrder === "asc" ? addrA - addrB : addrB - addrA;
    });
  }, [filteredScanResults, addressSortOrder]);

  // Parse PTR scan results to get pointer chains
  // Each result.value is in format: "module+0x1234 | 0x8 | 0x10"
  const ptrScanData = useMemo((): { 
    maxOffsets: number; 
    parsedResults: Array<{
      address: string;
      baseAddress: string;
      offsets: string[];
      originalResult: typeof sortedScanResults[0];
    }>;
  } => {
    if (!isPtrScanMode) return { maxOffsets: 0, parsedResults: [] };
    
    let maxOffsets = 0;
    const parsedResults = sortedScanResults.map(result => {
      const parts = result.value.split(" | ");
      const baseAddress = parts[0] || "";
      const offsets = parts.slice(1);
      maxOffsets = Math.max(maxOffsets, offsets.length);
      return {
        address: result.address,
        baseAddress,
        offsets,
        originalResult: result,
      };
    });
    
    return { maxOffsets, parsedResults };
  }, [isPtrScanMode, sortedScanResults]);

  const bookmarkUpdateInterval = useRef<number | null>(null);

  // Virtual scrolling state
  const containerRef = useRef<HTMLDivElement>(null);
  const [scrollTop, setScrollTop] = useState(0);
  const [containerHeight, setContainerHeight] = useState(800); // より大きな初期値

  // PTR virtual scrolling state
  const ptrContainerRef = useRef<HTMLDivElement>(null);
  const [ptrScrollTop, setPtrScrollTop] = useState(0);
  const [ptrContainerHeight, setPtrContainerHeight] = useState(400);

  // Bookmark table column widths
  const [bookmarkColumnWidths, setBookmarkColumnWidths] = useState({
    address: 180,
    type: 80,
    value: 120,
    description: 200,
  });
  const [resizingBookmarkColumn, setResizingBookmarkColumn] = useState<
    string | null
  >(null);

  // Bookmark column resize handlers
  const handleBookmarkColumnResizeStart =
    (column: string) => (e: React.MouseEvent) => {
      e.preventDefault();
      setResizingBookmarkColumn(column);
      const startX = e.clientX;
      const startWidth =
        bookmarkColumnWidths[column as keyof typeof bookmarkColumnWidths];

      const handleMouseMove = (moveEvent: MouseEvent) => {
        const diff = moveEvent.clientX - startX;
        const newWidth = Math.max(50, startWidth + diff);
        setBookmarkColumnWidths((prev) => ({
          ...prev,
          [column]: newWidth,
        }));
      };

      const handleMouseUp = () => {
        setResizingBookmarkColumn(null);
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
      };

      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
    };

  // Bookmark context menu handlers
  const handleBookmarkContextMenu = useCallback(
    (event: React.MouseEvent, bookmark: BookmarkItem) => {
      event.preventDefault();
      setBookmarkContextMenu({
        mouseX: event.clientX,
        mouseY: event.clientY,
        bookmark,
      });
    },
    []
  );

  const handleCloseBookmarkContextMenu = useCallback(() => {
    setBookmarkContextMenu(null);
  }, []);

  const handleCopyBookmarkAddress = useCallback(() => {
    if (bookmarkContextMenu?.bookmark) {
      const addr = bookmarkContextMenu.bookmark.address;
      const formatted =
        addr.startsWith("0x") || addr.startsWith("0X")
          ? `0x${addr.slice(2).toUpperCase()}`
          : addr.toUpperCase();
      navigator.clipboard.writeText(formatted);
    }
    handleCloseBookmarkContextMenu();
  }, [bookmarkContextMenu, handleCloseBookmarkContextMenu]);

  const handleCopyBookmarkType = useCallback(() => {
    if (bookmarkContextMenu?.bookmark) {
      navigator.clipboard.writeText(bookmarkContextMenu.bookmark.type);
    }
    handleCloseBookmarkContextMenu();
  }, [bookmarkContextMenu, handleCloseBookmarkContextMenu]);

  const handleCopyBookmarkValue = useCallback(() => {
    if (bookmarkContextMenu?.bookmark) {
      const currentValue =
        updatedBookmarkValues.get(bookmarkContextMenu.bookmark.address) ||
        bookmarkContextMenu.bookmark.value;
      navigator.clipboard.writeText(currentValue);
    }
    handleCloseBookmarkContextMenu();
  }, [
    bookmarkContextMenu,
    updatedBookmarkValues,
    handleCloseBookmarkContextMenu,
  ]);

  const handleCopyBookmarkDescription = useCallback(() => {
    if (bookmarkContextMenu?.bookmark) {
      navigator.clipboard.writeText(
        bookmarkContextMenu.bookmark.description || ""
      );
    }
    handleCloseBookmarkContextMenu();
  }, [bookmarkContextMenu, handleCloseBookmarkContextMenu]);

  // Generate PointerMap for a specific bookmark address
  const handleGeneratePointerMap = useCallback(async (address: string) => {
    setIsGeneratingPointerMap(true);
    setPointerMapStatus({ message: "Starting PointerMap generation...", type: "info" });
    
    try {
      const api = getApiClient();
      
      // Start pointermap generation with progress tracking
      const startResponse = await api.startPointerMapGeneration();
      if (!startResponse.success) {
        throw new Error(startResponse.message || "Failed to start generation");
      }
      
      const taskId = startResponse.task_id;
      
      // Poll for progress
      let isComplete = false;
      let lastProgress = 0;
      while (!isComplete) {
        await new Promise(resolve => setTimeout(resolve, 500)); // Poll every 500ms
        
        const progress = await api.getPointerMapProgress(taskId);
        
        if (progress.error) {
          throw new Error(progress.error);
        }
        
        // Update status with progress
        const progressPct = Math.round(progress.progress_percentage);
        if (progressPct !== lastProgress || progress.current_phase !== "Scanning memory") {
          lastProgress = progressPct;
          const bytesStr = progress.total_bytes > 0 
            ? ` (${formatBytes(progress.processed_bytes)}/${formatBytes(progress.total_bytes)})`
            : "";
          setPointerMapStatus({ 
            message: `${progress.current_phase}: ${progressPct}%${bytesStr}`, 
            type: "info" 
          });
        }
        
        isComplete = progress.is_complete;
      }
      
      // Download the completed pointermap
      setPointerMapStatus({ message: "Downloading PointerMap data...", type: "info" });
      const pointerMapData = await api.downloadPointerMap(taskId);
      
      // Create default filename with the target address
      const addressHex = address.replace("0x", "").replace("0X", "").toUpperCase();
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, 19);
      const defaultFilename = `pointermap_${addressHex}_${timestamp}.dptr`;
      
      setPointerMapStatus({ message: "Saving file...", type: "info" });
      
      // Try to use Tauri save dialog if available
      try {
        const { invoke } = await import("@tauri-apps/api/core");
        const dataArray = new Uint8Array(pointerMapData);
        
        const savedPath = await invoke<string | null>("save_binary_file_dialog", {
          title: "Save PointerMap",
          defaultFilename: defaultFilename,
          filterName: "PointerMap Files",
          filterExtensions: ["dptr"],
          data: Array.from(dataArray),
        });
        
        if (savedPath) {
          setPointerMapStatus({ message: `Saved to: ${savedPath}`, type: "success" });
          console.log(`PointerMap saved to: ${savedPath}`);
        } else {
          // User cancelled the dialog
          setPointerMapStatus(null);
        }
      } catch (tauriError) {
        // Fallback to browser download if Tauri is not available
        console.log("Tauri not available, using browser download");
        const blob = new Blob([pointerMapData], { type: "application/octet-stream" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = defaultFilename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        setPointerMapStatus({ message: `Downloaded: ${defaultFilename}`, type: "success" });
        console.log(`PointerMap saved as ${defaultFilename}`);
      }
      
      // Auto-hide success message after 5 seconds
      setTimeout(() => {
        setPointerMapStatus((prev) => 
          prev?.type === "success" ? null : prev
        );
      }, 5000);
      
    } catch (error) {
      console.error("Failed to generate PointerMap:", error);
      setPointerMapStatus({ 
        message: `Failed: ${error instanceof Error ? error.message : "Unknown error"}`, 
        type: "error" 
      });
    } finally {
      setIsGeneratingPointerMap(false);
    }
  }, []);

  // Calculate visible range for virtual scrolling
  const currentRowHeight = isCompactHeight ? COMPACT_ROW_HEIGHT : ROW_HEIGHT;
  // Ensure at least 10 items are shown even if container height is not calculated yet
  const itemsPerView = Math.max(10, Math.ceil(containerHeight / currentRowHeight));
  const bufferSize = 2; // Small buffer for smooth scrolling
  const visibleStart = Math.max(
    0,
    Math.floor(scrollTop / currentRowHeight) - bufferSize
  );
  const visibleEnd = Math.min(
    visibleStart + itemsPerView + bufferSize * 2,
    scanResults.length
  );

  const visibleResults = useMemo(() => {
    const maxViewableItems = Math.ceil(containerHeight / currentRowHeight);
    console.log(`Virtual scrolling debug:`, {
      visibleStart,
      visibleEnd,
      itemsPerView,
      maxViewableItems,
      containerHeight,
      currentRowHeight,
      totalResults: sortedScanResults.length,
      scrollTop,
      totalContentHeight: sortedScanResults.length * currentRowHeight,
    });
    return sortedScanResults.slice(visibleStart, visibleEnd);
  }, [
    sortedScanResults,
    visibleStart,
    visibleEnd,
    containerHeight,
    scrollTop,
    itemsPerView,
    currentRowHeight,
  ]);

  // Encode visible addresses to library+offset expressions (only for visible rows)
  const visibleAddressDetails = useMemo(() => {
    const detailsMap = new Map<string, string>();
    if (!attachedModules || attachedModules.length === 0) {
      return detailsMap;
    }

    visibleResults.forEach((result) => {
      // Parse address to numeric value
      const addressNum = parseInt(result.address, 16);
      if (!isNaN(addressNum)) {
        // Try to encode to library+offset expression
        const libraryExpr = encodeAddressToLibraryExpression(
          addressNum,
          attachedModules,
          true // prefer short filename
        );
        if (libraryExpr) {
          detailsMap.set(result.address, libraryExpr);
        }
      }
    });

    return detailsMap;
  }, [visibleResults, attachedModules]);

  // Helper function to get data type size
  const getDataTypeSize = useCallback(
    (
      valueType: ScanValueType,
      value?: string,
      explicitSize?: number
    ): number => {
      switch (valueType) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float":
          return 4;
        case "int64":
        case "uint64":
        case "double":
          return 8;
        case "string":
          // For strings, use explicit size if provided, or value length, otherwise default
          if (explicitSize && explicitSize > 0) {
            return explicitSize;
          }
          // Use the string value length (character count = byte count for ASCII)
          if (value && value.length > 0) {
            return value.length;
          }
          return 64; // Default size for string bookmarks
        case "bytes":
          // For bytes, use explicit size if provided
          if (explicitSize && explicitSize > 0) {
            return explicitSize;
          }
          // Fallback: try to calculate from value
          if (value) {
            // Remove spaces and calculate byte length
            const cleanHex = value.toString().replace(/\s/g, "");
            return Math.max(cleanHex.length / 2, 1); // Each pair of hex chars = 1 byte, minimum 1
          }
          return 4; // Default to 4 bytes if no value or size
        case "regex":
          // For regex type, use explicit size if provided, or value length (UTF-8 encoded)
          if (explicitSize && explicitSize > 0) {
            return explicitSize;
          }
          // Use the string value length (UTF-8 byte length)
          if (value && value.length > 0) {
            // Calculate UTF-8 byte length
            const encoder = new TextEncoder();
            return encoder.encode(value).length;
          }
          return 64; // Default size for regex matches
        default:
          return 4;
      }
    },
    []
  );

  // Helper function to convert ArrayBuffer to value based on type
  const convertArrayBufferToValue = useCallback(
    (buffer: ArrayBuffer, valueType: ScanValueType): string => {
      const view = new DataView(buffer);
      const byteLength = buffer.byteLength;
      
      // Helper to check buffer size and return default if insufficient
      const checkSize = (requiredBytes: number): boolean => {
        return byteLength >= requiredBytes;
      };
      
      try {
        switch (valueType) {
          case "int8":
            return checkSize(1) ? view.getInt8(0).toString() : "0";
          case "uint8":
            return checkSize(1) ? view.getUint8(0).toString() : "0";
          case "int16":
            return checkSize(2) ? view.getInt16(0, true).toString() : "0"; // little-endian
          case "uint16":
            return checkSize(2) ? view.getUint16(0, true).toString() : "0"; // little-endian
          case "int32":
            return checkSize(4) ? view.getInt32(0, true).toString() : "0";
          case "uint32":
            return checkSize(4) ? view.getUint32(0, true).toString() : "0"; // little-endian
          case "int64":
            return checkSize(8) ? view.getBigInt64(0, true).toString() : "0";
          case "uint64":
            return checkSize(8) ? view.getBigUint64(0, true).toString() : "0"; // little-endian
          case "float":
            return checkSize(4) ? view.getFloat32(0, true).toString() : "0";
          case "double":
            return checkSize(8) ? view.getFloat64(0, true).toString() : "0";
          case "string":
            // Convert buffer to string, handling null termination
            const uint8Array = new Uint8Array(buffer);
            let str = "";
            for (let i = 0; i < uint8Array.length; i++) {
              const byte = uint8Array[i];
              if (byte === 0) break; // Stop at null terminator
              // Only include printable ASCII characters
              if (byte >= 32 && byte <= 126) {
                str += String.fromCharCode(byte);
              }
              // Non-printable characters are ignored
            }
            return str; // Return empty string if no printable characters
          case "bytes":
            // For bytes type, return space-separated hex format like "11 22 33"
            return Array.from(new Uint8Array(buffer))
              .map((b) => b.toString(16).padStart(2, "0").toUpperCase())
              .join(" ");
          case "regex": {
            // For regex type, convert bytes to UTF-8 string
            const uint8ArrayRegex = new Uint8Array(buffer);
            try {
              const decoder = new TextDecoder("utf-8", { fatal: false });
              return decoder.decode(uint8ArrayRegex);
            } catch (error) {
              // Fallback to hex display
              return Array.from(uint8ArrayRegex)
                .map((b) => b.toString(16).padStart(2, "0").toUpperCase())
                .join(" ");
            }
          }
          default:
            return Array.from(new Uint8Array(buffer))
              .map((b) => b.toString(16).padStart(2, "0"))
              .join("")
              .toUpperCase();
        }
      } catch (error) {
        console.error("Failed to convert buffer to value:", error);
        // Return empty string for string type, "0" for others
        return valueType === "string" ? "" : "0";
      }
    },
    []
  );

  // Function to update memory values for bookmarks
  const updateBookmarkMemoryValues = useCallback(async () => {
    if (!onMemoryRead || bookmarks.length === 0) return;

    try {
      const updatePromises = bookmarks.map(async (bookmark) => {
        try {
          // For PTR type, resolve the pointer chain first
          if (bookmark.type === "ptr") {
            const api = getApiClient();
            const resolveResult = await api.resolveAddress(bookmark.address);
            if (resolveResult.success && resolveResult.data?.address) {
              const resolvedAddr = `0x${resolveResult.data.address.toString(16).toUpperCase()}`;
              // Always read 8 bytes for PTR type, mask based on ptrValueType for display
              const buffer = await onMemoryRead(resolvedAddr, 8);
              const view = new DataView(buffer);
              const fullValue = view.getBigUint64(0, true);
              
              // Mask based on ptrValueType for display
              const ptrValueType = bookmark.ptrValueType || "int32";
              let maskedValue: bigint;
              switch (ptrValueType) {
                case "int8":
                case "uint8":
                  maskedValue = fullValue & 0xFFn;
                  break;
                case "int16":
                case "uint16":
                  maskedValue = fullValue & 0xFFFFn;
                  break;
                case "int32":
                case "uint32":
                case "float":
                  maskedValue = fullValue & 0xFFFFFFFFn;
                  break;
                default:
                  maskedValue = fullValue;
              }
              return { id: bookmark.id, value: maskedValue.toString() };
            }
            // Resolve failed - keep previous value or use stored value
            const previousValue = updatedBookmarkValuesRef.current.get(bookmark.id);
            return { id: bookmark.id, value: previousValue || bookmark.value };
          }
          
          const size = getDataTypeSize(
            bookmark.type,
            bookmark.value,
            bookmark.size
          );
          const buffer = await onMemoryRead(bookmark.address, size);
          const newValue = convertArrayBufferToValue(buffer, bookmark.type);
          return { id: bookmark.id, value: newValue };
        } catch (error) {
          // Memory read failed, keep old value
          const previousValue = updatedBookmarkValuesRef.current.get(bookmark.id);
          return { id: bookmark.id, value: previousValue || bookmark.value };
        }
      });

      const updates = await Promise.all(updatePromises);
      const newUpdatedValues = new Map<string, string>();

      updates.forEach(({ id, value }) => {
        newUpdatedValues.set(id, String(value));
      });

      setUpdatedBookmarkValues(newUpdatedValues);
    } catch (error) {
      console.error("Failed to update bookmark memory values:", error);
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [onMemoryRead, bookmarks, getDataTypeSize, convertArrayBufferToValue, bookmarkTypesKey]);

  // Function to update memory values for visible results
  const updateMemoryValues = useCallback(async () => {
    if (
      !onMemoryRead ||
      isScanning ||
      isFiltering ||
      visibleResults.length === 0
    )
      return;

    try {
      const updatePromises = visibleResults.map(async (result) => {
        try {
          const size = getDataTypeSize(result.type, String(result.value));
          const buffer = await onMemoryRead(result.address, size);
          const newValue = convertArrayBufferToValue(buffer, result.type);
          return { address: result.address, value: newValue };
        } catch (error) {
          // Memory read failed, keep old value
          return { address: result.address, value: result.value };
        }
      });

      const updates = await Promise.all(updatePromises);
      const newUpdatedValues = new Map<string, string>();

      updates.forEach(({ address, value }) => {
        newUpdatedValues.set(address, String(value));
      });

      setUpdatedValues(newUpdatedValues);
    } catch (error) {
      console.error("Failed to update memory values:", error);
    }
  }, [
    onMemoryRead,
    isScanning,
    isFiltering,
    visibleResults,
    getDataTypeSize,
    convertArrayBufferToValue,
  ]);

  // Start/stop memory update interval
  useEffect(() => {
    if (activeTab === 0 && !isScanning && !isFiltering && onMemoryRead) {
      // Start memory updates every 400ms for scan results
      memoryUpdateInterval.current = setInterval(updateMemoryValues, 400);

      return () => {
        if (memoryUpdateInterval.current) {
          clearInterval(memoryUpdateInterval.current);
          memoryUpdateInterval.current = null;
        }
      };
    } else {
      // Stop memory updates
      if (memoryUpdateInterval.current) {
        clearInterval(memoryUpdateInterval.current);
        memoryUpdateInterval.current = null;
      }
    }
  }, [activeTab, isScanning, isFiltering, onMemoryRead, updateMemoryValues]);

  // Start/stop bookmark memory update interval
  useEffect(() => {
    if (activeTab === 1 && onMemoryRead && bookmarks.length > 0) {
      // Start bookmark memory updates every 200ms
      bookmarkUpdateInterval.current = setInterval(
        updateBookmarkMemoryValues,
        200
      );

      return () => {
        if (bookmarkUpdateInterval.current) {
          clearInterval(bookmarkUpdateInterval.current);
          bookmarkUpdateInterval.current = null;
        }
      };
    } else {
      // Stop bookmark memory updates
      if (bookmarkUpdateInterval.current) {
        clearInterval(bookmarkUpdateInterval.current);
        bookmarkUpdateInterval.current = null;
      }
    }
  }, [activeTab, onMemoryRead, bookmarks.length, updateBookmarkMemoryValues]);

  // Trigger immediate update when bookmark types change
  useEffect(() => {
    if (activeTab === 1 && onMemoryRead && bookmarks.length > 0) {
      // Immediate update - don't wait for interval
      const now = Date.now();
      if (now - lastBookmarkUpdateRef.current > 100) {
        lastBookmarkUpdateRef.current = now;
        updateBookmarkMemoryValues();
      }
    }
  }, [activeTab, onMemoryRead, bookmarks, bookmarkTypesKey, updateBookmarkMemoryValues]);

  // Debug watchpoint dialog state changes
  useEffect(() => {
    console.log("Watchpoint dialog state changed:", watchpointDialog);
  }, [watchpointDialog]);
  useEffect(() => {
    const updateHeight = () => {
      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        // Use the actual container height
        const actualHeight = rect.height;
        if (actualHeight > 0) {
          // 有効な高さのみ設定
          console.log(
            "Container height updated:",
            actualHeight,
            "Previous height:",
            containerHeight
          );
          setContainerHeight(actualHeight);
        }
      }
    };

    // 初期設定
    updateHeight();

    // 少し遅延させて再度実行（レンダリング完了後）
    const timer1 = setTimeout(updateHeight, 100);
    const timer2 = setTimeout(updateHeight, 500);

    // Use ResizeObserver for more accurate height tracking
    let resizeObserver: ResizeObserver | null = null;
    if (containerRef.current && window.ResizeObserver) {
      resizeObserver = new ResizeObserver((entries) => {
        for (const entry of entries) {
          const height = entry.contentRect.height;
          if (height > 0) {
            console.log("ResizeObserver: Container height changed to:", height);
            setContainerHeight(height);
          }
        }
      });
      resizeObserver.observe(containerRef.current);
    }

    // PTR container ResizeObserver
    let ptrResizeObserver: ResizeObserver | null = null;
    if (ptrContainerRef.current && window.ResizeObserver) {
      ptrResizeObserver = new ResizeObserver((entries) => {
        for (const entry of entries) {
          const height = entry.contentRect.height;
          if (height > 0) {
            setPtrContainerHeight(height);
          }
        }
      });
      ptrResizeObserver.observe(ptrContainerRef.current);
    }

    const handleResize = () => {
      setTimeout(updateHeight, 100);
    };

    window.addEventListener("resize", handleResize);

    return () => {
      clearTimeout(timer1);
      clearTimeout(timer2);
      window.removeEventListener("resize", handleResize);
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      if (ptrResizeObserver) {
        ptrResizeObserver.disconnect();
      }
    };
  }, [isCompactHeight, scanResults.length]); // scanResults.lengthも依存関係に追加

  // Clear selections when scan results change (e.g., after clear)
  useEffect(() => {
    setSelectedRows(new Set());
  }, [scanResults]);

  const handleRowClick = useCallback(
    (address: string, event: React.MouseEvent) => {
      if (event.ctrlKey || event.metaKey) {
        // Ctrl/Cmd+Click: Toggle selection
        setSelectedRows((prev) => {
          const newSet = new Set(prev);
          if (newSet.has(address)) {
            newSet.delete(address);
          } else {
            newSet.add(address);
          }
          return newSet;
        });
      } else if (event.shiftKey && selectedRows.size > 0) {
        // Shift+Click: Range selection
        const selectedArray = Array.from(selectedRows);
        const lastSelected = selectedArray[selectedArray.length - 1];
        const lastIndex = scanResults.findIndex(
          (r) => r.address === lastSelected
        );
        const currentIndex = scanResults.findIndex(
          (r) => r.address === address
        );

        if (lastIndex !== -1 && currentIndex !== -1) {
          const start = Math.min(lastIndex, currentIndex);
          const end = Math.max(lastIndex, currentIndex);
          const rangeAddresses = scanResults
            .slice(start, end + 1)
            .map((r) => r.address);

          setSelectedRows((prev) => {
            const newSet = new Set(prev);
            rangeAddresses.forEach((addr) => newSet.add(addr));
            return newSet;
          });
        }
      } else {
        // Normal click: Single selection
        setSelectedRows(new Set([address]));
      }
    },
    [selectedRows, scanResults]
  );

  const handleContextMenu = useCallback(
    (event: React.MouseEvent, address: string) => {
      event.preventDefault();
      setContextMenu({
        mouseX: event.clientX,
        mouseY: event.clientY,
        address,
      });
    },
    []
  );

  const handleContextMenuClose = useCallback(() => {
    setContextMenu(null);
  }, []);

  const handleEditStart = useCallback(
    (address: string, currentValue: string) => {
      const result = scanResults.find((r) => r.address === address);
      if (result) {
        setEditDialog({
          open: true,
          address,
          currentValue,
          rawValue: currentValue, // For scan results, raw value is the same as current value (decimal)
          valueType: result.type,
          newValue: currentValue,
          inputFormat: scanSettings?.valueInputFormat || "dec",
          bookmarkId: undefined, // Scan results don't have bookmark ID
        });
      }
      handleContextMenuClose();
    },
    [handleContextMenuClose, scanResults, scanSettings?.valueInputFormat]
  );

  const handleEditDialogClose = useCallback(() => {
    setEditDialog((prev) => ({ ...prev, open: false }));
  }, []);

  const handleEditDialogSave = useCallback(async () => {
    if (editDialog.valueType) {
      try {
        // For ptr type, we need to use the ptrValueType for the actual edit
        const effectiveValueType = editDialog.valueType === "ptr" 
          ? (editDialog.ptrValueType || "int32") 
          : editDialog.valueType;
        
        await onResultEdit(
          editDialog.address,
          editDialog.newValue,
          effectiveValueType,
          editDialog.inputFormat
        );
        handleEditDialogClose();
      } catch (error) {
        console.error("Failed to save edit:", error);
        // Keep dialog open on error
      }
    }
  }, [editDialog, onResultEdit, handleEditDialogClose]);

  const handleManualBookmarkDialogOpen = useCallback(() => {
    setManualBookmarkDialog({
      open: true,
      address: "",
      valueType: "int32",
      ptrValueType: "int32",
      size: 4,
      description: "",
      displayFormat: scanSettings?.valueInputFormat || "dec",
    });
  }, [scanSettings?.valueInputFormat]);

  const handleManualBookmarkDialogClose = useCallback(() => {
    setManualBookmarkDialog((prev) => ({ ...prev, open: false }));
  }, []);

  const handleManualBookmarkDialogSave = useCallback(async () => {
    if (onAddManualBookmark && manualBookmarkDialog.address) {
      try {
        const trimmedAddress = manualBookmarkDialog.address.trim();
        
        console.log("[Bookmark] Adding bookmark with address:", trimmedAddress);
        console.log("[Bookmark] Value type:", manualBookmarkDialog.valueType);

        // Check if the input looks like a pointer expression (arrow format or nested brackets)
        const isArrowFormat = trimmedAddress.includes("→") || trimmedAddress.includes("->");
        const isNestedBracket = trimmedAddress.includes("[[") || (trimmedAddress.startsWith("[") && trimmedAddress.includes("]+"));
        const looksLikePointerExpression = isArrowFormat || isNestedBracket;

        // If user didn't select ptr type but input looks like pointer expression, auto-detect
        if (looksLikePointerExpression && manualBookmarkDialog.valueType !== "ptr") {
          console.log("[Bookmark] Auto-detected pointer expression, switching to ptr type");
          // Handle as ptr type
        }

        // For PTR type OR detected pointer expression, handle pointer expression format
        if (manualBookmarkDialog.valueType === "ptr" || looksLikePointerExpression) {
          console.log("[Bookmark] Detected pointer expression type");
          console.log("[Bookmark] Ptr value type:", manualBookmarkDialog.ptrValueType);
          console.log("[Bookmark] Display format:", manualBookmarkDialog.displayFormat);
          
          // Convert nested format [[base]+0x10]+0x18 to arrow format: base → [0x10] → [0x18]
          let pointerExpression = trimmedAddress;
          
          // Normalize various arrow formats to " → " (with spaces)
          // First, replace -> with →
          pointerExpression = pointerExpression.replace(/->/g, "→");
          // Then normalize spacing around → (remove existing spaces and add consistent ones)
          pointerExpression = pointerExpression.replace(/\s*→\s*/g, " → ");
          
          // Check if it's in nested bracket format [[...]] and convert to arrow format
          if (pointerExpression.includes("[[") || (pointerExpression.startsWith("[") && pointerExpression.includes("]+"))) {
            // Convert [[base+0x10]+0x18]+0x20 to base+0x10 → [0x18] → [0x20]
            // First, extract the innermost base and offsets
            const convertNestedToArrow = (expr: string): string => {
              // Remove outer whitespace
              expr = expr.trim();
              
              // Pattern to match nested pointer format
              // Example: [[Tutorial-x86_64.exe+0x34ECA0]+0x10]+0x18
              const parts: string[] = [];
              let current = expr;
              
              // Extract each level from outside in
              while (current.startsWith("[")) {
                // Find the matching closing bracket and offset
                let depth = 0;
                let closingIndex = -1;
                for (let i = 0; i < current.length; i++) {
                  if (current[i] === "[") depth++;
                  else if (current[i] === "]") {
                    depth--;
                    if (depth === 0) {
                      closingIndex = i;
                      break;
                    }
                  }
                }
                
                if (closingIndex === -1) break;
                
                // Get the offset after the closing bracket
                const after = current.slice(closingIndex + 1);
                const offsetMatch = after.match(/^([+\-]0x[0-9A-Fa-f]+|\+[0-9]+)/i);
                if (offsetMatch) {
                  parts.unshift(offsetMatch[1]);
                }
                
                // Continue with inner content
                current = current.slice(1, closingIndex);
              }
              
              // The remaining current is the base
              if (current) {
                parts.unshift(current);
              }
              
              // Build arrow format: base → [offset1] → [offset2]
              if (parts.length === 0) return expr;
              let result = parts[0];
              for (let i = 1; i < parts.length; i++) {
                result += ` → [${parts[i]}]`;
              }
              return result;
            };
            
            pointerExpression = convertNestedToArrow(pointerExpression);
            console.log("[Bookmark] Converted to arrow format:", pointerExpression);
          }
          
          // Normalize case in the pointer expression (uppercase hex values)
          pointerExpression = pointerExpression.replace(/0x([0-9a-f]+)/gi, (_, hex) => `0x${hex.toUpperCase()}`);
          
          const success = await onAddManualBookmark(
            pointerExpression,
            "ptr",
            manualBookmarkDialog.description || "Pointer chain",
            undefined, // no library expression for ptr
            undefined, // no size for ptr
            manualBookmarkDialog.displayFormat,
            manualBookmarkDialog.ptrValueType
          );

          console.log("[Bookmark] Add result:", success);

          if (success) {
            handleManualBookmarkDialogClose();
          } else {
            alert("Failed to add bookmark. Address may already be bookmarked.");
          }
          return;
        }

        // Non-ptr type handling (original logic)
        let normalizedAddress: string | null;
        let libraryExpression: string | undefined;

        console.log(
          "[Bookmark] Attached modules count:",
          attachedModules?.length || 0
        );

        // Check if it's a library+offset expression
        if (isLibraryExpression(trimmedAddress)) {
          console.log("[Bookmark] Detected library+offset expression");
          // Save the original library expression
          libraryExpression = trimmedAddress;

          normalizedAddress = normalizeAddressString(
            trimmedAddress,
            attachedModules
          );

          console.log("[Bookmark] Normalized address:", normalizedAddress);

          if (!normalizedAddress) {
            console.error(
              "Failed to parse library+offset expression:",
              trimmedAddress
            );
            alert(
              "Failed to parse library+offset expression. Make sure the module is loaded."
            );
            return;
          }
        } else {
          console.log("[Bookmark] Detected direct address");
          // Direct address - normalize (no library expression)
          normalizedAddress = normalizeAddressString(trimmedAddress);

          console.log("[Bookmark] Normalized address:", normalizedAddress);

          if (!normalizedAddress) {
            console.error("Invalid address format:", trimmedAddress);
            alert("Invalid address format");
            return;
          }
        }

        // Ensure uppercase format
        const hexPart = normalizedAddress.replace(/^0x/i, "");
        normalizedAddress = `0x${hexPart.toUpperCase()}`;

        console.log("[Bookmark] Final normalized address:", normalizedAddress);
        console.log("[Bookmark] Library expression:", libraryExpression);
        console.log("[Bookmark] Value type:", manualBookmarkDialog.valueType);
        console.log("[Bookmark] Size:", manualBookmarkDialog.size);
        console.log(
          "[Bookmark] Display format:",
          manualBookmarkDialog.displayFormat
        );

        // Determine size for string/bytes types
        const size =
          manualBookmarkDialog.valueType === "string" ||
          manualBookmarkDialog.valueType === "bytes"
            ? manualBookmarkDialog.size
            : undefined;

        const success = await onAddManualBookmark(
          normalizedAddress,
          manualBookmarkDialog.valueType,
          manualBookmarkDialog.description || undefined,
          libraryExpression,
          size,
          manualBookmarkDialog.displayFormat,
          undefined // no ptrValueType for non-ptr types
        );

        console.log("[Bookmark] Add result:", success);

        if (success) {
          handleManualBookmarkDialogClose();
        } else {
          alert("Failed to add bookmark. Address may already be bookmarked.");
        }
      } catch (error) {
        console.error("Failed to add manual bookmark:", error);
        alert(
          `Error adding bookmark: ${error instanceof Error ? error.message : "Unknown error"}`
        );
        // Keep dialog open on error
      }
    }
  }, [
    manualBookmarkDialog,
    onAddManualBookmark,
    handleManualBookmarkDialogClose,
    attachedModules,
  ]);

  const handleWatchpointDialogOpen = useCallback((address?: string) => {
    console.log("handleWatchpointDialogOpen called with address:", address);
    const newDialog = {
      open: true,
      address: address || "",
      size: 4 as WatchpointSize,
      accessType: "rw" as WatchpointAccessType,
      description: "",
    };
    console.log("Setting watchpoint dialog state:", newDialog);
    setWatchpointDialog(newDialog);
  }, []);

  const handleWatchpointDialogClose = useCallback(() => {
    setWatchpointDialog((prev) => ({ ...prev, open: false }));
  }, []);

  const handleWatchpointDialogSave = useCallback(async () => {
    console.log("handleWatchpointDialogSave called with:", watchpointDialog);
    if (onSetWatchpoint && watchpointDialog.address) {
      try {
        // Normalize address to hex format
        let normalizedAddress = watchpointDialog.address.trim();

        // If address is decimal, convert to hex
        if (!/^0x/i.test(normalizedAddress)) {
          const decimalValue = parseInt(normalizedAddress, 10);
          if (!isNaN(decimalValue)) {
            normalizedAddress = `0x${decimalValue.toString(16).toUpperCase()}`;
          }
        } else {
          // If already hex, ensure proper format (0x + uppercase hex)
          const hexPart = normalizedAddress.slice(2);
          normalizedAddress = `0x${hexPart.toUpperCase()}`;
        }

        console.log("Calling onSetWatchpoint with:", {
          address: normalizedAddress,
          size: watchpointDialog.size,
          accessType: watchpointDialog.accessType,
          description: watchpointDialog.description || undefined,
        });

        const success = await onSetWatchpoint(
          normalizedAddress,
          watchpointDialog.size,
          watchpointDialog.accessType,
          watchpointDialog.description || undefined
        );
        if (success) {
          handleWatchpointDialogClose();
        }
      } catch (error) {
        console.error("Failed to set watchpoint:", error);
        // Keep dialog open on error
      }
    } else {
      console.warn("onSetWatchpoint handler not provided or address is empty");
      // For testing, just close the dialog
      alert(
        `Watchpoint would be set for ${watchpointDialog.address} (${watchpointDialog.size} bytes, ${watchpointDialog.accessType})`
      );
      handleWatchpointDialogClose();
    }
  }, [watchpointDialog, onSetWatchpoint, handleWatchpointDialogClose]);

  const handleEditSave = useCallback(
    async (address: string) => {
      try {
        const result = scanResults.find((r) => r.address === address);
        if (result) {
          await onResultEdit(address, editValue, result.type);
          setEditingRow(null);
          setEditValue("");
        }
      } catch (error) {
        console.error("Failed to save edit:", error);
        // Keep editing mode on error so user can try again
      }
    },
    [editValue, onResultEdit, scanResults]
  );

  const handleEditCancel = useCallback(() => {
    setEditingRow(null);
    setEditValue("");
  }, []);

  const formatValue = useCallback(
    (result: ScanResult) => {
      // Check if we have an updated value from memory reading
      const updatedValue = updatedValues.get(result.address);
      const value = updatedValue || result.value;
      //console.log(updatedValue);

      // Check if hex display is requested for integer types
      const isHexDisplay = scanSettings?.valueInputFormat === "hex";
      const isIntegerType = [
        "int8",
        "uint8",
        "int16",
        "uint16",
        "int32",
        "uint32",
        "int64",
        "uint64",
      ].includes(result.type);

      // For bytes type, the value has already been processed by convertHexBytesToValue
      // and should be in the correct format (space-separated hex), so just return it
      if (result.type === "bytes") {
        return value.toString();
      }

      // For regex type, the value should already be a UTF-8 string
      if (result.type === "regex") {
        return value.toString();
      }

      // Special handling for string type - display as readable text
      if (result.type === "string") {
        // If the value is a hex string, try to convert it to readable text
        if (typeof value === "string" && value.startsWith("0x")) {
          try {
            const hexString = value.slice(2); // Remove "0x" prefix
            let text = "";
            for (let i = 0; i < hexString.length; i += 2) {
              const byte = parseInt(hexString.substr(i, 2), 16);
              // Only include printable ASCII characters (32-126) and common extended chars
              if ((byte >= 32 && byte <= 126) || byte === 0) {
                text += byte === 0 ? "" : String.fromCharCode(byte);
              } else {
                // For non-printable characters, show as hex
                text += `\\x${byte.toString(16).padStart(2, "0")}`;
              }
            }
            return text || value; // Return hex if conversion fails
          } catch (error) {
            return value; // Return original value if parsing fails
          }
        }
        // If already a readable string, return as-is
        return value.toString();
      }

      // For integer types with hex display mode
      if (isIntegerType && isHexDisplay) {
        try {
          // Parse the value as a number
          let numValue: bigint | number;
          if (typeof value === "string") {
            if (value.startsWith("0x")) {
              numValue = BigInt(value);
            } else {
              numValue = ["int64", "uint64"].includes(result.type)
                ? BigInt(value)
                : parseInt(value, 10);
            }
          } else {
            numValue = Number(value);
          }
          // Format as hex with 0x prefix (handle signed integers with two's complement)
          let hexStr: string;
          if (typeof numValue === "bigint") {
            if (numValue < 0n) {
              // Two's complement for 64-bit
              const mask = (1n << 64n) - 1n;
              hexStr = (numValue & mask).toString(16).toUpperCase();
            } else {
              hexStr = numValue.toString(16).toUpperCase();
            }
          } else {
            if (numValue < 0) {
              // Two's complement based on type using bitwise AND with proper mask
              let hexStr: string;
              if (result.type === "int8") {
                hexStr = ((numValue & 0xff) >>> 0)
                  .toString(16)
                  .toUpperCase()
                  .padStart(2, "0");
              } else if (result.type === "int16") {
                hexStr = ((numValue & 0xffff) >>> 0)
                  .toString(16)
                  .toUpperCase()
                  .padStart(4, "0");
              } else {
                // int32: >>> 0 converts to unsigned 32-bit
                hexStr = (numValue >>> 0)
                  .toString(16)
                  .toUpperCase()
                  .padStart(8, "0");
              }
              return "0x" + hexStr;
            } else {
              hexStr = numValue.toString(16).toUpperCase();
            }
          }
          return "0x" + hexStr;
        } catch (e) {
          // Fallback to original value
          return value.toString();
        }
      }

      // If value is already a number or formatted string from our converter, display it directly
      if (typeof value === "string" && !value.startsWith("0x")) {
        // For numeric types, display the value as is
        switch (result.type) {
          case "int8":
          case "int16":
          case "int32":
          case "int64":
          case "uint8":
          case "uint16":
          case "uint32":
          case "uint64":
            return value; // Display the converted integer value
          case "float":
          case "double":
            return parseFloat(value).toString(); // Display float value
          default:
            return value;
        }
      } else if (typeof value === "string" && value.startsWith("0x")) {
        // For hex values - if dec mode for integer types, convert to decimal
        if (!isHexDisplay && isIntegerType) {
          try {
            const numValue = ["int64", "uint64"].includes(result.type)
              ? BigInt(value)
              : parseInt(value, 16);
            return numValue.toString();
          } catch {
            return value;
          }
        }
        // Otherwise display as hex
        return value;
      } else {
        // Fallback: try to interpret as number for display
        try {
          const numValue = Number(value);
          if (!isNaN(numValue)) {
            switch (result.type) {
              case "int8":
              case "int16":
              case "int32":
              case "int64":
              case "uint8":
              case "uint16":
              case "uint32":
              case "uint64":
                return numValue.toString();
              case "float":
              case "double":
                return numValue.toString();
              default:
                return value.toString();
            }
          }
        } catch (e) {
          // ignore
        }
        return value.toString();
      }
    },
    [updatedValues, scanSettings?.valueInputFormat]
  );

  return (
    <MainContent sx={{ height: "100%", p: 2 }}>
      {/* Chrome-style tabs */}
      <Box sx={{ display: "flex", alignItems: "flex-end" }}>
        <Tabs
          value={activeTab}
          onChange={(_, newValue) => handleTabChange(newValue)}
          aria-label="scanner tabs"
          sx={{
            minHeight: "28px",
            "& .MuiTabs-indicator": {
              display: "none",
            },
            "& .MuiTab-root": {
              minHeight: "28px",
              minWidth: "80px",
              fontSize: "11px",
              textTransform: "none",
              fontWeight: 500,
              px: 1.5,
              py: 0.5,
              borderTopLeftRadius: "6px",
              borderTopRightRadius: "6px",
              border: "1px solid",
              borderBottom: "none",
              borderColor: "divider",
              backgroundColor: "action.hover",
              color: "text.secondary",
              marginRight: "2px",
              "&.Mui-selected": {
                backgroundColor: "background.paper",
                color: "primary.main",
                fontWeight: 600,
              },
            },
          }}
        >
          <Tab
            icon={<Storage sx={{ fontSize: "12px" }} />}
            iconPosition="start"
            label="Results"
            id="scanner-tab-0"
            aria-controls="scanner-tabpanel-0"
            sx={{ gap: 0.5 }}
          />
          <Tab
            icon={<BookmarkBorderOutlined sx={{ fontSize: "12px" }} />}
            iconPosition="start"
            label="Bookmarks"
            id="scanner-tab-1"
            aria-controls="scanner-tabpanel-1"
            sx={{ gap: 0.5 }}
          />
          <Tab
            icon={<History sx={{ fontSize: "12px" }} />}
            iconPosition="start"
            label="History"
            id="scanner-tab-2"
            aria-controls="scanner-tabpanel-2"
            sx={{ gap: 0.5 }}
          />
        </Tabs>
      </Box>

      {/* Content area with top border connecting to tabs */}
      <Box
        sx={{
          borderTop: "1px solid",
          borderColor: "divider",
          mt: "-1px",
        }}
      >
        <TabPanel value={activeTab} index={0}>
          <TabContent sx={{ overflow: "hidden", height: "100%" }}>
            {isScanning || isFiltering ? (
              <Box sx={{ p: isCompactHeight ? 2 : 3, textAlign: "center" }}>
                <Typography
                  variant="h6"
                  gutterBottom
                  sx={{
                    fontSize: isCompactHeight ? "14px" : "18px",
                    mb: isCompactHeight ? 1 : 2,
                  }}
                >
                  {isScanning ? "Scanning Memory..." : "Filtering Results..."}
                </Typography>
                {isScanning && (
                  <>
                    <LinearProgress
                      variant="determinate"
                      value={scanProgress}
                      sx={{
                        mb: isCompactHeight ? 1 : 2,
                        width: "100%",
                        maxWidth: 400,
                        mx: "auto",
                        height: isCompactHeight ? "4px" : "6px",
                      }}
                    />
                    <Typography
                      variant="body2"
                      color="text.secondary"
                      gutterBottom
                      sx={{
                        fontSize: isCompactHeight ? "10px" : "14px",
                        mb: isCompactHeight ? 0.5 : 1,
                      }}
                    >
                      {scanProgress.toFixed(1)}% complete
                    </Typography>
                    {totalBytes > 0 && (
                      <Typography
                        variant="caption"
                        color="text.secondary"
                        display="block"
                        sx={{
                          fontSize: isCompactHeight ? "9px" : "12px",
                        }}
                      >
                        {(scannedBytes / (1024 * 1024)).toFixed(1)} MB /{" "}
                        {(totalBytes / (1024 * 1024)).toFixed(1)} MB
                      </Typography>
                    )}
                    {currentRegion && (
                      <Typography
                        variant="caption"
                        color="text.secondary"
                        display="block"
                        sx={{
                          mt: isCompactHeight ? 0.5 : 1,
                          fontSize: isCompactHeight ? "9px" : "12px",
                        }}
                      >
                        Scanning: {currentRegion}
                      </Typography>
                    )}
                    <Box sx={{ mt: isCompactHeight ? 1 : 2 }}>
                      <Button
                        variant="outlined"
                        color="error"
                        startIcon={<Stop />}
                        onClick={async () => {
                          if (onStopScan && currentScanId) {
                            try {
                              await onStopScan();
                            } catch (error) {
                              console.error("Failed to stop scan:", error);
                            }
                          }
                        }}
                        sx={{
                          mr: 1,
                          fontSize: isCompactHeight ? "10px" : "14px",
                          minHeight: isCompactHeight ? "24px" : "32px",
                          padding: isCompactHeight ? "2px 8px" : "4px 12px",
                        }}
                      >
                        Stop Scan
                      </Button>
                    </Box>
                  </>
                )}
                {isFiltering && (
                  <>
                    <LinearProgress
                      variant={
                        filterProgress > 0 ? "determinate" : "indeterminate"
                      }
                      value={filterProgress > 0 ? filterProgress : undefined}
                      sx={{
                        mb: isCompactHeight ? 1 : 2,
                        width: "100%",
                        maxWidth: 400,
                        mx: "auto",
                        height: isCompactHeight ? "4px" : "6px",
                      }}
                    />
                    {filterProgress > 0 && (
                      <Typography
                        variant="body2"
                        color="text.secondary"
                        gutterBottom
                        sx={{
                          fontSize: isCompactHeight ? "10px" : "14px",
                          mb: isCompactHeight ? 0.5 : 1,
                        }}
                      >
                        {filterProgress.toFixed(1)}% complete
                      </Typography>
                    )}
                    <Typography
                      variant="caption"
                      color="text.secondary"
                      display="block"
                      sx={{
                        fontSize: isCompactHeight ? "9px" : "12px",
                      }}
                    >
                      Please wait for filter to complete before viewing results
                    </Typography>
                  </>
                )}
              </Box>
            ) : scanResults.length === 0 ? (
              /* Empty state - no scan results OR unknown scan pending */
              <Box
                sx={{
                  p: isCompactHeight ? 2 : 3,
                  textAlign: "center",
                  display: "flex",
                  flexDirection: "column",
                  alignItems: "center",
                  justifyContent: "center",
                  height: "100%",
                }}
              >
                {isUnknownScanPending ? (
                  /* Unknown scan completed but results too large to display */
                  <>
                    <Storage
                      sx={{
                        fontSize: isCompactHeight ? 32 : 48,
                        color: "info.main",
                        mb: isCompactHeight ? 1 : 2,
                      }}
                    />
                    <Typography
                      variant="h6"
                      gutterBottom
                      sx={{
                        fontSize: isCompactHeight ? "14px" : "18px",
                        mb: isCompactHeight ? 1 : 2,
                      }}
                    >
                      Unknown Scan Complete
                    </Typography>
                    <Typography
                      variant="body2"
                      color="text.secondary"
                      sx={{
                        fontSize: isCompactHeight ? "11px" : "14px",
                        mb: 1,
                      }}
                    >
                      Memory snapshot saved. Use Next Scan to filter results.
                    </Typography>
                    <Typography
                      variant="body2"
                      color="text.secondary"
                      sx={{
                        fontSize: isCompactHeight ? "10px" : "12px",
                      }}
                    >
                      Results will be displayed after narrowing down to ~1M
                      entries
                    </Typography>
                  </>
                ) : (
                  /* Normal empty state */
                  <>
                    <Search
                      sx={{
                        fontSize: isCompactHeight ? 32 : 48,
                        color: "text.disabled",
                        mb: isCompactHeight ? 1 : 2,
                      }}
                    />
                    <Typography
                      variant="h6"
                      gutterBottom
                      sx={{
                        fontSize: isCompactHeight ? "14px" : "18px",
                        mb: isCompactHeight ? 1 : 2,
                      }}
                    >
                      No Scan Results
                    </Typography>
                    <Typography
                      variant="body2"
                      color="text.secondary"
                      sx={{
                        fontSize: isCompactHeight ? "11px" : "14px",
                      }}
                    >
                      Use the scanner panel to search for values in memory
                    </Typography>
                  </>
                )}
              </Box>
            ) : (
              <>
                {/* Header */}
                <Box
                  sx={{
                    p: isCompactHeight ? 1.5 : 2,
                    borderBottom: `1px solid ${borderColors.main}`,
                  }}
                >
                  <Stack
                    direction="row"
                    justifyContent="space-between"
                    alignItems="center"
                  >
                    <Typography
                      variant="h6"
                      sx={{
                        fontSize: isCompactHeight ? "14px" : "18px",
                      }}
                    >
                      Scan Results
                    </Typography>
                    <Stack direction="row" spacing={2} alignItems="center">
                      {selectedRows.size > 0 && (
                        <Typography
                          variant="body2"
                          color="text.secondary"
                          sx={{
                            fontSize: isCompactHeight ? "10px" : "14px",
                          }}
                        >
                          {selectedRows.size} selected
                        </Typography>
                      )}
                      <Typography
                        variant="body2"
                        color="text.secondary"
                        sx={{
                          fontSize: isCompactHeight ? "10px" : "14px",
                        }}
                      >
                        {filteredScanResults.length.toLocaleString()} /{" "}
                        {totalResults.toLocaleString()} results
                      </Typography>
                    </Stack>
                  </Stack>

                  {/* Divider line below Scan Results header */}
                  <Box
                    sx={{
                      mt: 1.5,
                      borderBottom: `1px solid ${borderColors.main}`,
                    }}
                  />
                </Box>

                {/* Virtual Results Table - PTR mode has different structure */}
                {isPtrScanMode ? (
                  /* PTR Scan Results Table - shows pointer chains */
                  <Box
                    sx={{
                      flex: 1,
                      display: "flex",
                      flexDirection: "column",
                      height: "100%",
                      overflow: "hidden",
                    }}
                  >
                    {/* PTR Table Header */}
                    <Box
                      sx={{
                        backgroundColor: "#080808",
                        borderBottom: `2px solid ${borderColors.main}`,
                        display: "flex",
                        alignItems: "center",
                        height: isCompactHeight
                          ? COMPACT_HEADER_HEIGHT
                          : HEADER_HEIGHT,
                        px: isCompactHeight ? 1 : 2,
                        overflowX: "auto",
                      }}
                    >
                      {/* Base Address Column */}
                      <Box
                        sx={{
                          width: "auto",
                          minWidth: "150px",
                          maxWidth: "300px",
                          fontWeight: 600,
                          color: "text.primary",
                          fontSize: isCompactHeight ? "11px" : "13px",
                          px: 1,
                        }}
                      >
                        Base Address
                      </Box>
                      {/* Offset Columns - dynamically generated based on max chain length */}
                      {Array.from({ length: ptrScanData.maxOffsets }, (_, i) => (
                        <Box
                          key={`offset-header-${i}`}
                          sx={{
                            width: "auto",
                            minWidth: "70px",
                            maxWidth: "120px",
                            fontWeight: 600,
                            color: "text.primary",
                            fontSize: isCompactHeight ? "11px" : "13px",
                            px: 1,
                            borderLeft: "1px solid #333",
                          }}
                        >
                          Offset {i}
                        </Box>
                      ))}
                      {/* Actions Column */}
                      <Box
                        sx={{
                          width: "48px",
                          fontWeight: 600,
                          color: "text.primary",
                          fontSize: isCompactHeight ? "11px" : "13px",
                          textAlign: "center",
                          marginLeft: "auto",
                        }}
                      >
                        Actions
                      </Box>
                    </Box>

                    {/* PTR Table Body - Manual Virtual Scrolling */}
                    <Box
                      ref={ptrContainerRef}
                      sx={{
                        flex: 1,
                        overflow: "auto",
                        position: "relative",
                        minHeight: 200,
                        maxHeight: "calc(100vh - 300px)",
                        height: "100%",
                        "&::-webkit-scrollbar": {
                          width: "14px",
                          backgroundColor: "#1e1e1e",
                        },
                        "&::-webkit-scrollbar-track": {
                          background: "#1e1e1e",
                          borderRadius: "7px",
                          border: "1px solid #333",
                        },
                        "&::-webkit-scrollbar-thumb": {
                          background: "#555",
                          borderRadius: "7px",
                          border: "2px solid #1e1e1e",
                          backgroundClip: "content-box",
                          minHeight: "30px",
                          "&:hover": {
                            background: "#777",
                          },
                          "&:active": {
                            background: "#999",
                          },
                        },
                        scrollbarWidth: "auto",
                        scrollbarColor: "#555 #1e1e1e",
                      }}
                      onScroll={(e) => {
                        const target = e.target as HTMLDivElement;
                        setPtrScrollTop(target.scrollTop);
                      }}
                    >
                      {(() => {
                        const ptrRowHeight = isCompactHeight ? 24 : 32;
                        // Ensure at least 10 items are shown even if container height is not calculated yet
                        const ptrItemsPerView = Math.max(10, Math.ceil(ptrContainerHeight / ptrRowHeight));
                        const ptrBufferSize = 5;
                        const ptrVisibleStart = Math.max(
                          0,
                          Math.floor(ptrScrollTop / ptrRowHeight) - ptrBufferSize
                        );
                        const ptrVisibleEnd = Math.min(
                          ptrVisibleStart + ptrItemsPerView + ptrBufferSize * 2,
                          ptrScanData.parsedResults.length
                        );
                        const ptrVisibleResults = ptrScanData.parsedResults.slice(ptrVisibleStart, ptrVisibleEnd);

                        return (
                          <>
                            {/* Total height container for proper scrollbar */}
                            <Box
                              sx={{
                                height: ptrScanData.parsedResults.length * ptrRowHeight,
                                position: "relative",
                                width: "100%",
                              }}
                            >
                              {/* Visible items positioned absolutely */}
                              <Box
                                sx={{
                                  position: "absolute",
                                  top: ptrVisibleStart * ptrRowHeight,
                                  left: 0,
                                  right: 0,
                                  width: "100%",
                                }}
                              >
                                {ptrVisibleResults.map((item, index) => {
                                  const actualIndex = ptrVisibleStart + index;
                                  const buildExpression = () => {
                                    const offsets = item.offsets.filter((o: string) => o);
                                    let expr = item.baseAddress;
                                    for (const offset of offsets) {
                                      expr += ` → [${offset}]`;
                                    }
                                    return expr;
                                  };

                                  return (
                                    <Box
                                      key={`ptr-result-${actualIndex}`}
                                      sx={{
                                        display: "flex",
                                        alignItems: "center",
                                        height: ptrRowHeight,
                                        px: isCompactHeight ? 1 : 2,
                                        borderBottom: "1px solid",
                                        borderColor: "divider",
                                        backgroundColor: selectedRows.has(item.address)
                                          ? "action.selected"
                                          : actualIndex % 2 === 0
                                            ? "#2a2a2a"
                                            : "#1e1e1e",
                                        "&:hover": {
                                          backgroundColor: "action.hover",
                                        },
                                        cursor: "pointer",
                                      }}
                                      onClick={(event) =>
                                        handleRowClick(item.address, event)
                                      }
                                      onContextMenu={(event) => {
                                        event.preventDefault();
                                        setContextMenu({
                                          mouseX: event.clientX,
                                          mouseY: event.clientY,
                                          address: buildExpression(),
                                        });
                                      }}
                                    >
                                      {/* Base Address */}
                                      <Box
                                        sx={{
                                          width: "auto",
                                          minWidth: "150px",
                                          maxWidth: "300px",
                                          fontFamily: "monospace",
                                          fontSize: isCompactHeight ? "10px" : "11px",
                                          fontWeight: 500,
                                          color: "#4fc1ff",
                                          px: 1,
                                          overflow: "hidden",
                                          textOverflow: "ellipsis",
                                          whiteSpace: "nowrap",
                                        }}
                                        title={item.baseAddress}
                                      >
                                        {item.baseAddress}
                                      </Box>
                                      {/* Offset Values */}
                                      {Array.from({ length: ptrScanData.maxOffsets }, (_, i) => (
                                        <Box
                                          key={`offset-${i}`}
                                          sx={{
                                            width: "auto",
                                            minWidth: "70px",
                                            maxWidth: "120px",
                                            fontFamily: "monospace",
                                            fontSize: isCompactHeight ? "10px" : "11px",
                                            fontWeight: 500,
                                            color: "#ce9178",
                                            px: 1,
                                            borderLeft: "1px solid #333",
                                          }}
                                        >
                                          {item.offsets[i] || "-"}
                                        </Box>
                                      ))}
                                      {/* Action Menu */}
                                      <Box
                                        sx={{
                                          width: "48px",
                                          display: "flex",
                                          justifyContent: "center",
                                          marginLeft: "auto",
                                        }}
                                      >
                                        <IconButton
                                          size="small"
                                          onClick={(event) => {
                                            event.stopPropagation();
                                            setContextMenu({
                                              mouseX: event.clientX,
                                              mouseY: event.clientY,
                                              address: buildExpression(),
                                            });
                                          }}
                                        >
                                          <MoreVert
                                            sx={{
                                              fontSize: isCompactHeight ? "14px" : "20px",
                                            }}
                                          />
                                        </IconButton>
                                      </Box>
                                    </Box>
                                  );
                                })}
                              </Box>
                            </Box>
                          </>
                        );
                      })()}
                    </Box>
                  </Box>
                ) : (
                /* Normal Results Table */
                <Box
                  sx={{
                    flex: 1,
                    display: "flex",
                    flexDirection: "column",
                    height: "100%",
                    overflow: "hidden",
                  }}
                >
                  {/* Table Header */}
                  <Box
                    sx={{
                      backgroundColor: "#080808",
                      borderBottom: `2px solid ${borderColors.main}`,
                      display: "flex",
                      alignItems: "center",
                      height: isCompactHeight
                        ? COMPACT_HEADER_HEIGHT
                        : HEADER_HEIGHT,
                      px: isCompactHeight ? 1 : 2,
                    }}
                  >
                    <Box
                      sx={{
                        width: `${scanResultsColumnResize.getColumnWidth("address")}px`,
                        minWidth: `${scanResultsColumnResize.getColumnWidth("address")}px`,
                        fontWeight: 600,
                        color: "text.primary",
                        fontSize: isCompactHeight ? "11px" : "13px",
                        position: "relative",
                        px: 1,
                        display: "flex",
                        alignItems: "center",
                        gap: 0.5,
                      }}
                    >
                      Address
                      <IconButton
                        size="small"
                        onClick={() => {
                          // Cycle through: "" -> asc -> desc -> ""
                          if (addressSortOrder === "") {
                            setAddressSortOrder("asc");
                          } else if (addressSortOrder === "asc") {
                            setAddressSortOrder("desc");
                          } else {
                            setAddressSortOrder("");
                          }
                        }}
                        sx={{
                          p: 0.25,
                          color: addressSortOrder
                            ? "primary.main"
                            : "text.secondary",
                        }}
                      >
                        {addressSortOrder === "desc" ? (
                          <ArrowDownward
                            sx={{ fontSize: isCompactHeight ? 14 : 16 }}
                          />
                        ) : (
                          <ArrowUpward
                            sx={{ fontSize: isCompactHeight ? 14 : 16 }}
                          />
                        )}
                      </IconButton>
                      <ColumnResizer
                        onMouseDown={(e) =>
                          scanResultsColumnResize.handleResizeStart(
                            "address",
                            e
                          )
                        }
                        isResizing={
                          scanResultsColumnResize.resizingColumn === "address"
                        }
                      />
                    </Box>
                    <Box
                      sx={{
                        width: `${scanResultsColumnResize.getColumnWidth("detail")}px`,
                        minWidth: `${scanResultsColumnResize.getColumnWidth("detail")}px`,
                        fontWeight: 600,
                        color: "text.primary",
                        fontSize: isCompactHeight ? "11px" : "13px",
                        position: "relative",
                        px: 1,
                        display: "flex",
                        alignItems: "center",
                        gap: 0.5,
                      }}
                    >
                      Detail
                      <IconButton
                        size="small"
                        onClick={(e) => setFilterAnchorEl(e.currentTarget)}
                        sx={{
                          p: 0.25,
                          color: moduleFilter
                            ? "primary.main"
                            : "text.secondary",
                        }}
                      >
                        <FilterList
                          sx={{ fontSize: isCompactHeight ? 14 : 16 }}
                        />
                      </IconButton>
                      <Popover
                        open={filterPopoverOpen}
                        anchorEl={filterAnchorEl}
                        onClose={() => setFilterAnchorEl(null)}
                        anchorOrigin={{
                          vertical: "bottom",
                          horizontal: "left",
                        }}
                        transformOrigin={{
                          vertical: "top",
                          horizontal: "left",
                        }}
                      >
                        <Box sx={{ minWidth: 200, py: 0.5 }}>
                          <MenuItem
                            selected={moduleFilter === ""}
                            onClick={() => {
                              setModuleFilter("");
                              setFilterAnchorEl(null);
                            }}
                            sx={{ fontSize: "13px" }}
                          >
                            All
                          </MenuItem>
                          <MenuItem
                            selected={moduleFilter === "__within_modules__"}
                            onClick={() => {
                              setModuleFilter("__within_modules__");
                              setFilterAnchorEl(null);
                            }}
                            sx={{ fontSize: "13px" }}
                          >
                            Within Modules
                          </MenuItem>
                          <MenuItem
                            selected={moduleFilter === "__outside_modules__"}
                            onClick={() => {
                              setModuleFilter("__outside_modules__");
                              setFilterAnchorEl(null);
                            }}
                            sx={{ fontSize: "13px" }}
                          >
                            Outside Modules
                          </MenuItem>
                          {availableModules.length > 0 && (
                            <>
                              <Divider sx={{ my: 0.5 }} />
                              <ListSubheader
                                sx={{
                                  fontSize: "11px",
                                  lineHeight: "24px",
                                  backgroundColor: "transparent",
                                }}
                              >
                                Modules
                              </ListSubheader>
                              {availableModules.map((moduleName) => (
                                <MenuItem
                                  key={moduleName}
                                  selected={moduleFilter === moduleName}
                                  onClick={() => {
                                    setModuleFilter(moduleName);
                                    setFilterAnchorEl(null);
                                  }}
                                  sx={{ fontSize: "13px" }}
                                >
                                  {moduleName}
                                </MenuItem>
                              ))}
                            </>
                          )}
                        </Box>
                      </Popover>
                      <ColumnResizer
                        onMouseDown={(e) =>
                          scanResultsColumnResize.handleResizeStart("detail", e)
                        }
                        isResizing={
                          scanResultsColumnResize.resizingColumn === "detail"
                        }
                      />
                    </Box>
                    <Box
                      sx={{
                        width: `${scanResultsColumnResize.getColumnWidth("value")}px`,
                        minWidth: `${scanResultsColumnResize.getColumnWidth("value")}px`,
                        fontWeight: 600,
                        color: "text.primary",
                        fontSize: isCompactHeight ? "11px" : "13px",
                        position: "relative",
                        px: 1,
                      }}
                    >
                      Value
                      <ColumnResizer
                        onMouseDown={(e) =>
                          scanResultsColumnResize.handleResizeStart("value", e)
                        }
                        isResizing={
                          scanResultsColumnResize.resizingColumn === "value"
                        }
                      />
                    </Box>
                    <Box
                      sx={{
                        width: `${scanResultsColumnResize.getColumnWidth("description")}px`,
                        minWidth: `${scanResultsColumnResize.getColumnWidth("description")}px`,
                        fontWeight: 600,
                        color: "text.primary",
                        fontSize: isCompactHeight ? "11px" : "13px",
                        position: "relative",
                        px: 1,
                      }}
                    >
                      Description
                      <ColumnResizer
                        onMouseDown={(e) =>
                          scanResultsColumnResize.handleResizeStart(
                            "description",
                            e
                          )
                        }
                        isResizing={
                          scanResultsColumnResize.resizingColumn ===
                          "description"
                        }
                      />
                    </Box>
                    <Box sx={{ width: "48px" }}></Box>
                  </Box>

                  {/* Virtual Scrollable Content */}
                  <Box
                    ref={containerRef}
                    sx={{
                      flex: 1,
                      overflow: "auto",
                      position: "relative",
                      minHeight: 200, // 最小高さを保証
                      maxHeight: "calc(100vh - 300px)", // ビューポートに基づく最大高さ
                      height: "100%",
                      // Custom scrollbar styles
                      "&::-webkit-scrollbar": {
                        width: "14px",
                        backgroundColor: "#1e1e1e",
                      },
                      "&::-webkit-scrollbar-track": {
                        background: "#1e1e1e",
                        borderRadius: "7px",
                        border: "1px solid #333",
                      },
                      "&::-webkit-scrollbar-thumb": {
                        background: "#555",
                        borderRadius: "7px",
                        border: "2px solid #1e1e1e",
                        backgroundClip: "content-box",
                        minHeight: "30px", // Minimum thumb height
                        "&:hover": {
                          background: "#777",
                        },
                        "&:active": {
                          background: "#999",
                        },
                      },
                      // For Firefox
                      scrollbarWidth: "auto",
                      scrollbarColor: "#555 #1e1e1e",
                    }}
                    onScroll={(e) => {
                      const target = e.target as HTMLDivElement;
                      const newScrollTop = target.scrollTop;
                      const maxScrollTop =
                        target.scrollHeight - target.clientHeight;
                      setScrollTop(newScrollTop);
                      console.log(`Scroll event:`, {
                        scrollTop: newScrollTop,
                        maxScrollTop,
                        scrollHeight: target.scrollHeight,
                        clientHeight: target.clientHeight,
                        containerHeight,
                        totalContentHeight:
                          sortedScanResults.length * currentRowHeight,
                        scrollPercentage:
                          ((newScrollTop / maxScrollTop) * 100).toFixed(1) +
                          "%",
                      });
                    }}
                  >
                    {/* Total height container for proper scrollbar */}
                    <Box
                      sx={{
                        height: sortedScanResults.length * currentRowHeight,
                        position: "relative",
                        width: "100%",
                      }}
                    >
                      {/* Visible items positioned absolutely */}
                      <Box
                        sx={{
                          position: "absolute",
                          top: visibleStart * currentRowHeight,
                          left: 0,
                          right: 0,
                          width: "100%",
                        }}
                      >
                        {visibleResults.map((result, index) => {
                          const actualIndex = visibleStart + index;
                          return (
                            <Box
                              key={result.address}
                              sx={{
                                display: "flex",
                                alignItems: "center",
                                height: currentRowHeight,
                                px: isCompactHeight ? 1 : 2,
                                borderBottom: "1px solid",
                                borderColor: "divider",
                                backgroundColor: selectedRows.has(
                                  result.address
                                )
                                  ? "action.selected"
                                  : actualIndex % 2 === 0
                                    ? "#2a2a2a"
                                    : "#1e1e1e",
                                "&:hover": {
                                  backgroundColor: "action.hover",
                                },
                                cursor: "pointer",
                              }}
                              onClick={(event) =>
                                handleRowClick(result.address, event)
                              }
                              onContextMenu={(event) =>
                                handleContextMenu(event, result.address)
                              }
                            >
                              <Box
                                sx={{
                                  width: `${scanResultsColumnResize.getColumnWidth("address")}px`,
                                  minWidth: `${scanResultsColumnResize.getColumnWidth("address")}px`,
                                  fontFamily: "monospace",
                                  fontSize: isCompactHeight ? "10px" : "11px",
                                  fontWeight: 500,
                                  color: "#4fc1ff",
                                  overflow: "hidden",
                                  textOverflow: "ellipsis",
                                  whiteSpace: "nowrap",
                                  px: 1,
                                }}
                              >
                                {result.address.startsWith("0x") ||
                                result.address.startsWith("0X")
                                  ? `0x${result.address.slice(2).toUpperCase()}`
                                  : result.address.toUpperCase()}
                              </Box>
                              <Box
                                sx={{
                                  width: `${scanResultsColumnResize.getColumnWidth("detail")}px`,
                                  minWidth: `${scanResultsColumnResize.getColumnWidth("detail")}px`,
                                  fontFamily: "monospace",
                                  fontSize: isCompactHeight ? "10px" : "11px",
                                  fontWeight: 500,
                                  color: "#90ee90",
                                  overflow: "hidden",
                                  textOverflow: "ellipsis",
                                  whiteSpace: "nowrap",
                                  px: 1,
                                }}
                                title={
                                  visibleAddressDetails.get(result.address) ||
                                  "-"
                                }
                              >
                                {visibleAddressDetails.get(result.address) ||
                                  "-"}
                              </Box>
                              <Box
                                sx={{
                                  width: `${scanResultsColumnResize.getColumnWidth("value")}px`,
                                  minWidth: `${scanResultsColumnResize.getColumnWidth("value")}px`,
                                  fontFamily: "monospace",
                                  fontSize: isCompactHeight ? "10px" : "11px",
                                  fontWeight: 500,
                                  color: "text.primary",
                                  px: 1,
                                }}
                              >
                                {editingRow === result.address ? (
                                  <TextField
                                    size="small"
                                    value={editValue}
                                    onChange={(e) =>
                                      setEditValue(e.target.value)
                                    }
                                    onBlur={() =>
                                      handleEditSave(result.address)
                                    }
                                    onKeyDown={(e) => {
                                      if (e.key === "Enter") {
                                        handleEditSave(result.address);
                                      } else if (e.key === "Escape") {
                                        handleEditCancel();
                                      }
                                    }}
                                    autoFocus
                                    sx={{
                                      "& .MuiInputBase-input": {
                                        fontFamily: "monospace",
                                        fontSize: isCompactHeight
                                          ? "10px"
                                          : "11px",
                                        fontWeight: 500,
                                        padding: isCompactHeight
                                          ? "2px 4px"
                                          : "4px 8px",
                                      },
                                    }}
                                  />
                                ) : (
                                  <Box
                                    onDoubleClick={() => {
                                      setEditDialog({
                                        open: true,
                                        address: result.address,
                                        currentValue: formatValue(result),
                                        rawValue: String(result.value), // Raw decimal value
                                        newValue: formatValue(result),
                                        valueType: result.type,
                                        inputFormat:
                                          scanSettings?.valueInputFormat ||
                                          "dec",
                                        bookmarkId: undefined, // Scan results don't have bookmark ID
                                      });
                                    }}
                                  >
                                    {formatValue(result)}
                                  </Box>
                                )}
                              </Box>
                              <Box
                                sx={{
                                  width: `${scanResultsColumnResize.getColumnWidth("description")}px`,
                                  minWidth: `${scanResultsColumnResize.getColumnWidth("description")}px`,
                                  fontSize: isCompactHeight ? "10px" : "11px",
                                  fontWeight: 400,
                                  color: "text.primary",
                                  overflow: "hidden",
                                  textOverflow: "ellipsis",
                                  whiteSpace: "nowrap",
                                  px: 1,
                                }}
                              >
                                {result.description || "-"}
                              </Box>
                              <Box
                                sx={{
                                  width: "48px",
                                  display: "flex",
                                  justifyContent: "center",
                                }}
                              >
                                <IconButton
                                  size="small"
                                  onClick={(event) => {
                                    event.stopPropagation();
                                    handleContextMenu(event, result.address);
                                  }}
                                >
                                  <MoreVert
                                    sx={{
                                      fontSize: isCompactHeight
                                        ? "14px"
                                        : "20px",
                                    }}
                                  />
                                </IconButton>
                              </Box>
                            </Box>
                          );
                        })}
                      </Box>
                    </Box>
                  </Box>
                </Box>
                )}
              </>
            )}
          </TabContent>
        </TabPanel>

        <TabPanel value={activeTab} index={1}>
          <TabContent sx={{ position: "relative" }}>
            {bookmarks.length === 0 ? (
              <Box sx={{ p: isCompactHeight ? 2 : 3, textAlign: "center" }}>
                <BookmarkBorderOutlined
                  sx={{
                    fontSize: isCompactHeight ? 36 : 48,
                    color: "text.secondary",
                    mb: isCompactHeight ? 1 : 2,
                  }}
                />
                <Typography
                  variant="h6"
                  gutterBottom
                  sx={{
                    fontSize: isCompactHeight ? "14px" : "18px",
                    mb: isCompactHeight ? 1 : 2,
                  }}
                >
                  No Bookmarks
                </Typography>
                <Typography
                  variant="body2"
                  color="text.secondary"
                  sx={{
                    mb: isCompactHeight ? 2 : 3,
                    fontSize: isCompactHeight ? "11px" : "14px",
                  }}
                >
                  Add bookmarks from scan results or manually by address
                </Typography>
                <Button
                  variant="contained"
                  startIcon={<AddIcon />}
                  onClick={handleManualBookmarkDialogOpen}
                  sx={{
                    fontSize: isCompactHeight ? "10px" : "14px",
                    minHeight: isCompactHeight ? "24px" : "32px",
                    padding: isCompactHeight ? "2px 8px" : "4px 12px",
                  }}
                >
                  Add Manual Bookmark
                </Button>
              </Box>
            ) : (
              <>
                {/* Header */}
                <Box
                  sx={{
                    p: isCompactHeight ? 1.5 : 2,
                    borderBottom: `1px solid ${borderColors.main}`,
                  }}
                >
                  <Stack
                    direction="row"
                    justifyContent="space-between"
                    alignItems="center"
                  >
                    <Typography
                      variant="h6"
                      sx={{
                        fontSize: isCompactHeight ? "14px" : "18px",
                      }}
                    >
                      Bookmarks
                    </Typography>
                    <Stack direction="row" spacing={1} alignItems="center">
                      <Typography
                        variant="body2"
                        color="text.secondary"
                        sx={{
                          fontSize: isCompactHeight ? "10px" : "14px",
                        }}
                      >
                        {bookmarks.length} bookmark
                        {bookmarks.length !== 1 ? "s" : ""}
                      </Typography>
                      {/* PointerMap Generation Status */}
                      {(isGeneratingPointerMap || pointerMapStatus) && (
                        <Box
                          sx={{
                            display: "flex",
                            alignItems: "center",
                            gap: 1,
                            px: 1.5,
                            py: 0.5,
                            borderRadius: 1,
                            backgroundColor: pointerMapStatus?.type === "error" 
                              ? "error.dark" 
                              : pointerMapStatus?.type === "success"
                              ? "success.dark"
                              : "info.dark",
                            opacity: 0.9,
                          }}
                        >
                          {isGeneratingPointerMap && (
                            <Box
                              sx={{
                                width: 14,
                                height: 14,
                                border: "2px solid",
                                borderColor: "transparent",
                                borderTopColor: "white",
                                borderRadius: "50%",
                                animation: "spin 1s linear infinite",
                                "@keyframes spin": {
                                  "0%": { transform: "rotate(0deg)" },
                                  "100%": { transform: "rotate(360deg)" },
                                },
                              }}
                            />
                          )}
                          <Typography
                            variant="body2"
                            sx={{
                              fontSize: isCompactHeight ? "10px" : "12px",
                              color: "white",
                              maxWidth: 300,
                              overflow: "hidden",
                              textOverflow: "ellipsis",
                              whiteSpace: "nowrap",
                            }}
                          >
                            {pointerMapStatus?.message || "Processing..."}
                          </Typography>
                          {pointerMapStatus && !isGeneratingPointerMap && (
                            <IconButton
                              size="small"
                              onClick={() => setPointerMapStatus(null)}
                              sx={{ 
                                p: 0, 
                                minWidth: 16, 
                                color: "white",
                                "&:hover": { opacity: 0.8 },
                              }}
                            >
                              ×
                            </IconButton>
                          )}
                        </Box>
                      )}
                      <Button
                        size="small"
                        startIcon={<AddIcon />}
                        onClick={handleManualBookmarkDialogOpen}
                        sx={{
                          fontSize: isCompactHeight ? "10px" : "12px",
                          minHeight: isCompactHeight ? "20px" : "24px",
                          padding: isCompactHeight ? "1px 6px" : "2px 8px",
                        }}
                      >
                        Add
                      </Button>
                    </Stack>
                  </Stack>
                </Box>

                {/* Bookmarks Table */}
                <TableContainer
                  sx={{
                    flex: 1,
                    overflow: "auto",
                    "&::-webkit-scrollbar": {
                      width: "8px",
                      height: "8px",
                    },
                    "&::-webkit-scrollbar-track": {
                      background: "#1e1e1e",
                    },
                    "&::-webkit-scrollbar-thumb": {
                      background: "#3e3e42",
                      borderRadius: "4px",
                      "&:hover": {
                        background: "#5a5a5e",
                      },
                    },
                  }}
                >
                  <Table size="small" stickyHeader>
                    <TableHead>
                      <TableRow>
                        <TableCell
                          sx={{
                            fontSize: "11px",
                            fontWeight: 600,
                            backgroundColor: "background.paper",
                            borderBottom: "1px solid",
                            borderColor: "divider",
                            width: bookmarkColumnWidths.address,
                            minWidth: bookmarkColumnWidths.address,
                            maxWidth: bookmarkColumnWidths.address,
                            position: "relative",
                          }}
                        >
                          Address
                          <ColumnResizer
                            onMouseDown={handleBookmarkColumnResizeStart(
                              "address"
                            )}
                            isResizing={resizingBookmarkColumn === "address"}
                          />
                        </TableCell>
                        <TableCell
                          sx={{
                            fontSize: "11px",
                            fontWeight: 600,
                            backgroundColor: "background.paper",
                            borderBottom: "1px solid",
                            borderColor: "divider",
                            width: bookmarkColumnWidths.type,
                            minWidth: bookmarkColumnWidths.type,
                            maxWidth: bookmarkColumnWidths.type,
                            position: "relative",
                          }}
                        >
                          Type
                          <ColumnResizer
                            onMouseDown={handleBookmarkColumnResizeStart(
                              "type"
                            )}
                            isResizing={resizingBookmarkColumn === "type"}
                          />
                        </TableCell>
                        <TableCell
                          sx={{
                            fontSize: "11px",
                            fontWeight: 600,
                            backgroundColor: "background.paper",
                            borderBottom: "1px solid",
                            borderColor: "divider",
                            width: bookmarkColumnWidths.value,
                            minWidth: bookmarkColumnWidths.value,
                            maxWidth: bookmarkColumnWidths.value,
                            position: "relative",
                          }}
                        >
                          Value
                          <ColumnResizer
                            onMouseDown={handleBookmarkColumnResizeStart(
                              "value"
                            )}
                            isResizing={resizingBookmarkColumn === "value"}
                          />
                        </TableCell>
                        <TableCell
                          sx={{
                            fontSize: "11px",
                            fontWeight: 600,
                            backgroundColor: "background.paper",
                            borderBottom: "1px solid",
                            borderColor: "divider",
                            width: bookmarkColumnWidths.description,
                            minWidth: bookmarkColumnWidths.description,
                            maxWidth: bookmarkColumnWidths.description,
                            position: "relative",
                          }}
                        >
                          Description
                          <ColumnResizer
                            onMouseDown={handleBookmarkColumnResizeStart(
                              "description"
                            )}
                            isResizing={
                              resizingBookmarkColumn === "description"
                            }
                          />
                        </TableCell>
                        <TableCell
                          sx={{
                            fontSize: "11px",
                            fontWeight: 600,
                            backgroundColor: "background.paper",
                            borderBottom: "1px solid",
                            borderColor: "divider",
                            textAlign: "center",
                          }}
                        >
                          Actions
                        </TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {bookmarks.map((bookmark) => {
                        const currentValue =
                          updatedBookmarkValues.get(bookmark.id) ||
                          bookmark.value;

                        // Format value based on bookmark's displayFormat
                        // For ptr type, use ptrValueType; otherwise use bookmark.type
                        const effectiveType = bookmark.type === "ptr" 
                          ? (bookmark.ptrValueType || "int32") 
                          : bookmark.type;
                        const isIntegerType = [
                          "int8",
                          "uint8",
                          "int16",
                          "uint16",
                          "int32",
                          "uint32",
                          "int64",
                          "uint64",
                        ].includes(effectiveType);
                        let displayValue = currentValue;
                        if (isIntegerType && bookmark.displayFormat === "hex") {
                          try {
                            const numValue = ["int64", "uint64"].includes(
                              effectiveType
                            )
                              ? BigInt(currentValue)
                              : parseInt(currentValue, 10);
                            // Handle signed integers with two's complement
                            let hexStr: string;
                            if (typeof numValue === "bigint") {
                              if (numValue < 0n) {
                                const mask = (1n << 64n) - 1n;
                                hexStr = (numValue & mask)
                                  .toString(16)
                                  .toUpperCase();
                              } else {
                                hexStr = numValue.toString(16).toUpperCase();
                              }
                            } else {
                              if (numValue < 0) {
                                // Two's complement based on type using bitwise AND with proper mask
                                if (effectiveType === "int8") {
                                  hexStr = ((numValue & 0xff) >>> 0)
                                    .toString(16)
                                    .toUpperCase()
                                    .padStart(2, "0");
                                } else if (effectiveType === "int16") {
                                  hexStr = ((numValue & 0xffff) >>> 0)
                                    .toString(16)
                                    .toUpperCase()
                                    .padStart(4, "0");
                                } else {
                                  // int32: >>> 0 converts to unsigned 32-bit
                                  hexStr = (numValue >>> 0)
                                    .toString(16)
                                    .toUpperCase()
                                    .padStart(8, "0");
                                }
                              } else {
                                hexStr = numValue.toString(16).toUpperCase();
                              }
                            }
                            displayValue = "0x" + hexStr;
                          } catch {
                            // Keep original value on error
                          }
                        }

                        return (
                          <TableRow
                            key={bookmark.id}
                            hover
                            sx={{
                              "&:hover": {
                                backgroundColor: "action.hover",
                              },
                            }}
                            onContextMenu={(e) =>
                              handleBookmarkContextMenu(e, bookmark)
                            }
                          >
                            {/* Address */}
                            <TableCell
                              sx={{
                                fontFamily: "monospace",
                                fontSize: isCompactHeight ? "10px" : "11px",
                                py: isCompactHeight ? 0.5 : 1,
                                width: bookmarkColumnWidths.address,
                                minWidth: bookmarkColumnWidths.address,
                                maxWidth: bookmarkColumnWidths.address,
                              }}
                            >
                              {/* PTR type: show structured pointer chain with colored arrows */}
                              {bookmark.type === "ptr" ? (
                                <Box
                                  sx={{
                                    display: "flex",
                                    alignItems: "center",
                                    flexWrap: "wrap",
                                    gap: 0.5,
                                    fontFamily: "monospace",
                                    fontSize: isCompactHeight ? "10px" : "11px",
                                  }}
                                >
                                  {(() => {
                                    // Parse pointer expression: "base → [0x10] → [0x18]"
                                    const parts = bookmark.address.split(" → ");
                                    return parts.map((part, idx) => (
                                      <Box key={idx} component="span" sx={{ display: "flex", alignItems: "center" }}>
                                        {idx > 0 && (
                                          <Box component="span" sx={{ color: "#ffcc00", mx: 0.5, fontWeight: 600 }}>→</Box>
                                        )}
                                        {idx === 0 ? (
                                          <Box component="span" sx={{ color: "#4fc1ff" }}>
                                            {part.replace(/0X/g, '0x')}
                                          </Box>
                                        ) : (
                                          <>
                                            <Box component="span" sx={{ color: "#888" }}>[</Box>
                                            <Box component="span" sx={{ color: "#ce9178" }}>
                                              {part.replace(/[\[\]]/g, '').replace(/0X/g, '0x')}
                                            </Box>
                                            <Box component="span" sx={{ color: "#888" }}>]</Box>
                                          </>
                                        )}
                                      </Box>
                                    ));
                                  })()}
                                </Box>
                              ) : bookmark.libraryExpression ? (
                                <>
                                  <Typography
                                    sx={{
                                      fontFamily: "monospace",
                                      fontWeight: 600,
                                      color: "primary.main",
                                      fontSize: isCompactHeight
                                        ? "10px"
                                        : "11px",
                                    }}
                                  >
                                    {bookmark.libraryExpression}
                                  </Typography>
                                  <Typography
                                    sx={{
                                      fontFamily: "monospace",
                                      fontSize: isCompactHeight
                                        ? "9px"
                                        : "10px",
                                      color: "text.secondary",
                                      fontStyle: "italic",
                                    }}
                                  >
                                    {bookmark.address.startsWith("0x") ||
                                    bookmark.address.startsWith("0X")
                                      ? `0x${bookmark.address.slice(2).toUpperCase()}`
                                      : bookmark.address.toUpperCase()}
                                  </Typography>
                                </>
                              ) : (
                                <Typography
                                  sx={{
                                    fontFamily: "monospace",
                                    fontSize: isCompactHeight ? "10px" : "11px",
                                  }}
                                >
                                  {bookmark.address.startsWith("0x") ||
                                  bookmark.address.startsWith("0X")
                                    ? `0x${bookmark.address.slice(2).toUpperCase()}`
                                    : bookmark.address.toUpperCase()}
                                </Typography>
                              )}
                            </TableCell>
                            {/* Type */}
                            <TableCell
                              sx={{
                                py: isCompactHeight ? 0.5 : 1,
                                width: bookmarkColumnWidths.type,
                                minWidth: bookmarkColumnWidths.type,
                                maxWidth: bookmarkColumnWidths.type,
                              }}
                            >
                              <Typography
                                sx={{
                                  backgroundColor: "#2d2d30",
                                  color: "#4fc1ff",
                                  padding: "2px 6px",
                                  borderRadius: "4px",
                                  fontSize: isCompactHeight ? "9px" : "10px",
                                  display: "inline-block",
                                }}
                              >
                                {bookmark.type === "ptr" 
                                  ? `ptr ${bookmark.ptrValueType || "int32"}` 
                                  : bookmark.type}
                              </Typography>
                            </TableCell>
                            {/* Value */}
                            <TableCell
                              sx={{
                                fontFamily: "monospace",
                                fontSize: isCompactHeight ? "10px" : "11px",
                                py: isCompactHeight ? 0.5 : 1,
                                width: bookmarkColumnWidths.value,
                                minWidth: bookmarkColumnWidths.value,
                                maxWidth: bookmarkColumnWidths.value,
                              }}
                            >
                              <Typography
                                sx={{
                                  fontFamily: "monospace",
                                  fontSize: isCompactHeight ? "10px" : "11px",
                                  color: "#ccc",
                                  backgroundColor: "#1e1e1e",
                                  padding: "2px 6px",
                                  borderRadius: "4px",
                                  display: "inline-block",
                                }}
                              >
                                {displayValue}
                              </Typography>
                            </TableCell>
                            {/* Description */}
                            <TableCell
                              sx={{
                                fontSize: isCompactHeight ? "10px" : "11px",
                                color: "text.secondary",
                                py: isCompactHeight ? 0.5 : 1,
                                width: bookmarkColumnWidths.description,
                                minWidth: bookmarkColumnWidths.description,
                                maxWidth: bookmarkColumnWidths.description,
                              }}
                            >
                              {bookmark.description || "-"}
                            </TableCell>
                            {/* Actions */}
                            <TableCell
                              sx={{
                                py: isCompactHeight ? 0.5 : 1,
                                textAlign: "center",
                              }}
                            >
                              <Box
                                sx={{
                                  display: "flex",
                                  alignItems: "center",
                                  justifyContent: "center",
                                  gap: 0.5,
                                }}
                              >
                                <IconButton
                                  size="small"
                                  onClick={() => {
                                    // currentValue is raw decimal from memory, displayValue is formatted
                                    // Ensure rawValue is always stored as decimal string for conversions
                                    let rawDecimalValue = currentValue;
                                    // If currentValue looks like hex, convert to decimal
                                    if (typeof currentValue === "string" && currentValue.toLowerCase().startsWith("0x")) {
                                      try {
                                        rawDecimalValue = BigInt(currentValue).toString();
                                      } catch {
                                        rawDecimalValue = currentValue;
                                      }
                                    }
                                    setEditDialog({
                                      open: true,
                                      address: bookmark.address,
                                      currentValue: displayValue,
                                      rawValue: rawDecimalValue, // Raw decimal value from memory
                                      valueType: bookmark.type,
                                      ptrValueType: bookmark.ptrValueType || "int32",
                                      newValue: displayValue,
                                      inputFormat:
                                        bookmark.displayFormat || "dec",
                                      bookmarkId: bookmark.id,
                                    });
                                  }}
                                  title="Edit Value"
                                >
                                  <Edit sx={{ fontSize: "16px" }} />
                                </IconButton>
                                <IconButton
                                  size="small"
                                  onClick={() => handleGeneratePointerMap(bookmark.address)}
                                  disabled={isGeneratingPointerMap}
                                  title={isGeneratingPointerMap ? "Generating PointerMap..." : "Generate PointerMap for this address"}
                                  sx={{
                                    color: isGeneratingPointerMap ? "info.main" : "text.secondary",
                                  }}
                                >
                                  <MapIcon sx={{ fontSize: "16px" }} />
                                </IconButton>
                                <IconButton
                                  size="small"
                                  onClick={() => {
                                    const currentAddress =
                                      bookmark.address.startsWith("0x") ||
                                      bookmark.address.startsWith("0X")
                                        ? bookmark.address
                                        : `0x${bookmark.address}`;
                                    handleWatchpointDialogOpen(currentAddress);
                                  }}
                                  title="Set Hardware Watchpoint"
                                  sx={{
                                    color: isAddressWatched?.(bookmark.address)
                                      ? "warning.main"
                                      : "text.secondary",
                                  }}
                                >
                                  <BugReport sx={{ fontSize: "16px" }} />
                                </IconButton>
                                <IconButton
                                  size="small"
                                  color="error"
                                  onClick={() =>
                                    onRemoveBookmark?.(bookmark.id)
                                  }
                                  title="Remove Bookmark"
                                >
                                  <Delete sx={{ fontSize: "16px" }} />
                                </IconButton>
                              </Box>
                            </TableCell>
                          </TableRow>
                        );
                      })}
                    </TableBody>
                  </Table>
                </TableContainer>
              </>
            )}
          </TabContent>
        </TabPanel>

        <TabPanel value={activeTab} index={2}>
          <TabContent sx={{ position: "relative" }}>
            {scanHistory.length === 0 ? (
              <Box sx={{ p: isCompactHeight ? 2 : 3, textAlign: "center" }}>
                <History
                  sx={{
                    fontSize: isCompactHeight ? 36 : 48,
                    color: "text.secondary",
                    mb: isCompactHeight ? 1 : 2,
                  }}
                />
                <Typography
                  variant="h6"
                  gutterBottom
                  sx={{
                    fontSize: isCompactHeight ? "14px" : "18px",
                    mb: isCompactHeight ? 1 : 2,
                  }}
                >
                  No Search History
                </Typography>
                <Typography
                  variant="body2"
                  color="text.secondary"
                  sx={{
                    mb: isCompactHeight ? 2 : 3,
                    fontSize: isCompactHeight ? "11px" : "14px",
                  }}
                >
                  Your search history will appear here after performing scans
                </Typography>
              </Box>
            ) : (
              <>
                {/* Header */}
                <Box
                  sx={{
                    p: isCompactHeight ? 1.5 : 2,
                    borderBottom: `1px solid ${borderColors.main}`,
                  }}
                >
                  <Stack
                    direction="row"
                    justifyContent="space-between"
                    alignItems="center"
                  >
                    <Typography
                      variant="h6"
                      sx={{
                        fontSize: isCompactHeight ? "14px" : "18px",
                      }}
                    >
                      Search History
                    </Typography>
                    <Stack direction="row" spacing={2} alignItems="center">
                      <Typography
                        variant="body2"
                        color="text.secondary"
                        sx={{
                          fontSize: isCompactHeight ? "10px" : "14px",
                        }}
                      >
                        {scanHistory.length}/10 searches
                      </Typography>
                      <Button
                        size="small"
                        onClick={() => {
                          onClearHistory?.();
                        }}
                        sx={{
                          color: "#4fc1ff",
                          fontSize: isCompactHeight ? "10px" : "12px",
                          minHeight: isCompactHeight ? "20px" : "24px",
                          padding: isCompactHeight ? "1px 6px" : "2px 8px",
                        }}
                      >
                        Clear
                      </Button>
                    </Stack>
                  </Stack>
                </Box>

                {/* History List */}
                <Box
                  sx={{
                    flex: 1,
                    overflow: "auto",
                    p: isCompactHeight ? 0.5 : 1,
                  }}
                >
                  {scanHistory.map((item) => (
                    <Box
                      key={item.id}
                      sx={{
                        display: "flex",
                        alignItems: "center",
                        p: isCompactHeight ? 0.75 : 1.25,
                        mb: isCompactHeight ? 0.25 : 0.5,
                        borderRadius: 1,
                        border: "1px solid",
                        borderColor: "divider",
                        backgroundColor: "background.paper",
                        cursor: "pointer",
                        "&:hover": {
                          backgroundColor: "action.hover",
                          borderColor: "#4fc1ff",
                        },
                      }}
                      onClick={() => onSelectHistory?.(item)}
                    >
                      <Box sx={{ flex: 1 }}>
                        <Typography
                          variant="body1"
                          sx={{
                            fontWeight: 600,
                            fontSize: isCompactHeight ? "11px" : "13px",
                            mb: 0.25,
                          }}
                        >
                          {item.description}
                        </Typography>

                        <Stack direction="row" spacing={1} sx={{ mb: 0.5 }}>
                          <Typography
                            variant="caption"
                            sx={{
                              backgroundColor: "#2d2d30",
                              color: "#4fc1ff",
                              padding: "2px 6px",
                              borderRadius: "4px",
                              fontSize: isCompactHeight ? "9px" : "10px",
                            }}
                          >
                            {item.valueType}
                          </Typography>
                          <Typography
                            variant="caption"
                            sx={{
                              backgroundColor: "#2d2d30",
                              color: "#ccc",
                              padding: "2px 6px",
                              borderRadius: "4px",
                              fontSize: isCompactHeight ? "9px" : "10px",
                            }}
                          >
                            {item.scanType}
                          </Typography>
                        </Stack>

                        {item.value && (
                          <Typography
                            variant="body2"
                            sx={{
                              fontFamily: "monospace",
                              fontSize: isCompactHeight ? "10px" : "12px",
                              color: "#ccc",
                              backgroundColor: "#1e1e1e",
                              padding: "3px 6px",
                              borderRadius: "4px",
                              mb: 0.5,
                              maxWidth: "300px",
                              overflow: "hidden",
                              textOverflow: "ellipsis",
                              whiteSpace: "nowrap",
                            }}
                          >
                            {item.value}
                          </Typography>
                        )}

                        <Typography
                          variant="caption"
                          color="text.secondary"
                          sx={{
                            fontSize: isCompactHeight ? "9px" : "11px",
                          }}
                        >
                          {new Date(item.timestamp).toLocaleString()}
                        </Typography>
                      </Box>

                      <Box
                        sx={{
                          display: "flex",
                          alignItems: "center",
                          gap: isCompactHeight ? 0.5 : 1,
                        }}
                      >
                        <IconButton
                          size="small"
                          onClick={(e) => {
                            e.stopPropagation();
                            // Execute search with this history item and switch to Results tab
                            if (onExecuteHistorySearch && handleTabChange) {
                              onExecuteHistorySearch(item);
                              handleTabChange(0); // Switch to Results tab (index 0)
                            }
                          }}
                          sx={{
                            color: "#4fc1ff",
                            "&:hover": {
                              color: "#fff",
                              backgroundColor: "rgba(79, 193, 255, 0.1)",
                            },
                          }}
                          title="Search with this condition and view results"
                        >
                          <Search
                            sx={{ fontSize: isCompactHeight ? "14px" : "18px" }}
                          />
                        </IconButton>
                        <IconButton
                          size="small"
                          onClick={(e) => {
                            e.stopPropagation();
                            onRemoveHistoryItem?.(item.id);
                          }}
                          color="error"
                          title="Remove from history"
                        >
                          <Delete
                            sx={{ fontSize: isCompactHeight ? "14px" : "18px" }}
                          />
                        </IconButton>
                      </Box>
                    </Box>
                  ))}
                </Box>
              </>
            )}
          </TabContent>
        </TabPanel>

        {/*<TabPanel value={currentTab} index={2}>
        <TabContent>
          <Box sx={{ p: 3, textAlign: "center" }}>
            <VisibilityOutlined
              sx={{ fontSize: 48, color: "text.secondary", mb: 2 }}
            />
            <Typography variant="h6" gutterBottom>
              Watch List
            </Typography>
            <Typography variant="body2" color="text.secondary">
              Watched addresses will appear here with real-time updates
            </Typography>
          </Box>
        </TabContent>
      </TabPanel>*/}

        {/* Context Menu */}
        <Menu
          open={contextMenu !== null}
          onClose={handleContextMenuClose}
          anchorReference="anchorPosition"
          anchorPosition={
            contextMenu !== null
              ? { top: contextMenu.mouseY, left: contextMenu.mouseX }
              : undefined
          }
        >
          {/* Edit Value - hide for PTR scan mode */}
          {!isPtrScanMode && (
          <MenuItem
            onClick={() =>
              contextMenu &&
              handleEditStart(
                contextMenu.address,
                formatValue(
                  scanResults.find((r) => r.address === contextMenu.address)!
                )
              )
            }
          >
            <Edit sx={{ mr: 1 }} />
            Edit Value
          </MenuItem>
          )}
          <MenuItem
            onClick={() => {
              if (contextMenu) {
                // For PTR scan, add the pointer expression as address
                // The address field contains the pointer expression like [[base]+0x8]+0x10
                if (isPtrScanMode) {
                  // Add as a manual bookmark with pointer expression
                  onAddManualBookmark?.(
                    contextMenu.address,
                    "ptr" as ScanValueType,
                    "Pointer chain"
                  );
                } else {
                  const isBookmarked =
                    isAddressBookmarked?.(contextMenu.address) || false;
                  onResultBookmark(contextMenu.address, !isBookmarked);
                }
                handleContextMenuClose();
              }
            }}
          >
            <Bookmark sx={{ mr: 1 }} />
            {isPtrScanMode
              ? "Add to Bookmarks"
              : isAddressBookmarked?.(contextMenu?.address || "")
                ? "Remove from Bookmarks"
                : "Add to Bookmarks"}
          </MenuItem>
          {/*<MenuItem
          onClick={() => {
            if (contextMenu) {
              onResultWatch(contextMenu.address, true);
              handleContextMenuClose();
            }
          }}
        >
          <Visibility sx={{ mr: 1 }} />
          Add to Watchlist
        </MenuItem>*/}
          <MenuItem
            onClick={() => {
              if (contextMenu) {
                onResultDelete(contextMenu.address);
                handleContextMenuClose();
              }
            }}
          >
            <Delete sx={{ mr: 1 }} />
            Remove
          </MenuItem>
        </Menu>

        {/* Bookmark Context Menu */}
        <Menu
          open={bookmarkContextMenu !== null}
          onClose={handleCloseBookmarkContextMenu}
          anchorReference="anchorPosition"
          anchorPosition={
            bookmarkContextMenu !== null
              ? {
                  top: bookmarkContextMenu.mouseY,
                  left: bookmarkContextMenu.mouseX,
                }
              : undefined
          }
        >
          <MenuItem onClick={handleCopyBookmarkAddress}>Copy Address</MenuItem>
          <MenuItem onClick={handleCopyBookmarkType}>Copy Type</MenuItem>
          <MenuItem onClick={handleCopyBookmarkValue}>Copy Value</MenuItem>
          <MenuItem onClick={handleCopyBookmarkDescription}>
            Copy Description
          </MenuItem>
        </Menu>

        {/* Edit Value Dialog */}
        <Dialog
          open={editDialog.open}
          onClose={handleEditDialogClose}
          maxWidth="sm"
          fullWidth
        >
          <DialogTitle>Edit Memory Value</DialogTitle>
          <DialogContent>
            <Stack spacing={1.5} sx={{ mt: 1 }}>
              {/* Info Section */}
              <Box sx={{ display: "flex", gap: 2, flexWrap: "wrap" }}>
                <Typography variant="body2" color="text.secondary">
                  Address: <code style={{ fontFamily: "monospace" }}>{editDialog.address}</code>
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Mode: {editDialog.valueType === "ptr" ? "Pointer Chain" : "Direct"}
                </Typography>
              </Box>
              
              {/* Setting Section */}
              <Typography variant="subtitle2" sx={{ fontWeight: 600, color: "primary.main", mt: 0.5 }}>
                Setting
              </Typography>
              
              {/* Value Type Row */}
              <Box sx={{ display: "flex", gap: 1, alignItems: "center" }}>
                <InputLabel sx={{ minWidth: 90, fontSize: "0.875rem" }}>Value Type</InputLabel>
                <Select
                  size="small"
                  sx={{ flex: 1 }}
                  value={editDialog.valueType === "ptr" ? (editDialog.ptrValueType || "int32") : (editDialog.valueType || "int32")}
                  onChange={(e) => {
                    const newType = e.target.value as ScanValueType;
                    const integerTypes = ["int8", "uint8", "int16", "uint16", "int32", "uint32", "int64", "uint64"];
                    
                    // Get type size info for masking
                    const getTypeMask = (type: string): { mask: bigint; signed: boolean } => {
                      switch (type) {
                        case "int8": return { mask: 0xFFn, signed: true };
                        case "uint8": return { mask: 0xFFn, signed: false };
                        case "int16": return { mask: 0xFFFFn, signed: true };
                        case "uint16": return { mask: 0xFFFFn, signed: false };
                        case "int32": return { mask: 0xFFFFFFFFn, signed: true };
                        case "uint32": return { mask: 0xFFFFFFFFn, signed: false };
                        case "int64": return { mask: 0xFFFFFFFFFFFFFFFFn, signed: true };
                        case "uint64": return { mask: 0xFFFFFFFFFFFFFFFFn, signed: false };
                        default: return { mask: 0xFFFFFFFFn, signed: true };
                      }
                    };
                    
                    let convertedValue = editDialog.currentValue;
                    if (integerTypes.includes(newType) && editDialog.rawValue) {
                      try {
                        // Parse the raw value and mask to new type's size
                        let numValue = BigInt(editDialog.rawValue);
                        const { mask } = getTypeMask(newType);
                        numValue = numValue & mask;
                        
                        // Re-format in current display format
                        if (editDialog.inputFormat === "hex") {
                          convertedValue = "0x" + numValue.toString(16).toUpperCase();
                        } else {
                          convertedValue = numValue.toString();
                        }
                      } catch {
                        // Keep original value if conversion fails
                      }
                    }
                    
                    if (editDialog.valueType === "ptr") {
                      setEditDialog((prev) => ({
                        ...prev,
                        ptrValueType: newType as Exclude<ScanValueType, "ptr" | "string" | "bytes" | "regex">,
                        newValue: convertedValue,
                      }));
                    } else {
                      setEditDialog((prev) => ({
                        ...prev,
                        valueType: newType,
                        newValue: convertedValue,
                      }));
                    }
                  }}
                >
                  <MenuItem value="int8">int8</MenuItem>
                  <MenuItem value="uint8">uint8</MenuItem>
                  <MenuItem value="int16">int16</MenuItem>
                  <MenuItem value="uint16">uint16</MenuItem>
                  <MenuItem value="int32">int32</MenuItem>
                  <MenuItem value="uint32">uint32</MenuItem>
                  <MenuItem value="int64">int64</MenuItem>
                  <MenuItem value="uint64">uint64</MenuItem>
                  <MenuItem value="float">float</MenuItem>
                  <MenuItem value="double">double</MenuItem>
                  {editDialog.valueType !== "ptr" && (
                    <>
                      <MenuItem value="string">string</MenuItem>
                      <MenuItem value="bytes">bytes</MenuItem>
                    </>
                  )}
                </Select>
                <Button
                  variant="outlined"
                  size="small"
                  onClick={() => {
                    if (editDialog.bookmarkId && onUpdateBookmark) {
                      const effectiveValueType = editDialog.valueType === "ptr"
                        ? (editDialog.ptrValueType || "int32")
                        : editDialog.valueType;
                      
                      if (editDialog.valueType === "ptr") {
                        onUpdateBookmark(editDialog.bookmarkId, {
                          ptrValueType: effectiveValueType as Exclude<ScanValueType, "ptr" | "string" | "bytes" | "regex">,
                        });
                      } else {
                        onUpdateBookmark(editDialog.bookmarkId, {
                          type: (editDialog.valueType || "int32") as ScanValueType,
                        });
                      }
                      const btn = document.activeElement as HTMLButtonElement;
                      if (btn) {
                        const originalText = btn.innerText;
                        btn.innerText = "✓";
                        btn.style.color = "#4caf50";
                        btn.style.borderColor = "#4caf50";
                        setTimeout(() => {
                          btn.innerText = originalText;
                          btn.style.color = "";
                          btn.style.borderColor = "";
                        }, 1500);
                      }
                    }
                  }}
                  disabled={!editDialog.bookmarkId || !onUpdateBookmark}
                  sx={{ minWidth: 60 }}
                >
                  Apply
                </Button>
              </Box>
              
              {/* Display Format Row */}
              {(() => {
                if (!editDialog.valueType) return null;
                const integerTypes = ["int8", "uint8", "int16", "uint16", "int32", "uint32", "int64", "uint64"];
                if (editDialog.valueType === "ptr") {
                  const ptrType = editDialog.ptrValueType || "int32";
                  if (!integerTypes.includes(ptrType)) return null;
                } else if (!integerTypes.includes(editDialog.valueType)) {
                  return null;
                }
                return (
                  <Box sx={{ display: "flex", gap: 1, alignItems: "center" }}>
                    <InputLabel sx={{ minWidth: 90, fontSize: "0.875rem" }}>Format</InputLabel>
                    <RadioGroup
                      row
                      value={editDialog.inputFormat}
                      onChange={(e) => {
                        const newFormat = e.target.value as "dec" | "hex";
                        
                        // Get current type for masking
                        const currentType = editDialog.valueType === "ptr" 
                          ? (editDialog.ptrValueType || "int32") 
                          : editDialog.valueType;
                        const getTypeMask = (type: string): bigint => {
                          switch (type) {
                            case "int8": case "uint8": return 0xFFn;
                            case "int16": case "uint16": return 0xFFFFn;
                            case "int32": case "uint32": return 0xFFFFFFFFn;
                            case "int64": case "uint64": return 0xFFFFFFFFFFFFFFFFn;
                            default: return 0xFFFFFFFFn;
                          }
                        };
                        
                        let convertedValue = editDialog.rawValue || editDialog.currentValue;
                        if (editDialog.rawValue) {
                          try {
                            let numValue = BigInt(editDialog.rawValue);
                            numValue = numValue & getTypeMask(currentType || "int32");
                            if (newFormat === "hex") {
                              convertedValue = "0x" + numValue.toString(16).toUpperCase();
                            } else {
                              convertedValue = numValue.toString();
                            }
                          } catch {
                            // Keep original value if conversion fails
                          }
                        }
                        setEditDialog((prev) => ({
                          ...prev,
                          inputFormat: newFormat,
                          newValue: convertedValue,
                        }));
                      }}
                      sx={{ flex: 1 }}
                    >
                      <FormControlLabel
                        value="dec"
                        control={<Radio size="small" />}
                        label="Dec"
                      />
                      <FormControlLabel
                        value="hex"
                        control={<Radio size="small" />}
                        label="Hex"
                      />
                    </RadioGroup>
                    <Button
                      variant="outlined"
                      size="small"
                      onClick={() => {
                        if (editDialog.bookmarkId && onUpdateBookmark) {
                          onUpdateBookmark(editDialog.bookmarkId, {
                            displayFormat: editDialog.inputFormat,
                          });
                          const btn = document.activeElement as HTMLButtonElement;
                          if (btn) {
                            const originalText = btn.innerText;
                            btn.innerText = "✓";
                            btn.style.color = "#4caf50";
                            btn.style.borderColor = "#4caf50";
                            setTimeout(() => {
                              btn.innerText = originalText;
                              btn.style.color = "";
                              btn.style.borderColor = "";
                            }, 1500);
                          }
                        }
                      }}
                      disabled={!editDialog.bookmarkId || !onUpdateBookmark}
                      sx={{ minWidth: 60 }}
                    >
                      Apply
                    </Button>
                  </Box>
                );
              })()}
              
              {/* Divider */}
              <Divider />
              
              {/* Edit Section */}
              <Typography variant="subtitle2" sx={{ fontWeight: 600, color: "primary.main" }}>
                Edit
              </Typography>
              <Box sx={{ display: "flex", gap: 1, alignItems: "flex-start" }}>
                <TextField
                  fullWidth
                  label="New Value"
                  size="small"
                  value={editDialog.newValue}
                  onChange={(e) =>
                    setEditDialog((prev) => ({
                      ...prev,
                      newValue: e.target.value,
                    }))
                  }
                  placeholder={(() => {
                    const effectiveType = editDialog.valueType === "ptr" 
                      ? (editDialog.ptrValueType || "int32") 
                      : editDialog.valueType;
                    const integerTypes = ["int8", "uint8", "int16", "uint16", "int32", "uint32", "int64", "uint64"];
                    if (effectiveType && integerTypes.includes(effectiveType)) {
                      return editDialog.inputFormat === "hex"
                        ? "0x1A2B or 1A2B"
                        : "Enter decimal value...";
                    }
                    return "Enter value...";
                  })()}
                  autoFocus
                  sx={{
                    "& .MuiInputBase-input": {
                      fontFamily: "monospace",
                    },
                  }}
                />
                <Button 
                  onClick={handleEditDialogSave} 
                  variant="contained"
                  sx={{ minWidth: 70, height: 40 }}
                >
                  Save
                </Button>
              </Box>
            </Stack>
          </DialogContent>
          <DialogActions>
            <Button onClick={handleEditDialogClose}>Close</Button>
          </DialogActions>
        </Dialog>

        {/* Manual Bookmark Dialog */}
        <Dialog
          open={manualBookmarkDialog.open}
          onClose={handleManualBookmarkDialogClose}
          maxWidth="sm"
          fullWidth
        >
          <DialogTitle>Add Manual Bookmark</DialogTitle>
          <DialogContent>
            <Stack spacing={2} sx={{ mt: 1 }}>
              <TextField
                fullWidth
                label={manualBookmarkDialog.valueType === "ptr" ? "Pointer Expression" : "Memory Address"}
                placeholder={
                  manualBookmarkDialog.valueType === "ptr"
                    ? "BASE+0x34ECA0 → [0x10] → [0x18] or [[Tutorial...]+0x100]+0x18"
                    : "0x12345678 or libc.so + 0x120000"
                }
                value={manualBookmarkDialog.address}
                onChange={(e) =>
                  setManualBookmarkDialog((prev) => ({
                    ...prev,
                    address: e.target.value,
                  }))
                }
                autoFocus
                helperText={
                  manualBookmarkDialog.valueType === "ptr"
                    ? "Enter pointer chain: BASE+offset → [offset] → [offset] or nested [[base]+offset]+offset"
                    : "Enter address in hex (0x...), decimal, or library+offset format"
                }
                sx={{
                  "& .MuiInputBase-input": {
                    fontFamily: "monospace",
                  },
                }}
              />
              <Box>
                <InputLabel id="bookmark-value-type-label">
                  Value Type
                </InputLabel>
                <Select
                  labelId="bookmark-value-type-label"
                  fullWidth
                  value={manualBookmarkDialog.valueType}
                  onChange={(e) => {
                    const newType = e.target.value as ScanValueType;
                    // Set default size based on type
                    let defaultSize = 4;
                    if (newType === "string") defaultSize = 64;
                    else if (newType === "bytes") defaultSize = 4;
                    setManualBookmarkDialog((prev) => ({
                      ...prev,
                      valueType: newType,
                      size: defaultSize,
                    }));
                  }}
                >
                  <MenuItem value="ptr">ptr (Pointer Chain)</MenuItem>
                  <MenuItem value="int8">int8</MenuItem>
                  <MenuItem value="uint8">uint8</MenuItem>
                  <MenuItem value="int16">int16</MenuItem>
                  <MenuItem value="uint16">uint16</MenuItem>
                  <MenuItem value="int32">int32</MenuItem>
                  <MenuItem value="uint32">uint32</MenuItem>
                  <MenuItem value="int64">int64</MenuItem>
                  <MenuItem value="uint64">uint64</MenuItem>
                  <MenuItem value="float">float</MenuItem>
                  <MenuItem value="double">double</MenuItem>
                  <MenuItem value="string">string</MenuItem>
                  <MenuItem value="bytes">bytes</MenuItem>
                </Select>
              </Box>
              {/* Pointer value type selection for ptr type */}
              {manualBookmarkDialog.valueType === "ptr" && (
                <Box>
                  <InputLabel id="bookmark-ptr-value-type-label">
                    Value Type (at final address)
                  </InputLabel>
                  <Select
                    labelId="bookmark-ptr-value-type-label"
                    fullWidth
                    value={manualBookmarkDialog.ptrValueType}
                    onChange={(e) =>
                      setManualBookmarkDialog((prev) => ({
                        ...prev,
                        ptrValueType: e.target.value as Exclude<ScanValueType, "ptr" | "string" | "bytes" | "regex">,
                      }))
                    }
                  >
                    <MenuItem value="int8">int8</MenuItem>
                    <MenuItem value="uint8">uint8</MenuItem>
                    <MenuItem value="int16">int16</MenuItem>
                    <MenuItem value="uint16">uint16</MenuItem>
                    <MenuItem value="int32">int32</MenuItem>
                    <MenuItem value="uint32">uint32</MenuItem>
                    <MenuItem value="int64">int64</MenuItem>
                    <MenuItem value="uint64">uint64</MenuItem>
                    <MenuItem value="float">float</MenuItem>
                    <MenuItem value="double">double</MenuItem>
                  </Select>
                </Box>
              )}
              {/* Size field for string/bytes types */}
              {(manualBookmarkDialog.valueType === "string" ||
                manualBookmarkDialog.valueType === "bytes") && (
                <TextField
                  fullWidth
                  label="Size (bytes)"
                  type="number"
                  value={manualBookmarkDialog.size}
                  onChange={(e) =>
                    setManualBookmarkDialog((prev) => ({
                      ...prev,
                      size: Math.max(1, parseInt(e.target.value) || 1),
                    }))
                  }
                  helperText={
                    manualBookmarkDialog.valueType === "string"
                      ? "Number of characters to read"
                      : "Number of bytes to read"
                  }
                  inputProps={{ min: 1, max: 1024 }}
                />
              )}
              {/* Display format for integer types (including ptr with integer ptrValueType) */}
              {(() => {
                const valueType = manualBookmarkDialog.valueType;
                const ptrValueType = manualBookmarkDialog.ptrValueType;
                const showDisplayFormat =
                  (valueType === "ptr" && !["float", "double"].includes(ptrValueType)) ||
                  (!["string", "bytes", "float", "double", "ptr"].includes(valueType));
                return showDisplayFormat ? (
                  <Box>
                    <InputLabel id="bookmark-display-format-label">
                      Display Format
                    </InputLabel>
                    <RadioGroup
                      row
                      value={manualBookmarkDialog.displayFormat}
                      onChange={(e) =>
                        setManualBookmarkDialog((prev) => ({
                          ...prev,
                          displayFormat: e.target.value as "dec" | "hex",
                        }))
                      }
                    >
                      <FormControlLabel
                        value="dec"
                        control={<Radio size="small" />}
                        label="Decimal"
                      />
                      <FormControlLabel
                        value="hex"
                        control={<Radio size="small" />}
                        label="Hexadecimal"
                      />
                    </RadioGroup>
                  </Box>
                ) : null;
              })()}
              <TextField
                fullWidth
                label="Description (Optional)"
                placeholder=""
                value={manualBookmarkDialog.description}
                onChange={(e) =>
                  setManualBookmarkDialog((prev) => ({
                    ...prev,
                    description: e.target.value,
                  }))
                }
              />
            </Stack>
          </DialogContent>
          <DialogActions>
            <Button onClick={handleManualBookmarkDialogClose}>Cancel</Button>
            <Button
              onClick={handleManualBookmarkDialogSave}
              variant="contained"
              disabled={!manualBookmarkDialog.address.trim()}
            >
              Add Bookmark
            </Button>
          </DialogActions>
        </Dialog>

        {/* Hardware Watchpoint Dialog */}
        <Dialog
          open={watchpointDialog.open}
          onClose={handleWatchpointDialogClose}
          maxWidth="sm"
          fullWidth
        >
          <DialogTitle>Set Hardware Watchpoint</DialogTitle>
          <DialogContent>
            <Stack spacing={2} sx={{ mt: 1 }}>
              <TextField
                fullWidth
                label="Memory Address"
                placeholder="0x12345678 or 305419896"
                value={watchpointDialog.address}
                onChange={(e) =>
                  setWatchpointDialog((prev) => ({
                    ...prev,
                    address: e.target.value,
                  }))
                }
                autoFocus
                helperText="Enter address in hex (0x...) or decimal format"
                sx={{
                  "& .MuiInputBase-input": {
                    fontFamily: "monospace",
                  },
                }}
              />
              <Box>
                <InputLabel id="watchpoint-size-label">Size (bytes)</InputLabel>
                <Select
                  labelId="watchpoint-size-label"
                  fullWidth
                  value={watchpointDialog.size}
                  onChange={(e) =>
                    setWatchpointDialog((prev) => ({
                      ...prev,
                      size: e.target.value as WatchpointSize,
                    }))
                  }
                >
                  <MenuItem value={1}>1 byte</MenuItem>
                  <MenuItem value={2}>2 bytes</MenuItem>
                  <MenuItem value={4}>4 bytes</MenuItem>
                  <MenuItem value={8}>8 bytes</MenuItem>
                </Select>
              </Box>
              <Box>
                <InputLabel id="watchpoint-access-type-label">
                  Trigger Condition
                </InputLabel>
                <Select
                  labelId="watchpoint-access-type-label"
                  fullWidth
                  value={watchpointDialog.accessType}
                  onChange={(e) =>
                    setWatchpointDialog((prev) => ({
                      ...prev,
                      accessType: e.target.value as WatchpointAccessType,
                    }))
                  }
                >
                  <MenuItem value="r">Read</MenuItem>
                  <MenuItem value="w">Write</MenuItem>
                  <MenuItem value="rw">Read/Write</MenuItem>
                </Select>
              </Box>
              <TextField
                fullWidth
                label="Description (Optional)"
                placeholder="Optional description for this watchpoint"
                value={watchpointDialog.description}
                onChange={(e) =>
                  setWatchpointDialog((prev) => ({
                    ...prev,
                    description: e.target.value,
                  }))
                }
              />
            </Stack>
          </DialogContent>
          <DialogActions>
            <Button onClick={handleWatchpointDialogClose}>Cancel</Button>
            <Button
              onClick={handleWatchpointDialogSave}
              variant="contained"
              disabled={!watchpointDialog.address.trim()}
              color="warning"
            >
              Set Watchpoint
            </Button>
          </DialogActions>
        </Dialog>
      </Box>
    </MainContent>
  );
};

```

`src/client/src/components/ScannerSidebar.tsx`:

```tsx
import React from "react";
import {
  Box,
  Paper,
  Typography,
  Select,
  MenuItem,
  TextField,
  Button,
  FormControl,
  FormControlLabel,
  Checkbox,
  Stack,
  InputLabel,
  Radio,
  RadioGroup,
  IconButton,
} from "@mui/material";
import { styled } from "@mui/material/styles";
import { Search, Refresh, TuneRounded, Delete, Map as MapIcon, ExpandMore, ExpandLess } from "@mui/icons-material";
import { borderColors } from "../utils/theme";
import { ScanValueType, ScanType, ScanSettings } from "../types/index";
import { useAppState } from "../hooks/useAppState";

export interface MemoryRegion {
  start_address: string;
  end_address: string;
  size: number;
  protection: string;
  module_name?: string;
  selected?: boolean;
}

const SidebarContainer = styled(Paper)(({ theme }) => ({
  gridArea: "sidebar",
  backgroundColor: theme.palette.background.default,
  borderRight: `1px solid ${borderColors.main}`,
  padding: 0,
  display: "flex",
  flexDirection: "column",
  maxHeight: "100%",
  overflow: "hidden",
}));

//const __SidebarHeader = styled(Box)(({ theme }) => ({
//  padding: theme.spacing(1),
//  borderBottom: `1px solid ${borderColors.main}`,
//  backgroundColor: theme.palette.background.paper,
//}));>

const SidebarContent = styled(Box)(({ theme }) => ({
  flex: 1,
  padding: theme.spacing(1),
  display: "flex",
  flexDirection: "column",
  gap: theme.spacing(0.5),
  overflow: "auto",
}));

const ScanSection = styled(Box)(({ theme }) => ({
  display: "flex",
  flexDirection: "column",
  gap: theme.spacing(0.25),
  marginBottom: theme.spacing(1),
  backgroundColor: "transparent",
}));

const ScanSectionHeader = styled(Box)(() => ({
  display: "flex",
  alignItems: "center",
  padding: "4px 8px",
  backgroundColor: "#252526",
  borderRadius: "4px",
}));

const ScanSectionContent = styled(Box)(() => ({
  padding: "4px 8px 0 8px",
}));

const ScanControls = styled(Box)(({ theme }) => ({
  display: "flex",
  flexDirection: "column",
  gap: theme.spacing(0.5),
}));

// Responsive form controls
const ResponsiveFormControl = styled(FormControl)(() => ({
  "@media (max-height: 800px)": {
    "& .MuiInputBase-root": {
      minHeight: "20px", // Half of normal height
      fontSize: "11px",
    },
    "& .MuiSelect-select": {
      paddingTop: "4px",
      paddingBottom: "4px",
    },
    "& .MuiInputLabel-root": {
      fontSize: "11px",
    },
  },
}));

const ResponsiveTextField = styled(TextField)(() => ({
  "@media (max-height: 800px)": {
    "& .MuiInputBase-root": {
      minHeight: "20px", // Half of normal height
      fontSize: "11px",
    },
    "& .MuiInputBase-input": {
      paddingTop: "4px",
      paddingBottom: "4px",
    },
    "& .MuiInputLabel-root": {
      fontSize: "11px",
    },
  },
}));

const ResponsiveButton = styled(Button)(() => ({
  "@media (max-height: 800px)": {
    minHeight: "24px", // Half of normal height
    fontSize: "10px",
    padding: "2px 8px",
  },
}));

const ResponsiveTypography = styled(Typography)(() => ({
  "@media (max-height: 800px)": {
    fontSize: "9px !important", // Half of the normal font size
  },
}));

const ResponsiveFormControlLabel = styled(FormControlLabel)(() => ({
  "@media (max-height: 800px)": {
    "& .MuiFormControlLabel-label": {
      fontSize: "9px",
    },
    "& .MuiCheckbox-root": {
      padding: "2px",
    },
    margin: "0 !important",
    minWidth: "auto",
  },
}));

const ResponsiveBox = styled(Box)(() => ({
  "@media (max-height: 800px)": {
    gap: "4px !important", // Reduced gap between elements
  },
}));

interface ScannerSidebarProps {
  // Legacy props for backward compatibility
  memoryRegionsLoaded?: boolean;
  onScanSettingsChange?: (settings: ScanSettings) => boolean;
  onFirstScan?: () => void;
  onNextScan?: () => void;
  onNewScan?: () => void;
  onClearScan?: () => void;
}

export const ScannerSidebar: React.FC<ScannerSidebarProps> = ({
  memoryRegionsLoaded: propsMemoryRegionsLoaded,
  onScanSettingsChange,
  onFirstScan,
  onNextScan,
  onNewScan,
  onClearScan,
}) => {
  // Use global app state
  const { ui, uiActions, system } = useAppState();
  const rawScanSettings = ui.scannerState.scanSettings;
  
  // Check if target is iOS or Android (YARA not supported due to wasmtime limitations)
  const isIOS = system.serverInfo?.target_os?.toLowerCase() === "ios";
  const isAndroid = system.serverInfo?.target_os?.toLowerCase() === "android";
  const isYaraDisabled = isIOS || isAndroid;
  
  // Collapse state for Search Mode section
  const [searchModeCollapsed, setSearchModeCollapsed] = React.useState(true);

  // デフォルト値で補完したスキャン設定を作成
  const defaultScanSettings = {
    valueType: "int32" as ScanValueType,
    scanType: "exact" as ScanType,
    value: "",
    valueMax: "", // For range search
    startAddress: "",
    endAddress: "",
    scanMode: "manual" as "manual" | "regions",
    selectedRegions: [],
    alignment: 4,
    writable: null as boolean | null,
    executable: null as boolean | null,
    readable: null as boolean | null,
    doSuspend: false,
    searchMode: "normal" as "normal" | "yara" | "ptr",
    yaraRule: "",
    ptrMapFilePaths: [] as Array<{ path: string; name: string; targetAddress?: string }>,
    ptrMaxDepth: 5,
    ptrMaxOffset: 4096,
  };

  const scanSettings = { ...defaultScanSettings, ...rawScanSettings };
  const isScanning = ui.scannerState.isScanning;
  const scanResults = ui.scannerState.totalResults;
  const canNextScan = ui.scannerState.scanResults.length > 0 && !isScanning;

  // Filter時（スキャン結果がある場合）は、Scan TypeとValue以外の設定をロック
  const isFilterMode = ui.scannerState.scanResults.length > 0;
  const isSettingsLocked = isScanning || isFilterMode;

  // Use props if provided (legacy support), otherwise use empty defaults
  const memoryRegionsLoaded = propsMemoryRegionsLoaded ?? true;
  const handleSettingChange = <K extends keyof ScanSettings>(
    key: K,
    value: ScanSettings[K]
  ) => {
    const newSettings = { ...scanSettings, [key]: value };
    // Update UI state
    uiActions.setScanSettings(newSettings);
    // Call legacy callback if provided - cast to proper type
    onScanSettingsChange?.(newSettings as ScanSettings);
  };

  const valueTypes = [
    { value: "int8", label: "Int8 (1 byte)" },
    { value: "uint8", label: "UInt8 (1 byte)" },
    { value: "int16", label: "Int16 (2 bytes)" },
    { value: "uint16", label: "UInt16 (2 bytes)" },
    { value: "int32", label: "Int32 (4 bytes)" },
    { value: "uint32", label: "UInt32 (4 bytes)" },
    { value: "int64", label: "Int64 (8 bytes)" },
    { value: "uint64", label: "UInt64 (8 bytes)" },
    { value: "float", label: "Float (4 bytes)" },
    { value: "double", label: "Double (8 bytes)" },
    { value: "string", label: "String" },
    { value: "bytes", label: "Array of Bytes" },
    { value: "regex", label: "Regex" },
  ];

  // string/bytes/regex型の場合、増減比較は意味がないため非表示にする
  const isStringOrBytesOrRegex =
    scanSettings.valueType === "string" ||
    scanSettings.valueType === "bytes" ||
    scanSettings.valueType === "regex";

  // Check if value type is an integer type (supports hex input)
  const isIntegerType = [
    "int8",
    "uint8",
    "int16",
    "uint16",
    "int32",
    "uint32",
    "int64",
    "uint64",
  ].includes(scanSettings.valueType);

  // Check if value type supports range search (numeric types only)
  const supportsRangeSearch = [
    "int8",
    "uint8",
    "int16",
    "uint16",
    "int32",
    "uint32",
    "int64",
    "uint64",
    "float",
    "double",
  ].includes(scanSettings.valueType);

  const scanTypes: { value: ScanType; label: string; disabled?: boolean }[] = [
    { value: "exact", label: "Exact Value" },
    // Range search only for numeric types
    ...(supportsRangeSearch
      ? [
          { value: "range" as ScanType, label: "Value between..." },
          {
            value: "greater_or_equal" as ScanType,
            label: "Greater than or equal...",
          },
          { value: "less_than" as ScanType, label: "Less than..." },
        ]
      : []),
    // Unknown value search only for numeric types (first scan only)
    ...(supportsRangeSearch && !canNextScan && false
      ? [{ value: "unknown" as ScanType, label: "Unknown initial value" }]
      : []),
    { value: "changed", label: "Changed value", disabled: !canNextScan },
    { value: "unchanged", label: "Unchanged value", disabled: !canNextScan },
    // increased/decreased are hidden for string/bytes/regex types
    ...(isStringOrBytesOrRegex
      ? []
      : [
          {
            value: "increased" as ScanType,
            label: "Increased value",
            disabled: !canNextScan,
          },
          {
            value: "decreased" as ScanType,
            label: "Decreased value",
            disabled: !canNextScan,
          },
        ]),
  ];

  const needsValue = [
    "exact",
    "bigger",
    "smaller",
    "range",
    "greater_or_equal",
    "less_than",
  ].includes(scanSettings.scanType);

  // Check if range search is selected
  const isRangeSearch = scanSettings.scanType === "range";

  // Unknown and comparison types don't need value input
  const isComparisonType = [
    "unknown",
    "changed",
    "unchanged",
    "increased",
    "decreased",
  ].includes(scanSettings.scanType);

  return (
    <SidebarContainer elevation={0}>
      {/* Settings Header */}
      <Box
        sx={{
          p: 1,
          borderBottom: "1px solid #3e3e42",
        }}
      >
        <Box
          sx={{
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            gap: 0.5,
          }}
        >
          <TuneRounded sx={{ fontSize: 16, color: "text.secondary" }} />
          <Typography
            variant="subtitle1"
            sx={{
              fontSize: "13px",
              fontWeight: 600,
              color: "text.primary",
            }}
          >
            Settings
          </Typography>
        </Box>
      </Box>
      <SidebarContent>
        {/* Search Mode Toggle (Normal / YARA / PTR) - Collapsible */}
        <ScanSection>
          <ScanSectionHeader
            sx={{ cursor: "pointer", justifyContent: "space-between" }}
            onClick={() => setSearchModeCollapsed(!searchModeCollapsed)}
          >
            <ResponsiveTypography
              variant="subtitle2"
              sx={{
                fontWeight: 600,
                fontSize: "10px",
                color: "#4fc1ff",
                textTransform: "uppercase",
                letterSpacing: "0.5px",
              }}
            >
              Search Mode: {(scanSettings.searchMode || "normal").toUpperCase()}
            </ResponsiveTypography>
            {searchModeCollapsed ? (
              <ExpandMore sx={{ fontSize: 16, color: "#888" }} />
            ) : (
              <ExpandLess sx={{ fontSize: 16, color: "#888" }} />
            )}
          </ScanSectionHeader>
          {!searchModeCollapsed && (
          <ScanSectionContent>
            <RadioGroup
              row
              value={scanSettings.searchMode || "normal"}
              onChange={(e) =>
                handleSettingChange(
                  "searchMode",
                  e.target.value as "normal" | "yara" | "ptr"
                )
              }
            >
              <ResponsiveFormControlLabel
                value="normal"
                control={<Radio size="small" disabled={isSettingsLocked} />}
                label="Normal"
                sx={{ mr: 1 }}
              />
              <ResponsiveFormControlLabel
                value="yara"
                control={<Radio size="small" disabled={isSettingsLocked || isYaraDisabled} />}
                label={"YARA"}
                sx={{ mr: 1, opacity: isYaraDisabled ? 0.5 : 1 }}
              />
              <ResponsiveFormControlLabel
                value="ptr"
                control={<Radio size="small" disabled={isSettingsLocked} />}
                label="PTR"
              />
            </RadioGroup>
          </ScanSectionContent>
          )}
        </ScanSection>

        {/* YARA Rule Input - only show in YARA mode */}
        {scanSettings.searchMode === "yara" && (
          <ScanSection>
            <ScanSectionHeader>
              <ResponsiveTypography
                variant="subtitle2"
                sx={{
                  fontWeight: 600,
                  fontSize: "10px",
                  color: "#4fc1ff",
                  textTransform: "uppercase",
                  letterSpacing: "0.5px",
                }}
              >
                YARA Rule
              </ResponsiveTypography>
            </ScanSectionHeader>
            <ScanSectionContent>
              <ResponsiveTextField
                fullWidth
                multiline
                rows={6}
                size="small"
                placeholder={`rule example {
  strings:
    $a = "pattern"
  condition:
    $a
}`}
                value={scanSettings.yaraRule || ""}
                disabled={isSettingsLocked}
                onChange={(e) => handleSettingChange("yaraRule", e.target.value)}
                sx={{
                  "& .MuiInputBase-root": {
                    fontFamily: "monospace",
                    fontSize: "11px",
                  },
                }}
              />
            </ScanSectionContent>
          </ScanSection>
        )}

        {/* PTR Scan Settings - only show in PTR mode */}
        {scanSettings.searchMode === "ptr" && (
          <ScanSection>
            <ScanSectionHeader>
              <ResponsiveTypography
                variant="subtitle2"
                sx={{
                  fontWeight: 600,
                  fontSize: "10px",
                  color: "#4fc1ff",
                  textTransform: "uppercase",
                  letterSpacing: "0.5px",
                }}
              >
                Pointer Scan Settings
              </ResponsiveTypography>
            </ScanSectionHeader>
            <ScanSectionContent>
              <Stack spacing={1}>
                <ResponsiveTypography
                  variant="caption"
                  sx={{
                    fontSize: "10px",
                    color: "#9cdcfe",
                  }}
                >
                  Select 2 or more PointerMap files (.dptr) to find common pointer paths.
                  Generate PointerMaps from Bookmarks tab first.
                </ResponsiveTypography>
                <Box sx={{ display: "flex", flexDirection: "column", gap: 0.5 }}>
                  <ResponsiveButton
                    variant="outlined"
                    size="small"
                    disabled={isSettingsLocked}
                    onClick={async () => {
                      console.log("Button clicked, isSettingsLocked:", isSettingsLocked);
                      try {
                        const { invoke } = await import("@tauri-apps/api/core");
                        console.log("Invoking open_pointermap_files_dialog...");
                        const files = await invoke<{ path: string; name: string }[]>("open_pointermap_files_dialog");
                        console.log("Files received:", files);
                        if (files && files.length > 0) {
                          // Get existing files
                          const existingFiles = scanSettings.ptrMapFilePaths || [];
                          console.log("Existing files:", existingFiles);
                          const existingPaths = new Set(existingFiles.map((f: { path: string }) => f.path));
                          // Filter out duplicates and add new files with parsed target address
                          const newFiles = files
                            .filter(f => !existingPaths.has(f.path))
                            .map(f => {
                              // Parse target address from filename: pointermap_XXXXXX_timestamp.dptr
                              const match = f.name.match(/pointermap_([0-9A-Fa-f]+)_/);
                              const targetAddress = match ? `0x${match[1].toUpperCase()}` : "";
                              return { ...f, targetAddress };
                            });
                          const allFiles = [...existingFiles, ...newFiles];
                          console.log("Setting ptrMapFilePaths to:", allFiles);
                          handleSettingChange("ptrMapFilePaths", allFiles);
                          console.log("After handleSettingChange, scanSettings.ptrMapFilePaths:", scanSettings.ptrMapFilePaths);
                        }
                      } catch (error) {
                        console.error("Failed to open file dialog:", error);
                      }
                    }}
                    sx={{ textTransform: "none" }}
                  >
                    Add PointerMap Files...
                  </ResponsiveButton>
                  {scanSettings.ptrMapFilePaths && scanSettings.ptrMapFilePaths.length > 0 && (
                    <>
                      <Box sx={{ 
                        backgroundColor: "#1e1e1e", 
                        borderRadius: "4px", 
                        maxHeight: "200px",
                        overflow: "auto"
                      }}>
                        {scanSettings.ptrMapFilePaths.map((file: { path: string; name: string; targetAddress?: string }, idx: number) => (
                          <Box
                            key={file.path}
                            sx={{
                              display: "flex",
                              flexDirection: "column",
                              px: 0.5,
                              py: 0.5,
                              borderBottom: idx < scanSettings.ptrMapFilePaths.length - 1 ? "1px solid #333" : "none",
                              "&:hover": {
                                backgroundColor: "#2a2a2a",
                              },
                            }}
                          >
                            <Box sx={{ display: "flex", alignItems: "center", justifyContent: "space-between" }}>
                              <Box sx={{ display: "flex", alignItems: "center", gap: 0.5, flex: 1, minWidth: 0 }}>
                                <MapIcon sx={{ fontSize: "12px", color: "#4fc1ff", flexShrink: 0 }} />
                                <ResponsiveTypography
                                  variant="caption"
                                  sx={{
                                    fontSize: "9px",
                                    color: "#4fc1ff",
                                    overflow: "hidden",
                                    textOverflow: "ellipsis",
                                    whiteSpace: "nowrap",
                                  }}
                                  title={file.path}
                                >
                                  {file.name}
                                </ResponsiveTypography>
                              </Box>
                              <IconButton
                                size="small"
                                disabled={isSettingsLocked}
                                onClick={() => {
                                  const newFiles = scanSettings.ptrMapFilePaths.filter((f: { path: string }) => f.path !== file.path);
                                  handleSettingChange("ptrMapFilePaths", newFiles);
                                  handleSettingChange("ptrMapFiles", newFiles.map((f: { name: string }) => f.name));
                                }}
                                sx={{ p: 0.25, color: "#f48771" }}
                              >
                                <Delete sx={{ fontSize: "12px" }} />
                              </IconButton>
                            </Box>
                            <Box sx={{ display: "flex", alignItems: "center", gap: 0.5, mt: 0.25, ml: 2 }}>
                              <ResponsiveTypography
                                variant="caption"
                                sx={{ fontSize: "8px", color: "#888", flexShrink: 0 }}
                              >
                                Target:
                              </ResponsiveTypography>
                              <input
                                type="text"
                                value={file.targetAddress || ""}
                                disabled={isSettingsLocked}
                                placeholder="0x..."
                                onChange={(e) => {
                                  const newFiles = scanSettings.ptrMapFilePaths.map((f: { path: string; name: string; targetAddress?: string }) =>
                                    f.path === file.path ? { ...f, targetAddress: e.target.value } : f
                                  );
                                  handleSettingChange("ptrMapFilePaths", newFiles);
                                }}
                                style={{
                                  flex: 1,
                                  backgroundColor: "#2d2d2d",
                                  border: "1px solid #444",
                                  borderRadius: "3px",
                                  color: "#9cdcfe",
                                  fontFamily: "monospace",
                                  fontSize: "10px",
                                  padding: "2px 4px",
                                  outline: "none",
                                  minWidth: 0,
                                }}
                              />
                            </Box>
                          </Box>
                        ))}
                      </Box>
                      <ResponsiveButton
                        variant="text"
                        size="small"
                        color="error"
                        disabled={isSettingsLocked}
                        onClick={() => {
                          handleSettingChange("ptrMapFilePaths", []);
                          handleSettingChange("ptrMapFiles", []);
                        }}
                        sx={{ textTransform: "none", fontSize: "9px", minHeight: "20px", p: 0.5 }}
                      >
                        Clear All
                      </ResponsiveButton>
                    </>
                  )}
                  {scanSettings.ptrMapFilePaths && scanSettings.ptrMapFilePaths.length > 0 && 
                   scanSettings.ptrMapFilePaths.length < 2 && (
                    <ResponsiveTypography
                      variant="caption"
                      sx={{
                        fontSize: "9px",
                        color: "#f48771",
                      }}
                    >
                      ⚠ Need at least 2 PointerMap files
                    </ResponsiveTypography>
                  )}
                </Box>
                <ResponsiveTextField
                  fullWidth
                  size="small"
                  label="Max Depth"
                  type="number"
                  value={scanSettings.ptrMaxDepth || 5}
                  disabled={isSettingsLocked}
                  onChange={(e) => handleSettingChange("ptrMaxDepth", parseInt(e.target.value) || 5)}
                  inputProps={{ min: 1, max: 10 }}
                />
                <ResponsiveTextField
                  fullWidth
                  size="small"
                  label="Max Offset (hex)"
                  placeholder="0x1000"
                  value={`0x${(scanSettings.ptrMaxOffset || 4096).toString(16).toUpperCase()}`}
                  disabled={isSettingsLocked}
                  onChange={(e) => {
                    const val = e.target.value.replace(/^0x/i, "");
                    const num = parseInt(val, 16);
                    if (!isNaN(num) && num >= 0) {
                      handleSettingChange("ptrMaxOffset", num);
                    }
                  }}
                  sx={{
                    "& .MuiInputBase-input": {
                      fontFamily: "monospace",
                    },
                  }}
                />
              </Stack>
            </ScanSectionContent>
          </ScanSection>
        )}

        {/* Value Type Selection - hide in YARA/PTR mode */}
        {scanSettings.searchMode !== "yara" && scanSettings.searchMode !== "ptr" && (
        <ScanSection>
          <ScanSectionHeader>
            <ResponsiveTypography
              variant="subtitle2"
              sx={{
                fontWeight: 600,
                fontSize: "10px",
                color: "#4fc1ff",
                textTransform: "uppercase",
                letterSpacing: "0.5px",
              }}
            >
              Value Type
            </ResponsiveTypography>
          </ScanSectionHeader>
          <ScanSectionContent>
            <ResponsiveFormControl fullWidth size="small">
              <Select
                value={scanSettings.valueType || "int32"}
                disabled={isSettingsLocked}
                onChange={(e) =>
                  handleSettingChange(
                    "valueType",
                    e.target.value as ScanValueType
                  )
                }
              >
                {valueTypes.map((type) => (
                  <MenuItem key={type.value} value={type.value}>
                    {type.label}
                  </MenuItem>
                ))}
              </Select>
            </ResponsiveFormControl>
          </ScanSectionContent>
        </ScanSection>
        )}

        {/* Scan Type Selection - hide in YARA/PTR mode */}
        {scanSettings.searchMode !== "yara" && scanSettings.searchMode !== "ptr" && (
        <ScanSection>
          <ScanSectionHeader>
            <ResponsiveTypography
              variant="subtitle2"
              sx={{
                fontWeight: 600,
                fontSize: "10px",
                color: "#4fc1ff",
                textTransform: "uppercase",
                letterSpacing: "0.5px",
              }}
            >
              Scan Type
            </ResponsiveTypography>
          </ScanSectionHeader>
          <ScanSectionContent>
            <ResponsiveFormControl fullWidth size="small">
              <Select
                value={scanSettings.scanType || "exact"}
                onChange={(e) =>
                  handleSettingChange("scanType", e.target.value as ScanType)
                }
              >
                {scanTypes.map((type) => (
                  <MenuItem
                    key={type.value}
                    value={type.value}
                    disabled={type.disabled}
                  >
                    {type.label}
                  </MenuItem>
                ))}
              </Select>
            </ResponsiveFormControl>
          </ScanSectionContent>
        </ScanSection>
        )}

        {/* Value Input - hide in YARA/PTR mode */}
        {scanSettings.searchMode !== "yara" && scanSettings.searchMode !== "ptr" && (needsValue || isComparisonType) && (
          <ScanSection>
            <ScanSectionHeader>
              <ResponsiveTypography
                variant="subtitle2"
                sx={{
                  fontWeight: 600,
                  fontSize: "10px",
                  color: "#4fc1ff",
                  textTransform: "uppercase",
                  letterSpacing: "0.5px",
                }}
              >
                Value
              </ResponsiveTypography>
            </ScanSectionHeader>
            <ScanSectionContent>
              <Stack spacing={0.5}>
                {/* Range search: Min value label */}
                {isRangeSearch && (
                  <ResponsiveTypography
                    variant="caption"
                    sx={{
                      fontSize: "9px",
                      color: "#9cdcfe",
                      textTransform: "uppercase",
                      letterSpacing: "0.3px",
                    }}
                  >
                    Min Value
                  </ResponsiveTypography>
                )}
                <ResponsiveTextField
                  fullWidth
                  size="small"
                  value={scanSettings.value || ""}
                  disabled={isComparisonType}
                  onChange={(e) => handleSettingChange("value", e.target.value)}
                  placeholder={
                    isComparisonType
                      ? "Not required"
                      : isRangeSearch
                        ? isIntegerType
                          ? scanSettings.valueInputFormat === "hex"
                            ? "Min (0x1A2B)"
                            : "Min value"
                          : "Min value"
                        : scanSettings.valueType === "string"
                          ? "Enter text..."
                          : scanSettings.valueType === "bytes"
                            ? "11 22 33"
                            : isIntegerType
                              ? scanSettings.valueInputFormat === "hex"
                                ? "0x1A2B or 1A2B"
                                : "Enter decimal value..."
                              : "Enter value..."
                  }
                  sx={{
                    "& .MuiInputBase-root": {
                      backgroundColor: "#1e1e1e",
                      fontSize: "14px",
                    },
                    "& .MuiInputBase-input": {
                      py: 1,
                    },
                    "@media (max-height: 800px)": {
                      "& .MuiInputBase-root": {
                        fontSize: "11px",
                      },
                      "& .MuiInputBase-input": {
                        py: 0.5,
                      },
                    },
                  }}
                />
                {/* Range search: Max value input */}
                {isRangeSearch && (
                  <>
                    <ResponsiveTypography
                      variant="caption"
                      sx={{
                        fontSize: "9px",
                        color: "#9cdcfe",
                        textTransform: "uppercase",
                        letterSpacing: "0.3px",
                        mt: 0.5,
                      }}
                    >
                      Max Value
                    </ResponsiveTypography>
                    <ResponsiveTextField
                      fullWidth
                      size="small"
                      value={scanSettings.valueMax || ""}
                      onChange={(e) =>
                        handleSettingChange("valueMax", e.target.value)
                      }
                      placeholder={
                        isIntegerType
                          ? scanSettings.valueInputFormat === "hex"
                            ? "Max (0x1A2B)"
                            : "Max value"
                          : "Max value"
                      }
                      sx={{
                        "& .MuiInputBase-root": {
                          backgroundColor: "#1e1e1e",
                          fontSize: "14px",
                        },
                        "& .MuiInputBase-input": {
                          py: 1,
                        },
                        "@media (max-height: 800px)": {
                          "& .MuiInputBase-root": {
                            fontSize: "11px",
                          },
                          "& .MuiInputBase-input": {
                            py: 0.5,
                          },
                        },
                      }}
                    />
                  </>
                )}
                {/* Hex/Dec toggle for integer types */}
                {isIntegerType && !isComparisonType && (
                  <RadioGroup
                    row
                    value={scanSettings.valueInputFormat || "dec"}
                    onChange={(e) =>
                      handleSettingChange(
                        "valueInputFormat",
                        e.target.value as "dec" | "hex"
                      )
                    }
                    sx={{
                      gap: 1,
                      "@media (max-height: 800px)": {
                        gap: 0.5,
                      },
                    }}
                  >
                    <FormControlLabel
                      value="dec"
                      control={
                        <Radio
                          size="small"
                          sx={{
                            padding: "2px",
                            "& .MuiSvgIcon-root": { fontSize: "14px" },
                            "@media (max-height: 800px)": {
                              padding: "1px",
                              "& .MuiSvgIcon-root": { fontSize: "12px" },
                            },
                          }}
                        />
                      }
                      label="Dec"
                      sx={{
                        margin: 0,
                        "& .MuiTypography-root": {
                          fontSize: "11px",
                          color: "#9cdcfe",
                        },
                        "@media (max-height: 800px)": {
                          "& .MuiTypography-root": {
                            fontSize: "9px",
                          },
                        },
                      }}
                    />
                    <FormControlLabel
                      value="hex"
                      control={
                        <Radio
                          size="small"
                          sx={{
                            padding: "2px",
                            "& .MuiSvgIcon-root": { fontSize: "14px" },
                            "@media (max-height: 800px)": {
                              padding: "1px",
                              "& .MuiSvgIcon-root": { fontSize: "12px" },
                            },
                          }}
                        />
                      }
                      label="Hex"
                      sx={{
                        margin: 0,
                        "& .MuiTypography-root": {
                          fontSize: "11px",
                          color: "#9cdcfe",
                        },
                        "@media (max-height: 800px)": {
                          "& .MuiTypography-root": {
                            fontSize: "9px",
                          },
                        },
                      }}
                    />
                  </RadioGroup>
                )}
              </Stack>
            </ScanSectionContent>
          </ScanSection>
        )}

        {/* Memory Range */}
        <ScanSection>
          <ScanSectionHeader>
            <ResponsiveTypography
              variant="subtitle2"
              sx={{
                fontWeight: 600,
                fontSize: "10px",
                color: "#4fc1ff",
                textTransform: "uppercase",
                letterSpacing: "0.5px",
              }}
            >
              Memory Range
            </ResponsiveTypography>
          </ScanSectionHeader>
          <ScanSectionContent>
            <Stack spacing={0.75}>
              <ResponsiveTextField
                fullWidth
                size="small"
                label="Start Address"
                value={scanSettings.startAddress || ""}
                disabled={isSettingsLocked}
                onChange={(e) =>
                  handleSettingChange("startAddress", e.target.value)
                }
                placeholder="0x0"
              />
              <ResponsiveTextField
                fullWidth
                size="small"
                label="End Address"
                value={scanSettings.endAddress || ""}
                disabled={isSettingsLocked}
                onChange={(e) =>
                  handleSettingChange("endAddress", e.target.value)
                }
                placeholder="0x7FFFFFFFFFFF"
              />
            </Stack>
          </ScanSectionContent>
        </ScanSection>

        {/* Memory Protection - hide in PTR mode */}
        {scanSettings.searchMode !== "ptr" && (
        <ScanSection>
          <ScanSectionHeader>
            <ResponsiveTypography
              variant="subtitle2"
              sx={{
                fontWeight: 600,
                fontSize: "10px",
                color: "#4fc1ff",
                textTransform: "uppercase",
                letterSpacing: "0.5px",
              }}
            >
              Protection
            </ResponsiveTypography>
          </ScanSectionHeader>
          <ScanSectionContent>
            <ResponsiveBox
              sx={{ display: "flex", flexDirection: "row", gap: 2 }}
            >
              <ResponsiveFormControlLabel
                control={
                  <Checkbox
                    checked={scanSettings.readable === true}
                    indeterminate={scanSettings.readable === null}
                    disabled={isSettingsLocked}
                    onChange={() => {
                      // 3段階サイクル: false → true → null → false
                      const currentValue = scanSettings.readable;
                      if (currentValue === false) {
                        handleSettingChange("readable", true);
                      } else if (currentValue === true) {
                        handleSettingChange("readable", null);
                      } else {
                        handleSettingChange("readable", false);
                      }
                    }}
                    size="small"
                  />
                }
                label={
                  <ResponsiveTypography variant="caption">
                    Read
                  </ResponsiveTypography>
                }
                sx={{ margin: 0, minWidth: 0 }}
              />
              <ResponsiveFormControlLabel
                control={
                  <Checkbox
                    checked={scanSettings.writable === true}
                    indeterminate={scanSettings.writable === null}
                    disabled={isSettingsLocked}
                    onChange={() => {
                      // 3段階サイクル: false → true → null → false
                      const currentValue = scanSettings.writable;
                      if (currentValue === false) {
                        handleSettingChange("writable", true);
                      } else if (currentValue === true) {
                        handleSettingChange("writable", null);
                      } else {
                        handleSettingChange("writable", false);
                      }
                    }}
                    size="small"
                  />
                }
                label={
                  <ResponsiveTypography variant="caption">
                    Write
                  </ResponsiveTypography>
                }
                sx={{ margin: 0, minWidth: 0 }}
              />
              <ResponsiveFormControlLabel
                control={
                  <Checkbox
                    checked={scanSettings.executable === true}
                    indeterminate={scanSettings.executable === null}
                    disabled={isSettingsLocked}
                    onChange={() => {
                      // 3段階サイクル: false → true → null → false
                      const currentValue = scanSettings.executable;
                      if (currentValue === false) {
                        handleSettingChange("executable", true);
                      } else if (currentValue === true) {
                        handleSettingChange("executable", null);
                      } else {
                        handleSettingChange("executable", false);
                      }
                    }}
                    size="small"
                  />
                }
                label={
                  <ResponsiveTypography variant="caption">
                    Execute
                  </ResponsiveTypography>
                }
                sx={{ margin: 0, minWidth: 0 }}
              />
            </ResponsiveBox>
          </ScanSectionContent>
        </ScanSection>
        )}

        {/* Setting */}
        <ScanSection>
          <ScanSectionHeader>
            <ResponsiveTypography
              variant="subtitle2"
              sx={{
                fontWeight: 600,
                fontSize: "10px",
                color: "#4fc1ff",
                textTransform: "uppercase",
                letterSpacing: "0.5px",
              }}
            >
              Setting
            </ResponsiveTypography>
          </ScanSectionHeader>
          <ScanSectionContent>
            <ResponsiveFormControl fullWidth size="small">
              <InputLabel id="alignment-label">Alignment</InputLabel>
              <Select
                labelId="alignment-label"
                label="Alignment"
                value={scanSettings.alignment || 4}
                disabled={isSettingsLocked}
                onChange={(e) =>
                  handleSettingChange("alignment", Number(e.target.value))
                }
              >
                <MenuItem value={1}>1 (No alignment)</MenuItem>
                <MenuItem value={2}>2 bytes</MenuItem>
                <MenuItem value={4}>4 bytes</MenuItem>
                <MenuItem value={8}>8 bytes</MenuItem>
                <MenuItem value={16}>16 bytes</MenuItem>
              </Select>
            </ResponsiveFormControl>
          </ScanSectionContent>
        </ScanSection>

        {/* Scan Controls */}
        <ScanControls>
          <ResponsiveButton
            fullWidth
            variant={scanResults > 0 ? "outlined" : "contained"}
            startIcon={<Search />}
            onClick={() => onFirstScan?.()}
            disabled={
              isScanning ||
              scanResults > 0 || // Disable if any results exist (after lookup)
              // PTR mode: require at least 2 files with target addresses
              (scanSettings.searchMode === "ptr" && (
                !scanSettings.ptrMapFilePaths || 
                scanSettings.ptrMapFilePaths.length < 2 ||
                scanSettings.ptrMapFilePaths.some((f: { targetAddress?: string }) => !f.targetAddress)
              )) ||
              // YARA mode: require yaraRule
              (scanSettings.searchMode === "yara" && !(scanSettings.yaraRule || "").trim()) ||
              // Normal mode: require value for non-comparison types
              (scanSettings.searchMode === "normal" && needsValue &&
                !(scanSettings.value || "").trim() &&
                !isComparisonType) ||
              (scanSettings.scanMode === "regions" && !memoryRegionsLoaded)
            }
            color="primary"
          >
            Look Up
          </ResponsiveButton>

          <ResponsiveButton
            fullWidth
            variant={scanResults > 0 ? "contained" : "outlined"}
            startIcon={<Search />}
            onClick={() => onNextScan?.()}
            disabled={
              isScanning ||
              !canNextScan ||
              // YARA mode doesn't support filtering
              scanSettings.searchMode === "yara" ||
              (needsValue &&
                !(scanSettings.value || "").trim() &&
                !isComparisonType) // Allow comparison types without value
            }
            color={scanResults > 0 ? "secondary" : "primary"}
          >
            Filter
          </ResponsiveButton>

          <ResponsiveButton
            fullWidth
            variant="text"
            startIcon={<Refresh />}
            onClick={() => {
              // Save current searchMode before reset
              const currentSearchMode = scanSettings.searchMode || "normal";
              // Reset settings to defaults but keep searchMode
              uiActions.setScanSettings({
                valueType: "int32",
                scanType: "exact",
                value: "",
                startAddress: "0x0",
                endAddress: "0x7FFFFFFFFFFF",
                scanMode: "manual",
                selectedRegions: [],
                alignment: 4,
                writable: true,
                executable: false,
                readable: true,
                doSuspend: false,
                searchMode: currentSearchMode, // Keep the current search mode
                yaraRule: "",
              });
              onClearScan?.();
              onNewScan?.();
            }}
            disabled={isScanning}
          >
            Clear
          </ResponsiveButton>
        </ScanControls>
      </SidebarContent>
    </SidebarContainer>
  );
};

```

`src/client/src/components/ScannerToolbar.tsx`:

```tsx
import React from "react";

interface ScannerToolbarProps {
  // Legacy props for backward compatibility
  visible?: boolean;
  onFirstScan?: () => void;
}

export const ScannerToolbar: React.FC<ScannerToolbarProps> = ({
  visible = true,
}) => {
  if (!visible) return null;

  return null;
};

```

`src/client/src/components/ServerConnection.tsx`:

```tsx
import { useState, useEffect, useCallback } from "react";
import {
  Typography,
  Button,
  TextField,
  Box,
  Chip,
  Paper,
  Stack,
  CircularProgress,
  Alert,
  AlertTitle,
  useMediaQuery,
} from "@mui/material";
import {
  PlayArrow as ConnectIcon,
  Stop as DisconnectIcon,
  CheckCircle as ConnectedIcon,
  Cancel as DisconnectedIcon,
  Warning as WarningIcon,
} from "@mui/icons-material";

import { getApiClient, ServerInfo, ProcessInfo } from "../lib/api";
import { useLocalStorage } from "../hooks/useLocalStorage";
import { useAppState } from "../hooks/useAppState";

// Legacy props for backward compatibility (optional)
interface ServerConnectionProps {
  onConnectionChange?: (
    connected: boolean,
    info?: ServerInfo,
    host?: string,
    port?: number
  ) => void;
}

export function ServerConnection({
  onConnectionChange,
}: ServerConnectionProps) {
  // Use global app state instead of props
  const { system, systemActions } = useAppState();
  const serverConnected = system.serverConnected;
  const serverInfo = system.serverInfo;
  const connectionHost = system.connectionHost;
  const connectionPort = system.connectionPort;

  const isCompactHeight = useMediaQuery("(max-height: 800px)");
  // Save connection settings to localStorage
  const [savedHost, setSavedHost] = useLocalStorage("server-host", "localhost");
  const [savedPort, setSavedPort] = useLocalStorage("server-port", 8080);

  const [host, setHost] = useState(savedHost || connectionHost || "localhost");
  const [port, setPort] = useState(
    (savedPort || connectionPort || 8080).toString()
  );
  const [connecting, setConnecting] = useState(false);
  const [lastError, setLastError] = useState<string | undefined>();
  const [authenticationStatus, setAuthenticationStatus] = useState<
    "none" | "authenticated" | "failed"
  >("none");
  const [connectionWarning, setConnectionWarning] = useState<
    string | undefined
  >();

  // Connection monitoring
  const handleConnectionStateChange = useCallback(
    (connected: boolean, error?: string) => {
      if (!connected && error) {
        console.warn("Connection state changed to disconnected:", error);
        setConnectionWarning(error);
        setAuthenticationStatus("none");

        // Update connection state
        systemActions.updateConnectionState(false, false);

        // Clear authentication info from Tauri state on disconnection
        systemActions.updateField("authToken", null);
        systemActions.updateField("serverSessionId", null);

        // Clear process and server info on disconnection (explicitly set to null)
        systemActions.updateField("attachedProcess", null);
        systemActions.updateField("attachedAppInfo", null);
        systemActions.updateField("serverInfo", null);
        systemActions.updateField("attachedModules", []);

        // Clear debug state on disconnection
        systemActions.updateField("isInBreakState", false);
        systemActions.updateField("currentThreadId", null);
        systemActions.updateField("currentBreakAddress", null);
        systemActions.updateField("currentRegisterData", {});

        // Clear breakpoints and watchpoints on disconnection
        systemActions.updateField("activeBreakpoints", []);
        systemActions.updateField("softwareBreakpoints", []);
        systemActions.updateField("watchpoints", []);

        console.log("All process and debug state cleared due to disconnection");

        // Notify parent component about disconnection (legacy support)
        onConnectionChange?.(false, undefined, undefined, undefined);
      }
    },
    [systemActions, onConnectionChange]
  );

  // Setup connection listener
  useEffect(() => {
    const client = getApiClient();
    client.addConnectionListener(handleConnectionStateChange);

    return () => {
      client.removeConnectionListener(handleConnectionStateChange);
    };
  }, [handleConnectionStateChange]);

  // Sync with global state and initialize from localStorage
  useEffect(() => {
    console.log("[ServerConnection] Syncing state:", {
      connectionHost,
      connectionPort,
      savedHost,
      savedPort,
    });

    // Sync UI state with global state (global store should be initialized)
    if (connectionHost) {
      console.log(
        "[ServerConnection] Using connectionHost from global state:",
        connectionHost
      );
      setHost(connectionHost);
    } else if (savedHost) {
      // Fallback to localStorage if global store is not yet initialized
      console.log(
        "[ServerConnection] Using savedHost from localStorage:",
        savedHost
      );
      setHost(savedHost);
    }

    if (connectionPort) {
      console.log(
        "[ServerConnection] Using connectionPort from global state:",
        connectionPort
      );
      setPort(connectionPort.toString());
    } else if (savedPort) {
      // Fallback to localStorage if global store is not yet initialized
      console.log(
        "[ServerConnection] Using savedPort from localStorage:",
        savedPort
      );
      setPort(savedPort.toString());
    }
  }, [connectionHost, connectionPort, savedHost, savedPort]);

  const handleConnect = async () => {
    setConnecting(true);
    setLastError(undefined);
    setConnectionWarning(undefined);
    setAuthenticationStatus("none");

    try {
      const client = getApiClient();
      client.updateConnection(host, parseInt(port));

      // Get server info directly (authentication is disabled on server)
      const serverInfo = await client.getServerInfo();

      // Save successful connection settings
      setSavedHost(host);
      setSavedPort(parseInt(port));

      // Update system state
      systemActions.updateConnectionState(true, true, host, parseInt(port));
      systemActions.updateProcessState(undefined, undefined, serverInfo);

      // Initialize debug state on new connection
      systemActions.updateField("isInBreakState", false);
      systemActions.updateField("currentThreadId", null);
      systemActions.updateField("currentBreakAddress", null);
      systemActions.updateField("currentRegisterData", {});
      systemActions.updateField("activeBreakpoints", []);
      systemActions.updateField("softwareBreakpoints", []);
      systemActions.updateField("watchpoints", []);
      
      // Check if WASM mode - auto-attach with virtual process
      if (serverInfo.mode === "wasm") {
        console.log("[ServerConnection] WASM mode detected - auto-attaching");
        
        // Create virtual process info for WASM
        const wasmProcess: ProcessInfo = {
          pid: 0, // Virtual PID for WASM
          processname: "WebAssembly"
        };
        
        // Auto-attach to WASM (server already handles this)
        try {
          await client.attachProcess(0);
        } catch (e) {
          console.warn("[ServerConnection] WASM attach call:", e);
          // Ignore - WASM mode doesn't need real attach
        }
        
        // Set attached process state
        systemActions.updateField("attachedProcess", wasmProcess);
        
        // Fetch modules (will return WASM module info)
        try {
          const modulesResponse = await client.enumerateModules();
          if (modulesResponse.success && modulesResponse.data?.modules) {
            systemActions.updateField("attachedModules", modulesResponse.data.modules);
          }
        } catch (e) {
          console.warn("[ServerConnection] Failed to get WASM modules:", e);
        }
        
        console.log("[ServerConnection] WASM auto-attach completed");
      } else {
        systemActions.updateField("attachedProcess", null);
        systemActions.updateField("attachedAppInfo", null);
        systemActions.updateField("attachedModules", []);
      }

      console.log("Debug state initialized on server connection");

      setAuthenticationStatus("authenticated");

      // Notify parent component (legacy support)
      onConnectionChange?.(true, serverInfo, host, parseInt(port));
    } catch (error) {
      console.error("Connection failed:", error);
      setLastError(
        error instanceof Error ? error.message : "Connection failed"
      );
      // Update system state
      systemActions.updateConnectionState(false, false);
      // Clear authentication info from Tauri state on connection failure
      systemActions.updateField("authToken", null);
      systemActions.updateField("serverSessionId", null);
      // Clear auth token in Rust backend
      try {
        const { invoke } = await import("@tauri-apps/api/core");
        await invoke("set_auth_token", { token: null });
      } catch (e) {
        console.warn("Failed to clear auth token in Rust backend:", e);
      }
      // Notify parent component (legacy support)
      onConnectionChange?.(false, undefined, undefined, undefined);
    } finally {
      setConnecting(false);
    }
  };

  const handleDisconnect = async () => {
    setConnectionWarning(undefined);
    setAuthenticationStatus("none");

    // Logout from server
    try {
      const client = getApiClient();
      await client.logout();
    } catch (error) {
      console.warn("Logout failed:", error);
    }

    // Clear auth token in Rust backend
    try {
      const { invoke } = await import("@tauri-apps/api/core");
      await invoke("set_auth_token", { token: null });
    } catch (e) {
      console.warn("Failed to clear auth token in Rust backend:", e);
    }

    // Update connection state
    systemActions.updateConnectionState(false, false);

    // Clear authentication info from Tauri state
    systemActions.updateField("authToken", null);
    systemActions.updateField("serverSessionId", null);

    // Clear process and server info (explicitly set to null)
    systemActions.updateField("attachedProcess", null);
    systemActions.updateField("attachedAppInfo", null);
    systemActions.updateField("serverInfo", null);
    systemActions.updateField("attachedModules", []);

    // Clear debug state
    systemActions.updateField("isInBreakState", false);
    systemActions.updateField("currentThreadId", null);
    systemActions.updateField("currentBreakAddress", null);
    systemActions.updateField("currentRegisterData", {});

    // Clear breakpoints and watchpoints
    systemActions.updateField("activeBreakpoints", []);
    systemActions.updateField("softwareBreakpoints", []);
    systemActions.updateField("watchpoints", []);

    console.log("All process and debug state cleared from Tauri state");

    // Notify parent component (legacy support)
    onConnectionChange?.(false, undefined, undefined, undefined);
  };

  return (
    <Paper
      sx={{
        p: isCompactHeight ? 1.5 : 2,
        border: "1px solid",
        borderColor: "divider",
        backgroundColor: "background.paper",
        maxWidth: "50%",
      }}
    >
      <Stack spacing={isCompactHeight ? 1.5 : 2}>
        <Typography
          variant="subtitle1"
          sx={{
            fontSize: isCompactHeight ? "11px" : "12px",
            fontWeight: 600,
            color: "primary.main",
          }}
        >
          Server Connection
        </Typography>

        {/* Connection Form */}
        <Stack direction="row" spacing={1} alignItems="center">
          <TextField
            label="Host"
            value={host}
            onChange={(e) => setHost(e.target.value)}
            disabled={serverConnected || connecting}
            size="small"
            sx={{
              minWidth: 120,
              "& .MuiInputLabel-root": {
                fontSize: isCompactHeight ? "10px" : "11px",
              },
              "& .MuiInputBase-input": {
                fontSize: isCompactHeight ? "10px" : "11px",
              },
              ...(isCompactHeight && {
                "& .MuiInputBase-root": {
                  minHeight: "20px",
                  fontSize: "11px",
                },
                "& .MuiInputBase-input": {
                  paddingTop: "4px",
                  paddingBottom: "4px",
                  fontSize: "11px",
                },
                "& .MuiInputLabel-root": {
                  fontSize: "11px",
                },
              }),
            }}
          />
          <TextField
            label="Port"
            value={port}
            onChange={(e) => setPort(e.target.value)}
            disabled={serverConnected || connecting}
            size="small"
            sx={{
              minWidth: 80,
              "& .MuiInputLabel-root": {
                fontSize: isCompactHeight ? "10px" : "11px",
              },
              "& .MuiInputBase-input": {
                fontSize: isCompactHeight ? "10px" : "11px",
              },
              ...(isCompactHeight && {
                "& .MuiInputBase-root": {
                  minHeight: "20px",
                  fontSize: "11px",
                },
                "& .MuiInputBase-input": {
                  paddingTop: "4px",
                  paddingBottom: "4px",
                  fontSize: "11px",
                },
                "& .MuiInputLabel-root": {
                  fontSize: "11px",
                },
              }),
            }}
          />
          {serverConnected ? (
            <Button
              variant="outlined"
              onClick={handleDisconnect}
              startIcon={<DisconnectIcon />}
              sx={{
                fontSize: isCompactHeight ? "10px" : "12px",
                py: isCompactHeight ? 0.25 : 0.5,
                px: 1,
                minWidth: "auto",
              }}
            >
              Disconnect
            </Button>
          ) : (
            <Button
              variant="contained"
              onClick={handleConnect}
              disabled={connecting}
              startIcon={
                connecting ? <CircularProgress size={16} /> : <ConnectIcon />
              }
              sx={{
                fontSize: isCompactHeight ? "10px" : "12px",
                py: isCompactHeight ? 0.25 : 0.5,
                px: 1,
                minWidth: "auto",
              }}
            >
              Connect
            </Button>
          )}
        </Stack>

        {/* Connection Status */}
        <Box display="flex" alignItems="center" gap={1} flexWrap="wrap">
          {serverConnected ? (
            <Chip
              icon={<ConnectedIcon />}
              label={`Connected to ${connectionHost}:${connectionPort}`}
              color="success"
              size="small"
              sx={{
                fontSize: isCompactHeight ? "10px" : "11px",
                height: isCompactHeight ? "18px" : "20px",
              }}
            />
          ) : (
            <Chip
              icon={<DisconnectedIcon />}
              label="Disconnected"
              color="error"
              size="small"
              sx={{
                fontSize: isCompactHeight ? "10px" : "11px",
                height: isCompactHeight ? "18px" : "20px",
              }}
            />
          )}

          {/* Authentication status */}
          {authenticationStatus === "authenticated" && (
            <Chip
              label="Authenticated"
              color="success"
              size="small"
              sx={{
                fontSize: isCompactHeight ? "9px" : "10px",
                height: isCompactHeight ? "16px" : "18px",
              }}
            />
          )}
          {authenticationStatus === "failed" && (
            <Chip
              icon={<WarningIcon />}
              label="Auth Failed"
              color="error"
              size="small"
              sx={{
                fontSize: isCompactHeight ? "9px" : "10px",
                height: isCompactHeight ? "16px" : "18px",
              }}
            />
          )}
        </Box>

        {/* Connection Warning */}
        {connectionWarning && (
          <Alert
            severity="warning"
            sx={{
              fontSize: isCompactHeight ? "10px" : "11px",
              py: isCompactHeight ? 0.5 : 1,
            }}
          >
            <AlertTitle sx={{ fontSize: isCompactHeight ? "10px" : "11px" }}>
              Connection Warning
            </AlertTitle>
            {connectionWarning}
          </Alert>
        )}

        {/* Server Info */}
        {serverConnected && serverInfo && (
          <Box
            sx={{
              mt: isCompactHeight ? 1 : 2,
              p: isCompactHeight ? 0.75 : 1,
              backgroundColor: "action.hover",
              borderRadius: 1,
              border: "1px solid",
              borderColor: "divider",
            }}
          >
            <Typography
              variant="body2"
              sx={{
                fontSize: isCompactHeight ? "10px" : "11px",
                fontWeight: 600,
                mb: isCompactHeight ? 0.5 : 1,
              }}
            >
              Server Information
            </Typography>
            <Stack spacing={isCompactHeight ? 0.25 : 0.5}>
              <Typography
                variant="body2"
                sx={{ fontSize: isCompactHeight ? "9px" : "10px" }}
              >
                Git Hash: {serverInfo.git_hash.substring(0, 8)}
              </Typography>
              <Typography
                variant="body2"
                sx={{ fontSize: isCompactHeight ? "9px" : "10px" }}
              >
                OS: {serverInfo.target_os}
              </Typography>
              <Typography
                variant="body2"
                sx={{ fontSize: isCompactHeight ? "9px" : "10px" }}
              >
                Arch: {serverInfo.arch}
              </Typography>
              <Typography
                variant="body2"
                sx={{ fontSize: isCompactHeight ? "9px" : "10px" }}
              >
                PID: {serverInfo.pid}
              </Typography>
              <Typography
                variant="body2"
                sx={{ fontSize: isCompactHeight ? "9px" : "10px" }}
              >
                Mode: {serverInfo.mode}
              </Typography>
              {serverInfo.build_timestamp && (
                <Typography
                  variant="body2"
                  sx={{ fontSize: isCompactHeight ? "9px" : "10px" }}
                >
                  Built:{" "}
                  {new Date(
                    serverInfo.build_timestamp * 1000
                  ).toLocaleDateString()}
                </Typography>
              )}
            </Stack>
          </Box>
        )}

        {/* Error Display */}
        {lastError && (
          <Alert
            severity="error"
            sx={{
              fontSize: isCompactHeight ? "10px" : "11px",
              py: isCompactHeight ? 0.5 : 1,
            }}
          >
            <AlertTitle sx={{ fontSize: isCompactHeight ? "10px" : "11px" }}>
              Connection Error
            </AlertTitle>
            {lastError}
          </Alert>
        )}
      </Stack>
    </Paper>
  );
}

```

`src/client/src/components/ServerContent.tsx`:

```tsx
import { useState } from "react";
import { Box, Typography, Paper, Tabs, Tab } from "@mui/material";
import {
  Link as AttachIcon,
  RocketLaunch as SpawnIcon,
} from "@mui/icons-material";
import { ServerConnection } from "./ServerConnection";
import { ProcessManager } from "./ProcessManager";
import { SpawnManager } from "./SpawnManager";
import { LinuxSpawnManager } from "./LinuxSpawnManager";
import { ModuleInfo } from "../lib/api";
import { useAppState } from "../hooks/useAppState";

interface ServerContentProps {
  // Legacy props for backward compatibility, but we'll use global store instead
  onModulesUpdate?: (modules: ModuleInfo[]) => void;
}

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function TabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`process-tabpanel-${index}`}
      aria-labelledby={`process-tab-${index}`}
      {...other}
    >
      {value === index && <Box>{children}</Box>}
    </div>
  );
}

export const ServerContent = ({ onModulesUpdate }: ServerContentProps) => {
  // Use new app state system instead of props
  const { system, systemActions } = useAppState();
  const serverConnected = system.serverConnected;
  const serverInfo = system.serverInfo;

  // Check if target OS is iOS
  const isIOS = serverInfo?.target_os?.toLowerCase() === "ios";

  // Check if target OS is Linux
  const isLinux = serverInfo?.target_os?.toLowerCase() === "linux";

  // Show Spawn tab for iOS and Linux
  const showSpawnTab = isIOS || isLinux;

  // Tab state: 0 = Attach, 1 = Spawn
  const [tabValue, setTabValue] = useState(0);

  const handleTabChange = (_event: React.SyntheticEvent, newValue: number) => {
    setTabValue(newValue);
  };

  // Callback handlers that update system state (legacy support)
  const handleServerConnectionChange = (
    connected: boolean,
    info?: any,
    host?: string,
    port?: number
  ) => {
    console.log("[ServerContent] Legacy connection change callback:", {
      connected,
      info,
      host,
      port,
    });
    // This is now handled by ServerConnection internally via systemActions
    // But we keep this for legacy compatibility if needed
  };

  const handleModulesUpdate = (modules: ModuleInfo[]) => {
    systemActions.updateModules(modules);
    // Also call the legacy callback if provided
    if (onModulesUpdate) {
      onModulesUpdate(modules);
    }
  };

  return (
    <Box
      sx={{
        gridArea: "main",
        gridColumn: "1 / -1",
        overflow: "auto",
        backgroundColor: "background.default",
        p: 2,
      }}
    >
      <Typography
        variant="h6"
        component="h1"
        gutterBottom
        sx={{ fontSize: "16px", fontWeight: 600 }}
      >
        Server Management
      </Typography>

      <Box sx={{ mb: 3 }}>
        <ServerConnection onConnectionChange={handleServerConnectionChange} />
      </Box>

      {serverConnected && (
        <Box sx={{ maxWidth: "50%" }}>
          {/* Section title for process management */}
          <Typography
            variant="subtitle1"
            sx={{
              fontSize: "16px",
              fontWeight: 600,
              mb: 1,
              color: "text.primary",
            }}
          >
            Process Management
          </Typography>

          {/* Chrome-style tabs at top-left of content */}
          <Box sx={{ display: "flex", alignItems: "flex-end" }}>
            <Tabs
              value={tabValue}
              onChange={handleTabChange}
              aria-label="process management tabs"
              sx={{
                minHeight: "28px",
                "& .MuiTabs-indicator": {
                  display: "none",
                },
                "& .MuiTab-root": {
                  minHeight: "28px",
                  minWidth: "80px",
                  fontSize: "11px",
                  textTransform: "none",
                  fontWeight: 500,
                  px: 1.5,
                  py: 0.5,
                  borderTopLeftRadius: "6px",
                  borderTopRightRadius: "6px",
                  border: "1px solid",
                  borderBottom: "none",
                  borderColor: "divider",
                  backgroundColor: "action.hover",
                  color: "text.secondary",
                  marginRight: "2px",
                  "&.Mui-selected": {
                    backgroundColor: "background.paper",
                    color: "primary.main",
                    fontWeight: 600,
                  },
                },
              }}
            >
              <Tab
                icon={<AttachIcon sx={{ fontSize: "12px" }} />}
                iconPosition="start"
                label="Attach"
                id="process-tab-0"
                aria-controls="process-tabpanel-0"
                sx={{ gap: 0.5 }}
              />
              {showSpawnTab && (
                <Tab
                  icon={<SpawnIcon sx={{ fontSize: "12px" }} />}
                  iconPosition="start"
                  label="Spawn"
                  id="process-tab-1"
                  aria-controls="process-tabpanel-1"
                  sx={{ gap: 0.5 }}
                />
              )}
            </Tabs>
          </Box>

          {/* Content area with top border connecting to tabs */}
          <Box
            sx={{
              borderTop: "1px solid",
              borderColor: "divider",
              mt: "-1px",
            }}
          >
            <TabPanel value={tabValue} index={0}>
              <ProcessManager onModulesUpdate={handleModulesUpdate} />
            </TabPanel>
            {isIOS && (
              <TabPanel value={tabValue} index={1}>
                <SpawnManager onModulesUpdate={handleModulesUpdate} />
              </TabPanel>
            )}
            {isLinux && (
              <TabPanel value={tabValue} index={1}>
                <LinuxSpawnManager onModulesUpdate={handleModulesUpdate} />
              </TabPanel>
            )}
          </Box>
        </Box>
      )}

      {!serverConnected && (
        <Paper
          sx={{
            p: 3,
            textAlign: "center",
            mt: 3,
            backgroundColor: "background.paper",
          }}
        >
          <Typography
            variant="body1"
            color="text.secondary"
            sx={{ fontSize: "14px", fontWeight: 600 }}
          >
            Connect to a server to manage processes
          </Typography>
          <Typography
            variant="body2"
            color="text.secondary"
            sx={{ mt: 1, fontSize: "12px" }}
          >
            Enter the server IP address and port above to establish a
            connection.
          </Typography>
        </Paper>
      )}
    </Box>
  );
};

```

`src/client/src/components/SettingsContent.tsx`:

```tsx
import React, { useState, useCallback } from "react";
import {
  Box,
  Typography,
  Button,
  Paper,
  List,
  ListItem,
  ListItemText,
  ListItemSecondaryAction,
  Divider,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  Alert,
  Snackbar,
  Stack,
} from "@mui/material";
import {
  Delete as DeleteIcon,
  Storage as StorageIcon,
  Cached as CachedIcon,
  Settings,
} from "@mui/icons-material";
import { invoke } from "@tauri-apps/api/core";

// LocalStorage keys used by the app
const LOCALSTORAGE_KEYS = [
  "dynadbg_ghidra_path",
  "dynadbg_analyzed_libraries",
  "dynadbg_news_read_items",
  "dynadbg_license_agreed",
];

export const SettingsContent: React.FC = () => {
  const [confirmDialogOpen, setConfirmDialogOpen] = useState(false);
  const [deleteType, setDeleteType] = useState<
    "all" | "ghidra" | "localStorage"
  >("all");
  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [snackbarMessage, setSnackbarMessage] = useState("");
  const [snackbarSeverity, setSnackbarSeverity] = useState<"success" | "error">(
    "success"
  );

  const showSnackbar = useCallback(
    (message: string, severity: "success" | "error") => {
      setSnackbarMessage(message);
      setSnackbarSeverity(severity);
      setSnackbarOpen(true);
    },
    []
  );

  const handleOpenConfirmDialog = useCallback(
    (type: "all" | "ghidra" | "localStorage") => {
      setDeleteType(type);
      setConfirmDialogOpen(true);
    },
    []
  );

  const handleCloseConfirmDialog = useCallback(() => {
    setConfirmDialogOpen(false);
  }, []);

  const clearLocalStorage = useCallback(() => {
    try {
      LOCALSTORAGE_KEYS.forEach((key) => {
        localStorage.removeItem(key);
      });
      return true;
    } catch (e) {
      console.error("Failed to clear localStorage:", e);
      return false;
    }
  }, []);

  const clearGhidraCache = useCallback(async () => {
    try {
      // Clear Ghidra SQLite database cache
      await invoke("clear_ghidra_cache");
      return true;
    } catch (e) {
      console.error("Failed to clear Ghidra cache:", e);
      return false;
    }
  }, []);

  const handleConfirmDelete = useCallback(async () => {
    setConfirmDialogOpen(false);

    let success = true;
    let message = "";

    try {
      switch (deleteType) {
        case "localStorage":
          success = clearLocalStorage();
          message = success
            ? "LocalStorage cache cleared successfully"
            : "Failed to clear localStorage cache";
          break;
        case "ghidra":
          success = await clearGhidraCache();
          message = success
            ? "Ghidra analysis cache cleared successfully"
            : "Failed to clear Ghidra cache";
          break;
        case "all":
          const localStorageSuccess = clearLocalStorage();
          const ghidraSuccess = await clearGhidraCache();
          success = localStorageSuccess && ghidraSuccess;
          message = success
            ? "All caches cleared successfully"
            : "Some caches could not be cleared";
          break;
      }
    } catch (e) {
      success = false;
      message = `Error: ${e}`;
    }

    showSnackbar(message, success ? "success" : "error");
  }, [deleteType, clearLocalStorage, clearGhidraCache, showSnackbar]);

  const getDialogContent = useCallback(() => {
    switch (deleteType) {
      case "localStorage":
        return "This will clear all localStorage data including Ghidra paths and UI preferences. This action cannot be undone.";
      case "ghidra":
        return "This will clear all Ghidra analysis cache from the SQLite database, including decompiled code and function lists. This action cannot be undone.";
      case "all":
        return "This will clear ALL cached data including localStorage and Ghidra analysis cache. You will need to re-analyze libraries with Ghidra. This action cannot be undone.";
    }
  }, [deleteType]);

  return (
    <Box
      sx={{
        height: "100%",
        overflow: "auto",
        backgroundColor: "#0f0f0f",
        p: 4,
        "&::-webkit-scrollbar": {
          width: "8px",
        },
        "&::-webkit-scrollbar-track": {
          background: "#1a1a1a",
        },
        "&::-webkit-scrollbar-thumb": {
          background: "#3a3a3a",
          borderRadius: "4px",
          "&:hover": {
            background: "#4a4a4a",
          },
        },
      }}
    >
      {/* Header Section */}
      <Box
        sx={{
          mb: 4,
          textAlign: "center",
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
        }}
      >
        <Stack
          direction="row"
          justifyContent="center"
          alignItems="center"
          spacing={1.5}
          sx={{ mb: 1 }}
        >
          <Settings sx={{ fontSize: 32, color: "#3b82f6" }} />
          <Typography
            variant="h4"
            sx={{
              fontWeight: 700,
              background: "linear-gradient(135deg, #3b82f6, #8b5cf6)",
              backgroundClip: "text",
              WebkitBackgroundClip: "text",
              WebkitTextFillColor: "transparent",
            }}
          >
            Settings
          </Typography>
        </Stack>
      </Box>

      <Paper sx={{ mb: 3 }}>
        <Box sx={{ p: 2 }}>
          <Box sx={{ display: "flex", alignItems: "center", gap: 1, mb: 2 }}>
            <StorageIcon color="primary" />
            <Typography variant="h6">Cache Management</Typography>
          </Box>
          <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
            Clear cached data stored by the application. This includes Ghidra
            analysis results, decompiled code, and other temporary data.
          </Typography>
        </Box>
        <Divider />
        <List>
          <ListItem>
            <ListItemText
              primary="Clear LocalStorage Cache"
              secondary="Remove UI preferences, Ghidra paths, and other browser-stored data"
            />
            <ListItemSecondaryAction>
              <Button
                variant="outlined"
                color="warning"
                startIcon={<CachedIcon />}
                onClick={() => handleOpenConfirmDialog("localStorage")}
              >
                Clear
              </Button>
            </ListItemSecondaryAction>
          </ListItem>
          <Divider component="li" />
          <ListItem>
            <ListItemText
              primary="Clear Ghidra Analysis Cache"
              secondary="Remove all cached Ghidra analysis results, decompiled code, and function lists from SQLite database"
            />
            <ListItemSecondaryAction>
              <Button
                variant="outlined"
                color="warning"
                startIcon={<CachedIcon />}
                onClick={() => handleOpenConfirmDialog("ghidra")}
              >
                Clear
              </Button>
            </ListItemSecondaryAction>
          </ListItem>
          <Divider component="li" />
          <ListItem>
            <ListItemText
              primary="Clear All Caches"
              secondary="Remove all cached data (LocalStorage + Ghidra SQLite database)"
            />
            <ListItemSecondaryAction>
              <Button
                variant="contained"
                color="error"
                startIcon={<DeleteIcon />}
                onClick={() => handleOpenConfirmDialog("all")}
              >
                Clear All
              </Button>
            </ListItemSecondaryAction>
          </ListItem>
        </List>
      </Paper>

      {/* Confirmation Dialog */}
      <Dialog
        open={confirmDialogOpen}
        onClose={handleCloseConfirmDialog}
        aria-labelledby="confirm-dialog-title"
        aria-describedby="confirm-dialog-description"
      >
        <DialogTitle id="confirm-dialog-title">
          Confirm Cache Deletion
        </DialogTitle>
        <DialogContent>
          <DialogContentText id="confirm-dialog-description">
            {getDialogContent()}
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseConfirmDialog} color="inherit">
            Cancel
          </Button>
          <Button
            onClick={handleConfirmDelete}
            color="error"
            variant="contained"
          >
            Delete
          </Button>
        </DialogActions>
      </Dialog>

      {/* Snackbar for feedback */}
      <Snackbar
        open={snackbarOpen}
        autoHideDuration={4000}
        onClose={() => setSnackbarOpen(false)}
        anchorOrigin={{ vertical: "bottom", horizontal: "center" }}
      >
        <Alert
          onClose={() => setSnackbarOpen(false)}
          severity={snackbarSeverity}
          sx={{ width: "100%" }}
        >
          {snackbarMessage}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default SettingsContent;

```

`src/client/src/components/Sidebar.tsx`:

```tsx
import { useState, useEffect } from "react";
import {
  Box,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Divider,
  Typography,
  Paper,
  IconButton,
  Tooltip,
  Avatar,
  Stack,
} from "@mui/material";
import {
  Computer as ProcessIcon,
  Memory as MemoryIcon,
  Search as ScanIcon,
  BugReport as DebugIcon,
  Storage as ModulesIcon,
  Code as AssemblyIcon,
  Settings as SettingsIcon,
  ChevronLeft as CollapseIcon,
  ChevronRight as ExpandIcon,
  Favorite as SponsorIcon,
} from "@mui/icons-material";
import { openUrl } from "@tauri-apps/plugin-opener";

interface Sponsor {
  id: string;
  name: string;
  icon_url: string;
  url: string;
}

interface SponsorResponse {
  sponsors: Sponsor[];
}

interface SidebarProps {
  collapsed: boolean;
  onCollapsedChange: (collapsed: boolean) => void;
  onNavigate?: (section: string) => void;
  currentSection?: string;
  currentMode?: "debugger" | "server" | "scanner";
  activeFunction?: string;
  onFunctionClick?: (functionName: string, functionAddress?: string) => void;
}

export function Sidebar({
  collapsed,
  onCollapsedChange,
  onNavigate,
  currentSection = "processes",
}: SidebarProps) {
  const [sponsors, setSponsors] = useState<Sponsor[]>([]);

  // Fetch sponsors on mount
  useEffect(() => {
    const fetchSponsors = async () => {
      try {
        const response = await fetch(
          "https://sponsor.dynadbg.com/api/sponsors",
          {
            method: "GET",
            headers: {
              Accept: "application/json",
            },
          }
        );
        if (response.ok) {
          const data: SponsorResponse = await response.json();
          // Limit to 5 sponsors
          setSponsors(data.sponsors.slice(0, 5));
        }
      } catch (error) {
        console.log("Failed to fetch sponsors:", error);
        // Fallback to demo sponsors for testing
        setSponsors([]);
      }
    };
    fetchSponsors();
  }, []);

  const handleSponsorClick = async (url: string) => {
    try {
      await openUrl(url);
    } catch (error) {
      console.error("Failed to open sponsor URL:", error);
    }
  };

  const menuItems = [
    { id: "processes", label: "Processes", icon: <ProcessIcon /> },
    { id: "modules", label: "Modules", icon: <ModulesIcon /> },
    { id: "memory", label: "Memory", icon: <MemoryIcon /> },
    { id: "scanner", label: "Scanner", icon: <ScanIcon /> },
    { id: "debugger", label: "Debugger", icon: <DebugIcon /> },
    { id: "assembly", label: "Assembly", icon: <AssemblyIcon /> },
  ];

  const handleItemClick = (itemId: string) => {
    if (onNavigate) {
      onNavigate(itemId);
    }
  };

  return (
    <Paper
      sx={{
        width: collapsed ? 60 : 240,
        height: "100%",
        display: "flex",
        flexDirection: "column",
        borderRadius: 0,
        borderRight: "1px solid",
        borderColor: "divider",
        transition: "width 0.3s ease",
        overflow: "hidden",
      }}
    >
      {/* Header */}
      <Box
        sx={{
          flexShrink: 0,
          p: 1,
          display: "flex",
          alignItems: "center",
          justifyContent: collapsed ? "center" : "space-between",
          borderBottom: "1px solid",
          borderColor: "divider",
          minHeight: 48,
        }}
      >
        {!collapsed && (
          <Typography
            variant="subtitle2"
            sx={{
              fontSize: "12px",
              fontWeight: 600,
              color: "primary.main",
            }}
          >
            Debug Tools
          </Typography>
        )}
        <Tooltip title={collapsed ? "Expand sidebar" : "Collapse sidebar"}>
          <IconButton
            size="small"
            onClick={() => onCollapsedChange(!collapsed)}
            sx={{
              color: "text.secondary",
              "&:hover": { backgroundColor: "action.hover" },
            }}
          >
            {collapsed ? (
              <ExpandIcon sx={{ fontSize: "16px" }} />
            ) : (
              <CollapseIcon sx={{ fontSize: "16px" }} />
            )}
          </IconButton>
        </Tooltip>
      </Box>

      {/* Navigation */}
      <Box sx={{ flex: 1, overflow: "auto", minHeight: 0 }}>
        <List sx={{ p: 0 }}>
          {menuItems.map((item) => (
            <ListItem key={item.id} disablePadding>
              <Tooltip
                title={collapsed ? item.label : ""}
                placement="right"
                disableHoverListener={!collapsed}
              >
                <ListItemButton
                  selected={currentSection === item.id}
                  onClick={() => handleItemClick(item.id)}
                  sx={{
                    minHeight: 36,
                    px: collapsed ? 1 : 2,
                    py: 0.5,
                    "&.Mui-selected": {
                      backgroundColor: "primary.main",
                      color: "primary.contrastText",
                      "&:hover": {
                        backgroundColor: "primary.dark",
                      },
                      "& .MuiListItemIcon-root": {
                        color: "primary.contrastText",
                      },
                    },
                    "&:hover": {
                      backgroundColor: "action.hover",
                    },
                  }}
                >
                  <ListItemIcon
                    sx={{
                      minWidth: collapsed ? "auto" : 40,
                      justifyContent: "center",
                      "& .MuiSvgIcon-root": {
                        fontSize: "18px",
                      },
                    }}
                  >
                    {item.icon}
                  </ListItemIcon>
                  {!collapsed && (
                    <ListItemText
                      primary={item.label}
                      primaryTypographyProps={{
                        fontSize: "11px",
                        fontWeight: 500,
                      }}
                    />
                  )}
                </ListItemButton>
              </Tooltip>
            </ListItem>
          ))}
        </List>

        <Divider sx={{ my: 1 }} />

        {/* Settings */}
        <List sx={{ p: 0 }}>
          <ListItem disablePadding>
            <Tooltip
              title={collapsed ? "Settings" : ""}
              placement="right"
              disableHoverListener={!collapsed}
            >
              <ListItemButton
                onClick={() => handleItemClick("settings")}
                sx={{
                  minHeight: 36,
                  px: collapsed ? 1 : 2,
                  py: 0.5,
                  "&:hover": {
                    backgroundColor: "action.hover",
                  },
                }}
              >
                <ListItemIcon
                  sx={{
                    minWidth: collapsed ? "auto" : 40,
                    justifyContent: "center",
                    "& .MuiSvgIcon-root": {
                      fontSize: "18px",
                    },
                  }}
                >
                  <SettingsIcon />
                </ListItemIcon>
                {!collapsed && (
                  <ListItemText
                    primary="Settings"
                    primaryTypographyProps={{
                      fontSize: "11px",
                      fontWeight: 500,
                    }}
                  />
                )}
              </ListItemButton>
            </Tooltip>
          </ListItem>
        </List>
      </Box>

      {/* Sponsors Section */}
      {sponsors.length > 0 && (
        <Box
          sx={{
            flexShrink: 0,
            borderTop: "1px solid #374151",
            py: collapsed ? 0.5 : 1,
            px: collapsed ? 0.5 : 1,
          }}
        >
          {!collapsed && (
            <Typography
              variant="caption"
              sx={{
                display: "flex",
                alignItems: "center",
                gap: 0.5,
                fontSize: "9px",
                fontWeight: 600,
                color: "text.secondary",
                mb: 0.5,
                px: 1,
              }}
            >
              <SponsorIcon sx={{ fontSize: "12px", color: "error.main" }} />
              Sponsors
            </Typography>
          )}
          <Stack
            direction={collapsed ? "column" : "row"}
            spacing={0.5}
            sx={{
              flexWrap: "wrap",
              justifyContent: collapsed ? "center" : "flex-start",
              px: collapsed ? 0 : 0.5,
              gap: collapsed ? 0.5 : 0.5,
            }}
          >
            {sponsors.map((sponsor) => (
              <Tooltip key={sponsor.id} title={sponsor.name} placement="top">
                <IconButton
                  size="small"
                  onClick={() => handleSponsorClick(sponsor.url)}
                  sx={{
                    p: 0.25,
                    "&:hover": {
                      backgroundColor: "action.hover",
                      transform: "scale(1.1)",
                    },
                    transition: "transform 0.2s ease",
                  }}
                >
                  <Avatar
                    src={sponsor.icon_url}
                    alt={sponsor.name}
                    sx={{
                      width: collapsed ? 24 : 20,
                      height: collapsed ? 24 : 20,
                      border: "1px solid",
                      borderColor: "divider",
                    }}
                  />
                </IconButton>
              </Tooltip>
            ))}
          </Stack>
        </Box>
      )}
    </Paper>
  );
}

```

`src/client/src/components/SidebarPanel.tsx`:

```tsx
import React, { useState, useEffect } from "react";
import {
  Box,
  Typography,
  IconButton,
  Tooltip,
  Collapse,
  styled,
} from "@mui/material";
import {
  ExpandMore as ExpandMoreIcon,
  ExpandLess as ExpandLessIcon,
} from "@mui/icons-material";

interface SidebarPanelAction {
  icon: React.ReactNode;
  tooltip: string;
  onClick: () => void;
}

interface SidebarPanelProps {
  title: string;
  icon?: React.ComponentType;
  badge?: string;
  actions?: SidebarPanelAction[];
  defaultExpanded?: boolean;
  // Controlled mode props
  expanded?: boolean;
  onExpandedChange?: (expanded: boolean) => void;
  // Optional height control
  height?: number | string;
  minHeight?: number;
  children: React.ReactNode;
}

const PanelContainer = styled(Box)(() => ({
  borderBottom: "1px solid",
  borderColor: "#2d2d30",
  backgroundColor: "transparent",
}));

const PanelHeader = styled(Box)(() => ({
  display: "flex",
  alignItems: "center",
  padding: "4px 8px",
  backgroundColor: "#252526",
  borderBottom: "1px solid #2d2d30",
  cursor: "pointer",
  minHeight: "24px",
  "&:hover": {
    backgroundColor: "rgba(255, 255, 255, 0.03)",
  },
  "@media (max-height: 800px)": {
    padding: "3px 8px",
    minHeight: "20px",
  },
}));

const PanelTitle = styled(Typography)(() => ({
  color: "#4fc1ff",
  fontWeight: 600,
  fontSize: "10px",
  flex: 1,
  textTransform: "uppercase",
  letterSpacing: "0.5px",
  "@media (max-height: 800px)": {
    fontSize: "9px",
  },
}));

const PanelIcon = styled(Box)(() => ({
  color: "#4fc1ff",
  display: "flex",
  alignItems: "center",
  marginRight: "6px",
  "& .MuiSvgIcon-root": {
    fontSize: "12px",
    "@media (max-height: 800px)": {
      fontSize: "10px",
    },
  },
}));

const PanelBadge = styled(Typography)(() => ({
  backgroundColor: "rgba(79, 193, 255, 0.15)",
  color: "#4fc1ff",
  borderRadius: "4px",
  padding: "0px 4px",
  fontSize: "9px",
  fontWeight: 600,
  marginRight: "4px",
  "@media (max-height: 800px)": {
    fontSize: "8px",
    padding: "0px 3px",
  },
}));

const PanelActions = styled(Box)(() => ({
  display: "flex",
  alignItems: "center",
  gap: "2px",
  "& .MuiIconButton-root": {
    color: "#858585",
    padding: "2px",
    "&:hover": {
      color: "#4fc1ff",
    },
  },
}));

const PanelContent = styled(Box, {
  shouldForwardProp: (prop) => prop !== "panelHeight" && prop !== "minHeight",
})<{ panelHeight?: number | string; minHeight?: number }>(
  ({ panelHeight, minHeight }) => ({
    padding: "4px 8px",
    ...(panelHeight && {
      height:
        typeof panelHeight === "number" ? `${panelHeight}px` : panelHeight,
      overflow: "hidden",
    }),
    ...(minHeight && { minHeight: `${minHeight}px` }),
  })
);

const ExpandIcon = styled(IconButton)(() => ({
  color: "#858585",
  padding: "1px",
  "& .MuiSvgIcon-root": {
    fontSize: "14px",
    "@media (max-height: 800px)": {
      fontSize: "12px",
    },
  },
  "&:hover": {
    color: "#4fc1ff",
  },
}));

export default function SidebarPanel({
  title,
  icon: Icon,
  badge,
  actions = [],
  defaultExpanded = true,
  expanded: controlledExpanded,
  onExpandedChange,
  height,
  minHeight,
  children,
}: SidebarPanelProps) {
  const [internalExpanded, setInternalExpanded] = useState(defaultExpanded);

  // Use controlled or uncontrolled mode
  const isControlled = controlledExpanded !== undefined;
  const expanded = isControlled ? controlledExpanded : internalExpanded;

  // Sync internal state with controlled value when switching to controlled mode
  useEffect(() => {
    if (controlledExpanded !== undefined) {
      setInternalExpanded(controlledExpanded);
    }
  }, [controlledExpanded]);

  const handleToggleExpanded = () => {
    const newExpanded = !expanded;
    console.log(
      `SidebarPanel: Toggling ${title} panel from ${expanded} to ${newExpanded}`
    );
    if (isControlled && onExpandedChange) {
      onExpandedChange(newExpanded);
    } else {
      setInternalExpanded(newExpanded);
    }
  };

  return (
    <PanelContainer>
      <PanelHeader onClick={handleToggleExpanded}>
        {Icon && (
          <PanelIcon>
            <Icon />
          </PanelIcon>
        )}
        <PanelTitle>{title}</PanelTitle>
        {badge && <PanelBadge>{badge}</PanelBadge>}
        <PanelActions>
          {actions.map((action, index) => (
            <Tooltip key={index} title={action.tooltip} placement="top">
              <IconButton
                size="small"
                onClick={(e) => {
                  e.stopPropagation();
                  action.onClick();
                }}
              >
                {action.icon}
              </IconButton>
            </Tooltip>
          ))}
        </PanelActions>
        <ExpandIcon>
          {expanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
        </ExpandIcon>
      </PanelHeader>
      <Collapse in={expanded}>
        <PanelContent panelHeight={height} minHeight={minHeight}>
          {children}
        </PanelContent>
      </Collapse>
    </PanelContainer>
  );
}

```

`src/client/src/components/SpawnManager.tsx`:

```tsx
import { useState, useEffect, useCallback } from "react";
import {
  Typography,
  TextField,
  Box,
  IconButton,
  Tooltip,
  Paper,
  Stack,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  CircularProgress,
  useMediaQuery,
  Autocomplete,
} from "@mui/material";
import {
  Refresh as RefreshIcon,
  PlayArrow as SpawnIcon,
  Apps as AppsIcon,
  ArrowUpward as ArrowUpIcon,
  ArrowDownward as ArrowDownIcon,
} from "@mui/icons-material";

import {
  getApiClient,
  InstalledAppInfo,
  AppInfo,
  ModuleInfo,
} from "../lib/api";
import { useGlobalDebugLogger } from "../hooks/useGlobalDebugLogger";
import { useAppState } from "../hooks/useAppState";

// LocalStorage key for filter history
const SPAWN_FILTER_HISTORY_KEY = "spawn_manager_filter_history";
const MAX_HISTORY_ITEMS = 5;

interface SpawnManagerProps {
  onModulesUpdate?: (modules: ModuleInfo[]) => void;
}

export function SpawnManager({ onModulesUpdate }: SpawnManagerProps) {
  const { system, systemActions } = useAppState();
  const connected = system.serverConnected;
  const attachedProcess = system.attachedProcess;

  const isCompactHeight = useMediaQuery("(max-height: 800px)");
  const [apps, setApps] = useState<InstalledAppInfo[]>([]);
  const [filteredApps, setFilteredApps] = useState<InstalledAppInfo[]>([]);
  const [loading, setLoading] = useState(false);
  const [spawningBundleId, setSpawningBundleId] = useState<string | null>(null);
  const [nameFilter, setNameFilter] = useState("");
  const [sortOrder, setSortOrder] = useState<"asc" | "desc">("asc");
  const [filterHistory, setFilterHistory] = useState<string[]>([]);

  // Load filter history from localStorage on mount
  useEffect(() => {
    try {
      const saved = localStorage.getItem(SPAWN_FILTER_HISTORY_KEY);
      if (saved) {
        setFilterHistory(JSON.parse(saved));
      }
    } catch (e) {
      console.error("Failed to load filter history:", e);
    }
  }, []);

  // Save history to localStorage
  const saveFilterHistory = useCallback((history: string[]) => {
    try {
      localStorage.setItem(SPAWN_FILTER_HISTORY_KEY, JSON.stringify(history));
    } catch (e) {
      console.error("Failed to save filter history:", e);
    }
  }, []);

  // Add filter to history
  const addToFilterHistory = useCallback(
    (filter: string) => {
      if (!filter.trim()) return;
      setFilterHistory((prev) => {
        const filtered = prev.filter(
          (f) => f.toLowerCase() !== filter.toLowerCase()
        );
        const newHistory = [filter, ...filtered].slice(0, MAX_HISTORY_ITEMS);
        saveFilterHistory(newHistory);
        return newHistory;
      });
    },
    [saveFilterHistory]
  );

  const [appIcons, setAppIcons] = useState<Map<string, string>>(new Map());
  const [appRunningStatus, setAppRunningStatus] = useState<Map<string, number>>(
    new Map()
  );

  const { addLog, logInfo } = useGlobalDebugLogger();

  const loadApps = useCallback(async () => {
    if (!connected) return;

    setLoading(true);
    try {
      const client = getApiClient();
      const response = await client.getInstalledApps();

      if (response.success && response.data?.apps) {
        setApps(response.data.apps);
        // Load icons and running status for apps
        loadAppIcons(response.data.apps);
        loadAppRunningStatus(response.data.apps);
      } else {
        console.error("Failed to load apps:", response.message);
        setApps([]);
      }
    } catch (error) {
      console.error("Failed to load installed apps:", error);
      setApps([]);
    } finally {
      setLoading(false);
    }
  }, [connected]);

  const loadAppIcons = async (appList: InstalledAppInfo[]) => {
    const client = getApiClient();
    const newIcons = new Map<string, string>();

    // Load icons for first 20 apps to avoid overwhelming the backend
    const appsToLoad = appList.slice(0, 20);

    await Promise.allSettled(
      appsToLoad.map(async (app) => {
        try {
          const iconUrl = await client.getAppIcon(app.bundleIdentifier);
          if (iconUrl) {
            newIcons.set(app.bundleIdentifier, iconUrl);
          }
        } catch (error) {
          console.debug(
            `Failed to load icon for app ${app.bundleIdentifier}:`,
            error
          );
        }
      })
    );

    setAppIcons((prev) => new Map([...prev, ...newIcons]));
  };

  const loadAppRunningStatus = async (appList: InstalledAppInfo[]) => {
    const client = getApiClient();
    const statusMap = new Map<string, number>();

    await Promise.allSettled(
      appList.map(async (app) => {
        try {
          const response = await client.getAppRunningStatus(
            app.bundleIdentifier
          );
          if (response.success && response.data) {
            // Only store if app is running (pid > 0)
            if (response.data.running && response.data.pid > 0) {
              statusMap.set(app.bundleIdentifier, response.data.pid);
            }
          }
        } catch (error) {
          console.debug(
            `Failed to get running status for app ${app.bundleIdentifier}:`,
            error
          );
        }
      })
    );

    setAppRunningStatus(statusMap);
  };

  // Filter and sort apps
  useEffect(() => {
    let filtered = apps.filter(
      (app) =>
        app.displayName.toLowerCase().includes(nameFilter.toLowerCase()) ||
        app.bundleIdentifier.toLowerCase().includes(nameFilter.toLowerCase())
    );

    // Sort by display name
    filtered = filtered.sort((a, b) => {
      return sortOrder === "asc"
        ? a.displayName.localeCompare(b.displayName)
        : b.displayName.localeCompare(a.displayName);
    });

    setFilteredApps(filtered);
  }, [apps, nameFilter, sortOrder]);

  const handleSortToggle = () => {
    setSortOrder((prev) => (prev === "asc" ? "desc" : "asc"));
  };

  const handleSpawnApp = async (app: InstalledAppInfo) => {
    setSpawningBundleId(app.bundleIdentifier);
    try {
      const client = getApiClient();

      // If there's an existing attached process, kill it first
      if (attachedProcess) {
        logInfo(
          "SPAWN",
          `Terminating existing process: ${attachedProcess.processname} (PID: ${attachedProcess.pid})`
        );
        try {
          // Kill the existing process by PID
          await client.terminateApp(attachedProcess.pid.toString());
          // Clear the attached state
          systemActions.updateField("attachedProcess", null);
          systemActions.updateField("attachedAppInfo", null);
          systemActions.updateField("spawnSuspended", false);
          systemActions.updateField("attachedModules", []);
        } catch (killError) {
          addLog(
            "WARN",
            "SPAWN",
            `Failed to terminate existing process, continuing with spawn...`
          );
        }
      }

      const response = await client.spawnApp(app.bundleIdentifier, true);

      if (response.success && response.data?.success) {
        const pid = response.data.pid;

        logInfo(
          "SPAWN",
          `Successfully spawned app: ${app.displayName} (${app.bundleIdentifier}) with PID: ${pid}`
        );

        if (pid && pid > 0) {
          // Attach to the spawned process
          await client.attachProcess(pid);

          // Get additional process information
          const appInfoResponse = await client.getProcessInfo();
          const modulesResponse = await client.enumerateModules();

          const appInfo: AppInfo = appInfoResponse.data
            ? {
                ...appInfoResponse.data,
                pid: pid,
                bundleIdentifier: app.bundleIdentifier,
              }
            : {
                name: app.displayName,
                pid: pid,
                bundleIdentifier: app.bundleIdentifier,
              };

          logInfo(
            "PROCESS",
            `Successfully attached to spawned process: ${app.displayName} (PID: ${pid})`
          );

          // Update process state with spawnSuspended flag
          systemActions.updateProcessState(
            {
              pid: pid,
              processname: app.displayName,
            },
            appInfo
          );

          // Set spawnSuspended flag
          systemActions.updateField("spawnSuspended", true);

          // Update modules
          if (onModulesUpdate && modulesResponse.data?.modules) {
            onModulesUpdate(modulesResponse.data.modules);
          }

          // Sync signal configurations to server on attach (skip for iOS)
          // Default: catch=false, pass=false (suppress signals, like GDB)
          const targetOs = system.serverInfo?.target_os;
          if (targetOs !== "ios") {
            try {
              const defaultSignalConfigs = [
                { signal: 4, catch_signal: false, pass_signal: false }, // SIGILL
                { signal: 6, catch_signal: false, pass_signal: false }, // SIGABRT
                { signal: 7, catch_signal: false, pass_signal: false }, // SIGBUS
                { signal: 8, catch_signal: false, pass_signal: false }, // SIGFPE
                { signal: 11, catch_signal: false, pass_signal: false }, // SIGSEGV
              ];
              await client.setAllSignalConfigs(defaultSignalConfigs);
              logInfo(
                "SIGNALS",
                "Synced default signal configurations to server"
              );
            } catch (signalError) {
              console.error(
                "Failed to sync signal configurations:",
                signalError
              );
              addLog(
                "WARN",
                "SIGNALS",
                "Failed to sync signal configurations to server"
              );
            }
          }
        }

        if (response.data?.warning) {
          addLog("WARN", "SPAWN", response.data.warning);
        }

        // Update running status after spawn (PID changed)
        setAppRunningStatus((prev) => {
          const newMap = new Map(prev);
          if (response.data?.pid && response.data.pid > 0) {
            newMap.set(app.bundleIdentifier, response.data.pid);
          }
          return newMap;
        });
      } else {
        const errorMsg =
          response.data?.error || response.message || "Unknown error";
        addLog(
          "ERROR",
          "SPAWN",
          `Failed to spawn app: ${app.displayName} - ${errorMsg}`
        );
      }
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error";
      addLog(
        "ERROR",
        "SPAWN",
        `Failed to spawn app: ${app.displayName} - ${errorMessage}`
      );
    } finally {
      setSpawningBundleId(null);
    }
  };

  useEffect(() => {
    if (connected) {
      loadApps();
    } else {
      setApps([]);
      setFilteredApps([]);
      setNameFilter("");
    }
  }, [connected, loadApps]);

  return (
    <Paper
      sx={{
        p: isCompactHeight ? 1.5 : 2,
        border: "1px solid",
        borderColor: "divider",
        backgroundColor: "background.paper",
        borderTopLeftRadius: 0,
      }}
    >
      <Stack spacing={isCompactHeight ? 1.5 : 2}>
        <Box display="flex" justifyContent="space-between" alignItems="center">
          <Typography
            variant="subtitle1"
            sx={{
              display: "flex",
              alignItems: "center",
              gap: 1,
              fontSize: isCompactHeight ? "11px" : "12px",
              fontWeight: 600,
              color: "primary.main",
            }}
          >
            <AppsIcon sx={{ fontSize: isCompactHeight ? "14px" : "16px" }} />
            Spawn Manager
          </Typography>
          <Tooltip title="Refresh app list">
            <IconButton
              onClick={loadApps}
              disabled={!connected || loading}
              size="small"
              sx={{
                color: "primary.main",
                "&:hover": { backgroundColor: "action.hover" },
              }}
            >
              <RefreshIcon
                sx={{ fontSize: isCompactHeight ? "14px" : "16px" }}
              />
            </IconButton>
          </Tooltip>
        </Box>

        {/* Attached Process Info (Application Information) */}
        {attachedProcess && (
          <Paper
            sx={{
              p: isCompactHeight ? 1 : 1.5,
              backgroundColor: "action.hover",
              borderRadius: 1,
              border: "1px solid",
              borderColor: "divider",
            }}
          >
            <Typography
              variant="body2"
              sx={{
                fontSize: isCompactHeight ? "10px" : "11px",
                fontWeight: 600,
                mb: isCompactHeight ? 0.5 : 1,
              }}
            >
              Application Information
            </Typography>
            <Stack spacing={isCompactHeight ? 0.25 : 0.5}>
              <Typography
                variant="body2"
                sx={{ fontSize: isCompactHeight ? "9px" : "10px" }}
              >
                Name: {attachedProcess.processname}
              </Typography>
              <Typography
                variant="body2"
                sx={{ fontSize: isCompactHeight ? "9px" : "10px" }}
              >
                PID: {attachedProcess.pid}
              </Typography>
              {system.attachedAppInfo?.bundleIdentifier && (
                <Typography
                  variant="body2"
                  sx={{
                    fontSize: isCompactHeight ? "9px" : "10px",
                    wordBreak: "break-all",
                    fontFamily: "monospace",
                  }}
                >
                  Bundle ID: {system.attachedAppInfo.bundleIdentifier}
                </Typography>
              )}
              {system.attachedAppInfo && (
                <Typography
                  variant="body2"
                  sx={{
                    fontSize: isCompactHeight ? "9px" : "10px",
                    wordBreak: "break-all",
                    fontFamily: "monospace",
                  }}
                >
                  Path: {system.attachedAppInfo.name || "Unknown"}
                </Typography>
              )}
            </Stack>
          </Paper>
        )}

        {/* Filter and Controls */}
        {connected && (
          <Stack direction="row" spacing={1} alignItems="center">
            <Autocomplete
              freeSolo
              options={filterHistory}
              inputValue={nameFilter}
              onInputChange={(_, value) => setNameFilter(value)}
              onChange={(_, value) => {
                if (value) {
                  setNameFilter(value);
                }
              }}
              onKeyDown={(e) => {
                if (e.key === "Enter" && nameFilter.trim()) {
                  addToFilterHistory(nameFilter.trim());
                }
              }}
              PaperComponent={({ children, ...props }) => (
                <Paper {...props} sx={{ backgroundColor: "#2d2d2d" }}>
                  {children}
                </Paper>
              )}
              renderOption={(props, option) => {
                const { key, ...restProps } = props as any;
                return (
                  <Box
                    key={key}
                    component="li"
                    {...restProps}
                    onMouseDown={(e: React.MouseEvent) => {
                      e.preventDefault();
                      setNameFilter(option);
                    }}
                    sx={{
                      fontSize: "11px",
                      cursor: "pointer",
                      padding: "6px 12px",
                      "&:hover": { backgroundColor: "rgba(255,255,255,0.1)" },
                    }}
                  >
                    {option}
                  </Box>
                );
              }}
              renderInput={(params) => (
                <TextField
                  {...params}
                  label="Filter by name or bundle ID"
                  size="small"
                  sx={{
                    "& .MuiInputLabel-root": {
                      fontSize: isCompactHeight ? "10px" : "11px",
                    },
                    "& .MuiInputBase-input": {
                      fontSize: isCompactHeight ? "10px" : "11px",
                    },
                    ...(isCompactHeight && {
                      "& .MuiInputBase-root": {
                        minHeight: "20px",
                        fontSize: "11px",
                      },
                      "& .MuiInputBase-input": {
                        paddingTop: "4px",
                        paddingBottom: "4px",
                        fontSize: "11px",
                      },
                      "& .MuiInputLabel-root": {
                        fontSize: "11px",
                        transform: "translate(14px, 6px) scale(1)",
                        "&.MuiInputLabel-shrink": {
                          transform: "translate(14px, -6px) scale(0.75)",
                        },
                      },
                    }),
                  }}
                />
              )}
              sx={{ flex: 1 }}
            />
            <Tooltip
              title={`Sort by name (${sortOrder === "asc" ? "A-Z" : "Z-A"})`}
            >
              <IconButton
                onClick={handleSortToggle}
                size="small"
                sx={{
                  color: "primary.main",
                  "&:hover": { backgroundColor: "action.hover" },
                }}
              >
                {sortOrder === "asc" ? (
                  <ArrowUpIcon
                    sx={{ fontSize: isCompactHeight ? "14px" : "16px" }}
                  />
                ) : (
                  <ArrowDownIcon
                    sx={{ fontSize: isCompactHeight ? "14px" : "16px" }}
                  />
                )}
              </IconButton>
            </Tooltip>
          </Stack>
        )}

        {/* App List */}
        <TableContainer
          component={Paper}
          sx={{
            maxHeight: isCompactHeight ? 300 : 400,
            border: "1px solid",
            borderColor: "divider",
          }}
        >
          <Table stickyHeader size="small">
            <TableHead>
              <TableRow>
                <TableCell
                  sx={{
                    fontSize: isCompactHeight ? "10px" : "11px",
                    fontWeight: 600,
                    py: isCompactHeight ? 0.5 : 1,
                    width: "32px",
                  }}
                >
                  Icon
                </TableCell>
                <TableCell
                  sx={{
                    fontSize: isCompactHeight ? "10px" : "11px",
                    fontWeight: 600,
                    py: isCompactHeight ? 0.5 : 1,
                    width: "50px",
                  }}
                >
                  PID
                </TableCell>
                <TableCell
                  sx={{
                    fontSize: isCompactHeight ? "10px" : "11px",
                    fontWeight: 600,
                    py: isCompactHeight ? 0.5 : 1,
                    width: "100px",
                  }}
                >
                  App Name
                </TableCell>
                <TableCell
                  sx={{
                    fontSize: isCompactHeight ? "10px" : "11px",
                    fontWeight: 600,
                    py: isCompactHeight ? 0.5 : 1,
                    width: "140px",
                  }}
                >
                  Bundle ID
                </TableCell>
                <TableCell
                  align="right"
                  sx={{
                    fontSize: isCompactHeight ? "10px" : "11px",
                    fontWeight: 600,
                    py: isCompactHeight ? 0.5 : 1,
                  }}
                >
                  Spawn
                </TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {loading ? (
                <TableRow>
                  <TableCell colSpan={5} align="center" sx={{ py: 2 }}>
                    <CircularProgress size={24} />
                  </TableCell>
                </TableRow>
              ) : filteredApps.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={5} align="center" sx={{ py: 2 }}>
                    <Typography
                      variant="body2"
                      color="text.secondary"
                      sx={{ fontSize: isCompactHeight ? "10px" : "11px" }}
                    >
                      {apps.length === 0
                        ? "No apps found. Make sure server is running on iOS device."
                        : "No apps match the filter."}
                    </Typography>
                  </TableCell>
                </TableRow>
              ) : (
                filteredApps.map((app) => (
                  <TableRow
                    key={app.bundleIdentifier}
                    hover
                    sx={{ "&:hover": { backgroundColor: "action.hover" } }}
                  >
                    <TableCell
                      sx={{ py: isCompactHeight ? 0.5 : 1, width: "32px" }}
                    >
                      {appIcons.get(app.bundleIdentifier) ? (
                        <img
                          src={appIcons.get(app.bundleIdentifier)}
                          alt="App icon"
                          style={{
                            width: isCompactHeight ? "14px" : "16px",
                            height: isCompactHeight ? "14px" : "16px",
                            objectFit: "contain",
                            borderRadius: "3px",
                          }}
                        />
                      ) : (
                        <AppsIcon
                          sx={{
                            fontSize: isCompactHeight ? "14px" : "16px",
                            color: "text.secondary",
                          }}
                        />
                      )}
                    </TableCell>
                    <TableCell
                      sx={{
                        fontSize: isCompactHeight ? "10px" : "11px",
                        py: isCompactHeight ? 0.5 : 1,
                        width: "50px",
                        fontFamily: "monospace",
                        color: appRunningStatus.has(app.bundleIdentifier)
                          ? "success.main"
                          : "text.secondary",
                      }}
                    >
                      {appRunningStatus.has(app.bundleIdentifier)
                        ? appRunningStatus.get(app.bundleIdentifier)
                        : "-"}
                    </TableCell>
                    <TableCell
                      sx={{
                        fontSize: isCompactHeight ? "10px" : "11px",
                        py: isCompactHeight ? 0.5 : 1,
                        width: "100px",
                      }}
                    >
                      <Box sx={{ display: "flex", flexDirection: "column" }}>
                        <span>{app.displayName}</span>
                        {app.bundleVersion && (
                          <span style={{ color: "gray", fontSize: "8px" }}>
                            v{app.bundleVersion}
                          </span>
                        )}
                      </Box>
                    </TableCell>
                    <TableCell
                      sx={{
                        fontSize: isCompactHeight ? "9px" : "10px",
                        py: isCompactHeight ? 0.5 : 1,
                        fontFamily: "monospace",
                        color: "text.secondary",
                        width: "140px",
                      }}
                    >
                      {app.bundleIdentifier}
                    </TableCell>
                    <TableCell
                      align="right"
                      sx={{ py: isCompactHeight ? 0.5 : 1 }}
                    >
                      <Tooltip title="Spawn (suspended)">
                        <IconButton
                          size="small"
                          onClick={() => handleSpawnApp(app)}
                          disabled={spawningBundleId === app.bundleIdentifier}
                          sx={{
                            color: "success.main",
                            "&:hover": { backgroundColor: "action.hover" },
                            "&:disabled": { color: "text.disabled" },
                          }}
                        >
                          {spawningBundleId === app.bundleIdentifier ? (
                            <CircularProgress
                              size={isCompactHeight ? 12 : 14}
                            />
                          ) : (
                            <SpawnIcon
                              sx={{
                                fontSize: isCompactHeight ? "12px" : "14px",
                              }}
                            />
                          )}
                        </IconButton>
                      </Tooltip>
                    </TableCell>
                  </TableRow>
                ))
              )}
            </TableBody>
          </Table>
        </TableContainer>

        {!connected && (
          <Typography
            variant="body2"
            color="text.secondary"
            align="center"
            sx={{
              mt: 2,
              fontSize: isCompactHeight ? "10px" : "11px",
            }}
          >
            Connect to server to view installed apps
          </Typography>
        )}
      </Stack>
    </Paper>
  );
}

```

`src/client/src/components/StackView.tsx`:

```tsx
import React, { useState, useEffect, useCallback, useMemo } from "react";
import {
  Box,
  Typography,
  Paper,
  styled,
  IconButton,
  Tooltip,
} from "@mui/material";
import { ViewList as StackIcon, Refresh } from "@mui/icons-material";
import { getApiClient, ModuleInfo } from "../lib/api";
import { encodeAddressToLibraryExpression } from "../utils/addressEncoder";

// スタックエントリーのデータ型
interface StackEntry {
  address: string;
  dword: string; // DWORDに戻す
  value: string;
}

// Props interface
interface StackViewProps {
  spRegister?: string | null; // SPレジスタの値
  isInBreakState?: boolean; // ブレーク状態かどうか
  currentThreadId?: number | null; // 現在のスレッドID
  attachedModules?: ModuleInfo[]; // モジュール情報（library+offset表示用）
  onNavigateToAddress?: (address: string) => void; // アドレスへのナビゲーションハンドラー
  resolveFunctionName?: (libraryPath: string, offset: number) => string | null; // 関数名解決
}

// Styled components for Stack View
const StackContainer = styled(Box)(() => ({
  height: "100%",
  display: "flex",
  flexDirection: "column",
  backgroundColor: "#1e1e1e",
  position: "relative",
  flex: "1 1 40%", // スタックビューを40%の幅に
  minWidth: "450px", // 最小幅をさらに増やす
  borderLeft: "1px solid #2d2d30",
}));

const StackHeader = styled(Box)(() => ({
  display: "flex",
  alignItems: "center",
  gap: "8px",
  padding: "8px 12px",
  backgroundColor: "#252526",
  borderBottom: "1px solid #2d2d30",
  minHeight: "48px",
  height: "48px",
  "@media (max-height: 800px)": {
    padding: "4px 8px",
    minHeight: "36px",
    height: "36px",
    gap: "4px",
  },
}));

const StackDisplay = styled(Paper)(() => ({
  margin: "8px",
  backgroundColor: "#1a1a1a",
  border: "1px solid #2d2d30",
  borderRadius: "4px",
  display: "flex",
  flexDirection: "column",
  height: "calc(100% - 16px)",
  overflow: "hidden",
  "@media (max-height: 800px)": {
    margin: "4px",
    height: "calc(100% - 8px)",
  },
}));

const StackHeaderRow = styled(Box)(() => ({
  padding: "4px",
  borderBottom: "1px solid #2d2d30",
  backgroundColor: "#252526",
  position: "sticky",
  top: 0,
  zIndex: 1,
  "@media (max-height: 800px)": {
    padding: "2px",
  },
}));

const StackContent = styled(Box)(() => ({
  flex: 1,
  overflow: "auto",
  padding: "4px",
  "&::-webkit-scrollbar": {
    width: "8px",
  },
  "&::-webkit-scrollbar-track": {
    background: "#1e1e1e",
  },
  "&::-webkit-scrollbar-thumb": {
    background: "#424242",
    borderRadius: "4px",
  },
  "&::-webkit-scrollbar-thumb:hover": {
    background: "#5a5a5e",
  },
}));

const StackRow = styled(Box)(() => ({
  display: "flex",
  fontSize: "11px",
  fontFamily: "monospace",
  padding: "2px 8px",
  minHeight: "18px", // 高さを少し増やす
  borderBottom: "1px solid rgba(255, 255, 255, 0.05)",
  alignItems: "center", // 垂直方向の中央揃え
  "&:hover": {
    backgroundColor: "rgba(255, 255, 255, 0.05)",
  },
  "@media (max-height: 800px)": {
    fontSize: "9px",
    padding: "1px 4px",
    minHeight: "14px",
  },
}));

const StackAddressColumn = styled(Box)(() => ({
  width: "160px", // Address列をさらに広げる
  minWidth: "160px",
  color: "#4fc1ff",
  textAlign: "left",
  paddingRight: "16px",
  paddingLeft: "8px", // 8pxから16pxに変更してヘッダーと合わせる
  fontFamily: "monospace",
  fontSize: "11px",
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap",
  "@media (max-height: 800px)": {
    fontSize: "9px",
    width: "120px",
    minWidth: "120px",
    paddingRight: "8px",
    paddingLeft: "8px",
  },
}));

const StackDwordColumn = styled(Box)(() => ({
  width: "120px", // Dword列の幅を調整
  minWidth: "120px",
  color: "#dcdcaa",
  textAlign: "left",
  paddingRight: "16px",
  paddingLeft: "0px", // ヘッダーと一致
  fontFamily: "monospace",
  fontSize: "11px",
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap",
  "@media (max-height: 800px)": {
    fontSize: "9px",
    width: "90px",
    minWidth: "90px",
    paddingRight: "8px",
    paddingLeft: "0px",
  },
}));

const StackValueColumn = styled(Box)(() => ({
  width: "420px",
  minWidth: "420px",
  color: "#ce9178",
  textAlign: "left",
  paddingLeft: "0px", // ヘッダーと一致
  fontFamily: "monospace",
  fontSize: "11px",
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap",
  "@media (max-height: 800px)": {
    fontSize: "9px",
    width: "300px",
    minWidth: "300px",
    paddingLeft: "0px",
  },
}));

const StackValueHeaderColumn = styled(Box)(() => ({
  width: "420px",
  minWidth: "420px",
  color: "#ce9178",
  textAlign: "left",
  paddingLeft: "0px", // データ行と一致させる（StackValueColumnにはpaddingLeft未設定）
  fontFamily: "monospace",
  fontSize: "10px",
  fontWeight: 600,
  "@media (max-height: 800px)": {
    width: "300px",
    minWidth: "300px",
    paddingLeft: "0px",
  },
}));

export const StackView: React.FC<StackViewProps> = ({
  spRegister = null,
  isInBreakState = false,
  currentThreadId = null,
  attachedModules = [],
  onNavigateToAddress,
  resolveFunctionName,
}) => {
  const [stackData, setStackData] = useState<StackEntry[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const apiClient = getApiClient();

  // Compute library+offset expressions for stack values (with function name resolution)
  const stackValueDetails = useMemo(() => {
    const detailsMap = new Map<
      string,
      { libraryExpr: string; functionName?: string }
    >();
    if (!attachedModules || attachedModules.length === 0) {
      return detailsMap;
    }

    stackData.forEach((entry) => {
      // Skip NULL values
      if (entry.value === "NULL") return;

      // Parse value address
      const valueMatch = entry.value.match(/0x([0-9A-F]+)/i);
      if (!valueMatch) return;

      const valueNum = parseInt(valueMatch[1], 16);
      if (isNaN(valueNum)) return;

      // Try to encode to library+offset expression
      const libraryExpr = encodeAddressToLibraryExpression(
        valueNum,
        attachedModules,
        true // prefer short filename
      );

      if (libraryExpr) {
        // Try to resolve function name if resolver is available
        let functionName: string | undefined;
        if (resolveFunctionName) {
          // Find which module this address belongs to
          for (const mod of attachedModules) {
            const modBase = mod.base;
            const modSize = mod.size || 0;
            if (valueNum >= modBase && valueNum < modBase + modSize) {
              const offset = valueNum - modBase;
              const modulePath = mod.path || mod.modulename || mod.name || "";
              const resolved = resolveFunctionName(modulePath, offset);
              if (resolved) {
                functionName = resolved;
              }
              break;
            }
          }
        }
        detailsMap.set(entry.address, { libraryExpr, functionName });
      }
    });

    return detailsMap;
  }, [stackData, attachedModules, resolveFunctionName]);

  // スタックデータを読み取る関数
  const loadStackData = useCallback(async () => {
    if (!isInBreakState || !spRegister) {
      setStackData([]);
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      console.log(
        `Loading stack data for thread ${currentThreadId || "default"} with SP: ${spRegister}`
      );

      // SPレジスタの値をパース
      const spValue = parseInt(spRegister, 16);
      if (isNaN(spValue)) {
        throw new Error("Invalid SP register value");
      }

      // スタックを読み取り（21エントリー分、各8バイト）
      const stackSize = 21 * 8; // 168バイト
      const memoryData = await apiClient.readMemory(
        `0x${spValue.toString(16)}`,
        stackSize
      );

      // ArrayBufferをUint8Arrayに変換
      const bytes = new Uint8Array(memoryData);

      // 8バイトずつ処理してスタックエントリーを作成
      const entries: StackEntry[] = [];
      for (let i = 0; i < bytes.length; i += 8) {
        const address = `0x${(spValue + i).toString(16).padStart(16, "0").toUpperCase()}`;

        // 4バイト（DWORD）を読み取り（リトルエンディアン）
        let dwordValue = 0;
        for (let j = 0; j < 4 && i + j < bytes.length; j++) {
          dwordValue += bytes[i + j] * Math.pow(256, j);
        }

        // 8バイト（値）を読み取り（リトルエンディアン）
        let value = 0;
        for (let j = 0; j < 8 && i + j < bytes.length; j++) {
          value += bytes[i + j] * Math.pow(256, j);
        }

        const dword = `0x${dwordValue.toString(16).padStart(8, "0").toUpperCase()}`;

        // 値を解釈（prefixなし）
        let interpretation;
        if (value === 0) {
          interpretation = "NULL";
        } else {
          interpretation = `0x${value.toString(16).padStart(16, "0").toUpperCase()}`;
        }

        entries.push({
          address,
          dword,
          value: interpretation,
        });
      }

      setStackData(entries);
    } catch (err) {
      console.error("Failed to load stack data:", err);
      setError(
        err instanceof Error ? err.message : "Failed to load stack data"
      );
      setStackData([]);
    } finally {
      setIsLoading(false);
    }
  }, [isInBreakState, spRegister, apiClient, currentThreadId]);

  // ブレーク状態になったときにスタックデータを読み込む
  useEffect(() => {
    if (isInBreakState && spRegister) {
      loadStackData();
    } else {
      setStackData([]);
      setError(null);
    }
  }, [isInBreakState, spRegister, loadStackData]);

  // リフレッシュハンドラー
  const handleRefresh = useCallback(() => {
    loadStackData();
  }, [loadStackData]);

  return (
    <StackContainer>
      {/* Stack Header */}
      <StackHeader>
        <Box
          sx={{
            display: "flex",
            alignItems: "center",
            gap: 0.5,
            height: "100%",
          }}
        >
          <StackIcon sx={{ fontSize: "16px", color: "#4fc1ff" }} />
          <Typography
            variant="body2"
            sx={{
              fontSize: "12px",
              fontWeight: 600,
              color: "#4fc1ff",
              lineHeight: 1,
              "@media (max-height: 800px)": {
                fontSize: "10px",
              },
            }}
          >
            Stack
          </Typography>
        </Box>

        {/* リフレッシュボタン */}
        {isInBreakState && (
          <Tooltip title="Refresh stack data">
            <IconButton
              size="small"
              onClick={handleRefresh}
              disabled={isLoading}
              sx={{
                color: "#9cdcfe",
                "&:hover": { backgroundColor: "#2d2d30" },
                "&:disabled": { color: "#666" },
              }}
            >
              <Refresh fontSize="small" />
            </IconButton>
          </Tooltip>
        )}
      </StackHeader>

      {/* Stack Content */}
      <Box
        sx={{
          flex: 1,
          overflow: "hidden",
          display: "flex",
          flexDirection: "column",
        }}
      >
        <StackDisplay elevation={0}>
          {/* Fixed Header */}
          <StackHeaderRow>
            <Box
              sx={{
                display: "flex",
                fontSize: "10px",
                color: "#9b9b9b",
                fontFamily: "monospace",
                fontWeight: 600,
              }}
            >
              <Box
                sx={{
                  width: "160px",
                  minWidth: "160px",
                  paddingRight: "16px",
                  paddingLeft: "8px", // データ行と一致させる
                  textAlign: "left",
                  color: "#4fc1ff", // Addressに青色を追加
                  fontWeight: 600,
                  "@media (max-height: 800px)": {
                    width: "120px",
                    minWidth: "120px",
                    paddingRight: "8px",
                    paddingLeft: "8px",
                  },
                }}
              >
                Address
              </Box>
              <Box
                sx={{
                  width: "120px",
                  minWidth: "120px",
                  paddingRight: "16px",
                  paddingLeft: "0px", // データ行と一致させる（StackDwordColumnはpaddingLeft未設定）
                  textAlign: "left",
                  color: "#dcdcaa", // Dwordに黄色を追加
                  fontWeight: 600,
                  "@media (max-height: 800px)": {
                    width: "90px",
                    minWidth: "90px",
                    paddingRight: "8px",
                    paddingLeft: "0px",
                  },
                }}
              >
                Dword
              </Box>
              <StackValueHeaderColumn>Value</StackValueHeaderColumn>
            </Box>
          </StackHeaderRow>

          {/* Scrollable Stack Rows */}
          <StackContent>
            {isLoading ? (
              <Box
                sx={{ padding: "16px", textAlign: "center", color: "#9b9b9b" }}
              >
                <Typography variant="body2" sx={{ fontSize: "12px" }}>
                  Loading stack data...
                </Typography>
              </Box>
            ) : error ? (
              <Box
                sx={{ padding: "16px", textAlign: "center", color: "#f48771" }}
              >
                <Typography variant="body2" sx={{ fontSize: "12px" }}>
                  Error: {error}
                </Typography>
              </Box>
            ) : !isInBreakState || !spRegister ? (
              <Box
                sx={{ padding: "16px", textAlign: "center", color: "#9b9b9b" }}
              >
                <Typography variant="body2" sx={{ fontSize: "12px" }}>
                  {!isInBreakState
                    ? "Program must be paused to view stack"
                    : "SP register not available"}
                </Typography>
              </Box>
            ) : stackData.length === 0 ? (
              <Box
                sx={{ padding: "16px", textAlign: "center", color: "#9b9b9b" }}
              >
                <Typography variant="body2" sx={{ fontSize: "12px" }}>
                  No stack data available
                </Typography>
              </Box>
            ) : (
              stackData.map((row, index) => {
                const detail = stackValueDetails.get(row.address);
                return (
                  <StackRow key={`stack-${index}`}>
                    <StackAddressColumn>{row.address}</StackAddressColumn>
                    <StackDwordColumn>{row.dword}</StackDwordColumn>
                    <StackValueColumn>
                      {detail ? (
                        <>
                          {row.value}{" "}
                          <Box
                            component="span"
                            onClick={() => {
                              if (onNavigateToAddress) {
                                onNavigateToAddress(row.value);
                              }
                            }}
                            sx={{
                              color: "#4fc1ff",
                              cursor: "pointer",
                              textDecoration: "underline",
                              "&:hover": {
                                color: "#6fd8ff",
                              },
                            }}
                          >
                            ({detail.libraryExpr})
                          </Box>
                          {detail.functionName && (
                            <Box
                              component="span"
                              sx={{
                                color: "#dcdcaa",
                                ml: 0.5,
                              }}
                            >
                              [{detail.functionName}]
                            </Box>
                          )}
                        </>
                      ) : (
                        row.value
                      )}
                    </StackValueColumn>
                  </StackRow>
                );
              })
            )}
          </StackContent>
        </StackDisplay>
      </Box>
    </StackContainer>
  );
};

```

`src/client/src/components/StatePanel.tsx`:

```tsx
import React, { useMemo } from 'react';
import { Box, Typography, Paper } from '@mui/material';
import { useAppState } from '../hooks/useAppState';

// Utility function to truncate arrays to max 3 elements
const truncateArrays = (obj: any, maxArrayLength = 3): any => {
  if (Array.isArray(obj)) {
    if (obj.length <= maxArrayLength) {
      return obj.map(item => truncateArrays(item, maxArrayLength));
    }
    return [
      ...obj.slice(0, maxArrayLength).map(item => truncateArrays(item, maxArrayLength)),
      `...${obj.length - maxArrayLength} more items`
    ];
  } else if (obj && typeof obj === 'object' && obj.constructor === Object) {
    const result: any = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = truncateArrays(value, maxArrayLength);
    }
    return result;
  }
  return obj;
};

/**
 * State Panel Component - Displays full app state as formatted JSON
 * With sidebar support and array truncation
 */
export const StatePanel: React.FC = () => {
  // Get entire app state from new unified system
  const { system, ui } = useAppState();

  // Create formatted JSON with array truncation
  const formattedState = useMemo(() => {
    // Combine system and UI state for display
    const combinedState = {
      system: system,
      ui: ui,
    };
    
    // Apply array truncation to the entire state
    const truncatedState = truncateArrays(combinedState);
    
    return JSON.stringify(truncatedState, null, 2);
  }, [system, ui]);

  // Syntax highlighting function for JSON
  const syntaxHighlight = (json: string) => {
    return json.replace(
      /("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g,
      (match) => {
        let cls = 'json-number';
        if (/^"/.test(match)) {
          if (/:$/.test(match)) {
            cls = 'json-key';
          } else {
            cls = 'json-string';
          }
        } else if (/true|false/.test(match)) {
          cls = 'json-boolean';
        } else if (/null/.test(match)) {
          cls = 'json-null';
        }
        return `<span class="${cls}">${match}</span>`;
      }
    );
  };

  return (
    <Box
      sx={{
        height: '100%',
        overflow: 'hidden',
        display: 'flex',
        flexDirection: 'column',
        backgroundColor: 'background.default',
      }}
    >
      {/* Header */}
      <Box sx={{ p: 2, pb: 1 }}>
        <Typography variant="h4" gutterBottom color="primary">
          Global State Monitor
        </Typography>
        <Typography variant="body2" color="text.secondary">
          Real-time JSON view of all application state
        </Typography>
      </Box>

      {/* JSON Content */}
      <Box sx={{ flex: 1, overflow: 'auto', px: 2, pb: 2 }}>
        <Paper
          elevation={2}
          sx={{
            p: 3,
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            border: '1px solid #333',
            overflow: 'auto',
          }}
        >
          <pre
            style={{
              margin: 0,
              fontFamily: 'Monaco, Consolas, "Courier New", monospace',
              fontSize: '13px',
              lineHeight: '1.4',
              color: '#e0e0e0',
              whiteSpace: 'pre-wrap',
              wordBreak: 'break-word',
            }}
            dangerouslySetInnerHTML={{
              __html: syntaxHighlight(formattedState)
            }}
          />
        </Paper>
      </Box>

      {/* CSS for syntax highlighting */}
      <style>
        {`
          .json-key {
            color: #92c5f7;
            font-weight: bold;
          }
          .json-string {
            color: #ce9178;
          }
          .json-number {
            color: #b5cea8;
          }
          .json-boolean {
            color: #569cd6;
            font-weight: bold;
          }
          .json-null {
            color: #569cd6;
            font-weight: bold;
          }
        `}
      </style>
    </Box>
  );
};
```

`src/client/src/components/StatusBar.tsx`:

```tsx
import React from "react";
import { Box, Typography, Avatar } from "@mui/material";
import { StatusBar } from "../utils/constants";
import { ProcessInfo, AppInfo } from "../lib/api";

interface StatusBarComponentProps {
  currentMode:
    | "home"
    | "debugger"
    | "server"
    | "scanner"
    | "information"
    | "network"
    | "logs"
    | "state"
    | "tools";
  debuggerConnected?: boolean;
  serverConnected: boolean;
  connectionHost?: string;
  connectionPort?: number;
  lastHealthCheck?: { latency: number; timestamp: string } | null;
  attachedProcess?: ProcessInfo;
  attachedAppInfo?: AppInfo;
  currentBreakAddress?: string | null;
  isInBreakState?: boolean;
}

export const StatusBarComponent: React.FC<StatusBarComponentProps> = ({
  currentMode,
  serverConnected,
  connectionHost,
  connectionPort,
  lastHealthCheck,
  attachedProcess,
  attachedAppInfo,
  currentBreakAddress,
  isInBreakState,
}) => {
  const getConnectionStatus = () => {
    if (currentMode === "home") {
      if (serverConnected && attachedProcess) {
        return `Connected to ${attachedProcess.processname}`;
      } else if (serverConnected) {
        return `Connected to ${connectionHost}:${connectionPort}`;
      } else {
        return "Ready to Connect";
      }
    } else {
      if (serverConnected && connectionHost && connectionPort) {
        return `Connected to ${connectionHost}:${connectionPort}`;
      }
      return "Server Disconnected";
    }
  };

  const getConnectionStatusColor = () => {
    if (serverConnected) {
      return "#4CAF50"; // Green for connected
    } else {
      return "#f44336"; // Red for disconnected
    }
  };

  const getLatencyInfo = () => {
    if (serverConnected && lastHealthCheck) {
      return `${lastHealthCheck.latency}ms`;
    }
    return null;
  };

  const getProcessInfo = () => {
    if (attachedProcess) {
      const processName =
        attachedAppInfo?.name || attachedProcess.processname || "Unknown";
      const pid = attachedProcess.pid;
      // Hide PID for WASM mode (pid === 0)
      const isWasmMode = pid === 0;
      return { processName, pid, isWasmMode };
    }
    return null;
  };

  const getModeDisplayName = () => {
    switch (currentMode) {
      case "debugger":
        return "Debugger";
      case "scanner":
        return "Memory Scanner";
      case "server":
        return "Server Management";
      case "home":
        return "Home";
      case "information":
        return "Information";
      case "network":
        return "Network";
      case "logs":
        return "Logs";
      default:
        return "Unknown";
    }
  };

  const processInfo = getProcessInfo();

  return (
    <StatusBar>
      <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
        <Typography variant="body2" sx={{ fontSize: "11px" }}>
          Mode: {getModeDisplayName()}
        </Typography>
        <Typography
          variant="body2"
          sx={{
            fontSize: "11px",
            color: getConnectionStatusColor(),
            fontWeight: serverConnected ? "bold" : "normal",
          }}
        >
          Status: {getConnectionStatus()}
        </Typography>
        {processInfo && (
          <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
            {attachedAppInfo?.icon && (
              <Avatar
                src={`data:image/png;base64,${attachedAppInfo.icon}`}
                sx={{ width: 16, height: 16 }}
              />
            )}
            <Typography
              variant="body2"
              sx={{ fontSize: "11px", color: "#FF9800" }}
            >
              {processInfo.isWasmMode
                ? `Process: ${processInfo.processName}`
                : `Process: ${processInfo.processName} (PID: ${processInfo.pid})`}
            </Typography>
          </Box>
        )}
        {isInBreakState && currentBreakAddress ? (
          <Typography
            variant="body2"
            sx={{
              fontSize: "11px",
              color: "#4CAF50",
              fontWeight: "bold",
              backgroundColor: "rgba(76, 175, 80, 0.1)",
              padding: "2px 6px",
              borderRadius: "4px",
              border: "1px solid rgba(76, 175, 80, 0.3)",
            }}
          >
            🔴 BREAK: {currentBreakAddress}
          </Typography>
        ) : getLatencyInfo() ? (
          <Typography
            variant="body2"
            sx={{ fontSize: "11px", color: "#4CAF50" }}
          >
            Latency: {getLatencyInfo()}
          </Typography>
        ) : null}
      </Box>
    </StatusBar>
  );
};

```

`src/client/src/components/TerminalWindow.tsx`:

```tsx
import React, { useEffect, useRef, useState, useCallback } from "react";
import {
  Box,
  Paper,
  Typography,
  IconButton,
  Tooltip,
  Chip,
} from "@mui/material";
import {
  Close as CloseIcon,
  Refresh as RefreshIcon,
} from "@mui/icons-material";
import { Terminal } from "@xterm/xterm";
import { FitAddon } from "@xterm/addon-fit";
import "@xterm/xterm/css/xterm.css";
import { getApiClient, ApiClient } from "../lib/api";

interface TerminalWindowProps {
  ptyFd: number;
  pid: number;
  processName: string;
  onClose: () => void;
  serverUrl?: string; // Optional: for standalone window mode
}

export const TerminalWindow: React.FC<TerminalWindowProps> = ({
  ptyFd,
  pid,
  processName,
  onClose,
  serverUrl,
}) => {
  const [isConnected, setIsConnected] = useState(true);
  const terminalRef = useRef<HTMLDivElement>(null);
  const xtermRef = useRef<Terminal | null>(null);
  const fitAddonRef = useRef<FitAddon | null>(null);
  const pollingRef = useRef<number | null>(null);
  const apiClientRef = useRef<ApiClient | null>(null);

  // Get or create API client
  const getClient = useCallback(() => {
    if (apiClientRef.current) {
      return apiClientRef.current;
    }

    // Check if we have a server URL from props or sessionStorage (for standalone window)
    const url = serverUrl || sessionStorage.getItem("terminal_server_url");
    if (url) {
      apiClientRef.current = new ApiClient(url);
      return apiClientRef.current;
    }

    // Fall back to global client
    return getApiClient();
  }, [serverUrl]);

  // Initialize xterm.js
  useEffect(() => {
    if (!terminalRef.current || xtermRef.current) return;

    const term = new Terminal({
      cursorBlink: true,
      fontSize: 13,
      fontFamily: '"Consolas", "Monaco", "Courier New", monospace',
      cols: 360,
      rows: 150,
      scrollback: 10000,
      theme: {
        background: "#1e1e1e",
        foreground: "#d4d4d4",
        cursor: "#d4d4d4",
        cursorAccent: "#1e1e1e",
        selectionBackground: "#264f78",
        black: "#1e1e1e",
        red: "#f44747",
        green: "#6a9955",
        yellow: "#dcdcaa",
        blue: "#569cd6",
        magenta: "#c586c0",
        cyan: "#4ec9b0",
        white: "#d4d4d4",
        brightBlack: "#808080",
        brightRed: "#f44747",
        brightGreen: "#6a9955",
        brightYellow: "#dcdcaa",
        brightBlue: "#569cd6",
        brightMagenta: "#c586c0",
        brightCyan: "#4ec9b0",
        brightWhite: "#ffffff",
      },
      allowProposedApi: true,
    });

    const fitAddon = new FitAddon();
    term.loadAddon(fitAddon);

    term.open(terminalRef.current);

    // Function to fit terminal and notify PTY
    const doFit = () => {
      if (fitAddon && terminalRef.current) {
        try {
          fitAddon.fit();
          const { cols, rows } = term;
          console.log(`Terminal size: ${cols}x${rows}`);
          const client = getClient();
          // API expects (ptyFd, rows, cols)
          client.ptyResize?.(ptyFd, rows, cols).catch(console.error);
        } catch (e) {
          console.error("Fit error:", e);
        }
      }
    };

    // Delay fit to ensure container is properly sized
    setTimeout(doFit, 50);
    setTimeout(doFit, 200);
    setTimeout(doFit, 500);

    xtermRef.current = term;
    fitAddonRef.current = fitAddon;

    // Use ResizeObserver to detect container size changes
    const resizeObserver = new ResizeObserver(() => {
      doFit();
    });
    resizeObserver.observe(terminalRef.current);

    // Handle user input - send to PTY
    term.onData(async (data) => {
      if (!isConnected) return;
      try {
        const client = getClient();
        await client.ptyWrite(ptyFd, data);
      } catch (error) {
        console.error("Error writing to PTY:", error);
      }
    });

    // Handle resize
    const handleResize = () => {
      if (fitAddonRef.current) {
        fitAddonRef.current.fit();
        // Notify PTY of size change
        if (xtermRef.current) {
          const { cols, rows } = xtermRef.current;
          const client = getClient();
          // API expects (ptyFd, rows, cols)
          client.ptyResize?.(ptyFd, rows, cols).catch(console.error);
        }
      }
    };

    window.addEventListener("resize", handleResize);

    return () => {
      window.removeEventListener("resize", handleResize);
      resizeObserver.disconnect();
      term.dispose();
      xtermRef.current = null;
      fitAddonRef.current = null;
    };
  }, [ptyFd, getClient, isConnected]);

  // Poll for PTY output
  const pollOutput = useCallback(async () => {
    if (!isConnected || !xtermRef.current) return;

    try {
      const client = getClient();
      const response = await client.ptyRead(ptyFd);

      if (response.success && response.data) {
        const { data, bytes } = response.data;
        if (bytes > 0 && data) {
          // Decode base64 data and write to xterm
          try {
            const decoded = atob(data);
            xtermRef.current.write(decoded);
          } catch {
            // If not base64, use as-is
            xtermRef.current.write(data);
          }
        }
      }
    } catch (error) {
      console.error("Error reading PTY:", error);
      setIsConnected(false);
    }
  }, [ptyFd, isConnected, getClient]);

  // Start polling when component mounts
  useEffect(() => {
    const poll = () => {
      pollOutput();
      pollingRef.current = window.setTimeout(poll, 50); // Poll every 50ms for smoother updates
    };
    poll();

    return () => {
      if (pollingRef.current) {
        clearTimeout(pollingRef.current);
      }
    };
  }, [pollOutput]);

  // Handle close
  const handleClose = async () => {
    try {
      const client = getClient();
      await client.ptyClose(ptyFd);
    } catch (error) {
      console.error("Error closing PTY:", error);
    }
    onClose();
  };

  // Clear terminal
  const handleClear = () => {
    if (xtermRef.current) {
      xtermRef.current.clear();
    }
  };

  return (
    <Paper
      sx={{
        display: "flex",
        flexDirection: "column",
        height: "100%",
        backgroundColor: "#1e1e1e",
        overflow: "hidden",
      }}
    >
      {/* Header */}
      <Box
        sx={{
          display: "flex",
          alignItems: "center",
          justifyContent: "space-between",
          px: 1.5,
          py: 0.5,
          backgroundColor: "#2d2d30",
          borderBottom: "1px solid #3e3e42",
        }}
      >
        <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
          <Typography
            variant="body2"
            sx={{ fontWeight: 500, color: "#cccccc" }}
          >
            Terminal - {processName}
          </Typography>
          <Chip
            label={`PID: ${pid}`}
            size="small"
            sx={{
              height: 18,
              fontSize: "10px",
              backgroundColor: "#3c3c3c",
              color: "#cccccc",
            }}
          />
          <Chip
            label={`PTY: ${ptyFd}`}
            size="small"
            sx={{
              height: 18,
              fontSize: "10px",
              backgroundColor: "#3c3c3c",
              color: "#cccccc",
            }}
          />
          {!isConnected && (
            <Chip
              label="Disconnected"
              size="small"
              color="error"
              sx={{ height: 18, fontSize: "10px" }}
            />
          )}
        </Box>
        <Box sx={{ display: "flex", alignItems: "center", gap: 0.5 }}>
          <Tooltip title="Clear terminal">
            <IconButton size="small" onClick={handleClear}>
              <RefreshIcon sx={{ fontSize: 16, color: "#cccccc" }} />
            </IconButton>
          </Tooltip>
          <Tooltip title="Close terminal">
            <IconButton size="small" onClick={handleClose}>
              <CloseIcon sx={{ fontSize: 16, color: "#cccccc" }} />
            </IconButton>
          </Tooltip>
        </Box>
      </Box>

      {/* xterm.js terminal area */}
      <Box
        ref={terminalRef}
        sx={{
          flex: 1,
          width: "100%",
          minWidth: 0, // Important: allow flex item to shrink below content size
          height: "100%",
          overflow: "hidden",
          backgroundColor: "#1e1e1e",
          "& .xterm": {
            width: "100% !important",
            height: "100% !important",
            padding: 0,
          },
          "& .xterm-screen": {
            width: "100% !important",
          },
          "& .xterm-viewport": {
            width: "100% !important",
            overflowY: "auto !important",
            "&::-webkit-scrollbar": {
              width: "8px",
            },
            "&::-webkit-scrollbar-track": {
              background: "#1e1e1e",
            },
            "&::-webkit-scrollbar-thumb": {
              background: "#3e3e42",
              borderRadius: "4px",
            },
          },
        }}
      />

      {/* Status bar */}
      <Box
        sx={{
          px: 1,
          py: 0.25,
          backgroundColor: "#007acc",
          display: "flex",
          justifyContent: "space-between",
        }}
      >
        <Typography
          variant="caption"
          sx={{ color: "#ffffff", fontSize: "10px" }}
        >
          {isConnected ? "Connected" : "Disconnected"}
        </Typography>
        <Typography
          variant="caption"
          sx={{ color: "#ffffff", fontSize: "10px" }}
        >
          ncurses compatible
        </Typography>
      </Box>
    </Paper>
  );
};

export default TerminalWindow;

```

`src/client/src/components/ToolsContent.tsx`:

```tsx
import React from "react";
import { Box, Paper, Tabs, Tab } from "@mui/material";
import { Extension as GhidraIcon } from "@mui/icons-material";
import { GhidraAnalyzer } from "./GhidraAnalyzer";
import { useUIStore } from "../stores/uiStore";
import type { ServerInfo } from "../lib/api";

interface ToolsContentProps {
  serverConnected: boolean;
  serverInfo?: ServerInfo;
}

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function TabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;
  return (
    <Box
      role="tabpanel"
      hidden={value !== index}
      id={`tools-tabpanel-${index}`}
      aria-labelledby={`tools-tab-${index}`}
      sx={{
        flex: 1,
        display: value === index ? "flex" : "none",
        flexDirection: "column",
        overflow: "hidden",
        minHeight: 0,
      }}
      {...other}
    >
      {value === index && children}
    </Box>
  );
}

export const ToolsContent: React.FC<ToolsContentProps> = ({
  serverConnected,
  serverInfo,
}) => {
  const currentTab = useUIStore((state) => state.toolsState.currentTab);
  const setToolsTab = useUIStore((state) => state.actions.setToolsTab);

  const handleTabChange = (_event: React.SyntheticEvent, newValue: number) => {
    setToolsTab(newValue);
  };

  return (
    <Box sx={{ width: "100%", height: "100%", p: 2 }}>
      {/* Chrome-style tabs matching InformationContent */}
      <Box sx={{ display: "flex", alignItems: "flex-end" }}>
        <Tabs
          value={currentTab}
          onChange={handleTabChange}
          aria-label="Tools tabs"
          sx={{
            minHeight: "28px",
            "& .MuiTabs-indicator": {
              display: "none",
            },
            "& .MuiTab-root": {
              minHeight: "28px",
              minWidth: "80px",
              fontSize: "11px",
              textTransform: "none",
              fontWeight: 500,
              px: 1.5,
              py: 0.5,
              borderTopLeftRadius: "6px",
              borderTopRightRadius: "6px",
              border: "1px solid",
              borderBottom: "none",
              borderColor: "divider",
              backgroundColor: "action.hover",
              color: "text.secondary",
              marginRight: "2px",
              gap: 0.5,
              "&.Mui-selected": {
                backgroundColor: "background.paper",
                color: "primary.main",
                fontWeight: 600,
              },
            },
          }}
        >
          <Tab
            icon={<GhidraIcon sx={{ fontSize: 12 }} />}
            iconPosition="start"
            label="Ghidra"
            id="tools-tab-0"
            aria-controls="tools-tabpanel-0"
          />
        </Tabs>
      </Box>

      {/* Content Panel */}
      <Paper
        sx={{
          flex: 1,
          display: "flex",
          flexDirection: "column",
          backgroundColor: "background.paper",
          borderRadius: "0 4px 4px 4px",
          border: "1px solid",
          borderColor: "divider",
          overflow: "hidden",
          minHeight: 0,
          height: "calc(100% - 28px)",
        }}
      >
        {/* Tab Content */}
        <Box
          sx={{
            flex: 1,
            height: 0,
            display: "flex",
            flexDirection: "column",
            minHeight: 0,
            overflow: "hidden",
          }}
        >
          <TabPanel value={currentTab} index={0}>
            <GhidraAnalyzer
              serverConnected={serverConnected}
              targetOs={serverInfo?.target_os}
            />
          </TabPanel>
        </Box>
      </Paper>
    </Box>
  );
};

export default ToolsContent;

```

`src/client/src/components/TreeItem.tsx`:

```tsx
import React, { useState } from "react";
import {
  Box,
  Typography,
  Chip,
  Menu,
  MenuItem,
  ListItemIcon,
  ListItemText,
  styled,
  alpha,
} from "@mui/material";
import { FiberManualRecord as FiberManualRecordIcon } from "@mui/icons-material";

interface ChipData {
  label: string;
  color?:
    | "default"
    | "primary"
    | "secondary"
    | "error"
    | "info"
    | "success"
    | "warning";
  variant?: "filled" | "outlined";
}

interface ContextMenuItem {
  label?: string;
  icon?: React.ReactNode;
  onClick?: () => void;
  disabled?: boolean;
  divider?: boolean;
}

interface TreeItemProps {
  children: React.ReactNode;
  details?: string;
  icon?: React.ComponentType;
  color?: string;
  active?: boolean;
  highlighted?: boolean;
  onClick?: () => void;
  chips?: ChipData[];
  contextMenu?: ContextMenuItem[];
}

const TreeItemContainer = styled(Box, {
  shouldForwardProp: (prop) => prop !== "active" && prop !== "highlighted",
})<{ active?: boolean; highlighted?: boolean }>(({ active, highlighted }) => ({
  position: "relative",
  padding: "4px 10px 4px 24px",
  display: "flex",
  alignItems: "center",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  cursor: "pointer",
  backgroundColor: active
    ? alpha("#4fc1ff", 0.15)
    : highlighted
      ? alpha("#3c3c3c", 0.5)
      : "transparent",
  color: active ? "#4fc1ff" : "#d4d4d4",
  borderLeft: `2px solid ${active ? "#4fc1ff" : "transparent"}`,
  "&:hover": {
    backgroundColor: active ? alpha("#4fc1ff", 0.2) : "#3c3c3c",
  },
  transition:
    "background-color 0.15s ease, border-color 0.15s ease, color 0.15s ease",
}));

const TreeItemIconContainer = styled(Box)(() => ({
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  position: "absolute",
  left: "4px",
  top: "50%",
  transform: "translateY(-50%)",
  width: "16px",
  height: "16px",
}));

const TreeItemContent = styled(Box)(() => ({
  display: "flex",
  alignItems: "center",
  overflow: "hidden",
  textOverflow: "ellipsis",
  width: "100%",
}));

const TreeItemText = styled(Typography)(() => ({
  fontSize: "12px",
  overflow: "hidden",
  textOverflow: "ellipsis",
  flexGrow: 1,
}));

const TreeItemDetails = styled(Typography)(() => ({
  fontSize: "11px",
  color: "#858585",
  marginLeft: "8px",
  whiteSpace: "nowrap",
}));

const TreeItemChip = styled(Chip)(() => ({
  height: "16px",
  fontSize: "10px",
  marginLeft: "4px",
}));

export default function TreeItem({
  children,
  details,
  icon,
  color,
  active,
  highlighted,
  onClick,
  chips = [],
  contextMenu,
}: TreeItemProps) {
  const IconComponent = icon || FiberManualRecordIcon;

  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);

  const handleContextMenu = (event: React.MouseEvent<HTMLElement>) => {
    if (contextMenu) {
      event.preventDefault();
      setAnchorEl(event.currentTarget);
    }
  };

  const handleCloseMenu = () => {
    setAnchorEl(null);
  };

  const handleMenuAction = (action: ContextMenuItem) => {
    handleCloseMenu();
    action.onClick && action.onClick();
  };

  return (
    <>
      <TreeItemContainer
        active={active}
        highlighted={highlighted}
        onClick={onClick}
        onContextMenu={handleContextMenu}
      >
        <TreeItemIconContainer>
          <IconComponent
            fontSize="inherit"
            sx={{
              color: color || (active ? "#4fc1ff" : "#858585"),
              fontSize: "14px",
            }}
          />
        </TreeItemIconContainer>
        <TreeItemContent>
          <TreeItemText>{children}</TreeItemText>
          {details && <TreeItemDetails>{details}</TreeItemDetails>}
          {chips.map((chip, index) => (
            <TreeItemChip
              key={index}
              label={chip.label}
              size="small"
              color={chip.color || "default"}
              variant={chip.variant || "outlined"}
            />
          ))}
        </TreeItemContent>
      </TreeItemContainer>

      {contextMenu && (
        <Menu
          anchorEl={anchorEl}
          open={Boolean(anchorEl)}
          onClose={handleCloseMenu}
          MenuListProps={{
            dense: true,
          }}
          PaperProps={{
            sx: {
              backgroundColor: "#2d2d30",
              border: "1px solid",
              borderColor: "#464647",
              boxShadow: 4,
            },
          }}
        >
          {contextMenu.map((item, index) => (
            <MenuItem
              key={index}
              onClick={() => handleMenuAction(item)}
              disabled={item.disabled}
              divider={item.divider}
              sx={{ fontSize: 12 }}
            >
              {item.label && (
                <>
                  {item.icon && (
                    <ListItemIcon sx={{ minWidth: 32 }}>
                      {item.icon}
                    </ListItemIcon>
                  )}
                  <ListItemText primary={item.label} />
                </>
              )}
            </MenuItem>
          ))}
        </Menu>
      )}
    </>
  );
}

```

`src/client/src/components/VirtualizedTable.tsx`:

```tsx
import React, {
  useMemo,
  useState,
  useRef,
  useEffect,
  CSSProperties,
  useCallback,
  forwardRef,
  ReactElement,
} from "react";
import { Box, styled, TableSortLabel } from "@mui/material";
import { List, RowComponentProps } from "react-window";

// Column definition for the table
export interface ColumnDef<T> {
  key: string;
  label: string;
  width: number; // percentage (initial width)
  minWidth?: number; // minimum percentage width
  align?: "left" | "right" | "center";
  sortable?: boolean;
  render: (item: T, index: number) => React.ReactNode;
  getCellStyle?: (item: T) => CSSProperties;
}

// Sort state
export type SortDirection = "asc" | "desc";

interface VirtualizedTableProps<T> {
  data: T[];
  columns: ColumnDef<T>[];
  rowHeight?: number;
  maxHeight?: number;
  sortField?: string;
  sortDirection?: SortDirection;
  onSort?: (field: string) => void;
  onRowClick?: (item: T, index: number) => void;
  isRowActive?: (item: T) => boolean;
  getRowColor?: (item: T) => string | undefined;
  getRowKey: (item: T, index: number) => string;
  // Column width persistence
  columnWidths?: Record<string, number>;
  onColumnWidthChange?: (key: string, width: number) => void;
}

// Styled components
const TableWrapper = styled(Box)({
  backgroundColor: "#1a1a1a",
  borderRadius: "4px",
  margin: "0 4px 4px 4px",
  border: "1px solid #333",
  overflow: "hidden",
  "@media (max-height: 800px)": {
    margin: "0 2px 2px 2px",
    borderRadius: "3px",
  },
});

const HeaderRow = styled(Box)({
  display: "flex",
  backgroundColor: "#2d2d30",
  borderBottom: "2px solid #4fc1ff",
  height: "22px",
  "@media (max-height: 800px)": {
    height: "18px",
  },
});

const HeaderCell = styled(Box)({
  padding: "4px 8px",
  fontSize: "10px",
  color: "#4fc1ff",
  fontWeight: 600,
  textTransform: "uppercase",
  cursor: "pointer",
  userSelect: "none",
  display: "flex",
  alignItems: "center",
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap",
  position: "relative",
  "&:hover": {
    backgroundColor: "#3a3a3a",
  },
  "@media (max-height: 800px)": {
    padding: "2px 6px",
    fontSize: "9px",
  },
});

// Column resize handle
const ResizeHandle = styled(Box, {
  shouldForwardProp: (prop) => prop !== "isResizing",
})<{ isResizing?: boolean }>(({ isResizing }) => ({
  position: "absolute",
  right: 0,
  top: 0,
  bottom: 0,
  width: "6px",
  cursor: "col-resize",
  backgroundColor: isResizing ? "rgba(79, 193, 255, 0.6)" : "transparent",
  transition: "background-color 0.15s ease",
  "&:hover": {
    backgroundColor: "rgba(79, 193, 255, 0.4)",
  },
  zIndex: 1,
}));

const RowContainer = styled(Box, {
  shouldForwardProp: (prop) =>
    prop !== "isActive" && prop !== "isEven" && prop !== "rowColor",
})<{ isActive?: boolean; isEven?: boolean; rowColor?: string }>(
  ({ isActive, isEven }) => ({
    display: "flex",
    cursor: "pointer",
    backgroundColor: isActive
      ? "rgba(79, 193, 255, 0.22)"
      : isEven
        ? "rgba(255, 255, 255, 0.02)"
        : "transparent",
    borderLeft: isActive ? "3px solid #4fc1ff" : "3px solid transparent",
    transition: "background-color 0.1s ease",
    "&:hover": {
      backgroundColor: isActive
        ? "rgba(79, 193, 255, 0.28)"
        : "rgba(79, 193, 255, 0.1)",
    },
  })
);

const CellContainer = styled(Box)({
  padding: "3px 8px",
  fontSize: "11px",
  color: "#d4d4d4",
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap",
  borderBottom: "1px solid #2a2a2a",
  display: "flex",
  alignItems: "center",
  "@media (max-height: 800px)": {
    padding: "2px 6px",
    fontSize: "10px",
  },
});

// Row props interface for react-window v2
interface RowProps<T> {
  data: T[];
  columns: ColumnDef<T>[];
  columnWidths: Record<string, number>;
  onRowClick?: (item: T, index: number) => void;
  isRowActive?: (item: T) => boolean;
  getRowColor?: (item: T) => string | undefined;
  getRowKey: (item: T, index: number) => string;
}

// Create a row component factory for react-window v2
function createRowComponent<T>(): React.ForwardRefExoticComponent<
  RowComponentProps<RowProps<T>> & React.RefAttributes<HTMLDivElement>
> {
  const Component = forwardRef<HTMLDivElement, RowComponentProps<RowProps<T>>>(
    function VirtualizedTableRow(
      { index, style, ...rowProps },
      ref
    ): ReactElement {
      const {
        data,
        columns,
        columnWidths,
        onRowClick,
        isRowActive,
        getRowColor,
        getRowKey,
      } = rowProps;
      const item = data[index];
      const isActive = isRowActive ? isRowActive(item) : false;
      const rowColor = getRowColor ? getRowColor(item) : undefined;
      const isEven = index % 2 === 1;

      const handleClick = useCallback(() => {
        if (onRowClick) {
          onRowClick(item, index);
        }
      }, [onRowClick, item, index]);

      return (
        <RowContainer
          ref={ref}
          style={style}
          isActive={isActive}
          isEven={isEven}
          onClick={handleClick}
          key={getRowKey(item, index)}
        >
          {columns.map((column: ColumnDef<T>) => {
            const cellStyle = column.getCellStyle
              ? column.getCellStyle(item)
              : {};
            const width = columnWidths[column.key] ?? column.width;
            return (
              <CellContainer
                key={column.key}
                sx={{
                  width: `${width}%`,
                  justifyContent:
                    column.align === "right"
                      ? "flex-end"
                      : column.align === "center"
                        ? "center"
                        : "flex-start",
                  color: rowColor,
                  fontWeight: isActive ? 600 : 400,
                  ...cellStyle,
                }}
              >
                {column.render(item, index)}
              </CellContainer>
            );
          })}
        </RowContainer>
      );
    }
  );
  return Component;
}

// Main VirtualizedTable component
export function VirtualizedTable<T>({
  data,
  columns,
  rowHeight = 24,
  maxHeight = 280,
  sortField,
  sortDirection,
  onSort,
  onRowClick,
  isRowActive,
  getRowColor,
  getRowKey,
  columnWidths: externalColumnWidths,
  onColumnWidthChange,
}: VirtualizedTableProps<T>) {
  // Internal column widths state (used if no external state provided)
  const [internalColumnWidths, setInternalColumnWidths] = useState<
    Record<string, number>
  >(() => {
    const initial: Record<string, number> = {};
    columns.forEach((col) => {
      initial[col.key] = col.width;
    });
    return initial;
  });

  // Use external or internal column widths
  const columnWidths = externalColumnWidths ?? internalColumnWidths;

  // Column resize state
  const [resizingColumn, setResizingColumn] = useState<string | null>(null);
  const resizeStartRef = useRef<{ x: number; width: number; key: string }>({
    x: 0,
    width: 0,
    key: "",
  });
  const tableRef = useRef<HTMLDivElement>(null);

  // Handle column resize
  const handleResizeStart = useCallback(
    (e: React.MouseEvent, columnKey: string) => {
      e.preventDefault();
      e.stopPropagation();
      const currentWidth =
        columnWidths[columnKey] ??
        columns.find((c) => c.key === columnKey)?.width ??
        20;
      setResizingColumn(columnKey);
      resizeStartRef.current = {
        x: e.clientX,
        width: currentWidth,
        key: columnKey,
      };
    },
    [columnWidths, columns]
  );

  // Column resize effect
  useEffect(() => {
    if (!resizingColumn) return;

    const handleMouseMove = (e: MouseEvent) => {
      e.preventDefault();
      const tableWidth = tableRef.current?.clientWidth || 1;
      const deltaX = e.clientX - resizeStartRef.current.x;
      const deltaPercent = (deltaX / tableWidth) * 100;
      const column = columns.find((c) => c.key === resizingColumn);
      const minWidth = column?.minWidth ?? 10;
      const newWidth = Math.max(
        minWidth,
        Math.min(80, resizeStartRef.current.width + deltaPercent)
      );

      if (onColumnWidthChange) {
        onColumnWidthChange(resizingColumn, newWidth);
      } else {
        setInternalColumnWidths((prev) => ({
          ...prev,
          [resizingColumn]: newWidth,
        }));
      }
    };

    const handleMouseUp = () => {
      setResizingColumn(null);
    };

    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    document.body.style.cursor = "col-resize";
    document.body.style.userSelect = "none";

    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    };
  }, [resizingColumn, columns, onColumnWidthChange]);

  // Calculate actual list height - use full maxHeight to fill panel
  const listHeight = useMemo(() => {
    const contentHeight = data.length * rowHeight;
    const availableHeight = maxHeight - 22; // 22px for header
    // Always use at least the content height, but cap at available height
    return Math.min(contentHeight, availableHeight);
  }, [data.length, rowHeight, maxHeight]);

  // Create row component - needs to be stable
  const RowComponent = useMemo(() => createRowComponent<T>(), []);

  // Render header with resize handles
  const renderHeader = () => (
    <HeaderRow>
      {columns.map((column, index) => {
        const width = columnWidths[column.key] ?? column.width;
        const isLastColumn = index === columns.length - 1;
        return (
          <HeaderCell
            key={column.key}
            sx={{ width: `${width}%` }}
            onClick={() =>
              onSort && column.sortable !== false && onSort(column.key)
            }
          >
            {column.sortable !== false ? (
              <TableSortLabel
                active={sortField === column.key}
                direction={sortField === column.key ? sortDirection : "asc"}
                sx={{
                  color: "#4fc1ff",
                  "&:hover": { color: "#6dd0ff" },
                  "&.Mui-active": { color: "#4fc1ff" },
                  "& .MuiTableSortLabel-icon": {
                    color: "#4fc1ff !important",
                    fontSize: "12px",
                  },
                }}
              >
                {column.label}
              </TableSortLabel>
            ) : (
              column.label
            )}
            {/* Resize handle - not on last column */}
            {!isLastColumn && (
              <ResizeHandle
                isResizing={resizingColumn === column.key}
                onMouseDown={(e) => handleResizeStart(e, column.key)}
              />
            )}
          </HeaderCell>
        );
      })}
    </HeaderRow>
  );

  if (data.length === 0) {
    return null;
  }

  return (
    <TableWrapper ref={tableRef}>
      {renderHeader()}
      <List
        rowHeight={rowHeight}
        rowCount={data.length}
        rowComponent={RowComponent as any}
        rowProps={{
          data,
          columns,
          columnWidths,
          onRowClick,
          isRowActive,
          getRowColor,
          getRowKey,
        }}
        overscanCount={5}
        style={{
          height: listHeight,
          overflowX: "hidden",
        }}
      />
    </TableWrapper>
  );
}

export default VirtualizedTable;

```

`src/client/src/components/WatchpointExceptionWindow.tsx`:

```tsx
import React, { useState, useEffect, useCallback, useMemo } from "react";
import {
  Box,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Typography,
  Chip,
  AppBar,
  Toolbar,
  Card,
  CardContent,
  IconButton,
  Tooltip,
  Menu,
  MenuItem,
} from "@mui/material";
import { BugReport, PlayArrow, Pause } from "@mui/icons-material";
import { WatchpointInfo } from "../types";
import { useTauriExceptionStore } from "../hooks/useTauriExceptionStore";
import { encodeAddressToLibraryExpression } from "../utils/addressEncoder";
import { useAppState } from "../hooks/useAppState";

interface WatchpointExceptionWindowProps {
  watchpoint: WatchpointInfo;
  onClose: (watchpointId: string) => void;
}

interface ProcessedWatchpointException {
  index: number;
  count: number;
  address: string;
  bytecode: string;
  opcode: string;
  timestamp: Date;
}

export const WatchpointExceptionWindow: React.FC<
  WatchpointExceptionWindowProps
> = ({ watchpoint, onClose: _onClose }) => {
  const [exceptions, setExceptions] = useState<ProcessedWatchpointException[]>(
    []
  );
  const [error, setError] = useState<string | null>(null);
  // isMonitoring controls UI updates (exception collection continues even when false)
  const [isMonitoring, setIsMonitoring] = useState(true);

  // Context menu state
  const [contextMenu, setContextMenu] = useState<{
    mouseX: number;
    mouseY: number;
    exception: ProcessedWatchpointException | null;
  } | null>(null);

  // Use Tauri store (data collected by global exception handler)
  const {
    getWatchpointExceptions,
    clearWatchpointExceptions,
    exceptions: tauriExceptions,
  } = useTauriExceptionStore();

  // Get attached modules from app state
  const { system } = useAppState();
  const attachedModules = system.attachedModules || [];

  // Encode PC addresses to library+offset expressions
  const addressDetails = useMemo(() => {
    const detailsMap = new Map<string, string>();
    if (!attachedModules || attachedModules.length === 0) {
      return detailsMap;
    }

    exceptions.forEach((exception) => {
      // Parse address to numeric value
      const addressNum = parseInt(exception.address, 16);
      if (!isNaN(addressNum)) {
        // Try to encode to library+offset expression
        const libraryExpr = encodeAddressToLibraryExpression(
          addressNum,
          attachedModules,
          true // prefer short filename
        );
        if (libraryExpr) {
          detailsMap.set(exception.address, libraryExpr);
        }
      }
    });

    return detailsMap;
  }, [exceptions, attachedModules]);

  // Fetch and filter exceptions from Tauri store
  // Skip UI updates when isMonitoring is false
  const fetchExceptions = useCallback(async () => {
    // Skip UI updates when monitoring is OFF
    if (!isMonitoring) {
      return;
    }

    try {
      // Get watchpoint exceptions only
      const watchpointExceptions = await getWatchpointExceptions();

      // Filter exceptions related to this specific watchpoint
      const watchpointAddr =
        typeof watchpoint.address === "string"
          ? parseInt(watchpoint.address, 16)
          : watchpoint.address;

      const filteredExceptions = watchpointExceptions.filter((ex) => {
        const memoryAddr = ex.memory_address;
        if (!memoryAddr) return false;

        // Check if memory address is within watchpoint range
        return (
          memoryAddr >= watchpointAddr &&
          memoryAddr < watchpointAddr + watchpoint.size
        );
      });

      // Group by PC address and count
      const exceptionMap = new Map<string, ProcessedWatchpointException>();

      filteredExceptions.forEach((ex) => {
        const pcAddr = ex.address;
        if (exceptionMap.has(pcAddr)) {
          const existing = exceptionMap.get(pcAddr)!;
          existing.count += 1;
        } else {
          exceptionMap.set(pcAddr, {
            index: exceptionMap.size,
            count: 1,
            address: pcAddr,
            bytecode: ex.bytecode || "unknown",
            opcode: ex.opcode || "unknown",
            timestamp: new Date(ex.timestamp),
          });
        }
      });

      const groupedExceptions = Array.from(exceptionMap.values());
      setExceptions(groupedExceptions);
      setError(null);
    } catch (err) {
      console.error("Failed to fetch watchpoint exceptions:", err);
      setError("Failed to fetch exceptions from Tauri store");
    }
  }, [watchpoint, getWatchpointExceptions, isMonitoring]);

  // Context menu handlers
  const handleContextMenu = useCallback(
    (event: React.MouseEvent, exception: ProcessedWatchpointException) => {
      event.preventDefault();
      setContextMenu({
        mouseX: event.clientX,
        mouseY: event.clientY,
        exception,
      });
    },
    []
  );

  const handleCloseContextMenu = useCallback(() => {
    setContextMenu(null);
  }, []);

  const handleCopyAddress = useCallback(() => {
    if (contextMenu?.exception) {
      navigator.clipboard.writeText(contextMenu.exception.address);
    }
    handleCloseContextMenu();
  }, [contextMenu, handleCloseContextMenu]);

  const handleCopyDetail = useCallback(() => {
    if (contextMenu?.exception) {
      const detail = addressDetails.get(contextMenu.exception.address) || "-";
      navigator.clipboard.writeText(detail);
    }
    handleCloseContextMenu();
  }, [contextMenu, addressDetails, handleCloseContextMenu]);

  const handleCopyBytecode = useCallback(() => {
    if (contextMenu?.exception) {
      navigator.clipboard.writeText(contextMenu.exception.bytecode);
    }
    handleCloseContextMenu();
  }, [contextMenu, handleCloseContextMenu]);

  const handleCopyInstruction = useCallback(() => {
    if (contextMenu?.exception) {
      navigator.clipboard.writeText(contextMenu.exception.opcode);
    }
    handleCloseContextMenu();
  }, [contextMenu, handleCloseContextMenu]);

  // Clear old exceptions for this watchpoint when window opens
  useEffect(() => {
    const watchpointAddr =
      typeof watchpoint.address === "string"
        ? parseInt(watchpoint.address, 16)
        : watchpoint.address;

    // Clear old exceptions for this watchpoint when window opens (fresh start)
    clearWatchpointExceptions(watchpointAddr, watchpoint.size).then(() => {
      console.log(
        `Cleared old exceptions for watchpoint at ${watchpoint.address}`
      );
      // Fetch any new exceptions after clearing
      fetchExceptions();
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // Run only once on mount

  // Monitor Tauri events for exception updates
  useEffect(() => {
    // Poll for updates periodically
    const interval = setInterval(fetchExceptions, 250);

    return () => {
      clearInterval(interval);
    };
  }, [fetchExceptions]);

  // Also update when tauriExceptions changes
  useEffect(() => {
    fetchExceptions();
  }, [tauriExceptions, fetchExceptions]);

  return (
    <Box sx={{ height: "100vh", display: "flex", flexDirection: "column" }}>
      {/* App Bar */}
      <AppBar position="static" color="default" elevation={1}>
        <Toolbar variant="dense">
          <BugReport color="warning" sx={{ mr: 1 }} />
          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
            Watchpoint - {watchpoint.address}
          </Typography>
          <Chip
            label={isMonitoring ? "Monitoring" : "Paused"}
            color={isMonitoring ? "success" : "default"}
            size="small"
            sx={{ mr: 1 }}
          />
          <Tooltip
            title={isMonitoring ? "Pause UI Updates" : "Resume UI Updates"}
          >
            <IconButton
              size="small"
              onClick={() => setIsMonitoring(!isMonitoring)}
              color={isMonitoring ? "error" : "primary"}
            >
              {isMonitoring ? <Pause /> : <PlayArrow />}
            </IconButton>
          </Tooltip>
        </Toolbar>
      </AppBar>

      {/* Content */}
      <Box sx={{ flex: 1, overflow: "hidden", px: 2, pb: 2, py: 2 }}>
        {/* Watchpoint Info Card */}
        <Card sx={{ mb: 2 }}>
          <CardContent sx={{ py: 2 }}>
            <Typography variant="subtitle2" color="text.secondary" gutterBottom>
              Monitoring Watchpoint
            </Typography>
            <Box display="flex" gap={2} alignItems="center">
              <Typography variant="body2" fontFamily="monospace">
                Address: <strong>{watchpoint.address}</strong>
              </Typography>
              <Typography variant="body2">
                Size: <strong>{watchpoint.size} bytes</strong>
              </Typography>
              <Typography variant="body2">
                Access: <strong>{watchpoint.accessType.toUpperCase()}</strong>
              </Typography>
            </Box>
          </CardContent>
        </Card>

        {error && (
          <Typography color="error" sx={{ mb: 2 }}>
            {error}
          </Typography>
        )}

        <TableContainer component={Paper} sx={{ height: "calc(100% - 100px)" }}>
          <Table stickyHeader size="small">
            <TableHead>
              <TableRow>
                <TableCell>Index</TableCell>
                <TableCell>Count</TableCell>
                <TableCell>PC Address</TableCell>
                <TableCell>Detail</TableCell>
                <TableCell>Bytecode</TableCell>
                <TableCell>Opcode</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {exceptions.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={6} align="center">
                    <Typography variant="body2" color="text.secondary">
                      Monitoring for exceptions...
                    </Typography>
                  </TableCell>
                </TableRow>
              ) : (
                exceptions.map((exception) => (
                  <TableRow
                    key={exception.address}
                    hover
                    onContextMenu={(e) => handleContextMenu(e, exception)}
                  >
                    <TableCell>
                      <Typography variant="body2" fontFamily="monospace">
                        {exception.index}
                      </Typography>
                    </TableCell>
                    <TableCell>
                      <Typography
                        variant="body2"
                        fontFamily="monospace"
                        fontWeight="bold"
                        color={exception.count > 1 ? "warning.main" : "inherit"}
                      >
                        {exception.count}
                      </Typography>
                    </TableCell>
                    <TableCell>
                      <Typography
                        variant="body2"
                        fontFamily="monospace"
                        color="primary"
                      >
                        {exception.address}
                      </Typography>
                    </TableCell>
                    <TableCell>
                      <Typography
                        variant="body2"
                        fontFamily="monospace"
                        sx={{ color: "#90ee90" }}
                      >
                        {addressDetails.get(exception.address) || "-"}
                      </Typography>
                    </TableCell>
                    <TableCell>
                      <Typography
                        variant="body2"
                        fontFamily="monospace"
                        fontSize="0.8rem"
                      >
                        {exception.bytecode}
                      </Typography>
                    </TableCell>
                    <TableCell>
                      <Typography
                        variant="body2"
                        fontFamily="monospace"
                        fontWeight="bold"
                      >
                        {exception.opcode}
                      </Typography>
                    </TableCell>
                  </TableRow>
                ))
              )}
            </TableBody>
          </Table>
        </TableContainer>

        {/* Context Menu */}
        <Menu
          open={contextMenu !== null}
          onClose={handleCloseContextMenu}
          anchorReference="anchorPosition"
          anchorPosition={
            contextMenu !== null
              ? { top: contextMenu.mouseY, left: contextMenu.mouseX }
              : undefined
          }
        >
          <MenuItem onClick={handleCopyAddress}>Copy Address</MenuItem>
          <MenuItem onClick={handleCopyDetail}>Copy Detail</MenuItem>
          <MenuItem onClick={handleCopyBytecode}>Copy Bytecode</MenuItem>
          <MenuItem onClick={handleCopyInstruction}>Copy Instruction</MenuItem>
        </Menu>
      </Box>
    </Box>
  );
};

```

`src/client/src/contexts/TauriSystemStateContext.tsx`:

```tsx
import React, { createContext, useContext, ReactNode } from "react";
import { useTauriSystemState } from "../hooks/useTauriSystemState";
import type {
  TauriSystemState,
  SystemConnectionState,
  SystemProcessState,
  SystemDebugState,
} from "../hooks/useTauriSystemState";

interface TauriSystemStateContextValue {
  state: TauriSystemState | null;
  isLoading: boolean;
  error: string | null;

  loadState: () => Promise<void>;
  updateField: (field: string, value: any) => Promise<void>;
  updateState: (updates: Record<string, any>) => Promise<void>;

  updateConnectionState: (
    serverConnected: boolean,
    debuggerConnected: boolean,
    host?: string,
    port?: number
  ) => Promise<void>;
  updateProcessState: (
    attachedProcess?: SystemProcessState["attachedProcess"],
    attachedAppInfo?: SystemProcessState["attachedAppInfo"],
    serverInfo?: SystemProcessState["serverInfo"]
  ) => Promise<void>;
  updateDebugState: (
    isInBreakState?: boolean,
    currentThreadId?: number,
    currentBreakAddress?: string,
    registerData?: Record<string, string>
  ) => Promise<void>;
  addBreakpoint: (address: string, isSoftware?: boolean) => Promise<void>;
  removeBreakpoint: (address: string) => Promise<void>;
  addWatchpoint: (
    watchpoint: SystemDebugState["watchpoints"][0]
  ) => Promise<{ success: boolean; error?: string }>;
  removeWatchpoint: (watchpointId: string) => Promise<void>;
  updateModules: (
    modules: SystemProcessState["attachedModules"]
  ) => Promise<void>;

  isConnected: boolean | undefined;
  hasAttachedProcess: boolean;
  isInBreakState: boolean;
}

const TauriSystemStateContext =
  createContext<TauriSystemStateContextValue | null>(null);

interface TauriSystemStateProviderProps {
  children: ReactNode;
}

export const TauriSystemStateProvider: React.FC<
  TauriSystemStateProviderProps
> = ({ children }) => {
  const systemState = useTauriSystemState();

  return (
    <TauriSystemStateContext.Provider value={systemState}>
      {children}
    </TauriSystemStateContext.Provider>
  );
};

export const useTauriSystemStateContext = (): TauriSystemStateContextValue => {
  const context = useContext(TauriSystemStateContext);
  if (!context) {
    throw new Error(
      "useTauriSystemStateContext must be used within a TauriSystemStateProvider"
    );
  }
  return context;
};

export const useConnectionStateContext = () => {
  const { state, isLoading, isConnected } = useTauriSystemStateContext();

  return {
    connectionState: state
      ? ({
          serverConnected: state.serverConnected,
          debuggerConnected: state.debuggerConnected,
          connectionHost: state.connectionHost,
          connectionPort: state.connectionPort,
          authToken: state.authToken,
          serverSessionId: state.serverSessionId,
        } as SystemConnectionState)
      : null,
    isLoading,
    isConnected,
  };
};

export const useDebugStateContext = () => {
  const { state, isLoading, isInBreakState } = useTauriSystemStateContext();

  return {
    debugState: state
      ? ({
          isInBreakState: state.isInBreakState,
          currentThreadId: state.currentThreadId,
          currentBreakAddress: state.currentBreakAddress,
          currentRegisterData: state.currentRegisterData,
          activeBreakpoints: state.activeBreakpoints,
          watchpoints: state.watchpoints,
        } as SystemDebugState)
      : null,
    isLoading,
    isInBreakState,
    hasActiveBreakpoints: (state?.activeBreakpoints?.length ?? 0) > 0,
    hasActiveWatchpoints: (state?.watchpoints?.length ?? 0) > 0,
  };
};

export const useProcessStateContext = () => {
  const { state, isLoading, hasAttachedProcess } = useTauriSystemStateContext();

  return {
    processState: state
      ? ({
          attachedProcess: state.attachedProcess,
          serverInfo: state.serverInfo,
          attachedAppInfo: state.attachedAppInfo,
          attachedModules: state.attachedModules,
        } as SystemProcessState)
      : null,
    isLoading,
    hasAttachedProcess,
  };
};

```

`src/client/src/data/sampleData.ts`:

```ts
// Sample data for debugger sidebar

export const functionsData = [
  {
    name: 'main',
    address: '0x401000',
    size: 256,
    scope: 'Global',
    type: 'Function'
  },
  {
    name: 'init',
    address: '0x401200',
    size: 128,
    scope: 'Global',
    type: 'Function'
  },
  {
    name: 'cleanup',
    address: '0x401400',
    size: 64,
    scope: 'Local',
    type: 'Function'
  },
  {
    name: 'process_data',
    address: '0x401600',
    size: 512,
    scope: 'Global',
    type: 'Function'
  }
];

export const namesData = [
  {
    name: 'global_var',
    address: '0x402000',
    size: 4,
    type: 'Variable',
    flags: ['Global', 'RW']
  },
  {
    name: 'buffer',
    address: '0x402100',
    size: 1024,
    type: 'Variable',
    flags: ['Local', 'RW']
  },
  {
    name: 'counter',
    address: '0x402200',
    size: 4,
    type: 'Variable',
    flags: ['Static', 'RW']
  }
];

export const importsData = [
  {
    name: 'printf',
    module: 'libc.so.6',
    address: '0x403000',
    type: 'Import'
  },
  {
    name: 'malloc',
    module: 'libc.so.6',
    address: '0x403100',
    type: 'Import'
  },
  {
    name: 'free',
    module: 'libc.so.6',
    address: '0x403200',
    type: 'Import'
  }
];

export const structuresData = [
  {
    name: 'ProcessInfo',
    size: '32 bytes',
    fields: ['pid', 'name', 'status']
  },
  {
    name: 'ModuleInfo',
    size: '48 bytes',
    fields: ['base', 'size', 'name', 'path']
  },
  {
    name: 'MemoryRegion',
    size: '24 bytes',
    fields: ['start', 'end', 'protection']
  }
];

```

`src/client/src/hooks/useAppState.ts`:

```ts
import { useEffect, useMemo } from "react";
import { useTauriSystemStateSingleton } from "./useTauriSystemStateSingleton";
import { useUIStore } from "../stores/uiStore";

let isUIStateInitialized = false;

/**
 * Hook for managing UI store and Tauri system state
 */
export const useAppState = () => {
  const tauriSystem = useTauriSystemStateSingleton();

  const uiState = useUIStore();
  const uiActions = useUIStore((state) => state.actions);

  useEffect(() => {
    if (isUIStateInitialized) {
      return;
    }

    const restoreUIState = () => {
      try {
        const savedDebuggerState = localStorage.getItem("debugger-ui-state");
        if (savedDebuggerState) {
          const debuggerState = JSON.parse(savedDebuggerState);
          const { gotoAddress, ...stateToRestore } = debuggerState;
          uiActions.updateDebuggerState(stateToRestore);
        }

        const defaultScannerSettings = {
          valueType: "int32",
          scanType: "exact",
          value: "",
          startAddress: "0x0",
          endAddress: "0x7FFFFFFFFFFF",
          scanMode: "manual",
          selectedRegions: [],
          alignment: 4,
          writable: true,
          executable: false,
          readable: true,
          doSuspend: false,
        };
        uiActions.setScanSettings(defaultScannerSettings);

        const savedInformationState = localStorage.getItem(
          "information-ui-state"
        );
        if (savedInformationState) {
          const informationState = JSON.parse(savedInformationState);
          uiActions.updateInformationState(informationState);
        }

        const savedScanHistory = localStorage.getItem("scan-history");
        if (savedScanHistory) {
          const scanHistory = JSON.parse(savedScanHistory);
          uiActions.setScanHistory(scanHistory);
        }

        const savedBookmarks = localStorage.getItem("bookmarks");
        if (savedBookmarks) {
          const bookmarks = JSON.parse(savedBookmarks);
          uiActions.setBookmarks(bookmarks);
        }

        console.log("[AppState] UI state restored from localStorage");

        isUIStateInitialized = true;
      } catch (error) {
        console.error(
          "[AppState] Error restoring UI state from localStorage:",
          error
        );
        isUIStateInitialized = true;
      }
    };

    restoreUIState();
  }, [uiActions]);

  return {
    system: {
      serverConnected: tauriSystem.state?.serverConnected ?? false,
      debuggerConnected: tauriSystem.state?.debuggerConnected ?? false,
      connectionHost: tauriSystem.state?.connectionHost,
      connectionPort: tauriSystem.state?.connectionPort,
      isConnected: tauriSystem.isConnected,

      attachedProcess: tauriSystem.state?.attachedProcess,
      serverInfo: tauriSystem.state?.serverInfo,
      attachedAppInfo: tauriSystem.state?.attachedAppInfo,
      attachedModules: tauriSystem.state?.attachedModules ?? [],
      hasAttachedProcess: tauriSystem.hasAttachedProcess,
      spawnSuspended: tauriSystem.state?.spawnSuspended ?? false,

      isInBreakState: tauriSystem.state?.isInBreakState ?? false,
      currentThreadId: tauriSystem.state?.currentThreadId,
      currentBreakAddress: tauriSystem.state?.currentBreakAddress,
      currentRegisterData: tauriSystem.state?.currentRegisterData ?? {},
      activeBreakpoints: tauriSystem.state?.activeBreakpoints ?? [],
      softwareBreakpoints: tauriSystem.state?.softwareBreakpoints ?? [],
      watchpoints: tauriSystem.state?.watchpoints ?? [],

      lastUpdate: tauriSystem.state?.lastUpdate ?? 0,
      isLoading: tauriSystem.isLoading,
      error: tauriSystem.error,
    },

    ui: {
      currentMode: uiState.currentMode,
      sidebarWidth: uiState.sidebarWidth,
      debuggerSidebarWidth: uiState.debuggerSidebarWidth,
      scannerSidebarWidth: uiState.scannerSidebarWidth,
      showRegisters: uiState.showRegisters,
      showToolbar: uiState.showToolbar,

      debuggerState: uiState.debuggerState,

      debuggerSidebarCache: uiState.debuggerSidebarCache,

      scannerState: uiState.scannerState,
      scanHistory: uiState.scanHistory,
      bookmarks: uiState.bookmarks,

      informationState: uiState.informationState,

      lastUpdate: uiState.lastUpdate,
    },

    systemActions: useMemo(
      () => ({
        updateConnectionState: tauriSystem.updateConnectionState,
        updateProcessState: tauriSystem.updateProcessState,
        updateDebugState: tauriSystem.updateDebugState,
        addBreakpoint: tauriSystem.addBreakpoint,
        removeBreakpoint: tauriSystem.removeBreakpoint,
        addWatchpoint: tauriSystem.addWatchpoint,
        removeWatchpoint: tauriSystem.removeWatchpoint,
        updateModules: tauriSystem.updateModules,
        updateField: tauriSystem.updateField,
        updateState: tauriSystem.updateState,
      }),
      [
        tauriSystem.updateConnectionState,
        tauriSystem.updateProcessState,
        tauriSystem.updateDebugState,
        tauriSystem.addBreakpoint,
        tauriSystem.removeBreakpoint,
        tauriSystem.addWatchpoint,
        tauriSystem.removeWatchpoint,
        tauriSystem.updateModules,
        tauriSystem.updateField,
        tauriSystem.updateState,
      ]
    ),

    uiActions,

    refresh: tauriSystem.loadState,
  };
};

export const useConnectionOnly = () => {
  const { system } = useAppState();
  return {
    serverConnected: system.serverConnected,
    debuggerConnected: system.debuggerConnected,
    isConnected: system.isConnected,
    connectionHost: system.connectionHost,
    connectionPort: system.connectionPort,
  };
};

export const useDebugOnly = () => {
  const { system } = useAppState();
  return {
    isInBreakState: system.isInBreakState,
    currentThreadId: system.currentThreadId,
    currentBreakAddress: system.currentBreakAddress,
    currentRegisterData: system.currentRegisterData,
    activeBreakpoints: system.activeBreakpoints,
    watchpoints: system.watchpoints,
  };
};

export const useUIOnly = () => {
  const { ui, uiActions } = useAppState();
  return { ui, uiActions };
};

```

`src/client/src/hooks/useBreakpointExceptionHandler.ts`:

```ts
import { useCallback } from "react";
import { useExceptionHandler, ProcessedException } from "./useExceptionHandler";

// Legacy interface for backward compatibility
export interface BreakpointException {
  address: string;
  instruction: string;
  timestamp: Date;
  thread_id?: number; // Thread ID from exception info
  context?: any; // Additional context information
  // Register values as individual fields (flattened from server processing)
  x0?: string | number;
  x1?: string | number;
  x2?: string | number;
  x3?: string | number;
  x4?: string | number;
  x5?: string | number;
  x6?: string | number;
  x7?: string | number;
  x8?: string | number;
  x9?: string | number;
  x10?: string | number;
  x11?: string | number;
  x12?: string | number;
  x13?: string | number;
  x14?: string | number;
  x15?: string | number;
  x16?: string | number;
  x17?: string | number;
  x18?: string | number;
  x19?: string | number;
  x20?: string | number;
  x21?: string | number;
  x22?: string | number;
  x23?: string | number;
  x24?: string | number;
  x25?: string | number;
  x26?: string | number;
  x27?: string | number;
  x28?: string | number;
  x29?: string | number;
  lr?: string | number;
  fp?: string | number;
  sp?: string | number;
  pc?: string | number;
  cpsr?: string | number;
}

export interface UseBreakpointExceptionHandlerOptions {
  pollingInterval?: number; // Default: 500ms
  onBreakpointHit?: (exception: BreakpointException) => void;
  onError?: (error: string) => void;
  autoStart?: boolean; // Auto-start monitoring when breakpoints are set
  // Connection and state checks (pass-through to useExceptionHandler)
  isConnected?: boolean; // Check if connected to server
  isProcessAttached?: boolean; // Check if process is attached
  hasActiveBreakpoints?: boolean; // Check if any breakpoints are set
}

// Convert ProcessedException to legacy BreakpointException format
const convertToLegacyFormat = (
  exception: ProcessedException
): BreakpointException => ({
  address: exception.address,
  instruction: exception.instruction,
  timestamp: exception.timestamp,
  context: exception.context,
  x0: exception.x0,
  x1: exception.x1,
  x2: exception.x2,
  x3: exception.x3,
  x4: exception.x4,
  x5: exception.x5,
  x6: exception.x6,
  x7: exception.x7,
  x8: exception.x8,
  x9: exception.x9,
  x10: exception.x10,
  x11: exception.x11,
  x12: exception.x12,
  x13: exception.x13,
  x14: exception.x14,
  x15: exception.x15,
  x16: exception.x16,
  x17: exception.x17,
  x18: exception.x18,
  x19: exception.x19,
  x20: exception.x20,
  x21: exception.x21,
  x22: exception.x22,
  x23: exception.x23,
  x24: exception.x24,
  x25: exception.x25,
  x26: exception.x26,
  x27: exception.x27,
  x28: exception.x28,
  x29: exception.x29,
  lr: exception.lr,
  fp: exception.fp,
  sp: exception.sp,
  pc: exception.pc,
  cpsr: exception.cpsr,
});

export const useBreakpointExceptionHandler = (
  options: UseBreakpointExceptionHandlerOptions = {}
) => {
  const {
    pollingInterval = 50,
    onBreakpointHit,
    onError,
    autoStart = true,
    isConnected = false,
    isProcessAttached = false,
    hasActiveBreakpoints = false,
  } = options;

  // Debug log
  console.log("[BREAKPOINT] useBreakpointExceptionHandler initialized with:", {
    pollingInterval,
    hasCallback: !!onBreakpointHit,
    autoStart,
  });

  // Convert callback to use legacy format
  const handleBreakpointHit = useCallback(
    (exception: ProcessedException) => {
      console.log("[BREAKPOINT] handleBreakpointHit called with:", exception);
      if (onBreakpointHit) {
        onBreakpointHit(convertToLegacyFormat(exception));
      }
    },
    [onBreakpointHit]
  );

  // Use the common exception handler with breakpoint-only configuration
  const exceptionHandlerConfig = {
    pollingInterval,
    onBreakpointHit: handleBreakpointHit,
    onError,
    autoStart,
    enableWatchpoints: false, // Only monitor breakpoints
    enableBreakpoints: true,
    isConnected,
    isProcessAttached,
    hasActiveBreakpoints,
  };

  console.log(
    "[BREAKPOINT] Passing config to useExceptionHandler:",
    exceptionHandlerConfig
  );

  const {
    isMonitoring,
    breakpointExceptions,
    lastCheckTime,
    error,
    startMonitoring,
    stopMonitoring,
    clearBreakpointExceptions,
    checkNow,
  } = useExceptionHandler(exceptionHandlerConfig);

  // Convert exceptions to legacy format
  const exceptions: BreakpointException[] = breakpointExceptions.map(
    convertToLegacyFormat
  );

  // Alias clearBreakpointExceptions as clearExceptions for backward compatibility
  const clearExceptions = clearBreakpointExceptions;

  return {
    // State
    isMonitoring,
    exceptions,
    lastCheckTime,
    error,

    // Actions
    startMonitoring,
    stopMonitoring,
    clearExceptions,
    checkNow,
  };
};

```

`src/client/src/hooks/useColumnResize.ts`:

```ts
import { useState, useCallback, useEffect } from "react";
import { useLocalStorage } from "./useLocalStorage";

interface ColumnWidths {
  [key: string]: number;
}

interface UseColumnResizeOptions {
  storageKey: string;
  defaultWidths: ColumnWidths;
  minWidth?: number;
  maxWidth?: number;
}

export const useColumnResize = ({
  storageKey,
  defaultWidths,
  minWidth = 50,
  maxWidth = 800,
}: UseColumnResizeOptions) => {
  const [columnWidths, setColumnWidths] = useLocalStorage<ColumnWidths>(
    storageKey,
    defaultWidths
  );
  const [resizingColumn, setResizingColumn] = useState<string | null>(null);
  const [startX, setStartX] = useState<number>(0);
  const [startWidth, setStartWidth] = useState<number>(0);

  const handleResizeStart = useCallback(
    (columnKey: string, e: React.MouseEvent) => {
      e.preventDefault();
      e.stopPropagation();
      setResizingColumn(columnKey);
      setStartX(e.clientX);
      setStartWidth(columnWidths[columnKey] || defaultWidths[columnKey]);
    },
    [columnWidths, defaultWidths]
  );

  const handleResizeMove = useCallback(
    (e: MouseEvent) => {
      if (!resizingColumn) return;

      const deltaX = e.clientX - startX;
      const newWidth = startWidth + deltaX;
      const constrainedWidth = Math.min(Math.max(newWidth, minWidth), maxWidth);

      setColumnWidths((prev) => ({
        ...prev,
        [resizingColumn]: constrainedWidth,
      }));
    },
    [resizingColumn, startX, startWidth, minWidth, maxWidth, setColumnWidths]
  );

  const handleResizeEnd = useCallback(() => {
    setResizingColumn(null);
  }, []);

  useEffect(() => {
    if (resizingColumn) {
      document.addEventListener("mousemove", handleResizeMove);
      document.addEventListener("mouseup", handleResizeEnd);

      // Prevent text selection during resize
      document.body.style.userSelect = "none";
      document.body.style.cursor = "col-resize";

      return () => {
        document.removeEventListener("mousemove", handleResizeMove);
        document.removeEventListener("mouseup", handleResizeEnd);
        document.body.style.userSelect = "";
        document.body.style.cursor = "";
      };
    }
  }, [resizingColumn, handleResizeMove, handleResizeEnd]);

  const getColumnWidth = useCallback(
    (columnKey: string): number => {
      return columnWidths[columnKey] || defaultWidths[columnKey];
    },
    [columnWidths, defaultWidths]
  );

  return {
    columnWidths,
    resizingColumn,
    handleResizeStart,
    getColumnWidth,
  };
};

```

`src/client/src/hooks/useDebugLogger.ts`:

```ts
import { useState, useCallback, useRef, useEffect } from "react";

export type LogLevel =
  | "DEBUG"
  | "INFO"
  | "WARN"
  | "ERROR"
  | "EXCEPTION"
  | "REGISTER";

export interface LogEntry {
  id: string;
  timestamp: Date;
  level: LogLevel;
  category: string;
  message: string;
  data?: any;
}

interface UseDebugLoggerOptions {
  maxEntries?: number;
  enabledCategories?: string[];
}

export const useDebugLogger = (options: UseDebugLoggerOptions = {}) => {
  const { maxEntries = 1000, enabledCategories = [] } = options;
  const [logs, setLogs] = useState<LogEntry[]>([]);
  const [searchTerm, setSearchTerm] = useState("");
  const [selectedLevel, setSelectedLevel] = useState<LogLevel | "ALL">("ALL");
  const [selectedCategory, setSelectedCategory] = useState<string | "ALL">(
    "ALL"
  );
  const idCounter = useRef(0);
  const enabledCategoriesRef = useRef(enabledCategories);

  // Check if development mode
  const isDevelopment =
    import.meta.env.DEV || import.meta.env.MODE === "development";

  // Update ref when enabledCategories changes
  useEffect(() => {
    enabledCategoriesRef.current = enabledCategories;
  }, [enabledCategories]);

  const addLog = useCallback(
    (level: LogLevel, category: string, message: string, data?: any) => {
      // Always add logs for debugging (remove development mode check)
      // if (!isDevelopment) return;

      // Check if category is enabled (if enabledCategories is specified)
      if (
        enabledCategoriesRef.current.length > 0 &&
        !enabledCategoriesRef.current.includes(category)
      ) {
        return;
      }

      const newLog: LogEntry = {
        id: `log_${idCounter.current++}`,
        timestamp: new Date(),
        level,
        category,
        message,
        data,
      };

      setLogs((prev) => {
        const newLogs = [newLog, ...prev];
        // Limit the number of entries
        return newLogs.slice(0, maxEntries);
      });
    },
    [maxEntries]
  ); // Removed enabledCategories from dependencies

  // Convenience methods for different log levels
  const logDebug = useCallback(
    (category: string, message: string, data?: any) => {
      addLog("DEBUG", category, message, data);
    },
    [addLog]
  );

  const logInfo = useCallback(
    (category: string, message: string, data?: any) => {
      addLog("INFO", category, message, data);
    },
    [addLog]
  );

  const logWarn = useCallback(
    (category: string, message: string, data?: any) => {
      addLog("WARN", category, message, data);
    },
    [addLog]
  );

  const logError = useCallback(
    (category: string, message: string, data?: any) => {
      addLog("ERROR", category, message, data);
    },
    [addLog]
  );

  const logException = useCallback(
    (category: string, message: string, data?: any) => {
      addLog("EXCEPTION", category, message, data);
    },
    [addLog]
  );

  const logRegister = useCallback(
    (category: string, message: string, data?: any) => {
      addLog("REGISTER", category, message, data);
    },
    [addLog]
  );

  // Filter logs based on search term, level, and category
  const filteredLogs = logs.filter((log) => {
    const matchesSearch =
      searchTerm === "" ||
      log.message.toLowerCase().includes(searchTerm.toLowerCase()) ||
      log.category.toLowerCase().includes(searchTerm.toLowerCase()) ||
      (log.data &&
        JSON.stringify(log.data)
          .toLowerCase()
          .includes(searchTerm.toLowerCase()));

    const matchesLevel = selectedLevel === "ALL" || log.level === selectedLevel;
    const matchesCategory =
      selectedCategory === "ALL" || log.category === selectedCategory;

    return matchesSearch && matchesLevel && matchesCategory;
  });

  // Get unique categories
  const categories = Array.from(
    new Set(logs.map((log) => log.category))
  ).sort();

  // Clear all logs
  const clearLogs = useCallback(() => {
    setLogs([]);
    idCounter.current = 0;
  }, []);

  // Export logs as JSON
  const exportLogs = useCallback(() => {
    const dataStr = JSON.stringify(filteredLogs, null, 2);
    const dataUri =
      "data:application/json;charset=utf-8," + encodeURIComponent(dataStr);

    const exportFileDefaultName = `debug_logs_${new Date().toISOString().split("T")[0]}.json`;

    const linkElement = document.createElement("a");
    linkElement.setAttribute("href", dataUri);
    linkElement.setAttribute("download", exportFileDefaultName);
    linkElement.click();
  }, [filteredLogs]);

  return {
    // State
    logs: filteredLogs,
    allLogs: logs,
    searchTerm,
    selectedLevel,
    selectedCategory,
    categories,
    isDevelopment,

    // Actions
    addLog,
    logDebug,
    logInfo,
    logWarn,
    logError,
    logException,
    logRegister,
    clearLogs,
    exportLogs,

    // Filters
    setSearchTerm,
    setSelectedLevel,
    setSelectedCategory,
  };
};

```

`src/client/src/hooks/useDebuggerContentState.ts`:

```ts
import { useState, useCallback } from "react";

export interface DebuggerContentState {
  assemblyAddress: string;
  breakpointNotification: {
    open: boolean;
    message: string;
  };
  gotoAddress: string;
  breakpointInputValue: string;
  activeBreakpoints: string[];
  memoryAddress: string; // Add memory address state
}

export const useDebuggerContentState = () => {
  // Assembly view address state
  const [assemblyAddress, setAssemblyAddress] = useState("0x0");

  // Notification state for breakpoint hits
  const [breakpointNotification, setBreakpointNotification] = useState<{
    open: boolean;
    message: string;
  }>({ open: false, message: "" });

  // Goto address state
  const [gotoAddress, setGotoAddress] = useState("");

  // Breakpoint input value state
  const [breakpointInputValue, setBreakpointInputValue] = useState<string>("");

  // Active breakpoints state
  const [activeBreakpoints, setActiveBreakpoints] = useState<string[]>([]);

  // Memory address state
  const [memoryAddress, setMemoryAddress] = useState("0x0");

  const updateAssemblyAddress = useCallback((address: string) => {
    setAssemblyAddress(address);
  }, []);

  const showBreakpointNotification = useCallback((message: string) => {
    setBreakpointNotification({ open: true, message });
  }, []);

  const hideBreakpointNotification = useCallback(() => {
    setBreakpointNotification((prev) => ({ ...prev, open: false }));
  }, []);

  const updateGotoAddress = useCallback((address: string) => {
    setGotoAddress(address);
  }, []);

  const updateBreakpointInputValue = useCallback((value: string) => {
    setBreakpointInputValue(value);
  }, []);

  const addActiveBreakpoint = useCallback((address: string) => {
    setActiveBreakpoints((prev) => {
      if (!prev.includes(address)) {
        return [...prev, address];
      }
      return prev;
    });
  }, []);

  const removeActiveBreakpoint = useCallback((address: string) => {
    setActiveBreakpoints((prev) => prev.filter((bp) => bp !== address));
  }, []);

  const clearActiveBreakpoints = useCallback(() => {
    setActiveBreakpoints([]);
  }, []);

  const updateMemoryAddress = useCallback((address: string) => {
    setMemoryAddress(address);
  }, []);

  return {
    // State
    assemblyAddress,
    breakpointNotification,
    gotoAddress,
    breakpointInputValue,
    activeBreakpoints,
    memoryAddress,

    // Actions
    updateAssemblyAddress,
    showBreakpointNotification,
    hideBreakpointNotification,
    updateGotoAddress,
    updateBreakpointInputValue,
    addActiveBreakpoint,
    removeActiveBreakpoint,
    clearActiveBreakpoints,
    updateMemoryAddress,
    setAssemblyAddress,
    setBreakpointNotification,
    setMemoryAddress,
  };
};

```

`src/client/src/hooks/useExceptionHandler.ts`:

```ts
import { useState, useCallback, useEffect, useRef } from "react";
import { invoke } from "@tauri-apps/api/core";
import { ExceptionInfo } from "../types";
import { getApiClient } from "../lib/api";
import { useGlobalDebugLogger } from "./useGlobalDebugLogger";
import {
  useTauriExceptionStore,
  TauriExceptionData,
  TauriTraceEntryData,
} from "./useTauriExceptionStore";
import { encodeAddressToLibraryExpression } from "../utils/addressEncoder";
import { useAppState } from "./useAppState";

// Global trace entry counter for unique IDs
let globalTraceEntryId = 0;
let globalTraceDepth = 0;

export type ExceptionType =
  | "watchpoint"
  | "breakpoint"
  | "singlestep"
  | "signal"
  | "sigsegv"
  | "sigbus"
  | "sigfpe"
  | "sigill"
  | "sigabrt"
  | "sigtrap"
  | "unknown";

// Script breakpoint event (from Lua script Debug.set_breakpoint/remove_breakpoint)
export interface ScriptBreakpointEvent {
  event_type: "script_breakpoint";
  action: "set" | "remove";
  address: number;
  bp_type?: "soft" | "hard";
  has_callback?: boolean;
  timestamp: string;
}

// Global monitoring state (singleton)
class GlobalExceptionMonitoringState {
  private static instance: GlobalExceptionMonitoringState;

  public isGloballyMonitoring: boolean = false;
  public activeInstances: Set<string> = new Set();
  public mainInstanceId: string | null = null;
  public intervalId: number | null = null;

  public static getInstance(): GlobalExceptionMonitoringState {
    if (!GlobalExceptionMonitoringState.instance) {
      GlobalExceptionMonitoringState.instance =
        new GlobalExceptionMonitoringState();
    }
    return GlobalExceptionMonitoringState.instance;
  }

  public addInstance(instanceId: string): boolean {
    this.activeInstances.add(instanceId);

    if (!this.isGloballyMonitoring) {
      this.isGloballyMonitoring = true;
      this.mainInstanceId = instanceId;
      return true; // This instance becomes main
    }

    return false; // This instance becomes secondary
  }

  public removeInstance(instanceId: string): boolean {
    this.activeInstances.delete(instanceId);

    if (this.mainInstanceId === instanceId) {
      const remainingInstances = Array.from(this.activeInstances);
      if (remainingInstances.length > 0) {
        this.mainInstanceId = remainingInstances[0];
        return false; // Transferred to another instance
      } else {
        this.isGloballyMonitoring = false;
        this.mainInstanceId = null;
        if (this.intervalId) {
          window.clearInterval(this.intervalId);
          this.intervalId = null;
        }
        return true; // Last instance, stopped monitoring
      }
    }

    return false; // Was secondary instance
  }

  public setInterval(intervalId: number): void {
    this.intervalId = intervalId;
  }

  public clearInterval(): void {
    if (this.intervalId) {
      window.clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }
}

export interface ProcessedException {
  address: string;
  instruction: string;
  timestamp: Date;
  type: ExceptionType;
  watchpointId?: string; // Only for watchpoint exceptions
  thread_id?: number; // Thread ID from exception info
  memory_address?: number; // Memory address for watchpoint exceptions
  singlestep_mode?: number; // Single step mode for singlestep exceptions
  is_trace?: boolean; // True if this is a trace exception (hit_count > 0)
  context?: any;
  // Register values as individual fields (flattened from server processing)
  x0?: string | number;
  x1?: string | number;
  x2?: string | number;
  x3?: string | number;
  x4?: string | number;
  x5?: string | number;
  x6?: string | number;
  x7?: string | number;
  x8?: string | number;
  x9?: string | number;
  x10?: string | number;
  x11?: string | number;
  x12?: string | number;
  x13?: string | number;
  x14?: string | number;
  x15?: string | number;
  x16?: string | number;
  x17?: string | number;
  x18?: string | number;
  x19?: string | number;
  x20?: string | number;
  x21?: string | number;
  x22?: string | number;
  x23?: string | number;
  x24?: string | number;
  x25?: string | number;
  x26?: string | number;
  x27?: string | number;
  x28?: string | number;
  x29?: string | number;
  lr?: string | number;
  fp?: string | number;
  sp?: string | number;
  pc?: string | number;
  cpsr?: string | number;
  // x86_64 registers
  rax?: string | number;
  rbx?: string | number;
  rcx?: string | number;
  rdx?: string | number;
  rsi?: string | number;
  rdi?: string | number;
  rbp?: string | number;
  rsp?: string | number;
  r8?: string | number;
  r9?: string | number;
  r10?: string | number;
  r11?: string | number;
  r12?: string | number;
  r13?: string | number;
  r14?: string | number;
  r15?: string | number;
  rip?: string | number;
  rflags?: string | number;
  cs?: string | number;
  ss?: string | number;
  ds?: string | number;
  es?: string | number;
  fs?: string | number;
  gs?: string | number;
}

export interface UseExceptionHandlerOptions {
  pollingInterval?: number; // Default: 500ms
  onWatchpointHit?: (exception: ProcessedException) => void;
  onBreakpointHit?: (exception: ProcessedException) => void;
  onSignalHit?: (exception: ProcessedException) => void; // Signal exception callback
  onScriptBreakpoint?: (event: ScriptBreakpointEvent) => void; // Script breakpoint set/remove callback
  onError?: (error: string) => void;
  autoStart?: boolean; // Auto-start monitoring when component mounts
  enableWatchpoints?: boolean; // Enable watchpoint monitoring
  enableBreakpoints?: boolean; // Enable breakpoint monitoring
  enableSignals?: boolean; // Enable signal monitoring
  // Connection and state checks
  isConnected?: boolean; // Check if connected to server
  isProcessAttached?: boolean; // Check if process is attached
  hasActiveWatchpoints?: boolean; // Check if any watchpoints are set
  hasActiveBreakpoints?: boolean; // Check if any breakpoints are set
}

// Global initialization flag
let globalInitialized = false;

export const useExceptionHandler = (
  options: UseExceptionHandlerOptions = {}
) => {
  const {
    pollingInterval = 50,
    onWatchpointHit,
    onBreakpointHit,
    onSignalHit,
    onScriptBreakpoint,
    onError,
    autoStart = true,
    enableWatchpoints = true,
    enableBreakpoints = true,
    enableSignals = true,
    isConnected = false,
    isProcessAttached = false,
    hasActiveWatchpoints = false,
    hasActiveBreakpoints = false,
  } = options;

  const { addLog } = useGlobalDebugLogger();

  // Get attached modules for library expression encoding
  const { system } = useAppState();
  const attachedModulesFromContext = system.attachedModules || [];

  // Also fetch from Tauri state as fallback
  const [tauriAttachedModules, setTauriAttachedModules] = useState<any[]>([]);
  useEffect(() => {
    const fetchModules = async () => {
      try {
        const state = (await invoke("get_app_state")) as any;
        if (state?.attached_modules && state.attached_modules.length > 0) {
          setTauriAttachedModules(
            state.attached_modules.map((m: any) => ({
              modulename: m.modulename,
              base: typeof m.base === "string" ? parseInt(m.base, 16) : m.base,
              size: typeof m.size === "string" ? parseInt(m.size, 16) : m.size,
              path: m.path,
            }))
          );
        }
      } catch (err) {
        console.error("Failed to fetch attached modules from Tauri:", err);
      }
    };
    fetchModules();
    // Refresh periodically
    const interval = setInterval(fetchModules, 2000);
    return () => clearInterval(interval);
  }, []);

  // Use context modules first, fallback to Tauri modules
  const attachedModules =
    attachedModulesFromContext.length > 0
      ? attachedModulesFromContext
      : tauriAttachedModules;

  // Get global monitoring state
  const globalState = GlobalExceptionMonitoringState.getInstance();

  // Only initialize once per hook instance, not on every re-render
  const hookInstanceId = useRef(Math.random().toString(36).substr(2, 9));

  useEffect(() => {
    // Only log initialization once globally across all instances
    if (
      !globalInitialized &&
      autoStart &&
      (enableWatchpoints || enableBreakpoints)
    ) {
      // Debug: Log stack trace to identify the caller
      console.trace("useExceptionHandler: First instance initialization");
      addLog(
        "DEBUG",
        "EXCEPTION",
        `Exception handler [${hookInstanceId.current}] initialized (FIRST INSTANCE)`,
        {
          enableWatchpoints,
          enableBreakpoints,
          autoStart,
          pollingInterval,
          hasWatchpointCallback: !!onWatchpointHit,
          hasBreakpointCallback: !!onBreakpointHit,
          isConnected,
          isProcessAttached,
          hasActiveWatchpoints,
          hasActiveBreakpoints,
          willAutoStart:
            autoStart &&
            isConnected &&
            isProcessAttached &&
            (enableWatchpoints || enableBreakpoints),
        }
      );
      globalInitialized = true;
    } else if (autoStart && (enableWatchpoints || enableBreakpoints)) {
      // Debug: Log stack trace to identify the caller
      console.trace("useExceptionHandler: Additional instance initialization");
      addLog(
        "DEBUG",
        "EXCEPTION",
        `Exception handler [${hookInstanceId.current}] initialized (ADDITIONAL INSTANCE - will not log details)`
      );
    }
  }, []); // Empty dependency array to run only once per instance mount

  const [isMonitoring, setIsMonitoring] = useState(false);
  const [watchpointExceptions, setWatchpointExceptions] = useState<
    ProcessedException[]
  >([]);
  const [breakpointExceptions, setBreakpointExceptions] = useState<
    ProcessedException[]
  >([]);
  const [signalExceptions, setSignalExceptions] = useState<
    ProcessedException[]
  >([]);
  const [allExceptions, setAllExceptions] = useState<ProcessedException[]>([]);
  const [lastCheckTime, setLastCheckTime] = useState<Date | null>(null);
  const [error, setError] = useState<string | null>(null);

  const intervalRef = useRef<number | null>(null);
  const isMonitoringRef = useRef<boolean>(false);
  const isPollingRef = useRef<boolean>(false);

  const { addExceptions: addExceptionsToTauriStore } = useTauriExceptionStore();

  // Process raw exception data into typed exceptions
  const processExceptions = useCallback(
    (
      rawExceptions: ExceptionInfo[]
    ): {
      watchpoints: ProcessedException[];
      breakpoints: ProcessedException[];
      signals: ProcessedException[];
      all: ProcessedException[];
    } => {
      const processedExceptions: ProcessedException[] = rawExceptions.map(
        (exception) => {
          // Handle different address formats
          let address = "unknown";

          if (exception.address) {
            address = exception.address;
          } else if ((exception as any).pc) {
            // If PC is provided as a separate field, use it as address
            const pc = (exception as any).pc;
            address =
              typeof pc === "number"
                ? `0x${pc.toString(16).padStart(16, "0").toUpperCase()}`
                : pc.toString();
          }

          // Ensure address starts with 0x
          if (
            address !== "unknown" &&
            !address.startsWith("0x") &&
            !address.startsWith("0X")
          ) {
            // If it's a valid hex number, add 0x prefix
            if (/^[0-9A-Fa-f]+$/.test(address)) {
              address = `0x${address}`;
            }
          }

          // Determine exception type based on exception_type field first, then fallback to instruction content
          let exceptionType: ExceptionType;
          if (
            exception.exception_type !== undefined &&
            exception.exception_type !== null
          ) {
            // Use the exception_type from C++ send_exception_info (matches Rust enum)
            // Handle both string and numeric values
            // Rust/C++ enum values: Breakpoint=1, Watchpoint=2, SingleStep=3
            switch (exception.exception_type) {
              case "breakpoint":
              case 1: // ExceptionType::Breakpoint
                exceptionType = "breakpoint";
                break;
              case "watchpoint":
              case 2: // ExceptionType::Watchpoint
                exceptionType = "watchpoint";
                break;
              case "singlestep":
              case 3: // ExceptionType::SingleStep
                exceptionType = "singlestep";
                break;
              case "signal":
              case 4: // ExceptionType::Signal
                exceptionType = "signal";
                break;
              case "sigsegv":
              case 5: // ExceptionType::Sigsegv
                exceptionType = "sigsegv";
                break;
              case "sigbus":
              case 6: // ExceptionType::Sigbus
                exceptionType = "sigbus";
                break;
              case "sigfpe":
              case 7: // ExceptionType::Sigfpe
                exceptionType = "sigfpe";
                break;
              case "sigill":
              case 8: // ExceptionType::Sigill
                exceptionType = "sigill";
                break;
              case "sigabrt":
              case 9: // ExceptionType::Sigabrt
                exceptionType = "sigabrt";
                break;
              case "sigtrap":
              case 10: // ExceptionType::Sigtrap
                exceptionType = "sigtrap";
                break;
              default:
                addLog(
                  "WARN",
                  "EXCEPTION",
                  `Unknown exception_type: ${exception.exception_type}`,
                  {
                    address,
                    exception_type: exception.exception_type,
                    instruction: exception.instruction,
                    typeOfExceptionType: typeof exception.exception_type,
                  }
                );
                exceptionType = "unknown";
                break;
            }
          } else {
            // Fallback to old logic for backward compatibility
            // Also check instruction content to detect single step
            if (exception.watchpointId) {
              exceptionType = "watchpoint";
            } else if (
              exception.instruction &&
              exception.instruction !== "unknown | unknown" &&
              !exception.instruction.includes("__METADATA__")
            ) {
              // If we have a proper instruction, it's likely a single step completion
              exceptionType = "singlestep";
            } else {
              // Otherwise, assume it's a breakpoint
              exceptionType = "breakpoint";
            }
          }

          // Log exception processing details with more context
          addLog("INFO", "EXCEPTION", "Processing exception:", {
            index: rawExceptions.indexOf(exception),
            address,
            hasWatchpointId: !!exception.watchpointId,
            watchpointId: exception.watchpointId,
            exception_type: exception.exception_type,
            exception_type_typeof: typeof exception.exception_type,
            detectedType: exceptionType,
            thread_id: exception.thread_id,
            instruction: exception.instruction,
            bytecode: exception.bytecode,
            opcode: exception.opcode,
            hasInstruction: !!exception.instruction,
            instructionContainsMetadata:
              exception.instruction?.includes("__METADATA__"),
          });

          // Parse instruction to extract bytecode and opcode
          // Format from server: "0xADDRESS|BYTECODE|OPCODE\n__METADATA__..."
          let bytecode = "unknown";
          let opcode = "unknown";

          if (
            exception.instruction &&
            exception.instruction !== "unknown | unknown"
          ) {
            // Split by newline first to remove metadata
            const instructionLines = exception.instruction.split("\n");
            const mainInstruction = instructionLines[0]; // Get first line before metadata

            // instruction format: "0xADDRESS|BYTECODE|OPCODE"
            const parts = mainInstruction.split("|");
            if (parts.length >= 3) {
              // Format: address | bytecode | opcode
              bytecode = parts[1].trim();
              opcode = parts[2].trim();
            } else if (parts.length === 2) {
              // Legacy format: bytecode | opcode
              bytecode = parts[0].trim();
              opcode = parts[1].trim();
            } else if (parts.length === 1) {
              // If it's a single instruction without separator, use it as opcode
              opcode = parts[0].trim();
            }
          }

          return {
            address,
            instruction:
              exception.instruction ||
              `${exception.bytecode || "unknown"} | ${exception.opcode || "unknown"}`,
            timestamp: exception.timestamp
              ? new Date(exception.timestamp)
              : new Date(),
            type: exceptionType,
            watchpointId: exception.watchpointId,
            thread_id: exception.thread_id, // Include thread_id from exception info
            // Extract memory_address from various sources
            memory_address:
              (exception as any).memory_address ||
              (exception as any).exception_info?.memory_address ||
              (exception as any).registers?.memory ||
              (exception as any).memory,
            // Extract singlestep_mode
            singlestep_mode:
              (exception as any).singlestep_mode ||
              (exception as any).exception_info?.singlestep_mode ||
              (exception as any).registers?.singlestep_mode,
            // Extract is_trace flag
            is_trace:
              (exception as any).is_trace ||
              (exception as any).exception_info?.is_trace ||
              false,
            // Copy register fields directly from exception (first priority)
            // ARM64 registers
            x0: exception.x0,
            x1: exception.x1,
            x2: exception.x2,
            x3: exception.x3,
            x4: exception.x4,
            x5: exception.x5,
            x6: exception.x6,
            x7: exception.x7,
            x8: exception.x8,
            x9: exception.x9,
            x10: exception.x10,
            x11: exception.x11,
            x12: exception.x12,
            x13: exception.x13,
            x14: exception.x14,
            x15: exception.x15,
            x16: exception.x16,
            x17: exception.x17,
            x18: exception.x18,
            x19: exception.x19,
            x20: exception.x20,
            x21: exception.x21,
            x22: exception.x22,
            x23: exception.x23,
            x24: exception.x24,
            x25: exception.x25,
            x26: exception.x26,
            x27: exception.x27,
            x28: exception.x28,
            x29: exception.x29,
            lr: exception.lr,
            fp: exception.fp,
            sp: exception.sp,
            pc: exception.pc,
            cpsr: exception.cpsr,
            // x86_64 registers
            rax: (exception as any).rax,
            rbx: (exception as any).rbx,
            rcx: (exception as any).rcx,
            rdx: (exception as any).rdx,
            rsi: (exception as any).rsi,
            rdi: (exception as any).rdi,
            rbp: (exception as any).rbp,
            rsp: (exception as any).rsp,
            r8: (exception as any).r8,
            r9: (exception as any).r9,
            r10: (exception as any).r10,
            r11: (exception as any).r11,
            r12: (exception as any).r12,
            r13: (exception as any).r13,
            r14: (exception as any).r14,
            r15: (exception as any).r15,
            rip: (exception as any).rip,
            rflags: (exception as any).rflags,
            cs: (exception as any).cs,
            ss: (exception as any).ss,
            ds: (exception as any).ds,
            es: (exception as any).es,
            fs: (exception as any).fs,
            gs: (exception as any).gs,
            context: {
              index: exception.index || 0,
              count: exception.count || 1,
              bytecode: bytecode,
              opcode: opcode,
              pc: exception.pc,
              // Include the full exception object as fallback for register extraction
              rawException: exception,
            },
          };
        }
      );

      // Separate watchpoint, breakpoint, singlestep, and signal exceptions
      const watchpoints = processedExceptions.filter(
        (ex) => ex.type === "watchpoint"
      );
      const breakpoints = processedExceptions.filter(
        (ex) => ex.type === "breakpoint" || ex.type === "singlestep"
      );
      const signals = processedExceptions.filter(
        (ex) =>
          ex.type === "signal" ||
          ex.type === "sigsegv" ||
          ex.type === "sigbus" ||
          ex.type === "sigfpe" ||
          ex.type === "sigill" ||
          ex.type === "sigabrt" ||
          ex.type === "sigtrap"
      );
      return {
        watchpoints,
        breakpoints,
        signals,
        all: processedExceptions,
      };
    },
    []
  );

  // Fetch and check for new exceptions
  const checkForExceptions = useCallback(async () => {
    // Prevent concurrent polling - if already polling, skip this cycle
    if (isPollingRef.current) {
      return;
    }
    isPollingRef.current = true;

    const pollStartTime = performance.now();

    try {
      // Check preconditions before fetching exceptions
      if (!isConnected) {
        return;
      }

      if (!isProcessAttached) {
        return;
      }

      // Determine which exception types to monitor
      const exceptionTypesToMonitor: string[] = [];
      if (enableBreakpoints) {
        exceptionTypesToMonitor.push("breakpoint", "single_step");
      }
      if (enableWatchpoints) {
        exceptionTypesToMonitor.push("watchpoint");
      }
      if (enableSignals) {
        exceptionTypesToMonitor.push(
          "signal",
          "sigsegv",
          "sigbus",
          "sigfpe",
          "sigill",
          "sigabrt",
          "sigtrap"
        );
      }

      // If no exception types are enabled, skip checking
      if (exceptionTypesToMonitor.length === 0) {
        return;
      }

      const apiClient = getApiClient();
      // Fetch exceptions based on enabled types
      // For single_step, fetch Breakpoint mode (2), UserStep mode (3), and SoftwareBreakpoint mode (4)
      const apiStartTime = performance.now();
      const response = await apiClient.getExceptionInfo(
        exceptionTypesToMonitor,
        enableBreakpoints ? [2, 3, 4] : undefined // SingleStepMode::Breakpoint (2), UserStep (3), SoftwareBreakpoint (4)
      );
      const apiEndTime = performance.now();

      if (response.success && response.exceptions.length > 0) {
        console.log(
          `[POLLING] Found ${response.exceptions.length} exceptions, API took ${(apiEndTime - apiStartTime).toFixed(2)}ms, total poll time: ${(apiEndTime - pollStartTime).toFixed(2)}ms`
        );
      }

      if (response.success) {
        // Check for script breakpoint events first (from Lua Debug.set_breakpoint/remove_breakpoint)
        const scriptBpEvents = response.exceptions.filter(
          (ex: any) => ex.event_type === "script_breakpoint"
        );

        // Check for script output events (from print() in callbacks)
        const scriptOutputEvents = response.exceptions.filter(
          (ex: any) => ex.event_type === "script_output"
        );

        const regularExceptions = response.exceptions.filter(
          (ex: any) =>
            ex.event_type !== "script_breakpoint" &&
            ex.event_type !== "script_output"
        );

        // Handle script output events (print from callbacks)
        if (scriptOutputEvents.length > 0) {
          scriptOutputEvents.forEach((event: any) => {
            addLog("INFO", "SCRIPT", `[Callback] ${event.message}`, {
              source: event.source,
              timestamp: event.timestamp,
            });
            // Dispatch custom event for ScriptEditor to receive
            window.dispatchEvent(
              new CustomEvent("script-callback-output", {
                detail: { message: event.message, source: event.source },
              })
            );
          });
        }

        // Handle script breakpoint events
        if (scriptBpEvents.length > 0 && onScriptBreakpoint) {
          scriptBpEvents.forEach((event: any) => {
            addLog(
              "INFO",
              "SCRIPT",
              `Script breakpoint ${event.action}: 0x${event.address.toString(16)}`,
              {
                action: event.action,
                address: event.address,
                bp_type: event.bp_type,
                has_callback: event.has_callback,
              }
            );
            onScriptBreakpoint(event as ScriptBreakpointEvent);
          });
        }

        if (regularExceptions.length > 0) {
          addLog(
            "INFO",
            "EXCEPTION",
            `Raw exceptions received (${regularExceptions.length})`,
            regularExceptions.map((ex: any, index: number) => ({
              index,
              address: ex.address,
              timestamp: ex.timestamp,
              watchpointId: ex.watchpointId,
              bytecode: ex.bytecode,
              opcode: ex.opcode,
              instruction: ex.instruction,
              exception_type: ex.exception_type,
              thread_id: ex.thread_id,
              pc: ex.pc,
              lr: ex.lr,
              sp: ex.sp,
              fullException: ex,
            }))
          );
        }
        // Debug: Log even when no exceptions (to confirm polling is working)
        // Uncomment to debug: addLog("DEBUG", "EXCEPTION", "Polling check - no exceptions");

        const { watchpoints, breakpoints, signals, all } =
          processExceptions(regularExceptions);

        // Log processing configuration
        if (
          breakpoints.length > 0 ||
          watchpoints.length > 0 ||
          signals.length > 0
        ) {
          addLog("DEBUG", "EXCEPTION", "Processing configuration check:", {
            watchpoints: watchpoints.length,
            breakpoints: breakpoints.length,
            signals: signals.length,
            total: all.length,
            enabledWatchpoints: enableWatchpoints,
            enabledBreakpoints: enableBreakpoints,
          });
        }

        if (breakpoints.length > 0) {
          addLog("INFO", "EXCEPTION", "Processed exceptions:", {
            watchpoints: watchpoints.length,
            breakpoints: breakpoints.length,
            total: all.length,
            enabledWatchpoints: enableWatchpoints,
            enabledBreakpoints: enableBreakpoints,
          });
        }

        // Check for watchpoint exceptions - process ALL watchpoints every time
        if (enableWatchpoints && watchpoints.length > 0) {
          addLog(
            "INFO",
            "EXCEPTION",
            `Processing ALL watchpoint exceptions (${watchpoints.length})`,
            watchpoints
          );

          setWatchpointExceptions(watchpoints);

          // Process ALL watchpoint exceptions every time (no filtering)
          watchpoints.forEach((exception) => {
            addLog(
              "WARN",
              "EXCEPTION",
              `Watchpoint hit at ${exception.address} for watchpoint ${exception.watchpointId}: ${exception.instruction}`
            );

            if (onWatchpointHit) {
              onWatchpointHit(exception);
            }
          });
        }

        // Check for breakpoint exceptions - process ALL breakpoints every time
        // Filter out trace exceptions (is_trace=true) from breakpoint callback notifications
        const nonTraceBreakpoints = breakpoints.filter((ex) => !ex.is_trace);
        const traceBreakpoints = breakpoints.filter((ex) => ex.is_trace);

        if (enableBreakpoints && nonTraceBreakpoints.length > 0) {
          addLog(
            "INFO",
            "EXCEPTION",
            `Processing breakpoint exceptions (${nonTraceBreakpoints.length} non-trace, ${traceBreakpoints.length} trace)`,
            nonTraceBreakpoints
          );
          addLog("DEBUG", "EXCEPTION", "Breakpoint processing enabled check:", {
            enableBreakpoints,
            breakpointsLength: breakpoints.length,
            nonTraceCount: nonTraceBreakpoints.length,
            traceCount: traceBreakpoints.length,
            willProcess: enableBreakpoints && nonTraceBreakpoints.length > 0,
            hasCallback: !!onBreakpointHit,
          });

          setBreakpointExceptions(nonTraceBreakpoints);

          // Process only non-trace breakpoint exceptions (trace exceptions are handled separately)
          nonTraceBreakpoints.forEach((exception) => {
            const exceptionTypeLabel =
              exception.type === "singlestep" ? "Single step" : "Breakpoint";
            addLog(
              "WARN",
              "EXCEPTION",
              `${exceptionTypeLabel} hit at ${exception.address}: ${exception.instruction}`
            );

            // Determine if this is a single step or breakpoint for logging
            if (exception.type === "singlestep") {
              addLog(
                "DEBUG",
                "EXCEPTION",
                "Detected as single step completion",
                {
                  address: exception.address,
                  instruction: exception.instruction,
                  thread_id: exception.thread_id,
                }
              );
            } else {
              addLog("DEBUG", "EXCEPTION", "Detected as breakpoint hit", {
                address: exception.address,
                instruction: exception.instruction,
                thread_id: exception.thread_id,
              });
            }

            if (onBreakpointHit) {
              addLog(
                "DEBUG",
                "EXCEPTION",
                `Calling onBreakpointHit callback for ${exceptionTypeLabel.toLowerCase()}`
              );
              onBreakpointHit(exception);
            } else {
              addLog(
                "DEBUG",
                "EXCEPTION",
                "No onBreakpointHit callback available"
              );
            }
          });
        } else if (traceBreakpoints.length > 0) {
          addLog(
            "DEBUG",
            "EXCEPTION",
            `Skipping ${traceBreakpoints.length} trace exceptions from breakpoint callback`
          );
        }

        // Check for signal exceptions
        if (enableSignals && signals.length > 0) {
          addLog(
            "WARN",
            "EXCEPTION",
            `Processing signal exceptions (${signals.length})`,
            signals.map((s) => ({
              type: s.type,
              address: s.address,
              thread_id: s.thread_id,
            }))
          );

          setSignalExceptions(signals);

          signals.forEach((exception) => {
            const signalName = exception.type.toUpperCase();
            addLog(
              "ERROR",
              "EXCEPTION",
              `${signalName} at ${exception.address}: ${exception.instruction}`,
              {
                thread_id: exception.thread_id,
                memory_address: exception.memory_address,
              }
            );

            if (onSignalHit) {
              onSignalHit(exception);
            }
          });
        }

        // Update all exceptions
        setAllExceptions(all);
        setLastCheckTime(new Date());
        setError(null);

        if (all.length > 0) {
          const tauriExceptions: TauriExceptionData[] = all.map((ex) => ({
            exception_type: ex.type,
            address: ex.address,
            instruction: ex.instruction,
            timestamp: ex.timestamp.toISOString(),
            thread_id: ex.thread_id,
            watchpoint_id: ex.watchpointId,
            memory_address: ex.memory_address,
            singlestep_mode: ex.singlestep_mode,
            registers: ex.context?.rawException || {},
            bytecode: ex.context?.bytecode,
            opcode: ex.context?.opcode,
            pc: ex.context?.pc,
          }));

          addLog("DEBUG", "EXCEPTION", "Saving exceptions to Tauri store:", {
            count: tauriExceptions.length,
            types: tauriExceptions.map((e) => e.exception_type),
            watchpoints: tauriExceptions.filter(
              (e) => e.exception_type === "watchpoint"
            ).length,
            breakpoints: tauriExceptions.filter(
              (e) => e.exception_type === "breakpoint"
            ).length,
          });

          addExceptionsToTauriStore(tauriExceptions).catch((error) => {
            console.error("Failed to save exceptions to Tauri store:", error);
            addLog(
              "ERROR",
              "EXCEPTION",
              "Failed to save to Tauri store:",
              error
            );
          });

          // Debug: Log all singlestep exceptions to see what we're getting
          const allSinglesteps = all.filter((ex) => ex.type === "singlestep");
          if (allSinglesteps.length > 0) {
            addLog(
              "DEBUG",
              "TRACING",
              `All singlestep exceptions (${allSinglesteps.length}):`,
              allSinglesteps.map((ex) => ({
                address: ex.address,
                type: ex.type,
                singlestep_mode: ex.singlestep_mode,
                instruction: ex.instruction,
              }))
            );
          }

          // Process singlestep exceptions for code tracing
          // singlestep_mode values:
          //   2 = Breakpoint (hardware breakpoint single step)
          //   4 = SoftwareBreakpoint (software breakpoint single step)
          // Also include singlestep exceptions with undefined mode (fallback)
          // AND include breakpoint exceptions (first hit in trace mode)
          let traceExceptions = all
            .filter(
              (ex) =>
                (ex.type === "singlestep" &&
                  (ex.singlestep_mode === 2 ||
                    ex.singlestep_mode === 4 ||
                    ex.singlestep_mode === undefined)) ||
                ex.type === "breakpoint" // Include breakpoint hits (first trace entry)
            )
            // Sort by timestamp to ensure correct order
            .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());

          if (traceExceptions.length > 0) {
            // Get trace session to check tracked_thread_id
            let traceSession: any = null;
            try {
              traceSession = await invoke("get_trace_session");
            } catch (err) {
              // No active trace session
            }

            // If we have a trace session
            if (traceSession && traceSession.is_active) {
              if (
                traceSession.tracked_thread_id === undefined ||
                traceSession.tracked_thread_id === null
              ) {
                const firstBreakpoint = traceExceptions.find(
                  (ex) => ex.type === "breakpoint" && ex.thread_id !== undefined
                );
                if (
                  firstBreakpoint &&
                  firstBreakpoint.thread_id !== undefined
                ) {
                  addLog(
                    "INFO",
                    "TRACING",
                    `Setting tracked thread to ${firstBreakpoint.thread_id} (first breakpoint hit)`
                  );
                  try {
                    await invoke("set_trace_tracked_thread", {
                      threadId: firstBreakpoint.thread_id,
                    });
                    // Update local reference
                    traceSession.tracked_thread_id = firstBreakpoint.thread_id;
                  } catch (err) {
                    addLog(
                      "ERROR",
                      "TRACING",
                      `Failed to set tracked thread: ${err}`
                    );
                  }
                }
              }

              if (
                traceSession.tracked_thread_id !== undefined &&
                traceSession.tracked_thread_id !== null
              ) {
                const trackedThreadId = traceSession.tracked_thread_id;
                const beforeCount = traceExceptions.length;
                traceExceptions = traceExceptions.filter(
                  (ex) => ex.thread_id === trackedThreadId
                );
                const afterCount = traceExceptions.length;
                if (beforeCount !== afterCount) {
                  addLog(
                    "DEBUG",
                    "TRACING",
                    `Filtered trace exceptions: ${beforeCount} -> ${afterCount} (tracked thread: ${trackedThreadId})`
                  );
                }
              }
            }

            addLog(
              "INFO",
              "TRACING",
              `Processing ${traceExceptions.length} trace exceptions (batch)`
            );

            // Debug: Log attachedModules status
            if (attachedModules.length === 0) {
              addLog(
                "WARN",
                "TRACING",
                "No attached modules available for library expression encoding"
              );
            } else {
              addLog(
                "DEBUG",
                "TRACING",
                `Using ${attachedModules.length} modules for library encoding`,
                attachedModules.map((m: any) => ({
                  name: m.modulename,
                  base: m.base,
                }))
              );
            }

            // Build all trace entries first, then send as batch
            const traceEntries: TauriTraceEntryData[] = [];

            for (const ex of traceExceptions) {
              const pcNum =
                typeof ex.pc === "number"
                  ? ex.pc
                  : typeof ex.pc === "string"
                    ? parseInt(ex.pc, 16)
                    : parseInt(ex.address.replace(/^0x/i, ""), 16);

              // Parse instruction to get opcode and operands
              let opcode = ex.context?.opcode || "unknown";
              let operands = "";

              if (ex.instruction && ex.instruction !== "unknown | unknown") {
                const parts = ex.instruction.split("|");
                if (parts.length >= 3) {
                  const opcodeAndOperands = parts[2].trim().split("\n")[0];
                  const match = opcodeAndOperands.match(/^(\S+)\s*(.*)?$/);
                  if (match) {
                    opcode = match[1];
                    operands = match[2] || "";
                  }
                }
              }

              // Determine call/return based on opcode (ARM64)
              const opcodeUpper = opcode.toUpperCase();
              const isCall =
                opcodeUpper.startsWith("BL") &&
                !["BLT", "BLE", "BLS"].includes(opcodeUpper);
              const isReturn = opcodeUpper.startsWith("RET");

              // Update depth
              if (isReturn && globalTraceDepth > 0) globalTraceDepth--;
              const entryDepth = globalTraceDepth;
              if (isCall) globalTraceDepth++;

              // Build register map
              const registers: Record<string, string> = {};
              for (let i = 0; i <= 29; i++) {
                const regName = `x${i}`;
                const val = (ex as any)[regName];
                if (val !== undefined) {
                  registers[regName] =
                    typeof val === "number"
                      ? `0x${val.toString(16)}`
                      : String(val);
                }
              }
              ["lr", "fp", "sp", "pc", "cpsr"].forEach((regName) => {
                const val = (ex as any)[regName];
                if (val !== undefined) {
                  registers[regName] =
                    typeof val === "number"
                      ? `0x${val.toString(16)}`
                      : String(val);
                }
              });

              const traceEntry: TauriTraceEntryData = {
                id: ++globalTraceEntryId, // Will be reassigned by backend
                address: ex.address,
                instruction: ex.instruction,
                opcode: opcode,
                operands: operands,
                registers: registers,
                depth: entryDepth,
                is_call: isCall,
                is_return: isReturn,
                function_name: undefined,
                timestamp: ex.timestamp.getTime(), // Use exception timestamp for dedup
                library_expression:
                  encodeAddressToLibraryExpression(
                    pcNum,
                    attachedModules,
                    true
                  ) || undefined,
                target_address: "", // Will be determined by active session
              };

              traceEntries.push(traceEntry);
            }

            // Send all entries as a single batch
            if (traceEntries.length > 0) {
              invoke("add_trace_entries_batch", {
                entries: traceEntries,
              }).catch((err) => {
                console.error("Failed to add trace entries batch:", err);
              });
            }
          }
        }
      } else {
        const errorMsg = response.message || "Failed to fetch exceptions";
        addLog("ERROR", "EXCEPTION", "Failed to fetch exceptions:", errorMsg);
        setError(errorMsg);
        if (onError) {
          onError(errorMsg);
        }
      }
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : "Unknown error";
      addLog("ERROR", "EXCEPTION", "Exception check failed:", {
        error: errorMsg,
        fullError: error,
      });
      setError(errorMsg);
      if (onError) {
        onError(errorMsg);
      }
    } finally {
      // Always reset polling flag when done
      isPollingRef.current = false;
    }
  }, [
    processExceptions,
    enableWatchpoints,
    enableBreakpoints,
    enableSignals,
    onWatchpointHit,
    onBreakpointHit,
    onSignalHit,
    onError,
    isConnected,
    isProcessAttached,
    hasActiveWatchpoints,
    hasActiveBreakpoints,
  ]);

  // Start monitoring
  const startMonitoring = useCallback(() => {
    if (isMonitoring) {
      // Don't log if already monitoring to reduce noise
      return;
    }

    const isMainInstance = globalState.addInstance(hookInstanceId.current);

    if (!isMainInstance) {
      addLog(
        "DEBUG",
        "EXCEPTION",
        `[${hookInstanceId.current}] Monitoring already active by instance ${globalState.mainInstanceId}, joining as secondary`
      );
      setIsMonitoring(true);
      isMonitoringRef.current = true;
      return;
    }

    // This instance becomes the main monitoring instance
    addLog(
      "INFO",
      "EXCEPTION",
      `[${hookInstanceId.current}] Starting exception monitoring (main instance)`,
      {
        watchpoints: enableWatchpoints,
        breakpoints: enableBreakpoints,
        pollingInterval,
      }
    );
    setIsMonitoring(true);
    isMonitoringRef.current = true;

    // Clear any existing interval
    if (intervalRef.current) {
      window.clearInterval(intervalRef.current);
    }

    // Start polling
    intervalRef.current = window.setInterval(() => {
      checkForExceptions();
    }, pollingInterval);

    // Store interval in global state
    globalState.setInterval(intervalRef.current);

    addLog(
      "INFO",
      "EXCEPTION",
      `[${hookInstanceId.current}] Exception monitoring started with interval ${pollingInterval}ms`,
      {
        intervalId: intervalRef.current,
      }
    );

    // Initial check
    checkForExceptions();
  }, [
    isMonitoring,
    checkForExceptions,
    pollingInterval,
    enableWatchpoints,
    enableBreakpoints,
    globalState,
  ]);

  // Stop monitoring
  const stopMonitoring = useCallback(() => {
    if (!isMonitoring) {
      // Don't log if not monitoring to reduce noise
      return;
    }

    const wasLastInstance = globalState.removeInstance(hookInstanceId.current);

    if (wasLastInstance) {
      addLog(
        "INFO",
        "EXCEPTION",
        `[${hookInstanceId.current}] Stopping exception monitoring (last instance)`
      );
    } else if (globalState.mainInstanceId === hookInstanceId.current) {
      addLog(
        "INFO",
        "EXCEPTION",
        `[${hookInstanceId.current}] Transferring monitoring control to another instance`
      );
    } else {
      addLog(
        "DEBUG",
        "EXCEPTION",
        `[${hookInstanceId.current}] Stopping secondary monitoring instance`
      );
    }

    setIsMonitoring(false);
    isMonitoringRef.current = false;

    // Clear local interval reference
    if (intervalRef.current) {
      intervalRef.current = null;
    }
  }, [isMonitoring, globalState]);

  // Clear exceptions
  const clearExceptions = useCallback(() => {
    setWatchpointExceptions([]);
    setBreakpointExceptions([]);
    setAllExceptions([]);
    setError(null);
  }, []);

  // Clear specific exception types
  const clearWatchpointExceptions = useCallback(() => {
    setWatchpointExceptions([]);
    // Update all exceptions by removing watchpoint exceptions
    setAllExceptions((prev) => prev.filter((ex) => ex.type !== "watchpoint"));
  }, []);

  const clearBreakpointExceptions = useCallback(() => {
    setBreakpointExceptions([]);
    // Update all exceptions by removing breakpoint exceptions
    setAllExceptions((prev) => prev.filter((ex) => ex.type !== "breakpoint"));
  }, []);

  // Manual check (useful for immediate checking after setting watchpoint/breakpoint)
  const checkNow = useCallback(() => {
    checkForExceptions();
  }, [checkForExceptions]);

  // Auto-start monitoring when component mounts if autoStart is true
  useEffect(() => {
    // Only auto-start if we have the necessary conditions
    // Note: For breakpoints, we always monitor when enableBreakpoints is true
    // because breakpoints are managed server-side and can be hit at any time
    // (e.g., trace breakpoints set via startTraceSession)
    const shouldAutoStart =
      autoStart &&
      isConnected &&
      isProcessAttached &&
      ((enableWatchpoints && hasActiveWatchpoints) || enableBreakpoints); // Always monitor for breakpoints when enabled

    const currentlyMonitoring = isMonitoringRef.current;

    // Only log when actually starting or stopping monitoring, not on every condition check
    if (shouldAutoStart && !currentlyMonitoring) {
      addLog(
        "INFO",
        "EXCEPTION",
        `[${hookInstanceId.current}] Auto-starting monitoring`,
        {
          autoStart,
          isConnected,
          isProcessAttached,
          enableWatchpoints,
          enableBreakpoints,
          hasActiveWatchpoints,
          hasActiveBreakpoints,
        }
      );
      startMonitoring();
    } else if (!shouldAutoStart && currentlyMonitoring) {
      addLog(
        "INFO",
        "EXCEPTION",
        `[${hookInstanceId.current}] Auto-stopping monitoring - conditions not met`,
        {
          autoStart,
          isConnected,
          isProcessAttached,
          enableWatchpoints,
          enableBreakpoints,
        }
      );
      stopMonitoring();
    }
  }, [
    autoStart,
    enableWatchpoints,
    enableBreakpoints,
    isConnected,
    isProcessAttached,
    hasActiveWatchpoints,
    hasActiveBreakpoints,
    startMonitoring,
    stopMonitoring,
  ]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      // Only cleanup if we were actually monitoring
      if (intervalRef.current) {
        addLog(
          "DEBUG",
          "EXCEPTION",
          `[${hookInstanceId.current}] Component unmount: stopping monitoring`
        );

        // Remove from global state
        globalState.removeInstance(hookInstanceId.current);

        // Clear interval
        window.clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
    };
  }, []);

  return {
    // State
    isMonitoring,
    watchpointExceptions,
    breakpointExceptions,
    signalExceptions,
    allExceptions,
    lastCheckTime,
    error,

    // Actions
    startMonitoring,
    stopMonitoring,
    clearExceptions,
    clearWatchpointExceptions,
    clearBreakpointExceptions,
    checkNow,
  };
};

```

`src/client/src/hooks/useGhidraAnalysis.ts`:

```ts
import { useState, useCallback, useRef, useEffect } from "react";
import { invoke } from "@tauri-apps/api/core";
import { useUIStore } from "../stores/uiStore";

export interface GhidraAnalysisStatus {
  library_path: string;
  analyzed: boolean;
  project_path: string | null;
  error: string | null;
}

export interface GhidraTokenInfo {
  text: string;
  line: number;
  col_start: number;
  col_end: number;
  token_type: "function" | "variable" | "type" | "field" | "data" | "unknown";
  target_offset?: string; // For function calls - offset of the called function
  target_name?: string; // For function calls - name of the called function
  var_name?: string; // For variables
  data_type?: string; // For variables/types
  is_parameter?: boolean; // For variables
}

export interface GhidraDecompileResult {
  success: boolean;
  function_name: string | null;
  address: string | null;
  decompiled_code: string | null;
  line_mapping: Record<string, string> | null; // line number (as string) -> offset (hex string)
  tokens?: GhidraTokenInfo[] | null; // Token information for syntax highlighting
  error: string | null;
}

export interface XrefEntry {
  from_address: string;
  from_function: string | null;
  from_function_offset?: string | null;
  ref_type: string;
  instruction?: string | null;
}

export interface GhidraXrefsResult {
  success: boolean;
  target_function: string;
  target_address: string;
  xrefs: XrefEntry[];
  error: string | null;
}

export interface GhidraFunctionEntry {
  name: string;
  address: string; // offset from image base as hex string
  size: number;
}

export interface GhidraFunctionListResult {
  success: boolean;
  functions: GhidraFunctionEntry[];
  error: string | null;
}

export interface GhidraVariableInfo {
  name: string;
  data_type: string;
  storage: string;
  is_parameter: boolean;
  size: number;
}

export interface GhidraCalledFunction {
  name: string;
  offset: string;
}

export interface GhidraFunctionInfoResult {
  success: boolean;
  function_name: string | null;
  function_offset: string | null;
  variables: GhidraVariableInfo[];
  called_functions: GhidraCalledFunction[];
  error: string | null;
}

// CFG (Control Flow Graph) types from Ghidra analysis
export interface GhidraCfgInstruction {
  address: string;
  bytes: string;
  opcode: string;
  operands: string;
}

export interface GhidraCfgBlock {
  id: string;
  startAddress: string;
  endAddress: string;
  instructions: GhidraCfgInstruction[];
  successors: string[];
  predecessors: string[];
  isEntry: boolean;
  isExit: boolean;
}

export interface GhidraCfgEdge {
  from: string;
  to: string;
  type: string; // "normal" | "conditional-true" | "conditional-false" | "unconditional"
}

export interface GhidraCfgResult {
  success: boolean;
  function_name: string | null;
  function_offset: string | null;
  blocks: GhidraCfgBlock[];
  edges: GhidraCfgEdge[];
  error: string | null;
}

// Block reachability analysis types (Z3-based)
export interface BlockReachability {
  blockId: string;
  startAddress: string;
  endAddress: string;
  status: "current" | "reachable" | "unreachable" | "conditional" | "unknown";
  condition: string;
  probability?: number;
  pathConditions?: string[];
}

export interface ReachabilityResult {
  success: boolean;
  functionName: string | null;
  functionOffset: string | null;
  currentBlock: string | null;
  blocks: BlockReachability[];
  error: string | null;
}

// Ghidra Data item types
export interface GhidraDataItem {
  address: string;
  name: string | null;
  type: string;
  category:
    | "string"
    | "pointer"
    | "integer"
    | "float"
    | "struct"
    | "array"
    | "other";
  size: number;
  value: string | null;
}

export interface GhidraDataResult {
  success: boolean;
  data: GhidraDataItem[];
  total: number;
  truncated: boolean;
  error: string | null;
}

interface AnalyzedLibrary {
  libraryPath: string;
  localPath: string;
  projectPath: string;
  analyzedAt: number;
  functions?: GhidraFunctionEntry[]; // Cached function list
}

const ANALYZED_LIBS_KEY = "dynadbg_analyzed_libraries";

export const useGhidraAnalysis = () => {
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [isDecompiling, setIsDecompiling] = useState(false);
  const [analysisProgress, setAnalysisProgress] = useState<string>("");
  const [analyzedLibraries, setAnalyzedLibraries] = useState<
    Map<string, AnalyzedLibrary>
  >(new Map());
  const [lastDecompileResult, setLastDecompileResult] =
    useState<GhidraDecompileResult | null>(null);

  // Server state from uiStore for persistence
  const toolsState = useUIStore((state) => state.toolsState);
  const updateToolsState = useUIStore(
    (state) => state.actions.updateToolsState
  );

  const serverRunning = toolsState.ghidraServerStatus === "running";
  const serverPort = toolsState.ghidraServerPort;
  const serverProjectPath = toolsState.ghidraServerProjectPath;

  const abortControllerRef = useRef<AbortController | null>(null);

  // Load analyzed libraries from localStorage
  useEffect(() => {
    try {
      const savedLibs = localStorage.getItem(ANALYZED_LIBS_KEY);
      if (savedLibs) {
        const libsArray: AnalyzedLibrary[] = JSON.parse(savedLibs);
        const libsMap = new Map<string, AnalyzedLibrary>();
        libsArray.forEach((lib) => libsMap.set(lib.libraryPath, lib));
        setAnalyzedLibraries(libsMap);
      }
    } catch (e) {
      console.error("Failed to load Ghidra analyzed libraries:", e);
    }
  }, []);

  // Save analyzed libraries to localStorage
  const saveAnalyzedLibraries = useCallback(
    (libs: Map<string, AnalyzedLibrary>) => {
      const libsArray = Array.from(libs.values());
      localStorage.setItem(ANALYZED_LIBS_KEY, JSON.stringify(libsArray));
      setAnalyzedLibraries(libs);
    },
    []
  );

  // Check if a library is already analyzed
  const isLibraryAnalyzed = useCallback(
    (libraryPath: string): boolean => {
      if (!libraryPath) return false;
      // Normalize path for comparison
      const normalizedPath = libraryPath.replace(/\\/g, "/").toLowerCase();

      // First try exact path match
      for (const [key] of analyzedLibraries) {
        if (key.replace(/\\/g, "/").toLowerCase() === normalizedPath) {
          return true;
        }
      }

      // Then try matching by filename only
      const getFileName = (p: string) => {
        const parts = p.replace(/\\/g, "/").split("/");
        return parts[parts.length - 1].toLowerCase();
      };
      const targetFileName = getFileName(libraryPath);

      for (const [key] of analyzedLibraries) {
        if (getFileName(key) === targetFileName) {
          return true;
        }
      }

      return false;
    },
    [analyzedLibraries]
  );

  // Get analyzed library info
  const getAnalyzedLibraryInfo = useCallback(
    (libraryPath: string): AnalyzedLibrary | null => {
      if (!libraryPath) return null;
      const normalizedPath = libraryPath.replace(/\\/g, "/").toLowerCase();

      // First try exact path match
      for (const [key, value] of analyzedLibraries) {
        if (key.replace(/\\/g, "/").toLowerCase() === normalizedPath) {
          return value;
        }
      }

      // Then try matching by filename only
      const getFileName = (p: string) => {
        const parts = p.replace(/\\/g, "/").split("/");
        return parts[parts.length - 1].toLowerCase();
      };
      const targetFileName = getFileName(libraryPath);

      for (const [key, value] of analyzedLibraries) {
        if (getFileName(key) === targetFileName) {
          return value;
        }
      }

      return null;
    },
    [analyzedLibraries]
  );

  // Download library from server
  const downloadLibrary = useCallback(
    async (remoteLibraryPath: string): Promise<string | null> => {
      try {
        setAnalysisProgress("Downloading library from server...");
        const localPath = await invoke<string>("download_library_file", {
          libraryPath: remoteLibraryPath,
        });
        return localPath;
      } catch (e) {
        console.error("Failed to download library:", e);
        setAnalysisProgress(`Error: Failed to download library - ${e}`);
        return null;
      }
    },
    []
  );

  // Analyze library with Ghidra
  const analyzeLibrary = useCallback(
    async (
      remoteLibraryPath: string,
      ghidraPath: string
    ): Promise<GhidraAnalysisStatus | null> => {
      console.log("[useGhidraAnalysis] analyzeLibrary called");
      console.log("[useGhidraAnalysis] remoteLibraryPath:", remoteLibraryPath);
      console.log("[useGhidraAnalysis] ghidraPath:", ghidraPath);

      if (!ghidraPath) {
        console.log("[useGhidraAnalysis] Error: Ghidra path not provided");
        setAnalysisProgress("Error: Ghidra path not provided");
        return null;
      }

      setIsAnalyzing(true);
      setAnalysisProgress("Starting analysis...");

      try {
        // Step 1: Download library
        console.log("[useGhidraAnalysis] Step 1: Downloading library...");
        const localPath = await downloadLibrary(remoteLibraryPath);
        console.log("[useGhidraAnalysis] Downloaded to localPath:", localPath);
        if (!localPath) {
          console.log("[useGhidraAnalysis] Download failed, localPath is null");
          setIsAnalyzing(false);
          return null;
        }

        // Step 2: Run Ghidra analysis
        console.log("[useGhidraAnalysis] Step 2: Running Ghidra analysis...");
        setAnalysisProgress(
          "Running Ghidra analysis (this may take several minutes)..."
        );
        console.log("[useGhidraAnalysis] Invoking analyze_with_ghidra with:", {
          localLibraryPath: localPath,
          ghidraPath: ghidraPath,
        });
        const result = await invoke<GhidraAnalysisStatus>(
          "analyze_with_ghidra",
          {
            localLibraryPath: localPath,
            ghidraPath: ghidraPath,
          }
        );
        console.log(
          "[useGhidraAnalysis] analyze_with_ghidra returned:",
          result
        );

        if (result.analyzed && result.project_path) {
          console.log(
            "[useGhidraAnalysis] Analysis succeeded, project_path:",
            result.project_path
          );
          // Save to analyzed libraries
          const newLibs = new Map(analyzedLibraries);
          newLibs.set(remoteLibraryPath, {
            libraryPath: remoteLibraryPath,
            localPath: localPath,
            projectPath: result.project_path,
            analyzedAt: Date.now(),
          });
          saveAnalyzedLibraries(newLibs);
          setAnalysisProgress("Analysis completed successfully!");
        } else {
          console.log(
            "[useGhidraAnalysis] Analysis failed, error:",
            result.error
          );
          setAnalysisProgress(
            `Analysis failed: ${result.error || "Unknown error"}`
          );
        }

        setIsAnalyzing(false);
        return result;
      } catch (e) {
        console.error("[useGhidraAnalysis] Exception during analysis:", e);
        setAnalysisProgress(`Error: ${e}`);
        setIsAnalyzing(false);
        return null;
      }
    },
    [downloadLibrary, analyzedLibraries, saveAnalyzedLibraries]
  );

  // Decompile a function
  const decompileFunction = useCallback(
    async (
      libraryPath: string,
      functionAddress: string,
      ghidraPath: string
    ): Promise<GhidraDecompileResult | null> => {
      if (!ghidraPath) {
        return {
          success: false,
          function_name: "",
          address: functionAddress,
          decompiled_code: null,
          line_mapping: null,
          error: "Ghidra path not provided",
        };
      }

      const libInfo = getAnalyzedLibraryInfo(libraryPath);
      if (!libInfo) {
        return {
          success: false,
          function_name: "",
          address: functionAddress,
          decompiled_code: null,
          line_mapping: null,
          error: "Library not analyzed. Please analyze with Ghidra first.",
        };
      }

      setIsDecompiling(true);

      try {
        // Extract library filename
        const pathParts = libraryPath.split(/[/\\]/);
        const libraryName = pathParts[pathParts.length - 1];

        // Check if server is running for this project
        if (serverRunning && serverProjectPath === libInfo.projectPath) {
          // Use fast server mode
          console.log("[Ghidra] Using server mode for decompile");
          const result = await invoke<GhidraDecompileResult>(
            "ghidra_server_decompile",
            {
              projectPath: libInfo.projectPath,
              functionAddress: functionAddress,
            }
          );
          setLastDecompileResult(result);
          setIsDecompiling(false);
          return result;
        }

        // Fallback to regular mode
        const result = await invoke<GhidraDecompileResult>("ghidra_decompile", {
          projectPath: libInfo.projectPath,
          libraryName: libraryName,
          functionAddress: functionAddress,
          ghidraPath: ghidraPath,
        });

        setLastDecompileResult(result);
        setIsDecompiling(false);
        return result;
      } catch (e) {
        console.error("Failed to decompile function:", e);
        const errorResult: GhidraDecompileResult = {
          success: false,
          function_name: "",
          address: functionAddress,
          decompiled_code: null,
          line_mapping: null,
          error: String(e),
        };
        setLastDecompileResult(errorResult);
        setIsDecompiling(false);
        return errorResult;
      }
    },
    [getAnalyzedLibraryInfo, serverRunning, serverProjectPath]
  );

  // Check analysis status (used to verify if analysis exists on disk)
  const checkAnalysisStatus = useCallback(
    async (libraryName: string): Promise<GhidraAnalysisStatus | null> => {
      try {
        const result = await invoke<GhidraAnalysisStatus>(
          "check_ghidra_analysis",
          {
            libraryName: libraryName,
          }
        );
        return result;
      } catch (e) {
        console.error("Failed to check analysis status:", e);
        return null;
      }
    },
    []
  );

  // Remove analyzed library from cache
  const removeAnalyzedLibrary = useCallback(
    (libraryPath: string) => {
      const newLibs = new Map(analyzedLibraries);
      const normalizedPath = libraryPath.replace(/\\/g, "/").toLowerCase();
      for (const [key] of analyzedLibraries) {
        if (key.replace(/\\/g, "/").toLowerCase() === normalizedPath) {
          newLibs.delete(key);
          break;
        }
      }
      saveAnalyzedLibraries(newLibs);
    },
    [analyzedLibraries, saveAnalyzedLibraries]
  );

  // Cancel ongoing analysis
  const cancelAnalysis = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }
    setIsAnalyzing(false);
    setIsDecompiling(false);
    setAnalysisProgress("Analysis cancelled");
  }, []);

  // Get cross-references to a function
  const getXrefs = useCallback(
    async (
      libraryPath: string,
      functionAddress: string,
      ghidraPath: string
    ): Promise<GhidraXrefsResult | null> => {
      if (!ghidraPath) {
        return {
          success: false,
          target_function: "",
          target_address: functionAddress,
          xrefs: [],
          error: "Ghidra path not provided",
        };
      }

      const libInfo = getAnalyzedLibraryInfo(libraryPath);
      if (!libInfo) {
        return {
          success: false,
          target_function: "",
          target_address: functionAddress,
          xrefs: [],
          error: "Library not analyzed. Please analyze with Ghidra first.",
        };
      }

      try {
        const pathParts = libraryPath.split(/[/\\]/);
        const libraryName = pathParts[pathParts.length - 1];

        // Check if server is running for this project
        if (serverRunning && serverProjectPath === libInfo.projectPath) {
          // Use fast server mode
          console.log("[Ghidra] Using server mode for xrefs");
          const result = await invoke<GhidraXrefsResult>(
            "ghidra_server_xrefs",
            {
              projectPath: libInfo.projectPath,
              functionAddress: functionAddress,
            }
          );
          return result;
        }

        // Fallback to regular mode
        const result = await invoke<GhidraXrefsResult>("ghidra_get_xrefs", {
          projectPath: libInfo.projectPath,
          libraryName: libraryName,
          functionAddress: functionAddress,
          ghidraPath: ghidraPath,
        });

        return result;
      } catch (e) {
        console.error("Failed to get xrefs:", e);
        return {
          success: false,
          target_function: "",
          target_address: functionAddress,
          xrefs: [],
          error: String(e),
        };
      }
    },
    [getAnalyzedLibraryInfo, serverRunning, serverProjectPath]
  );

  // Save functions to SQLite database
  const saveFunctionsToDb = useCallback(
    async (
      targetOs: string,
      moduleName: string,
      functions: GhidraFunctionEntry[]
    ): Promise<boolean> => {
      try {
        const functionsJson = JSON.stringify(functions);
        await invoke("save_ghidra_functions", {
          targetOs,
          moduleName,
          functionsJson,
        });
        return true;
      } catch (e) {
        console.error("Failed to save functions to SQLite:", e);
        return false;
      }
    },
    []
  );

  // Load functions from SQLite database
  const loadFunctionsFromDb = useCallback(
    async (
      targetOs: string,
      moduleName: string
    ): Promise<GhidraFunctionEntry[] | null> => {
      try {
        const functionsJson = await invoke<string | null>(
          "get_ghidra_functions",
          {
            targetOs,
            moduleName,
          }
        );
        if (functionsJson) {
          return JSON.parse(functionsJson) as GhidraFunctionEntry[];
        }
        return null;
      } catch (e) {
        console.error("Failed to load functions from SQLite:", e);
        return null;
      }
    },
    []
  );

  // Get function list from an analyzed library
  const getFunctions = useCallback(
    async (
      libraryPath: string,
      ghidraPath: string,
      targetOs?: string
    ): Promise<GhidraFunctionListResult | null> => {
      if (!ghidraPath) {
        return {
          success: false,
          functions: [],
          error: "Ghidra path not provided",
        };
      }

      const libInfo = getAnalyzedLibraryInfo(libraryPath);
      if (!libInfo) {
        return {
          success: false,
          functions: [],
          error: "Library not analyzed. Please analyze with Ghidra first.",
        };
      }

      const pathParts = libraryPath.split(/[/\\]/);
      const libraryName = pathParts[pathParts.length - 1];
      const osKey = targetOs || "unknown";

      // Check if we have cached functions in SQLite first
      const cachedFunctions = await loadFunctionsFromDb(osKey, libraryName);
      if (cachedFunctions && cachedFunctions.length > 0) {
        // Also update in-memory cache
        const newLibs = new Map(analyzedLibraries);
        const normalizedPath = libraryPath.replace(/\\/g, "/").toLowerCase();
        for (const [key, value] of analyzedLibraries) {
          if (key.replace(/\\/g, "/").toLowerCase() === normalizedPath) {
            newLibs.set(key, { ...value, functions: cachedFunctions });
            break;
          }
        }
        setAnalyzedLibraries(newLibs);

        return {
          success: true,
          functions: cachedFunctions,
          error: null,
        };
      }

      try {
        const result = await invoke<GhidraFunctionListResult>(
          "ghidra_get_functions",
          {
            projectPath: libInfo.projectPath,
            libraryName: libraryName,
            ghidraPath: ghidraPath,
          }
        );

        // Save to SQLite and update in-memory cache
        if (result.success && result.functions.length > 0) {
          await saveFunctionsToDb(osKey, libraryName, result.functions);

          const newLibs = new Map(analyzedLibraries);
          const normalizedPath = libraryPath.replace(/\\/g, "/").toLowerCase();
          for (const [key, value] of analyzedLibraries) {
            if (key.replace(/\\/g, "/").toLowerCase() === normalizedPath) {
              newLibs.set(key, { ...value, functions: result.functions });
              break;
            }
          }
          setAnalyzedLibraries(newLibs);
        }

        return result;
      } catch (e) {
        console.error("Failed to get functions:", e);
        return {
          success: false,
          functions: [],
          error: String(e),
        };
      }
    },
    [
      getAnalyzedLibraryInfo,
      analyzedLibraries,
      loadFunctionsFromDb,
      saveFunctionsToDb,
    ]
  );

  // Get cached functions for a library (without fetching from Ghidra)
  const getCachedFunctions = useCallback(
    (libraryPath: string): GhidraFunctionEntry[] | null => {
      const libInfo = getAnalyzedLibraryInfo(libraryPath);
      if (!libInfo || !libInfo.functions) {
        return null;
      }
      return libInfo.functions;
    },
    [getAnalyzedLibraryInfo]
  );

  // Get cached functions asynchronously (checks SQLite if not in memory)
  const getCachedFunctionsAsync = useCallback(
    async (
      libraryPath: string,
      targetOs?: string
    ): Promise<GhidraFunctionEntry[] | null> => {
      // First check in-memory cache
      const libInfo = getAnalyzedLibraryInfo(libraryPath);
      if (libInfo?.functions && libInfo.functions.length > 0) {
        return libInfo.functions;
      }

      // Then check SQLite
      const pathParts = libraryPath.split(/[/\\]/);
      const libraryName = pathParts[pathParts.length - 1];
      const osKey = targetOs || "unknown";

      const dbFunctions = await loadFunctionsFromDb(osKey, libraryName);
      if (dbFunctions && dbFunctions.length > 0) {
        // Update in-memory cache
        if (libInfo) {
          const newLibs = new Map(analyzedLibraries);
          const normalizedPath = libraryPath.replace(/\\/g, "/").toLowerCase();
          for (const [key, value] of analyzedLibraries) {
            if (key.replace(/\\/g, "/").toLowerCase() === normalizedPath) {
              newLibs.set(key, { ...value, functions: dbFunctions });
              break;
            }
          }
          setAnalyzedLibraries(newLibs);
        }
        return dbFunctions;
      }

      return null;
    },
    [getAnalyzedLibraryInfo, loadFunctionsFromDb, analyzedLibraries]
  );

  // Resolve function name from offset
  const resolveFunctionName = useCallback(
    (libraryPath: string, offset: number): string | null => {
      const functions = getCachedFunctions(libraryPath);
      if (!functions) return null;

      const offsetHex = `0x${offset.toString(16)}`;

      // First try exact match
      const exactMatch = functions.find((f) => f.address === offsetHex);
      if (exactMatch) return exactMatch.name;

      // Then try to find function containing this offset
      for (const func of functions) {
        const funcOffset = parseInt(func.address, 16);
        if (offset >= funcOffset && offset < funcOffset + func.size) {
          return func.name;
        }
      }

      return null;
    },
    [getCachedFunctions]
  );

  // Save decompile result to cache
  const saveDecompileToCache = useCallback(
    async (
      targetOs: string,
      moduleName: string,
      functionAddress: string,
      functionName: string,
      decompiledCode: string,
      lineMapping?: Record<number, string> | null
    ): Promise<boolean> => {
      try {
        const lineMappingJson = lineMapping
          ? JSON.stringify(lineMapping)
          : null;
        await invoke("save_decompile_cache", {
          targetOs,
          moduleName,
          functionAddress,
          functionName,
          decompiledCode,
          lineMappingJson,
        });
        return true;
      } catch (e) {
        console.error("Failed to save decompile to cache:", e);
        return false;
      }
    },
    []
  );

  // Get decompile result from cache
  const getDecompileFromCache = useCallback(
    async (
      targetOs: string,
      moduleName: string,
      functionAddress: string
    ): Promise<GhidraDecompileResult | null> => {
      try {
        const result = await invoke<GhidraDecompileResult | null>(
          "get_decompile_cache",
          {
            targetOs,
            moduleName,
            functionAddress,
          }
        );
        return result;
      } catch (e) {
        console.error("Failed to get decompile from cache:", e);
        return null;
      }
    },
    []
  );

  // Save xref result to cache
  const saveXrefToCache = useCallback(
    async (
      targetOs: string,
      moduleName: string,
      functionAddress: string,
      functionName: string,
      xrefs: XrefEntry[]
    ): Promise<boolean> => {
      try {
        const xrefsJson = JSON.stringify(xrefs);
        await invoke("save_xref_cache", {
          targetOs,
          moduleName,
          functionAddress,
          functionName,
          xrefsJson,
        });
        return true;
      } catch (e) {
        console.error("Failed to save xref to cache:", e);
        return false;
      }
    },
    []
  );

  // Get xref result from cache
  const getXrefFromCache = useCallback(
    async (
      targetOs: string,
      moduleName: string,
      functionAddress: string
    ): Promise<GhidraXrefsResult | null> => {
      try {
        const result = await invoke<GhidraXrefsResult | null>(
          "get_xref_cache",
          {
            targetOs,
            moduleName,
            functionAddress,
          }
        );
        return result;
      } catch (e) {
        console.error("Failed to get xref from cache:", e);
        return null;
      }
    },
    []
  );

  // Start Ghidra HTTP server for fast decompile/xref
  const startGhidraServer = useCallback(
    async (
      projectPath: string,
      libraryName: string,
      ghidraPath: string,
      port: number = 18462
    ): Promise<boolean> => {
      try {
        const result = await invoke<boolean>("start_ghidra_server", {
          projectPath,
          libraryName,
          ghidraPath,
          port,
        });
        if (result) {
          updateToolsState({
            ghidraServerStatus: "running",
            ghidraServerPort: port,
            ghidraServerProjectPath: projectPath,
          });
        }
        return result;
      } catch (e) {
        console.error("Failed to start Ghidra server:", e);
        return false;
      }
    },
    [updateToolsState]
  );

  // Stop Ghidra server
  const stopGhidraServer = useCallback(
    async (projectPath: string): Promise<boolean> => {
      try {
        const result = await invoke<boolean>("stop_ghidra_server", {
          projectPath,
        });
        if (result) {
          updateToolsState({
            ghidraServerStatus: "stopped",
            ghidraServerPort: null,
            ghidraServerProjectPath: null,
          });
        }
        return result;
      } catch (e) {
        console.error("Failed to stop Ghidra server:", e);
        return false;
      }
    },
    [updateToolsState]
  );

  // Check if Ghidra server is running
  const checkGhidraServer = useCallback(
    async (projectPath: string): Promise<number | null> => {
      try {
        const port = await invoke<number | null>("check_ghidra_server", {
          projectPath,
        });
        if (port !== null) {
          updateToolsState({
            ghidraServerStatus: "running",
            ghidraServerPort: port,
            ghidraServerProjectPath: projectPath,
          });
        } else {
          updateToolsState({
            ghidraServerStatus: "stopped",
            ghidraServerPort: null,
            ghidraServerProjectPath: null,
          });
        }
        return port;
      } catch (e) {
        console.error("Failed to check Ghidra server:", e);
        return null;
      }
    },
    [updateToolsState]
  );

  // Fast decompile using running Ghidra server
  const serverDecompile = useCallback(
    async (
      projectPath: string,
      functionAddress: string
    ): Promise<GhidraDecompileResult | null> => {
      try {
        const result = await invoke<GhidraDecompileResult>(
          "ghidra_server_decompile",
          {
            projectPath,
            functionAddress,
          }
        );
        return result;
      } catch (e) {
        console.error("Server decompile failed:", e);
        return null;
      }
    },
    []
  );

  // Fast xrefs using running Ghidra server
  const serverXrefs = useCallback(
    async (
      projectPath: string,
      functionAddress: string
    ): Promise<GhidraXrefsResult | null> => {
      try {
        const result = await invoke<GhidraXrefsResult>("ghidra_server_xrefs", {
          projectPath,
          functionAddress,
        });
        return result;
      } catch (e) {
        console.error("Server xrefs failed:", e);
        return null;
      }
    },
    []
  );

  // Get function info (variables and called functions) using running Ghidra server
  const getFunctionInfo = useCallback(
    async (
      libraryPath: string,
      functionAddress: string
    ): Promise<GhidraFunctionInfoResult | null> => {
      const libInfo = getAnalyzedLibraryInfo(libraryPath);
      if (!libInfo) {
        return {
          success: false,
          function_name: null,
          function_offset: null,
          variables: [],
          called_functions: [],
          error: "Library not analyzed. Please analyze with Ghidra first.",
        };
      }

      // Check if server is running for this project
      if (serverRunning && serverProjectPath === libInfo.projectPath) {
        try {
          const result = await invoke<GhidraFunctionInfoResult>(
            "ghidra_server_function_info",
            {
              projectPath: libInfo.projectPath,
              functionAddress,
            }
          );
          return result;
        } catch (e) {
          console.error("Server function info failed:", e);
          return {
            success: false,
            function_name: null,
            function_offset: null,
            variables: [],
            called_functions: [],
            error: String(e),
          };
        }
      }

      return {
        success: false,
        function_name: null,
        function_offset: null,
        variables: [],
        called_functions: [],
        error: "Ghidra server not running. Please start the server first.",
      };
    },
    [getAnalyzedLibraryInfo, serverRunning, serverProjectPath]
  );

  // Get CFG (Control Flow Graph) for a function using running Ghidra server
  const getCfg = useCallback(
    async (
      libraryPath: string,
      functionAddress: string
    ): Promise<GhidraCfgResult | null> => {
      const libInfo = getAnalyzedLibraryInfo(libraryPath);
      if (!libInfo) {
        return {
          success: false,
          function_name: null,
          function_offset: null,
          blocks: [],
          edges: [],
          error: "Library not analyzed. Please analyze with Ghidra first.",
        };
      }

      // Check if server is running for this project
      if (serverRunning && serverProjectPath === libInfo.projectPath) {
        try {
          console.log("[Ghidra] Getting CFG for function at", functionAddress);
          const result = await invoke<GhidraCfgResult>("ghidra_server_cfg", {
            projectPath: libInfo.projectPath,
            functionAddress,
          });
          console.log("[Ghidra] CFG result:", result);
          return result;
        } catch (e) {
          console.error("Server CFG failed:", e);
          return {
            success: false,
            function_name: null,
            function_offset: null,
            blocks: [],
            edges: [],
            error: String(e),
          };
        }
      }

      return {
        success: false,
        function_name: null,
        function_offset: null,
        blocks: [],
        edges: [],
        error: "Ghidra server not running. Please start the server first.",
      };
    },
    [getAnalyzedLibraryInfo, serverRunning, serverProjectPath]
  );

  // Get Data items (strings, variables, constants) using running Ghidra server
  const getData = useCallback(
    async (libraryPath: string): Promise<GhidraDataResult | null> => {
      const libInfo = getAnalyzedLibraryInfo(libraryPath);
      if (!libInfo) {
        return {
          success: false,
          data: [],
          total: 0,
          truncated: false,
          error: "Library not analyzed. Please analyze with Ghidra first.",
        };
      }

      // Check if server is running for this project
      if (serverRunning && serverProjectPath === libInfo.projectPath) {
        try {
          console.log("[Ghidra] Getting Data items for library", libraryPath);
          const result = await invoke<GhidraDataResult>("ghidra_server_data", {
            projectPath: libInfo.projectPath,
          });
          console.log("[Ghidra] Data result:", result);
          return result;
        } catch (e) {
          console.error("Server Data failed:", e);
          return {
            success: false,
            data: [],
            total: 0,
            truncated: false,
            error: String(e),
          };
        }
      }

      return {
        success: false,
        data: [],
        total: 0,
        truncated: false,
        error: "Ghidra server not running. Please start the server first.",
      };
    },
    [getAnalyzedLibraryInfo, serverRunning, serverProjectPath]
  );

  // Analyze block reachability using Z3 constraint solver
  // Register values are now passed from UI instead of fetching via API
  const analyzeReachability = useCallback(
    async (
      libraryPath: string,
      functionOffset: string,
      currentBlockOffset: string,
      dbgsrvUrl: string, // URL of dbgsrv for memory access
      authToken: string, // Authentication token for dbgsrv API
      ghidraPath: string,
      registersJson: string, // JSON string of register values from breakpoint UI (e.g., {"x0": "0x1234", ...})
      libraryBaseAddress: string // Base address of the library in memory (e.g., "0x71d7d93000")
    ): Promise<ReachabilityResult> => {
      const libInfo = getAnalyzedLibraryInfo(libraryPath);
      if (!libInfo) {
        return {
          success: false,
          functionName: null,
          functionOffset: null,
          currentBlock: null,
          blocks: [],
          error: "Library not analyzed. Please analyze with Ghidra first.",
        };
      }

      try {
        console.log(
          "[Ghidra] Analyzing reachability for block at",
          currentBlockOffset
        );
        console.log("[Ghidra] dbgsrv URL:", dbgsrvUrl);
        console.log("[Ghidra] Library base address:", libraryBaseAddress);
        console.log("[Ghidra] Registers JSON length:", registersJson.length);
        const result = await invoke<ReachabilityResult>(
          "ghidra_analyze_reachability",
          {
            projectPath: libInfo.projectPath,
            libraryName: libraryPath,
            functionOffset,
            currentBlockOffset,
            dbgsrvUrl,
            authToken,
            ghidraPath,
            registersJson,
            libraryBaseAddress,
          }
        );
        console.log("[Ghidra] Reachability result:", result);
        return result;
      } catch (e) {
        console.error("Reachability analysis failed:", e);
        return {
          success: false,
          functionName: null,
          functionOffset: null,
          currentBlock: null,
          blocks: [],
          error: String(e),
        };
      }
    },
    [getAnalyzedLibraryInfo]
  );

  return {
    // State
    isAnalyzing,
    isDecompiling,
    analysisProgress,
    analyzedLibraries,
    lastDecompileResult,
    // Server state
    serverRunning,
    serverPort,
    serverProjectPath,

    // Actions
    isLibraryAnalyzed,
    getAnalyzedLibraryInfo,
    analyzeLibrary,
    decompileFunction,
    getXrefs,
    getFunctions,
    getCachedFunctions,
    getCachedFunctionsAsync,
    saveFunctionsToDb,
    loadFunctionsFromDb,
    resolveFunctionName,
    checkAnalysisStatus,
    removeAnalyzedLibrary,
    cancelAnalysis,
    // Cache functions
    saveDecompileToCache,
    getDecompileFromCache,
    saveXrefToCache,
    getXrefFromCache,
    // Server mode functions
    startGhidraServer,
    stopGhidraServer,
    checkGhidraServer,
    serverDecompile,
    serverXrefs,
    getFunctionInfo,
    getCfg,
    getData,
    // Z3 reachability analysis
    analyzeReachability,
  };
};

export default useGhidraAnalysis;

```

`src/client/src/hooks/useGlobalDebugLogger.tsx`:

```tsx
import React, { createContext, useContext, useMemo } from "react";
import { useDebugLogger, LogLevel, LogEntry } from "./useDebugLogger";

interface DebugLoggerContextType {
  // Actions
  addLog: (
    level: LogLevel,
    category: string,
    message: string,
    data?: any
  ) => void;
  logDebug: (category: string, message: string, data?: any) => void;
  logInfo: (category: string, message: string, data?: any) => void;
  logWarn: (category: string, message: string, data?: any) => void;
  logError: (category: string, message: string, data?: any) => void;
  logException: (category: string, message: string, data?: any) => void;
  logRegister: (category: string, message: string, data?: any) => void;
  clearLogs: () => void;
  exportLogs: () => void;

  // State
  logs: LogEntry[];
  allLogs: LogEntry[];
  searchTerm: string;
  selectedLevel: LogLevel | "ALL";
  selectedCategory: string | "ALL";
  categories: string[];
  isDevelopment: boolean;

  // Filters
  setSearchTerm: (term: string) => void;
  setSelectedLevel: (level: LogLevel | "ALL") => void;
  setSelectedCategory: (category: string | "ALL") => void;
}

const DebugLoggerContext = createContext<DebugLoggerContextType | null>(null);

export const DebugLoggerProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const logger = useDebugLogger();

  // Memoize the context value to prevent unnecessary re-renders
  // Include all properties from the logger
  const contextValue = useMemo(
    () => ({
      // Actions
      addLog: logger.addLog,
      logDebug: logger.logDebug,
      logInfo: logger.logInfo,
      logWarn: logger.logWarn,
      logError: logger.logError,
      logException: logger.logException,
      logRegister: logger.logRegister,
      clearLogs: logger.clearLogs,
      exportLogs: logger.exportLogs,

      // State
      logs: logger.logs,
      allLogs: logger.allLogs,
      searchTerm: logger.searchTerm,
      selectedLevel: logger.selectedLevel,
      selectedCategory: logger.selectedCategory,
      categories: logger.categories,
      isDevelopment: logger.isDevelopment,

      // Filters
      setSearchTerm: logger.setSearchTerm,
      setSelectedLevel: logger.setSelectedLevel,
      setSelectedCategory: logger.setSelectedCategory,
    }),
    [
      logger.addLog,
      logger.logDebug,
      logger.logInfo,
      logger.logWarn,
      logger.logError,
      logger.logException,
      logger.logRegister,
      logger.clearLogs,
      logger.exportLogs,
      logger.logs,
      logger.allLogs,
      logger.searchTerm,
      logger.selectedLevel,
      logger.selectedCategory,
      logger.categories,
      logger.isDevelopment,
      logger.setSearchTerm,
      logger.setSelectedLevel,
      logger.setSelectedCategory,
    ]
  );

  return (
    <DebugLoggerContext.Provider value={contextValue}>
      {children}
    </DebugLoggerContext.Provider>
  );
};

export const useGlobalDebugLogger = (): DebugLoggerContextType => {
  const context = useContext(DebugLoggerContext);
  if (!context) {
    throw new Error(
      "useGlobalDebugLogger must be used within a DebugLoggerProvider"
    );
  }
  return context;
};

```

`src/client/src/hooks/useGlobalExceptionHandler.tsx`:

```tsx
import React, { createContext, useContext, useMemo } from "react";
import {
  useExceptionHandler,
  UseExceptionHandlerOptions,
  ProcessedException,
  ScriptBreakpointEvent,
} from "./useExceptionHandler";
import { useAppState } from "./useAppState";

interface GlobalExceptionHandlerContextType {
  // State
  isMonitoring: boolean;
  watchpointExceptions: ProcessedException[];
  breakpointExceptions: ProcessedException[];
  signalExceptions: ProcessedException[];
  allExceptions: ProcessedException[];
  lastCheckTime: Date | null;
  error: string | null;

  // Current thread exception (for thread switching back to current thread)
  currentThreadException: ProcessedException | null;

  // All stopped threads map (threadId -> exception)
  allStoppedThreads: Map<number, ProcessedException>;

  // Queued exceptions (from other threads while in break state)
  queuedBreakpointExceptions: ProcessedException[];
  queuedWatchpointExceptions: ProcessedException[];

  // Actions
  startMonitoring: () => void;
  stopMonitoring: () => void;
  clearExceptions: () => void;
  clearWatchpointExceptions: () => void;
  clearBreakpointExceptions: () => void;
  clearQueuedExceptions: () => void;
  clearAllStoppedThreads: () => void;
  processQueuedExceptions: () => void;
  checkNow: () => void;

  // Event handlers registration
  registerWatchpointHandler: (
    handler: (exception: ProcessedException) => void
  ) => void;
  unregisterWatchpointHandler: (
    handler: (exception: ProcessedException) => void
  ) => void;
  registerBreakpointHandler: (
    handler: (exception: ProcessedException) => void
  ) => void;
  unregisterBreakpointHandler: (
    handler: (exception: ProcessedException) => void
  ) => void;
  registerSignalHandler: (
    handler: (exception: ProcessedException) => void
  ) => void;
  unregisterSignalHandler: (
    handler: (exception: ProcessedException) => void
  ) => void;
  // Script breakpoint event handlers (from Lua scripts)
  registerScriptBreakpointHandler: (
    handler: (event: ScriptBreakpointEvent) => void
  ) => void;
  unregisterScriptBreakpointHandler: (
    handler: (event: ScriptBreakpointEvent) => void
  ) => void;
}

const GlobalExceptionHandlerContext =
  createContext<GlobalExceptionHandlerContextType | null>(null);

interface GlobalExceptionHandlerProviderProps {
  children: React.ReactNode;
  options?: UseExceptionHandlerOptions;
}

export const GlobalExceptionHandlerProvider: React.FC<
  GlobalExceptionHandlerProviderProps
> = ({ children, options = {} }) => {
  // Get break state and current thread from app state
  const { system } = useAppState();
  const isInBreakState = system.isInBreakState;
  const currentThreadId = system.currentThreadId;

  // All stopped thread exceptions map (threadId -> exception)
  const allStoppedThreadsRef = React.useRef<Map<number, ProcessedException>>(
    new Map()
  );
  const [allStoppedThreads, setAllStoppedThreads] = React.useState<
    Map<number, ProcessedException>
  >(new Map());

  // Current thread exception storage (for the currently active thread)
  const currentThreadExceptionRef = React.useRef<ProcessedException | null>(
    null
  );
  const [currentThreadException, setCurrentThreadException] =
    React.useState<ProcessedException | null>(null);

  // Queued exceptions storage (from other threads while in break state)
  const queuedBreakpointExceptionsRef = React.useRef<ProcessedException[]>([]);
  const queuedWatchpointExceptionsRef = React.useRef<ProcessedException[]>([]);
  const [queuedBreakpointExceptions, setQueuedBreakpointExceptions] =
    React.useState<ProcessedException[]>([]);
  const [queuedWatchpointExceptions, setQueuedWatchpointExceptions] =
    React.useState<ProcessedException[]>([]);

  // Refs to track current state for use in callbacks (avoid stale closure)
  const isInBreakStateRef = React.useRef(isInBreakState);
  const currentThreadIdRef = React.useRef(currentThreadId);

  // Keep refs in sync with state
  React.useEffect(() => {
    isInBreakStateRef.current = isInBreakState;
  }, [isInBreakState]);

  React.useEffect(() => {
    currentThreadIdRef.current = currentThreadId;
  }, [currentThreadId]);

  // Handler registration storage
  const watchpointHandlers = React.useRef<
    Set<(exception: ProcessedException) => void>
  >(new Set());
  const breakpointHandlers = React.useRef<
    Set<(exception: ProcessedException) => void>
  >(new Set());
  const signalHandlers = React.useRef<
    Set<(exception: ProcessedException) => void>
  >(new Set());
  const scriptBreakpointHandlers = React.useRef<
    Set<(event: ScriptBreakpointEvent) => void>
  >(new Set());

  // Global exception handler - use passed options
  const exceptionHandler = useExceptionHandler({
    pollingInterval: options.pollingInterval ?? 100,
    enableWatchpoints: options.enableWatchpoints ?? true,
    enableBreakpoints: options.enableBreakpoints ?? true,
    autoStart: options.autoStart ?? true,
    isConnected: options.isConnected,
    isProcessAttached: options.isProcessAttached,
    hasActiveWatchpoints: options.hasActiveWatchpoints,
    hasActiveBreakpoints: options.hasActiveBreakpoints,
    onScriptBreakpoint: (event) => {
      // Call all registered script breakpoint handlers
      console.log(
        `[EXCEPTION_HANDLER] Script breakpoint event: ${event.action} at 0x${event.address.toString(16)}`
      );

      // Call the handler passed via options (from MainApp)
      if (options.onScriptBreakpoint) {
        try {
          options.onScriptBreakpoint(event);
        } catch (error) {
          console.error("Error in options.onScriptBreakpoint:", error);
        }
      }

      // Also call all registered handlers
      scriptBreakpointHandlers.current.forEach((handler) => {
        try {
          handler(event);
        } catch (error) {
          console.error("Error in script breakpoint handler:", error);
        }
      });
    },
    onWatchpointHit: (exception) => {
      // Use refs to get current state (avoid stale closure)
      const inBreakState = isInBreakStateRef.current;
      const activeThreadId = currentThreadIdRef.current;

      // If not in break state, this is the first exception of a new break session
      // Clear old stopped threads to start fresh
      if (!inBreakState) {
        console.log(
          `[EXCEPTION_HANDLER] New break session (watchpoint) - clearing old stopped threads`
        );
        allStoppedThreadsRef.current.clear();
      }

      // Add to allStoppedThreads map if thread_id is available
      if (exception.thread_id !== undefined) {
        allStoppedThreadsRef.current.set(exception.thread_id, exception);
        setAllStoppedThreads(new Map(allStoppedThreadsRef.current));
        console.log(
          `[EXCEPTION_HANDLER] Added thread ${exception.thread_id} to allStoppedThreads (total: ${allStoppedThreadsRef.current.size})`
        );
      }

      // If in break state and exception is from a different thread, queue it (don't call handlers)
      if (
        inBreakState &&
        activeThreadId !== null &&
        activeThreadId !== undefined
      ) {
        if (
          exception.thread_id !== undefined &&
          exception.thread_id !== activeThreadId
        ) {
          console.log(
            `[EXCEPTION_HANDLER] Queuing watchpoint exception from thread ${exception.thread_id} (current: ${activeThreadId})`
          );
          queuedWatchpointExceptionsRef.current.push(exception);
          setQueuedWatchpointExceptions([
            ...queuedWatchpointExceptionsRef.current,
          ]);
          return;
        }
      }

      // First exception sets the break state immediately (for same-cycle processing)
      if (!inBreakState && exception.thread_id !== undefined) {
        console.log(
          `[EXCEPTION_HANDLER] First watchpoint exception - setting break state for thread ${exception.thread_id}`
        );
        isInBreakStateRef.current = true;
        currentThreadIdRef.current = exception.thread_id;
      }

      // Save current thread exception for thread switching
      currentThreadExceptionRef.current = exception;
      setCurrentThreadException(exception);

      // Call all registered watchpoint handlers
      watchpointHandlers.current.forEach((handler) => {
        try {
          handler(exception);
        } catch (error) {
          console.error("Error in watchpoint handler:", error);
        }
      });
    },
    onBreakpointHit: (exception) => {
      // Use refs to get current state (avoid stale closure)
      const inBreakState = isInBreakStateRef.current;
      const activeThreadId = currentThreadIdRef.current;

      // If not in break state, this is the first exception of a new break session
      // Clear old stopped threads to start fresh
      if (!inBreakState) {
        console.log(
          `[EXCEPTION_HANDLER] New break session (breakpoint) - clearing old stopped threads`
        );
        allStoppedThreadsRef.current.clear();
      }

      // Add to allStoppedThreads map if thread_id is available
      if (exception.thread_id !== undefined) {
        allStoppedThreadsRef.current.set(exception.thread_id, exception);
        setAllStoppedThreads(new Map(allStoppedThreadsRef.current));
        console.log(
          `[EXCEPTION_HANDLER] Added thread ${exception.thread_id} to allStoppedThreads (total: ${allStoppedThreadsRef.current.size})`
        );
      }

      // If in break state and exception is from a different thread, queue it (don't call handlers)
      if (
        inBreakState &&
        activeThreadId !== null &&
        activeThreadId !== undefined
      ) {
        if (
          exception.thread_id !== undefined &&
          exception.thread_id !== activeThreadId
        ) {
          console.log(
            `[EXCEPTION_HANDLER] Queuing breakpoint exception from thread ${exception.thread_id} (current: ${activeThreadId})`
          );
          queuedBreakpointExceptionsRef.current.push(exception);
          setQueuedBreakpointExceptions([
            ...queuedBreakpointExceptionsRef.current,
          ]);
          return;
        }
      }

      // First exception sets the break state immediately (for same-cycle processing)
      if (!inBreakState && exception.thread_id !== undefined) {
        console.log(
          `[EXCEPTION_HANDLER] First breakpoint exception - setting break state for thread ${exception.thread_id}`
        );
        isInBreakStateRef.current = true;
        currentThreadIdRef.current = exception.thread_id;
      }

      // Save current thread exception for thread switching
      currentThreadExceptionRef.current = exception;
      setCurrentThreadException(exception);

      // Call all registered breakpoint handlers
      breakpointHandlers.current.forEach((handler) => {
        try {
          handler(exception);
        } catch (error) {
          console.error("Error in breakpoint handler:", error);
        }
      });
    },
    enableSignals: options.enableSignals ?? true,
    onSignalHit: (exception) => {
      // Use refs to get current state (avoid stale closure)
      const inBreakState = isInBreakStateRef.current;

      // If not in break state, this is the first exception of a new break session
      // Clear old stopped threads to start fresh
      if (!inBreakState) {
        console.log(
          `[EXCEPTION_HANDLER] New break session (signal) - clearing old stopped threads`
        );
        allStoppedThreadsRef.current.clear();
      }

      // Add to allStoppedThreads map if thread_id is available
      if (exception.thread_id !== undefined) {
        allStoppedThreadsRef.current.set(exception.thread_id, exception);
        setAllStoppedThreads(new Map(allStoppedThreadsRef.current));
        console.log(
          `[EXCEPTION_HANDLER] Added thread ${exception.thread_id} to allStoppedThreads (signal: ${exception.type}, total: ${allStoppedThreadsRef.current.size})`
        );
      }

      // First exception sets the break state immediately
      if (!inBreakState && exception.thread_id !== undefined) {
        console.log(
          `[EXCEPTION_HANDLER] First signal exception (${exception.type}) - setting break state for thread ${exception.thread_id}`
        );
        isInBreakStateRef.current = true;
        currentThreadIdRef.current = exception.thread_id;
      }

      // Save current thread exception for thread switching
      currentThreadExceptionRef.current = exception;
      setCurrentThreadException(exception);

      // Call all registered signal handlers
      signalHandlers.current.forEach((handler) => {
        try {
          handler(exception);
        } catch (error) {
          console.error("Error in signal handler:", error);
        }
      });
    },
    // Note: Do NOT spread options here as it would override our callbacks
    // Other options like pollingInterval can be spread separately if needed
  });

  // Register the onBreakpointHit callback from options if provided
  React.useEffect(() => {
    console.log(
      "[EXCEPTION_HANDLER] useEffect for onBreakpointHit - options:",
      {
        hasOnBreakpointHit: !!options.onBreakpointHit,
        handlersCount: breakpointHandlers.current.size,
      }
    );
    if (options.onBreakpointHit) {
      console.log(
        "[EXCEPTION_HANDLER] Registering onBreakpointHit handler from options"
      );
      breakpointHandlers.current.add(options.onBreakpointHit);
      return () => {
        console.log("[BREAKPOINT HANDLER] Unregistering breakpoint handler");
        if (options.onBreakpointHit) {
          breakpointHandlers.current.delete(options.onBreakpointHit);
        }
      };
    }
  }, [options.onBreakpointHit]);

  // Register the onWatchpointHit callback from options if provided
  React.useEffect(() => {
    if (options.onWatchpointHit) {
      console.log(
        "[EXCEPTION_HANDLER] Registering onWatchpointHit handler from options"
      );
      watchpointHandlers.current.add(options.onWatchpointHit);
      return () => {
        if (options.onWatchpointHit) {
          watchpointHandlers.current.delete(options.onWatchpointHit);
        }
      };
    }
  }, [options.onWatchpointHit]);

  // Register the onSignalHit callback from options if provided
  React.useEffect(() => {
    if (options.onSignalHit) {
      console.log(
        "[EXCEPTION_HANDLER] Registering onSignalHit handler from options"
      );
      signalHandlers.current.add(options.onSignalHit);
      return () => {
        if (options.onSignalHit) {
          signalHandlers.current.delete(options.onSignalHit);
        }
      };
    }
  }, [options.onSignalHit]);

  // Handler registration functions
  const registerWatchpointHandler = React.useCallback(
    (handler: (exception: ProcessedException) => void) => {
      watchpointHandlers.current.add(handler);
    },
    []
  );

  const unregisterWatchpointHandler = React.useCallback(
    (handler: (exception: ProcessedException) => void) => {
      watchpointHandlers.current.delete(handler);
    },
    []
  );

  const registerBreakpointHandler = React.useCallback(
    (handler: (exception: ProcessedException) => void) => {
      breakpointHandlers.current.add(handler);
    },
    []
  );

  const unregisterBreakpointHandler = React.useCallback(
    (handler: (exception: ProcessedException) => void) => {
      breakpointHandlers.current.delete(handler);
    },
    []
  );

  const registerSignalHandler = React.useCallback(
    (handler: (exception: ProcessedException) => void) => {
      signalHandlers.current.add(handler);
    },
    []
  );

  const unregisterSignalHandler = React.useCallback(
    (handler: (exception: ProcessedException) => void) => {
      signalHandlers.current.delete(handler);
    },
    []
  );

  const registerScriptBreakpointHandler = React.useCallback(
    (handler: (event: ScriptBreakpointEvent) => void) => {
      scriptBreakpointHandlers.current.add(handler);
    },
    []
  );

  const unregisterScriptBreakpointHandler = React.useCallback(
    (handler: (event: ScriptBreakpointEvent) => void) => {
      scriptBreakpointHandlers.current.delete(handler);
    },
    []
  );

  // Clear queued exceptions
  const clearQueuedExceptions = React.useCallback(() => {
    queuedBreakpointExceptionsRef.current = [];
    queuedWatchpointExceptionsRef.current = [];
    setQueuedBreakpointExceptions([]);
    setQueuedWatchpointExceptions([]);
    console.log("[EXCEPTION_HANDLER] Cleared all queued exceptions");
  }, []);

  // Clear all stopped threads
  const clearAllStoppedThreads = React.useCallback(() => {
    allStoppedThreadsRef.current.clear();
    setAllStoppedThreads(new Map());
    currentThreadExceptionRef.current = null;
    setCurrentThreadException(null);
    // Reset break state refs
    isInBreakStateRef.current = false;
    currentThreadIdRef.current = undefined;
    clearQueuedExceptions();
    console.log(
      "[EXCEPTION_HANDLER] Cleared all stopped threads and reset break state"
    );
  }, [clearQueuedExceptions]);

  // Process queued exceptions (call handlers for all queued exceptions)
  const processQueuedExceptions = React.useCallback(() => {
    console.log(
      `[EXCEPTION_HANDLER] Processing ${queuedBreakpointExceptionsRef.current.length} queued breakpoint exceptions`
    );

    // Process queued breakpoint exceptions
    queuedBreakpointExceptionsRef.current.forEach((exception) => {
      breakpointHandlers.current.forEach((handler) => {
        try {
          handler(exception);
        } catch (error) {
          console.error(
            "Error in breakpoint handler for queued exception:",
            error
          );
        }
      });
    });

    // Process queued watchpoint exceptions
    queuedWatchpointExceptionsRef.current.forEach((exception) => {
      watchpointHandlers.current.forEach((handler) => {
        try {
          handler(exception);
        } catch (error) {
          console.error(
            "Error in watchpoint handler for queued exception:",
            error
          );
        }
      });
    });

    // Clear the queues after processing
    clearQueuedExceptions();
  }, [clearQueuedExceptions]);

  const contextValue = useMemo(
    () => ({
      // State from the exception handler
      isMonitoring: exceptionHandler.isMonitoring,
      watchpointExceptions: exceptionHandler.watchpointExceptions,
      breakpointExceptions: exceptionHandler.breakpointExceptions,
      signalExceptions: exceptionHandler.signalExceptions,
      allExceptions: exceptionHandler.allExceptions,
      lastCheckTime: exceptionHandler.lastCheckTime,
      error: exceptionHandler.error,

      // Current thread exception (for switching back)
      currentThreadException,

      // All stopped threads map
      allStoppedThreads,

      // Queued exceptions state
      queuedBreakpointExceptions,
      queuedWatchpointExceptions,

      // Actions from the exception handler
      startMonitoring: exceptionHandler.startMonitoring,
      stopMonitoring: exceptionHandler.stopMonitoring,
      clearExceptions: exceptionHandler.clearExceptions,
      clearWatchpointExceptions: exceptionHandler.clearWatchpointExceptions,
      clearBreakpointExceptions: exceptionHandler.clearBreakpointExceptions,
      clearQueuedExceptions,
      clearAllStoppedThreads,
      processQueuedExceptions,
      checkNow: exceptionHandler.checkNow,

      // Handler registration
      registerWatchpointHandler,
      unregisterWatchpointHandler,
      registerBreakpointHandler,
      unregisterBreakpointHandler,
      registerSignalHandler,
      unregisterSignalHandler,
      registerScriptBreakpointHandler,
      unregisterScriptBreakpointHandler,
    }),
    [
      exceptionHandler.isMonitoring,
      exceptionHandler.watchpointExceptions,
      exceptionHandler.breakpointExceptions,
      exceptionHandler.signalExceptions,
      exceptionHandler.allExceptions,
      exceptionHandler.lastCheckTime,
      exceptionHandler.error,
      currentThreadException,
      allStoppedThreads,
      queuedBreakpointExceptions,
      queuedWatchpointExceptions,
      exceptionHandler.startMonitoring,
      exceptionHandler.stopMonitoring,
      exceptionHandler.clearExceptions,
      exceptionHandler.clearWatchpointExceptions,
      exceptionHandler.clearBreakpointExceptions,
      clearQueuedExceptions,
      clearAllStoppedThreads,
      processQueuedExceptions,
      exceptionHandler.checkNow,
      registerWatchpointHandler,
      unregisterWatchpointHandler,
      registerBreakpointHandler,
      unregisterBreakpointHandler,
      registerSignalHandler,
      unregisterSignalHandler,
      registerScriptBreakpointHandler,
      unregisterScriptBreakpointHandler,
    ]
  );

  return (
    <GlobalExceptionHandlerContext.Provider value={contextValue}>
      {children}
    </GlobalExceptionHandlerContext.Provider>
  );
};

export const useGlobalExceptionHandler =
  (): GlobalExceptionHandlerContextType => {
    const context = useContext(GlobalExceptionHandlerContext);
    if (!context) {
      throw new Error(
        "useGlobalExceptionHandler must be used within a GlobalExceptionHandlerProvider"
      );
    }
    return context;
  };

// Convenience hook for watchpoint handling
export const useWatchpointHandler = (
  handler?: (exception: ProcessedException) => void
) => {
  const {
    registerWatchpointHandler,
    unregisterWatchpointHandler,
    watchpointExceptions,
  } = useGlobalExceptionHandler();

  React.useEffect(() => {
    if (handler) {
      registerWatchpointHandler(handler);
      return () => {
        unregisterWatchpointHandler(handler);
      };
    }
  }, [handler, registerWatchpointHandler, unregisterWatchpointHandler]);

  return { watchpointExceptions };
};

// Convenience hook for breakpoint handling
export const useBreakpointHandler = (
  handler?: (exception: ProcessedException) => void
) => {
  const {
    registerBreakpointHandler,
    unregisterBreakpointHandler,
    breakpointExceptions,
  } = useGlobalExceptionHandler();

  const handlerRef = React.useRef(handler);
  const registeredRef = React.useRef(false);

  React.useEffect(() => {
    handlerRef.current = handler;
  }, [handler]);

  React.useEffect(() => {
    if (handler && !registeredRef.current) {
      console.log("[BREAKPOINT HANDLER] Registering breakpoint handler");
      registerBreakpointHandler(handler);
      registeredRef.current = true;
      return () => {
        console.log("[BREAKPOINT HANDLER] Unregistering breakpoint handler");
        unregisterBreakpointHandler(handler);
        registeredRef.current = false;
      };
    }
  }, [handler, registerBreakpointHandler, unregisterBreakpointHandler]);

  return { breakpointExceptions };
};

```

`src/client/src/hooks/useGlobalNetworkLogger.tsx`:

```tsx
import React, { createContext, useContext, ReactNode } from "react";
import { NetworkLogger, useNetworkLogger } from "./useNetworkLogger";

interface NetworkLoggerProviderProps {
  children: ReactNode;
}

const NetworkLoggerContext = createContext<NetworkLogger | null>(null);

export const NetworkLoggerProvider: React.FC<NetworkLoggerProviderProps> = ({
  children,
}) => {
  const networkLogger = useNetworkLogger();

  return (
    <NetworkLoggerContext.Provider value={networkLogger}>
      {children}
    </NetworkLoggerContext.Provider>
  );
};

export const useGlobalNetworkLogger = (): NetworkLogger => {
  const context = useContext(NetworkLoggerContext);
  if (!context) {
    throw new Error(
      "useGlobalNetworkLogger must be used within a NetworkLoggerProvider"
    );
  }
  return context;
};

```

`src/client/src/hooks/useLocalStorage.ts`:

```ts
import { useState } from "react";

export function useLocalStorage<T>(key: string, initialValue: T) {
  // Get value from localStorage or use initialValue
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Return a wrapped version of useState's setter function that persists the new value to localStorage
  const setValue = (value: T | ((val: T) => T)) => {
    try {
      // Allow value to be a function so we have the same API as useState
      const valueToStore =
        value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      // Save to localStorage
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  };

  return [storedValue, setValue] as const;
}

```

`src/client/src/hooks/useNetworkLogger.ts`:

```ts
import { useCallback, useMemo, useState } from "react";
import { useLocalStorage } from "./useLocalStorage";

export type NetworkMethod = "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
export type NetworkStatus = number;

export interface NetworkEntry {
  id: string;
  timestamp: Date;
  method: NetworkMethod;
  url: string;
  endpoint: string;
  status?: NetworkStatus;
  duration?: number; // in milliseconds
  requestHeaders?: Record<string, string>;
  requestBody?: any;
  requestSize?: number; // in bytes
  responseHeaders?: Record<string, string>;
  responseBody?: any;
  responseSize?: number; // in bytes
  error?: string;
}

export interface NetworkLogger {
  requests: NetworkEntry[];
  allRequests: NetworkEntry[];
  endpoints: string[];
  methods: NetworkMethod[];
  searchTerm: string;
  setSearchTerm: (term: string) => void;
  selectedMethod: NetworkMethod | "ALL";
  setSelectedMethod: (method: NetworkMethod | "ALL") => void;
  selectedStatus: NetworkStatus | "ALL";
  setSelectedStatus: (status: NetworkStatus | "ALL") => void;
  selectedEndpoint: string;
  setSelectedEndpoint: (endpoint: string) => void;
  sortField: "timestamp" | "duration" | "status" | "endpoint";
  setSortField: (
    field: "timestamp" | "duration" | "status" | "endpoint"
  ) => void;
  sortDirection: "asc" | "desc";
  setSortDirection: (direction: "asc" | "desc") => void;
  excludedEndpoints: string[];
  setExcludedEndpoints: (endpoints: string[]) => void;
  isPaused: boolean;
  setIsPaused: (paused: boolean) => void;
  addRequest: (request: Omit<NetworkEntry, "id" | "timestamp">) => string;
  updateRequest: (id: string, updates: Partial<NetworkEntry>) => void;
  clearRequests: () => void;
  exportRequests: () => void;
}

export const useNetworkLogger = (): NetworkLogger => {
  const [allRequests, setAllRequests] = useState<NetworkEntry[]>([]);
  const [searchTerm, setSearchTerm] = useState<string>("");
  const [selectedMethod, setSelectedMethod] = useState<NetworkMethod | "ALL">(
    "ALL"
  );
  const [selectedStatus, setSelectedStatus] = useState<NetworkStatus | "ALL">(
    "ALL"
  );
  const [selectedEndpoint, setSelectedEndpoint] = useState<string>("ALL");
  const [sortField, setSortField] = useState<
    "timestamp" | "duration" | "status" | "endpoint"
  >("timestamp");
  const [sortDirection, setSortDirection] = useState<"asc" | "desc">("desc");
  const [excludedEndpoints, setExcludedEndpoints] = useLocalStorage<string[]>(
    "network-excluded-endpoints",
    []
  );
  const [isPaused, setIsPaused] = useState<boolean>(false);

  // Add new request
  const addRequest = useCallback(
    (request: Omit<NetworkEntry, "id" | "timestamp">): string => {
      if (isPaused) {
        return "";
      }

      const id = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const newRequest: NetworkEntry = {
        ...request,
        id,
        timestamp: new Date(),
      };

      setAllRequests((prev) => [...prev, newRequest]);
      return id;
    },
    [isPaused]
  );

  // Update existing request
  const updateRequest = useCallback(
    (id: string, updates: Partial<NetworkEntry>) => {
      setAllRequests((prev) =>
        prev.map((req) => (req.id === id ? { ...req, ...updates } : req))
      );
    },
    []
  );

  // Clear all requests
  const clearRequests = useCallback(() => {
    setAllRequests([]);
  }, []);

  // Export requests to JSON
  const exportRequests = useCallback(() => {
    const dataStr = JSON.stringify(allRequests, null, 2);
    const dataBlob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `network_requests_${new Date().toISOString().split("T")[0]}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }, [allRequests]);

  // Get unique endpoints
  const endpoints = useMemo(() => {
    const endpointSet = new Set(allRequests.map((req) => req.endpoint));
    return Array.from(endpointSet).sort();
  }, [allRequests]);

  // Get unique methods
  const methods = useMemo(() => {
    const methodSet = new Set(allRequests.map((req) => req.method));
    return Array.from(methodSet).sort() as NetworkMethod[];
  }, [allRequests]);

  // Filter and sort requests
  const requests = useMemo(() => {
    let filtered = allRequests;

    // Apply excluded endpoints filter first
    if (excludedEndpoints.length > 0) {
      filtered = filtered.filter(
        (req) => !excludedEndpoints.includes(req.endpoint)
      );
    }

    // Apply search filter
    if (searchTerm) {
      const searchLower = searchTerm.toLowerCase();
      filtered = filtered.filter(
        (req) =>
          req.url.toLowerCase().includes(searchLower) ||
          req.endpoint.toLowerCase().includes(searchLower) ||
          req.method.toLowerCase().includes(searchLower) ||
          (req.status?.toString() || "").includes(searchLower) ||
          JSON.stringify(req.requestBody || "")
            .toLowerCase()
            .includes(searchLower) ||
          JSON.stringify(req.responseBody || "")
            .toLowerCase()
            .includes(searchLower)
      );
    }

    // Apply method filter
    if (selectedMethod !== "ALL") {
      filtered = filtered.filter((req) => req.method === selectedMethod);
    }

    // Apply status filter
    if (selectedStatus !== "ALL") {
      if (selectedStatus === 200) {
        filtered = filtered.filter(
          (req) => req.status && req.status >= 200 && req.status < 300
        );
      } else if (selectedStatus === 300) {
        filtered = filtered.filter(
          (req) => req.status && req.status >= 300 && req.status < 400
        );
      } else if (selectedStatus === 400) {
        filtered = filtered.filter(
          (req) => req.status && req.status >= 400 && req.status < 500
        );
      } else if (selectedStatus === 500) {
        filtered = filtered.filter((req) => req.status && req.status >= 500);
      }
    }

    // Apply endpoint filter
    if (selectedEndpoint !== "ALL") {
      filtered = filtered.filter((req) => req.endpoint === selectedEndpoint);
    }

    // Apply sorting
    const sorted = [...filtered].sort((a, b) => {
      let aValue: any;
      let bValue: any;

      switch (sortField) {
        case "timestamp":
          aValue = a.timestamp.getTime();
          bValue = b.timestamp.getTime();
          break;
        case "duration":
          aValue = a.duration || 0;
          bValue = b.duration || 0;
          break;
        case "status":
          aValue = a.status || 0;
          bValue = b.status || 0;
          break;
        case "endpoint":
          aValue = a.endpoint;
          bValue = b.endpoint;
          break;
        default:
          return 0;
      }

      if (typeof aValue === "string" && typeof bValue === "string") {
        return sortDirection === "asc"
          ? aValue.localeCompare(bValue)
          : bValue.localeCompare(aValue);
      }

      return sortDirection === "asc" ? aValue - bValue : bValue - aValue;
    });

    return sorted;
  }, [
    allRequests,
    searchTerm,
    selectedMethod,
    selectedStatus,
    selectedEndpoint,
    sortField,
    sortDirection,
    excludedEndpoints,
  ]);

  return useMemo(
    () => ({
      requests,
      allRequests,
      endpoints,
      methods,
      searchTerm,
      setSearchTerm,
      selectedMethod,
      setSelectedMethod,
      selectedStatus,
      setSelectedStatus,
      selectedEndpoint,
      setSelectedEndpoint,
      sortField,
      setSortField,
      sortDirection,
      setSortDirection,
      excludedEndpoints,
      setExcludedEndpoints,
      isPaused,
      setIsPaused,
      addRequest,
      updateRequest,
      clearRequests,
      exportRequests,
    }),
    [
      requests,
      allRequests,
      endpoints,
      methods,
      searchTerm,
      setSearchTerm,
      selectedMethod,
      setSelectedMethod,
      selectedStatus,
      setSelectedStatus,
      selectedEndpoint,
      setSelectedEndpoint,
      sortField,
      setSortField,
      sortDirection,
      setSortDirection,
      excludedEndpoints,
      setExcludedEndpoints,
      isPaused,
      setIsPaused,
      addRequest,
      updateRequest,
      clearRequests,
      exportRequests,
    ]
  );
};

```

`src/client/src/hooks/useResizable.ts`:

```ts
import { useState, useCallback, useEffect, useRef } from "react";
import { useLocalStorage } from "./useLocalStorage";

interface UseResizableOptions {
  storageKey: string;
  defaultSize: number;
  minSize?: number;
  maxSize?: number;
  orientation?: "horizontal" | "vertical";
  containerRef?: React.RefObject<HTMLElement | null>;
}

/**
 * Hook for managing resizable panels with localStorage persistence
 */
export const useResizable = ({
  storageKey,
  defaultSize,
  minSize = 100,
  maxSize = Infinity,
  orientation = "vertical",
  containerRef,
}: UseResizableOptions) => {
  const [size, setSize] = useLocalStorage<number>(storageKey, defaultSize);
  const [isResizing, setIsResizing] = useState(false);
  const initialPositionRef = useRef<number>(0);
  const initialSizeRef = useRef<number>(0);
  const containerSizeRef = useRef<number>(0);

  const handleMouseDown = useCallback(
    (e: React.MouseEvent) => {
      e.preventDefault();
      setIsResizing(true);
      initialPositionRef.current =
        orientation === "vertical" ? e.clientY : e.clientX;
      initialSizeRef.current = size;

      // Get container size for percentage calculations
      if (containerRef?.current) {
        containerSizeRef.current =
          orientation === "vertical"
            ? containerRef.current.clientHeight
            : containerRef.current.clientWidth;
      }
    },
    [size, orientation, containerRef]
  );

  const handleMouseMove = useCallback(
    (e: MouseEvent) => {
      if (!isResizing) return;

      const currentPosition =
        orientation === "vertical" ? e.clientY : e.clientX;
      const deltaPixels = currentPosition - initialPositionRef.current;

      // Convert pixel delta to percentage delta
      const containerSize = containerSizeRef.current || 1000; // Fallback to reasonable default
      const deltaPercentage = (deltaPixels / containerSize) * 100;
      const newSize = initialSizeRef.current + deltaPercentage;

      // Apply constraints
      const constrainedSize = Math.min(Math.max(newSize, minSize), maxSize);
      setSize(constrainedSize);
    },
    [isResizing, orientation, minSize, maxSize, setSize]
  );

  const handleMouseUp = useCallback(() => {
    setIsResizing(false);
  }, []);

  useEffect(() => {
    if (isResizing) {
      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);

      // Prevent text selection during resize
      document.body.style.userSelect = "none";
      document.body.style.cursor =
        orientation === "vertical" ? "ns-resize" : "ew-resize";

      return () => {
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
        document.body.style.userSelect = "";
        document.body.style.cursor = "";
      };
    }
  }, [isResizing, handleMouseMove, handleMouseUp, orientation]);

  return {
    size,
    setSize,
    isResizing,
    handleMouseDown,
  };
};

```

`src/client/src/hooks/useScanHistory.ts`:

```ts
import { useState, useCallback, useEffect } from "react";
import {
  ScanHistoryItem,
  ScanSettings,
  ScanValueType,
  ScanType,
} from "../types/index";

const SCAN_HISTORY_KEY = "scanner-history";
const MAX_HISTORY_ITEMS = 10;

export const useScanHistory = () => {
  // Initialize history from localStorage
  const [history, setHistory] = useState<ScanHistoryItem[]>(() => {
    try {
      const saved = localStorage.getItem(SCAN_HISTORY_KEY);
      return saved ? JSON.parse(saved) : [];
    } catch (error) {
      console.error("Failed to load scan history from localStorage:", error);
      return [];
    }
  });

  // Save history to localStorage whenever it changes
  useEffect(() => {
    try {
      localStorage.setItem(SCAN_HISTORY_KEY, JSON.stringify(history));
    } catch (error) {
      console.error("Failed to save scan history to localStorage:", error);
    }
  }, [history]);

  // Add a new scan to history
  const addToHistory = useCallback((scanSettings: ScanSettings) => {
    // Only add to history if it's a first scan with a value
    const needsValue = ["exact", "bigger", "smaller", "range"].includes(
      scanSettings.scanType
    );
    if (!needsValue || !scanSettings.value.trim()) {
      return;
    }

    const description = generateDescription(scanSettings);

    const newItem: ScanHistoryItem = {
      id: `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      valueType: scanSettings.valueType,
      scanType: scanSettings.scanType,
      value: scanSettings.value,
      description,
      timestamp: new Date(),
      scanSettings: {
        startAddress: scanSettings.startAddress,
        endAddress: scanSettings.endAddress,
        scanMode: scanSettings.scanMode,
        selectedRegions: scanSettings.selectedRegions,
        alignment: scanSettings.alignment,
        writable: scanSettings.writable,
        executable: scanSettings.executable,
        readable: scanSettings.readable,
        doSuspend: scanSettings.doSuspend,
        searchMode: scanSettings.searchMode,
      },
    };

    setHistory((prev) => {
      // Check if this exact search already exists
      const existingIndex = prev.findIndex(
        (item) =>
          item.valueType === newItem.valueType &&
          item.scanType === newItem.scanType &&
          item.value === newItem.value
      );

      let newHistory;
      if (existingIndex !== -1) {
        // If exists, remove it and add to front (move to top)
        newHistory = [
          newItem,
          ...prev.filter((_, index) => index !== existingIndex),
        ];
      } else {
        // If new, add to front
        newHistory = [newItem, ...prev];
      }

      // Keep only the latest MAX_HISTORY_ITEMS
      return newHistory.slice(0, MAX_HISTORY_ITEMS);
    });
  }, []);

  // Generate description from scan settings
  const generateDescription = (scanSettings: ScanSettings): string => {
    const typeDisplayName = getValueTypeDisplayName(scanSettings.valueType);
    const scanTypeDisplayName = getScanTypeDisplayName(scanSettings.scanType);

    let baseDesc = `${typeDisplayName} - ${scanTypeDisplayName}`;

    if (scanSettings.value.trim()) {
      // Truncate long values
      const displayValue =
        scanSettings.value.length > 20
          ? `${scanSettings.value.substring(0, 20)}...`
          : scanSettings.value;
      baseDesc += `: ${displayValue}`;
    }

    return baseDesc;
  };

  // Get display name for value type
  const getValueTypeDisplayName = (valueType: ScanValueType): string => {
    const displayNames: Record<ScanValueType, string> = {
      int8: "Int8",
      uint8: "UInt8",
      int16: "Int16",
      uint16: "UInt16",
      int32: "Int32",
      uint32: "UInt32",
      int64: "Int64",
      uint64: "UInt64",
      float: "Float",
      double: "Double",
      string: "String",
      bytes: "Bytes",
      regex: "Regex",
      ptr: "Pointer",
    };
    return displayNames[valueType] || valueType;
  };

  // Get display name for scan type
  const getScanTypeDisplayName = (scanType: ScanType): string => {
    const displayNames: Record<ScanType, string> = {
      exact: "Exact Value",
      bigger: "Bigger than",
      smaller: "Smaller than",
      range: "Value between",
      changed: "Changed value",
      unchanged: "Unchanged value",
      increased: "Increased value",
      decreased: "Decreased value",
      unknown: "Unknown value",
      greater_or_equal: "Greater or equal",
      less_than: "Less than",
    };
    return displayNames[scanType] || scanType;
  };

  // Clear all history
  const clearHistory = useCallback(() => {
    setHistory([]);
  }, []);

  // Remove specific history item
  const removeHistoryItem = useCallback((id: string) => {
    setHistory((prev) => prev.filter((item) => item.id !== id));
  }, []);

  // Get history item by id
  const getHistoryItem = useCallback(
    (id: string) => {
      return history.find((item) => item.id === id);
    },
    [history]
  );

  return {
    history,
    addToHistory,
    clearHistory,
    removeHistoryItem,
    getHistoryItem,
  };
};

```

`src/client/src/hooks/useScannerGlobalState.ts`:

```ts
import { useCallback } from "react";
import { useAppState } from "./useAppState";
import type {
  ScanResult,
  ScanValueType,
  BookmarkItem,
  ScanHistoryItem,
  ScanSettings,
} from "../types/index";
import { getApiClient } from "../lib/api";

/**
 * Scanner state management using new app state system
 */
export const useScannerGlobalState = () => {
  const { ui, uiActions } = useAppState();
  const scannerState = ui.scannerState;
  const scanResults = scannerState.scanResults;
  const scanHistory = ui.scanHistory;
  const bookmarks = ui.bookmarks;
  const scanSettings = scannerState.scanSettings;

  const apiClient = getApiClient();

  // Scan results management
  const setScanResults = useCallback(
    (results: ScanResult[]) => {
      uiActions.setScanResults(results);
    },
    [uiActions]
  );

  const clearScanResults = useCallback(() => {
    uiActions.clearScanResults();
  }, [uiActions]);

  // Scanner state management
  const updateScannerState = useCallback(
    (updates: Partial<typeof scannerState>) => {
      uiActions.updateScannerState(updates);
    },
    [uiActions]
  );

  // Scan settings management
  const setScanSettings = useCallback(
    (settings: ScanSettings) => {
      uiActions.setScanSettings(settings);
    },
    [uiActions]
  );

  const updateScanSettings = useCallback(
    (updates: Partial<ScanSettings>) => {
      uiActions.updateScanSettings(updates);
    },
    [uiActions]
  );

  // Full settings update function for compatibility with components that expect complete settings
  const updateFullScanSettings = useCallback(
    (settings: ScanSettings) => {
      uiActions.setScanSettings(settings);
      return true;
    },
    [uiActions]
  );

  // Bookmarks management
  const addBookmark = useCallback(
    (bookmark: BookmarkItem) => {
      uiActions.addBookmark(bookmark);
    },
    [uiActions]
  );

  const removeBookmark = useCallback(
    (bookmarkId: string) => {
      uiActions.removeBookmark(bookmarkId);
    },
    [uiActions]
  );

  const updateBookmark = useCallback(
    (bookmarkId: string, updates: Partial<BookmarkItem>) => {
      uiActions.updateBookmark(bookmarkId, updates);
    },
    [uiActions]
  );

  const isAddressBookmarked = useCallback(
    (address: string) => {
      return bookmarks.some((b) => b.address === address);
    },
    [bookmarks]
  );

  // Function to add manual bookmark by address
  const addManualBookmark = useCallback(
    async (
      address: string,
      valueType: ScanValueType,
      description?: string,
      libraryExpression?: string,
      size?: number,
      displayFormat?: "dec" | "hex",
      ptrValueType?: Exclude<ScanValueType, "ptr" | "string" | "bytes" | "regex">
    ) => {
      try {
        console.log("[useScannerGlobalState] addManualBookmark called with:", {
          address,
          valueType,
          description,
          libraryExpression,
          size,
          displayFormat,
          ptrValueType,
        });

        // For PTR type, the address is a pointer expression like [[base]+0x8]+0x10
        // Skip normalization and use as-is
        let normalizedAddress = address.trim();
        const isPtrType = valueType === "ptr";

        if (!isPtrType) {
          // Normalize address to proper hex format
          // If address doesn't start with 0x, assume it's decimal and convert to hex
          if (!/^0x/i.test(normalizedAddress)) {
            const decimalValue = parseInt(normalizedAddress, 10);
            if (!isNaN(decimalValue)) {
              normalizedAddress = `0x${decimalValue.toString(16).toUpperCase()}`;
            } else {
              throw new Error("Invalid address format");
            }
          } else {
            // If already hex, ensure proper format (0x prefix, uppercase)
            normalizedAddress = "0x" + normalizedAddress.slice(2).toUpperCase();
          }
        }

        // Try to read current value from memory
        let currentValue = valueType === "string" ? "" : "0";
        
        if (isPtrType) {
          // For PTR type, resolve the pointer chain and read the value at the final address
          try {
            const resolveResult = await apiClient.resolveAddress(normalizedAddress);
            if (resolveResult.success && resolveResult.data?.address) {
              const resolvedAddr = `0x${resolveResult.data.address.toString(16).toUpperCase()}`;
              // Always read 8 bytes for PTR type, mask based on ptrValueType for display
              const buffer = await apiClient.readMemory(resolvedAddr, 8);
              const view = new DataView(buffer);
              const fullValue = view.getBigUint64(0, true);
              
              // Mask based on ptrValueType for display
              const effectiveType = ptrValueType || "int32";
              let maskedValue: bigint;
              switch (effectiveType) {
                case "int8":
                case "uint8":
                  maskedValue = fullValue & 0xFFn;
                  break;
                case "int16":
                case "uint16":
                  maskedValue = fullValue & 0xFFFFn;
                  break;
                case "int32":
                case "uint32":
                case "float":
                  maskedValue = fullValue & 0xFFFFFFFFn;
                  break;
                default:
                  maskedValue = fullValue;
              }
              currentValue = maskedValue.toString();
            } else {
              currentValue = "N/A";
            }
          } catch (error) {
            console.warn(`Could not resolve pointer chain: ${normalizedAddress}`);
            currentValue = "N/A";
          }
        } else {
          try {
            const readSize =
              valueType === "int8" || valueType === "uint8"
                ? 1
                : valueType === "int16" || valueType === "uint16"
                  ? 2
                  : valueType === "int32" ||
                      valueType === "uint32" ||
                      valueType === "float"
                    ? 4
                    : valueType === "int64" ||
                        valueType === "uint64" ||
                        valueType === "double"
                      ? 8
                      : valueType === "string"
                        ? size || 64
                        : valueType === "bytes"
                          ? size || 4
                          : 4;

            const buffer = await apiClient.readMemory(
              normalizedAddress,
              readSize
            );
            // Convert buffer to value based on type
            const view = new DataView(buffer);

            switch (valueType) {
              case "int8":
                currentValue = view.getInt8(0).toString();
                break;
              case "uint8":
                currentValue = view.getUint8(0).toString();
                break;
              case "int16":
                currentValue = view.getInt16(0, true).toString();
                break;
              case "uint16":
                currentValue = view.getUint16(0, true).toString();
                break;
              case "int32":
                currentValue = view.getInt32(0, true).toString();
                break;
              case "uint32":
                currentValue = view.getUint32(0, true).toString();
                break;
              case "int64":
                currentValue = view.getBigInt64(0, true).toString();
                break;
              case "uint64":
                currentValue = view.getBigUint64(0, true).toString();
                break;
              case "float":
                currentValue = view.getFloat32(0, true).toString();
                break;
              case "double":
                currentValue = view.getFloat64(0, true).toString();
                break;
              case "string": {
                const uint8Array = new Uint8Array(buffer);
                let str = "";
                for (let i = 0; i < uint8Array.length; i++) {
                  const byte = uint8Array[i];
                  if (byte === 0) break;
                  if (byte >= 32 && byte <= 126) {
                    str += String.fromCharCode(byte);
                  }
                }
                currentValue = str;
                break;
              }
              case "bytes": {
                currentValue = Array.from(new Uint8Array(buffer))
                  .map((b) => b.toString(16).padStart(2, "0").toUpperCase())
                  .join(" ");
                break;
              }
              default:
                currentValue = "0";
            }
          } catch (error) {
            console.warn(
              `Could not read memory at ${normalizedAddress}, using default value`
            );
          }
        }

        const newBookmark: BookmarkItem = {
          id: `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          address: normalizedAddress,
          libraryExpression: libraryExpression, // Save library+offset expression if provided
          value: currentValue,
          type: valueType,
          ptrValueType: valueType === "ptr" ? (ptrValueType || "int32") : undefined,
          size:
            valueType === "string" || valueType === "bytes" ? size : undefined,
          description: description || `Manual bookmark`,
          displayFormat: displayFormat,
          createdAt: new Date(),
          tags: [],
        };

        console.log("[useScannerGlobalState] Creating bookmark:", newBookmark);

        // Check if already bookmarked
        if (isAddressBookmarked(normalizedAddress)) {
          console.warn(
            "[useScannerGlobalState] Address already bookmarked:",
            normalizedAddress
          );
          return false;
        }

        addBookmark(newBookmark);
        console.log(
          `[useScannerGlobalState] Added manual bookmark for address: ${normalizedAddress}`
        );
        return true;
      } catch (error) {
        console.error(
          `[useScannerGlobalState] Failed to add manual bookmark for ${address}:`,
          error
        );
        return false;
      }
    },
    [apiClient, isAddressBookmarked, addBookmark]
  );

  // History management
  const addScanHistory = useCallback(
    (item: ScanHistoryItem) => {
      uiActions.addScanHistory(item);
    },
    [uiActions]
  );

  const clearScanHistory = useCallback(() => {
    uiActions.clearScanHistory();
  }, [uiActions]);

  const removeHistoryItem = useCallback(
    (id: string) => {
      const index = scanHistory.findIndex((item: any) => item.id === id);
      if (index !== -1) {
        uiActions.removeScanHistory(index);
      }
    },
    [uiActions, scanHistory]
  );

  // Function to handle result bookmark toggle
  const handleResultBookmark = useCallback(
    (address: string, bookmarked: boolean) => {
      if (bookmarked) {
        // Add to bookmarks
        const existingResult = scanResults.find((r) => r.address === address);
        if (existingResult) {
          const newBookmark: BookmarkItem = {
            id: `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            address,
            value: existingResult.value.toString(),
            type: existingResult.type,
            description:
              existingResult.description || "Bookmarked from scan results",
            displayFormat: scanSettings?.valueInputFormat || "dec",
            createdAt: new Date(),
            tags: [],
          };

          // Check if already bookmarked
          if (!isAddressBookmarked(address)) {
            addBookmark(newBookmark);
            console.log(`Added bookmark for address: ${address}`);
          }
        }
      } else {
        // Remove from bookmarks
        const bookmark = bookmarks.find((b) => b.address === address);
        if (bookmark) {
          removeBookmark(bookmark.id);
          console.log(`Removed bookmark for address: ${address}`);
        }
      }
    },
    [
      scanResults,
      bookmarks,
      scanSettings?.valueInputFormat,
      isAddressBookmarked,
      addBookmark,
      removeBookmark,
    ]
  );

  return {
    // State
    scannerState,
    scanResults,
    scanHistory,
    bookmarks,
    scanSettings,

    // Scanner state actions
    updateScannerState,
    setScanResults,
    clearScanResults,

    // Scan settings actions
    setScanSettings,
    updateScanSettings,
    updateFullScanSettings,

    // Bookmark actions
    addBookmark,
    removeBookmark,
    updateBookmark,
    addManualBookmark,
    isAddressBookmarked,
    handleResultBookmark,

    // History actions
    addScanHistory,
    clearScanHistory,
    removeHistoryItem,
  };
};

```

`src/client/src/hooks/useScannerState.ts`:

```ts
import { useState, useCallback, useRef, useEffect } from "react";
import { invoke } from "@tauri-apps/api/core";
import {
  ScanResult,
  ScanSettings,
  ScanValueType,
  ScanType,
  ScannerState,
  FilterRequest,
  BookmarkItem,
  ScanHistoryItem,
} from "../types/index";
import { getApiClient } from "../lib/api";
import { useAppState } from "./useAppState";
import { normalizeAddressString } from "../utils/addressEncoder";

export interface MemoryRegion {
  start_address: string;
  end_address: string;
  size: number;
  protection: string;
  module_name?: string;
  selected?: boolean;
}

interface MemoryScanRequest {
  pattern: string;
  pattern_max?: string; // For range search: pattern is min, pattern_max is max
  address_ranges: [number, number][];
  find_type: string;
  data_type: string;
  scan_id: string;
  align: number;
  return_as_json: boolean;
  do_suspend: boolean;
}

const defaultScanSettings: ScanSettings = {
  valueType: "int32",
  scanType: "exact",
  value: "",
  valueMax: "", // For range search
  startAddress: "0x0",
  endAddress: "0x7FFFFFFFFFFF",
  scanMode: "manual",
  selectedRegions: [],
  alignment: 4,
  writable: true,
  executable: false,
  readable: true,
  doSuspend: false,
  searchMode: "normal",
  yaraRule: "",
};

// Generate unique scan ID
const generateScanId = () =>
  `scan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

// Map frontend types to backend types
const mapToBackendDataType = (valueType: ScanValueType): string => {
  const mapping: Record<ScanValueType, string> = {
    int8: "int8",
    uint8: "uint8",
    int16: "int16",
    uint16: "uint16",
    int32: "int32",
    uint32: "uint32",
    int64: "int64",
    uint64: "uint64",
    float: "float",
    double: "double",
    string: "string",
    bytes: "bytes",
    regex: "regex",
    ptr: "ptr",
  };
  return mapping[valueType] || "int32";
};

const mapToBackendFindType = (scanType: ScanType): string => {
  const mapping: Record<string, string> = {
    exact: "exact",
    bigger: "bigger",
    smaller: "smaller",
    range: "range",
    greater_or_equal: "greater_or_equal",
    less_than: "less_than",
    unknown: "unknown",
    changed: "changed",
    unchanged: "unchanged",
    increased: "increased",
    decreased: "decreased",
  };
  return mapping[scanType] || "exact";
};

// Convert hex bytes to human-readable value based on data type
const convertHexBytesToValue = (
  hexValue: string,
  valueType: ScanValueType,
  maxLength?: number // For any type, limit to search pattern length
): string => {
  try {
    // Remove any whitespace and ensure it's a clean hex string
    let cleanHex = hexValue.replace(/\s/g, "");

    // If maxLength is specified, limit the hex string length
    if (maxLength) {
      const maxHexChars = maxLength * 2; // Each byte = 2 hex chars
      cleanHex = cleanHex.substring(0, maxHexChars);
    }

    // Convert hex string to bytes
    const bytes = new Uint8Array(cleanHex.length / 2);
    for (let i = 0; i < cleanHex.length; i += 2) {
      bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
    }

    // Create DataView for proper endianness handling
    const buffer = new ArrayBuffer(bytes.length);
    const view = new DataView(buffer);
    const uint8View = new Uint8Array(buffer);
    uint8View.set(bytes);

    switch (valueType) {
      case "int8": {
        if (bytes.length >= 1) {
          return view.getInt8(0).toString();
        }
        break;
      }
      case "uint8": {
        if (bytes.length >= 1) {
          return view.getUint8(0).toString();
        }
        break;
      }
      case "int16": {
        if (bytes.length >= 2) {
          return view.getInt16(0, true).toString(); // true = little-endian
        }
        break;
      }
      case "uint16": {
        if (bytes.length >= 2) {
          return view.getUint16(0, true).toString(); // true = little-endian
        }
        break;
      }
      case "int32": {
        if (bytes.length >= 4) {
          return view.getInt32(0, true).toString(); // true = little-endian
        }
        break;
      }
      case "uint32": {
        if (bytes.length >= 4) {
          return view.getUint32(0, true).toString(); // true = little-endian
        }
        break;
      }
      case "int64": {
        if (bytes.length >= 8) {
          return view.getBigInt64(0, true).toString(); // true = little-endian
        }
        break;
      }
      case "uint64": {
        if (bytes.length >= 8) {
          return view.getBigUint64(0, true).toString(); // true = little-endian
        }
        break;
      }
      case "float": {
        if (bytes.length >= 4) {
          return view.getFloat32(0, true).toString(); // true = little-endian
        }
        break;
      }
      case "double": {
        if (bytes.length >= 8) {
          return view.getFloat64(0, true).toString(); // true = little-endian
        }
        break;
      }
      case "string": {
        // Convert hex bytes back to UTF-8 string
        try {
          const decoder = new TextDecoder("utf-8");
          return decoder.decode(uint8View);
        } catch (error) {
          return `0x${cleanHex.toUpperCase()}`;
        }
      }
      case "regex": {
        // For regex, display the matched bytes as UTF-8 string
        try {
          const decoder = new TextDecoder("utf-8", { fatal: false });
          return decoder.decode(uint8View);
        } catch (error) {
          // Fallback to hex display if decoding fails
          const hexPairs = cleanHex.match(/.{1,2}/g) || [];
          return hexPairs.map((pair) => pair.toUpperCase()).join(" ");
        }
      }
      case "bytes":
      default:
        // For bytes, return as space-separated hex bytes for better readability
        const hexPairs = cleanHex.match(/.{1,2}/g) || [];
        return hexPairs.map((pair) => pair.toUpperCase()).join(" ");
    }

    // Fallback: return as hex string
    return `0x${cleanHex.toUpperCase()}`;
  } catch (error) {
    console.error("Failed to convert hex bytes to value:", error);
    return hexValue; // Return original on error
  }
};

const convertValueToHexBytes = (
  value: string,
  valueType: ScanValueType,
  inputFormat: "dec" | "hex" = "dec"
): string => {
  const buffer = new ArrayBuffer(16); // Max size for any type
  const view = new DataView(buffer);

  // Helper function to parse integer value based on input format
  const parseIntValue = (val: string): number => {
    const trimmed = val.trim();
    if (inputFormat === "hex") {
      // Parse as hex, remove 0x prefix if present
      return parseInt(trimmed.replace(/^0x/i, ""), 16);
    }
    return parseInt(trimmed, 10);
  };

  // Helper function to parse BigInt value based on input format
  const parseBigIntValue = (val: string): bigint => {
    const trimmed = val.trim();
    if (inputFormat === "hex") {
      // Parse as hex, remove 0x prefix if present
      const hexStr = trimmed.replace(/^0x/i, "");
      return BigInt("0x" + hexStr);
    }
    return BigInt(trimmed);
  };

  try {
    switch (valueType) {
      case "int8": {
        const val = parseIntValue(value);
        view.setInt8(0, val);
        return Array.from(new Uint8Array(buffer, 0, 1))
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("");
      }
      case "uint8": {
        const val = parseIntValue(value);
        view.setUint8(0, val);
        return Array.from(new Uint8Array(buffer, 0, 1))
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("");
      }
      case "int16": {
        const val = parseIntValue(value);
        view.setInt16(0, val, true); // true = little-endian
        return Array.from(new Uint8Array(buffer, 0, 2))
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("");
      }
      case "uint16": {
        const val = parseIntValue(value);
        view.setUint16(0, val, true); // true = little-endian
        return Array.from(new Uint8Array(buffer, 0, 2))
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("");
      }
      case "int32": {
        const val = parseIntValue(value);
        view.setInt32(0, val, true); // true = little-endian
        return Array.from(new Uint8Array(buffer, 0, 4))
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("");
      }
      case "uint32": {
        const val = parseIntValue(value);
        view.setUint32(0, val, true); // true = little-endian
        return Array.from(new Uint8Array(buffer, 0, 4))
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("");
      }
      case "int64": {
        const val = parseBigIntValue(value);
        view.setBigInt64(0, val, true); // true = little-endian
        return Array.from(new Uint8Array(buffer, 0, 8))
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("");
      }
      case "uint64": {
        const val = parseBigIntValue(value);
        view.setBigUint64(0, val, true); // true = little-endian
        return Array.from(new Uint8Array(buffer, 0, 8))
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("");
      }
      case "float": {
        const val = parseFloat(value);
        view.setFloat32(0, val, true); // true = little-endian
        return Array.from(new Uint8Array(buffer, 0, 4))
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("");
      }
      case "double": {
        const val = parseFloat(value);
        view.setFloat64(0, val, true); // true = little-endian
        return Array.from(new Uint8Array(buffer, 0, 8))
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("");
      }
      case "string": {
        // Convert string to UTF-8 bytes
        const encoder = new TextEncoder();
        const utf8Bytes = encoder.encode(value);
        return Array.from(utf8Bytes)
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("");
      }
      case "regex": {
        // For regex, return the pattern as-is (backend handles regex directly)
        return value;
      }
      case "bytes":
      default:
        // For bytes, handle space-separated hex bytes like "f2 f2" or "FF 00 12 34"
        // Also handle continuous hex like "f2f2" or with 0x prefix
        let cleanValue = value.replace(/^0x/i, "").trim();

        // If contains spaces, treat as space-separated bytes
        if (cleanValue.includes(" ")) {
          // Split by whitespace and filter out empty strings
          const byteStrings = cleanValue
            .split(/\s+/)
            .filter((s) => s.length > 0);
          const validBytes: string[] = [];

          for (const byteStr of byteStrings) {
            if (byteStr === "??" || byteStr === "??") {
              // Wildcard byte - for now, treat as 00 (this should be handled by server)
              validBytes.push("00");
            } else if (/^[0-9a-fA-F]{1,2}$/.test(byteStr)) {
              // Valid hex byte (1 or 2 digits)
              validBytes.push(byteStr.padStart(2, "0").toLowerCase());
            }
          }
          return validBytes.join("");
        } else {
          // Continuous hex string - just clean and validate
          cleanValue = cleanValue.replace(/[^0-9a-fA-F]/g, "");
          return cleanValue.toLowerCase();
        }
    }
  } catch (error) {
    console.error("Failed to convert value to hex bytes:", error);
    // Fallback: treat as hex string
    return value.replace(/^0x/, "").replace(/\s/g, "");
  }
};

export const useScannerState = () => {
  // Use new app state system
  const { ui, uiActions } = useAppState();

  // Get values from global state
  const scanResults = ui.scannerState.scanResults;
  const scanHistory = ui.scanHistory;
  const bookmarks = ui.bookmarks;

  // Local state for scanner-specific functionality
  const [scannerState, setScannerState] = useState<ScannerState>({
    isScanning: false,
    scanResults: [],
    scanHistory: [],
    currentScanIndex: -1,
    totalResults: 0,
    scanSettings: defaultScanSettings,
    scanId: generateScanId(),
    scanProgress: 0,
    scannedBytes: 0,
    totalBytes: 0,
    currentRegion: undefined,
    searchPatternLength: undefined,
    errorMessage: undefined,
  });

  const [memoryRegions] = useState<MemoryRegion[]>([]);
  const [memoryRegionsLoaded] = useState(true); // Always true for manual mode
  const [isSettingsLocked, setIsSettingsLocked] = useState(false); // Lock settings after first scan
  const progressIntervalRef = useRef<number | null>(null);

  const apiClient = getApiClient();

  // Sync scanner state with global UI state
  useEffect(() => {
    setScannerState((prev) => ({
      ...prev,
      scanResults: ui.scannerState.scanResults,
      totalResults: ui.scannerState.totalResults,
      isScanning: ui.scannerState.isScanning,
      scanProgress: ui.scannerState.scanProgress,
      scanSettings: {
        ...ui.scannerState.scanSettings,
        valueType: ui.scannerState.scanSettings.valueType as ScanValueType,
        scanType: ui.scannerState.scanSettings.scanType as ScanType,
        scanMode: ui.scannerState.scanSettings.scanMode as "manual" | "regions",
        searchMode: (ui.scannerState.scanSettings as any).searchMode || "normal",
        yaraRule: (ui.scannerState.scanSettings as any).yaraRule || "",
      },
    }));
  }, [ui.scannerState]);

  // Function to start filter progress polling
  const startFilterProgressPolling = useCallback(
    (filterId: string) => {
      if (progressIntervalRef.current) {
        clearInterval(progressIntervalRef.current);
      }

      console.log(`Starting filter progress polling for filter: ${filterId}`);

      progressIntervalRef.current = setInterval(async () => {
        try {
          console.log(`Polling filter progress for filter: ${filterId}`);
          const response = await apiClient.getFilterProgress(filterId);
          console.log(`Filter progress response:`, response);

          if (response.success && response.data) {
            const progress = response.data;
            setScannerState((prev) => ({
              ...prev,
              scanProgress: progress.progress_percentage,
              scannedBytes: progress.processed_results,
              totalBytes: progress.total_results,
              currentRegion: progress.current_region,
              isScanning: progress.is_filtering,
            }));

            // Update global state
            uiActions.updateScannerState({
              scanProgress: progress.progress_percentage,
              isScanning: progress.is_filtering,
            });

            // If filter is complete, fetch results and stop polling
            if (!progress.is_filtering && progressIntervalRef.current) {
              console.log(
                `Filter completed, fetching results for scan: ${scannerState.scanId}`
              );
              clearInterval(progressIntervalRef.current);
              progressIntervalRef.current = null;

              try {
                // Fetch filter results using the original scan ID
                const resultsResponse = await apiClient.getFilterResults(
                  scannerState.scanId
                );
                console.log(`Filter results response:`, resultsResponse);

                if (resultsResponse.success && resultsResponse.data) {
                  const resultsData = resultsResponse.data;

                  // Get current state for pattern length
                  setScannerState((prev) => {
                    const results: ScanResult[] =
                      resultsData.matched_addresses.map(
                        (item: { address: number; value: string }) => {
                          return {
                            address: `0x${item.address.toString(16)}`,
                            value: convertHexBytesToValue(
                              item.value,
                              prev.scanSettings.valueType,
                              prev.searchPatternLength
                            ),
                            type: prev.scanSettings.valueType,
                            description: "Filter result",
                          };
                        }
                      );

                    // Update global state
                    uiActions.setScanResults(results);
                    uiActions.updateScannerState({
                      scanResults: results,
                      totalResults: resultsData.found,
                      scanProgress: 100,
                      isScanning: false,
                    });

                    const newHistory = [...prev.scanHistory, results];
                    return {
                      ...prev,
                      isScanning: false,
                      scanResults: results,
                      scanHistory: newHistory,
                      currentScanIndex: newHistory.length - 1,
                      totalResults: resultsData.found,
                      scanProgress: 100,
                    };
                  });
                }
              } catch (error) {
                console.error("Failed to fetch filter results:", error);
                setScannerState((prev) => ({
                  ...prev,
                  isScanning: false,
                  scanProgress: 100,
                }));
                uiActions.updateScannerState({ isScanning: false });
              }
            }
          }
        } catch (error) {
          console.error("Failed to get filter progress:", error);
        }
      }, 100); // Poll every 100ms
    },
    [apiClient, scannerState.scanId, uiActions]
  );

  // Function to perform unknown scan using server-side streaming API
  const performUnknownScanStreaming = useCallback(
    async (
      addressRanges: [number, number][],
      alignment: number,
      dataType: string,
      scanId: string,
      doSuspend: boolean
    ) => {
      console.log(`Starting server-side unknown scan streaming for: ${scanId}`);

      // Calculate data size from data type
      const dataSize = (() => {
        switch (dataType) {
          case "int8":
          case "uint8":
            return 1;
          case "int16":
          case "uint16":
            return 2;
          case "int32":
          case "uint32":
          case "float":
            return 4;
          case "int64":
          case "uint64":
          case "double":
            return 8;
          default:
            return 4;
        }
      })();

      // Initialize local file for storing chunks
      const filePath = await invoke<string>("init_unknown_scan_file", {
        scanId,
        alignment,
        dataSize,
      });
      console.log(`Created unknown scan file: ${filePath}`);

      // Start server-side scan
      const startResponse = await apiClient.unknownScanStart({
        address_ranges: addressRanges,
        alignment,
        data_type: dataType,
        scan_id: scanId,
        do_suspend: doSuspend,
      });

      if (!startResponse.success) {
        throw new Error(startResponse.error || "Failed to start unknown scan");
      }

      console.log(`Server unknown scan started:`, startResponse);

      // Update initial state
      setScannerState((prev) => ({
        ...prev,
        totalBytes: startResponse.total_bytes,
      }));

      // Stream chunks from server and save to local file
      let chunkCount = 0;
      let isComplete = false;

      while (!isComplete) {
        try {
          const streamResponse = await apiClient.unknownScanStream(scanId);

          // Process received chunks
          for (const chunk of streamResponse.chunks) {
            // compressed_data is already a number array from JSON serialization
            // Just convert to Uint8Array
            const bytes = new Uint8Array(chunk.compressed_data);

            // Append to local file
            await invoke("append_unknown_scan_chunk", {
              scanId,
              offset: chunk.start_address,
              compressedData: Array.from(bytes),
            });
            chunkCount++;
          }

          // Update progress
          setScannerState((prev) => ({
            ...prev,
            scanProgress:
              (streamResponse.processed_bytes / streamResponse.total_bytes) *
              100,
            scannedBytes: streamResponse.processed_bytes,
            totalBytes: streamResponse.total_bytes,
            isScanning: streamResponse.is_scanning,
          }));

          uiActions.updateScannerState({
            scanProgress:
              (streamResponse.processed_bytes / streamResponse.total_bytes) *
              100,
            isScanning: streamResponse.is_scanning,
          });

          // Check if complete
          isComplete =
            !streamResponse.is_scanning && streamResponse.chunks.length === 0;

          // Small delay to prevent tight loop when no chunks available
          if (
            streamResponse.chunks.length === 0 &&
            streamResponse.is_scanning
          ) {
            await new Promise((resolve) => setTimeout(resolve, 100));
          }
        } catch (error) {
          console.error("Error streaming unknown scan:", error);
          // Try to stop the scan gracefully
          try {
            await apiClient.unknownScanStop(scanId);
          } catch {}
          throw error;
        }
      }

      // Finalize the file
      await invoke("finalize_unknown_scan_file", { scanId, chunkCount });

      console.log(`Unknown scan completed: ${chunkCount} chunks saved`);

      // Get file info for display
      const fileInfo = await invoke<{
        path: string;
        size: number;
        chunk_count: number;
      }>("get_unknown_scan_file_info", { scanId });
      console.log(`Unknown scan file info:`, fileInfo);

      // Update state to show completion
      setScannerState((prev) => ({
        ...prev,
        isScanning: false,
        scanProgress: 100,
        unknownScanId: scanId,
        // Store total result count approximation (actual counting would need decompression)
        totalResults: chunkCount > 0 ? -1 : 0, // -1 indicates unknown but has data
      }));

      uiActions.updateScannerState({
        isScanning: false,
        scanProgress: 100,
      });

      // Lock settings after scan
      setIsSettingsLocked(true);

      return chunkCount;
    },
    [apiClient, uiActions]
  );

  // Function to start unknown scan progress polling
  const startUnknownScanProgressPolling = useCallback(
    (
      scanId: string,
      onComplete: (scanId: string, totalAddresses: number) => void
    ) => {
      if (progressIntervalRef.current) {
        clearInterval(progressIntervalRef.current);
      }

      console.log(`Starting unknown scan progress polling for: ${scanId}`);

      progressIntervalRef.current = setInterval(async () => {
        try {
          const progress = await apiClient.getUnknownScanProgress(scanId);
          console.log(`Unknown scan progress:`, progress);

          setScannerState((prev) => ({
            ...prev,
            scanProgress: progress.progress_percentage,
            scannedBytes: progress.processed_bytes,
            totalBytes: progress.total_bytes,
            currentRegion: progress.current_region || undefined,
            isScanning: progress.is_scanning,
          }));

          // Update global state
          uiActions.updateScannerState({
            scanProgress: progress.progress_percentage,
            isScanning: progress.is_scanning,
          });

          // If scan is complete, stop polling and load results
          if (!progress.is_scanning && progressIntervalRef.current) {
            console.log(
              `Unknown scan completed: ${progress.found_count} addresses found`
            );
            clearInterval(progressIntervalRef.current);
            progressIntervalRef.current = null;

            onComplete(scanId, progress.found_count);
          }
        } catch (error) {
          console.error("Failed to get unknown scan progress:", error);
        }
      }, 100); // Poll every 100ms
    },
    [apiClient, uiActions]
  );

  // Function to start progress polling
  const startProgressPolling = useCallback(
    (scanId: string) => {
      if (progressIntervalRef.current) {
        clearInterval(progressIntervalRef.current);
      }

      console.log(`Starting progress polling for scan: ${scanId}`);

      progressIntervalRef.current = setInterval(async () => {
        try {
          console.log(`Polling progress for scan: ${scanId}`);
          const response = await apiClient.getScanProgress(scanId);
          console.log(`Progress response:`, response);

          if (response.success && response.data) {
            const progress = response.data;
            setScannerState((prev) => ({
              ...prev,
              scanProgress: progress.progress_percentage,
              scannedBytes: progress.scanned_bytes,
              totalBytes: progress.total_bytes,
              currentRegion: progress.current_region,
              isScanning: progress.is_scanning,
            }));

            // Update global state
            uiActions.updateScannerState({
              scanProgress: progress.progress_percentage,
              isScanning: progress.is_scanning,
            });

            // If scan is complete, fetch results and stop polling
            if (!progress.is_scanning && progressIntervalRef.current) {
              console.log(`Scan completed, fetching results for: ${scanId}`);
              clearInterval(progressIntervalRef.current);
              progressIntervalRef.current = null;

              try {
                // Fetch scan results
                const resultsResponse = await apiClient.getScanResults(scanId);
                console.log(`Scan results response:`, resultsResponse);

                if (resultsResponse.success && resultsResponse.data) {
                  const resultsData = resultsResponse.data;
                  console.log(`Scan results data:`, {
                    found: resultsData.found,
                    matchedAddressesLength: resultsData.matched_addresses?.length,
                    matchedAddresses: resultsData.matched_addresses?.slice(0, 5), // First 5 for debug
                  });

                  // Get current state for pattern length
                  setScannerState((prev) => {
                    const isYaraMode = (prev.scanSettings as any).searchMode === "yara";
                    
                    const results: ScanResult[] =
                      resultsData.matched_addresses.map(
                        (item: { address: number; value: string }) => {
                          if (isYaraMode) {
                            // YARA results: value format is "rule::pattern|hex_data"
                            let displayValue = item.value;
                            let description = "YARA match";
                            
                            try {
                              // Parse the new format: rule::pattern|hex_data
                              const pipeIdx = item.value.indexOf('|');
                              if (pipeIdx > 0) {
                                // Extract rule info (before |)
                                description = item.value.slice(0, pipeIdx);
                                
                                // Extract matched data hex (after |)
                                const hexData = item.value.slice(pipeIdx + 1);
                                const bytes = hexData.match(/.{1,2}/g) || [];
                                const chars = bytes.map(b => parseInt(b, 16));
                                
                                // Check if printable ASCII
                                const isPrintable = chars.every(c => c >= 32 && c < 127);
                                if (isPrintable && chars.length > 0) {
                                  displayValue = chars.map(c => String.fromCharCode(c)).join('');
                                } else {
                                  // Keep as hex with spaces
                                  displayValue = chars.map(c => c.toString(16).padStart(2, '0')).join(' ');
                                }
                              }
                            } catch {
                              // Keep original value if parsing fails
                            }
                            
                            return {
                              address: `0x${item.address.toString(16)}`,
                              value: displayValue,
                              type: "string" as ScanValueType,
                              description,
                            };
                          } else {
                            return {
                              address: `0x${item.address.toString(16)}`,
                              value: convertHexBytesToValue(
                                item.value,
                                prev.scanSettings.valueType,
                                prev.searchPatternLength
                              ),
                              type: prev.scanSettings.valueType,
                              description: "Scan result",
                            };
                          }
                        }
                      );
                    
                    console.log(`Processed scan results:`, {
                      resultsLength: results.length,
                      firstFive: results.slice(0, 5),
                    });

                    // Update global state
                    uiActions.setScanResults(results);
                    uiActions.updateScannerState({
                      scanResults: results,
                      totalResults: resultsData.found,
                      scanProgress: 100,
                      isScanning: false,
                    });

                    const newHistory =
                      prev.currentScanIndex === -1
                        ? [results]
                        : [...prev.scanHistory, results];
                    return {
                      ...prev,
                      isScanning: false,
                      scanResults: results,
                      scanHistory: newHistory,
                      currentScanIndex: newHistory.length - 1,
                      totalResults: resultsData.found,
                      scanProgress: 100,
                    };
                  });

                  // Lock settings after first successful scan
                  setIsSettingsLocked(true);
                }
              } catch (error) {
                console.error("Failed to fetch scan results:", error);
                setScannerState((prev) => ({
                  ...prev,
                  isScanning: false,
                  scanProgress: 100,
                }));
                uiActions.updateScannerState({ isScanning: false });
              }
            }
          }
        } catch (error) {
          console.error("Failed to get scan progress:", error);
        }
      }, 100); // Poll every 100ms
    },
    [apiClient, uiActions]
  );

  // Function to stop progress polling
  const stopProgressPolling = useCallback(() => {
    if (progressIntervalRef.current) {
      clearInterval(progressIntervalRef.current);
      progressIntervalRef.current = null;
    }
  }, []);

  // Clean up interval on unmount
  useEffect(() => {
    return () => {
      stopProgressPolling();
    };
  }, [stopProgressPolling]);

  const updateScanSettings = useCallback(
    (settings: ScanSettings) => {
      // Update both local state and global store
      setScannerState((prev) => ({
        ...prev,
        scanSettings: settings,
      }));
      uiActions.setScanSettings(settings);
      return true;
    },
    [uiActions]
  );

  // Perform pointer scan using Tauri command
  const performPointerScan = useCallback(
    async (currentSettings: ScanSettings) => {
      console.log("Starting pointer scan...");

      setScannerState((prev) => ({
        ...prev,
        isScanning: true,
        scanProgress: 0,
      }));

      uiActions.updateScannerState({
        isScanning: true,
        scanProgress: 0,
      });

      try {
        const { invoke } = await import("@tauri-apps/api/core");

        // Prepare files with target addresses
        const files = (currentSettings.ptrMapFilePaths || []).map(
          (f: { path: string; name: string; targetAddress?: string }) => ({
            path: f.path,
            targetAddress: f.targetAddress || "",
          })
        );

        if (files.length < 2) {
          throw new Error("At least 2 PointerMap files are required");
        }

        // Check all files have target addresses
        for (const file of files) {
          if (!file.targetAddress) {
            throw new Error(
              "All PointerMap files must have a target address set"
            );
          }
        }

        // Update progress: Loading files
        uiActions.updateScannerState({ 
          scanProgress: 10,
          currentRegion: "Loading PointerMap files..."
        });

        console.log("Calling run_pointer_scan with:", {
          files,
          maxDepth: currentSettings.ptrMaxDepth || 5,
          maxOffset: currentSettings.ptrMaxOffset || 4096,
        });

        // Set up event listener for PTR scan progress
        const { listen } = await import("@tauri-apps/api/event");
        const unlisten = await listen<{
          nodesProcessed: number;
          chainsFound: number;
          fileIndex: number;
          totalFiles: number;
          phase?: string;
        }>("ptr-scan-progress", (event) => {
          const { nodesProcessed, chainsFound, fileIndex, totalFiles, phase } = event.payload;
          
          let progressText: string;
          let progressPercent: number;
          
          switch (phase) {
            case "loading":
              progressText = `Loading file ${fileIndex + 1}/${totalFiles}...`;
              progressPercent = 10 + Math.floor((fileIndex / totalFiles) * 10);
              break;
            case "decompressing":
              progressText = "Decompressing files...";
              progressPercent = 25;
              break;
            case "scanning":
              progressText = `File ${fileIndex + 1}/${totalFiles}: Nodes: ${nodesProcessed.toLocaleString()} / Chains: ${chainsFound.toLocaleString()}`;
              progressPercent = 30 + Math.floor((fileIndex / totalFiles) * 50);
              break;
            case "complete":
              progressText = `Completed: ${chainsFound.toLocaleString()} chains found`;
              progressPercent = 80;
              break;
            default:
              progressText = `File ${fileIndex + 1}/${totalFiles}: Nodes: ${nodesProcessed.toLocaleString()} / Chains: ${chainsFound.toLocaleString()}`;
              progressPercent = 30 + Math.floor((fileIndex / totalFiles) * 50);
          }
          
          uiActions.updateScannerState({
            scanProgress: progressPercent,
            currentRegion: progressText
          });
        });

        // Update progress: Scanning
        uiActions.updateScannerState({ 
          scanProgress: 30,
          currentRegion: "Scanning for pointer chains..."
        });

        const results = await invoke<
          Array<{
            chain: Array<{ module?: string; offset: number }>;
            finalAddress: string;
          }>
        >("run_pointer_scan", {
          files,
          maxDepth: currentSettings.ptrMaxDepth || 5,
          maxOffset: currentSettings.ptrMaxOffset || 4096,
        });

        // Stop listening for progress events
        unlisten();

        // Update progress: Processing results
        uiActions.updateScannerState({ 
          scanProgress: 80,
          currentRegion: "Processing results..."
        });

        console.log(`Pointer scan found ${results.length} results`);

        // Convert pointer scan results to scan results format
        // Format: baseaddress | offset0 | offset1 | ...
        const scanResults: ScanResult[] = results.map((result, index) => {
          // Build chain parts: first is base (module+offset), rest are offsets
          const chainParts: string[] = [];
          
          // Helper to extract filename from path
          const getFileName = (path: string): string => {
            const parts = path.split(/[\\/]/);
            return parts[parts.length - 1] || path;
          };
          
          for (let i = 0; i < result.chain.length; i++) {
            const step = result.chain[i];
            if (i === 0 && step.module) {
              // Base address: module filename + offset (lowercase hex)
              const moduleName = getFileName(step.module);
              chainParts.push(`${moduleName}+0x${step.offset.toString(16)}`);
            } else {
              // Offset (lowercase hex)
              const offsetStr = step.offset >= 0
                ? `0x${step.offset.toString(16)}`
                : `-0x${Math.abs(step.offset).toString(16)}`;
              chainParts.push(offsetStr);
            }
          }
          
          const chainStr = chainParts.join(" | ");

          return {
            address: result.finalAddress,
            value: chainStr,
            previousValue: "",
            moduleName: result.chain[0]?.module || "",
            type: "ptr" as ScanValueType,
            index: index,
          };
        });

        // Update state with results
        setScannerState((prev) => ({
          ...prev,
          scanResults,
          totalResults: scanResults.length,
          isScanning: false,
          scanProgress: 100,
        }));

        uiActions.updateScannerState({
          isScanning: false,
          scanProgress: 100,
          scanResults,
          totalResults: scanResults.length,
        });

        console.log("Pointer scan complete");
      } catch (error) {
        console.error("Pointer scan failed:", error);
        setScannerState((prev) => ({
          ...prev,
          isScanning: false,
          scanProgress: 0,
        }));
        uiActions.updateScannerState({
          isScanning: false,
          scanProgress: 0,
        });
      }
    },
    [uiActions]
  );

  const performFirstScan = useCallback(async () => {
    const currentScanId = scannerState.scanId;
    console.log(`Starting first scan with ID: ${currentScanId}`);

    // Get current settings from global store to ensure we have the latest
    const currentSettings = ui.scannerState.scanSettings as ScanSettings;

    // Handle PTR mode (pointer scan)
    if (currentSettings.searchMode === "ptr") {
      await performPointerScan(currentSettings);
      return;
    }

    setScannerState((prev) => ({
      ...prev,
      isScanning: true,
      scanProgress: 0,
      scannedBytes: 0,
      totalBytes: 0,
      currentRegion: undefined,
    }));

    // Update global state
    uiActions.updateScannerState({
      isScanning: true,
      scanProgress: 0,
    });

    try {
      // Convert frontend types to backend types using current settings
      const backendDataType = mapToBackendDataType(
        currentSettings.valueType as ScanValueType
      );
      const backendFindType = mapToBackendFindType(
        currentSettings.scanType as ScanType
      );

      // Get valid memory regions within the specified range
      const startAddr = parseInt(currentSettings.startAddress || "0x0", 16);
      const endAddr = parseInt(
        currentSettings.endAddress || "0x7FFFFFFFFFFF",
        16
      );

      console.log(
        `Getting memory regions in range: 0x${startAddr.toString(16)} - 0x${endAddr.toString(16)}`
      );

      // Get all memory regions
      const memoryMapResponse = await apiClient.enumerateRegions();

      // Filter regions based on address range and permissions
      const validRegions = memoryMapResponse.regions.filter(
        (region: MemoryRegion) => {
          const regionStart = parseInt(region.start_address, 16);
          const regionEnd = parseInt(region.end_address, 16);

          // Check if region overlaps with our target range
          const overlaps = regionStart < endAddr && regionEnd > startAddr;
          if (!overlaps) return false;

          // Check permissions based on protection string (e.g., "rwx", "r--", "rw-")
          const protection = region.protection.toLowerCase();

          if (currentSettings.readable && !protection.includes("r"))
            return false;
          if (currentSettings.writable && !protection.includes("w"))
            return false;
          if (currentSettings.executable && !protection.includes("x"))
            return false;

          return true;
        }
      );

      // Convert valid regions to address ranges
      const addressRanges: [number, number][] = validRegions.map(
        (region: MemoryRegion) => {
          const regionStart = parseInt(region.start_address, 16);
          const regionEnd = parseInt(region.end_address, 16);

          // Clamp to our target range
          const clampedStart = Math.max(regionStart, startAddr);
          const clampedEnd = Math.min(regionEnd, endAddr);

          return [clampedStart, clampedEnd];
        }
      );

      console.log(
        `Found ${validRegions.length} valid memory regions:`,
        addressRanges
          .map(
            ([start, end]) => `0x${start.toString(16)}-0x${end.toString(16)}`
          )
          .join(", ")
      );

      if (addressRanges.length === 0) {
        throw new Error(
          "No valid memory regions found in the specified range with the selected permissions"
        );
      }

      // YARA scan mode - use YARA API with progress polling
      if ((currentSettings as any).searchMode === "yara") {
        const yaraRule = (currentSettings as any).yaraRule || "";
        if (!yaraRule.trim()) {
          throw new Error("YARA rule is required for YARA scan mode");
        }

        console.log(`Starting YARA scan with rule:`, yaraRule);

        const yaraRequest = {
          rule: yaraRule,
          address_ranges: addressRanges,
          scan_id: currentScanId,
          align: currentSettings.alignment,
          do_suspend: currentSettings.doSuspend,
        };

        const yaraResponse = await apiClient.yaraScan(yaraRequest);
        console.log(`YARA scan response:`, yaraResponse);

        if (!yaraResponse.success) {
          throw new Error(yaraResponse.message || "YARA scan failed");
        }

        // Start progress polling - YARA scan runs in background like normal scan
        startProgressPolling(currentScanId);
        return; // Exit early - results will be fetched via progress polling
      }

      // Convert the search value to hex bytes based on data type
      const pattern = convertValueToHexBytes(
        currentSettings.value,
        currentSettings.valueType as ScanValueType,
        currentSettings.valueInputFormat || "dec"
      );

      // For range search, also convert the max value
      const patternMax =
        currentSettings.scanType === "range" &&
        (currentSettings as ScanSettings).valueMax
          ? convertValueToHexBytes(
              (currentSettings as ScanSettings).valueMax!,
              currentSettings.valueType as ScanValueType,
              currentSettings.valueInputFormat || "dec"
            )
          : undefined;

      // Calculate the pattern length for proper result display based on data type
      const patternLength = (() => {
        switch (currentSettings.valueType as ScanValueType) {
          case "int8":
          case "uint8":
            return 1;
          case "int16":
          case "uint16":
            return 2;
          case "int32":
          case "uint32":
          case "float":
            return 4;
          case "int64":
          case "uint64":
          case "double":
            return 8;
          case "bytes":
            return pattern.length / 2; // Each pair of hex chars = 1 byte
          case "string":
            return pattern.length / 2; // String length in bytes
          default:
            return undefined;
        }
      })();

      console.log(`Pattern length calculation:`, {
        valueType: currentSettings.valueType,
        pattern,
        patternLength,
        searchValue: currentSettings.value,
      });

      console.log(
        `Converting search value "${currentSettings.value}" (${currentSettings.valueType}) to hex pattern: ${pattern}`
      );

      // Store pattern length for result display
      setScannerState((prev) => ({
        ...prev,
        searchPatternLength: patternLength,
      }));

      // For unknown scan, use server-side streaming API
      if (currentSettings.scanType === "unknown") {
        try {
          await performUnknownScanStreaming(
            addressRanges,
            currentSettings.alignment,
            currentSettings.valueType as string,
            currentScanId,
            currentSettings.doSuspend
          );
          return; // Exit early for unknown scan
        } catch (error) {
          console.error("Unknown scan streaming failed:", error);
          throw error;
        }
      }

      // Build scan request - normal scan types
      const scanRequest: MemoryScanRequest = {
        pattern: pattern,
        ...(patternMax ? { pattern_max: patternMax } : {}),
        address_ranges: addressRanges,
        find_type: backendFindType,
        data_type: backendDataType,
        scan_id: currentScanId,
        align: currentSettings.alignment,
        return_as_json: false, // Don't return results immediately
        do_suspend: currentSettings.doSuspend,
      };

      console.log(`Sending scan request:`, scanRequest);

      // Start the scan (which now returns immediately)
      const response = await apiClient.memoryScan(scanRequest);
      console.log(`Scan started response:`, response);

      // Add to scan history after successful scan start
      const needsValue = ["exact", "bigger", "smaller", "range"].includes(
        currentSettings.scanType
      );
      if (needsValue && currentSettings.value.trim()) {
        // Generate a simple description without redundant type info
        const description = "";
        const newItem: ScanHistoryItem = {
          id: `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          valueType: currentSettings.valueType as ScanValueType,
          scanType: currentSettings.scanType as ScanType,
          value: currentSettings.value,
          description,
          timestamp: new Date(),
          scanSettings: {
            startAddress: currentSettings.startAddress,
            endAddress: currentSettings.endAddress,
            scanMode: currentSettings.scanMode as "manual" | "regions",
            selectedRegions: currentSettings.selectedRegions,
            alignment: currentSettings.alignment,
            writable: currentSettings.writable,
            executable: currentSettings.executable,
            readable: currentSettings.readable,
            doSuspend: currentSettings.doSuspend,
            searchMode: (currentSettings as any).searchMode || "normal",
            yaraRule: (currentSettings as any).yaraRule || "",
          },
        };
        uiActions.addScanHistory(newItem);
      }

      // Start progress polling to monitor the scan
      startProgressPolling(currentScanId);
    } catch (error) {
      console.error("Scan failed:", error);
      setScannerState((prev) => ({
        ...prev,
        isScanning: false,
        scanProgress: 0,
        errorMessage:
          error instanceof Error ? error.message : "Scan failed: Unknown error",
      }));
      uiActions.updateScannerState({ isScanning: false });
      stopProgressPolling();

      // Check if it's a connection-related error
      if (error instanceof Error) {
        if (
          error.message.includes("Authentication failed") ||
          error.message.includes("Server access denied") ||
          error.message.includes("Network error") ||
          error.message.includes("Connection refused")
        ) {
          console.warn("Connection error during scan:", error.message);
        }
      }
    }
  }, [
    scannerState.scanId,
    apiClient,
    startProgressPolling,
    startUnknownScanProgressPolling,
    stopProgressPolling,
    performUnknownScanStreaming,
    ui.scannerState.scanSettings,
    uiActions,
  ]);

  const performNextScan = useCallback(async () => {
    if (scannerState.scanResults.length === 0) return;

    // Allow comparison-based scan types after any scan (not just first)
    const comparisonTypes = ["changed", "unchanged", "increased", "decreased"];
    if (
      comparisonTypes.includes(scannerState.scanSettings.scanType) &&
      scannerState.scanHistory.length === 0
    ) {
      console.error(
        "Comparison-based scan types require at least one previous scan"
      );
      return;
    }

    const currentScanId = scannerState.scanId;
    console.log(`Starting next scan with ID: ${currentScanId}`);

    setScannerState((prev) => ({
      ...prev,
      isScanning: true,
      scanProgress: 0,
      scannedBytes: 0,
      totalBytes: 0,
      currentRegion: undefined,
    }));

    uiActions.updateScannerState({ isScanning: true, scanProgress: 0 });

    try {
      const backendDataType = mapToBackendDataType(
        scannerState.scanSettings.valueType
      );
      const backendFilterMethod = mapToBackendFindType(
        scannerState.scanSettings.scanType
      );

      // Define comparison types that don't require value input
      const comparisonTypes = [
        "changed",
        "unchanged",
        "increased",
        "decreased",
        "greater_than",
        "less_than",
      ];

      // Convert the search value to hex bytes based on data type
      // For comparison types, use empty pattern
      const pattern = comparisonTypes.includes(
        scannerState.scanSettings.scanType
      )
        ? ""
        : convertValueToHexBytes(
            scannerState.scanSettings.value,
            scannerState.scanSettings.valueType,
            scannerState.scanSettings.valueInputFormat || "dec"
          );

      // For range filter, also convert the max value
      const patternMax =
        scannerState.scanSettings.scanType === "range" &&
        scannerState.scanSettings.valueMax
          ? convertValueToHexBytes(
              scannerState.scanSettings.valueMax,
              scannerState.scanSettings.valueType,
              scannerState.scanSettings.valueInputFormat || "dec"
            )
          : undefined;

      console.log(
        `Filter: Converting search value "${scannerState.scanSettings.value}" (${scannerState.scanSettings.scanType}) to hex pattern: ${pattern}`
      );

      // If we have unknown scan results stored in temp files, use native filter
      if (scannerState.unknownScanId) {
        console.log(`Using native filter for unknown scan results`);

        // Get current addresses from scan results
        const addresses = scannerState.scanResults.map((r) =>
          parseInt(r.address, 16)
        );

        // For comparison types, we need previous values as byte arrays
        const oldValues = comparisonTypes.includes(
          scannerState.scanSettings.scanType
        )
          ? scannerState.scanResults.map((r) => {
              // Convert the current value to hex bytes, then to byte array
              const hexBytes = convertValueToHexBytes(
                String(r.value),
                scannerState.scanSettings.valueType,
                scannerState.scanSettings.valueInputFormat || "dec"
              );
              // Convert hex string to byte array
              const bytes: number[] = [];
              for (let i = 0; i < hexBytes.length; i += 2) {
                bytes.push(parseInt(hexBytes.substr(i, 2), 16));
              }
              return bytes;
            })
          : scannerState.scanResults.map(() => [] as number[]);

        const nativeFilterResponse = await apiClient.filterMemoryNative({
          addresses,
          old_values: oldValues,
          pattern: pattern || "",
          pattern_max: patternMax,
          filter_method: backendFilterMethod,
          data_type: backendDataType,
        });

        if (nativeFilterResponse.success) {
          const results: ScanResult[] = nativeFilterResponse.results.map(
            (item) => {
              const hexValue = item.value
                .map((b) => b.toString(16).padStart(2, "0"))
                .join("");
              return {
                address: `0x${item.address.toString(16)}`,
                value: convertHexBytesToValue(
                  hexValue,
                  scannerState.scanSettings.valueType,
                  scannerState.searchPatternLength
                ),
                type: scannerState.scanSettings.valueType,
                description: "Filter result",
              };
            }
          );

          const newHistory = [...scannerState.scanHistory, results];

          setScannerState((prev) => ({
            ...prev,
            isScanning: false,
            scanResults: results,
            scanHistory: newHistory,
            currentScanIndex: newHistory.length - 1,
            totalResults: results.length,
            scanProgress: 100,
          }));

          uiActions.setScanResults(results);
          uiActions.updateScannerState({
            scanResults: results,
            totalResults: results.length,
            scanProgress: 100,
            isScanning: false,
          });

          console.log(`Native filter completed: ${results.length} results`);
          return;
        } else {
          throw new Error(nativeFilterResponse.error || "Native filter failed");
        }
      }

      const filterRequest: FilterRequest = {
        pattern: pattern,
        ...(patternMax ? { pattern_max: patternMax } : {}),
        data_type: backendDataType,
        scan_id: currentScanId,
        filter_method: backendFilterMethod,
        return_as_json: false, // Don't return results immediately
        do_suspend: scannerState.scanSettings.doSuspend,
      };

      console.log(`Sending filter request:`, filterRequest);

      // Start the filter (which now returns immediately)
      const response = await apiClient.memoryFilter(filterRequest);
      console.log(`Filter started response:`, response);

      // Start filter progress polling to monitor the filter using filter_id from response
      if (response.success && response.filter_id) {
        startFilterProgressPolling(response.filter_id);
      } else {
        throw new Error("Failed to start filter: " + response.message);
      }
    } catch (error) {
      console.error("Next scan failed:", error);
      setScannerState((prev) => ({
        ...prev,
        isScanning: false,
        scanProgress: 0,
        errorMessage:
          error instanceof Error
            ? error.message
            : "Filter failed: Unknown error",
      }));
      uiActions.updateScannerState({ isScanning: false });
      stopProgressPolling();

      // Check if it's a connection-related error
      if (error instanceof Error) {
        if (
          error.message.includes("Authentication failed") ||
          error.message.includes("Server access denied") ||
          error.message.includes("Network error") ||
          error.message.includes("Connection refused")
        ) {
          console.warn("Connection error during filter:", error.message);
        }
      }
    }
  }, [
    scannerState.scanResults,
    scannerState.scanHistory,
    scannerState.scanSettings,
    scannerState.scanId,
    scannerState.unknownScanId,
    scannerState.searchPatternLength,
    apiClient,
    startFilterProgressPolling,
    stopProgressPolling,
    uiActions,
  ]);

  // Native filter function - processes filter locally using Tauri with network memory reads
  // This is more efficient for smaller result sets and provides immediate feedback
  const performNativeFilter = useCallback(async () => {
    if (scannerState.scanResults.length === 0) return;

    const comparisonTypes = ["changed", "unchanged", "increased", "decreased"];
    if (
      comparisonTypes.includes(scannerState.scanSettings.scanType) &&
      scannerState.scanHistory.length === 0
    ) {
      console.error(
        "Comparison-based scan types require at least one previous scan"
      );
      return;
    }

    setScannerState((prev) => ({
      ...prev,
      isScanning: true,
      scanProgress: 0,
      scannedBytes: 0,
      totalBytes: prev.scanResults.length,
      currentRegion: "Native filter processing...",
    }));

    uiActions.updateScannerState({ isScanning: true, scanProgress: 0 });

    try {
      const backendDataType = mapToBackendDataType(
        scannerState.scanSettings.valueType
      );
      const backendFilterMethod = mapToBackendFindType(
        scannerState.scanSettings.scanType
      );

      // Prepare addresses and old values from current scan results
      const addresses: number[] = [];
      const oldValues: number[][] = [];

      for (const result of scannerState.scanResults) {
        // Parse address
        const addr = parseInt(result.address.replace("0x", ""), 16);
        if (!isNaN(addr)) {
          addresses.push(addr);
          // Convert old value to byte array
          const oldHex = convertValueToHexBytes(
            String(result.value),
            scannerState.scanSettings.valueType,
            scannerState.scanSettings.valueInputFormat || "dec"
          );
          const bytes: number[] = [];
          for (let i = 0; i < oldHex.length; i += 2) {
            bytes.push(parseInt(oldHex.substr(i, 2), 16));
          }
          oldValues.push(bytes);
        }
      }

      // Convert pattern to hex
      const noValueTypes = ["changed", "unchanged", "increased", "decreased"];
      const pattern = noValueTypes.includes(scannerState.scanSettings.scanType)
        ? ""
        : convertValueToHexBytes(
            scannerState.scanSettings.value,
            scannerState.scanSettings.valueType,
            scannerState.scanSettings.valueInputFormat || "dec"
          );

      const patternMax =
        scannerState.scanSettings.scanType === "range" &&
        scannerState.scanSettings.valueMax
          ? convertValueToHexBytes(
              scannerState.scanSettings.valueMax,
              scannerState.scanSettings.valueType,
              scannerState.scanSettings.valueInputFormat || "dec"
            )
          : undefined;

      console.log(
        `Native filter: ${addresses.length} addresses, method: ${backendFilterMethod}`
      );

      const response = await apiClient.filterMemoryNative({
        addresses,
        old_values: oldValues,
        pattern,
        pattern_max: patternMax,
        data_type: backendDataType,
        filter_method: backendFilterMethod,
      });

      if (response.success) {
        const results: ScanResult[] = response.results.map((item) => {
          // Convert byte array to hex string for value conversion
          const hexValue = item.value
            .map((b) => b.toString(16).padStart(2, "0"))
            .join("");
          return {
            address: `0x${item.address.toString(16)}`,
            value: convertHexBytesToValue(
              hexValue,
              scannerState.scanSettings.valueType,
              scannerState.searchPatternLength
            ),
            type: scannerState.scanSettings.valueType,
            description: "Native filter result",
          };
        });

        const newHistory = [...scannerState.scanHistory, results];

        setScannerState((prev) => ({
          ...prev,
          isScanning: false,
          scanResults: results,
          scanHistory: newHistory,
          currentScanIndex: newHistory.length - 1,
          totalResults: results.length,
          scanProgress: 100,
          currentRegion: undefined,
        }));

        uiActions.setScanResults(results);
        uiActions.updateScannerState({
          scanResults: results,
          totalResults: results.length,
          scanProgress: 100,
          isScanning: false,
        });
      } else {
        throw new Error(response.error || "Native filter failed");
      }
    } catch (error) {
      console.error("Native filter failed:", error);
      setScannerState((prev) => ({
        ...prev,
        isScanning: false,
        scanProgress: 0,
        errorMessage:
          error instanceof Error
            ? error.message
            : "Native filter failed: Unknown error",
      }));
      uiActions.updateScannerState({ isScanning: false });
    }
  }, [
    scannerState.scanResults,
    scannerState.scanHistory,
    scannerState.scanSettings,
    scannerState.searchPatternLength,
    apiClient,
    uiActions,
  ]);

  // Native lookup function - refreshes values for all current results using Tauri
  const performNativeLookup = useCallback(async () => {
    if (scannerState.scanResults.length === 0) return;

    setScannerState((prev) => ({
      ...prev,
      currentRegion: "Refreshing values...",
    }));

    try {
      const addresses: number[] = scannerState.scanResults.map((result) =>
        parseInt(result.address.replace("0x", ""), 16)
      );

      const backendDataType = mapToBackendDataType(
        scannerState.scanSettings.valueType
      );

      const response = await apiClient.lookupMemoryNative(
        addresses,
        backendDataType
      );

      if (response.success) {
        // Create a map of address -> new value for quick lookup
        const valueMap = new Map<string, string>();
        for (const item of response.results) {
          const hexValue = item.value
            .map((b) => b.toString(16).padStart(2, "0"))
            .join("");
          const convertedValue = convertHexBytesToValue(
            hexValue,
            scannerState.scanSettings.valueType,
            scannerState.searchPatternLength
          );
          valueMap.set(
            `0x${item.address.toString(16)}`,
            String(convertedValue)
          );
        }

        // Update results with new values
        const updatedResults = scannerState.scanResults.map((result) => ({
          ...result,
          value: valueMap.get(result.address) ?? result.value,
        }));

        setScannerState((prev) => ({
          ...prev,
          scanResults: updatedResults,
          currentRegion: undefined,
        }));

        uiActions.setScanResults(updatedResults);
      } else {
        console.error("Native lookup failed:", response.error);
      }
    } catch (error) {
      console.error("Native lookup error:", error);
      setScannerState((prev) => ({
        ...prev,
        currentRegion: undefined,
      }));
    }
  }, [
    scannerState.scanResults,
    scannerState.scanSettings.valueType,
    scannerState.searchPatternLength,
    apiClient,
    uiActions,
  ]);

  const performNewScan = useCallback(() => {
    const newScanId = generateScanId();
    // Stop any existing progress polling
    stopProgressPolling();

    // Clear unknown scan temp files if any
    if (scannerState.unknownScanId) {
      apiClient.clearUnknownScan(scannerState.unknownScanId).catch((e) => {
        console.warn("Failed to clear unknown scan temp files:", e);
      });
    }

    // Unlock settings for new scan
    setIsSettingsLocked(false);

    setScannerState((prev) => ({
      ...prev,
      scanResults: [],
      scanHistory: [],
      currentScanIndex: -1,
      totalResults: 0,
      scanId: newScanId,
      scanProgress: 0,
      scannedBytes: 0,
      totalBytes: 0,
      currentRegion: undefined,
      searchPatternLength: undefined, // Reset pattern length
      scanSettings: defaultScanSettings, // Reset to default settings
      unknownScanId: undefined, // Clear unknown scan ID
      unknownScanTempDir: undefined, // Clear unknown scan temp dir
    }));

    // Update global state
    uiActions.clearScanResults();
    uiActions.updateScannerState({
      scanProgress: 0,
      isScanning: false,
    });
  }, [stopProgressPolling, uiActions, scannerState.unknownScanId, apiClient]);

  const handleResultEdit = useCallback(
    async (
      address: string,
      newValue: string,
      valueType: ScanValueType,
      inputFormat: "dec" | "hex" = "dec"
    ) => {
      try {
        // Convert the new value to hex bytes based on data type and input format
        const hexBytes = convertValueToHexBytes(
          newValue,
          valueType,
          inputFormat
        );

        // Convert hex string to ArrayBuffer
        const bytes = new Uint8Array(hexBytes.length / 2);
        for (let i = 0; i < hexBytes.length; i += 2) {
          bytes[i / 2] = parseInt(hexBytes.substr(i, 2), 16);
        }
        const buffer = bytes.buffer;

        // Write to memory
        await apiClient.writeMemory(address, buffer);

        // Update the local state with the new value
        setScannerState((prev) => ({
          ...prev,
          scanResults: prev.scanResults.map((result) =>
            result.address === address ? { ...result, value: newValue } : result
          ),
        }));

        // Update global state
        const updatedResults = scanResults.map((result) =>
          result.address === address ? { ...result, value: newValue } : result
        );
        uiActions.setScanResults(updatedResults);

        console.log(
          `Successfully wrote value "${newValue}" to address ${address}`
        );
      } catch (error) {
        console.error(`Failed to write value to address ${address}:`, error);
        throw error;
      }
    },
    [apiClient, scanResults, uiActions]
  );

  const handleResultDelete = useCallback(
    (address: string) => {
      setScannerState((prev) => ({
        ...prev,
        scanResults: prev.scanResults.filter(
          (result) => result.address !== address
        ),
        totalResults: prev.totalResults - 1,
      }));

      // Update global state
      const updatedResults = scanResults.filter(
        (result) => result.address !== address
      );
      uiActions.setScanResults(updatedResults);
      uiActions.updateScannerState({
        totalResults: updatedResults.length,
      });
    },
    [scanResults, uiActions]
  );

  const handleResultBookmark = useCallback(
    (address: string, bookmarked: boolean) => {
      if (bookmarked) {
        // Add to bookmarks
        const existingResult = scannerState.scanResults.find(
          (r) => r.address === address
        );
        if (existingResult) {
          const newBookmark: BookmarkItem = {
            id: `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            address,
            value: existingResult.value.toString(),
            type: existingResult.type,
            description:
              existingResult.description || `Bookmarked from scan results`,
            createdAt: new Date(),
            tags: [],
          };

          // Check if already bookmarked
          if (!bookmarks.some((b) => b.address === address)) {
            uiActions.addBookmark(newBookmark);
            console.log(`Added bookmark for address: ${address}`);
          }
        }
      } else {
        // Remove from bookmarks
        const bookmark = bookmarks.find((b) => b.address === address);
        if (bookmark) {
          uiActions.removeBookmark(bookmark.id);
          console.log(`Removed bookmark for address: ${address}`);
        }
      }
    },
    [scannerState.scanResults, bookmarks, uiActions]
  );

  // Function to add manual bookmark by address
  const addManualBookmark = useCallback(
    async (
      address: string,
      valueType: ScanValueType,
      description?: string,
      libraryExpression?: string,
      size?: number,
      displayFormat?: "dec" | "hex",
      ptrValueType?: Exclude<ScanValueType, "ptr" | "string" | "bytes" | "regex">
    ) => {
      try {
        console.log("[addManualBookmark] Called with:", {
          address,
          valueType,
          description,
          libraryExpression,
          size,
          displayFormat,
          ptrValueType,
        });

        // For PTR type, the address is a pointer expression like [[base]+0x8]+0x10
        // Don't normalize it as a hex address
        const addressTrimmed = address.trim();
        
        if (valueType === "ptr") {
          // PTR type: keep the pointer expression as-is
          // Just store it directly without trying to parse as hex
          const newBookmark: BookmarkItem = {
            id: `bookmark-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            address: addressTrimmed,
            value: "(pointer chain)",
            type: valueType,
            ptrValueType: ptrValueType || "int32",
            description: description || "Pointer chain",
            displayFormat: displayFormat,
            createdAt: new Date(),
            tags: [],
          };
          
          if (!bookmarks.some((b) => b.address === addressTrimmed)) {
            uiActions.addBookmark(newBookmark);
            console.log("[addManualBookmark] PTR bookmark added:", newBookmark);
            return true;
          } else {
            console.warn("[addManualBookmark] PTR address already bookmarked:", addressTrimmed);
            return false;
          }
        }

        // Normalize address to proper hex format
        let normalizedAddress = address.trim();

        // If address doesn't start with 0x, assume it's decimal and convert to hex
        if (!/^0x/i.test(normalizedAddress)) {
          const decimalValue = parseInt(normalizedAddress, 10);
          if (!isNaN(decimalValue)) {
            normalizedAddress = `0x${decimalValue.toString(16).toUpperCase()}`;
          } else {
            throw new Error("Invalid address format");
          }
        } else {
          // If already hex, ensure proper format (0x prefix, uppercase)
          normalizedAddress = "0x" + normalizedAddress.slice(2).toUpperCase();
        }

        console.log(
          "[addManualBookmark] Normalized address:",
          normalizedAddress
        );

        // Try to read current value from memory
        // Use empty string as default for string type, "0" for others
        let currentValue = valueType === "string" ? "" : "0";
        try {
          // Calculate read size based on value type
          const readSize =
            valueType === "int8" || valueType === "uint8"
              ? 1
              : valueType === "int16" || valueType === "uint16"
                ? 2
                : valueType === "int32" ||
                    valueType === "uint32" ||
                    valueType === "float"
                  ? 4
                  : valueType === "int64" ||
                      valueType === "uint64" ||
                      valueType === "double"
                    ? 8
                    : valueType === "string"
                      ? size || 64 // Use provided size or default 64 for strings
                      : valueType === "bytes"
                        ? size || 4 // Use provided size or default 4 for bytes
                        : 4;

          const buffer = await apiClient.readMemory(
            normalizedAddress,
            readSize
          );
          // Convert buffer to value based on type
          const view = new DataView(buffer);

          switch (valueType) {
            case "int8":
              currentValue = view.getInt8(0).toString();
              break;
            case "uint8":
              currentValue = view.getUint8(0).toString();
              break;
            case "int16":
              currentValue = view.getInt16(0, true).toString();
              break;
            case "uint16":
              currentValue = view.getUint16(0, true).toString();
              break;
            case "int32":
              currentValue = view.getInt32(0, true).toString();
              break;
            case "uint32":
              currentValue = view.getUint32(0, true).toString();
              break;
            case "int64":
              currentValue = view.getBigInt64(0, true).toString();
              break;
            case "uint64":
              currentValue = view.getBigUint64(0, true).toString();
              break;
            case "float":
              currentValue = view.getFloat32(0, true).toString();
              break;
            case "double":
              currentValue = view.getFloat64(0, true).toString();
              break;
            case "string": {
              // Read as ASCII string (1 byte per character)
              const uint8Array = new Uint8Array(buffer);
              let str = "";
              for (let i = 0; i < uint8Array.length; i++) {
                const byte = uint8Array[i];
                if (byte === 0) break; // Stop at null terminator
                // Only include printable ASCII characters
                if (byte >= 32 && byte <= 126) {
                  str += String.fromCharCode(byte);
                }
                // Non-printable characters are ignored
              }
              currentValue = str;
              break;
            }
            case "bytes": {
              // Read as hex bytes (space-separated)
              currentValue = Array.from(new Uint8Array(buffer))
                .map((b) => b.toString(16).padStart(2, "0").toUpperCase())
                .join(" ");
              break;
            }
            default:
              currentValue = "0";
          }
        } catch (error) {
          console.warn(
            `Could not read memory at ${normalizedAddress}, using default value`
          );
        }

        const newBookmark: BookmarkItem = {
          id: `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          address: normalizedAddress,
          libraryExpression: libraryExpression, // Save library+offset expression if provided
          value: currentValue,
          type: valueType,
          size:
            valueType === "string" || valueType === "bytes" ? size : undefined, // Save size for string/bytes
          description: description || `Manual bookmark`,
          createdAt: new Date(),
          tags: [],
        };

        console.log("[addManualBookmark] Creating bookmark:", newBookmark);
        console.log(
          "[addManualBookmark] Current bookmarks count:",
          bookmarks.length
        );

        // Check if already bookmarked
        if (!bookmarks.some((b) => b.address === normalizedAddress)) {
          console.log(
            "[addManualBookmark] Address not already bookmarked, adding..."
          );
          uiActions.addBookmark(newBookmark);
          console.log("[addManualBookmark] Bookmark added successfully");
        } else {
          console.warn(
            "[addManualBookmark] Address already bookmarked:",
            normalizedAddress
          );
          return false;
        }

        console.log(
          `[addManualBookmark] Added manual bookmark for address: ${normalizedAddress}`
        );
        return true;
      } catch (error) {
        console.error(
          `[addManualBookmark] Failed to add manual bookmark for ${address}:`,
          error
        );
        return false;
      }
    },
    [apiClient, bookmarks, uiActions]
  );

  // Function to remove bookmark by ID
  const removeBookmark = useCallback(
    (bookmarkId: string) => {
      uiActions.removeBookmark(bookmarkId);
    },
    [uiActions]
  );

  // Function to update bookmark
  const updateBookmark = useCallback(
    (bookmarkId: string, updates: Partial<BookmarkItem>) => {
      // Find existing bookmark and update it
      const existingBookmark = bookmarks.find((b) => b.id === bookmarkId);
      if (existingBookmark) {
        const updatedBookmark = { ...existingBookmark, ...updates };
        // For simplicity, we'll remove and re-add
        uiActions.removeBookmark(bookmarkId);
        uiActions.addBookmark(updatedBookmark);
      }
    },
    [bookmarks, uiActions]
  );

  // Function to update bookmark addresses when modules are reloaded
  const updateBookmarkAddressesFromModules = useCallback(
    (modules: any[]) => {
      if (!modules || modules.length === 0) {
        return;
      }

      // Update bookmarks that have library expressions
      bookmarks.forEach((bookmark) => {
        if (bookmark.libraryExpression) {
          const newAddress = normalizeAddressString(
            bookmark.libraryExpression,
            modules
          );

          if (newAddress && newAddress !== bookmark.address) {
            console.log(
              `Updating bookmark ${bookmark.id}: ${bookmark.libraryExpression} from ${bookmark.address} to ${newAddress}`
            );
            updateBookmark(bookmark.id, { address: newAddress });
          }
        }
      });
    },
    [bookmarks, updateBookmark]
  );

  // Check if address is bookmarked
  const isAddressBookmarked = useCallback(
    (address: string) => {
      return bookmarks.some((b) => b.address === address);
    },
    [bookmarks]
  );

  const handleResultWatch = useCallback((address: string, watched: boolean) => {
    // TODO: Implement watch functionality
    console.log(
      `${watched ? "Added" : "Removed"} watch for address: ${address}`
    );
  }, []);

  // Stop current scan
  const stopScan = useCallback(async () => {
    try {
      console.log(`Stopping scan: ${scannerState.scanId}`);
      
      // Get current settings from global store
      const currentSettings = ui.scannerState.scanSettings as ScanSettings;
      
      // For pointer scan mode, use Tauri command to cancel
      if (currentSettings.searchMode === "ptr") {
        try {
          await invoke("cancel_pointer_scan");
          console.log("Pointer scan cancelled");
        } catch (error) {
          console.error("Failed to cancel pointer scan:", error);
        }
        setScannerState((prev) => ({
          ...prev,
          isScanning: false,
          scanProgress: 0,
        }));
        uiActions.updateScannerState({ isScanning: false });
        return;
      }
      
      const response = await apiClient.stopScan(scannerState.scanId);

      if (response.success) {
        setScannerState((prev) => ({
          ...prev,
          isScanning: false,
          scanProgress: 0,
          scannedBytes: 0,
          currentRegion: undefined,
        }));
        uiActions.updateScannerState({ isScanning: false });
        console.log("Scan stopped successfully");
      } else {
        console.error("Failed to stop scan:", response.message);
      }
    } catch (error) {
      console.error("Error stopping scan:", error);
    }
  }, [apiClient, scannerState.scanId, uiActions]);

  // Clear current scan data
  const clearScan = useCallback(async () => {
    try {
      console.log(`Clearing scan: ${scannerState.scanId}`);
      const response = await apiClient.clearScan(scannerState.scanId);

      if (response.success) {
        setScannerState((prev) => ({
          ...prev,
          scanResults: [],
          totalResults: 0,
          scanHistory: [],
          scanProgress: 0,
          scannedBytes: 0,
          totalBytes: 0,
          currentRegion: undefined,
          scanId: generateScanId(), // Generate new scan ID
        }));

        uiActions.clearScanResults();
        uiActions.updateScannerState({
          scanProgress: 0,
          isScanning: false,
        });

        console.log("Scan cleared successfully");
      } else {
        console.error("Failed to clear scan:", response.message);
      }
    } catch (error) {
      console.error("Error clearing scan:", error);
    }
  }, [apiClient, scannerState.scanId, uiActions]);

  // Function to handle history selection
  const handleSelectHistory = useCallback(
    (item: ScanHistoryItem) => {
      const newSettings: ScanSettings = {
        ...scannerState.scanSettings,
        ...item.scanSettings,
        valueType: item.valueType,
        scanType: item.scanType,
        value: item.value,
      };

      // Update both local state and global store
      setScannerState((prev) => ({
        ...prev,
        scanSettings: newSettings,
      }));

      // Also update global store
      uiActions.setScanSettings(newSettings);
    },
    [scannerState.scanSettings, uiActions]
  );

  return {
    scannerState,
    memoryRegions,
    memoryRegionsLoaded,
    isSettingsLocked,
    updateScanSettings,
    performFirstScan,
    performNextScan,
    performNewScan,
    performNativeFilter,
    performNativeLookup,
    handleResultEdit,
    handleResultDelete,
    handleResultBookmark,
    handleResultWatch,
    stopScan,
    clearScan,
    canNextScan:
      scannerState.scanHistory.length > 0 &&
      scannerState.scanResults.length > 0 &&
      !scannerState.isScanning,
    // Bookmark management
    bookmarks,
    addManualBookmark,
    removeBookmark,
    updateBookmark,
    updateBookmarkAddressesFromModules,
    isAddressBookmarked,
    // History management
    scanHistory: scanHistory,
    onSelectHistory: handleSelectHistory,
    onRemoveHistoryItem: (id: string) => {
      // Find the index of the item to remove
      const index = scanHistory.findIndex((item) => item.id === id);
      if (index >= 0) {
        uiActions.removeScanHistory(index);
      }
    },
    onClearHistory: () => uiActions.clearScanHistory(),
  };
};

```

`src/client/src/hooks/useSidebarWidth.ts`:

```ts
import { useEffect } from 'react';

/**
 * Hook to force DOM updates when sidebar width changes
 * This ensures grid layout recalculates properly
 */
export const useSidebarWidth = (sidebarWidth: number) => {
  useEffect(() => {
    // Force a layout recalculation
    const gridElement = document.querySelector('[data-sidebar-grid]');
    if (gridElement) {
      // Trigger reflow by reading a layout property
      gridElement.getBoundingClientRect();
    }
  }, [sidebarWidth]);
};

```

`src/client/src/hooks/useSymbolCache.ts`:

```ts
import { useCallback, useRef, useState, useEffect } from "react";
import { useUIStore, CachedSymbol } from "../stores/uiStore";
import { getApiClient, ModuleInfo } from "../lib/api";
import { invoke } from "@tauri-apps/api/core";

interface GhidraFunctionEntry {
  name: string;
  address: string;
  size: number;
}

/**
 * シンボルキャッシュを管理するカスタムフック
 * オンデマンドでモジュールのシンボル情報をロードし、
 * アドレスからシンボルを検索できるようにする
 */
export function useSymbolCache() {
  const globalSymbolCache = useUIStore((state) => state.globalSymbolCache);
  const assemblyDemangleEnabled = useUIStore(
    (state) => state.debuggerState.assemblyDemangleEnabled
  );
  const actions = useUIStore((state) => state.actions);

  const loadingModulesRef = useRef<Set<number>>(new Set());

  const serverInfoRef = useRef<{ ip: string; port: number } | null>(null);

  const targetOsRef = useRef<string>("unknown");

  // Demangled names cache
  const [demangledNames, setDemangledNames] = useState<Map<string, string>>(
    new Map()
  );

  const isDemanglingRef = useRef(false);

  // Demangle symbols when cache changes or demangle setting changes
  useEffect(() => {
    if (!assemblyDemangleEnabled || globalSymbolCache.symbols.length === 0) {
      return;
    }

    if (isDemanglingRef.current) {
      return;
    }

    // Get unique names that need demangling
    const uniqueNames = new Set<string>();
    for (const symbol of globalSymbolCache.symbols) {
      if (!demangledNames.has(symbol.name)) {
        uniqueNames.add(symbol.name);
      }
    }

    const namesToDemangle = Array.from(uniqueNames).slice(0, 1000); // Limit to 1000 at a time

    if (namesToDemangle.length === 0) {
      return;
    }

    isDemanglingRef.current = true;

    // Call Tauri demangle command
    invoke<string[]>("demangle_symbols", { names: namesToDemangle })
      .then((demangled) => {
        const newCache = new Map(demangledNames);
        namesToDemangle.forEach((name, index) => {
          newCache.set(name, demangled[index]);
        });
        setDemangledNames(newCache);
      })
      .catch((error) => {
        console.error("Failed to demangle symbols:", error);
      })
      .finally(() => {
        isDemanglingRef.current = false;
      });
  }, [globalSymbolCache.symbols.length, assemblyDemangleEnabled]);

  /**
   * サーバー情報を更新
   */
  const updateServerInfo = useCallback(
    (serverInfo: { ip: string; port: number; targetOs?: string } | null) => {
      serverInfoRef.current = serverInfo;
      if (serverInfo?.targetOs) {
        targetOsRef.current = serverInfo.targetOs;
      }
    },
    []
  );

  /**
   * Simplify C++ template names by removing/shortening template arguments
   * e.g., "std::mersenne_twister_engine<unsigned long, 32, ...>" -> "std::mersenne_twister_engine<...>"
   */
  const simplifyTemplateName = useCallback((name: string): string => {
    // Find the first '<' and last '>'
    const firstBracket = name.indexOf("<");
    if (firstBracket === -1) return name;

    const lastBracket = name.lastIndexOf(">");
    if (lastBracket === -1 || lastBracket <= firstBracket) return name;

    // Get the base name and check template content length
    const baseName = name.substring(0, firstBracket);
    const templateContent = name.substring(firstBracket + 1, lastBracket);
    const suffix = name.substring(lastBracket + 1);

    // If template content is short enough, keep it
    if (templateContent.length <= 30) return name;

    // Count nested brackets to find first-level arguments
    let depth = 0;
    let firstArgEnd = -1;
    for (let i = 0; i < templateContent.length; i++) {
      const char = templateContent[i];
      if (char === "<") depth++;
      else if (char === ">") depth--;
      else if (char === "," && depth === 0) {
        firstArgEnd = i;
        break;
      }
    }

    if (firstArgEnd === -1) {
      // Single argument, just shorten it
      return `${baseName}<...>${suffix}`;
    }

    // Keep first argument if it's short, otherwise abbreviate
    const firstArg = templateContent.substring(0, firstArgEnd).trim();
    if (firstArg.length <= 20) {
      return `${baseName}<${firstArg}, ...>${suffix}`;
    }
    return `${baseName}<...>${suffix}`;
  }, []);

  /**
   * Get demangled name if enabled
   */
  const getDisplayName = useCallback(
    (name: string): string => {
      if (!assemblyDemangleEnabled) return name;
      const demangled = demangledNames.get(name) || name;
      // Simplify template names for readability
      return simplifyTemplateName(demangled);
    },
    [assemblyDemangleEnabled, demangledNames, simplifyTemplateName]
  );

  /**
   * 指定されたモジュールのシンボルをキャッシュにロード（内部用）
   */
  const loadModuleSymbolsInternal = useCallback(
    async (module: ModuleInfo): Promise<CachedSymbol[]> => {
      if (globalSymbolCache.loadedModules.has(module.base)) {
        return globalSymbolCache.symbols.filter(
          (s) => s.moduleBase === module.base
        );
      }

      if (loadingModulesRef.current.has(module.base)) {
        for (let i = 0; i < 50; i++) {
          await new Promise((resolve) => setTimeout(resolve, 100));
          if (!loadingModulesRef.current.has(module.base)) {
            return globalSymbolCache.symbols.filter(
              (s) => s.moduleBase === module.base
            );
          }
        }
        return [];
      }

      loadingModulesRef.current.add(module.base);

      try {
        const client = getApiClient();
        const serverInfo = serverInfoRef.current;
        if (serverInfo) {
          client.updateConnection(serverInfo.ip, serverInfo.port);
        }
        const symbols = await client.enumerateSymbolsForModule(module);

        if (!symbols || symbols.length === 0) {
          actions.markModuleAsLoaded(module.base);
          return [];
        }

        const fullModuleName = module.modulename || module.name || "unknown";
        const moduleName =
          fullModuleName.split(/[\/\\]/).pop() || fullModuleName;

        // Filter symbols that are likely functions (for disassembly symbol resolution)
        // Include: Function, FUNC (ELF/PE), SECT with size (MachO functions in __TEXT)
        // Also include Public (Windows export symbols) and Thunk (Windows thunk functions)
        const functionSymbols = symbols.filter(
          (s) =>
            s.type === "Function" ||
            s.type === "FUNC" ||
            s.type === "Public" ||
            s.type === "Thunk" ||
            (s.type === "SECT" && s.size > 0)
        );

        const cachedSymbols: CachedSymbol[] = functionSymbols
          .map((symbol) => {
            const address = parseInt(symbol.address, 16);
            if (isNaN(address)) return null;

            // Use symbol's module_base if available (important for WASM mode),
            // otherwise fall back to the module's base address
            let symbolModuleBase = module.base;
            if (symbol.module_base) {
              const parsedModuleBase = parseInt(symbol.module_base, 16);
              if (!isNaN(parsedModuleBase)) {
                symbolModuleBase = parsedModuleBase;
              }
            }

            return {
              address,
              endAddress: address + (symbol.size || 1),
              name: symbol.name,
              moduleName,
              moduleBase: symbolModuleBase,
            };
          })
          .filter((s): s is CachedSymbol => s !== null);

        // Also load Ghidra analyzed functions from SQLite
        let ghidraSymbols: CachedSymbol[] = [];
        try {
          const targetOs = targetOsRef.current.toLowerCase();
          // Try multiple targetOs variations
          let functionsJson = await invoke<string | null>(
            "get_ghidra_functions",
            {
              targetOs: targetOs,
              moduleName: moduleName,
            }
          );
          if (!functionsJson) {
            functionsJson = await invoke<string | null>(
              "get_ghidra_functions",
              {
                targetOs: "unknown",
                moduleName: moduleName,
              }
            );
          }

          if (functionsJson) {
            const ghidraFunctions: GhidraFunctionEntry[] =
              JSON.parse(functionsJson);
            ghidraSymbols = ghidraFunctions
              .map((func) => {
                // Ghidra addresses are offsets from module base
                const offsetHex = func.address.startsWith("0x")
                  ? func.address
                  : `0x${func.address}`;
                const offset = parseInt(offsetHex, 16);
                if (isNaN(offset)) return null;

                const absoluteAddress = module.base + offset;

                return {
                  address: absoluteAddress,
                  endAddress: absoluteAddress + (func.size || 1),
                  name: func.name,
                  moduleName,
                  moduleBase: module.base,
                };
              })
              .filter((s): s is CachedSymbol => s !== null);

            if (ghidraSymbols.length > 0) {
              console.log(
                `[SymbolCache] Loaded ${ghidraSymbols.length} Ghidra functions for ${moduleName}`
              );
            }
          }
        } catch (e) {
          // Ghidra functions not available, continue with regular symbols
          console.log(`[SymbolCache] No Ghidra functions for ${moduleName}`);
        }

        // Merge symbols, preferring existing symbols over Ghidra ones for same address
        const symbolAddressSet = new Set(cachedSymbols.map((s) => s.address));
        const uniqueGhidraSymbols = ghidraSymbols.filter(
          (s) => !symbolAddressSet.has(s.address)
        );
        const allSymbols = [...cachedSymbols, ...uniqueGhidraSymbols];

        if (allSymbols.length > 0) {
          actions.addSymbolsToCache(allSymbols);
        }

        actions.markModuleAsLoaded(module.base);
        console.log(
          `[SymbolCache] Loaded ${cachedSymbols.length} symbols + ${uniqueGhidraSymbols.length} Ghidra functions for ${moduleName}`
        );
        return allSymbols;
      } catch (error) {
        console.error(
          `Failed to load symbols for module ${module.modulename}:`,
          error
        );
        actions.markModuleAsLoaded(module.base);
        return [];
      } finally {
        loadingModulesRef.current.delete(module.base);
      }
    },
    [globalSymbolCache.loadedModules, globalSymbolCache.symbols, actions]
  );

  /**
   * アドレスからシンボル情報を検索
   */
  const findSymbolForAddress = useCallback(
    (address: number): { symbol: CachedSymbol; offset: number } | null => {
      const symbol = actions.findSymbolForAddress(address);
      if (!symbol) return null;

      const offset = address - symbol.address;
      return { symbol, offset };
    },
    [actions]
  );

  /**
   * アドレスを「module@function + offset」形式に変換
   * 必要に応じてモジュールのシンボルを自動ロード
   */
  const formatAddressWithSymbol = useCallback(
    (
      address: number,
      modules: ModuleInfo[],
      format: "library" | "function"
    ): string | null => {
      const module = modules.find((m) => {
        const moduleEnd = m.base + m.size;
        return address >= m.base && address < moduleEnd;
      });

      if (!module) return null;

      const fullModuleName = module.modulename || module.name || "unknown";
      const moduleName = fullModuleName.split(/[\/\\]/).pop() || fullModuleName;
      const moduleOffset = address - module.base;

      if (format === "library") {
        return `${moduleName} + 0x${moduleOffset.toString(16)}`;
      }

      if (!globalSymbolCache.loadedModules.has(module.base)) {
        if (loadingModulesRef.current.has(module.base)) {
          return `${moduleName} + 0x${moduleOffset.toString(16)}`;
        }
        loadModuleSymbolsInternal(module);
        return `${moduleName} + 0x${moduleOffset.toString(16)}`;
      }

      const result = findSymbolForAddress(address);
      if (result) {
        const { symbol, offset } = result;
        const displayName = getDisplayName(symbol.name);

        if (offset === 0) {
          return `${moduleName}@${displayName}`;
        }
        return `${moduleName}@${displayName} + 0x${offset.toString(16)}`;
      }

      return `${moduleName} + 0x${moduleOffset.toString(16)}`;
    },
    [
      findSymbolForAddress,
      getDisplayName,
      globalSymbolCache.loadedModules,
      loadModuleSymbolsInternal,
    ]
  );

  /**
   * シンボル名からアドレスを検索
   * 必要に応じてモジュールのシンボルをロード
   */
  const findAddressForSymbol = useCallback(
    async (
      symbolName: string,
      moduleName: string,
      modules: ModuleInfo[]
    ): Promise<CachedSymbol | null> => {
      const module = modules.find((m) => {
        const fullModuleName = m.modulename || m.name || "";
        const shortName =
          fullModuleName.split(/[\/\\]/).pop() || fullModuleName;
        return (
          shortName.toLowerCase() === moduleName.toLowerCase() ||
          fullModuleName.toLowerCase().includes(moduleName.toLowerCase())
        );
      });

      if (!module) return null;

      if (!globalSymbolCache.loadedModules.has(module.base)) {
        await loadModuleSymbolsInternal(module);
      }

      const currentCache = useUIStore.getState().globalSymbolCache;
      const symbol = currentCache.symbols.find((s) => {
        if (s.moduleBase !== module.base) return false;
        return (
          s.name.toLowerCase().includes(symbolName.toLowerCase()) ||
          symbolName.toLowerCase().includes(s.name.toLowerCase())
        );
      });

      return symbol || null;
    },
    [globalSymbolCache.loadedModules, loadModuleSymbolsInternal]
  );

  /**
   * アドレスに対応するモジュールのシンボルを事前ロード
   * AssemblyView等で表示アドレスが変わったときに呼び出す
   * @param serverInfo サーバー接続情報（必須）
   * @returns ロードが開始されたかどうか
   */
  const ensureModuleSymbolsLoaded = useCallback(
    async (
      address: number,
      modules: ModuleInfo[],
      serverInfo: { ip: string; port: number } | null
    ): Promise<boolean> => {
      if (!serverInfo) {
        console.log(
          "[useSymbolCache] ensureModuleSymbolsLoaded: No server info provided"
        );
        return false;
      }

      const module = modules.find((m) => {
        const moduleEnd = m.base + m.size;
        return address >= m.base && address < moduleEnd;
      });

      if (!module) {
        console.log(
          `[useSymbolCache] ensureModuleSymbolsLoaded: No module found for address 0x${address.toString(16)}`
        );
        return false;
      }

      if (globalSymbolCache.loadedModules.has(module.base)) {
        console.log(
          `[useSymbolCache] ensureModuleSymbolsLoaded: Module ${module.modulename} already loaded`
        );
        return false;
      }

      serverInfoRef.current = serverInfo;

      console.log(
        `[useSymbolCache] ensureModuleSymbolsLoaded: Loading symbols for ${module.modulename}`
      );
      await loadModuleSymbolsInternal(module);
      return true;
    },
    [globalSymbolCache.loadedModules, loadModuleSymbolsInternal]
  );

  /**
   * キャッシュをクリア
   */
  const clearCache = useCallback(() => {
    actions.clearSymbolCache();
    setDemangledNames(new Map());
  }, [actions]);

  return {
    isLoading: globalSymbolCache.isLoading,
    loadingProgress: globalSymbolCache.loadingProgress,
    symbolCount: globalSymbolCache.symbols.length,
    loadedModuleCount: globalSymbolCache.loadedModules.size,
    loadedModules: globalSymbolCache.loadedModules,
    assemblyDemangleEnabled,

    updateServerInfo,
    findSymbolForAddress,
    findAddressForSymbol,
    formatAddressWithSymbol,
    ensureModuleSymbolsLoaded,
    getDisplayName,
    clearCache,
  };
}

```

`src/client/src/hooks/useTableColumnResize.ts`:

```ts
import { useState, useCallback, useEffect, useRef } from "react";
import { useLocalStorage } from "./useLocalStorage";

interface ColumnWidths {
  [columnId: string]: number;
}

interface UseTableColumnResizeOptions {
  storageKey: string;
  defaultWidths: ColumnWidths;
  minWidth?: number;
  maxWidth?: number;
}

/**
 * Hook for managing table column widths with localStorage persistence
 */
export const useTableColumnResize = ({
  storageKey,
  defaultWidths,
  minWidth = 30,
  maxWidth = 500,
}: UseTableColumnResizeOptions) => {
  const [columnWidths, setColumnWidths] = useLocalStorage<ColumnWidths>(
    storageKey,
    defaultWidths
  );
  const [resizingColumn, setResizingColumn] = useState<string | null>(null);
  const initialPositionRef = useRef<number>(0);
  const initialWidthRef = useRef<number>(0);

  const handleResizeStart = useCallback(
    (columnId: string, e: React.MouseEvent) => {
      e.preventDefault();
      e.stopPropagation();
      setResizingColumn(columnId);
      initialPositionRef.current = e.clientX;
      initialWidthRef.current =
        columnWidths[columnId] || defaultWidths[columnId];
    },
    [columnWidths, defaultWidths]
  );

  const handleMouseMove = useCallback(
    (e: MouseEvent) => {
      if (!resizingColumn) return;

      const delta = e.clientX - initialPositionRef.current;
      const newWidth = initialWidthRef.current + delta;

      // Apply constraints
      const constrainedWidth = Math.min(Math.max(newWidth, minWidth), maxWidth);

      setColumnWidths((prev) => ({
        ...prev,
        [resizingColumn]: constrainedWidth,
      }));
    },
    [resizingColumn, minWidth, maxWidth, setColumnWidths]
  );

  const handleMouseUp = useCallback(() => {
    setResizingColumn(null);
  }, []);

  useEffect(() => {
    if (resizingColumn) {
      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);

      // Prevent text selection during resize
      document.body.style.userSelect = "none";
      document.body.style.cursor = "ew-resize";

      return () => {
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
        document.body.style.userSelect = "";
        document.body.style.cursor = "";
      };
    }
  }, [resizingColumn, handleMouseMove, handleMouseUp]);

  const getColumnWidth = useCallback(
    (columnId: string): number => {
      return columnWidths[columnId] || defaultWidths[columnId];
    },
    [columnWidths, defaultWidths]
  );

  return {
    columnWidths,
    getColumnWidth,
    resizingColumn,
    handleResizeStart,
  };
};

```

`src/client/src/hooks/useTauriExceptionStore.ts`:

```ts
import { invoke } from "@tauri-apps/api/core";
import { listen } from "@tauri-apps/api/event";
import { useEffect, useState, useCallback, useRef } from "react";

export interface TauriExceptionData {
  exception_type: string; // "watchpoint", "breakpoint", "singlestep"
  address: string;
  instruction?: string;
  timestamp: string;
  thread_id?: number;
  watchpoint_id?: string;
  memory_address?: number;
  singlestep_mode?: number;
  registers: any;
  bytecode?: string;
  opcode?: string;
  pc?: number;
}

export interface TauriTraceEntryData {
  id: number;
  address: string;
  instruction: string;
  opcode: string;
  operands: string;
  registers: any;
  depth: number;
  is_call: boolean;
  is_return: boolean;
  function_name?: string;
  timestamp: number;
  library_expression?: string;
  target_address: string;
}

export interface TauriTraceSession {
  target_address: string;
  total_count: number;
  current_count: number;
  is_active: boolean;
  started_at: number;
  tracked_thread_id?: number;
}

/**
 * Tauriの共有例外ストアにアクセスするためのフック
 * 全ウィンドウ間で例外データを共有するために使用
 */
export const useTauriExceptionStore = () => {
  const [exceptions, setExceptions] = useState<TauriExceptionData[]>([]);
  const [isListening, setIsListening] = useState(false);

  const addExceptions = useCallback(
    async (newExceptions: TauriExceptionData[]) => {
      try {
        await invoke("add_exceptions", { exceptions: newExceptions });
      } catch (error) {
        console.error("Failed to add exceptions to Tauri store:", error);
      }
    },
    []
  );

  const getExceptions = useCallback(
    async (
      exceptionTypeFilter?: string[],
      limit?: number
    ): Promise<TauriExceptionData[]> => {
      try {
        const result = await invoke<TauriExceptionData[]>("get_exceptions", {
          exceptionTypeFilter,
          limit,
        });
        return result;
      } catch (error) {
        console.error("Failed to get exceptions from Tauri store:", error);
        return [];
      }
    },
    []
  );

  const getWatchpointExceptions = useCallback(
    async (
      watchpointId?: string,
      limit?: number
    ): Promise<TauriExceptionData[]> => {
      try {
        const result = await invoke<TauriExceptionData[]>(
          "get_watchpoint_exceptions",
          {
            watchpointId,
            limit,
          }
        );
        return result;
      } catch (error) {
        console.error(
          "Failed to get watchpoint exceptions from Tauri store:",
          error
        );
        return [];
      }
    },
    []
  );

  const clearExceptions = useCallback(async (exceptionType?: string) => {
    try {
      await invoke("clear_exceptions", { exceptionType });
    } catch (error) {
      console.error("Failed to clear exceptions from Tauri store:", error);
    }
  }, []);

  const clearWatchpointExceptions = useCallback(
    async (watchpointAddress: number, watchpointSize: number) => {
      try {
        await invoke("clear_watchpoint_exceptions", {
          watchpointAddress,
          watchpointSize,
        });
      } catch (error) {
        console.error(
          "Failed to clear watchpoint exceptions from Tauri store:",
          error
        );
      }
    },
    []
  );

  useEffect(() => {
    if (isListening) return;

    let unlistenAdded: (() => void) | undefined;
    let unlistenCleared: (() => void) | undefined;

    const setupListeners = async () => {
      try {
        unlistenAdded = await listen<TauriExceptionData[]>(
          "exceptions-added",
          (event) => {
            //console.log("Exceptions added event received:", event.payload);
            setExceptions((prev) => [...prev, ...event.payload]);
          }
        );

        unlistenCleared = await listen("exceptions-cleared", () => {
          console.log("Exceptions cleared event received");
          setExceptions([]);
        });

        setIsListening(true);
      } catch (error) {
        console.error("Failed to setup Tauri exception listeners:", error);
      }
    };

    setupListeners();

    return () => {
      if (unlistenAdded) unlistenAdded();
      if (unlistenCleared) unlistenCleared();
      setIsListening(false);
    };
  }, [isListening]);

  return {
    exceptions,
    addExceptions,
    getExceptions,
    getWatchpointExceptions,
    clearExceptions,
    clearWatchpointExceptions,
  };
};

/**
 * Tauriのトレースストアにアクセスするためのフック
 * Code Tracingウィンドウで使用
 */
export const useTauriTraceStore = () => {
  const [traceEntries, setTraceEntries] = useState<TauriTraceEntryData[]>([]);
  const [traceSession, setTraceSession] = useState<TauriTraceSession | null>(
    null
  );
  const [isListening, setIsListening] = useState(false);

  const startTraceSession = useCallback(
    async (targetAddress: string, totalCount: number) => {
      try {
        await invoke("start_trace_session", { targetAddress, totalCount });
        setTraceEntries([]);
      } catch (error) {
        console.error("Failed to start trace session:", error);
        throw error;
      }
    },
    []
  );

  const addTraceEntry = useCallback(async (entry: TauriTraceEntryData) => {
    try {
      await invoke("add_trace_entry", { entry });
    } catch (error) {
      console.error("Failed to add trace entry:", error);
      throw error;
    }
  }, []);

  const getTraceEntries = useCallback(
    async (
      targetAddress?: string,
      limit?: number
    ): Promise<TauriTraceEntryData[]> => {
      try {
        const result = await invoke<TauriTraceEntryData[]>(
          "get_trace_entries",
          {
            targetAddress,
            limit,
          }
        );
        return result;
      } catch (error) {
        console.error("Failed to get trace entries:", error);
        return [];
      }
    },
    []
  );

  const getTraceSession =
    useCallback(async (): Promise<TauriTraceSession | null> => {
      try {
        const result = await invoke<TauriTraceSession | null>(
          "get_trace_session"
        );
        return result;
      } catch (error) {
        console.error("Failed to get trace session:", error);
        return null;
      }
    }, []);

  const stopTraceSession = useCallback(async () => {
    try {
      await invoke("stop_trace_session");
    } catch (error) {
      console.error("Failed to stop trace session:", error);
    }
  }, []);

  const setTrackedThread = useCallback(async (threadId: number) => {
    try {
      await invoke("set_trace_tracked_thread", { threadId });
      setTraceSession((prev) =>
        prev ? { ...prev, tracked_thread_id: threadId } : null
      );
    } catch (error) {
      console.error("Failed to set tracked thread:", error);
    }
  }, []);

  const clearTraceEntries = useCallback(async () => {
    try {
      await invoke("clear_trace_entries");
      setTraceEntries([]);
      setTraceSession(null);
    } catch (error) {
      console.error("Failed to clear trace entries:", error);
    }
  }, []);

  useEffect(() => {
    if (isListening) return;

    let unlistenEntryAdded: (() => void) | undefined;
    let unlistenProgress: (() => void) | undefined;
    let unlistenSessionStarted: (() => void) | undefined;
    let unlistenSessionComplete: (() => void) | undefined;
    let unlistenSessionStopped: (() => void) | undefined;
    let unlistenEntriesCleared: (() => void) | undefined;
    let unlistenThreadTracked: (() => void) | undefined;

    const setupListeners = async () => {
      try {
        unlistenEntryAdded = await listen<TauriTraceEntryData>(
          "trace-entry-added",
          (event) => {
            console.log("Trace entry added:", event.payload);
            setTraceEntries((prev) => [...prev, event.payload]);
          }
        );

        unlistenProgress = await listen<{ current: number; total: number }>(
          "trace-progress",
          (event) => {
            setTraceSession((prev) =>
              prev
                ? {
                    ...prev,
                    current_count: event.payload.current,
                  }
                : null
            );
          }
        );

        unlistenSessionStarted = await listen<{
          targetAddress: string;
          totalCount: number;
        }>("trace-session-started", (event) => {
          console.log("Trace session started:", event.payload);
          setTraceSession({
            target_address: event.payload.targetAddress,
            total_count: event.payload.totalCount,
            current_count: 0,
            is_active: true,
            started_at: Date.now(),
            tracked_thread_id: undefined,
          });
          setTraceEntries([]);
        });

        unlistenSessionComplete = await listen<{ totalEntries: number }>(
          "trace-session-complete",
          (event) => {
            console.log("Trace session complete:", event.payload);
            setTraceSession((prev) =>
              prev ? { ...prev, is_active: false } : null
            );
          }
        );

        unlistenSessionStopped = await listen("trace-session-stopped", () => {
          console.log("Trace session stopped");
          setTraceSession((prev) =>
            prev ? { ...prev, is_active: false } : null
          );
        });

        unlistenThreadTracked = await listen<{ threadId: number }>(
          "trace-thread-tracked",
          (event) => {
            console.log("Trace thread tracked:", event.payload);
            setTraceSession((prev) =>
              prev
                ? { ...prev, tracked_thread_id: event.payload.threadId }
                : null
            );
          }
        );

        unlistenEntriesCleared = await listen("trace-entries-cleared", () => {
          console.log("Trace entries cleared");
          setTraceEntries([]);
          setTraceSession(null);
        });

        setIsListening(true);
      } catch (error) {
        console.error("Failed to setup trace listeners:", error);
      }
    };

    setupListeners();

    return () => {
      if (unlistenEntryAdded) unlistenEntryAdded();
      if (unlistenProgress) unlistenProgress();
      if (unlistenSessionStarted) unlistenSessionStarted();
      if (unlistenSessionComplete) unlistenSessionComplete();
      if (unlistenSessionStopped) unlistenSessionStopped();
      if (unlistenThreadTracked) unlistenThreadTracked();
      if (unlistenEntriesCleared) unlistenEntriesCleared();
      setIsListening(false);
    };
  }, [isListening]);

  const hasLoadedInitialState = useRef(false);
  useEffect(() => {
    if (!isListening) return;
    // Only load once
    if (hasLoadedInitialState.current) return;
    hasLoadedInitialState.current = true;

    const loadInitialState = async () => {
      console.log("Loading initial trace state...");
      const session = await getTraceSession();
      console.log("Loaded trace session:", session);
      if (session) {
        setTraceSession(session);
        const entries = await getTraceEntries(undefined);
        console.log("Loaded trace entries:", entries.length);
        setTraceEntries(entries);
      }
    };
    loadInitialState();
  }, [isListening]); // Remove getTraceSession and getTraceEntries from deps - they are stable

  return {
    traceEntries,
    traceSession,
    startTraceSession,
    addTraceEntry,
    getTraceEntries,
    getTraceSession,
    stopTraceSession,
    setTrackedThread,
    clearTraceEntries,
  };
};

```

`src/client/src/hooks/useTauriSystemState.ts`:

```ts
import { useState, useEffect, useCallback } from "react";
import { invoke } from "@tauri-apps/api/core";
import { listen } from "@tauri-apps/api/event";

export interface SystemConnectionState {
  serverConnected: boolean;
  debuggerConnected: boolean;
  connectionHost?: string;
  connectionPort?: number;
  authToken?: string;
  serverSessionId?: string;
}

export interface SystemProcessState {
  attachedProcess?: {
    pid: number;
    processname: string;
  };
  serverInfo?: {
    git_hash: string;
    arch: string;
    pid: number;
    mode: string;
    target_os: string;
    build_timestamp?: number;
  };
  attachedAppInfo?: {
    name: string;
    pid: number;
    icon?: string;
    arch?: string;
    bundleIdentifier?: string;
  };
  spawnSuspended?: boolean;
  attachedModules: Array<{
    modulename: string;
    base: number;
    size: number;
    path?: string;
    is_64bit?: boolean;
  }>;
}

export interface SystemDebugState {
  isInBreakState: boolean;
  currentThreadId?: number;
  currentBreakAddress?: string;
  currentRegisterData: Record<string, string>;
  activeBreakpoints: string[];
  softwareBreakpoints: string[]; // Track which addresses are software breakpoints
  watchpoints: Array<{
    id: string;
    address: string;
    size: number;
    accessType: string;
    hitCount: number;
    createdAt: string;
    description?: string;
  }>;
}

export interface TauriSystemState
  extends SystemConnectionState,
    SystemProcessState,
    SystemDebugState {
  lastUpdate: number;
}

interface StateUpdateEvent {
  field: string;
  value: any;
  timestamp: number;
}

/**
 * Tauriのシステム状態管理フック
 * 接続状態、プロセス状態、デバッグ状態など、複数ウィンドウ間で共有すべき状態のみ管理
 */
export const useTauriSystemState = () => {
  const [state, setState] = useState<TauriSystemState | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const loadState = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      const tauriState = await invoke<TauriSystemState>("get_app_state");
      setState(tauriState);
    } catch (err) {
      console.error("Failed to load Tauri system state:", err);
      setError(err instanceof Error ? err.message : "Unknown error");
    } finally {
      setIsLoading(false);
    }
  }, []);

  const updateField = useCallback(async (field: string, value: any) => {
    try {
      await invoke("update_single_state", { field, value });
    } catch (err) {
      console.error(`Failed to update field ${field}:`, err);
      setError(err instanceof Error ? err.message : "Unknown error");
    }
  }, []);

  const updateState = useCallback(async (updates: Record<string, any>) => {
    try {
      await invoke("update_app_state", { updates });
    } catch (err) {
      console.error("Failed to update Tauri state:", err);
      setError(err instanceof Error ? err.message : "Unknown error");
    }
  }, []);

  const updateConnectionState = useCallback(
    async (
      serverConnected: boolean,
      debuggerConnected: boolean,
      host?: string,
      port?: number
    ) => {
      const updates: Record<string, any> = {
        serverConnected,
        debuggerConnected,
      };
      if (host !== undefined) updates.connectionHost = host;
      if (port !== undefined) updates.connectionPort = port;

      await updateState(updates);
    },
    [updateState]
  );

  const updateProcessState = useCallback(
    async (
      attachedProcess?: SystemProcessState["attachedProcess"],
      attachedAppInfo?: SystemProcessState["attachedAppInfo"],
      serverInfo?: SystemProcessState["serverInfo"]
    ) => {
      const updates: Record<string, any> = {};
      if (attachedProcess !== undefined)
        updates.attachedProcess = attachedProcess;
      if (attachedAppInfo !== undefined)
        updates.attachedAppInfo = attachedAppInfo;
      if (serverInfo !== undefined) updates.serverInfo = serverInfo;

      await updateState(updates);
    },
    [updateState]
  );

  const updateDebugState = useCallback(
    async (
      isInBreakState?: boolean,
      currentThreadId?: number,
      currentBreakAddress?: string,
      registerData?: Record<string, string>
    ) => {
      const updates: Record<string, any> = {};
      if (isInBreakState !== undefined) updates.isInBreakState = isInBreakState;
      if (currentThreadId !== undefined)
        updates.currentThreadId = currentThreadId;
      if (currentBreakAddress !== undefined)
        updates.currentBreakAddress = currentBreakAddress;
      if (registerData !== undefined)
        updates.currentRegisterData = registerData;

      await updateState(updates);
    },
    [updateState]
  );

  const addBreakpoint = useCallback(
    async (address: string, isSoftware: boolean = false) => {
      if (state) {
        // Track software breakpoints FIRST to avoid red flash on UI
        if (isSoftware) {
          const newSoftwareBreakpoints = [...(state.softwareBreakpoints || [])];
          if (!newSoftwareBreakpoints.includes(address)) {
            newSoftwareBreakpoints.push(address);
            await updateField("softwareBreakpoints", newSoftwareBreakpoints);
          }
        }
        // Then add to active breakpoints
        const newBreakpoints = [...(state.activeBreakpoints || [])];
        if (!newBreakpoints.includes(address)) {
          newBreakpoints.push(address);
          await updateField("activeBreakpoints", newBreakpoints);
        }
      }
    },
    [state, updateField]
  );

  const removeBreakpoint = useCallback(
    async (address: string) => {
      if (state) {
        const newBreakpoints = (state.activeBreakpoints || []).filter(
          (bp) => bp !== address
        );
        await updateField("activeBreakpoints", newBreakpoints);
        // Also remove from software breakpoints if present
        const newSoftwareBreakpoints = (state.softwareBreakpoints || []).filter(
          (bp) => bp !== address
        );
        await updateField("softwareBreakpoints", newSoftwareBreakpoints);
      }
    },
    [state, updateField]
  );

  const MAX_WATCHPOINTS_ANDROID = 1;

  const addWatchpoint = useCallback(
    async (
      watchpoint: SystemDebugState["watchpoints"][0]
    ): Promise<{ success: boolean; error?: string }> => {
      if (state) {
        const currentWatchpoints = state.watchpoints || [];
        const targetOs = state.serverInfo?.target_os;

        if (
          (targetOs === "android" || targetOs === "linux") &&
          currentWatchpoints.length >= MAX_WATCHPOINTS_ANDROID
        ) {
          return {
            success: false,
            error: `Watchpoint limit reached: Maximum ${MAX_WATCHPOINTS_ANDROID} watchpoint(s) allowed for ${targetOs}. Please remove an existing watchpoint first.`,
          };
        }

        const newWatchpoints = [...currentWatchpoints];
        const existingIndex = newWatchpoints.findIndex(
          (w) => w.id === watchpoint.id
        );
        if (existingIndex === -1) {
          newWatchpoints.push(watchpoint);
          await updateField("watchpoints", newWatchpoints);
        }
        return { success: true };
      }
      return { success: false, error: "State not available" };
    },
    [state, updateField]
  );

  const removeWatchpoint = useCallback(
    async (watchpointId: string) => {
      if (state) {
        const newWatchpoints = (state.watchpoints || []).filter(
          (w) => w.id !== watchpointId
        );
        await updateField("watchpoints", newWatchpoints);
      }
    },
    [state, updateField]
  );

  const updateModules = useCallback(
    async (modules: SystemProcessState["attachedModules"]) => {
      await updateField("attachedModules", modules);
    },
    [updateField]
  );

  useEffect(() => {
    let unlisten: (() => void) | undefined;

    const setupListener = async () => {
      try {
        unlisten = await listen<StateUpdateEvent>("state-updated", (event) => {
          const { field, value, timestamp } = event.payload;
          console.log("[TauriSystemState] State updated:", {
            field,
            value,
            timestamp,
            source: "useTauriSystemState hook",
            hookId: Math.random().toString(36).substr(2, 9),
          });

          setState((currentState) => {
            if (!currentState) return currentState;

            return {
              ...currentState,
              [field]: value,
              lastUpdate: timestamp,
            };
          });
        });
      } catch (error) {
        console.error("Failed to setup state update listener:", error);
      }
    };

    setupListener();

    return () => {
      if (unlisten) {
        unlisten();
      }
    };
  }, []);

  useEffect(() => {
    loadState();
  }, []);

  return {
    state,
    isLoading,
    error,

    loadState,
    updateField,
    updateState,

    updateConnectionState,
    updateProcessState,
    updateDebugState,
    addBreakpoint,
    removeBreakpoint,
    addWatchpoint,
    removeWatchpoint,
    updateModules,

    isConnected: state?.serverConnected && state?.debuggerConnected,
    hasAttachedProcess: !!state?.attachedProcess,
    isInBreakState: state?.isInBreakState ?? false,
  };
};

/**
 * 接続状態のみを監視する軽量フック
 */
export const useConnectionState = () => {
  const [connectionState, setConnectionState] =
    useState<SystemConnectionState | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const loadConnectionState = async () => {
      try {
        const state = await invoke<SystemConnectionState>(
          "get_connection_state"
        );
        setConnectionState(state);
      } catch (err) {
        console.error("Failed to load connection state:", err);
      } finally {
        setIsLoading(false);
      }
    };

    loadConnectionState();

    let unlisten: (() => void) | undefined;

    const setupListener = async () => {
      try {
        unlisten = await listen<StateUpdateEvent>("state-updated", (event) => {
          const { field, value } = event.payload;
          if (
            [
              "serverConnected",
              "debuggerConnected",
              "connectionHost",
              "connectionPort",
            ].includes(field)
          ) {
            setConnectionState((current) =>
              current ? { ...current, [field]: value } : current
            );
          }
        });
      } catch (error) {
        console.error("Failed to setup connection state listener:", error);
      }
    };

    setupListener();

    return () => {
      if (unlisten) {
        unlisten();
      }
    };
  }, []);

  return {
    connectionState,
    isLoading,
    isConnected:
      connectionState?.serverConnected && connectionState?.debuggerConnected,
  };
};

/**
 * デバッグ状態のみを監視する軽量フック
 */
export const useDebugState = () => {
  const [debugState, setDebugState] = useState<SystemDebugState | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const loadDebugState = async () => {
      try {
        const state = await invoke<SystemDebugState>("get_debug_state");
        setDebugState(state);
      } catch (err) {
        console.error("Failed to load debug state:", err);
      } finally {
        setIsLoading(false);
      }
    };

    loadDebugState();

    let unlisten: (() => void) | undefined;

    const setupListener = async () => {
      try {
        unlisten = await listen<StateUpdateEvent>("state-updated", (event) => {
          const { field, value } = event.payload;
          if (
            [
              "isInBreakState",
              "currentThreadId",
              "currentBreakAddress",
              "currentRegisterData",
              "activeBreakpoints",
              "watchpoints",
            ].includes(field)
          ) {
            setDebugState((current) =>
              current ? { ...current, [field]: value } : current
            );
          }
        });
      } catch (error) {
        console.error("Failed to setup debug state listener:", error);
      }
    };

    setupListener();

    return () => {
      if (unlisten) {
        unlisten();
      }
    };
  }, []);

  return {
    debugState,
    isLoading,
    isInBreakState: debugState?.isInBreakState ?? false,
    hasActiveBreakpoints: (debugState?.activeBreakpoints?.length ?? 0) > 0,
    hasActiveWatchpoints: (debugState?.watchpoints?.length ?? 0) > 0,
  };
};

```

`src/client/src/hooks/useTauriSystemStateSingleton.ts`:

```ts
import { useState, useEffect, useCallback, useRef } from "react";
import { invoke } from "@tauri-apps/api/core";
import { listen } from "@tauri-apps/api/event";
import type {
  TauriSystemState,
  SystemProcessState,
  SystemDebugState,
} from "./useTauriSystemState";

class TauriSystemStateSingleton {
  private static instance: TauriSystemStateSingleton;
  private state: TauriSystemState | null = null;
  private listeners = new Set<(state: TauriSystemState | null) => void>();
  private isLoading = true;
  private error: string | null = null;
  private isInitialized = false;
  private unlisten: (() => void) | null = null;

  private constructor() {}

  static getInstance(): TauriSystemStateSingleton {
    if (!TauriSystemStateSingleton.instance) {
      TauriSystemStateSingleton.instance = new TauriSystemStateSingleton();
    }
    return TauriSystemStateSingleton.instance;
  }

  addListener(listener: (state: TauriSystemState | null) => void) {
    this.listeners.add(listener);

    if (this.state) {
      listener(this.state);
    }

    if (!this.isInitialized) {
      this.initialize();
    }

    return () => {
      this.listeners.delete(listener);

      if (this.listeners.size === 0) {
        this.cleanup();
      }
    };
  }

  private async initialize() {
    if (this.isInitialized) return;

    this.isInitialized = true;
    console.log("[TauriSystemStateSingleton] Initializing...");

    try {
      await this.loadState();

      await this.setupEventListener();
    } catch (error) {
      console.error("[TauriSystemStateSingleton] Failed to initialize:", error);
      this.error = error instanceof Error ? error.message : "Unknown error";
      this.isLoading = false;
      this.notifyListeners();
    }
  }

  private async loadState() {
    try {
      this.isLoading = true;
      this.error = null;
      const tauriState = await invoke<TauriSystemState>("get_app_state");
      this.state = tauriState;
      this.isLoading = false;
      this.notifyListeners();
      console.log("[TauriSystemStateSingleton] State loaded successfully");
    } catch (err) {
      console.error("[TauriSystemStateSingleton] Failed to load state:", err);
      this.error = err instanceof Error ? err.message : "Unknown error";
      this.isLoading = false;
      this.notifyListeners();
    }
  }

  private async setupEventListener() {
    try {
      if (this.unlisten) {
        console.warn(
          "[TauriSystemStateSingleton] Event listener already set up"
        );
        return;
      }

      this.unlisten = await listen<{
        field: string;
        value: any;
        timestamp: number;
      }>("state-updated", (event) => {
        const { field, value, timestamp } = event.payload;

        // Skip if value is the same as current (debounce duplicate updates)
        if (this.state) {
          const currentValue = (this.state as any)[field];
          // Deep equality check for objects, strict equality for primitives
          const isSameValue =
            typeof value === "object" && value !== null
              ? JSON.stringify(currentValue) === JSON.stringify(value)
              : currentValue === value;

          if (isSameValue) {
            // Skip duplicate update
            return;
          }
        }

        console.log("[TauriSystemStateSingleton] State updated:", {
          field,
          value,
          timestamp,
          listenerCount: this.listeners.size,
        });

        if (this.state) {
          this.state = {
            ...this.state,
            [field]: value,
            lastUpdate: timestamp,
          };
          this.notifyListeners();
        }
      });

      console.log(
        "[TauriSystemStateSingleton] Event listener set up successfully"
      );
    } catch (error) {
      console.error(
        "[TauriSystemStateSingleton] Failed to setup event listener:",
        error
      );
    }
  }

  private notifyListeners() {
    this.listeners.forEach((listener) => {
      try {
        listener(this.state);
      } catch (error) {
        console.error(
          "[TauriSystemStateSingleton] Error notifying listener:",
          error
        );
      }
    });
  }

  private cleanup() {
    console.log("[TauriSystemStateSingleton] Cleaning up...");
    if (this.unlisten) {
      this.unlisten();
      this.unlisten = null;
    }
    this.isInitialized = false;
  }

  async updateField(field: string, value: any) {
    try {
      await invoke("update_single_state", { field, value });
    } catch (err) {
      console.error(
        `[TauriSystemStateSingleton] Failed to update field ${field}:`,
        err
      );
      throw err;
    }
  }

  async updateState(updates: Record<string, any>) {
    try {
      await invoke("update_app_state", { updates });
    } catch (err) {
      console.error("[TauriSystemStateSingleton] Failed to update state:", err);
      throw err;
    }
  }

  getCurrentState() {
    return {
      state: this.state,
      isLoading: this.isLoading,
      error: this.error,
    };
  }
}

export const useTauriSystemStateSingleton = () => {
  const [state, setState] = useState<TauriSystemState | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const singleton = useRef(TauriSystemStateSingleton.getInstance());

  useEffect(() => {
    const updateLocalState = (newState: TauriSystemState | null) => {
      setState(newState);
      const currentState = singleton.current.getCurrentState();
      setIsLoading(currentState.isLoading);
      setError(currentState.error);
    };

    const cleanup = singleton.current.addListener(updateLocalState);

    return cleanup;
  }, []);

  const updateField = useCallback(async (field: string, value: any) => {
    return singleton.current.updateField(field, value);
  }, []);

  const updateState = useCallback(async (updates: Record<string, any>) => {
    return singleton.current.updateState(updates);
  }, []);

  const loadState = useCallback(async () => {
    console.log(
      "[useTauriSystemStateSingleton] Manual loadState called (handled by singleton)"
    );
  }, []);

  const updateConnectionState = useCallback(
    async (
      serverConnected: boolean,
      debuggerConnected: boolean,
      host?: string,
      port?: number
    ) => {
      const updates: Record<string, any> = {
        serverConnected,
        debuggerConnected,
      };
      if (host !== undefined) updates.connectionHost = host;
      if (port !== undefined) updates.connectionPort = port;

      await updateState(updates);
    },
    [updateState]
  );

  const updateProcessState = useCallback(
    async (
      attachedProcess?: SystemProcessState["attachedProcess"],
      attachedAppInfo?: SystemProcessState["attachedAppInfo"],
      serverInfo?: SystemProcessState["serverInfo"]
    ) => {
      const updates: Record<string, any> = {};
      if (attachedProcess !== undefined)
        updates.attachedProcess = attachedProcess;
      if (attachedAppInfo !== undefined)
        updates.attachedAppInfo = attachedAppInfo;
      if (serverInfo !== undefined) updates.serverInfo = serverInfo;

      await updateState(updates);
    },
    [updateState]
  );

  const updateDebugState = useCallback(
    async (
      isInBreakState?: boolean,
      currentThreadId?: number,
      currentBreakAddress?: string,
      registerData?: Record<string, string>
    ) => {
      const updates: Record<string, any> = {};
      if (isInBreakState !== undefined) updates.isInBreakState = isInBreakState;
      if (currentThreadId !== undefined)
        updates.currentThreadId = currentThreadId;
      if (currentBreakAddress !== undefined)
        updates.currentBreakAddress = currentBreakAddress;
      if (registerData !== undefined)
        updates.currentRegisterData = registerData;

      await updateState(updates);
    },
    [updateState]
  );

  const addBreakpoint = useCallback(
    async (address: string, isSoftware: boolean = false) => {
      const currentState = singleton.current.getCurrentState().state;
      if (currentState) {
        // Track software breakpoints FIRST to avoid red flash on UI
        if (isSoftware) {
          const newSoftwareBreakpoints = [
            ...(currentState.softwareBreakpoints || []),
          ];
          if (!newSoftwareBreakpoints.includes(address)) {
            newSoftwareBreakpoints.push(address);
            await updateField("softwareBreakpoints", newSoftwareBreakpoints);
          }
        }
        // Then add to active breakpoints
        const newBreakpoints = [...(currentState.activeBreakpoints || [])];
        if (!newBreakpoints.includes(address)) {
          newBreakpoints.push(address);
          await updateField("activeBreakpoints", newBreakpoints);
        }
      }
    },
    [updateField]
  );

  const removeBreakpoint = useCallback(
    async (address: string) => {
      const currentState = singleton.current.getCurrentState().state;
      if (currentState) {
        const newBreakpoints = (currentState.activeBreakpoints || []).filter(
          (bp) => bp !== address
        );
        await updateField("activeBreakpoints", newBreakpoints);
        // Also remove from software breakpoints if present
        const newSoftwareBreakpoints = (
          currentState.softwareBreakpoints || []
        ).filter((bp) => bp !== address);
        await updateField("softwareBreakpoints", newSoftwareBreakpoints);
      }
    },
    [updateField]
  );

  const MAX_WATCHPOINTS_ANDROID = 1;

  const addWatchpoint = useCallback(
    async (
      watchpoint: SystemDebugState["watchpoints"][0]
    ): Promise<{ success: boolean; error?: string }> => {
      const currentState = singleton.current.getCurrentState().state;
      if (currentState) {
        const currentWatchpoints = currentState.watchpoints || [];
        const targetOs = currentState.serverInfo?.target_os;

        if (
          (targetOs === "android" || targetOs === "linux") &&
          currentWatchpoints.length >= MAX_WATCHPOINTS_ANDROID
        ) {
          return {
            success: false,
            error: `Watchpoint limit reached: Maximum ${MAX_WATCHPOINTS_ANDROID} watchpoint(s) allowed for ${targetOs}. Please remove an existing watchpoint first.`,
          };
        }

        const newWatchpoints = [...currentWatchpoints];
        const existingIndex = newWatchpoints.findIndex(
          (w) => w.id === watchpoint.id
        );
        if (existingIndex === -1) {
          newWatchpoints.push(watchpoint);
          await updateField("watchpoints", newWatchpoints);
        }
        return { success: true };
      }
      return { success: false, error: "State not available" };
    },
    [updateField]
  );

  const removeWatchpoint = useCallback(
    async (watchpointId: string) => {
      const currentState = singleton.current.getCurrentState().state;
      if (currentState) {
        const newWatchpoints = (currentState.watchpoints || []).filter(
          (w) => w.id !== watchpointId
        );
        await updateField("watchpoints", newWatchpoints);
      }
    },
    [updateField]
  );

  const updateModules = useCallback(
    async (modules: SystemProcessState["attachedModules"]) => {
      await updateField("attachedModules", modules);
    },
    [updateField]
  );

  return {
    state,
    isLoading,
    error,

    loadState,
    updateField,
    updateState,

    updateConnectionState,
    updateProcessState,
    updateDebugState,
    addBreakpoint,
    removeBreakpoint,
    addWatchpoint,
    removeWatchpoint,
    updateModules,

    isConnected: state?.serverConnected && state?.debuggerConnected,
    hasAttachedProcess: !!state?.attachedProcess,
    isInBreakState: state?.isInBreakState ?? false,
  };
};

```

`src/client/src/hooks/useWatchpointExceptionHandler.ts`:

```ts
import { useCallback } from "react";
import { useExceptionHandler, ProcessedException } from "./useExceptionHandler";

// Legacy interface for backward compatibility
export interface WatchpointException {
  address: string;
  instruction: string;
  timestamp: Date;
  watchpointId: string;
  context?: any; // Additional context information
  // Register values as individual fields (flattened from server processing)
  x0?: string | number;
  x1?: string | number;
  x2?: string | number;
  x3?: string | number;
  x4?: string | number;
  x5?: string | number;
  x6?: string | number;
  x7?: string | number;
  x8?: string | number;
  x9?: string | number;
  x10?: string | number;
  x11?: string | number;
  x12?: string | number;
  x13?: string | number;
  x14?: string | number;
  x15?: string | number;
  x16?: string | number;
  x17?: string | number;
  x18?: string | number;
  x19?: string | number;
  x20?: string | number;
  x21?: string | number;
  x22?: string | number;
  x23?: string | number;
  x24?: string | number;
  x25?: string | number;
  x26?: string | number;
  x27?: string | number;
  x28?: string | number;
  x29?: string | number;
  lr?: string | number;
  fp?: string | number;
  sp?: string | number;
  pc?: string | number;
  cpsr?: string | number;
}

export interface UseWatchpointExceptionHandlerOptions {
  pollingInterval?: number; // Default: 500ms
  onWatchpointHit?: (exception: WatchpointException) => void;
  onError?: (error: string) => void;
  autoStart?: boolean; // Auto-start monitoring when watchpoints are set
  // Connection and state checks (pass-through to useExceptionHandler)
  isConnected?: boolean; // Check if connected to server
  isProcessAttached?: boolean; // Check if process is attached
  hasActiveWatchpoints?: boolean; // Check if any watchpoints are set
}

// Convert ProcessedException to legacy WatchpointException format
const convertToLegacyFormat = (
  exception: ProcessedException
): WatchpointException => ({
  address: exception.address,
  instruction: exception.instruction,
  timestamp: exception.timestamp,
  watchpointId: exception.watchpointId!,
  context: exception.context,
  x0: exception.x0,
  x1: exception.x1,
  x2: exception.x2,
  x3: exception.x3,
  x4: exception.x4,
  x5: exception.x5,
  x6: exception.x6,
  x7: exception.x7,
  x8: exception.x8,
  x9: exception.x9,
  x10: exception.x10,
  x11: exception.x11,
  x12: exception.x12,
  x13: exception.x13,
  x14: exception.x14,
  x15: exception.x15,
  x16: exception.x16,
  x17: exception.x17,
  x18: exception.x18,
  x19: exception.x19,
  x20: exception.x20,
  x21: exception.x21,
  x22: exception.x22,
  x23: exception.x23,
  x24: exception.x24,
  x25: exception.x25,
  x26: exception.x26,
  x27: exception.x27,
  x28: exception.x28,
  x29: exception.x29,
  lr: exception.lr,
  fp: exception.fp,
  sp: exception.sp,
  pc: exception.pc,
  cpsr: exception.cpsr,
});

export const useWatchpointExceptionHandler = (
  options: UseWatchpointExceptionHandlerOptions = {}
) => {
  const {
    pollingInterval = 50,
    onWatchpointHit,
    onError,
    autoStart = true,
    isConnected = false,
    isProcessAttached = false,
    hasActiveWatchpoints = false,
  } = options;

  // Convert callback to use legacy format
  const handleWatchpointHit = useCallback(
    (exception: ProcessedException) => {
      if (onWatchpointHit) {
        onWatchpointHit(convertToLegacyFormat(exception));
      }
    },
    [onWatchpointHit]
  );

  // Use the common exception handler with watchpoint-only configuration
  const {
    isMonitoring,
    watchpointExceptions,
    lastCheckTime,
    error,
    startMonitoring,
    stopMonitoring,
    clearWatchpointExceptions,
    checkNow,
  } = useExceptionHandler({
    pollingInterval,
    onWatchpointHit: handleWatchpointHit,
    onError,
    autoStart,
    enableWatchpoints: true,
    enableBreakpoints: false, // Only monitor watchpoints
    isConnected,
    isProcessAttached,
    hasActiveWatchpoints,
  });

  // Convert exceptions to legacy format
  const exceptions: WatchpointException[] = watchpointExceptions.map(
    convertToLegacyFormat
  );

  // Alias clearWatchpointExceptions as clearExceptions for backward compatibility
  const clearExceptions = clearWatchpointExceptions;

  return {
    // State
    isMonitoring,
    exceptions,
    lastCheckTime,
    error,

    // Actions
    startMonitoring,
    stopMonitoring,
    clearExceptions,
    checkNow,
  };
};

```

`src/client/src/lib/api.ts`:

```ts
// API client for communicating with the backend server
import { invoke } from "@tauri-apps/api/core";
import {
  FilterRequest,
  FilterResponse,
  FilterProgressResponse,
  ExceptionInfo,
} from "../types/index";

// Native memory filter types (for Tauri commands)
export interface NativeMemoryFilterRequest {
  addresses: number[]; // List of addresses to filter
  old_values: number[][]; // Previous values at those addresses (as byte arrays)
  pattern: string; // Hex-encoded pattern for comparison (min for range)
  pattern_max?: string; // Hex-encoded max pattern for range filter
  data_type: string; // "int8", "uint8", "int16", etc.
  filter_method: string; // "exact", "range", "greater_or_equal", "less_than", "changed", "unchanged", "increased", "decreased"
}

export interface NativeMemoryFilterResult {
  address: number;
  value: number[]; // New value at the address as byte array
}

export interface NativeMemoryFilterResponse {
  success: boolean;
  results: NativeMemoryFilterResult[];
  total_processed: number;
  error?: string;
}

// Native unknown scan types (for Tauri commands)
// Unknown Scan Streaming API types (server-side)
export interface UnknownScanStartRequest {
  scan_id: string;
  address_ranges: [number, number][]; // [(start, end), ...]
  data_type: string; // "int8", "uint8", "int16", etc.
  alignment: number;
  do_suspend: boolean;
}

export interface UnknownScanStartResponse {
  success: boolean;
  scan_id: string;
  total_bytes: number;
  message?: string;
  error?: string;
}

export interface UnknownScanChunk {
  start_address: number;
  uncompressed_size: number;
  compressed_data: number[]; // LZ4 compressed bytes
}

export interface UnknownScanStreamResponse {
  success: boolean;
  scan_id: string;
  progress_percentage: number;
  processed_bytes: number;
  total_bytes: number;
  is_scanning: boolean;
  chunks: UnknownScanChunk[];
  message?: string;
}

// Legacy Tauri-based unknown scan types (for backward compatibility)
export interface NativeUnknownScanRequest {
  address_ranges: [number, number][]; // [(start, end), ...]
  data_type: string; // "int8", "uint8", "int16", etc.
  alignment: number; // Alignment for scanning
  scan_id: string; // Unique scan ID for temp file storage
}

export interface NativeUnknownScanResponse {
  success: boolean;
  scan_id: string;
  total_addresses: number;
  temp_dir: string;
  error?: string;
}

export interface NativeUnknownScanProgress {
  scan_id: string;
  progress_percentage: number;
  processed_bytes: number;
  total_bytes: number;
  found_count: number;
  is_scanning: boolean;
  current_region?: string;
}

export interface NativeUnknownScanLookupResponse {
  success: boolean;
  results: NativeMemoryFilterResult[];
  total_count: number;
  error?: string;
}

// Network logging types
export interface NetworkRequestCapture {
  method: string;
  url: string;
  endpoint: string;
  requestHeaders?: Record<string, string>;
  requestBody?: any;
  requestSize?: number;
}

export interface NetworkResponseCapture {
  status: number;
  responseHeaders?: Record<string, string>;
  responseBody?: any;
  responseSize?: number;
  duration: number;
  error?: string;
}

export interface ServerInfo {
  git_hash: string;
  arch: string;
  pid: number;
  mode: string;
  target_os: string;
  build_timestamp?: number;
}

export interface DisassembleRequest {
  address: number;
  size: number;
  architecture: string;
}

export interface DisassembleResponse {
  success: boolean;
  disassembly?: string;
  instructions_count: number;
  error?: string;
}

export interface MemoryReadRequest {
  address: number;
  size: number;
}

export interface MemoryReadResponse {
  success: boolean;
  data?: number[] | Uint8Array;
  error?: string;
}

export interface NewsItem {
  id: string;
  date: string;
  title: string;
  body: string;
  type: "update" | "info" | "warning" | "announcement";
  link: string;
}

export interface NewsResponse {
  latest_version: string;
  force_update: boolean;
  news: NewsItem[];
}

export interface WatchpointInfo {
  id: string;
  address: number;
  size: number;
  access_type: string; // "r", "w", "rw", "x", "rx", "wx", "rwx"
  hit_count: number;
  created_at: string; // ISO 8601 timestamp
  description?: string;
}

export interface ConnectionState {
  connected: boolean;
  host: string;
  port: number;
  serverInfo?: ServerInfo;
  lastError?: string;
}

export interface ProcessState {
  attached: boolean;
  pid?: number;
  name?: string;
  processInfo?: ProcessInfo;
  appInfo?: AppInfo;
  modules?: ModuleInfo[];
  symbols?: { [moduleBase: string]: SymbolInfo[] };
}

export interface AppInfo {
  name: string;
  pid: number;
  icon?: string;
  arch?: string;
  bundleIdentifier?: string;
}

export interface ProcessInfo {
  pid: number;
  processname: string;
}

export interface ModuleInfo {
  name?: string; // deprecated, use modulename
  modulename: string;
  base_address?: string; // deprecated, use base
  base: number;
  size: number;
  path?: string;
  is_64bit?: boolean;
}

export interface InstalledAppInfo {
  bundleIdentifier: string;
  displayName: string;
  bundleVersion: string;
  bundlePath: string;
  executableName?: string;
  executablePath?: string;
  minimumOSVersion?: string;
  dataContainerPath?: string;
  iconFile?: string;
}

export interface SpawnAppResult {
  success: boolean;
  pid?: number;
  bundleIdentifier?: string;
  suspended?: boolean;
  error?: string;
  warning?: string;
}

export interface SymbolInfo {
  address: string;
  name: string;
  size: number;
  type: string;
  scope: string;
  module_base: string;
  file_name?: string;
  line_number?: number;
  // Extended Mach-O metadata (iOS/macOS only)
  is_external?: boolean;
  is_private_external?: boolean;
  is_weak_def?: boolean;
  is_weak_ref?: boolean;
  is_thumb?: boolean;
  section_index?: number;
  library_ordinal?: number;
  source?: string; // "symtab" or "export_trie"
}

export interface ThreadInfo {
  thread_id: number;
  name: string;
  pc: string;
  sp: string;
  fp: string;
  state: string;
  suspend_count: number;
}

export interface NetworkConnection {
  protocol: string;
  local_address: string;
  local_port: number;
  remote_address: string;
  remote_port: number;
  state: string;
  inode?: string;
}

export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  message?: string;
}

export interface SimpleResponse {
  success: boolean;
  message: string;
}

// Script Execution Types
export type ScriptJobStatus =
  | "pending"
  | "running"
  | "completed"
  | "failed"
  | "cancelled";

export interface ExecuteScriptResponse {
  success: boolean;
  job_id: string;
  message: string;
}

export interface ScriptFileUpload {
  filename: string;
  data_base64: string;
  mime_type?: string;
}

export interface ScriptStatusResponse {
  success: boolean;
  job_id: string;
  status: ScriptJobStatus;
  output: string;
  error?: string;
  trace_callback_registered: boolean;
  files: ScriptFileUpload[];
}

export interface ScriptCancelResponse {
  success: boolean;
  message: string;
}

export interface ScriptDisableResponse {
  success: boolean;
  message: string;
}

export interface ScanProgressResponse {
  scan_id: string;
  progress_percentage: number;
  scanned_bytes: number;
  total_bytes: number;
  is_scanning: boolean;
  current_region?: string;
}

class ApiClient {
  private baseUrl: string = "";
  private authToken: string | null = null;
  private serverSessionId: string | null = null;
  private connectionListeners: ((
    connected: boolean,
    error?: string
  ) => void)[] = [];
  private healthCheckInterval: number | null = null;
  private isHealthCheckRunning: boolean = false;

  constructor(baseUrl?: string) {
    if (baseUrl) {
      this.baseUrl = baseUrl;
    }
  }

  getBaseUrl(): string {
    return this.baseUrl;
  }

  updateConnection(host: string, port: number) {
    const newBaseUrl = `http://${host}:${port}`;
    // Only clear auth token when actually changing to a different server
    if (this.baseUrl !== newBaseUrl) {
      this.baseUrl = newBaseUrl;
      // Clear auth token when changing connection
      this.authToken = null;
      this.serverSessionId = null;
      // Also set connection for Tauri backend
      this.setTauriServerConnection(host, port);
      // Stop any existing health check
      this.stopHealthCheck();
    }
  }

  // Add connection listener for UI updates
  addConnectionListener(
    listener: (connected: boolean, error?: string) => void
  ) {
    this.connectionListeners.push(listener);
  }

  removeConnectionListener(
    listener: (connected: boolean, error?: string) => void
  ) {
    const index = this.connectionListeners.indexOf(listener);
    if (index > -1) {
      this.connectionListeners.splice(index, 1);
    }
  }

  private notifyConnectionState(connected: boolean, error?: string) {
    this.connectionListeners.forEach((listener) => listener(connected, error));
  }

  private async request<T>(
    endpoint: string,
    options?: RequestInit,
    requireAuth: boolean = true
  ): Promise<T> {
    const url = `${this.baseUrl}${endpoint}`;
    const headers: { [key: string]: string } = {
      "Content-Type": "application/json",
      ...((options?.headers as { [key: string]: string }) || {}),
    };

    // Add auth token if required and available
    if (requireAuth && this.authToken) {
      headers["Authorization"] = `Bearer ${this.authToken}`;
    }

    const startTime = performance.now();

    try {
      // Add detailed timing for single step endpoint
      const isSingleStep = endpoint === "/api/debug/step";
      if (isSingleStep) {
        console.log(`[API TIMING] fetch() starting at ${Date.now()}ms`);
      }

      const response = await fetch(url, {
        ...options,
        headers,
      });

      const fetchEndTime = performance.now();
      if (isSingleStep) {
        console.log(
          `[API TIMING] fetch() completed at ${Date.now()}ms, took ${(fetchEndTime - startTime).toFixed(2)}ms`
        );
      }

      if (!response.ok) {
        // Check for authentication errors
        if (response.status === 401) {
          this.authToken = null;
          this.serverSessionId = null;
          this.notifyConnectionState(
            false,
            "Authentication failed - server may have restarted"
          );
          throw new Error("Authentication failed - please reconnect");
        } else if (response.status === 403) {
          this.notifyConnectionState(false, "Server access denied");
          throw new Error("Server access denied");
        }

        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const jsonStartTime = performance.now();
      const jsonResult = await response.json();
      if (isSingleStep) {
        console.log(
          `[API TIMING] json() parsing took ${(performance.now() - jsonStartTime).toFixed(2)}ms, total: ${(performance.now() - startTime).toFixed(2)}ms`
        );
      }
      return jsonResult;
    } catch (error) {
      // Handle network errors as potential disconnections
      if (error instanceof TypeError && error.message.includes("fetch")) {
        this.notifyConnectionState(
          false,
          "Network error - server may be unreachable"
        );
        // Stop health check on network errors
        this.stopHealthCheck();
      } else if (
        error instanceof Error &&
        error.message.includes("ERR_CONNECTION_REFUSED")
      ) {
        this.notifyConnectionState(
          false,
          "Connection refused - server may have stopped"
        );
        this.stopHealthCheck();
      }
      throw error;
    }
  }

  async logout(): Promise<void> {
    if (this.authToken) {
      try {
        await this.request<any>("/api/auth/logout", {
          method: "POST",
        });
      } catch (error) {
        // Ignore logout errors
        console.warn("Logout request failed:", error);
      }
    }

    this.authToken = null;
    this.serverSessionId = null;
    // Stop health check when logging out
    this.stopHealthCheck();
  }

  isAuthenticated(): boolean {
    return this.authToken !== null;
  }

  getServerSessionId(): string | null {
    return this.serverSessionId;
  }

  // Set authentication info for new windows
  setAuthenticationInfo(authToken: string, serverSessionId?: string) {
    this.authToken = authToken;
    this.serverSessionId = serverSessionId || null;
    console.log("Authentication info set:", {
      hasToken: !!authToken,
      hasSessionId: !!serverSessionId,
    });
  }

  // Get current authentication info
  getAuthenticationInfo(): {
    authToken: string | null;
    serverSessionId: string | null;
  } {
    return {
      authToken: this.authToken,
      serverSessionId: this.serverSessionId,
    };
  }

  // Health check
  async healthCheck(): Promise<any> {
    return this.request<any>("/health", undefined, false);
  }

  // Start periodic health check
  startHealthCheck(intervalMs: number = 5000) {
    if (this.healthCheckInterval) {
      this.stopHealthCheck();
    }

    this.isHealthCheckRunning = true;
    this.healthCheckInterval = window.setInterval(async () => {
      if (!this.isHealthCheckRunning) {
        return;
      }

      try {
        await this.healthCheck();
        // Health check succeeded, no action needed
      } catch (error) {
        console.warn("Health check failed:", error);
        // Notify listeners about connection loss
        this.notifyConnectionState(false, "Server connection lost");
        this.stopHealthCheck();
      }
    }, intervalMs);
  }

  // Stop health check
  stopHealthCheck() {
    this.isHealthCheckRunning = false;
    if (this.healthCheckInterval) {
      window.clearInterval(this.healthCheckInterval);
      this.healthCheckInterval = null;
    }
  }

  async getServerInfo(): Promise<ServerInfo> {
    return this.request<ServerInfo>("/api/server/info");
  }

  // Process management
  async enumerateProcesses(): Promise<ProcessInfo[]> {
    return this.request<ProcessInfo[]>("/api/processes");
  }

  async attachProcess(pid: number): Promise<SimpleResponse> {
    return this.request<SimpleResponse>(`/api/processes/${pid}/attach`, {
      method: "POST",
    });
  }

  async getProcessInfo(): Promise<ApiResponse<AppInfo>> {
    return this.request<ApiResponse<AppInfo>>("/api/process/info");
  }

  async changeProcessState(doPlay: boolean): Promise<SimpleResponse> {
    return this.request<SimpleResponse>("/api/process/state", {
      method: "PUT",
      body: JSON.stringify({ do_play: doPlay }),
    });
  }

  async getProcessIcon(pid: number): Promise<string | null> {
    try {
      const response = await fetch(
        `${this.baseUrl}/api/processes/${pid}/icon`,
        {
          headers: this.authToken
            ? { Authorization: `Bearer ${this.authToken}` }
            : {},
        }
      );

      if (response.status === 401) {
        this.authToken = null;
        this.serverSessionId = null;
        this.notifyConnectionState(
          false,
          "Authentication failed - server may have restarted"
        );
        return null;
      }

      if (response.ok) {
        const blob = await response.blob();
        return URL.createObjectURL(blob);
      }
      return null;
    } catch (error) {
      if (error instanceof TypeError && error.message.includes("fetch")) {
        this.notifyConnectionState(
          false,
          "Network error - server may be unreachable"
        );
        this.stopHealthCheck();
      }
      console.debug(`Failed to get icon for process ${pid}:`, error);
      return null;
    }
  }

  // Module management
  async enumerateModules(): Promise<ApiResponse<{ modules: ModuleInfo[] }>> {
    return this.request<ApiResponse<{ modules: ModuleInfo[] }>>("/api/modules");
  }

  // Thread management
  async enumerateThreads(): Promise<ApiResponse<{ threads: ThreadInfo[] }>> {
    return this.request<ApiResponse<{ threads: ThreadInfo[] }>>("/api/threads");
  }

  // Network connections
  async enumerateNetwork(): Promise<
    ApiResponse<{ connections: NetworkConnection[] }>
  > {
    return this.request<ApiResponse<{ connections: NetworkConnection[] }>>(
      "/api/network"
    );
  }

  async enumerateSymbols(
    moduleBase: string
  ): Promise<ApiResponse<{ symbols: SymbolInfo[] }>> {
    const baseAddress = parseInt(moduleBase.replace("0x", ""), 16);
    return this.request<ApiResponse<{ symbols: SymbolInfo[] }>>(
      `/api/modules/${baseAddress}/symbols`
    );
  }

  async enumerateSymbolsForModule(module: ModuleInfo): Promise<SymbolInfo[]> {
    try {
      const baseAddress =
        module.base_address || `0x${module.base.toString(16)}`;
      const response = await this.enumerateSymbols(baseAddress);
      return response.data?.symbols || [];
    } catch (error) {
      const moduleName = module.name || module.modulename;
      console.error(
        `Failed to enumerate symbols for module ${moduleName}:`,
        error
      );
      return [];
    }
  }

  async enumerateAllSymbols(
    modules: ModuleInfo[]
  ): Promise<{ [moduleBase: string]: SymbolInfo[] }> {
    const symbolsMap: { [moduleBase: string]: SymbolInfo[] } = {};

    for (const module of modules) {
      try {
        const symbols = await this.enumerateSymbolsForModule(module);
        const baseKey = module.base_address || `0x${module.base.toString(16)}`;
        symbolsMap[baseKey] = symbols;
      } catch (error) {
        const moduleName = module.name || module.modulename;
        const baseKey = module.base_address || `0x${module.base.toString(16)}`;
        console.error(
          `Failed to enumerate symbols for module ${moduleName}:`,
          error
        );
        symbolsMap[baseKey] = [];
      }
    }

    return symbolsMap;
  }

  // Memory operations
  async readMemory(
    address: string,
    size: number,
    usePtrace: boolean = false
  ): Promise<ArrayBuffer> {
    // Convert hex address to decimal for API compatibility
    let numericAddress: number;
    if (address.startsWith("0x") || address.startsWith("0X")) {
      numericAddress = parseInt(address, 16);
    } else {
      numericAddress = parseInt(address, 10);
    }

    if (isNaN(numericAddress) || numericAddress < 0) {
      throw new Error(`Invalid address format: ${address}`);
    }

    try {
      const headers: { [key: string]: string } = {};
      if (this.authToken) {
        headers["Authorization"] = `Bearer ${this.authToken}`;
      }

      const usePtraceParam = usePtrace ? "&use_ptrace=true" : "";
      const response = await fetch(
        `${this.baseUrl}/api/memory/read?address=${numericAddress}&size=${size}${usePtraceParam}`,
        { headers }
      );

      if (!response.ok) {
        // Handle authentication errors
        if (response.status === 401) {
          this.authToken = null;
          this.serverSessionId = null;
          this.notifyConnectionState(
            false,
            "Authentication failed - server may have restarted"
          );
          throw new Error("Authentication failed - please reconnect");
        } else if (response.status === 403) {
          this.notifyConnectionState(false, "Server access denied");
          throw new Error("Server access denied");
        }

        const errorText = await response.text();
        throw new Error(
          `HTTP ${response.status}: ${response.statusText} - ${errorText}`
        );
      }

      return response.arrayBuffer();
    } catch (error) {
      // Handle network errors
      if (error instanceof TypeError && error.message.includes("fetch")) {
        this.notifyConnectionState(
          false,
          "Network error - server may be unreachable"
        );
        this.stopHealthCheck();
      }
      console.error(
        `Failed to read memory at ${address} (${numericAddress}):`,
        error
      );
      throw error;
    }
  }

  async writeMemory(address: string, buffer: ArrayBuffer): Promise<string> {
    const response = await this.request<any>("/api/memory/write", {
      method: "POST",
      body: JSON.stringify({
        address: parseInt(address.replace("0x", ""), 16),
        buffer: Array.from(new Uint8Array(buffer)),
      }),
    });
    return typeof response === "string" ? response : JSON.stringify(response);
  }

  async enumerateRegions(
    includeFilePath: boolean = true
  ): Promise<{ regions: any[] }> {
    return this.request<{ regions: any[] }>(
      `/api/memory/regions?include_file_path=${includeFilePath}`
    );
  }

  // Memory analysis
  async memoryScan(scanRequest: any): Promise<any> {
    return this.request<any>("/api/memory/scan", {
      method: "POST",
      body: JSON.stringify(scanRequest),
    });
  }

  // YARA memory scan
  async yaraScan(scanRequest: {
    rule: string;
    address_ranges: [number, number][];
    scan_id: string;
    align: number;
    do_suspend: boolean;
  }): Promise<{
    success: boolean;
    message: string;
    scan_id: string;
    matches: {
      rule_name: string;
      address: number;
      length: number;
      pattern_id: string;
      matched_data: string;
    }[];
    total_matches: number;
    scanned_bytes: number;
  }> {
    return this.request("/api/memory/yara", {
      method: "POST",
      body: JSON.stringify(scanRequest),
    });
  }

  async memoryFilter(filterRequest: FilterRequest): Promise<FilterResponse> {
    return this.request<FilterResponse>("/api/memory/filter", {
      method: "POST",
      body: JSON.stringify(filterRequest),
    });
  }

  async getScanProgress(
    scanId: string
  ): Promise<ApiResponse<ScanProgressResponse>> {
    return this.request<ApiResponse<ScanProgressResponse>>(
      "/api/memory/scan/progress",
      {
        method: "POST",
        body: JSON.stringify({ scan_id: scanId }),
      }
    );
  }

  async getFilterProgress(
    filterId: string
  ): Promise<ApiResponse<FilterProgressResponse>> {
    return this.request<ApiResponse<FilterProgressResponse>>(
      "/api/memory/filter/progress",
      {
        method: "POST",
        body: JSON.stringify({ filter_id: filterId }),
      }
    );
  }

  async getScanResults(scanId: string): Promise<any> {
    return this.request<any>("/api/memory/scan/results", {
      method: "POST",
      body: JSON.stringify({ scan_id: scanId }),
    });
  }

  async getFilterResults(scanId: string): Promise<any> {
    return this.request<any>("/api/memory/filter/results", {
      method: "POST",
      body: JSON.stringify({ scan_id: scanId }),
    });
  }

  async stopScan(scanId: string): Promise<SimpleResponse> {
    return this.request<SimpleResponse>("/api/memory/scan/stop", {
      method: "POST",
      body: JSON.stringify({ scan_id: scanId }),
    });
  }

  async clearScan(scanId: string): Promise<SimpleResponse> {
    return this.request<SimpleResponse>("/api/memory/scan/clear", {
      method: "POST",
      body: JSON.stringify({ scan_id: scanId }),
    });
  }

  // Tauri-specific disassembly (using local Rust implementation)
  async disassembleMemoryLocal(
    request: DisassembleRequest
  ): Promise<DisassembleResponse> {
    try {
      return await invoke<DisassembleResponse>("disassemble_memory", {
        request,
      });
    } catch (error) {
      return {
        success: false,
        instructions_count: 0,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  // Set server connection for Tauri backend
  async setTauriServerConnection(host: string, port: number): Promise<void> {
    try {
      await invoke("set_server_connection", { host, port });
    } catch (error) {
      console.error("Failed to set Tauri server connection:", error);
    }
  }

  // Read memory using Tauri backend
  async readMemoryLocal(
    address: number,
    size: number
  ): Promise<MemoryReadResponse> {
    try {
      return await invoke<MemoryReadResponse>("read_memory", { address, size });
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  // Native memory filter using Tauri backend (processes filter locally with network memory reads)
  async filterMemoryNative(
    request: NativeMemoryFilterRequest
  ): Promise<NativeMemoryFilterResponse> {
    try {
      return await invoke<NativeMemoryFilterResponse>("filter_memory_native", {
        request,
      });
    } catch (error) {
      return {
        success: false,
        results: [],
        total_processed: 0,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  // Native memory lookup using Tauri backend (reads current values for addresses)
  async lookupMemoryNative(
    addresses: number[],
    dataType: string
  ): Promise<NativeMemoryFilterResponse> {
    try {
      return await invoke<NativeMemoryFilterResponse>("lookup_memory_native", {
        addresses,
        data_type: dataType,
      });
    } catch (error) {
      return {
        success: false,
        results: [],
        total_processed: 0,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  // ============================================================================
  // Unknown Scan Streaming API (Server-side)
  // ============================================================================

  // Start unknown scan on server (streams compressed chunks)
  async unknownScanStart(
    request: UnknownScanStartRequest
  ): Promise<UnknownScanStartResponse> {
    return await this.request<UnknownScanStartResponse>(
      "/api/memory/unknown-scan/start",
      {
        method: "POST",
        body: JSON.stringify(request),
      }
    );
  }

  // Get streamed unknown scan data (chunks are removed from server after retrieval)
  async unknownScanStream(scanId: string): Promise<UnknownScanStreamResponse> {
    const response = await this.request<
      { success: boolean } & UnknownScanStreamResponse
    >("/api/memory/unknown-scan/stream", {
      method: "POST",
      body: JSON.stringify({ scan_id: scanId }),
    });
    return response;
  }

  // Stop unknown scan
  async unknownScanStop(
    scanId: string
  ): Promise<{ success: boolean; message: string }> {
    return await this.request<{ success: boolean; message: string }>(
      "/api/memory/unknown-scan/stop",
      {
        method: "POST",
        body: JSON.stringify({ scan_id: scanId }),
      }
    );
  }

  // ============================================================================
  // Legacy Tauri-based Unknown Scan (for backward compatibility)
  // ============================================================================

  // Native unknown scan using Tauri backend (scans memory ranges for unknown initial value)
  // Results are stored in temp files, use getUnknownScanProgress to poll progress
  async unknownScanNative(
    request: NativeUnknownScanRequest
  ): Promise<NativeUnknownScanResponse> {
    try {
      return await invoke<NativeUnknownScanResponse>("unknown_scan_native", {
        request,
      });
    } catch (error) {
      return {
        success: false,
        scan_id: request.scan_id,
        total_addresses: 0,
        temp_dir: "",
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  // Initialize unknown scan progress (call before starting scan to prevent race condition)
  async initUnknownScanProgress(
    scanId: string,
    totalBytes: number
  ): Promise<void> {
    try {
      await invoke("init_unknown_scan_progress", {
        scanId: scanId,
        totalBytes: totalBytes,
      });
    } catch (error) {
      console.error("Failed to init unknown scan progress:", error);
    }
  }

  // Get unknown scan progress
  async getUnknownScanProgress(
    scanId: string
  ): Promise<NativeUnknownScanProgress> {
    try {
      return await invoke<NativeUnknownScanProgress>(
        "get_unknown_scan_progress",
        {
          scanId: scanId,
        }
      );
    } catch (error) {
      return {
        scan_id: scanId,
        progress_percentage: 0,
        processed_bytes: 0,
        total_bytes: 0,
        found_count: 0,
        is_scanning: false,
        current_region: undefined,
      };
    }
  }

  // Load unknown scan results from temp files (for display)
  async loadUnknownScanResults(
    scanId: string,
    offset: number,
    limit: number
  ): Promise<NativeUnknownScanLookupResponse> {
    try {
      return await invoke<NativeUnknownScanLookupResponse>(
        "load_unknown_scan_results",
        {
          scanId: scanId,
          offset,
          limit,
        }
      );
    } catch (error) {
      return {
        success: false,
        results: [],
        total_count: 0,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  // Clear unknown scan temp files
  async clearUnknownScan(scanId: string): Promise<boolean> {
    try {
      return await invoke<boolean>("clear_unknown_scan", {
        scanId: scanId,
      });
    } catch (error) {
      return false;
    }
  }

  // Disassemble memory using Tauri backend with Capstone
  async disassembleWithCapstone(
    address: string,
    size: number,
    architecture: string = "arm64"
  ): Promise<DisassembleResponse> {
    try {
      // Convert address to number
      let numericAddress: number;
      if (address.startsWith("0x") || address.startsWith("0X")) {
        numericAddress = parseInt(address, 16);
      } else {
        numericAddress = parseInt(address, 10);
      }

      if (isNaN(numericAddress) || numericAddress < 0) {
        return {
          success: false,
          instructions_count: 0,
          error: `Invalid address format: ${address}`,
        };
      }

      const request = {
        address: numericAddress,
        size,
        architecture,
      };

      return await invoke<DisassembleResponse>("disassemble_memory", request);
    } catch (error) {
      return {
        success: false,
        instructions_count: 0,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  // Debug operations
  async setWatchpoint(request: {
    address: number;
    size: number;
    _type: string;
  }): Promise<{
    success: boolean;
    message: string;
    watchpoint_id?: string;
  }> {
    return this.request<{
      success: boolean;
      message: string;
      watchpoint_id?: string;
    }>("/api/debug/watchpoint", {
      method: "POST",
      body: JSON.stringify(request),
    });
  }

  async removeWatchpoint(request: {
    address: number;
  }): Promise<SimpleResponse> {
    return this.request<SimpleResponse>("/api/debug/watchpoint", {
      method: "DELETE",
      body: JSON.stringify(request),
    });
  }

  async listWatchpoints(): Promise<{
    success: boolean;
    watchpoints: WatchpointInfo[];
    message?: string;
  }> {
    return this.request<{
      success: boolean;
      watchpoints: WatchpointInfo[];
      message?: string;
    }>("/api/debug/watchpoints", {
      method: "GET",
    });
  }

  async setBreakpoint(request: {
    address: number;
    hit_count: number;
    trace_to_file?: boolean;
    trace_file_path?: string;
    end_address?: number; // Optional end address for trace
    full_memory_cache?: boolean; // If true, dump initial memory and log all memory accesses
    is_software?: boolean; // If true, use software breakpoint instead of hardware
  }): Promise<{
    success: boolean;
    message: string;
    trace_file_path?: string;
  }> {
    return this.request<{
      success: boolean;
      message: string;
      trace_file_path?: string;
    }>("/api/debug/breakpoint", {
      method: "POST",
      body: JSON.stringify(request),
    });
  }

  async removeBreakpoint(request: {
    address: number;
  }): Promise<SimpleResponse> {
    return this.request<SimpleResponse>("/api/debug/breakpoint", {
      method: "DELETE",
      body: JSON.stringify(request),
    });
  }

  // Get original instruction bytes for a software breakpoint
  async getSoftwareBreakpointBytes(address: number): Promise<{
    success: boolean;
    address: number;
    original_bytes: string;
    size: number;
    message?: string;
  }> {
    return this.request<{
      success: boolean;
      address: number;
      original_bytes: string;
      size: number;
      message?: string;
    }>(`/api/debug/breakpoint/software/${address}`, {
      method: "GET",
    });
  }

  // Trace status
  async getTraceStatus(): Promise<{
    success: boolean;
    enabled: boolean;
    file_path?: string;
    entry_count: number;
    ended_by_end_address: boolean;
    message: string;
  }> {
    // Check if baseUrl is set
    if (!this.baseUrl) {
      throw new Error("Server not connected - baseUrl is empty");
    }

    const url = `${this.baseUrl}/api/debug/trace/status`;
    const headers: { [key: string]: string } = {
      "Content-Type": "application/json",
    };
    if (this.authToken) {
      headers["Authorization"] = `Bearer ${this.authToken}`;
    }

    const response = await fetch(url, {
      method: "GET",
      headers,
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    return response.json();
  }

  // Download trace file as binary
  async downloadTraceFile(): Promise<Blob> {
    const headers: Record<string, string> = {
      Accept: "application/octet-stream",
    };
    if (this.authToken) {
      headers["Authorization"] = `Bearer ${this.authToken}`;
    }

    const response = await fetch(
      `${this.baseUrl}/api/debug/trace/file/download`,
      {
        method: "GET",
        headers,
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to download trace file: ${response.statusText}`);
    }

    return await response.blob();
  }

  async getExceptionInfo(
    exceptionTypes?: string[],
    singlestepModes?: number[]
  ): Promise<{
    success: boolean;
    exceptions: ExceptionInfo[];
    message?: string;
  }> {
    let url = "/api/debug/exception";
    const queryParams: string[] = [];

    // Add exception type filter if specified
    if (exceptionTypes && exceptionTypes.length > 0) {
      const queryParam = exceptionTypes.join(",");
      queryParams.push(`exception_type=${encodeURIComponent(queryParam)}`);
    }

    // Add singlestep_mode filter if specified
    if (singlestepModes && singlestepModes.length > 0) {
      const queryParam = singlestepModes.join(",");
      queryParams.push(`singlestep_mode=${encodeURIComponent(queryParam)}`);
    }

    // Combine query parameters
    if (queryParams.length > 0) {
      url += `?${queryParams.join("&")}`;
    }

    const response = await this.request<{
      success: boolean;
      data?: {
        exceptions: ExceptionInfo[];
      };
      message?: string;
    }>(url, {
      method: "GET",
    });

    // Transform the response to match the expected format
    return {
      success: response.success,
      exceptions: response.data?.exceptions || [],
      message: response.message,
    };
  }

  // Signal configuration (catch/pass)
  // SignalConfig: { catch_signal: boolean, pass_signal: boolean }
  // - catch=true: Stop debugger on signal
  // - pass=true: Deliver signal to process on continue
  async getSignalConfigs(): Promise<{
    success: boolean;
    configs: Array<{
      signal: number;
      catch_signal: boolean;
      pass_signal: boolean;
    }>;
  }> {
    return this.request<{
      success: boolean;
      configs: Array<{
        signal: number;
        catch_signal: boolean;
        pass_signal: boolean;
      }>;
    }>("/api/debug/signals", {
      method: "GET",
    });
  }

  async setSignalConfig(
    signal: number,
    catch_signal: boolean,
    pass_signal: boolean
  ): Promise<{
    success: boolean;
    configs: Array<{
      signal: number;
      catch_signal: boolean;
      pass_signal: boolean;
    }>;
  }> {
    return this.request<{
      success: boolean;
      configs: Array<{
        signal: number;
        catch_signal: boolean;
        pass_signal: boolean;
      }>;
    }>("/api/debug/signals", {
      method: "POST",
      body: JSON.stringify({ signal, catch_signal, pass_signal }),
    });
  }

  async setAllSignalConfigs(
    configs: Array<{
      signal: number;
      catch_signal: boolean;
      pass_signal: boolean;
    }>
  ): Promise<{
    success: boolean;
    configs: Array<{
      signal: number;
      catch_signal: boolean;
      pass_signal: boolean;
    }>;
  }> {
    return this.request<{
      success: boolean;
      configs: Array<{
        signal: number;
        catch_signal: boolean;
        pass_signal: boolean;
      }>;
    }>("/api/debug/signals/all", {
      method: "PUT",
      body: JSON.stringify({ configs }),
    });
  }

  async removeSignalConfig(signal: number): Promise<{
    success: boolean;
    configs: Array<{
      signal: number;
      catch_signal: boolean;
      pass_signal: boolean;
    }>;
  }> {
    return this.request<{
      success: boolean;
      configs: Array<{
        signal: number;
        catch_signal: boolean;
        pass_signal: boolean;
      }>;
    }>("/api/debug/signals/remove", {
      method: "POST",
      body: JSON.stringify({ signal }),
    });
  }

  // New break state control methods
  async continueExecution(threadId?: number): Promise<SimpleResponse> {
    const body = threadId ? { thread_id: threadId } : {};
    return this.request<SimpleResponse>("/api/debug/continue", {
      method: "POST",
      body: JSON.stringify(body),
    });
  }

  async continueExecutionMultiple(threadIds: number[]): Promise<{
    success: boolean;
    message: string;
    results?: Array<{ thread_id: number; success: boolean; message: string }>;
  }> {
    const body = { thread_ids: threadIds };
    return this.request<{
      success: boolean;
      message: string;
      results?: Array<{ thread_id: number; success: boolean; message: string }>;
    }>("/api/debug/continue", {
      method: "POST",
      body: JSON.stringify(body),
    });
  }

  async singleStep(threadId?: number): Promise<SimpleResponse> {
    const body = { thread_id: threadId || 0 };
    return this.request<SimpleResponse>("/api/debug/step", {
      method: "POST",
      body: JSON.stringify(body),
    });
  }

  async readRegister(
    registerName: string,
    threadId?: number
  ): Promise<{
    success: boolean;
    register_name: string;
    value?: number;
    message: string;
  }> {
    const body = threadId
      ? { register_name: registerName, thread_id: threadId }
      : { register_name: registerName };
    return this.request<{
      success: boolean;
      register_name: string;
      value?: number;
      message: string;
    }>("/api/debug/register/read", {
      method: "POST",
      body: JSON.stringify(body),
    });
  }

  async writeRegister(
    registerName: string,
    value: number,
    threadId: number
  ): Promise<SimpleResponse> {
    const body = { register_name: registerName, value, thread_id: threadId };
    return this.request<SimpleResponse>("/api/debug/register/write", {
      method: "POST",
      body: JSON.stringify(body),
    });
  }

  async getDebugState(): Promise<{
    success: boolean;
    is_in_break_state: boolean;
    message: string;
  }> {
    return this.request<{
      success: boolean;
      is_in_break_state: boolean;
      message: string;
    }>("/api/debug/state");
  }

  async disassemble(request: {
    address: number;
    size: number;
    architecture: string;
  }): Promise<{
    success: boolean;
    disassembly?: string;
    instructions_count: number;
    error?: string;
  }> {
    return this.request<{
      success: boolean;
      disassembly?: string;
      instructions_count: number;
      error?: string;
    }>("/api/memory/disassemble", {
      method: "POST",
      body: JSON.stringify(request),
    });
  }

  // Utility functions
  async resolveAddress(
    query: string
  ): Promise<ApiResponse<{ address: number }>> {
    return this.request<ApiResponse<{ address: number }>>(
      `/api/memory/resolve?query=${encodeURIComponent(query)}`
    );
  }

  async exploreDirectory(path: string, maxDepth: number = 3): Promise<any> {
    return this.request<any>(
      `/api/utils/directory?path=${encodeURIComponent(path)}&max_depth=${maxDepth}`
    );
  }

  async readFile(path: string): Promise<ArrayBuffer> {
    const headers: { [key: string]: string } = {};
    if (this.authToken) {
      headers["Authorization"] = `Bearer ${this.authToken}`;
    }

    try {
      const response = await fetch(
        `${this.baseUrl}/api/utils/file?path=${encodeURIComponent(path)}`,
        { headers }
      );

      if (!response.ok) {
        // Handle authentication errors
        if (response.status === 401) {
          this.authToken = null;
          this.serverSessionId = null;
          this.notifyConnectionState(
            false,
            "Authentication failed - server may have restarted"
          );
          throw new Error("Authentication failed - please reconnect");
        } else if (response.status === 403) {
          this.notifyConnectionState(false, "Server access denied");
          throw new Error("Server access denied");
        }

        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return response.arrayBuffer();
    } catch (error) {
      if (error instanceof TypeError && error.message.includes("fetch")) {
        this.notifyConnectionState(
          false,
          "Network error - server may be unreachable"
        );
        this.stopHealthCheck();
      }
      throw error;
    }
  }

  async uploadFile(
    path: string,
    data: ArrayBuffer
  ): Promise<{ success: boolean; path: string; error?: string }> {
    const headers: { [key: string]: string } = {};
    if (this.authToken) {
      headers["Authorization"] = `Bearer ${this.authToken}`;
    }

    try {
      const response = await fetch(
        `${this.baseUrl}/api/utils/file?path=${encodeURIComponent(path)}`,
        {
          method: "POST",
          headers,
          body: data,
        }
      );

      if (!response.ok) {
        if (response.status === 401) {
          this.authToken = null;
          this.serverSessionId = null;
          this.notifyConnectionState(
            false,
            "Authentication failed - server may have restarted"
          );
          throw new Error("Authentication failed - please reconnect");
        } else if (response.status === 403) {
          this.notifyConnectionState(false, "Server access denied");
          throw new Error("Server access denied");
        }
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return response.json();
    } catch (error) {
      if (error instanceof TypeError && error.message.includes("fetch")) {
        this.notifyConnectionState(
          false,
          "Network error - server may be unreachable"
        );
        this.stopHealthCheck();
      }
      throw error;
    }
  }

  async generatePointerScan(request: any): Promise<ArrayBuffer> {
    const headers: { [key: string]: string } = {
      "Content-Type": "application/json",
    };
    if (this.authToken) {
      headers["Authorization"] = `Bearer ${this.authToken}`;
    }

    try {
      const response = await fetch(`${this.baseUrl}/api/memory/pointer-scan`, {
        method: "POST",
        headers,
        body: JSON.stringify(request),
      });

      if (!response.ok) {
        // Handle authentication errors
        if (response.status === 401) {
          this.authToken = null;
          this.serverSessionId = null;
          this.notifyConnectionState(
            false,
            "Authentication failed - server may have restarted"
          );
          throw new Error("Authentication failed - please reconnect");
        } else if (response.status === 403) {
          this.notifyConnectionState(false, "Server access denied");
          throw new Error("Server access denied");
        }

        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return response.arrayBuffer();
    } catch (error) {
      if (error instanceof TypeError && error.message.includes("fetch")) {
        this.notifyConnectionState(
          false,
          "Network error - server may be unreachable"
        );
        this.stopHealthCheck();
      }
      throw error;
    }
  }

  /**
   * Generate a full pointermap for the entire process memory
   * Returns LZ4 compressed binary data in DynaDbg PointerMap format (.dptr)
   */
  async generatePointerMap(): Promise<ArrayBuffer> {
    const headers: { [key: string]: string } = {};
    if (this.authToken) {
      headers["Authorization"] = `Bearer ${this.authToken}`;
    }

    try {
      const response = await fetch(`${this.baseUrl}/api/memory/pointermap`, {
        method: "GET",
        headers,
      });

      if (!response.ok) {
        if (response.status === 401) {
          this.authToken = null;
          this.serverSessionId = null;
          this.notifyConnectionState(
            false,
            "Authentication failed - server may have restarted"
          );
          throw new Error("Authentication failed - please reconnect");
        } else if (response.status === 403) {
          this.notifyConnectionState(false, "Server access denied");
          throw new Error("Server access denied");
        }

        try {
          const errorData = await response.json();
          throw new Error(errorData.message || `HTTP ${response.status}: ${response.statusText}`);
        } catch {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
      }

      return response.arrayBuffer();
    } catch (error) {
      if (error instanceof TypeError && error.message.includes("fetch")) {
        this.notifyConnectionState(
          false,
          "Network error - server may be unreachable"
        );
        this.stopHealthCheck();
      }
      throw error;
    }
  }

  /**
   * Start pointermap generation with progress tracking
   */
  async startPointerMapGeneration(): Promise<{ success: boolean; task_id: string; message: string }> {
    return this.request<{ success: boolean; task_id: string; message: string }>(
      "/api/memory/pointermap/start",
      { method: "POST" }
    );
  }

  /**
   * Get pointermap generation progress
   */
  async getPointerMapProgress(taskId: string): Promise<{
    task_id: string;
    progress_percentage: number;
    current_phase: string;
    processed_regions: number;
    total_regions: number;
    processed_bytes: number;
    total_bytes: number;
    is_generating: boolean;
    is_complete: boolean;
    error: string | null;
  }> {
    return this.request("/api/memory/pointermap/progress", {
      method: "POST",
      body: JSON.stringify({ task_id: taskId }),
    });
  }

  /**
   * Download completed pointermap data
   */
  async downloadPointerMap(taskId: string): Promise<ArrayBuffer> {
    const headers: { [key: string]: string } = {
      "Content-Type": "application/json",
    };
    if (this.authToken) {
      headers["Authorization"] = `Bearer ${this.authToken}`;
    }

    const response = await fetch(`${this.baseUrl}/api/memory/pointermap/download`, {
      method: "POST",
      headers,
      body: JSON.stringify({ task_id: taskId }),
    });

    if (!response.ok) {
      try {
        const errorData = await response.json();
        throw new Error(errorData.message || `HTTP ${response.status}: ${response.statusText}`);
      } catch {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
    }

    return response.arrayBuffer();
  }

  // App management APIs (iOS)
  async getInstalledApps(): Promise<ApiResponse<{ apps: InstalledAppInfo[] }>> {
    return this.request<ApiResponse<{ apps: InstalledAppInfo[] }>>("/api/apps");
  }

  async getAppIcon(bundleIdentifier: string): Promise<string | null> {
    try {
      const headers: { [key: string]: string } = {};
      if (this.authToken) {
        headers["Authorization"] = `Bearer ${this.authToken}`;
      }

      const response = await fetch(
        `${this.baseUrl}/api/apps/icon?bundle_identifier=${encodeURIComponent(bundleIdentifier)}`,
        { headers }
      );

      if (response.status === 401) {
        this.authToken = null;
        this.serverSessionId = null;
        this.notifyConnectionState(
          false,
          "Authentication failed - server may have restarted"
        );
        return null;
      }

      if (response.ok) {
        const blob = await response.blob();
        return URL.createObjectURL(blob);
      }
      return null;
    } catch (error) {
      if (error instanceof TypeError && error.message.includes("fetch")) {
        this.notifyConnectionState(
          false,
          "Network error - server may be unreachable"
        );
        this.stopHealthCheck();
      }
      console.debug(`Failed to get icon for app ${bundleIdentifier}:`, error);
      return null;
    }
  }

  async spawnApp(
    bundleIdentifier: string,
    suspended: boolean = true
  ): Promise<ApiResponse<SpawnAppResult>> {
    return this.request<ApiResponse<SpawnAppResult>>("/api/apps/spawn", {
      method: "POST",
      body: JSON.stringify({
        bundle_identifier: bundleIdentifier,
        suspended,
      }),
    });
  }

  // Spawn a process from executable path (Linux)
  async spawnProcess(
    executablePath: string,
    args: string[] = []
  ): Promise<ApiResponse<{ pid: number; success: boolean }>> {
    return this.request<ApiResponse<{ pid: number; success: boolean }>>(
      "/api/process/spawn",
      {
        method: "POST",
        body: JSON.stringify({
          executable_path: executablePath,
          args,
        }),
      }
    );
  }

  // Spawn a process with PTY for terminal I/O (Linux)
  async spawnProcessWithPty(
    executablePath: string,
    args: string[] = []
  ): Promise<ApiResponse<{ pid: number; pty_fd: number; success: boolean }>> {
    return this.request<
      ApiResponse<{ pid: number; pty_fd: number; success: boolean }>
    >("/api/process/spawn-pty", {
      method: "POST",
      body: JSON.stringify({
        executable_path: executablePath,
        args,
      }),
    });
  }

  // Read from PTY (returns base64 encoded data)
  async ptyRead(
    ptyFd: number
  ): Promise<ApiResponse<{ data: string; bytes: number }>> {
    return this.request<ApiResponse<{ data: string; bytes: number }>>(
      `/api/pty/${ptyFd}/read`
    );
  }

  // Write to PTY
  async ptyWrite(
    ptyFd: number,
    data: string
  ): Promise<ApiResponse<{ bytes_written: number }>> {
    return this.request<ApiResponse<{ bytes_written: number }>>(
      "/api/pty/write",
      {
        method: "POST",
        body: JSON.stringify({
          pty_fd: ptyFd,
          data,
        }),
      }
    );
  }

  // Resize PTY window
  async ptyResize(
    ptyFd: number,
    rows: number,
    cols: number
  ): Promise<ApiResponse<{ success: boolean }>> {
    return this.request<ApiResponse<{ success: boolean }>>("/api/pty/resize", {
      method: "POST",
      body: JSON.stringify({
        pty_fd: ptyFd,
        rows,
        cols,
      }),
    });
  }

  // Close PTY
  async ptyClose(ptyFd: number): Promise<ApiResponse<{ success: boolean }>> {
    return this.request<ApiResponse<{ success: boolean }>>(
      `/api/pty/${ptyFd}/close`,
      {
        method: "POST",
      }
    );
  }

  async terminateApp(
    pid: number | string
  ): Promise<ApiResponse<{ terminated: boolean; pid: number }>> {
    const pidNum = typeof pid === "string" ? parseInt(pid, 10) : pid;
    return this.request<ApiResponse<{ terminated: boolean; pid: number }>>(
      "/api/apps/terminate",
      {
        method: "POST",
        body: JSON.stringify({
          pid: pidNum,
        }),
      }
    );
  }

  // Resume a suspended spawned app
  async resumeApp(
    pid: number
  ): Promise<ApiResponse<{ success: boolean; pid: number; resumed: boolean }>> {
    return this.request<
      ApiResponse<{ success: boolean; pid: number; resumed: boolean }>
    >("/api/apps/resume", {
      method: "POST",
      body: JSON.stringify({
        pid,
      }),
    });
  }

  // Check if an app is running and get its PID
  async getAppRunningStatus(
    bundleIdentifier: string
  ): Promise<
    ApiResponse<{ running: boolean; pid: number; bundle_identifier: string }>
  > {
    return this.request<
      ApiResponse<{ running: boolean; pid: number; bundle_identifier: string }>
    >(
      `/api/apps/status?bundle_identifier=${encodeURIComponent(bundleIdentifier)}`
    );
  }

  // =============================================
  // ObjC Dynamic Analyzer APIs
  // =============================================

  /**
   * Get list of all Objective-C classes
   * @param filter Optional filter string to match class names
   */
  async getObjcClassList(filter?: string): Promise<
    ApiResponse<{
      classes: import("../types").ObjcClassInfo[];
      total_count: number;
    }>
  > {
    const url = filter
      ? `/api/objc/classes?filter=${encodeURIComponent(filter)}`
      : "/api/objc/classes";
    return this.request<
      ApiResponse<{
        classes: import("../types").ObjcClassInfo[];
        total_count: number;
      }>
    >(url);
  }

  /**
   * Get methods for a specific Objective-C class
   * @param className The name of the class to get methods for
   */
  async getObjcMethods(className: string): Promise<
    ApiResponse<{
      methods: import("../types").ObjcMethodInfo[];
      total_count: number;
      class_name: string;
    }>
  > {
    return this.request<
      ApiResponse<{
        methods: import("../types").ObjcMethodInfo[];
        total_count: number;
        class_name: string;
      }>
    >(`/api/objc/methods?class_name=${encodeURIComponent(className)}`);
  }

  /**
   * Get instance variables (ivars) for a specific Objective-C class
   * @param className The name of the class to get ivars for
   */
  async getObjcIvars(className: string): Promise<
    ApiResponse<{
      ivars: import("../types").ObjcIvarInfo[];
      total_count: number;
      class_name: string;
    }>
  > {
    return this.request<
      ApiResponse<{
        ivars: import("../types").ObjcIvarInfo[];
        total_count: number;
        class_name: string;
      }>
    >(`/api/objc/ivars?class_name=${encodeURIComponent(className)}`);
  }

  /**
   * Get properties for a specific Objective-C class
   * @param className The name of the class to get properties for
   */
  async getObjcProperties(className: string): Promise<
    ApiResponse<{
      properties: import("../types").ObjcPropertyInfo[];
      total_count: number;
      class_name: string;
    }>
  > {
    return this.request<
      ApiResponse<{
        properties: import("../types").ObjcPropertyInfo[];
        total_count: number;
        class_name: string;
      }>
    >(`/api/objc/properties?class_name=${encodeURIComponent(className)}`);
  }

  /**
   * Get protocols adopted by a specific Objective-C class
   * @param className The name of the class to get protocols for
   */
  async getObjcProtocols(className: string): Promise<
    ApiResponse<{
      protocols: import("../types").ObjcProtocolInfo[];
      total_count: number;
      class_name: string;
    }>
  > {
    return this.request<
      ApiResponse<{
        protocols: import("../types").ObjcProtocolInfo[];
        total_count: number;
        class_name: string;
      }>
    >(`/api/objc/protocols?class_name=${encodeURIComponent(className)}`);
  }

  // =============================================
  // Script Execution APIs
  // =============================================

  /**
   * Execute a Python script using DynaDbg API (async execution)
   * Returns a job ID for status tracking
   * @param script Python script source code
   */
  async executeScript(script: string): Promise<ExecuteScriptResponse> {
    return this.request<ExecuteScriptResponse>("/api/script/execute", {
      method: "POST",
      body: JSON.stringify({ script }),
    });
  }

  /**
   * Get the status of a script execution job
   * @param jobId The job ID returned from executeScript
   */
  async getScriptStatus(jobId: string): Promise<ScriptStatusResponse> {
    return this.request<ScriptStatusResponse>(`/api/script/status/${jobId}`);
  }

  /**
   * Cancel a running script execution job
   * @param jobId The job ID to cancel
   */
  async cancelScript(jobId: string): Promise<ScriptCancelResponse> {
    return this.request<ScriptCancelResponse>(`/api/script/${jobId}`, {
      method: "DELETE",
    });
  }

  /**
   * Disable script session - removes all script-owned breakpoints and clears state
   */
  async disableScript(): Promise<ScriptDisableResponse> {
    return this.request<ScriptDisableResponse>("/api/script/disable", {
      method: "POST",
    });
  }

  // =============================================
  // WASM Binary APIs
  // =============================================

  /**
   * Dump the entire WASM binary from Chrome extension
   * Returns ArrayBuffer of the WASM module
   */
  async dumpWasmBinary(): Promise<ArrayBuffer | null> {
    const url = `${this.baseUrl}/api/wasm/dump`;
    const headers: { [key: string]: string } = {};
    
    if (this.authToken) {
      headers["Authorization"] = `Bearer ${this.authToken}`;
    }

    try {
      const response = await fetch(url, { headers });
      
      if (!response.ok) {
        console.error(`WASM dump failed: ${response.status}`);
        return null;
      }
      
      return await response.arrayBuffer();
    } catch (error) {
      console.error("Failed to dump WASM binary:", error);
      return null;
    }
  }

  /**
   * Get WASM module info from Chrome extension
   */
  async getWasmModuleInfo(): Promise<{
    codeSize: number;
    hasBinary: boolean;
    hasSnapshot: boolean;
  } | null> {
    try {
      const response = await this.request<{
        module_info: { codeSize: number };
        has_binary: boolean;
        has_snapshot: boolean;
      }>("/api/wasm/info");
      
      return {
        codeSize: response.module_info?.codeSize || 0,
        hasBinary: response.has_binary || false,
        hasSnapshot: response.has_snapshot || false,
      };
    } catch (error) {
      console.error("Failed to get WASM module info:", error);
      return null;
    }
  }
}

// Global API client instance
let apiClient: ApiClient | null = null;

export function getApiClient(): ApiClient {
  if (!apiClient) {
    apiClient = new ApiClient();
  }
  return apiClient;
}

// Export ApiClient class for standalone window usage
export { ApiClient };

```

`src/client/src/main.tsx`:

```tsx
import { StrictMode } from "react";
import ReactDOM from "react-dom/client";
import { HashRouter } from "react-router-dom";
import App from "./App";

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <StrictMode>
    <HashRouter>
      <App />
    </HashRouter>
  </StrictMode>
);

```

`src/client/src/pages/CodeTracingPage.tsx`:

```tsx
import React, {
  useEffect,
  useState,
  useCallback,
  useMemo,
  useRef,
} from "react";
import {
  ThemeProvider,
  CssBaseline,
  Box,
  Typography,
  IconButton,
  Tooltip,
  styled,
  alpha,
  Button,
  CircularProgress,
  LinearProgress,
  Divider,
  Select,
  MenuItem,
  FormControlLabel,
  Checkbox,
} from "@mui/material";
import { useSearchParams } from "react-router-dom";
import { invoke } from "@tauri-apps/api/core";
import { darkTheme } from "../utils/theme";
import { useTauriSystemStateSingleton } from "../hooks/useTauriSystemStateSingleton";
import {
  useTauriTraceStore,
  TauriTraceEntryData,
  TauriTraceSession,
} from "../hooks/useTauriExceptionStore";
import { getCurrentWebviewWindow } from "@tauri-apps/api/webviewWindow";
import { encodeAddressToLibraryExpression } from "../utils/addressEncoder";
import { useSymbolCache } from "../hooks/useSymbolCache";
import { ColumnResizer } from "../components/ColumnResizer";
import {
  Close as CloseIcon,
  ExpandMore as ExpandMoreIcon,
  ExpandLess as ExpandLessIcon,
  KeyboardArrowRight as ArrowRightIcon,
  KeyboardArrowDown as ArrowDownIcon,
  Timeline as TimelineIcon,
  ContentCopy as CopyIcon,
  Download as DownloadIcon,
  SwapHoriz as SwapHorizIcon,
  ViewColumn as ViewColumnIcon,
} from "@mui/icons-material";
import { parseTraceFile } from "../utils/traceFileParser";
import { getApiClient } from "../lib/api";

// Memory dump for a register
export interface RegisterMemoryDump {
  register: string;
  data: Uint8Array;
}

// Trace entry representing a single instruction execution
export interface TraceEntry {
  id: number;
  address: string;
  instruction: string;
  opcode: string;
  operands: string;
  registers: Record<string, string>;
  depth: number;
  isCall: boolean;
  isReturn: boolean;
  functionName?: string;
  timestamp?: number;
  libraryExpression?: string;
  memory?: RegisterMemoryDump[]; // Memory dumps for x0-x5
}

// Tree node for hierarchical display
interface TraceTreeNode {
  entry: TraceEntry;
  children: TraceTreeNode[];
}

// Styled components
const WindowHeader = styled(Box)(() => ({
  display: "flex",
  alignItems: "center",
  justifyContent: "space-between",
  padding: "8px 12px",
  backgroundColor: "#252526",
  borderBottom: "1px solid #3c3c3c",
}));

const WindowTitle = styled(Typography)(() => ({
  fontSize: "14px",
  fontWeight: "bold",
  color: "#4fc1ff",
  display: "flex",
  alignItems: "center",
  gap: "8px",
}));

const ToolbarContainer = styled(Box)(() => ({
  display: "flex",
  alignItems: "center",
  gap: "12px",
  padding: "8px 16px",
  backgroundColor: "#252526",
  borderBottom: "1px solid #2d2d30",
}));

const MainContent = styled(Box)(() => ({
  flex: 1,
  display: "flex",
  overflow: "hidden",
}));

const TreePanel = styled(Box)(() => ({
  flex: "1 1 70%",
  overflow: "hidden",
  borderRight: "1px solid #3c3c3c",
  fontFamily: 'Consolas, "Courier New", monospace',
  fontSize: "12px",
  display: "flex",
  flexDirection: "column",
}));

const TreePanelContent = styled(Box)(() => ({
  flex: 1,
  overflow: "auto",
  position: "relative",
  "&::-webkit-scrollbar": { width: "8px" },
  "&::-webkit-scrollbar-track": { background: "#1e1e1e" },
  "&::-webkit-scrollbar-thumb": { background: "#424242", borderRadius: "4px" },
}));

const RegisterPanel = styled(Box)(() => ({
  flex: "0 0 30%",
  minWidth: "200px",
  maxWidth: "350px",
  overflow: "auto",
  backgroundColor: "#1a1a1a",
  fontFamily: 'Consolas, "Courier New", monospace',
  fontSize: "12px",
  "&::-webkit-scrollbar": { width: "8px" },
  "&::-webkit-scrollbar-track": { background: "#1a1a1a" },
  "&::-webkit-scrollbar-thumb": { background: "#424242", borderRadius: "4px" },
}));

const RegisterPanelHeader = styled(Box)(() => ({
  padding: "6px 8px",
  backgroundColor: "#252526",
  borderBottom: "1px solid #3c3c3c",
  position: "sticky",
  top: 0,
  zIndex: 1,
}));

const RegisterSection = styled(Box)(() => ({
  padding: "4px 8px",
}));

const RegisterRow = styled(Box, {
  shouldForwardProp: (prop) => prop !== "changed",
})<{ changed?: boolean }>(({ changed }) => ({
  display: "flex",
  justifyContent: "space-between",
  padding: "1px 6px",
  borderRadius: "2px",
  backgroundColor: changed ? alpha("#ff9800", 0.15) : "transparent",
  "&:hover": { backgroundColor: alpha("#4fc1ff", 0.1) },
}));

const RegisterName = styled("span")(() => ({
  color: "#9cdcfe",
  fontWeight: "bold",
  minWidth: "45px",
}));

const RegisterValue = styled("span")(() => ({
  color: "#ce9178",
  fontFamily: 'Consolas, "Courier New", monospace',
}));

const TreeRow = styled(Box, {
  shouldForwardProp: (prop) => prop !== "selected",
})<{ selected?: boolean }>(({ selected }) => ({
  display: "flex",
  alignItems: "center",
  padding: "1px 8px",
  cursor: "pointer",
  backgroundColor: selected ? alpha("#4fc1ff", 0.2) : "transparent",
  borderLeft: selected ? "2px solid #4fc1ff" : "2px solid transparent",
  "&:hover": {
    backgroundColor: selected ? alpha("#4fc1ff", 0.25) : alpha("#4fc1ff", 0.08),
  },
}));

const TreeExpandIcon = styled(Box)(() => ({
  width: "16px",
  height: "16px",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  cursor: "pointer",
  color: "#858585",
  "&:hover": { color: "#d4d4d4" },
}));

const TreeContent = styled(Box)(() => ({
  display: "flex",
  alignItems: "center",
  gap: "8px",
  flex: 1,
  overflow: "hidden",
}));

const IndexSpan = styled("span")(() => ({
  color: "#6a9955",
  fontSize: "11px",
  fontWeight: "bold",
  flexShrink: 0,
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap",
}));

const AddressSpan = styled("span")(() => ({
  color: "#dcdcaa",
  flexShrink: 0,
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap",
}));

const LibraryExprSpan = styled("span")(() => ({
  color: "#9cdcfe",
  fontSize: "11px",
  flexShrink: 0,
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap",
}));

const InstructionContainer = styled(Box)(() => ({
  display: "flex",
  alignItems: "center",
  gap: "4px",
}));

const OpcodeSpan = styled("span")(() => ({
  color: "#569cd6",
  fontWeight: "bold",
  minWidth: "45px",
}));

const OperandsSpan = styled("span")(() => ({
  color: "#d4d4d4",
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap",
}));

const FunctionNameSpan = styled("span")(() => ({
  color: "#dcdcaa",
  marginLeft: "8px",
  fontStyle: "italic",
  opacity: 0.8,
}));

const CallReturnBadge = styled("span", {
  shouldForwardProp: (prop) => prop !== "type",
})<{ type: "call" | "return" }>(({ type }) => ({
  fontSize: "10px",
  padding: "1px 4px",
  borderRadius: "3px",
  marginLeft: "4px",
  backgroundColor:
    type === "call" ? alpha("#4caf50", 0.3) : alpha("#ff9800", 0.3),
  color: type === "call" ? "#4caf50" : "#ff9800",
}));

const StatusBar = styled(Box)(() => ({
  display: "flex",
  alignItems: "center",
  justifyContent: "space-between",
  padding: "8px 16px",
  backgroundColor: "#252526",
  borderTop: "1px solid #3c3c3c",
  fontSize: "11px",
  color: "#858585",
}));

const TableHeader = styled(Box)(() => ({
  display: "flex",
  alignItems: "center",
  padding: "4px 8px",
  backgroundColor: "#2d2d30",
  borderBottom: "1px solid #3c3c3c",
  fontFamily: 'Consolas, "Courier New", monospace',
  fontSize: "11px",
  fontWeight: "bold",
  color: "#858585",
  position: "sticky",
  top: 0,
  zIndex: 1,
}));

const HeaderCell = styled("span")(() => ({
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap",
}));

// Build tree structure from flat trace entries
const buildTraceTree = (entries: TraceEntry[]): TraceTreeNode[] => {
  const roots: TraceTreeNode[] = [];
  const stack: TraceTreeNode[] = [];

  entries.forEach((entry) => {
    const node: TraceTreeNode = { entry, children: [] };

    if (entry.isReturn && stack.length > 0) {
      stack[stack.length - 1].children.push(node);
      stack.pop();
      return;
    }

    while (
      stack.length > 0 &&
      stack[stack.length - 1].entry.depth >= entry.depth
    ) {
      stack.pop();
    }

    if (stack.length === 0) {
      roots.push(node);
    } else {
      stack[stack.length - 1].children.push(node);
    }

    if (entry.isCall) {
      stack.push(node);
    }
  });

  return roots;
};

// Column widths type
type ColumnWidths = {
  index: number;
  address: number;
  library: number;
};

// FlatRowComponent
const FlatRowComponent: React.FC<{
  entry: TraceEntry;
  selected: boolean;
  onSelect: (entry: TraceEntry) => void;
  columnWidths: ColumnWidths;
}> = ({ entry, selected, onSelect, columnWidths }) => (
  <TreeRow selected={selected} onClick={() => onSelect(entry)}>
    <TreeContent>
      <IndexSpan
        style={{ width: columnWidths.index, minWidth: columnWidths.index }}
      >
        #{entry.id}
      </IndexSpan>
      <AddressSpan
        style={{ width: columnWidths.address, minWidth: columnWidths.address }}
      >
        {entry.address}
      </AddressSpan>
      <LibraryExprSpan
        style={{ width: columnWidths.library, minWidth: columnWidths.library }}
      >
        {entry.libraryExpression || ""}
      </LibraryExprSpan>
      <InstructionContainer>
        <OpcodeSpan>{entry.opcode}</OpcodeSpan>
        <OperandsSpan>{entry.operands}</OperandsSpan>
        {entry.isCall && <CallReturnBadge type="call">CALL</CallReturnBadge>}
        {entry.isReturn && <CallReturnBadge type="return">RET</CallReturnBadge>}
        {entry.functionName && (
          <FunctionNameSpan>→ {entry.functionName}</FunctionNameSpan>
        )}
      </InstructionContainer>
    </TreeContent>
  </TreeRow>
);

// Convert TauriTraceEntryData to TraceEntry
const convertToTraceEntry = (data: TauriTraceEntryData): TraceEntry => ({
  id: data.id,
  address: data.address,
  instruction: data.instruction,
  opcode: data.opcode,
  operands: data.operands,
  registers: data.registers || {},
  depth: data.depth,
  isCall: data.is_call,
  isReturn: data.is_return,
  functionName: data.function_name,
  timestamp: data.timestamp,
  libraryExpression: data.library_expression,
});

// Code Tracing Page Component
const CodeTracingPageInner: React.FC = () => {
  const [searchParams] = useSearchParams();
  const targetAddress = searchParams.get("address") || "";
  const traceCount = parseInt(searchParams.get("count") || "100", 10);
  const loadFromFile = searchParams.get("loadFromFile") === "true";
  const localFilePath = searchParams.get("localFilePath"); // Path to local trace file

  const [selectedEntry, setSelectedEntry] = useState<TraceEntry | null>(null);
  const [expandedIds, setExpandedIds] = useState<Set<number>>(new Set());
  const [useTreeView, setUseTreeView] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // File-loaded trace data
  const [fileTraceEntries, setFileTraceEntries] = useState<TraceEntry[]>([]);
  const [isFileLoaded, setIsFileLoaded] = useState(false);
  const [showMemoryPanel, setShowMemoryPanel] = useState(false);

  // File loading progress
  const [loadingProgress, setLoadingProgress] = useState<{
    isLoading: boolean;
    phase: string;
    current: number;
    total: number;
  } | null>(null);

  // Memory panel settings
  const [memoryDisplayBytes, setMemoryDisplayBytes] = useState<number>(64);
  const [showAscii, setShowAscii] = useState<boolean>(true);
  const [hexUnitSize, setHexUnitSize] = useState<1 | 2 | 4 | 8>(1); // 1, 2, 4, or 8 bytes per hex unit
  const [hexPrefixFormat, setHexPrefixFormat] = useState<"padded" | "0x">(
    "padded"
  ); // "padded" = 00000002822a0150, "0x" = 0x2822a0150

  // Panel widths for resizable panels
  // sidePanelWidth: total width of the right side panel (Registers + Memory Dumps)
  // registerRatio: ratio of register panel width within the side panel (0.0 to 1.0)
  const [sidePanelWidth, setSidePanelWidth] = useState(680);
  const [registerRatio, setRegisterRatio] = useState(0.4); // 40% for registers, 60% for memory

  // Column width state for resizable columns
  const [columnWidths, setColumnWidths] = useState({
    index: 45,
    address: 145,
    library: 200,
  });
  const [resizingColumn, setResizingColumn] = useState<string | null>(null);
  const resizeStartX = useRef(0);
  const resizeStartWidth = useRef(0);

  // Address display format state (library or function)
  const [addressDisplayFormat, setAddressDisplayFormat] = useState<
    "library" | "function"
  >("library");

  // Virtual scrolling state
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef<HTMLDivElement>(null);
  const ROW_HEIGHT = 20;
  const OVERSCAN = 10;

  // Use Tauri system state singleton for global state
  const { state: tauriState, isLoading: tauriLoading } =
    useTauriSystemStateSingleton();

  // Use symbol cache for symbol resolution
  const { formatAddressWithSymbol, updateServerInfo, loadedModules } =
    useSymbolCache();

  // Use Tauri trace store for trace data (shared with main window)
  const {
    traceEntries: tauriTraceEntries,
    traceSession,
    getTraceEntries: fetchTraceEntries,
    getTraceSession: fetchTraceSession,
  } = useTauriTraceStore();

  // Local state for trace data (updated via polling)
  const [localTraceEntries, setLocalTraceEntries] = useState<
    TauriTraceEntryData[]
  >([]);
  const [localTraceSession, setLocalTraceSession] =
    useState<TauriTraceSession | null>(null);

  // Fetch trace data from Tauri store (polling pattern like Watchpoint)
  const fetchTraceData = useCallback(async () => {
    try {
      const session = await fetchTraceSession();
      if (session) {
        setLocalTraceSession(session);
        const entries = await fetchTraceEntries(undefined);
        setLocalTraceEntries(entries);

        // Check if trace ended by end_address (server-side termination)
        // Only check if connected to server and session is active
        if (
          session.is_active &&
          tauriState?.connectionHost &&
          tauriState?.connectionPort
        ) {
          try {
            const apiClient = getApiClient();
            // Ensure apiClient has the correct server connection
            apiClient.updateConnection(
              tauriState.connectionHost,
              tauriState.connectionPort
            );
            const status = await apiClient.getTraceStatus();
            console.log("[CodeTracingPage] Trace status:", status);
            if (status.ended_by_end_address) {
              console.log(
                "[CodeTracingPage] Trace ended by end_address, stopping session"
              );
              // Stop the Tauri session to update UI
              await invoke("stop_trace_session");
              // Update local state immediately
              setLocalTraceSession((prev) =>
                prev ? { ...prev, is_active: false } : null
              );
            }
          } catch (statusError) {
            // Ignore errors from getTraceStatus - server might not be available
            console.debug(
              "[CodeTracingPage] Failed to get trace status:",
              statusError
            );
          }
        }
      }
    } catch (err) {
      console.error("Failed to fetch trace data:", err);
    }
  }, [
    fetchTraceSession,
    fetchTraceEntries,
    tauriState?.connectionHost,
    tauriState?.connectionPort,
  ]);

  // Ref to track current state for close handler (to avoid stale closures)
  const closeHandlerStateRef = useRef({
    localTraceEntries: [] as TauriTraceEntryData[],
    localTraceSession: null as TauriTraceSession | null,
    connectionHost: "",
    connectionPort: 0,
  });

  // Ref to prevent multiple close attempts (shared across handlers)
  const isClosingRef = useRef(false);

  // Keep ref updated with latest state
  useEffect(() => {
    closeHandlerStateRef.current = {
      localTraceEntries,
      localTraceSession,
      connectionHost: tauriState?.connectionHost || "",
      connectionPort: tauriState?.connectionPort || 0,
    };
  }, [
    localTraceEntries,
    localTraceSession,
    tauriState?.connectionHost,
    tauriState?.connectionPort,
  ]);

  // Handle window close event (when user clicks X button)
  // This ensures breakpoint is removed even when closing via window controls
  useEffect(() => {
    if (loadFromFile || localFilePath) {
      // Don't need to handle breakpoint cleanup for file loading mode
      return;
    }

    const currentWindow = getCurrentWebviewWindow();

    const setupCloseHandler = async () => {
      const unlisten = await currentWindow.onCloseRequested(async () => {
        // Prevent multiple close attempts
        if (isClosingRef.current) {
          return;
        }
        isClosingRef.current = true;

        // Get current state from ref
        const state = closeHandlerStateRef.current;

        // Check if we need to remove breakpoint
        const hasTraceEntries =
          state.localTraceEntries.length > 0 ||
          (state.localTraceSession &&
            state.localTraceSession.current_count > 0);

        if (!hasTraceEntries && targetAddress) {
          console.log(
            "[CodeTracingPage] Window close requested, removing pending breakpoint:",
            targetAddress
          );
          try {
            const apiClient = getApiClient();
            if (state.connectionHost && state.connectionPort) {
              apiClient.updateConnection(
                state.connectionHost,
                state.connectionPort
              );
            }
            const addressNum = parseInt(targetAddress.replace(/^0x/i, ""), 16);
            if (!isNaN(addressNum)) {
              // Fire and forget - don't wait for the response
              apiClient
                .removeBreakpoint({ address: addressNum })
                .then(() => {
                  console.log(
                    "[CodeTracingPage] Breakpoint removed successfully"
                  );
                })
                .catch((error) => {
                  console.error(
                    "[CodeTracingPage] Failed to remove breakpoint:",
                    error
                  );
                });
            }
          } catch (error) {
            console.error(
              "[CodeTracingPage] Failed to remove breakpoint:",
              error
            );
          }
        }

        // Don't call preventDefault() - let the window close naturally
        // The breakpoint removal is fire-and-forget
      });

      return unlisten;
    };

    let unlistenFn: (() => void) | undefined;
    setupCloseHandler().then((fn) => {
      unlistenFn = fn;
    });

    return () => {
      if (unlistenFn) {
        unlistenFn();
      }
    };
  }, [loadFromFile, localFilePath, targetAddress]); // Minimal dependencies - state accessed via ref

  // Polling for trace data (same pattern as WatchpointExceptionWindow)
  // Skip polling when loading from file
  useEffect(() => {
    if (loadFromFile || localFilePath) {
      // Don't poll when in file loading mode
      return;
    }

    // Initial fetch
    fetchTraceData();

    // Poll for updates every 250ms
    const interval = setInterval(fetchTraceData, 250);

    return () => {
      clearInterval(interval);
    };
  }, [fetchTraceData, loadFromFile, localFilePath]);

  // Also update when tauriTraceEntries changes (from event listeners)
  useEffect(() => {
    if (tauriTraceEntries.length > 0) {
      setLocalTraceEntries(tauriTraceEntries);
    }
  }, [tauriTraceEntries]);

  // Also update session when traceSession changes
  useEffect(() => {
    if (traceSession) {
      setLocalTraceSession(traceSession);
    }
  }, [traceSession]);

  // Get attached modules from Tauri state for address resolution
  const attachedModules = useMemo(() => {
    return tauriState?.attachedModules || [];
  }, [tauriState?.attachedModules]);

  // Convert Tauri trace entries to local format, remove duplicates, sort by ID,
  // and recalculate libraryExpression from current module info with symbol resolution
  const traceEntries = useMemo(() => {
    const converted = localTraceEntries.map((data) => {
      const entry = convertToTraceEntry(data);

      // If we have attached modules, try to resolve address based on display format
      if (attachedModules.length > 0) {
        const addressNum = parseInt(entry.address.replace(/^0x/i, ""), 16);
        if (!isNaN(addressNum)) {
          // Use formatAddressWithSymbol with current display format
          const expr = formatAddressWithSymbol(
            addressNum,
            attachedModules,
            addressDisplayFormat
          );
          if (expr) {
            entry.libraryExpression = expr;
          } else {
            // Fallback to library + offset
            const libraryExpr = encodeAddressToLibraryExpression(
              addressNum,
              attachedModules,
              true // prefer short name
            );
            if (libraryExpr) {
              entry.libraryExpression = libraryExpr;
            }
          }
        }
      }

      return entry;
    });
    // Remove duplicates by ID (keep first occurrence)
    const uniqueMap = new Map<number, TraceEntry>();
    converted.forEach((entry) => {
      if (!uniqueMap.has(entry.id)) {
        uniqueMap.set(entry.id, entry);
      }
    });
    // Sort by ID to ensure correct order
    return Array.from(uniqueMap.values()).sort((a, b) => a.id - b.id);
  }, [
    localTraceEntries,
    attachedModules,
    formatAddressWithSymbol,
    loadedModules,
    addressDisplayFormat,
  ]);

  // Get active trace entries (file-loaded or live) with symbol resolution
  const activeTraceEntries = useMemo(() => {
    const baseEntries =
      isFileLoaded && fileTraceEntries.length > 0
        ? fileTraceEntries
        : traceEntries;

    // For file-loaded entries, apply symbol resolution
    if (
      isFileLoaded &&
      fileTraceEntries.length > 0 &&
      attachedModules.length > 0
    ) {
      return baseEntries.map((entry) => {
        const addressNum = parseInt(entry.address.replace(/^0x/i, ""), 16);
        if (!isNaN(addressNum)) {
          const expr = formatAddressWithSymbol(
            addressNum,
            attachedModules,
            addressDisplayFormat
          );
          if (expr) {
            return { ...entry, libraryExpression: expr };
          } else {
            const libraryExpr = encodeAddressToLibraryExpression(
              addressNum,
              attachedModules,
              true
            );
            if (libraryExpr) {
              return { ...entry, libraryExpression: libraryExpr };
            }
          }
        }
        return entry;
      });
    }

    return baseEntries;
  }, [
    isFileLoaded,
    fileTraceEntries,
    traceEntries,
    attachedModules,
    formatAddressWithSymbol,
    addressDisplayFormat,
  ]);

  // Derive tracing state from session
  // File loading mode is never in tracing state
  const isTracing =
    loadFromFile || localFilePath
      ? false
      : (localTraceSession?.is_active ?? false);
  const tracingProgress = localTraceSession
    ? {
        current: localTraceSession.current_count,
        total: localTraceSession.total_count,
      }
    : { current: 0, total: traceCount };

  // Show error if not connected, and update symbol cache server info
  useEffect(() => {
    if (tauriLoading) return;

    if (!tauriState?.connectionHost || !tauriState?.connectionPort) {
      setError("No connection information available");
    } else {
      setError(null);
      // Update symbol cache with server info for symbol loading
      updateServerInfo({
        ip: tauriState.connectionHost,
        port: tauriState.connectionPort,
      });
    }
  }, [tauriState, tauriLoading, updateServerInfo]);

  // Update expanded IDs only on initial load (not on every poll)
  const initialExpandedRef = useRef(false);
  useEffect(() => {
    if (activeTraceEntries.length > 0 && !initialExpandedRef.current) {
      setExpandedIds(
        new Set(activeTraceEntries.filter((e) => e.isCall).map((e) => e.id))
      );
      initialExpandedRef.current = true;
    }
  }, [activeTraceEntries]);

  // Reset expanded state when trace session changes (new trace started)
  useEffect(() => {
    if (localTraceSession?.started_at) {
      initialExpandedRef.current = false;
    }
  }, [localTraceSession?.started_at]);

  const treeNodes = useMemo(
    () => buildTraceTree(activeTraceEntries),
    [activeTraceEntries]
  );

  const flattenedTreeRows = useMemo(() => {
    const rows: { node: TraceTreeNode; depth: number }[] = [];
    const traverse = (nodes: TraceTreeNode[], depth: number) => {
      nodes.forEach((node) => {
        rows.push({ node, depth });
        if (node.children.length > 0 && expandedIds.has(node.entry.id)) {
          traverse(node.children, depth + 1);
        }
      });
    };
    traverse(treeNodes, 0);
    return rows;
  }, [treeNodes, expandedIds]);

  const visibleRows = useMemo(() => {
    const containerHeight = containerRef.current?.clientHeight || 600;
    const totalRows = useTreeView
      ? flattenedTreeRows.length
      : activeTraceEntries.length;
    const startIndex = Math.max(
      0,
      Math.floor(scrollTop / ROW_HEIGHT) - OVERSCAN
    );
    const endIndex = Math.min(
      totalRows,
      Math.ceil((scrollTop + containerHeight) / ROW_HEIGHT) + OVERSCAN
    );
    return { startIndex, endIndex, totalRows };
  }, [
    scrollTop,
    flattenedTreeRows.length,
    activeTraceEntries.length,
    useTreeView,
  ]);

  const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {
    setScrollTop(e.currentTarget.scrollTop);
  }, []);

  // Column resize handler
  const handleColumnResizeStart = useCallback(
    (column: keyof typeof columnWidths) => (e: React.MouseEvent) => {
      e.preventDefault();
      setResizingColumn(column);
      resizeStartX.current = e.clientX;
      resizeStartWidth.current = columnWidths[column];

      const handleMouseMove = (moveEvent: MouseEvent) => {
        const delta = moveEvent.clientX - resizeStartX.current;
        const newWidth = Math.max(30, resizeStartWidth.current + delta);
        setColumnWidths((prev) => ({ ...prev, [column]: newWidth }));
      };

      const handleMouseUp = () => {
        setResizingColumn(null);
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
      };

      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
    },
    [columnWidths]
  );

  const previousEntry = useMemo(() => {
    if (!selectedEntry) return null;
    const idx = activeTraceEntries.findIndex((e) => e.id === selectedEntry.id);
    return idx > 0 ? activeTraceEntries[idx - 1] : null;
  }, [selectedEntry, activeTraceEntries]);

  const changedRegisters = useMemo(() => {
    if (!selectedEntry || !previousEntry) return new Set<string>();
    const changed = new Set<string>();
    Object.keys(selectedEntry.registers).forEach((reg) => {
      if (selectedEntry.registers[reg] !== previousEntry.registers[reg]) {
        changed.add(reg);
      }
    });
    return changed;
  }, [selectedEntry, previousEntry]);

  const toggleExpand = useCallback((id: number) => {
    setExpandedIds((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(id)) newSet.delete(id);
      else newSet.add(id);
      return newSet;
    });
  }, []);

  const expandAll = useCallback(() => {
    setExpandedIds(
      new Set(activeTraceEntries.filter((e) => e.isCall).map((e) => e.id))
    );
  }, [activeTraceEntries]);

  const collapseAll = useCallback(() => {
    setExpandedIds(new Set());
  }, []);

  // Handle downloading trace file from server
  const handleDownloadFromServer = useCallback(async () => {
    try {
      // Clear existing entries before loading
      setFileTraceEntries([]);
      setIsFileLoaded(false);

      setLoadingProgress({
        isLoading: true,
        phase: "Downloading from server...",
        current: 0,
        total: 0,
      });

      const api = getApiClient();

      // Try to download directly - don't check status first as file_path may be empty after completion
      const blob = await api.downloadTraceFile();

      if (blob.size === 0) {
        console.log("No trace file available on server (empty response)");
        setLoadingProgress(null);
        return;
      }

      setLoadingProgress({
        isLoading: true,
        phase: "Parsing trace file...",
        current: 0,
        total: 0,
      });
      const arrayBuffer = await blob.arrayBuffer();
      const result = parseTraceFile(arrayBuffer);

      if (!result || !result.entries) {
        console.error("Failed to parse downloaded trace file");
        setLoadingProgress(null);
        return;
      }

      // ParsedTraceEntry is compatible with TraceEntry, use directly without copying
      setFileTraceEntries(result.entries as TraceEntry[]);
      setIsFileLoaded(true);
      setShowMemoryPanel(true);
      setLoadingProgress(null);
    } catch (err) {
      console.error("Failed to download trace file from server:", err);
      setLoadingProgress(null);
    }
  }, []);

  // Auto-download from server when loadFromFile is true, or load from local file when localFilePath is provided
  useEffect(() => {
    if (localFilePath && !isFileLoaded) {
      console.log(`Loading trace file from local path: ${localFilePath}`);

      // Read file using Rust backend
      (async () => {
        try {
          // Clear existing entries before loading
          setFileTraceEntries([]);

          setLoadingProgress({
            isLoading: true,
            phase: "Reading file...",
            current: 0,
            total: 0,
          });

          // Receive base64 encoded file data for faster transfer
          const base64Data = await invoke<string>("read_trace_file", {
            path: localFilePath,
          });

          // Decode base64 to ArrayBuffer
          const binaryString = atob(base64Data);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          const arrayBuffer = bytes.buffer;

          setLoadingProgress({
            isLoading: true,
            phase: "Parsing trace file...",
            current: 0,
            total: 0,
          });
          const result = parseTraceFile(arrayBuffer);

          if (!result || !result.entries) {
            console.error("Failed to parse trace file");
            setLoadingProgress(null);
            return;
          }

          // ParsedTraceEntry is compatible with TraceEntry, use directly without copying
          setFileTraceEntries(result.entries as TraceEntry[]);
          setIsFileLoaded(true);
          setShowMemoryPanel(true);
          setLoadingProgress(null);

          console.log(
            `Loaded ${result.entries.length} entries from file: ${localFilePath}`
          );
        } catch (err) {
          console.error("Failed to load trace file:", err);
          setLoadingProgress(null);
        }
      })();
    } else if (loadFromFile && !isFileLoaded) {
      console.log("Auto-downloading trace file from server...");
      handleDownloadFromServer();
    }
  }, [loadFromFile, localFilePath, isFileLoaded, handleDownloadFromServer]);

  const handleRowClick = useCallback((entry: TraceEntry) => {
    setSelectedEntry(entry);
    // TODO: Emit event to main window to navigate to address
  }, []);

  const handleCopyToClipboard = useCallback(() => {
    const text = activeTraceEntries
      .map((e) => `${e.address}: ${e.opcode} ${e.operands}`)
      .join("\n");
    navigator.clipboard.writeText(text);
  }, [activeTraceEntries]);

  const handleExportJson = useCallback(() => {
    const json = JSON.stringify(activeTraceEntries, null, 2);
    const blob = new Blob([json], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `trace_${targetAddress || "unknown"}_${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }, [activeTraceEntries, targetAddress]);

  const handleClose = useCallback(async () => {
    // Just trigger window close - the onCloseRequested handler will handle breakpoint cleanup
    try {
      const currentWindow = getCurrentWebviewWindow();
      await currentWindow.close();
    } catch (err) {
      console.error("Failed to close window:", err);
    }
  }, []);

  const stats = useMemo(() => {
    let calls = 0,
      returns = 0,
      maxDepth = 0;
    activeTraceEntries.forEach((e) => {
      if (e.isCall) calls++;
      if (e.isReturn) returns++;
      if (e.depth > maxDepth) maxDepth = e.depth;
    });
    return { calls, returns, maxDepth };
  }, [activeTraceEntries]);

  const registerGroups = useMemo(() => {
    if (!selectedEntry) return [];

    // Detect architecture based on available registers
    const isX86_64 =
      selectedEntry.registers["rax"] !== undefined ||
      selectedEntry.registers["RAX"] !== undefined ||
      selectedEntry.registers["rip"] !== undefined ||
      selectedEntry.registers["RIP"] !== undefined;

    if (isX86_64) {
      // x86_64 registers
      const generalRegs = [
        {
          name: "rax",
          value: selectedEntry.registers["rax"] || "0x0",
          changed: changedRegisters.has("rax"),
        },
        {
          name: "rbx",
          value: selectedEntry.registers["rbx"] || "0x0",
          changed: changedRegisters.has("rbx"),
        },
        {
          name: "rcx",
          value: selectedEntry.registers["rcx"] || "0x0",
          changed: changedRegisters.has("rcx"),
        },
        {
          name: "rdx",
          value: selectedEntry.registers["rdx"] || "0x0",
          changed: changedRegisters.has("rdx"),
        },
        {
          name: "rsi",
          value: selectedEntry.registers["rsi"] || "0x0",
          changed: changedRegisters.has("rsi"),
        },
        {
          name: "rdi",
          value: selectedEntry.registers["rdi"] || "0x0",
          changed: changedRegisters.has("rdi"),
        },
        {
          name: "rbp",
          value: selectedEntry.registers["rbp"] || "0x0",
          changed: changedRegisters.has("rbp"),
        },
        {
          name: "r8",
          value: selectedEntry.registers["r8"] || "0x0",
          changed: changedRegisters.has("r8"),
        },
        {
          name: "r9",
          value: selectedEntry.registers["r9"] || "0x0",
          changed: changedRegisters.has("r9"),
        },
        {
          name: "r10",
          value: selectedEntry.registers["r10"] || "0x0",
          changed: changedRegisters.has("r10"),
        },
        {
          name: "r11",
          value: selectedEntry.registers["r11"] || "0x0",
          changed: changedRegisters.has("r11"),
        },
        {
          name: "r12",
          value: selectedEntry.registers["r12"] || "0x0",
          changed: changedRegisters.has("r12"),
        },
        {
          name: "r13",
          value: selectedEntry.registers["r13"] || "0x0",
          changed: changedRegisters.has("r13"),
        },
        {
          name: "r14",
          value: selectedEntry.registers["r14"] || "0x0",
          changed: changedRegisters.has("r14"),
        },
        {
          name: "r15",
          value: selectedEntry.registers["r15"] || "0x0",
          changed: changedRegisters.has("r15"),
        },
      ];
      const specialRegs = [
        {
          name: "rsp",
          value: selectedEntry.registers["rsp"] || "0x0",
          changed: changedRegisters.has("rsp"),
        },
        {
          name: "rip",
          value: selectedEntry.registers["rip"] || "0x0",
          changed: changedRegisters.has("rip"),
        },
        {
          name: "rflags",
          value: selectedEntry.registers["rflags"] || "0x0",
          changed: changedRegisters.has("rflags"),
        },
      ];
      const segmentRegs = [
        {
          name: "cs",
          value: selectedEntry.registers["cs"] || "0x0",
          changed: changedRegisters.has("cs"),
        },
        {
          name: "ss",
          value: selectedEntry.registers["ss"] || "0x0",
          changed: changedRegisters.has("ss"),
        },
        {
          name: "ds",
          value: selectedEntry.registers["ds"] || "0x0",
          changed: changedRegisters.has("ds"),
        },
        {
          name: "es",
          value: selectedEntry.registers["es"] || "0x0",
          changed: changedRegisters.has("es"),
        },
        {
          name: "fs",
          value: selectedEntry.registers["fs"] || "0x0",
          changed: changedRegisters.has("fs"),
        },
        {
          name: "gs",
          value: selectedEntry.registers["gs"] || "0x0",
          changed: changedRegisters.has("gs"),
        },
      ];
      return [
        { title: "General Purpose Registers", regs: generalRegs },
        { title: "Special Registers", regs: specialRegs },
        { title: "Segment Registers", regs: segmentRegs },
      ];
    } else {
      // ARM64 registers
      const generalRegs = [];
      for (let i = 0; i <= 29; i++) {
        const name = `x${i}`;
        if (selectedEntry.registers[name]) {
          generalRegs.push({
            name,
            value: selectedEntry.registers[name],
            changed: changedRegisters.has(name),
          });
        }
      }
      const specialRegs = [
        {
          name: "lr",
          value: selectedEntry.registers["lr"] || "0x0",
          changed: changedRegisters.has("lr"),
        },
        {
          name: "fp",
          value: selectedEntry.registers["fp"] || "0x0",
          changed: changedRegisters.has("fp"),
        },
        {
          name: "sp",
          value: selectedEntry.registers["sp"] || "0x0",
          changed: changedRegisters.has("sp"),
        },
        {
          name: "pc",
          value: selectedEntry.registers["pc"] || "0x0",
          changed: changedRegisters.has("pc"),
        },
        {
          name: "cpsr",
          value: selectedEntry.registers["cpsr"] || "0x0",
          changed: changedRegisters.has("cpsr"),
        },
      ];
      return [
        { title: "General Purpose Registers", regs: generalRegs },
        { title: "Special Registers", regs: specialRegs },
      ];
    }
  }, [selectedEntry, changedRegisters]);

  if (error) {
    return (
      <ThemeProvider theme={darkTheme}>
        <CssBaseline />
        <Box
          sx={{
            height: "100vh",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            color: "#f44336",
          }}
        >
          <Typography>{error}</Typography>
        </Box>
      </ThemeProvider>
    );
  }

  return (
    <ThemeProvider theme={darkTheme}>
      <CssBaseline />
      <Box
        sx={{
          height: "100vh",
          display: "flex",
          flexDirection: "column",
          backgroundColor: "#1e1e1e",
        }}
      >
        <WindowHeader>
          <WindowTitle>
            <TimelineIcon />
            Code Tracing
            {localFilePath ? (
              <Typography
                variant="caption"
                sx={{ color: "#858585", ml: 1, fontWeight: "normal" }}
              >
                - {localFilePath.split("/").pop() || "File"}
              </Typography>
            ) : loadFromFile ? (
              <Typography
                variant="caption"
                sx={{ color: "#858585", ml: 1, fontWeight: "normal" }}
              >
                - Downloaded
              </Typography>
            ) : targetAddress && targetAddress !== "0x0" ? (
              <Typography
                variant="caption"
                sx={{ color: "#858585", ml: 1, fontWeight: "normal" }}
              >
                @ {targetAddress}
              </Typography>
            ) : null}
          </WindowTitle>
          <Box display="flex" alignItems="center" gap={1}>
            <Tooltip title="Copy all to clipboard">
              <IconButton
                size="small"
                onClick={handleCopyToClipboard}
                sx={{ color: "#858585" }}
                disabled={activeTraceEntries.length === 0}
              >
                <CopyIcon fontSize="small" />
              </IconButton>
            </Tooltip>
            <Tooltip title="Export as JSON">
              <IconButton
                size="small"
                onClick={handleExportJson}
                sx={{ color: "#858585" }}
                disabled={activeTraceEntries.length === 0}
              >
                <DownloadIcon fontSize="small" />
              </IconButton>
            </Tooltip>
            <IconButton
              size="small"
              onClick={handleClose}
              sx={{ color: "#858585" }}
            >
              <CloseIcon fontSize="small" />
            </IconButton>
          </Box>
        </WindowHeader>

        <ToolbarContainer>
          <Button
            size="small"
            onClick={() => setUseTreeView(!useTreeView)}
            sx={{ color: "#858585", fontSize: "11px", textTransform: "none" }}
          >
            {useTreeView ? "Flat View" : "Tree View"}
          </Button>
          <Divider
            orientation="vertical"
            flexItem
            sx={{ mx: 1, borderColor: "#3c3c3c" }}
          />
          <Tooltip title="Expand All">
            <IconButton
              size="small"
              onClick={expandAll}
              sx={{ color: "#858585" }}
              disabled={!useTreeView}
            >
              <ExpandMoreIcon />
            </IconButton>
          </Tooltip>
          <Tooltip title="Collapse All">
            <IconButton
              size="small"
              onClick={collapseAll}
              sx={{ color: "#858585" }}
              disabled={!useTreeView}
            >
              <ExpandLessIcon />
            </IconButton>
          </Tooltip>

          {isFileLoaded && (
            <Tooltip
              title={
                showMemoryPanel ? "Hide memory panel" : "Show memory panel"
              }
            >
              <IconButton
                size="small"
                onClick={() => setShowMemoryPanel(!showMemoryPanel)}
                sx={{ color: showMemoryPanel ? "#4fc1ff" : "#858585" }}
              >
                <ViewColumnIcon fontSize="small" />
              </IconButton>
            </Tooltip>
          )}
        </ToolbarContainer>

        <Box
          sx={{
            flex: 1,
            overflow: "hidden",
            display: "flex",
            flexDirection: "column",
          }}
        >
          {isTracing && tracingProgress && (
            <Box
              sx={{
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                padding: "12px",
                gap: 2,
                backgroundColor: alpha("#4fc1ff", 0.1),
              }}
            >
              {tracingProgress.current === 0 ? (
                <Typography variant="body2" sx={{ color: "#d4d4d4" }}>
                  Waiting for breakpoint hit...
                </Typography>
              ) : (
                <>
                  <CircularProgress size={20} />
                  <Typography variant="body2" sx={{ color: "#d4d4d4" }}>
                    Tracing... {tracingProgress.current} /{" "}
                    {tracingProgress.total} instructions
                  </Typography>
                </>
              )}
            </Box>
          )}

          {/* File loading progress */}
          {loadingProgress && (
            <Box
              sx={{
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                justifyContent: "center",
                padding: "20px",
                backgroundColor: "#252526",
                borderBottom: "1px solid #3c3c3c",
              }}
            >
              <Typography variant="body2" sx={{ color: "#d4d4d4", mb: 1 }}>
                {loadingProgress.phase}
                {loadingProgress.total > 0 && (
                  <>
                    {" "}
                    ({loadingProgress.current.toLocaleString()} /{" "}
                    {loadingProgress.total.toLocaleString()})
                  </>
                )}
              </Typography>
              <Box sx={{ width: "100%", maxWidth: 400 }}>
                {loadingProgress.total > 0 ? (
                  <LinearProgress
                    variant="determinate"
                    value={
                      (loadingProgress.current / loadingProgress.total) * 100
                    }
                    sx={{
                      height: 6,
                      borderRadius: 3,
                      backgroundColor: "#3c3c3c",
                      "& .MuiLinearProgress-bar": {
                        backgroundColor: "#4fc1ff",
                        borderRadius: 3,
                      },
                    }}
                  />
                ) : (
                  <LinearProgress
                    sx={{
                      height: 6,
                      borderRadius: 3,
                      backgroundColor: "#3c3c3c",
                      "& .MuiLinearProgress-bar": {
                        backgroundColor: "#4fc1ff",
                      },
                    }}
                  />
                )}
              </Box>
              {loadingProgress.total > 0 && (
                <Typography variant="caption" sx={{ color: "#858585", mt: 1 }}>
                  {Math.round(
                    (loadingProgress.current / loadingProgress.total) * 100
                  )}
                  %
                </Typography>
              )}
            </Box>
          )}

          {!loadingProgress && (
            <MainContent>
              <TreePanel>
                <TableHeader>
                  <Box
                    sx={{
                      width: `${columnWidths.index}px`,
                      minWidth: `${columnWidths.index}px`,
                      flexShrink: 0,
                      position: "relative",
                    }}
                  >
                    <HeaderCell>#</HeaderCell>
                    <ColumnResizer
                      onMouseDown={handleColumnResizeStart("index")}
                      isResizing={resizingColumn === "index"}
                    />
                  </Box>
                  <Box
                    sx={{
                      width: `${columnWidths.address}px`,
                      minWidth: `${columnWidths.address}px`,
                      flexShrink: 0,
                      ml: 1,
                      position: "relative",
                    }}
                  >
                    <HeaderCell>Address</HeaderCell>
                    <ColumnResizer
                      onMouseDown={handleColumnResizeStart("address")}
                      isResizing={resizingColumn === "address"}
                    />
                  </Box>
                  <Box
                    sx={{
                      width: `${columnWidths.library}px`,
                      minWidth: `${columnWidths.library}px`,
                      flexShrink: 0,
                      ml: 1,
                      position: "relative",
                      display: "flex",
                      alignItems: "center",
                    }}
                  >
                    <HeaderCell>Detail</HeaderCell>
                    <Tooltip
                      title={
                        addressDisplayFormat === "library"
                          ? "library + offset (click to switch to function)"
                          : "module@function + offset (click to switch to library)"
                      }
                    >
                      <IconButton
                        size="small"
                        onClick={() =>
                          setAddressDisplayFormat((prev) =>
                            prev === "library" ? "function" : "library"
                          )
                        }
                        sx={{
                          padding: "2px",
                          ml: 0.5,
                          color:
                            addressDisplayFormat === "function"
                              ? "#dcdcaa"
                              : "#808080",
                          "&:hover": { color: "#fff" },
                        }}
                      >
                        <SwapHorizIcon sx={{ fontSize: 14 }} />
                      </IconButton>
                    </Tooltip>
                    <ColumnResizer
                      onMouseDown={handleColumnResizeStart("library")}
                      isResizing={resizingColumn === "library"}
                    />
                  </Box>
                  <HeaderCell sx={{ flex: 1, ml: 1 }}>Instruction</HeaderCell>
                </TableHeader>
                {activeTraceEntries.length === 0 ? (
                  <Box
                    sx={{
                      display: "flex",
                      flexDirection: "column",
                      alignItems: "center",
                      justifyContent: "center",
                      flex: 1,
                      color: "#858585",
                    }}
                  >
                    <TimelineIcon sx={{ fontSize: 48, opacity: 0.5, mb: 2 }} />
                    <Typography variant="body2">
                      {isTracing
                        ? "Waiting for trace data..."
                        : "No trace data"}
                    </Typography>
                  </Box>
                ) : (
                  <TreePanelContent ref={containerRef} onScroll={handleScroll}>
                    <Box
                      sx={{
                        height: visibleRows.totalRows * ROW_HEIGHT,
                        position: "relative",
                      }}
                    >
                      <Box
                        sx={{
                          position: "absolute",
                          top: visibleRows.startIndex * ROW_HEIGHT,
                          left: 0,
                          right: 0,
                        }}
                      >
                        {useTreeView
                          ? flattenedTreeRows
                              .slice(
                                visibleRows.startIndex,
                                visibleRows.endIndex
                              )
                              .map(({ node, depth }) => (
                                <Box
                                  key={node.entry.id}
                                  sx={{ height: ROW_HEIGHT }}
                                >
                                  <TreeRow
                                    selected={
                                      selectedEntry?.id === node.entry.id
                                    }
                                    onClick={() => handleRowClick(node.entry)}
                                  >
                                    <TreeContent>
                                      <IndexSpan
                                        style={{
                                          width: columnWidths.index,
                                          minWidth: columnWidths.index,
                                        }}
                                      >
                                        #{node.entry.id}
                                      </IndexSpan>
                                      <AddressSpan
                                        style={{
                                          width: columnWidths.address,
                                          minWidth: columnWidths.address,
                                        }}
                                      >
                                        {node.entry.address}
                                      </AddressSpan>
                                      <LibraryExprSpan
                                        style={{
                                          width: columnWidths.library,
                                          minWidth: columnWidths.library,
                                        }}
                                      >
                                        {node.entry.libraryExpression || ""}
                                      </LibraryExprSpan>
                                      <InstructionContainer
                                        style={{ paddingLeft: depth * 16 }}
                                      >
                                        {node.children.length > 0 ? (
                                          <TreeExpandIcon
                                            onClick={(e) => {
                                              e.stopPropagation();
                                              e.preventDefault();
                                              toggleExpand(node.entry.id);
                                            }}
                                          >
                                            {expandedIds.has(node.entry.id) ? (
                                              <ArrowDownIcon
                                                sx={{ fontSize: 14 }}
                                              />
                                            ) : (
                                              <ArrowRightIcon
                                                sx={{ fontSize: 14 }}
                                              />
                                            )}
                                          </TreeExpandIcon>
                                        ) : (
                                          <Box sx={{ width: 16 }} />
                                        )}
                                        <OpcodeSpan>
                                          {node.entry.opcode}
                                        </OpcodeSpan>
                                        <OperandsSpan>
                                          {node.entry.operands}
                                        </OperandsSpan>
                                        {node.entry.isCall && (
                                          <CallReturnBadge type="call">
                                            CALL
                                          </CallReturnBadge>
                                        )}
                                        {node.entry.isReturn && (
                                          <CallReturnBadge type="return">
                                            RET
                                          </CallReturnBadge>
                                        )}
                                        {node.entry.functionName && (
                                          <FunctionNameSpan>
                                            → {node.entry.functionName}
                                          </FunctionNameSpan>
                                        )}
                                      </InstructionContainer>
                                    </TreeContent>
                                  </TreeRow>
                                </Box>
                              ))
                          : activeTraceEntries
                              .slice(
                                visibleRows.startIndex,
                                visibleRows.endIndex
                              )
                              .map((entry) => (
                                <Box key={entry.id} sx={{ height: ROW_HEIGHT }}>
                                  <FlatRowComponent
                                    entry={entry}
                                    selected={selectedEntry?.id === entry.id}
                                    onSelect={handleRowClick}
                                    columnWidths={columnWidths}
                                  />
                                </Box>
                              ))}
                      </Box>
                    </Box>
                  </TreePanelContent>
                )}
              </TreePanel>

              {/* Resizer between Tree Panel and Side Panel (Registers + Memory) */}
              <Box
                sx={{
                  width: "4px",
                  cursor: "col-resize",
                  backgroundColor: "#3c3c3c",
                  "&:hover": { backgroundColor: "#4fc1ff" },
                  "&:active": { backgroundColor: "#4fc1ff" },
                }}
                onMouseDown={(e) => {
                  e.preventDefault();
                  const startX = e.clientX;
                  const startWidth = sidePanelWidth;
                  const onMouseMove = (moveEvent: MouseEvent) => {
                    const delta = startX - moveEvent.clientX;
                    setSidePanelWidth(
                      Math.max(300, Math.min(900, startWidth + delta))
                    );
                  };
                  const onMouseUp = () => {
                    document.removeEventListener("mousemove", onMouseMove);
                    document.removeEventListener("mouseup", onMouseUp);
                  };
                  document.addEventListener("mousemove", onMouseMove);
                  document.addEventListener("mouseup", onMouseUp);
                }}
              />

              {/* Side Panel Container (Registers + Memory Dumps) */}
              <Box
                sx={{
                  width: sidePanelWidth,
                  minWidth: 300,
                  maxWidth: 900,
                  display: "flex",
                  flexDirection: "row",
                  flex: "none",
                }}
              >
                <RegisterPanel
                  sx={{
                    width:
                      showMemoryPanel && isFileLoaded && selectedEntry?.memory
                        ? `${registerRatio * 100}%`
                        : "100%",
                    minWidth: 180,
                    flex: "none",
                  }}
                >
                  <RegisterPanelHeader>
                    <Typography
                      variant="subtitle2"
                      sx={{ color: "#4fc1ff", fontWeight: "bold" }}
                    >
                      Registers
                    </Typography>
                    {selectedEntry && (
                      <Typography
                        variant="caption"
                        sx={{ color: "#858585", display: "block", mt: 0.5 }}
                      >
                        #{selectedEntry.id} @ {selectedEntry.address}
                      </Typography>
                    )}
                  </RegisterPanelHeader>

                  {selectedEntry ? (
                    <>
                      {registerGroups.map((group, groupIdx) => (
                        <RegisterSection key={groupIdx}>
                          <Typography
                            variant="caption"
                            sx={{
                              color: "#858585",
                              fontSize: "10px",
                              textTransform: "uppercase",
                              letterSpacing: "0.5px",
                              display: "block",
                              mb: 1,
                            }}
                          >
                            {group.title}
                          </Typography>
                          {group.regs.map((reg) => (
                            <RegisterRow key={reg.name} changed={reg.changed}>
                              <RegisterName>{reg.name}</RegisterName>
                              <RegisterValue>{reg.value}</RegisterValue>
                            </RegisterRow>
                          ))}
                          {groupIdx < registerGroups.length - 1 && (
                            <Divider sx={{ my: 1, borderColor: "#3c3c3c" }} />
                          )}
                        </RegisterSection>
                      ))}
                    </>
                  ) : (
                    <Box
                      sx={{
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        justifyContent: "center",
                        height: "200px",
                        color: "#858585",
                      }}
                    >
                      <Typography variant="caption">
                        Select an instruction to view registers
                      </Typography>
                    </Box>
                  )}
                </RegisterPanel>

                {/* Internal Resizer between Register Panel and Memory Panel (within the side panel) */}
                {showMemoryPanel && isFileLoaded && selectedEntry?.memory && (
                  <Box
                    sx={{
                      width: "4px",
                      cursor: "col-resize",
                      backgroundColor: "#3c3c3c",
                      "&:hover": { backgroundColor: "#4fc1ff" },
                      "&:active": { backgroundColor: "#4fc1ff" },
                    }}
                    onMouseDown={(e) => {
                      e.preventDefault();
                      const startX = e.clientX;
                      const startRatio = registerRatio;
                      const containerWidth = sidePanelWidth - 4; // minus resizer width
                      const onMouseMove = (moveEvent: MouseEvent) => {
                        const delta = moveEvent.clientX - startX;
                        const newRatio = startRatio + delta / containerWidth;
                        setRegisterRatio(
                          Math.max(0.2, Math.min(0.8, newRatio))
                        );
                      };
                      const onMouseUp = () => {
                        document.removeEventListener("mousemove", onMouseMove);
                        document.removeEventListener("mouseup", onMouseUp);
                      };
                      document.addEventListener("mousemove", onMouseMove);
                      document.addEventListener("mouseup", onMouseUp);
                    }}
                  />
                )}

                {/* Memory Panel for file-loaded traces */}
                {showMemoryPanel && isFileLoaded && selectedEntry?.memory && (
                  <Box
                    sx={{
                      flex: 1,
                      minWidth: 200,
                      borderLeft: "1px solid #3c3c3c",
                      backgroundColor: "#1e1e1e",
                      display: "flex",
                      flexDirection: "column",
                      overflow: "hidden",
                    }}
                  >
                    {/* Header - matching RegisterPanelHeader style */}
                    <Box
                      sx={{
                        padding: "6px 8px",
                        backgroundColor: "#252526",
                        borderBottom: "1px solid #3c3c3c",
                      }}
                    >
                      <Typography
                        variant="subtitle2"
                        sx={{ color: "#4fc1ff", fontWeight: "bold" }}
                      >
                        Memory Dumps
                      </Typography>
                      {selectedEntry && (
                        <Typography
                          variant="caption"
                          sx={{ color: "#858585", display: "block", mt: 0.5 }}
                        >
                          #{selectedEntry.id} @ {selectedEntry.address}
                        </Typography>
                      )}
                    </Box>
                    {/* Controls */}
                    <Box
                      sx={{
                        padding: "4px 8px",
                        borderBottom: "1px solid #3c3c3c",
                        display: "flex",
                        alignItems: "center",
                        gap: 1,
                        backgroundColor: "#252526",
                      }}
                    >
                      <Select
                        size="small"
                        value={memoryDisplayBytes}
                        onChange={(e) =>
                          setMemoryDisplayBytes(Number(e.target.value))
                        }
                        sx={{
                          color: "#d4d4d4",
                          fontSize: "10px",
                          height: "22px",
                          "& .MuiOutlinedInput-notchedOutline": {
                            borderColor: "#3c3c3c",
                          },
                          "&:hover .MuiOutlinedInput-notchedOutline": {
                            borderColor: "#4fc1ff",
                          },
                          "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
                            borderColor: "#4fc1ff",
                          },
                          "& .MuiSelect-icon": { color: "#858585" },
                        }}
                      >
                        <MenuItem value={16}>16B</MenuItem>
                        <MenuItem value={32}>32B</MenuItem>
                        <MenuItem value={64}>64B</MenuItem>
                        <MenuItem value={128}>128B</MenuItem>
                        <MenuItem value={256}>256B</MenuItem>
                      </Select>
                      <Box
                        sx={{
                          display: "flex",
                          border: "1px solid #3c3c3c",
                          borderRadius: "3px",
                        }}
                      >
                        {([1, 2, 4, 8] as const).map((size) => (
                          <Box
                            key={size}
                            onClick={() => setHexUnitSize(size)}
                            sx={{
                              px: 0.8,
                              py: 0.3,
                              fontSize: "10px",
                              cursor: "pointer",
                              backgroundColor:
                                hexUnitSize === size
                                  ? "#4fc1ff"
                                  : "transparent",
                              color:
                                hexUnitSize === size ? "#1e1e1e" : "#858585",
                              fontWeight:
                                hexUnitSize === size ? "bold" : "normal",
                              "&:hover": {
                                backgroundColor:
                                  hexUnitSize === size
                                    ? "#4fc1ff"
                                    : alpha("#4fc1ff", 0.2),
                              },
                              borderRight:
                                size !== 8 ? "1px solid #3c3c3c" : "none",
                            }}
                          >
                            {size}B
                          </Box>
                        ))}
                      </Box>
                      {/* Hex format toggle - only shown for 2B/4B/8B */}
                      {hexUnitSize > 1 && (
                        <Box
                          sx={{
                            display: "flex",
                            border: "1px solid #3c3c3c",
                            borderRadius: "3px",
                          }}
                        >
                          {(["padded", "0x"] as const).map((fmt) => (
                            <Box
                              key={fmt}
                              onClick={() => setHexPrefixFormat(fmt)}
                              sx={{
                                px: 0.8,
                                py: 0.3,
                                fontSize: "10px",
                                cursor: "pointer",
                                backgroundColor:
                                  hexPrefixFormat === fmt
                                    ? "#4fc1ff"
                                    : "transparent",
                                color:
                                  hexPrefixFormat === fmt
                                    ? "#1e1e1e"
                                    : "#858585",
                                fontWeight:
                                  hexPrefixFormat === fmt ? "bold" : "normal",
                                "&:hover": {
                                  backgroundColor:
                                    hexPrefixFormat === fmt
                                      ? "#4fc1ff"
                                      : alpha("#4fc1ff", 0.2),
                                },
                                borderRight:
                                  fmt === "padded"
                                    ? "1px solid #3c3c3c"
                                    : "none",
                              }}
                            >
                              {fmt === "padded" ? "Pad" : "0x"}
                            </Box>
                          ))}
                        </Box>
                      )}
                      <FormControlLabel
                        control={
                          <Checkbox
                            checked={showAscii}
                            onChange={(e) => setShowAscii(e.target.checked)}
                            size="small"
                            sx={{
                              color: "#858585",
                              "&.Mui-checked": { color: "#4fc1ff" },
                              padding: "2px",
                            }}
                          />
                        }
                        label={
                          <Typography
                            sx={{ color: "#858585", fontSize: "10px" }}
                          >
                            ASCII
                          </Typography>
                        }
                        sx={{ margin: 0, marginLeft: 0.5 }}
                      />
                    </Box>
                    <Box
                      sx={{
                        flex: 1,
                        overflow: "auto",
                        padding: "4px 8px",
                      }}
                    >
                      {["x0", "x1", "x2", "x3", "x4", "x5"].map((reg) => {
                        // Find memory dump for this register in the array
                        const memEntry = selectedEntry.memory?.find(
                          (m) => m.register === reg
                        );
                        const memDump = memEntry?.data;
                        if (!memDump || memDump.length === 0) return null;
                        const address = selectedEntry.registers[reg];
                        const displayData = memDump.slice(
                          0,
                          memoryDisplayBytes
                        );
                        const bytesPerLine = 16;

                        // Format hex values based on unit size
                        const formatHexUnits = (chunk: Uint8Array) => {
                          const units: string[] = [];
                          const hexChars = hexUnitSize * 2;

                          for (let i = 0; i < chunk.length; i += hexUnitSize) {
                            let value = 0n;
                            // Little-endian: first byte is least significant
                            for (
                              let j = 0;
                              j < hexUnitSize && i + j < chunk.length;
                              j++
                            ) {
                              value |= BigInt(chunk[i + j]) << BigInt(j * 8);
                            }
                            if (hexUnitSize > 1 && hexPrefixFormat === "0x") {
                              // 0x format with zero padding
                              units.push(
                                "0x" +
                                  value.toString(16).padStart(hexChars, "0")
                              );
                            } else {
                              // Padded format
                              units.push(
                                value.toString(16).padStart(hexChars, "0")
                              );
                            }
                          }
                          return units;
                        };

                        return (
                          <Box key={reg} sx={{ mb: 1.5 }}>
                            <Typography
                              variant="caption"
                              sx={{
                                color: "#858585",
                                fontSize: "10px",
                                letterSpacing: "0.5px",
                                display: "block",
                                mb: 0.5,
                              }}
                            >
                              {reg.toUpperCase()} @{" "}
                              {address?.startsWith("0x") ||
                              address?.startsWith("0X")
                                ? "0x" + address.slice(2).toLowerCase()
                                : address?.toLowerCase()}
                            </Typography>
                            <Box
                              sx={{
                                backgroundColor: "#252525",
                                borderRadius: "3px",
                                padding: "4px 6px",
                                fontFamily: "monospace",
                                fontSize: "10px",
                                overflow: "auto",
                              }}
                            >
                              {Array.from({
                                length: Math.ceil(
                                  displayData.length / bytesPerLine
                                ),
                              }).map((_, lineIndex) => {
                                const start = lineIndex * bytesPerLine;
                                const chunk = displayData.slice(
                                  start,
                                  start + bytesPerLine
                                );
                                return (
                                  <Box
                                    key={lineIndex}
                                    sx={{
                                      display: "flex",
                                      whiteSpace: "pre",
                                      lineHeight: "1.4",
                                    }}
                                  >
                                    {/* Offset */}
                                    <Box
                                      component="span"
                                      sx={{
                                        color: "#569cd6",
                                        minWidth: "36px",
                                      }}
                                    >
                                      {start.toString(16).padStart(4, "0")}
                                    </Box>
                                    {/* Separator between Offset and Hex */}
                                    <Box
                                      component="span"
                                      sx={{
                                        color: "#3c3c3c",
                                        width: "12px",
                                        textAlign: "center",
                                      }}
                                    >
                                      {" "}
                                    </Box>
                                    {/* Hex bytes - with configurable unit size */}
                                    <Box
                                      component="span"
                                      sx={{
                                        color: "#dcdcaa",
                                      }}
                                    >
                                      {formatHexUnits(chunk).map(
                                        (hexVal, i, arr) => (
                                          <span key={i}>
                                            {hexVal}
                                            {i < arr.length - 1 ? " " : ""}
                                          </span>
                                        )
                                      )}
                                    </Box>
                                    {/* ASCII */}
                                    {showAscii && (
                                      <>
                                        {/* Separator between Hex and ASCII */}
                                        <Box
                                          component="span"
                                          sx={{
                                            color: "#3c3c3c",
                                            width: "12px",
                                            textAlign: "center",
                                          }}
                                        >
                                          {" "}
                                        </Box>
                                        <Box
                                          component="span"
                                          sx={{ color: "#ce9178" }}
                                        >
                                          {Array.from(chunk).map((b, i) => (
                                            <span key={i}>
                                              {b >= 32 && b < 127
                                                ? String.fromCharCode(b)
                                                : "."}
                                            </span>
                                          ))}
                                        </Box>
                                      </>
                                    )}
                                  </Box>
                                );
                              })}
                            </Box>
                          </Box>
                        );
                      })}
                    </Box>
                  </Box>
                )}
              </Box>
              {/* End of Side Panel Container */}
            </MainContent>
          )}
        </Box>

        <StatusBar>
          <Box display="flex" gap={3}>
            <span>Total: {activeTraceEntries.length} instructions</span>
            <span>Calls: {stats.calls}</span>
            <span>Returns: {stats.returns}</span>
            <span>Max Depth: {stats.maxDepth}</span>
          </Box>
          {isTracing && (
            <Typography variant="caption" sx={{ color: "#4caf50" }}>
              ● Tracing in progress...
            </Typography>
          )}
        </StatusBar>
      </Box>
    </ThemeProvider>
  );
};

export const CodeTracingPage: React.FC = () => {
  return <CodeTracingPageInner />;
};

```

`src/client/src/pages/GraphViewPage.tsx`:

```tsx
import React, { useEffect, useState, useCallback, useRef } from "react";
import {
  ThemeProvider,
  CssBaseline,
  Box,
  Typography,
  IconButton,
  Tooltip,
  styled,
  alpha,
  CircularProgress,
} from "@mui/material";
import { useSearchParams } from "react-router-dom";
import { darkTheme } from "../utils/theme";
import { invoke } from "@tauri-apps/api/core";
import { emit } from "@tauri-apps/api/event";
import { getCurrentWebviewWindow } from "@tauri-apps/api/webviewWindow";
import {
  Close as CloseIcon,
  ZoomIn as ZoomInIcon,
  ZoomOut as ZoomOutIcon,
  CenterFocusStrong as CenterIcon,
  AccountTree as GraphIcon,
} from "@mui/icons-material";
import {
  useGhidraAnalysis,
  GhidraCfgBlock,
  GhidraCfgEdge,
  BlockReachability,
} from "../hooks/useGhidraAnalysis";
import { useTauriSystemState } from "../hooks/useTauriSystemState";
import { useTauriExceptionStore } from "../hooks/useTauriExceptionStore";

// Basic block structure
interface BasicBlock {
  id: string;
  startAddress: string;
  endAddress: string;
  instructions: Instruction[];
  successors: string[]; // IDs of successor blocks
  predecessors: string[]; // IDs of predecessor blocks
  isEntry: boolean;
  isExit: boolean;
}

interface Instruction {
  address: string;
  bytes: string;
  opcode: string;
  operands: string;
  detail?: string; // Module detail info
}

// Layout position for blocks
interface BlockLayout {
  id: string;
  x: number;
  y: number;
  width: number;
  height: number;
}

// Edge between blocks
interface Edge {
  from: string;
  to: string;
  type: "normal" | "conditional-true" | "conditional-false" | "unconditional";
}

// Data from Tauri store
interface GraphViewStoredData {
  address: string;
  function_name: string;
  instructions: string; // JSON string
  function_start_address: string;
  function_end_address: string;
  // Ghidra CFG mode fields (optional)
  ghidra_mode?: boolean;
  library_path?: string;
  function_offset?: string;
  // dbgsrv URL for Z3 reachability analysis
  server_url?: string;
  // Breakpoint register values for reachability analysis (optional)
  breakpoint_registers?: Record<string, string>;
  // Library base address for offset calculation (optional)
  library_base_address?: string;
}

// CFG source mode
type CfgSourceMode = "dynamic" | "ghidra";

// Styled components
const WindowContainer = styled(Box)(() => ({
  display: "flex",
  flexDirection: "column",
  height: "100vh",
  width: "100vw",
  backgroundColor: "#1e1e1e",
  overflow: "hidden",
}));

const WindowHeader = styled(Box)(() => ({
  display: "flex",
  alignItems: "center",
  justifyContent: "space-between",
  padding: "8px 12px",
  backgroundColor: "#252526",
  borderBottom: "1px solid #3c3c3c",
  flexShrink: 0,
}));

const WindowTitle = styled(Typography)(() => ({
  fontSize: "14px",
  fontWeight: "bold",
  color: "#4fc1ff",
  display: "flex",
  alignItems: "center",
  gap: "8px",
}));

const ToolbarContainer = styled(Box)(() => ({
  display: "flex",
  alignItems: "center",
  gap: "8px",
  padding: "6px 12px",
  backgroundColor: "#252526",
  borderBottom: "1px solid #2d2d30",
  flexShrink: 0,
}));

const GraphCanvas = styled(Box)(() => ({
  flex: 1,
  overflow: "hidden",
  position: "relative",
  cursor: "grab",
  "&:active": {
    cursor: "grabbing",
  },
}));

const BlockContainer = styled(Box, {
  shouldForwardProp: (prop) =>
    prop !== "isEntry" && prop !== "isExit" && prop !== "isDragging",
})<{ isEntry?: boolean; isExit?: boolean; isDragging?: boolean }>(
  ({ isEntry, isExit, isDragging }) => ({
    position: "absolute",
    backgroundColor: "#252526",
    border: `2px solid ${isEntry ? "#4caf50" : isExit ? "#ff5722" : "#3c3c3c"}`,
    borderRadius: "4px",
    overflow: "hidden",
    minWidth: "420px",
    maxWidth: "600px",
    boxShadow: isDragging
      ? "0 8px 24px rgba(0,0,0,0.5)"
      : "0 2px 8px rgba(0,0,0,0.3)",
    cursor: isDragging ? "grabbing" : "grab",
    transition: isDragging ? "none" : "box-shadow 0.2s ease",
    zIndex: isDragging ? 1000 : 1,
    "&:hover": {
      borderColor: "#4fc1ff",
    },
  })
);

const BlockHeader = styled(Box, {
  shouldForwardProp: (prop) => prop !== "isEntry" && prop !== "isExit",
})<{ isEntry?: boolean; isExit?: boolean }>(({ isEntry, isExit }) => ({
  padding: "4px 8px",
  backgroundColor: isEntry
    ? alpha("#4caf50", 0.2)
    : isExit
      ? alpha("#ff5722", 0.2)
      : "#1a1a1a",
  borderBottom: "1px solid #3c3c3c",
  fontSize: "12px",
  fontFamily: 'Consolas, "Courier New", monospace',
  color: isEntry ? "#4caf50" : isExit ? "#ff5722" : "#4fc1ff",
  fontWeight: "bold",
  cursor: "grab",
  userSelect: "none",
}));

const InstructionRow = styled(Box)(() => ({
  display: "flex",
  padding: "1px 8px",
  fontSize: "12px",
  fontFamily: 'Consolas, "Courier New", monospace',
  lineHeight: 1.2,
  cursor: "pointer",
  "&:hover": {
    backgroundColor: alpha("#4fc1ff", 0.1),
  },
}));

const AddressText = styled(Typography)(() => ({
  color: "#4fc1ff",
  fontSize: "12px",
  fontFamily: 'Consolas, "Courier New", monospace',
  minWidth: "90px",
  marginRight: "12px",
  flexShrink: 0,
}));

const OpcodeText = styled(Typography)(() => ({
  color: "#569cd6",
  fontSize: "12px",
  fontFamily: 'Consolas, "Courier New", monospace',
  fontWeight: "bold",
  minWidth: "60px",
  marginRight: "12px",
  flexShrink: 0,
}));

const OperandsText = styled(Typography)(() => ({
  color: "#d4d4d4",
  fontSize: "12px",
  fontFamily: 'Consolas, "Courier New", monospace',
  flexGrow: 1,
  whiteSpace: "nowrap",
}));

const LoadingOverlay = styled(Box)(() => ({
  position: "absolute",
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  display: "flex",
  flexDirection: "column",
  alignItems: "center",
  justifyContent: "center",
  backgroundColor: alpha("#1e1e1e", 0.9),
  zIndex: 100,
}));

// Minimap container
const MinimapContainer = styled(Box)(() => ({
  position: "absolute",
  top: 10,
  left: 10,
  width: 200,
  height: 150,
  backgroundColor: alpha("#1a1a1a", 0.95),
  border: "1px solid #3c3c3c",
  borderRadius: 4,
  overflow: "hidden",
  zIndex: 50,
  cursor: "pointer",
  boxShadow: "0 2px 8px rgba(0,0,0,0.3)",
}));

// Jump instruction detection
// Note: bl, blr, call are function calls that return to the next instruction,
// so they should NOT split blocks
const JUMP_OPCODES = new Set([
  // ARM64
  "b",
  "br",
  "ret",
  "b.eq",
  "b.ne",
  "b.cs",
  "b.cc",
  "b.mi",
  "b.pl",
  "b.vs",
  "b.vc",
  "b.hi",
  "b.ls",
  "b.ge",
  "b.lt",
  "b.gt",
  "b.le",
  "b.al",
  "cbz",
  "cbnz",
  "tbz",
  "tbnz",
  // x86
  "jmp",
  "je",
  "jne",
  "jz",
  "jnz",
  "jc",
  "jnc",
  "js",
  "jns",
  "jo",
  "jno",
  "jp",
  "jnp",
  "ja",
  "jae",
  "jb",
  "jbe",
  "jg",
  "jge",
  "jl",
  "jle",
  "ret",
  "retn",
  // WASM control flow
  "br",
  "br_if",
  "br_table",
  "return",
  "end",
]);

const CONDITIONAL_JUMP_OPCODES = new Set([
  // ARM64
  "b.eq",
  "b.ne",
  "b.cs",
  "b.cc",
  "b.mi",
  "b.pl",
  "b.vs",
  "b.vc",
  "b.hi",
  "b.ls",
  "b.ge",
  "b.lt",
  "b.gt",
  "b.le",
  "cbz",
  "cbnz",
  "tbz",
  "tbnz",
  // x86
  "je",
  "jne",
  "jz",
  "jnz",
  "jc",
  "jnc",
  "js",
  "jns",
  "jo",
  "jno",
  "jp",
  "jnp",
  "ja",
  "jae",
  "jb",
  "jbe",
  "jg",
  "jge",
  "jl",
  "jle",
  // WASM conditional
  "br_if",
  "if",
]);

const RETURN_OPCODES = new Set(["ret", "retn", "return"]);

const isJumpInstruction = (opcode: string): boolean => {
  return JUMP_OPCODES.has(opcode.toLowerCase());
};

const isConditionalJump = (opcode: string): boolean => {
  return CONDITIONAL_JUMP_OPCODES.has(opcode.toLowerCase());
};

const isReturnInstruction = (opcode: string): boolean => {
  return RETURN_OPCODES.has(opcode.toLowerCase());
};

// Extract jump target from operands
const extractJumpTarget = (operands: string): string | null => {
  const match = operands.match(/(0x[0-9a-fA-F]+)/);
  return match ? match[1].toLowerCase() : null;
};

// Build CFG from instructions
const buildCFG = (
  instructions: Instruction[]
): { blocks: BasicBlock[]; edges: Edge[] } => {
  if (instructions.length === 0) {
    return { blocks: [], edges: [] };
  }

  // Build address to index map
  const addressToIndex = new Map<string, number>();
  instructions.forEach((instr, idx) => {
    const normalizedAddr = instr.address.toLowerCase().replace(/^0x0*/, "0x");
    addressToIndex.set(normalizedAddr, idx);
    addressToIndex.set(instr.address.toLowerCase(), idx);
  });

  // Identify block leaders (first instruction of each block)
  const leaders = new Set<number>();
  leaders.add(0); // First instruction is always a leader

  instructions.forEach((instr, idx) => {
    const opcode = instr.opcode.toLowerCase();

    if (isJumpInstruction(opcode)) {
      // Next instruction after jump is a leader
      if (idx + 1 < instructions.length) {
        leaders.add(idx + 1);
      }

      // Jump target is a leader
      const target = extractJumpTarget(instr.operands);
      if (target) {
        const normalizedTarget = target.toLowerCase().replace(/^0x0*/, "0x");
        const targetIdx = addressToIndex.get(normalizedTarget);
        if (targetIdx !== undefined) {
          leaders.add(targetIdx);
        }
      }
    }
  });

  // Sort leaders to create blocks
  const sortedLeaders = Array.from(leaders).sort((a, b) => a - b);

  // Create basic blocks
  const blocks: BasicBlock[] = [];
  const addressToBlockId = new Map<string, string>();

  sortedLeaders.forEach((leaderIdx, blockIdx) => {
    const nextLeaderIdx =
      blockIdx + 1 < sortedLeaders.length
        ? sortedLeaders[blockIdx + 1]
        : instructions.length;

    const blockInstructions = instructions.slice(leaderIdx, nextLeaderIdx);
    const blockId = `block_${blockIdx}`;

    const block: BasicBlock = {
      id: blockId,
      startAddress: blockInstructions[0].address,
      endAddress: blockInstructions[blockInstructions.length - 1].address,
      instructions: blockInstructions,
      successors: [],
      predecessors: [],
      isEntry: blockIdx === 0,
      isExit: false,
    };

    blocks.push(block);

    // Map addresses to block ID
    blockInstructions.forEach((instr) => {
      const normalizedAddr = instr.address.toLowerCase().replace(/^0x0*/, "0x");
      addressToBlockId.set(normalizedAddr, blockId);
      addressToBlockId.set(instr.address.toLowerCase(), blockId);
    });
  });

  // Build edges
  const edges: Edge[] = [];

  blocks.forEach((block) => {
    const lastInstr = block.instructions[block.instructions.length - 1];
    const opcode = lastInstr.opcode.toLowerCase();

    if (isReturnInstruction(opcode)) {
      block.isExit = true;
      return;
    }

    if (isJumpInstruction(opcode)) {
      const target = extractJumpTarget(lastInstr.operands);

      if (target) {
        const normalizedTarget = target.toLowerCase().replace(/^0x0*/, "0x");
        const targetBlockId = addressToBlockId.get(normalizedTarget);

        if (targetBlockId) {
          block.successors.push(targetBlockId);
          const targetBlock = blocks.find((b) => b.id === targetBlockId);
          if (targetBlock) {
            targetBlock.predecessors.push(block.id);
          }

          const edgeType = isConditionalJump(opcode)
            ? "conditional-true"
            : "unconditional";
          edges.push({ from: block.id, to: targetBlockId, type: edgeType });
        }
      }

      // Conditional jumps fall through to next block
      if (isConditionalJump(opcode)) {
        const blockIdx = blocks.indexOf(block);
        if (blockIdx + 1 < blocks.length) {
          const nextBlock = blocks[blockIdx + 1];
          block.successors.push(nextBlock.id);
          nextBlock.predecessors.push(block.id);
          edges.push({
            from: block.id,
            to: nextBlock.id,
            type: "conditional-false",
          });
        }
      }
    } else {
      // Non-jump instruction falls through
      const blockIdx = blocks.indexOf(block);
      if (blockIdx + 1 < blocks.length) {
        const nextBlock = blocks[blockIdx + 1];
        block.successors.push(nextBlock.id);
        nextBlock.predecessors.push(block.id);
        edges.push({ from: block.id, to: nextBlock.id, type: "normal" });
      } else {
        block.isExit = true;
      }
    }
  });

  // Mark blocks with no successors as exits
  blocks.forEach((block) => {
    if (block.successors.length === 0) {
      block.isExit = true;
    }
  });

  return { blocks, edges };
};

// Address-aware layout algorithm - respects address order for natural flow
const layoutBlocks = (blocks: BasicBlock[], edges: Edge[]): BlockLayout[] => {
  if (blocks.length === 0) return [];

  const layouts: BlockLayout[] = [];

  // Calculate block dimensions
  const getBlockDimensions = (
    block: BasicBlock
  ): { width: number; height: number } => {
    const lineHeight = 16;
    const headerHeight = 22;
    const borderHeight = 4;
    const height =
      headerHeight + block.instructions.length * lineHeight + borderHeight;
    const width = 380;
    return { width, height };
  };

  // Extract start address from block ID (format: "block_0x...")
  const getBlockAddress = (block: BasicBlock): bigint => {
    const match = block.id.match(/block_(0x[0-9a-fA-F]+)/);
    if (match) {
      return BigInt(match[1]);
    }
    // Fallback: try to get from first instruction's address
    if (block.instructions.length > 0) {
      const addr = block.instructions[0].address;
      if (addr && addr.startsWith("0x")) {
        return BigInt(addr);
      }
    }
    return BigInt(0);
  };

  // Build adjacency info
  const blockMap = new Map<string, BasicBlock>();
  blocks.forEach((b) => blockMap.set(b.id, b));

  const blockDimensions = new Map<string, { width: number; height: number }>();
  blocks.forEach((block) => {
    blockDimensions.set(block.id, getBlockDimensions(block));
  });

  // Get block addresses for sorting
  const blockAddresses = new Map<string, bigint>();
  blocks.forEach((block) => {
    blockAddresses.set(block.id, getBlockAddress(block));
  });

  // Sort blocks by address
  const sortedByAddress = [...blocks].sort((a, b) => {
    const addrA = blockAddresses.get(a.id)!;
    const addrB = blockAddresses.get(b.id)!;
    if (addrA < addrB) return -1;
    if (addrA > addrB) return 1;
    return 0;
  });

  // Create address rank (0, 1, 2, ... based on address order)
  const addressRank = new Map<string, number>();
  sortedByAddress.forEach((block, index) => {
    addressRank.set(block.id, index);
  });

  // Find entry block
  const entryBlock = blocks.find((b) => b.isEntry);
  if (!entryBlock) return [];

  // Build predecessors map
  const predecessors = new Map<string, string[]>();
  blocks.forEach((b) => predecessors.set(b.id, []));
  blocks.forEach((block) => {
    for (const succ of block.successors) {
      if (predecessors.has(succ)) {
        predecessors.get(succ)!.push(block.id);
      }
    }
  });

  // ========================================
  // Assign levels based on address order + CFG structure
  // ========================================
  // Use a hybrid approach:
  // 1. BFS from entry to determine reachability and basic structure
  // 2. Adjust levels based on address to ensure address-order consistency

  const levels = new Map<string, number>();
  const visited = new Set<string>();

  // First pass: BFS to get basic structure
  const bfsLevels = new Map<string, number>();
  const queue: { id: string; level: number }[] = [
    { id: entryBlock.id, level: 0 },
  ];
  bfsLevels.set(entryBlock.id, 0);

  while (queue.length > 0) {
    const { id, level } = queue.shift()!;
    if (visited.has(id)) continue;
    visited.add(id);

    const block = blockMap.get(id);
    if (!block) continue;

    for (const successorId of block.successors) {
      if (!blockMap.has(successorId)) continue;
      if (bfsLevels.get(successorId) === undefined) {
        bfsLevels.set(successorId, level + 1);
        queue.push({ id: successorId, level: level + 1 });
      }
    }
  }

  // Second pass: Adjust levels to respect address order
  // Blocks with higher addresses should generally be at higher or equal levels
  // Entry block is always level 0
  levels.set(entryBlock.id, 0);

  // Process blocks in address order (excluding entry)
  for (const block of sortedByAddress) {
    if (block.id === entryBlock.id) continue;

    const myRank = addressRank.get(block.id)!;
    const preds = predecessors.get(block.id) || [];

    // Find the maximum level among predecessors that have lower addresses
    // (forward edges in address space)
    let maxPredLevel = -1;
    let hasForwardPred = false;

    for (const predId of preds) {
      const predRank = addressRank.get(predId)!;
      const predLevel = levels.get(predId);

      if (predLevel !== undefined) {
        if (predRank < myRank) {
          // Forward edge (predecessor has lower address)
          maxPredLevel = Math.max(maxPredLevel, predLevel);
          hasForwardPred = true;
        } else {
          // Back edge (predecessor has higher address) - this is a loop
          // Still consider it but don't require level > predLevel
          maxPredLevel = Math.max(maxPredLevel, predLevel);
        }
      }
    }

    if (maxPredLevel >= 0) {
      // Place at level after the highest predecessor
      // But for back edges (loop targets), we can be at same or lower level
      if (hasForwardPred) {
        levels.set(block.id, maxPredLevel + 1);
      } else {
        // Only back edges - use BFS level as hint
        const bfsLevel = bfsLevels.get(block.id) ?? 1;
        levels.set(block.id, bfsLevel);
      }
    } else {
      // No predecessor with assigned level yet, use address-based level
      // Estimate level based on relative position in address space
      const bfsLevel = bfsLevels.get(block.id) ?? 1;
      levels.set(block.id, bfsLevel);
    }
  }

  // Group by level
  const levelGroups = new Map<number, BasicBlock[]>();
  blocks.forEach((block) => {
    const level = levels.get(block.id) ?? 0;
    if (!levelGroups.has(level)) {
      levelGroups.set(level, []);
    }
    levelGroups.get(level)!.push(block);
  });

  // Sort blocks within each level by address
  levelGroups.forEach((blocksAtLevel) => {
    blocksAtLevel.sort((a, b) => {
      const addrA = blockAddresses.get(a.id)!;
      const addrB = blockAddresses.get(b.id)!;
      if (addrA < addrB) return -1;
      if (addrA > addrB) return 1;
      return 0;
    });
  });

  const sortedLevels = Array.from(levelGroups.keys()).sort((a, b) => a - b);

  // Build tree structure for layout
  // Each block tracks its subtree width
  const subtreeWidth = new Map<string, number>();
  const horizontalGap = 60;
  const verticalGap = 100;

  // Track which blocks are "owned" by which parent for layout purposes
  // A block is owned by its first (leftmost) parent to avoid double-counting at merge points
  const layoutParent = new Map<string, string>();

  // Determine layout parent for each block (the parent that "owns" it for width calculation)
  // Use BFS order to assign ownership to the first parent encountered
  const assignLayoutParents = () => {
    const visited = new Set<string>();
    const queue = [entryBlock.id];
    visited.add(entryBlock.id);

    while (queue.length > 0) {
      const blockId = queue.shift()!;
      const block = blockMap.get(blockId);
      if (!block) continue;

      const myLevel = levels.get(blockId) ?? 0;
      const children = block.successors.filter((sid) => {
        const childLevel = levels.get(sid);
        return (
          childLevel !== undefined && childLevel > myLevel && blockMap.has(sid)
        );
      });

      for (const childId of children) {
        if (!layoutParent.has(childId)) {
          layoutParent.set(childId, blockId);
        }
        if (!visited.has(childId)) {
          visited.add(childId);
          queue.push(childId);
        }
      }
    }
  };

  assignLayoutParents();

  // Calculate subtree widths bottom-up, only counting children owned by this parent
  const calcSubtreeWidth = (
    blockId: string,
    visitedCalc: Set<string>
  ): number => {
    if (visitedCalc.has(blockId)) return 0;
    visitedCalc.add(blockId);

    const block = blockMap.get(blockId);
    if (!block) return 0;

    const dim = blockDimensions.get(blockId)!;

    // Get children that this block "owns" (are assigned to this parent)
    const myLevel = levels.get(blockId) ?? 0;
    const ownedChildren = block.successors.filter((sid) => {
      const childLevel = levels.get(sid);
      return (
        childLevel !== undefined &&
        childLevel > myLevel &&
        blockMap.has(sid) &&
        layoutParent.get(sid) === blockId // Only count if we're the layout parent
      );
    });

    if (ownedChildren.length === 0) {
      subtreeWidth.set(blockId, dim.width);
      return dim.width;
    }

    // Sum of owned children subtree widths + gaps
    let totalChildWidth = 0;
    for (const childId of ownedChildren) {
      totalChildWidth += calcSubtreeWidth(childId, visitedCalc);
    }
    totalChildWidth += Math.max(0, (ownedChildren.length - 1) * horizontalGap);

    const width = Math.max(dim.width, totalChildWidth);
    subtreeWidth.set(blockId, width);
    return width;
  };

  calcSubtreeWidth(entryBlock.id, new Set());

  // Ensure all blocks have a subtree width
  blocks.forEach((b) => {
    if (!subtreeWidth.has(b.id)) {
      subtreeWidth.set(b.id, blockDimensions.get(b.id)!.width);
    }
  });

  // Position blocks
  const blockPositions = new Map<string, { x: number; y: number }>();

  // Calculate Y positions for each level
  const levelY = new Map<number, number>();
  let currentY = 50;
  for (const level of sortedLevels) {
    levelY.set(level, currentY);
    const blocksAtLevel = levelGroups.get(level)!;
    const maxHeight = Math.max(
      ...blocksAtLevel.map((b) => blockDimensions.get(b.id)!.height)
    );
    currentY += maxHeight + verticalGap;
  }

  // Position blocks using DFS, centering owned children under parent
  const positionBlock = (
    blockId: string,
    centerX: number,
    visitedPos: Set<string>
  ) => {
    if (visitedPos.has(blockId)) return;
    visitedPos.add(blockId);

    const block = blockMap.get(blockId);
    if (!block) return;

    const dim = blockDimensions.get(blockId)!;
    const level = levels.get(blockId) ?? 0;
    const y = levelY.get(level) ?? 0;

    // Position this block centered at centerX
    const x = centerX - dim.width / 2;
    blockPositions.set(blockId, { x, y });

    // Get only the children that this block owns (for positioning)
    const myLevel = levels.get(blockId) ?? 0;
    const ownedChildren = block.successors.filter((sid) => {
      const childLevel = levels.get(sid);
      return (
        childLevel !== undefined &&
        childLevel > myLevel &&
        blockMap.has(sid) &&
        layoutParent.get(sid) === blockId
      );
    });

    if (ownedChildren.length === 0) return;

    // Sort children: true branch left, false branch right, unconditional center
    const sortedChildren = [...ownedChildren].sort((a, b) => {
      const edgeA = edges.find((e) => e.from === blockId && e.to === a);
      const edgeB = edges.find((e) => e.from === blockId && e.to === b);
      const orderA =
        edgeA?.type === "conditional-true"
          ? 0
          : edgeA?.type === "unconditional"
            ? 1
            : 2;
      const orderB =
        edgeB?.type === "conditional-true"
          ? 0
          : edgeB?.type === "unconditional"
            ? 1
            : 2;
      return orderA - orderB;
    });

    // Calculate total width needed for owned children
    let totalChildWidth = 0;
    for (const childId of sortedChildren) {
      totalChildWidth +=
        subtreeWidth.get(childId) || blockDimensions.get(childId)!.width;
    }
    totalChildWidth += Math.max(0, (sortedChildren.length - 1) * horizontalGap);

    // Position children
    let childX = centerX - totalChildWidth / 2;
    for (const childId of sortedChildren) {
      const childSubtreeWidth =
        subtreeWidth.get(childId) || blockDimensions.get(childId)!.width;
      const childCenterX = childX + childSubtreeWidth / 2;
      positionBlock(childId, childCenterX, visitedPos);
      childX += childSubtreeWidth + horizontalGap;
    }
  };

  // Start positioning from entry block
  const entrySubtreeWidth =
    subtreeWidth.get(entryBlock.id) ||
    blockDimensions.get(entryBlock.id)!.width;
  positionBlock(entryBlock.id, entrySubtreeWidth / 2 + 50, new Set());

  // Handle any unpositioned blocks (disconnected or only reachable via back edges)
  blocks.forEach((block) => {
    if (!blockPositions.has(block.id)) {
      const level = levels.get(block.id) ?? 0;
      const y = levelY.get(level) ?? 0;
      // Find rightmost block at this level
      let maxX = 0;
      blockPositions.forEach((pos, id) => {
        if (levels.get(id) === level) {
          const d = blockDimensions.get(id)!;
          maxX = Math.max(maxX, pos.x + d.width);
        }
      });
      blockPositions.set(block.id, { x: maxX + horizontalGap, y });
    }
  });

  // Resolve overlaps at each level
  for (const level of sortedLevels) {
    const blocksAtLevel = levelGroups.get(level)!;
    const sortedByX = blocksAtLevel
      .filter((b) => blockPositions.has(b.id))
      .sort(
        (a, b) => blockPositions.get(a.id)!.x - blockPositions.get(b.id)!.x
      );

    for (let i = 1; i < sortedByX.length; i++) {
      const prev = sortedByX[i - 1];
      const curr = sortedByX[i];
      const prevPos = blockPositions.get(prev.id)!;
      const currPos = blockPositions.get(curr.id)!;
      const prevDim = blockDimensions.get(prev.id)!;

      const minX = prevPos.x + prevDim.width + horizontalGap;
      if (currPos.x < minX) {
        currPos.x = minX;
      }
    }
  }

  // Find the overall graph width to use as reference for centering
  let graphMinX = Infinity;
  let graphMaxX = -Infinity;
  blockPositions.forEach((pos, id) => {
    const dim = blockDimensions.get(id)!;
    graphMinX = Math.min(graphMinX, pos.x);
    graphMaxX = Math.max(graphMaxX, pos.x + dim.width);
  });
  const graphCenterX = (graphMinX + graphMaxX) / 2;

  // Center all blocks at each level
  for (const level of sortedLevels) {
    const blocksAtLevel = levelGroups.get(level)!;

    const sortedByX = blocksAtLevel
      .filter((b) => blockPositions.has(b.id))
      .sort(
        (a, b) => blockPositions.get(a.id)!.x - blockPositions.get(b.id)!.x
      );

    if (sortedByX.length === 0) continue;

    // Calculate current level width
    const firstBlock = sortedByX[0];
    const lastBlock = sortedByX[sortedByX.length - 1];
    const firstPos = blockPositions.get(firstBlock.id)!;
    const lastPos = blockPositions.get(lastBlock.id)!;
    const lastDim = blockDimensions.get(lastBlock.id)!;
    const levelWidth = lastPos.x + lastDim.width - firstPos.x;
    const levelCenterX = firstPos.x + levelWidth / 2;

    // Calculate offset to center this level
    const offset = graphCenterX - levelCenterX;

    // Apply offset to all blocks at this level
    for (const block of sortedByX) {
      const pos = blockPositions.get(block.id);
      if (pos) {
        pos.x += offset;
      }
    }
  }

  // Create layouts
  blocks.forEach((block) => {
    const pos = blockPositions.get(block.id);
    const dim = blockDimensions.get(block.id);
    if (pos && dim) {
      layouts.push({
        id: block.id,
        x: pos.x,
        y: pos.y,
        width: dim.width,
        height: dim.height,
      });
    }
  });

  return layouts;
};

// Format function name for title (e.g., "libc.so@open64")
const formatTitleFunctionName = (functionName: string): string => {
  if (!functionName) return "";
  // Already in the format we want (module@function) or just return as-is
  // Extract just module@function part if there's an offset
  const plusIndex = functionName.indexOf(" + ");
  if (plusIndex > 0) {
    return functionName.substring(0, plusIndex);
  }
  return functionName;
};

export const GraphViewPage: React.FC = () => {
  const [searchParams] = useSearchParams();
  const address = searchParams.get("address") || "";

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [blocks, setBlocks] = useState<BasicBlock[]>([]);
  const [edges, setEdges] = useState<Edge[]>([]);
  const [layouts, setLayouts] = useState<BlockLayout[]>([]);
  const [functionName, setFunctionName] = useState<string>("");
  const [startAddress, setStartAddress] = useState<string>("");
  const [endAddress, setEndAddress] = useState<string>("");

  // CFG source mode: "dynamic" (from DynaDbg) or "ghidra" (from Ghidra analysis)
  const [cfgMode, setCfgMode] = useState<CfgSourceMode>("dynamic");
  const [ghidraAvailable, setGhidraAvailable] = useState(false);
  const [libraryPath, setLibraryPath] = useState<string>("");
  const [functionOffset, setFunctionOffset] = useState<string>("");
  const [, setLoadingGhidra] = useState(false);
  const [ghidraProjectPath, setGhidraProjectPath] = useState<string>("");

  // Reachability analysis state
  const [reachabilityEnabled, setReachabilityEnabled] = useState(false);
  const [, setReachabilityLoading] = useState(false);
  const [blockReachability, setBlockReachability] = useState<
    Map<string, BlockReachability>
  >(new Map());
  const [ghidraPath, setGhidraPath] = useState<string>("");
  const [serverUrl, setServerUrl] = useState<string>(""); // dbgsrv URL for Z3 analysis
  const [breakpointRegisters, setBreakpointRegisters] = useState<
    Record<string, string>
  >({}); // Registers at breakpoint
  const [libraryBaseAddress, setLibraryBaseAddress] = useState<string>(""); // Library base address for offset calculation

  // Exception store hook for getting breakpoint registers
  const { getExceptions } = useTauriExceptionStore();

  // Ghidra analysis hook
  const { getAnalyzedLibraryInfo, checkGhidraServer, analyzeReachability } =
    useGhidraAnalysis();

  // System state hook for auth token
  const { state: tauriState } = useTauriSystemState();

  // Pan and zoom state - initial zoom at 30% for overview
  const initialZoom = 0.3;
  const [pan, setPan] = useState({ x: 0, y: 0 });
  const [zoom, setZoom] = useState(initialZoom);
  const [isPanning, setIsPanning] = useState(false);
  const [panStart, setPanStart] = useState({ x: 0, y: 0 });

  // Block dragging state
  const [draggingBlock, setDraggingBlock] = useState<string | null>(null);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
  const [dragBlockStart, setDragBlockStart] = useState({ x: 0, y: 0 });

  const canvasRef = useRef<HTMLDivElement>(null);
  const svgRef = useRef<SVGSVGElement>(null);

  // Load CFG from Tauri store
  const loadCFG = useCallback(async () => {
    if (!address) {
      setError("No address specified");
      setLoading(false);
      return;
    }

    setLoading(true);
    setError(null);

    try {
      // Get graph view data from Tauri store
      const storedData = await invoke<GraphViewStoredData | null>(
        "get_graph_view_data",
        {
          address,
        }
      );

      if (!storedData) {
        throw new Error(
          "No graph view data found. Please open graph view from the assembly view."
        );
      }

      setFunctionName(storedData.function_name);
      setStartAddress(storedData.function_start_address);
      setEndAddress(storedData.function_end_address);

      // Set server URL for Z3 reachability analysis
      if (storedData.server_url) {
        setServerUrl(storedData.server_url);
        console.log(`[GraphView] Server URL: ${storedData.server_url}`);
      }

      // Load breakpoint registers if available
      if (storedData.breakpoint_registers) {
        setBreakpointRegisters(storedData.breakpoint_registers);
        console.log(
          `[GraphView] Loaded breakpoint registers:`,
          Object.keys(storedData.breakpoint_registers).length,
          "registers"
        );
      } else {
        // Try to get latest breakpoint exception for registers
        try {
          const exceptions = await getExceptions(["breakpoint"], 1);
          if (exceptions.length > 0 && exceptions[0].registers) {
            const regs: Record<string, string> = {};
            const ex = exceptions[0];
            // Extract register values from exception
            for (let i = 0; i <= 29; i++) {
              const regName = `x${i}`;
              const val =
                (ex as any)[regName] ?? (ex.registers as any)?.[regName];
              if (val !== undefined) {
                regs[regName] =
                  typeof val === "number"
                    ? `0x${val.toString(16)}`
                    : String(val);
              }
            }
            ["lr", "fp", "sp", "pc", "cpsr"].forEach((regName) => {
              const val =
                (ex as any)[regName] ?? (ex.registers as any)?.[regName];
              if (val !== undefined) {
                regs[regName] =
                  typeof val === "number"
                    ? `0x${val.toString(16)}`
                    : String(val);
              }
            });
            setBreakpointRegisters(regs);
            console.log(
              `[GraphView] Loaded registers from latest breakpoint:`,
              Object.keys(regs).length,
              "registers"
            );
          }
        } catch (e) {
          console.log(`[GraphView] Failed to get breakpoint registers:`, e);
        }
      }

      // Load library base address if available
      if (storedData.library_base_address) {
        setLibraryBaseAddress(storedData.library_base_address);
        console.log(
          `[GraphView] Library base address: ${storedData.library_base_address}`
        );
      }

      // Check if Ghidra mode is available
      if (storedData.library_path && storedData.function_offset) {
        setLibraryPath(storedData.library_path);
        setFunctionOffset(storedData.function_offset);
        console.log(
          `[GraphView] Ghidra info: library_path=${storedData.library_path}, function_offset=${storedData.function_offset}`
        );

        const libInfo = getAnalyzedLibraryInfo(storedData.library_path);
        console.log(`[GraphView] libInfo=`, libInfo);

        if (libInfo) {
          // Check if Ghidra server is running for this project
          setGhidraProjectPath(libInfo.projectPath);

          // Get Ghidra path from localStorage for reachability analysis
          // Key must match GhidraAnalyzer.tsx: "dynadbg_ghidra_path"
          try {
            const savedGhidraPath = localStorage.getItem("dynadbg_ghidra_path");
            if (savedGhidraPath) {
              setGhidraPath(savedGhidraPath);
              console.log(
                `[GraphView] Loaded Ghidra path from localStorage:`,
                savedGhidraPath
              );
            } else {
              console.log(`[GraphView] No Ghidra path found in localStorage`);
            }
          } catch (e) {
            console.log(
              `[GraphView] Failed to get Ghidra path from localStorage:`,
              e
            );
          }

          try {
            const serverPort = await checkGhidraServer(libInfo.projectPath);
            console.log(`[GraphView] Ghidra server port:`, serverPort);
            if (serverPort !== null) {
              console.log(`[GraphView] Ghidra mode available`);
              setGhidraAvailable(true);
            } else {
              console.log(`[GraphView] Ghidra server not running for project`);
            }
          } catch (e) {
            console.log(`[GraphView] Failed to check Ghidra server:`, e);
          }
        } else {
          console.log(
            `[GraphView] Library not analyzed: ${storedData.library_path}`
          );
        }
      } else {
        console.log(
          `[GraphView] No Ghidra info in storedData: library_path=${storedData.library_path}, function_offset=${storedData.function_offset}`
        );
      }

      // Parse instructions from JSON string
      const instructions: Instruction[] = JSON.parse(storedData.instructions);

      if (instructions.length === 0) {
        throw new Error("No instructions found in function range");
      }

      console.log(
        `[GraphView] Loaded ${instructions.length} instructions for ${address}`
      );

      // Build CFG from instructions
      const { blocks: cfgBlocks, edges: cfgEdges } = buildCFG(instructions);

      // Find blocks reachable from entry block using BFS
      const entryBlock = cfgBlocks.find((b) => b.isEntry);
      const reachableBlockIds = new Set<string>();

      if (entryBlock) {
        const queue: string[] = [entryBlock.id];
        reachableBlockIds.add(entryBlock.id);

        while (queue.length > 0) {
          const currentId = queue.shift()!;
          const currentBlock = cfgBlocks.find((b) => b.id === currentId);

          if (currentBlock) {
            // Add all successors to the queue if not already visited
            for (const successorId of currentBlock.successors) {
              if (!reachableBlockIds.has(successorId)) {
                reachableBlockIds.add(successorId);
                queue.push(successorId);
              }
            }
          }
        }
      }

      // Filter to only include blocks reachable from entry
      const reachableBlocks = cfgBlocks.filter((block) =>
        reachableBlockIds.has(block.id)
      );

      // Also filter edges to only include edges between reachable blocks
      const reachableEdges = cfgEdges.filter(
        (edge) =>
          reachableBlockIds.has(edge.from) && reachableBlockIds.has(edge.to)
      );

      console.log(
        `[GraphView] Filtered ${cfgBlocks.length - reachableBlocks.length} unreachable blocks`
      );

      const blockLayouts = layoutBlocks(reachableBlocks, reachableEdges);

      // Calculate initial pan to focus on entry block
      const entryBlockForLayout = reachableBlocks.find((b) => b.isEntry);
      const entryLayout = entryBlockForLayout
        ? blockLayouts.find((l) => l.id === entryBlockForLayout.id)
        : null;

      if (entryLayout) {
        // Get canvas size (use default if not available yet)
        const canvas = canvasRef.current;
        const canvasWidth = canvas?.clientWidth || 800;

        // Center the entry block horizontally and position it near the top
        const blockCenterX = entryLayout.x + entryLayout.width / 2;
        const blockTopY = entryLayout.y;

        const newPanX = canvasWidth / 2 - blockCenterX * initialZoom;
        const newPanY = 80 - blockTopY * initialZoom;

        setPan({ x: newPanX, y: newPanY });
      } else {
        setPan({ x: 50, y: 50 });
      }

      setBlocks(reachableBlocks);
      setEdges(reachableEdges);
      setLayouts(blockLayouts);
    } catch (err) {
      console.error("Failed to load CFG:", err);
      setError(err instanceof Error ? err.message : "Unknown error");
    } finally {
      setLoading(false);
    }
  }, [address, getAnalyzedLibraryInfo, checkGhidraServer]);

  // Load CFG from Ghidra analysis
  const loadGhidraCFG = useCallback(async () => {
    if (!libraryPath || !functionOffset || !ghidraProjectPath) {
      setError(
        "Ghidra CFG requires library path, function offset, and project path"
      );
      return;
    }

    setLoadingGhidra(true);
    setError(null);

    try {
      console.log(
        `[GraphView] Loading Ghidra CFG for ${functionOffset} in ${libraryPath}, project: ${ghidraProjectPath}`
      );

      // Call Tauri command directly since we're in a separate window
      const cfgResult = await invoke<{
        success: boolean;
        function_name: string | null;
        function_offset: string | null;
        blocks: GhidraCfgBlock[];
        edges: GhidraCfgEdge[];
        error: string | null;
      }>("ghidra_server_cfg", {
        projectPath: ghidraProjectPath,
        functionAddress: functionOffset,
      });

      if (!cfgResult || !cfgResult.success) {
        throw new Error(cfgResult?.error || "Failed to get CFG from Ghidra");
      }

      console.log(
        `[GraphView] Ghidra CFG: ${cfgResult.blocks.length} blocks, ${cfgResult.edges.length} edges`
      );

      // Convert Ghidra CFG blocks to BasicBlock format
      const ghidraBlocks: BasicBlock[] = cfgResult.blocks.map(
        (ghBlock: GhidraCfgBlock) => ({
          id: ghBlock.id,
          startAddress: ghBlock.startAddress,
          endAddress: ghBlock.endAddress,
          instructions: ghBlock.instructions.map((instr) => ({
            address: instr.address,
            bytes: instr.bytes,
            opcode: instr.opcode,
            operands: instr.operands,
          })),
          successors: ghBlock.successors,
          predecessors: ghBlock.predecessors,
          isEntry: ghBlock.isEntry,
          isExit: ghBlock.isExit,
        })
      );

      // Convert Ghidra edges to Edge format
      const ghidraEdges: Edge[] = cfgResult.edges.map(
        (ghEdge: GhidraCfgEdge) => ({
          from: ghEdge.from,
          to: ghEdge.to,
          type: ghEdge.type as Edge["type"],
        })
      );

      // Find blocks reachable from entry block using BFS
      const entryBlock = ghidraBlocks.find((b) => b.isEntry);
      const reachableBlockIds = new Set<string>();

      if (entryBlock) {
        const queue: string[] = [entryBlock.id];
        reachableBlockIds.add(entryBlock.id);

        while (queue.length > 0) {
          const currentId = queue.shift()!;
          const currentBlock = ghidraBlocks.find((b) => b.id === currentId);

          if (currentBlock) {
            for (const successorId of currentBlock.successors) {
              if (!reachableBlockIds.has(successorId)) {
                reachableBlockIds.add(successorId);
                queue.push(successorId);
              }
            }
          }
        }
      }

      // Filter to only include blocks reachable from entry
      const reachableBlocks = ghidraBlocks.filter((block) =>
        reachableBlockIds.has(block.id)
      );

      const reachableEdges = ghidraEdges.filter(
        (edge) =>
          reachableBlockIds.has(edge.from) && reachableBlockIds.has(edge.to)
      );

      console.log(
        `[GraphView] Ghidra CFG: Filtered to ${reachableBlocks.length} reachable blocks`
      );

      const blockLayouts = layoutBlocks(reachableBlocks, reachableEdges);

      // Calculate initial pan to focus on entry block
      const entryBlockForLayout = reachableBlocks.find((b) => b.isEntry);
      const entryLayout = entryBlockForLayout
        ? blockLayouts.find((l) => l.id === entryBlockForLayout.id)
        : null;

      if (entryLayout) {
        const canvas = canvasRef.current;
        const canvasWidth = canvas?.clientWidth || 800;
        const blockCenterX = entryLayout.x + entryLayout.width / 2;
        const blockTopY = entryLayout.y;
        const newPanX = canvasWidth / 2 - blockCenterX * initialZoom;
        const newPanY = 80 - blockTopY * initialZoom;
        setPan({ x: newPanX, y: newPanY });
      } else {
        setPan({ x: 50, y: 50 });
      }

      if (cfgResult.function_name) {
        setFunctionName(cfgResult.function_name);
      }

      setBlocks(reachableBlocks);
      setEdges(reachableEdges);
      setLayouts(blockLayouts);
    } catch (err) {
      console.error("Failed to load Ghidra CFG:", err);
      setError(err instanceof Error ? err.message : "Unknown error");
    } finally {
      setLoadingGhidra(false);
    }
  }, [libraryPath, functionOffset, ghidraProjectPath, initialZoom]);

  // Handle mode change (unused - CFG source toggle hidden)
  // @ts-expect-error Unused function kept for future use
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const _handleModeChange = useCallback(
    (_event: React.MouseEvent<HTMLElement>, newMode: CfgSourceMode | null) => {
      if (newMode && newMode !== cfgMode) {
        setCfgMode(newMode);
        if (newMode === "ghidra") {
          loadGhidraCFG();
        } else {
          loadCFG();
        }
      }
    },
    [cfgMode, loadGhidraCFG, loadCFG]
  );

  // Analyze block reachability using Z3
  const runReachabilityAnalysis = useCallback(async () => {
    if (!ghidraAvailable || !libraryPath || !functionOffset) {
      console.log(
        "[GraphView] Reachability analysis not available - missing Ghidra info"
      );
      return;
    }

    if (!ghidraPath) {
      console.error(
        "[GraphView] Ghidra path not set - cannot run reachability analysis"
      );
      return;
    }

    if (!serverUrl) {
      console.error(
        "[GraphView] Server URL not set - cannot run reachability analysis"
      );
      return;
    }

    // Find entry block or first block as "current" block
    const entryBlock = blocks.find((b) => b.isEntry) || blocks[0];
    if (!entryBlock) {
      console.log("[GraphView] No blocks available for reachability analysis");
      return;
    }

    const currentBlockOffset = entryBlock.startAddress;

    // Check for auth token
    const authToken = tauriState?.authToken;
    if (!authToken) {
      console.error(
        "[GraphView] No auth token available - cannot run reachability analysis"
      );
      return;
    }

    setReachabilityLoading(true);
    try {
      console.log(
        `[GraphView] Running reachability analysis from block ${currentBlockOffset}`
      );
      console.log(`[GraphView] dbgsrv URL: ${serverUrl}`);
      console.log(`[GraphView] Library base address: ${libraryBaseAddress}`);
      console.log(
        `[GraphView] Registers count: ${Object.keys(breakpointRegisters).length}`
      );

      // Convert registers to JSON string
      const registersJson = JSON.stringify(breakpointRegisters);

      const result = await analyzeReachability(
        libraryPath,
        functionOffset,
        currentBlockOffset,
        serverUrl,
        authToken,
        ghidraPath,
        registersJson,
        libraryBaseAddress
      );

      if (result.success && result.blocks) {
        // Build reachability map by block ID
        const reachMap = new Map<string, BlockReachability>();
        for (const br of result.blocks) {
          reachMap.set(br.blockId, br);
        }
        setBlockReachability(reachMap);
        setReachabilityEnabled(true);
        console.log(
          `[GraphView] Reachability analysis complete: ${result.blocks.length} blocks analyzed`
        );
      } else {
        console.error(
          "[GraphView] Reachability analysis failed:",
          result.error
        );
      }
    } catch (err) {
      console.error("[GraphView] Reachability analysis error:", err);
    } finally {
      setReachabilityLoading(false);
    }
  }, [
    ghidraAvailable,
    libraryPath,
    functionOffset,
    blocks,
    analyzeReachability,
    ghidraPath,
    serverUrl,
    tauriState?.authToken,
    breakpointRegisters,
    libraryBaseAddress,
  ]);

  // Toggle reachability display (unused - Z3 reachability hidden)
  // @ts-expect-error Unused function kept for future use
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const _toggleReachability = useCallback(() => {
    if (reachabilityEnabled) {
      setReachabilityEnabled(false);
      setBlockReachability(new Map());
    } else {
      runReachabilityAnalysis();
    }
  }, [reachabilityEnabled, runReachabilityAnalysis]);

  // Get block border color based on reachability status
  const getBlockBorderColor = useCallback(
    (block: BasicBlock): string => {
      if (!reachabilityEnabled) {
        // Default coloring
        if (block.isEntry) return "#4caf50";
        if (block.isExit) return "#ff5722";
        return "#3c3c3c";
      }

      const reachability = blockReachability.get(block.id);
      if (!reachability) {
        return "#3c3c3c"; // Unknown
      }

      switch (reachability.status) {
        case "current":
          return "#2196f3"; // Blue for current block
        case "reachable":
          return "#4caf50"; // Green for reachable
        case "unreachable":
          return "#f44336"; // Red for unreachable
        case "conditional":
          return "#ff9800"; // Orange for conditional
        default:
          return "#9e9e9e"; // Gray for unknown
      }
    },
    [reachabilityEnabled, blockReachability]
  );

  // Get block header background based on reachability
  const getBlockHeaderBg = useCallback(
    (block: BasicBlock): string => {
      if (!reachabilityEnabled) {
        if (block.isEntry) return alpha("#4caf50", 0.2);
        if (block.isExit) return alpha("#ff5722", 0.2);
        return "#1a1a1a";
      }

      const reachability = blockReachability.get(block.id);
      if (!reachability) return "#1a1a1a";

      switch (reachability.status) {
        case "current":
          return alpha("#2196f3", 0.2);
        case "reachable":
          return alpha("#4caf50", 0.2);
        case "unreachable":
          return alpha("#f44336", 0.2);
        case "conditional":
          return alpha("#ff9800", 0.2);
        default:
          return "#1a1a1a";
      }
    },
    [reachabilityEnabled, blockReachability]
  );

  useEffect(() => {
    loadCFG();
  }, [loadCFG]);

  // Canvas pan handlers (when not dragging a block)
  const handleCanvasMouseDown = useCallback(
    (e: React.MouseEvent) => {
      // Only start panning if clicking on canvas (not on a block)
      if (e.button === 0 && !draggingBlock) {
        setIsPanning(true);
        setPanStart({ x: e.clientX - pan.x, y: e.clientY - pan.y });
      }
    },
    [pan, draggingBlock]
  );

  const handleCanvasMouseMove = useCallback(
    (e: React.MouseEvent) => {
      if (draggingBlock) {
        // Dragging a block
        const deltaX = (e.clientX - dragStart.x) / zoom;
        const deltaY = (e.clientY - dragStart.y) / zoom;

        setLayouts((prevLayouts) =>
          prevLayouts.map((layout) =>
            layout.id === draggingBlock
              ? {
                  ...layout,
                  x: dragBlockStart.x + deltaX,
                  y: dragBlockStart.y + deltaY,
                }
              : layout
          )
        );
      } else if (isPanning) {
        // Panning the canvas
        setPan({
          x: e.clientX - panStart.x,
          y: e.clientY - panStart.y,
        });
      }
    },
    [draggingBlock, dragStart, dragBlockStart, zoom, isPanning, panStart]
  );

  const handleCanvasMouseUp = useCallback(() => {
    setIsPanning(false);
    setDraggingBlock(null);
  }, []);

  // Block drag handlers
  const handleBlockMouseDown = useCallback(
    (blockId: string, e: React.MouseEvent) => {
      e.stopPropagation();
      if (e.button === 0) {
        const layout = layouts.find((l) => l.id === blockId);
        if (layout) {
          setDraggingBlock(blockId);
          setDragStart({ x: e.clientX, y: e.clientY });
          setDragBlockStart({ x: layout.x, y: layout.y });
        }
      }
    },
    [layouts]
  );

  // Zoom handlers - zoom centered on mouse position
  const handleWheel = useCallback(
    (e: React.WheelEvent) => {
      e.preventDefault();

      const canvas = canvasRef.current;
      if (!canvas) return;

      // Get mouse position relative to canvas
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // Calculate graph position under mouse before zoom
      const graphX = (mouseX - pan.x) / zoom;
      const graphY = (mouseY - pan.y) / zoom;

      // Calculate new zoom
      const delta = e.deltaY > 0 ? 1.1 : 0.9;
      const newZoom = Math.min(Math.max(zoom * delta, 0.05), 3);

      // Calculate new pan to keep mouse position fixed
      const newPanX = mouseX - graphX * newZoom;
      const newPanY = mouseY - graphY * newZoom;

      setZoom(newZoom);
      setPan({ x: newPanX, y: newPanY });
    },
    [zoom, pan]
  );

  // Toolbar zoom buttons - zoom centered on canvas center
  const handleZoomIn = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) {
      setZoom((prev) => Math.min(prev * 1.2, 3));
      return;
    }

    const centerX = canvas.clientWidth / 2;
    const centerY = canvas.clientHeight / 2;
    const graphX = (centerX - pan.x) / zoom;
    const graphY = (centerY - pan.y) / zoom;

    const newZoom = Math.min(zoom * 1.2, 3);
    const newPanX = centerX - graphX * newZoom;
    const newPanY = centerY - graphY * newZoom;

    setZoom(newZoom);
    setPan({ x: newPanX, y: newPanY });
  }, [zoom, pan]);

  const handleZoomOut = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) {
      setZoom((prev) => Math.max(prev * 0.8, 0.05));
      return;
    }

    const centerX = canvas.clientWidth / 2;
    const centerY = canvas.clientHeight / 2;
    const graphX = (centerX - pan.x) / zoom;
    const graphY = (centerY - pan.y) / zoom;

    const newZoom = Math.max(zoom * 0.8, 0.05);
    const newPanX = centerX - graphX * newZoom;
    const newPanY = centerY - graphY * newZoom;

    setZoom(newZoom);
    setPan({ x: newPanX, y: newPanY });
  }, [zoom, pan]);

  const handleCenter = useCallback(() => {
    setPan({ x: 0, y: 0 });
    setZoom(1);
  }, []);

  const handleClose = useCallback(async () => {
    const window = getCurrentWebviewWindow();
    await window.close();
  }, []);

  // Calculate graph bounds for minimap
  const graphBounds = React.useMemo(() => {
    if (layouts.length === 0)
      return {
        minX: 0,
        minY: 0,
        maxX: 1000,
        maxY: 1000,
        width: 1000,
        height: 1000,
      };

    let minX = Infinity,
      minY = Infinity,
      maxX = -Infinity,
      maxY = -Infinity;
    layouts.forEach((layout) => {
      minX = Math.min(minX, layout.x);
      minY = Math.min(minY, layout.y);
      maxX = Math.max(maxX, layout.x + layout.width);
      maxY = Math.max(maxY, layout.y + layout.height);
    });

    // Add padding
    const padding = 50;
    minX -= padding;
    minY -= padding;
    maxX += padding;
    maxY += padding;

    return { minX, minY, maxX, maxY, width: maxX - minX, height: maxY - minY };
  }, [layouts]);

  // Minimap dimensions
  const minimapWidth = 200;
  const minimapHeight = 150;

  // Calculate minimap scale and offset to center the graph
  const minimapScale = React.useMemo(() => {
    const scaleX = minimapWidth / graphBounds.width;
    const scaleY = minimapHeight / graphBounds.height;
    return Math.min(scaleX, scaleY);
  }, [graphBounds]);

  // Calculate offset to center graph in minimap
  const minimapOffset = React.useMemo(() => {
    const scaledWidth = graphBounds.width * minimapScale;
    const scaledHeight = graphBounds.height * minimapScale;
    return {
      x: (minimapWidth - scaledWidth) / 2,
      y: (minimapHeight - scaledHeight) / 2,
    };
  }, [graphBounds, minimapScale]);

  // Handle minimap click to navigate
  const handleMinimapClick = useCallback(
    (e: React.MouseEvent<HTMLDivElement>) => {
      const rect = e.currentTarget.getBoundingClientRect();
      const clickX = e.clientX - rect.left - minimapOffset.x;
      const clickY = e.clientY - rect.top - minimapOffset.y;

      // Convert minimap coordinates to graph coordinates
      const graphX = graphBounds.minX + clickX / minimapScale;
      const graphY = graphBounds.minY + clickY / minimapScale;

      // Get canvas size
      const canvas = canvasRef.current;
      if (!canvas) return;
      const canvasWidth = canvas.clientWidth;
      const canvasHeight = canvas.clientHeight;

      // Center the view on the clicked point
      const newPanX = -(graphX * zoom) + canvasWidth / 2;
      const newPanY = -(graphY * zoom) + canvasHeight / 2;

      setPan({ x: newPanX, y: newPanY });
    },
    [graphBounds, minimapScale, minimapOffset, zoom]
  );

  // Calculate viewport rectangle on minimap
  const viewportRect = React.useMemo(() => {
    const canvas = canvasRef.current;
    if (!canvas)
      return { x: 0, y: 0, width: minimapWidth, height: minimapHeight };

    const canvasWidth = canvas.clientWidth || 800;
    const canvasHeight = canvas.clientHeight || 600;

    // Calculate what portion of the graph is visible
    const visibleLeft = -pan.x / zoom;
    const visibleTop = -pan.y / zoom;
    const visibleWidth = canvasWidth / zoom;
    const visibleHeight = canvasHeight / zoom;

    // Convert to minimap coordinates (with offset for centering)
    const x = (visibleLeft - graphBounds.minX) * minimapScale + minimapOffset.x;
    const y = (visibleTop - graphBounds.minY) * minimapScale + minimapOffset.y;
    const width = visibleWidth * minimapScale;
    const height = visibleHeight * minimapScale;

    return { x, y, width, height };
  }, [pan, zoom, graphBounds, minimapScale, minimapOffset]);

  // Render edge path using straight lines with orthogonal routing
  const renderEdgePath = useCallback(
    (edge: Edge, allEdges: Edge[], edgeIndex: number): string => {
      const fromLayout = layouts.find((l) => l.id === edge.from);
      const toLayout = layouts.find((l) => l.id === edge.to);

      if (!fromLayout || !toLayout) return "";

      const margin = 15; // Margin around blocks for collision detection
      const edgeSpacing = 12; // Spacing between parallel edges

      // Helper: Check if a horizontal line segment intersects a specific block
      const horizontalIntersectsBlock = (
        y: number,
        x1: number,
        x2: number,
        block: BlockLayout
      ): boolean => {
        const minX = Math.min(x1, x2);
        const maxX = Math.max(x1, x2);
        // Check if horizontal line passes through block
        return (
          y > block.y - margin &&
          y < block.y + block.height + margin &&
          maxX > block.x - margin &&
          minX < block.x + block.width + margin
        );
      };

      // Helper: Check if a vertical line segment intersects a specific block
      const verticalIntersectsBlock = (
        x: number,
        y1: number,
        y2: number,
        block: BlockLayout
      ): boolean => {
        const minY = Math.min(y1, y2);
        const maxY = Math.max(y1, y2);
        // Check if vertical line passes through block
        return (
          x > block.x - margin &&
          x < block.x + block.width + margin &&
          maxY > block.y - margin &&
          minY < block.y + block.height + margin
        );
      };

      // Get blocks that are potentially in the path between from and to
      // Only consider blocks whose bounding area overlaps with the edge's bounding box
      const getBlocksInPath = (): BlockLayout[] => {
        const minX = Math.min(fromLayout.x, toLayout.x) - margin;
        const maxX =
          Math.max(
            fromLayout.x + fromLayout.width,
            toLayout.x + toLayout.width
          ) + margin;
        const minY = Math.min(fromLayout.y, toLayout.y) - margin;
        const maxY =
          Math.max(
            fromLayout.y + fromLayout.height,
            toLayout.y + toLayout.height
          ) + margin;

        return layouts.filter((layout) => {
          // Skip source and target blocks
          if (layout.id === edge.from || layout.id === edge.to) return false;

          // Check if block overlaps with the bounding box of the edge
          const blockRight = layout.x + layout.width;
          const blockBottom = layout.y + layout.height;

          return !(
            blockRight < minX ||
            layout.x > maxX ||
            blockBottom < minY ||
            layout.y > maxY
          );
        });
      };

      const blocksInPath = getBlocksInPath();

      // Count edges from same source to offset them
      const edgesFromSame = allEdges.filter((e) => e.from === edge.from);
      const indexInSource = edgesFromSame.indexOf(edge);
      const totalFromSource = edgesFromSame.length;

      // Count edges to same target to offset them
      const edgesToSame = allEdges.filter((e) => e.to === edge.to);
      const indexInTarget = edgesToSame.indexOf(edge);
      const totalToTarget = edgesToSame.length;

      // Calculate offset for multiple edges from same source
      const sourceOffset =
        totalFromSource > 1
          ? (indexInSource - (totalFromSource - 1) / 2) * 25
          : 0;

      // Calculate offset for multiple edges to same target
      const targetOffset =
        totalToTarget > 1 ? (indexInTarget - (totalToTarget - 1) / 2) * 25 : 0;

      // Start from bottom of source block (with offset for multiple edges)
      const fromX = fromLayout.x + fromLayout.width / 2 + sourceOffset;
      const fromY = fromLayout.y + fromLayout.height;

      // End at top of target block (with offset for multiple edges)
      const toX = toLayout.x + toLayout.width / 2 + targetOffset;
      const toY = toLayout.y;

      // Use edge index for vertical offset to prevent overlap
      const verticalOffset = edgeIndex * edgeSpacing;

      // Check if going upward (back edge / loop)
      const isBackEdge = toLayout.y <= fromLayout.y;

      if (isBackEdge) {
        // Back edge - route around the side
        // Find the bounding box of blocks involved in the back edge
        const relevantBlocks = [fromLayout, toLayout, ...blocksInPath];
        let minBlockX = Infinity;
        let maxBlockX = -Infinity;
        let minBlockY = Infinity;
        let maxBlockY = -Infinity;
        for (const block of relevantBlocks) {
          minBlockX = Math.min(minBlockX, block.x);
          maxBlockX = Math.max(maxBlockX, block.x + block.width);
          minBlockY = Math.min(minBlockY, block.y);
          maxBlockY = Math.max(maxBlockY, block.y + block.height);
        }

        const outerMargin = 80; // Increased margin for back edges
        const routeRight = fromX > fromLayout.x + fromLayout.width / 2;
        const sideX = routeRight
          ? maxBlockX + outerMargin + verticalOffset
          : minBlockX - outerMargin - verticalOffset;

        const exitY = fromY + margin + 25 + (edgeIndex % 3) * edgeSpacing;
        const entryY = toY - margin - 25 - (edgeIndex % 3) * edgeSpacing;

        return `M ${fromX} ${fromY}
                L ${fromX} ${exitY}
                L ${sideX} ${exitY}
                L ${sideX} ${entryY}
                L ${toX} ${entryY}
                L ${toX} ${toY}`;
      }

      // Normal downward edge - check for collisions only with blocks in path
      if (blocksInPath.length === 0) {
        // No blocks in the way, use simple routing
        if (Math.abs(fromX - toX) < 5) {
          // Nearly vertical
          return `M ${fromX} ${fromY} L ${toX} ${toY}`;
        }
        // Use midpoint routing with offset to prevent overlapping horizontal segments
        const baseMidY = fromY + (toY - fromY) / 2;
        const midY = baseMidY + ((edgeIndex % 5) - 2) * edgeSpacing;
        return `M ${fromX} ${fromY}
                L ${fromX} ${midY}
                L ${toX} ${midY}
                L ${toX} ${toY}`;
      }

      // There are blocks in the path - check for actual collisions
      const baseMidY = fromY + (toY - fromY) / 2;
      const midY = baseMidY + ((edgeIndex % 5) - 2) * edgeSpacing;

      // Check if midpoint routing collides with any block in path
      let hasCollision = false;
      for (const block of blocksInPath) {
        if (
          verticalIntersectsBlock(fromX, fromY, midY, block) ||
          horizontalIntersectsBlock(midY, fromX, toX, block) ||
          verticalIntersectsBlock(toX, midY, toY, block)
        ) {
          hasCollision = true;
          break;
        }
      }

      if (!hasCollision) {
        // Midpoint routing is clear
        return `M ${fromX} ${fromY}
                L ${fromX} ${midY}
                L ${toX} ${midY}
                L ${toX} ${toY}`;
      }

      // Need to route around the blocking blocks
      // Find the extents of blocking blocks
      let minBlockX = Infinity;
      let maxBlockX = -Infinity;
      for (const block of blocksInPath) {
        minBlockX = Math.min(minBlockX, block.x);
        maxBlockX = Math.max(maxBlockX, block.x + block.width);
      }

      // Decide which side to route around
      const leftDistance = Math.min(fromX, toX) - minBlockX;
      const rightDistance = maxBlockX - Math.max(fromX, toX);
      const routeRight = rightDistance < leftDistance;

      const outerMargin = 80; // Increased margin for collision avoidance
      const sideX = routeRight
        ? maxBlockX + outerMargin + verticalOffset
        : minBlockX - outerMargin - verticalOffset;

      // Route: exit from bottom of source block -> side -> entry to target
      // exitY is just below the source block (fromY is already block bottom)
      const exitY = fromY + 15 + (edgeIndex % 3) * edgeSpacing;
      const entryY = toY - 15 - (edgeIndex % 3) * edgeSpacing;

      return `M ${fromX} ${fromY}
              L ${fromX} ${exitY}
              L ${sideX} ${exitY}
              L ${sideX} ${entryY}
              L ${toX} ${entryY}
              L ${toX} ${toY}`;
    },
    [layouts]
  );

  // Edge color based on type
  const getEdgeColor = (type: Edge["type"]): string => {
    switch (type) {
      case "conditional-true":
        return "#4caf50";
      case "conditional-false":
        return "#ff5722";
      case "unconditional":
        return "#4fc1ff";
      default:
        return "#808080";
    }
  };

  // Format title
  const titleText = formatTitleFunctionName(functionName) || address;

  return (
    <ThemeProvider theme={darkTheme}>
      <CssBaseline />
      <WindowContainer>
        <WindowHeader>
          <WindowTitle>
            <GraphIcon sx={{ fontSize: 18, color: "#4fc1ff" }} />
            Graph View - {titleText}
            <Typography
              component="span"
              sx={{
                color: "#808080",
                fontSize: "11px",
                ml: 2,
                fontWeight: "normal",
              }}
            >
              {startAddress} - {endAddress}
            </Typography>
          </WindowTitle>
          <Box display="flex" gap={1}>
            <Tooltip title="Close">
              <IconButton
                size="small"
                onClick={handleClose}
                sx={{ color: "#808080" }}
              >
                <CloseIcon fontSize="small" />
              </IconButton>
            </Tooltip>
          </Box>
        </WindowHeader>

        <ToolbarContainer>
          <Tooltip title="Zoom In">
            <IconButton
              size="small"
              onClick={handleZoomIn}
              sx={{ color: "#808080" }}
            >
              <ZoomInIcon fontSize="small" />
            </IconButton>
          </Tooltip>
          <Tooltip title="Zoom Out">
            <IconButton
              size="small"
              onClick={handleZoomOut}
              sx={{ color: "#808080" }}
            >
              <ZoomOutIcon fontSize="small" />
            </IconButton>
          </Tooltip>
          <Tooltip title="Center View">
            <IconButton
              size="small"
              onClick={handleCenter}
              sx={{ color: "#808080" }}
            >
              <CenterIcon fontSize="small" />
            </IconButton>
          </Tooltip>
          <Typography sx={{ color: "#808080", fontSize: "12px", ml: 2 }}>
            Zoom: {Math.round(zoom * 100)}%
          </Typography>
          <Typography sx={{ color: "#606060", fontSize: "11px", ml: 2 }}>
            Blocks: {blocks.length}
          </Typography>

          {/* Right side spacer */}
          <Box sx={{ ml: "auto" }} />
        </ToolbarContainer>

        <GraphCanvas
          ref={canvasRef}
          onMouseDown={handleCanvasMouseDown}
          onMouseMove={handleCanvasMouseMove}
          onMouseUp={handleCanvasMouseUp}
          onMouseLeave={handleCanvasMouseUp}
          onWheel={handleWheel}
        >
          {loading && (
            <LoadingOverlay>
              <CircularProgress size={40} sx={{ color: "#4fc1ff" }} />
              <Typography sx={{ color: "#808080", mt: 2 }}>
                Loading CFG...
              </Typography>
            </LoadingOverlay>
          )}

          {error && (
            <Box
              sx={{
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                height: "100%",
                color: "#ff5722",
              }}
            >
              <Typography>Error: {error}</Typography>
            </Box>
          )}

          {!loading && !error && (
            <>
              {/* Minimap */}
              <MinimapContainer onClick={handleMinimapClick}>
                <svg
                  width={minimapWidth}
                  height={minimapHeight}
                  style={{ display: "block" }}
                >
                  {/* Background */}
                  <rect
                    x={0}
                    y={0}
                    width={minimapWidth}
                    height={minimapHeight}
                    fill="#1a1a1a"
                  />

                  {/* Edges */}
                  {edges.map((edge, idx) => {
                    const fromLayout = layouts.find((l) => l.id === edge.from);
                    const toLayout = layouts.find((l) => l.id === edge.to);
                    if (!fromLayout || !toLayout) return null;

                    const fromX =
                      (fromLayout.x + fromLayout.width / 2 - graphBounds.minX) *
                        minimapScale +
                      minimapOffset.x;
                    const fromY =
                      (fromLayout.y + fromLayout.height - graphBounds.minY) *
                        minimapScale +
                      minimapOffset.y;
                    const toX =
                      (toLayout.x + toLayout.width / 2 - graphBounds.minX) *
                        minimapScale +
                      minimapOffset.x;
                    const toY =
                      (toLayout.y - graphBounds.minY) * minimapScale +
                      minimapOffset.y;

                    const edgeColor =
                      edge.type === "conditional-true"
                        ? "#4caf50"
                        : edge.type === "conditional-false"
                          ? "#ff5722"
                          : edge.type === "unconditional"
                            ? "#4fc1ff"
                            : "#808080";

                    return (
                      <line
                        key={`minimap-edge-${idx}`}
                        x1={fromX}
                        y1={fromY}
                        x2={toX}
                        y2={toY}
                        stroke={edgeColor}
                        strokeWidth={0.5}
                        opacity={0.6}
                      />
                    );
                  })}

                  {/* Blocks */}
                  {layouts.map((layout) => {
                    const block = blocks.find((b) => b.id === layout.id);
                    const x =
                      (layout.x - graphBounds.minX) * minimapScale +
                      minimapOffset.x;
                    const y =
                      (layout.y - graphBounds.minY) * minimapScale +
                      minimapOffset.y;
                    const width = layout.width * minimapScale;
                    const height = layout.height * minimapScale;

                    const fillColor = block?.isEntry
                      ? "#4caf50"
                      : block?.isExit
                        ? "#ff5722"
                        : "#3c3c3c";

                    return (
                      <rect
                        key={`minimap-block-${layout.id}`}
                        x={x}
                        y={y}
                        width={Math.max(width, 2)}
                        height={Math.max(height, 2)}
                        fill={fillColor}
                        opacity={0.8}
                      />
                    );
                  })}

                  {/* Viewport indicator */}
                  <rect
                    x={Math.max(0, viewportRect.x)}
                    y={Math.max(0, viewportRect.y)}
                    width={Math.min(
                      viewportRect.width,
                      minimapWidth - Math.max(0, viewportRect.x)
                    )}
                    height={Math.min(
                      viewportRect.height,
                      minimapHeight - Math.max(0, viewportRect.y)
                    )}
                    fill="rgba(79, 193, 255, 0.05)"
                    stroke="rgba(79, 193, 255, 0.4)"
                    strokeWidth={1}
                  />
                </svg>
              </MinimapContainer>

              <Box
                sx={{
                  transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`,
                  transformOrigin: "top left",
                  position: "absolute",
                  top: 0,
                  left: 0,
                }}
              >
                {/* Edges SVG */}
                <svg
                  ref={svgRef}
                  style={{
                    position: "absolute",
                    top: 0,
                    left: 0,
                    width: "3000px",
                    height: "5000px",
                    pointerEvents: "none",
                    overflow: "visible",
                  }}
                >
                  <defs>
                    {/* Start markers (circles at the beginning of lines) */}
                    <marker
                      id="startpoint-green"
                      markerWidth="6"
                      markerHeight="6"
                      refX="3"
                      refY="3"
                    >
                      <circle cx="3" cy="3" r="3" fill="#4caf50" />
                    </marker>
                    <marker
                      id="startpoint-red"
                      markerWidth="6"
                      markerHeight="6"
                      refX="3"
                      refY="3"
                    >
                      <circle cx="3" cy="3" r="3" fill="#ff5722" />
                    </marker>
                    <marker
                      id="startpoint-blue"
                      markerWidth="6"
                      markerHeight="6"
                      refX="3"
                      refY="3"
                    >
                      <circle cx="3" cy="3" r="3" fill="#4fc1ff" />
                    </marker>
                    <marker
                      id="startpoint-gray"
                      markerWidth="6"
                      markerHeight="6"
                      refX="3"
                      refY="3"
                    >
                      <circle cx="3" cy="3" r="3" fill="#808080" />
                    </marker>
                    {/* End markers (arrowheads) */}
                    <marker
                      id="arrowhead-green"
                      markerWidth="10"
                      markerHeight="7"
                      refX="0"
                      refY="3.5"
                      orient="auto"
                    >
                      <polygon points="0 0, 10 3.5, 0 7" fill="#4caf50" />
                    </marker>
                    <marker
                      id="arrowhead-red"
                      markerWidth="10"
                      markerHeight="7"
                      refX="0"
                      refY="3.5"
                      orient="auto"
                    >
                      <polygon points="0 0, 10 3.5, 0 7" fill="#ff5722" />
                    </marker>
                    <marker
                      id="arrowhead-blue"
                      markerWidth="10"
                      markerHeight="7"
                      refX="0"
                      refY="3.5"
                      orient="auto"
                    >
                      <polygon points="0 0, 10 3.5, 0 7" fill="#4fc1ff" />
                    </marker>
                    <marker
                      id="arrowhead-gray"
                      markerWidth="10"
                      markerHeight="7"
                      refX="0"
                      refY="3.5"
                      orient="auto"
                    >
                      <polygon points="0 0, 10 3.5, 0 7" fill="#808080" />
                    </marker>
                    {/* Down-pointing arrowheads for downward edges */}
                    <marker
                      id="arrowhead-down-green"
                      markerWidth="5"
                      markerHeight="6"
                      refX="2.5"
                      refY="6"
                    >
                      <polygon points="0 0, 5 0, 2.5 6" fill="#4caf50" />
                    </marker>
                    <marker
                      id="arrowhead-down-red"
                      markerWidth="5"
                      markerHeight="6"
                      refX="2.5"
                      refY="6"
                    >
                      <polygon points="0 0, 5 0, 2.5 6" fill="#ff5722" />
                    </marker>
                    <marker
                      id="arrowhead-down-blue"
                      markerWidth="5"
                      markerHeight="6"
                      refX="2.5"
                      refY="6"
                    >
                      <polygon points="0 0, 5 0, 2.5 6" fill="#4fc1ff" />
                    </marker>
                    <marker
                      id="arrowhead-down-gray"
                      markerWidth="5"
                      markerHeight="6"
                      refX="2.5"
                      refY="6"
                    >
                      <polygon points="0 0, 5 0, 2.5 6" fill="#808080" />
                    </marker>
                    {/* Up-pointing arrowheads for back edges */}
                    <marker
                      id="arrowhead-up-green"
                      markerWidth="7"
                      markerHeight="10"
                      refX="3.5"
                      refY="0"
                    >
                      <polygon points="3.5 0, 7 10, 0 10" fill="#4caf50" />
                    </marker>
                    <marker
                      id="arrowhead-up-red"
                      markerWidth="7"
                      markerHeight="10"
                      refX="3.5"
                      refY="0"
                    >
                      <polygon points="3.5 0, 7 10, 0 10" fill="#ff5722" />
                    </marker>
                    <marker
                      id="arrowhead-up-blue"
                      markerWidth="7"
                      markerHeight="10"
                      refX="3.5"
                      refY="0"
                    >
                      <polygon points="3.5 0, 7 10, 0 10" fill="#4fc1ff" />
                    </marker>
                    <marker
                      id="arrowhead-up-gray"
                      markerWidth="7"
                      markerHeight="10"
                      refX="3.5"
                      refY="0"
                    >
                      <polygon points="3.5 0, 7 10, 0 10" fill="#808080" />
                    </marker>
                  </defs>
                  {edges.map((edge, idx) => {
                    // All edges enter target block from the top, so always use down-pointing arrows
                    const markerEndId =
                      edge.type === "conditional-true"
                        ? "arrowhead-down-green"
                        : edge.type === "conditional-false"
                          ? "arrowhead-down-red"
                          : edge.type === "unconditional"
                            ? "arrowhead-down-blue"
                            : "arrowhead-down-gray";
                    const markerStartId =
                      edge.type === "conditional-true"
                        ? "startpoint-green"
                        : edge.type === "conditional-false"
                          ? "startpoint-red"
                          : edge.type === "unconditional"
                            ? "startpoint-blue"
                            : "startpoint-gray";
                    return (
                      <path
                        key={`edge-${idx}`}
                        d={renderEdgePath(edge, edges, idx)}
                        fill="none"
                        stroke={getEdgeColor(edge.type)}
                        strokeWidth="2"
                        markerStart={`url(#${markerStartId})`}
                        markerEnd={`url(#${markerEndId})`}
                      />
                    );
                  })}
                </svg>

                {/* Blocks */}
                {blocks.map((block) => {
                  const layout = layouts.find((l) => l.id === block.id);
                  if (!layout) return null;

                  const borderColor = getBlockBorderColor(block);
                  const headerBg = getBlockHeaderBg(block);
                  const reachability = blockReachability.get(block.id);

                  return (
                    <BlockContainer
                      key={block.id}
                      isEntry={block.isEntry}
                      isExit={block.isExit}
                      isDragging={draggingBlock === block.id}
                      sx={{
                        left: layout.x,
                        top: layout.y,
                        width: layout.width,
                        borderColor: borderColor,
                      }}
                      onMouseDown={(e) => handleBlockMouseDown(block.id, e)}
                    >
                      <BlockHeader
                        isEntry={!reachabilityEnabled && block.isEntry}
                        isExit={!reachabilityEnabled && block.isExit}
                        sx={{
                          backgroundColor: headerBg,
                          color: borderColor,
                        }}
                      >
                        {block.startAddress}
                        {block.isEntry && " (entry)"}
                        {block.isExit && " (exit)"}
                        {reachabilityEnabled && reachability && (
                          <Typography
                            component="span"
                            sx={{
                              ml: 1,
                              fontSize: "10px",
                              opacity: 0.8,
                            }}
                          >
                            [{reachability.status}]
                            {reachability.condition &&
                              ` - ${reachability.condition}`}
                          </Typography>
                        )}
                      </BlockHeader>
                      {block.instructions.map((instr, idx) => (
                        <InstructionRow
                          key={idx}
                          onClick={() => {
                            // Emit event to main window to navigate to this address
                            emit("navigate-to-address", {
                              address: instr.address,
                            });
                          }}
                        >
                          <AddressText>{instr.address}</AddressText>
                          <OpcodeText
                            sx={{
                              color: isJumpInstruction(instr.opcode)
                                ? isConditionalJump(instr.opcode)
                                  ? "#cc9900"
                                  : "#66cc66"
                                : "#569cd6",
                            }}
                          >
                            {instr.opcode}
                          </OpcodeText>
                          <OperandsText>{instr.operands}</OperandsText>
                        </InstructionRow>
                      ))}
                    </BlockContainer>
                  );
                })}
              </Box>
            </>
          )}
        </GraphCanvas>
      </WindowContainer>
    </ThemeProvider>
  );
};

export default GraphViewPage;

```

`src/client/src/pages/TerminalPage.tsx`:

```tsx
import React, { useEffect, useState } from "react";
import { useSearchParams } from "react-router-dom";
import { Box, ThemeProvider, createTheme, CssBaseline } from "@mui/material";
import { TerminalWindow } from "../components/TerminalWindow";
import { getCurrentWebviewWindow } from "@tauri-apps/api/webviewWindow";

// Dark theme for terminal
const darkTheme = createTheme({
  palette: {
    mode: "dark",
    background: {
      default: "#1e1e1e",
      paper: "#252526",
    },
  },
});

export const TerminalPage: React.FC = () => {
  const [searchParams] = useSearchParams();
  const [isReady, setIsReady] = useState(false);

  const ptyFd = parseInt(searchParams.get("pty_fd") || "0", 10);
  const pid = parseInt(searchParams.get("pid") || "0", 10);
  const processName = searchParams.get("process_name") || "Unknown";
  const serverUrl = searchParams.get("server_url") || "";

  useEffect(() => {
    // Store server URL for API client to use
    if (serverUrl) {
      sessionStorage.setItem("terminal_server_url", serverUrl);
    }
    setIsReady(true);
  }, [serverUrl]);

  const handleClose = async () => {
    const window = getCurrentWebviewWindow();
    await window.close();
  };

  if (!isReady || !ptyFd || !pid) {
    return (
      <ThemeProvider theme={darkTheme}>
        <CssBaseline />
        <Box
          sx={{
            height: "100vh",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            color: "#888",
          }}
        >
          Loading terminal...
        </Box>
      </ThemeProvider>
    );
  }

  return (
    <ThemeProvider theme={darkTheme}>
      <CssBaseline />
      <Box
        sx={{
          height: "100vh",
          width: "100vw",
          display: "flex",
          flexDirection: "column",
          overflow: "hidden",
        }}
      >
        <TerminalWindow
          ptyFd={ptyFd}
          pid={pid}
          processName={processName}
          onClose={handleClose}
          serverUrl={serverUrl}
        />
      </Box>
    </ThemeProvider>
  );
};

export default TerminalPage;

```

`src/client/src/pages/WatchpointExceptionPage.tsx`:

```tsx
import React, { useEffect, useState, useCallback } from "react";
import { ThemeProvider, CssBaseline } from "@mui/material";
import { useParams } from "react-router-dom";
import { darkTheme } from "../utils/theme";
import { WatchpointExceptionWindow } from "../components/WatchpointExceptionWindow";
import { getApiClient } from "../lib/api";
import { useTauriSystemStateSingleton } from "../hooks/useTauriSystemStateSingleton";
import { getCurrentWebviewWindow } from "@tauri-apps/api/webviewWindow";
import type { WatchpointInfo } from "../types";

const WatchpointExceptionPageInner: React.FC = () => {
  const { watchpointId } = useParams<{ watchpointId: string }>();
  const [watchpoint, setWatchpoint] = useState<WatchpointInfo | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isClosing, setIsClosing] = useState(false);

  // Get connection info from Tauri global state instead of URL parameters
  const { state: tauriState, isLoading: tauriLoading } =
    useTauriSystemStateSingleton();

  console.log(
    "WatchpointExceptionPage rendered with watchpointId:",
    watchpointId
  );

  console.log("Connection parameters from Tauri state:", {
    host: tauriState?.connectionHost,
    port: tauriState?.connectionPort,
    serverConnected: tauriState?.serverConnected,
    debuggerConnected: tauriState?.debuggerConnected,
  });

  // Initialize API client and load watchpoint details
  useEffect(() => {
    // Wait for Tauri state to load
    if (tauriLoading || !tauriState) {
      console.log("Waiting for Tauri state to load...");
      return;
    }

    // Ensure we have connection info from Tauri state
    if (!tauriState.connectionHost || !tauriState.connectionPort) {
      console.error("No connection info available in Tauri state");
      setError("No connection information available");
      setLoading(false);
      return;
    }

    // Skip reload if watchpoint is already loaded
    if (watchpoint) {
      console.log("Watchpoint already loaded, skipping reload");
      return;
    }

    const initializeAndLoad = async () => {
      console.log("Initializing API client with Tauri state connection info:", {
        host: tauriState.connectionHost,
        port: tauriState.connectionPort,
      });

      const apiClient = getApiClient();
      apiClient.updateConnection(
        tauriState.connectionHost!,
        tauriState.connectionPort!
      );

      // Now load the watchpoint
      try {
        await loadWatchpoint();
      } catch (error) {
        console.error("Failed to initialize and load watchpoint:", error);
        setError(`Failed to load watchpoint: ${error}`);
        setLoading(false);
      }
    };

    const loadWatchpoint = async () => {
      console.log("Loading watchpoint with ID:", watchpointId);

      if (!watchpointId) {
        console.error("No watchpoint ID provided");
        setError("No watchpoint ID provided");
        setLoading(false);
        return;
      }

      // Try to find watchpoint in Tauri state first
      if (tauriState?.watchpoints) {
        const foundWatchpoint = tauriState.watchpoints.find(
          (wp: any) => wp.id === watchpointId
        );

        if (foundWatchpoint) {
          console.log("Found watchpoint in Tauri state:", foundWatchpoint);
          const watchpointInfo: WatchpointInfo = {
            id: foundWatchpoint.id,
            address: foundWatchpoint.address,
            size: foundWatchpoint.size,
            accessType: foundWatchpoint.accessType as any,
            hitCount: foundWatchpoint.hitCount,
            createdAt: new Date(foundWatchpoint.createdAt),
            description: foundWatchpoint.description,
          };
          setWatchpoint(watchpointInfo);
          setLoading(false);
          return;
        }
      }

      // Fallback to API call if not found in state
      try {
        console.log("Fetching watchpoints from API...");
        const apiClient = getApiClient();
        const response = await apiClient.listWatchpoints();
        console.log("API response:", response);

        if (response.success) {
          const foundWatchpoint = response.watchpoints.find(
            (wp) => wp.id === watchpointId
          );
          console.log("Found watchpoint:", foundWatchpoint);

          if (foundWatchpoint) {
            // Convert to our WatchpointInfo format
            const watchpointInfo: WatchpointInfo = {
              id: foundWatchpoint.id,
              address: `0x${foundWatchpoint.address.toString(16).toUpperCase()}`,
              size: foundWatchpoint.size,
              accessType: foundWatchpoint.access_type as any,
              hitCount: foundWatchpoint.hit_count || 0,
              createdAt: foundWatchpoint.created_at
                ? new Date(foundWatchpoint.created_at)
                : new Date(),
              description: foundWatchpoint.description,
            };
            console.log("Setting watchpoint info:", watchpointInfo);
            setWatchpoint(watchpointInfo);
          } else {
            console.error(`Watchpoint with ID ${watchpointId} not found`);
            setError(`Watchpoint with ID ${watchpointId} not found`);
          }
        } else {
          console.error("API response failed:", response.message);
          setError("Failed to load watchpoint from server");
        }
      } catch (err) {
        console.error("Exception while loading watchpoint:", err);
        setError("Failed to connect to server");
      } finally {
        console.log("Loading complete");
        setLoading(false);
      }
    };

    initializeAndLoad();
  }, [watchpointId, tauriState, tauriLoading]);

  const handleClose = useCallback(
    async (_id: string) => {
      console.log("handleClose called for watchpoint:", watchpoint);

      // Set closing flag to prevent error display during cleanup
      setIsClosing(true);

      // Remove watchpoint first to ensure it's deleted even if window close fails
      if (watchpoint) {
        try {
          console.log("Removing watchpoint from server...");
          const apiClient = getApiClient();
          const addressNum = parseInt(watchpoint.address, 16);
          await apiClient.removeWatchpoint({ address: addressNum });
          console.log("Watchpoint removed successfully");
        } catch (error) {
          console.error("Failed to remove watchpoint:", error);
          // Continue with window close even if watchpoint removal fails
        }
      }

      // Close window after watchpoint removal using Tauri API
      try {
        console.log("Closing window...");
        const currentWindow = getCurrentWebviewWindow();
        await currentWindow.close();
      } catch (error) {
        console.error("Failed to close window:", error);
      }
    },
    [watchpoint]
  );

  if (loading) {
    console.log("Rendering loading state");
    return (
      <ThemeProvider theme={darkTheme}>
        <CssBaseline />
        <div
          style={{
            height: "100vh",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            flexDirection: "column",
            gap: "16px",
            color: "white",
            fontSize: "18px",
          }}
        >
          <div>Loading watchpoint exception monitor...</div>
          <div style={{ fontSize: "14px", opacity: 0.7 }}>
            Watchpoint ID: {watchpointId}
          </div>
        </div>
      </ThemeProvider>
    );
  }

  // Don't show error if window is closing
  if ((error || !watchpoint) && !isClosing) {
    console.log("Rendering error state:", error);
    return (
      <ThemeProvider theme={darkTheme}>
        <CssBaseline />
        <div
          style={{
            height: "100vh",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            flexDirection: "column",
            gap: "16px",
            color: "#f44336",
            fontSize: "18px",
            padding: "20px",
          }}
        >
          <div>Error: {error || "Unknown error"}</div>
          <div style={{ fontSize: "14px", opacity: 0.7 }}>
            Watchpoint ID: {watchpointId}
          </div>
        </div>
      </ThemeProvider>
    );
  }

  // If closing, show nothing or a closing message
  if (isClosing) {
    return (
      <ThemeProvider theme={darkTheme}>
        <CssBaseline />
        <div
          style={{
            height: "100vh",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            color: "white",
            fontSize: "16px",
          }}
        >
          Closing...
        </div>
      </ThemeProvider>
    );
  }

  console.log(
    "Rendering WatchpointExceptionWindow with watchpoint:",
    watchpoint
  );

  // Ensure watchpoint is not null before rendering
  if (!watchpoint) {
    return (
      <ThemeProvider theme={darkTheme}>
        <CssBaseline />
        <div
          style={{
            height: "100vh",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            color: "white",
            fontSize: "16px",
          }}
        >
          Loading...
        </div>
      </ThemeProvider>
    );
  }

  // Use Tauri state for connection info
  if (!tauriState?.connectionHost || !tauriState?.connectionPort) {
    return (
      <ThemeProvider theme={darkTheme}>
        <CssBaseline />
        <div
          style={{
            height: "100vh",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            flexDirection: "column",
            gap: "16px",
            color: "#f44336",
            fontSize: "18px",
            padding: "20px",
          }}
        >
          <div>Error: No connection information available in Tauri state</div>
          <div style={{ fontSize: "14px", opacity: 0.7 }}>
            Watchpoint ID: {watchpointId}
          </div>
        </div>
      </ThemeProvider>
    );
  }

  return (
    <ThemeProvider theme={darkTheme}>
      <CssBaseline />
      <WatchpointExceptionWindow
        watchpoint={watchpoint}
        onClose={handleClose}
      />
    </ThemeProvider>
  );
};

export const WatchpointExceptionPage: React.FC = () => {
  return <WatchpointExceptionPageInner />;
};

```

`src/client/src/stores/uiStore.ts`:

```ts
import { create } from "zustand";
import { devtools } from "zustand/middleware";

export type Mode =
  | "home"
  | "server"
  | "debugger"
  | "information"
  | "scanner"
  | "network"
  | "logs"
  | "state"
  | "tools";

export interface DebuggerTabState {
  tabValue: number;
  activeFunction: string;
  selectedFunction?: { name: string; address: string };
  selectedModule: any;
  assemblyAddress: string;
  assemblyNavigationTrigger: number; // Counter to force re-navigation to same address
  assemblyNavigationHistory: string[]; // Stack of previous addresses for "Back" navigation
  memoryAddress: string;
  memoryCurrentAddress: string;
  memoryInputAddress: string;
  breakpointInputValue: string;
  gotoAddress: string;
  addressDisplayFormat: "library" | "function";
  assemblyDemangleEnabled: boolean;
  debuggerSettingsOpen: boolean; // Debugger settings dialog open state
  sourceCodeLevelDebug: boolean; // Source code level debugging enabled
  breakpointNotification: {
    open: boolean;
    message: string;
  };
}

export interface ScannerUIState {
  scanSettings: {
    valueType: string;
    scanType: string;
    value: string;
    startAddress?: string;
    endAddress?: string;
    scanMode: string;
    selectedRegions: string[];
    alignment: number;
    writable: boolean | null;
    executable: boolean | null;
    readable: boolean | null;
    doSuspend: boolean;
    valueInputFormat?: "dec" | "hex";
  };
  scanResults: any[];
  totalResults: number;
  isScanning: boolean;
  scanProgress: number;
  scannedBytes: number;
  totalBytes: number;
  currentRegion: string | null;
  scanId: string | null;
  unknownScanId?: string;
}

export interface InformationUIState {
  currentTab: number;
  nameFilter: string;
  sortField: string;
  sortDirection: "asc" | "desc";
  threads: ThreadInfo[];
  threadFilter: string;
  regions: RegionInfo[];
  regionFilter: string;
  regionProtectionFilter: {
    readable: boolean | null;
    writable: boolean | null;
    executable: boolean | null;
    private: boolean | null;
  };
  // Network connections
  networkConnections: NetworkConnectionInfo[];
  networkFilter: string;
  selectedModuleBase: number | null;
  symbols: SymbolInfoStore[];
  symbolFilter: string;
  symbolDemangleEnabled: boolean;
  symbolSortField: "name" | "address" | "size" | "type" | "scope";
  symbolSortDirection: "asc" | "desc";
  symbolTypeFilter: string;
  symbolScopeFilter: string;
  symbolColumnWidths: {
    name: number;
    address: number;
    size: number;
    type: number;
    scope: number;
    flags: number;
  };
  moduleColumnWidths: {
    name: number;
    base: number;
    size: number;
    arch: number;
    path: number;
  };
  regionColumnWidths: {
    start: number;
    end: number;
    size: number;
    protection: number;
    path: number;
  };
  threadColumnWidths: {
    id: number;
    name: number;
    address: number;
    detail: number;
    state: number;
  };
}

export interface SymbolInfoStore {
  name: string;
  address: string;
  size: number;
  type: string;
  scope?: string;
}

export interface ThreadInfo {
  thread_id: number;
  name: string;
  pc: string;
  sp: string;
  fp: string;
  state: string;
  suspend_count: number;
}

export interface RegionInfo {
  start_address: string;
  end_address: string;
  protection: string;
  file_path?: string;
}

export interface NetworkConnectionInfo {
  protocol: string;
  local_address: string;
  local_port: number;
  remote_address: string;
  remote_port: number;
  state: string;
  inode?: string;
}

export interface AssemblyViewCache {
  topVisibleAddress: string | null;
  timestamp: number;
}

export interface CachedSymbol {
  address: number;
  endAddress: number;
  name: string;
  moduleName: string;
  moduleBase: number;
}

export interface GlobalSymbolCache {
  symbols: CachedSymbol[];
  loadedModules: Set<number>;
  isLoading: boolean;
  loadingProgress: number;
}

export interface ToolsUIState {
  currentTab: number;
  objcClasses: any[];
  objcSelectedClass: any | null;
  objcSearchFilter: string;
  objcDetailTab: number;
  objcMethods: any[];
  objcIvars: any[];
  objcProperties: any[];
  objcProtocols: any[];
  ghidraPath: string;
  ghidraProjectName: string; // Project name for organizing analyzed libraries
  ghidraModuleFilter: string;
  ghidraModules: any[]; // ModuleInfo[] - persisted module list
  ghidraSelectedModuleBase: number | null;
  ghidraAnalysisLogs: Array<{
    timestamp: number;
    type: "info" | "error" | "success" | "output";
    message: string;
  }>;
  ghidraAnalysisProgress: string;
  ghidraIsAnalyzing: boolean;
  ghidraServerStatus: "stopped" | "starting" | "running" | "stopping";
  ghidraServerPort: number | null;
  ghidraServerProjectPath: string | null;
  scriptEditorContent: string;
  scriptShowLineNumbers: boolean;
  savedScripts: Array<{
    name: string;
    content: string;
    createdAt: number;
    description?: string;
  }>;
  selectedScriptIndex: number | null;
  openScriptTabs: Array<{
    id: string;
    name: string;
    content: string;
    isModified: boolean;
    savedScriptIndex: number | null;
  }>;
  activeScriptTabIndex: number;
  outputPanelHeight: number;
  scriptSidebarWidth: number;
  scriptCurrentJobId: string | null;
  scriptJobStatus:
    | "pending"
    | "running"
    | "completed"
    | "failed"
    | "cancelled"
    | null;
  scriptLogs: Array<{
    timestamp: number;
    type: "info" | "error" | "success" | "output";
    message: string;
  }>;
  scriptFiles: Array<{
    filename: string;
    data_base64: string;
    mime_type?: string;
  }>;
  scriptDownloadedFiles: string[];
  fileExplorerCurrentPath: string;
  fileExplorerItems: FileExplorerItem[];
  fileExplorerExpandedPaths: string[];
  fileExplorerSelectedPath: string | null;
  fileExplorerViewerContent: FileViewerContent | null;
  fileExplorerIsLoading: boolean;
  debugState: DebugPanelState | null;
}

// Source breakpoint info
export interface SourceBreakpoint {
  filePath: string;
  line: number;
  address: number; // Absolute address (module base + offset)
  moduleBase: number;
  offset: number;
  enabled: boolean;
  isHit: boolean; // Currently stopped at this breakpoint
}

// Pending source jump request (from OUTLINE click)
export interface PendingSourceJump {
  filePath: string;
  line: number;
}

// DWARF Debug Panel state
export interface DebugPanelState {
  analysisResult: any | null; // DwarfAnalysisResult
  sourceCodeLevelDebug: boolean;
  selectedModuleBase: number | null;
  selectedModulePath: string | null; // Selected module path (for persistence)
  sourceRootPath: string; // Host OS path to source code root
  ndkPath: string; // Android NDK path (ANDROID_NDK_HOME)
  sourceBreakpoints: SourceBreakpoint[]; // Source-level breakpoints
  currentHitAddress: number | null; // Address where we're currently stopped
  pendingSourceJump: PendingSourceJump | null; // Jump to source line request
}

// File Explorer types
export interface FileExplorerItem {
  item_type: "file" | "directory";
  name: string;
  path: string;
  size?: number;
  last_opened?: number;
  children?: FileExplorerItem[];
}

export interface FileViewerContent {
  path: string;
  name: string;
  type: "text" | "binary" | "image" | "unknown";
  content: string | ArrayBuffer;
  size: number;
  mimeType?: string;
}

// Debugger Sidebar Cache (to prevent API calls on tab switch)
export interface DebuggerSidebarCache {
  modules: any[]; // ModuleInfo[]
  selectedModuleSymbols: any[]; // SymbolInfo[]
  ghidraFunctions: any[]; // GhidraFunctionEntry[]
  ghidraDataItems: any[]; // GhidraDataItem[]
  cachedProcessPid: number | null; // Track which process the cache is for
  cachedModulePath: string | null; // Track which module the symbols/functions are for
}

interface UIState {
  currentMode: Mode;

  sidebarWidth: number;
  debuggerSidebarWidth: number;
  scannerSidebarWidth: number;
  showRegisters: boolean;
  showToolbar: boolean;

  debuggerState: DebuggerTabState;

  scannerState: ScannerUIState;

  informationState: InformationUIState;

  toolsState: ToolsUIState;

  assemblyViewCache: AssemblyViewCache | null;

  globalSymbolCache: GlobalSymbolCache;

  debuggerSidebarCache: DebuggerSidebarCache;

  scanHistory: any[];
  bookmarks: any[];

  lastUpdate: number;
}

interface UIActions {
  setCurrentMode: (mode: Mode) => void;

  setSidebarWidth: (width: number) => void;
  setDebuggerSidebarWidth: (width: number) => void;
  setScannerSidebarWidth: (width: number) => void;
  setShowRegisters: (show: boolean) => void;
  setShowToolbar: (show: boolean) => void;

  setDebuggerTab: (tab: number) => void;
  setActiveFunction: (functionName: string) => void;
  setSelectedFunction: (
    functionInfo: { name: string; address: string } | undefined
  ) => void;
  setSelectedModule: (module: any) => void;
  setAssemblyAddress: (address: string) => void;
  setAssemblyAddressWithHistory: (address: string) => void; // Navigate with history tracking for Back button
  goBackAssemblyNavigation: () => void; // Go back to previous address
  clearAssemblyNavigationHistory: () => void; // Clear navigation history
  setMemoryAddress: (address: string) => void;
  setMemoryCurrentAddress: (address: string) => void;
  setMemoryInputAddress: (address: string) => void;
  setBreakpointInputValue: (value: string) => void;
  setGotoAddress: (address: string) => void;
  setAddressDisplayFormat: (format: "library" | "function") => void;
  toggleAddressDisplayFormat: () => void;
  setAssemblyDemangleEnabled: (enabled: boolean) => void;
  toggleAssemblyDemangle: () => void;
  setDebuggerSettingsOpen: (open: boolean) => void;
  setSourceCodeLevelDebug: (enabled: boolean) => void;
  toggleSourceCodeLevelDebug: () => void;
  showBreakpointNotification: (message: string) => void;
  hideBreakpointNotification: () => void;
  updateDebuggerState: (updates: Partial<DebuggerTabState>) => void;

  updateScannerState: (updates: Partial<ScannerUIState>) => void;
  setScanResults: (results: any[]) => void;
  clearScanResults: () => void;
  setScanSettings: (settings: any) => void;
  updateScanSettings: (updates: any) => void;

  setInformationTab: (tab: number) => void;
  setInformationNameFilter: (filter: string) => void;
  setInformationSort: (field: string, direction: "asc" | "desc") => void;
  updateInformationState: (updates: Partial<InformationUIState>) => void;
  setInformationThreads: (threads: ThreadInfo[]) => void;
  setInformationThreadFilter: (filter: string) => void;
  setInformationRegions: (regions: RegionInfo[]) => void;
  setInformationRegionFilter: (filter: string) => void;
  setRegionProtectionFilter: (filter: {
    readable: boolean | null;
    writable: boolean | null;
    executable: boolean | null;
    private: boolean | null;
  }) => void;
  setNetworkConnections: (connections: NetworkConnectionInfo[]) => void;
  setNetworkFilter: (filter: string) => void;
  setSymbolsSelectedModule: (moduleBase: number | null) => void;
  setSymbols: (symbols: SymbolInfoStore[]) => void;
  setSymbolFilter: (filter: string) => void;
  setSymbolDemangleEnabled: (enabled: boolean) => void;
  setSymbolSortField: (
    field: "name" | "address" | "size" | "type" | "scope"
  ) => void;
  setSymbolSortDirection: (direction: "asc" | "desc") => void;
  setSymbolTypeFilter: (filter: string) => void;
  setSymbolScopeFilter: (filter: string) => void;
  setSymbolColumnWidth: (
    column: keyof InformationUIState["symbolColumnWidths"],
    width: number
  ) => void;
  setModuleColumnWidth: (
    column: keyof InformationUIState["moduleColumnWidths"],
    width: number
  ) => void;
  setRegionColumnWidth: (
    column: keyof InformationUIState["regionColumnWidths"],
    width: number
  ) => void;
  setThreadColumnWidth: (
    column: keyof InformationUIState["threadColumnWidths"],
    width: number
  ) => void;

  setAssemblyViewCache: (cache: AssemblyViewCache | null) => void;
  clearAssemblyViewCache: () => void;

  addSymbolsToCache: (symbols: CachedSymbol[]) => void;
  markModuleAsLoaded: (moduleBase: number) => void;
  setSymbolCacheLoading: (isLoading: boolean, progress?: number) => void;
  clearSymbolCache: () => void;
  findSymbolForAddress: (address: number) => CachedSymbol | null;

  setScanHistory: (history: any[]) => void;
  addScanHistory: (item: any) => void;
  removeScanHistory: (index: number) => void;
  clearScanHistory: () => void;
  setBookmarks: (bookmarks: any[]) => void;
  addBookmark: (bookmark: any) => void;
  updateBookmark: (bookmarkId: string, updates: Partial<any>) => void;
  removeBookmark: (bookmarkId: string) => void;

  setToolsTab: (tab: number) => void;
  updateToolsState: (updates: Partial<ToolsUIState>) => void;
  setFileExplorerPath: (path: string) => void;
  setFileExplorerItems: (items: FileExplorerItem[]) => void;
  toggleFileExplorerExpanded: (path: string) => void;
  setFileExplorerSelectedPath: (path: string | null) => void;
  setFileExplorerViewerContent: (content: FileViewerContent | null) => void;
  setFileExplorerIsLoading: (loading: boolean) => void;

  // Source-level breakpoint actions
  addSourceBreakpoint: (breakpoint: SourceBreakpoint) => void;
  removeSourceBreakpoint: (filePath: string, line: number) => void;
  toggleSourceBreakpoint: (filePath: string, line: number) => void;
  setCurrentHitAddress: (address: number | null) => void;
  clearSourceBreakpoints: () => void;
  setPendingSourceJump: (jump: PendingSourceJump | null) => void;

  // Debugger Sidebar Cache
  setDebuggerSidebarModules: (modules: any[], processPid: number) => void;
  setDebuggerSidebarSymbols: (symbols: any[], modulePath: string) => void;
  setDebuggerSidebarGhidraFunctions: (
    functions: any[],
    modulePath: string
  ) => void;
  setDebuggerSidebarGhidraData: (dataItems: any[], modulePath: string) => void;
  clearDebuggerSidebarCache: () => void;

  touch: () => void;
}

const initialState: UIState = {
  currentMode: "home",
  sidebarWidth: 240,
  debuggerSidebarWidth: 280,
  scannerSidebarWidth: 280,
  showRegisters: false,
  showToolbar: true,

  debuggerState: {
    tabValue: 0,
    activeFunction: "",
    selectedFunction: undefined,
    selectedModule: null,
    assemblyAddress: "",
    assemblyNavigationTrigger: 0,
    assemblyNavigationHistory: [],
    memoryAddress: "",
    memoryCurrentAddress: "",
    memoryInputAddress: "",
    breakpointInputValue: "",
    gotoAddress: "",
    addressDisplayFormat: "function" as const,
    assemblyDemangleEnabled: true,
    debuggerSettingsOpen: false,
    sourceCodeLevelDebug: false,
    breakpointNotification: {
      open: false,
      message: "",
    },
  },

  scannerState: {
    scanSettings: {
      valueType: "int32",
      scanType: "exact",
      value: "",
      startAddress: "",
      endAddress: "",
      scanMode: "manual",
      selectedRegions: [],
      alignment: 4,
      writable: null,
      executable: null,
      readable: null,
      doSuspend: false,
      valueInputFormat: "dec" as "dec" | "hex",
    },
    scanResults: [],
    totalResults: 0,
    isScanning: false,
    scanProgress: 0,
    scannedBytes: 0,
    totalBytes: 0,
    currentRegion: null,
    scanId: null,
  },

  informationState: {
    currentTab: 0,
    nameFilter: "",
    sortField: "name",
    sortDirection: "asc",
    threads: [],
    threadFilter: "",
    regions: [],
    regionFilter: "",
    regionProtectionFilter: {
      readable: null,
      writable: null,
      executable: null,
      private: null,
    },
    networkConnections: [],
    networkFilter: "",
    selectedModuleBase: null,
    symbols: [],
    symbolFilter: "",
    symbolDemangleEnabled: true,
    symbolSortField: "address",
    symbolSortDirection: "asc",
    symbolTypeFilter: "all",
    symbolScopeFilter: "all",
    symbolColumnWidths: {
      name: 300,
      address: 140,
      size: 80,
      type: 100,
      scope: 80,
      flags: 150,
    },
    moduleColumnWidths: {
      name: 240,
      base: 140,
      size: 70,
      arch: 80,
      path: 200,
    },
    regionColumnWidths: {
      start: 180,
      end: 180,
      size: 90,
      protection: 90,
      path: 200,
    },
    threadColumnWidths: {
      id: 100,
      name: 200,
      address: 140,
      detail: 200,
      state: 100,
    },
  },

  toolsState: {
    currentTab: 0,
    objcClasses: [],
    objcSelectedClass: null,
    objcSearchFilter: "",
    objcDetailTab: 0,
    objcMethods: [],
    objcIvars: [],
    objcProperties: [],
    objcProtocols: [],
    ghidraPath: localStorage.getItem("dynadbg_ghidra_path") || "",
    ghidraProjectName:
      localStorage.getItem("dynadbg_ghidra_project_name") || "",
    ghidraModuleFilter: "",
    ghidraModules: [],
    ghidraSelectedModuleBase: null,
    ghidraAnalysisLogs: [],
    ghidraAnalysisProgress: "",
    ghidraIsAnalyzing: false,
    ghidraServerStatus: "stopped",
    ghidraServerPort: null,
    ghidraServerProjectPath: null,
    scriptEditorContent: "",
    scriptShowLineNumbers: true,
    savedScripts: [],
    selectedScriptIndex: null,
    openScriptTabs: [],
    activeScriptTabIndex: 0,
    outputPanelHeight: 150,
    scriptSidebarWidth: 200,
    scriptCurrentJobId: null,
    scriptJobStatus: null,
    scriptLogs: [],
    scriptFiles: [],
    scriptDownloadedFiles: [],
    fileExplorerCurrentPath: "/",
    fileExplorerItems: [],
    fileExplorerExpandedPaths: [],
    fileExplorerSelectedPath: null,
    fileExplorerViewerContent: null,
    fileExplorerIsLoading: false,
    debugState: (() => {
      try {
        const saved = localStorage.getItem("dynadbg_dwarf_settings");
        if (saved) {
          const parsed = JSON.parse(saved);
          return {
            analysisResult: null, // Don't persist analysis results
            sourceCodeLevelDebug: parsed.sourceCodeLevelDebug || false,
            selectedModuleBase: null, // Don't persist, will be set on module select
            selectedModulePath: parsed.selectedModulePath || null,
            sourceRootPath: parsed.sourceRootPath || "",
            ndkPath: parsed.ndkPath || "",
            sourceBreakpoints: [], // Don't persist breakpoints
            currentHitAddress: null,
            pendingSourceJump: null,
          };
        }
      } catch (e) {
        console.error("Failed to load DWARF settings from localStorage:", e);
      }
      return null;
    })(),
  },

  assemblyViewCache: null,

  globalSymbolCache: {
    symbols: [],
    loadedModules: new Set<number>(),
    isLoading: false,
    loadingProgress: 0,
  },

  debuggerSidebarCache: {
    modules: [],
    selectedModuleSymbols: [],
    ghidraFunctions: [],
    ghidraDataItems: [],
    cachedProcessPid: null,
    cachedModulePath: null,
  },

  scanHistory: [],
  bookmarks: [],
  lastUpdate: Date.now(),
};

export const useUIStore = create<UIState & { actions: UIActions }>()(
  devtools(
    (set): UIState & { actions: UIActions } => ({
      ...initialState,

      actions: {
        setCurrentMode: (mode) =>
          set(() => ({
            currentMode: mode,
            lastUpdate: Date.now(),
          })),

        setSidebarWidth: (width) =>
          set(() => ({
            sidebarWidth: width,
            lastUpdate: Date.now(),
          })),

        setDebuggerSidebarWidth: (width) =>
          set(() => ({
            debuggerSidebarWidth: width,
            lastUpdate: Date.now(),
          })),

        setScannerSidebarWidth: (width) =>
          set(() => ({
            scannerSidebarWidth: width,
            lastUpdate: Date.now(),
          })),

        setShowRegisters: (show) =>
          set(() => ({
            showRegisters: show,
            lastUpdate: Date.now(),
          })),

        setShowToolbar: (show) =>
          set(() => ({
            showToolbar: show,
            lastUpdate: Date.now(),
          })),

        setDebuggerTab: (tab) =>
          set((state) => {
            const newDebuggerState = { ...state.debuggerState, tabValue: tab };
            try {
              localStorage.setItem(
                "debugger-ui-state",
                JSON.stringify(newDebuggerState)
              );
            } catch (error) {
              console.error(
                "Failed to save debugger UI state to localStorage:",
                error
              );
            }
            return {
              debuggerState: newDebuggerState,
              lastUpdate: Date.now(),
            };
          }),

        setActiveFunction: (functionName) =>
          set((state) => ({
            debuggerState: {
              ...state.debuggerState,
              activeFunction: functionName,
            },
            lastUpdate: Date.now(),
          })),

        setSelectedFunction: (functionInfo) =>
          set((state) => ({
            debuggerState: {
              ...state.debuggerState,
              selectedFunction: functionInfo,
            },
            lastUpdate: Date.now(),
          })),

        setSelectedModule: (module) =>
          set((state) => ({
            debuggerState: {
              ...state.debuggerState,
              selectedModule: module,
            },
            lastUpdate: Date.now(),
          })),

        setAssemblyAddress: (address) =>
          set((state) => ({
            debuggerState: {
              ...state.debuggerState,
              assemblyAddress: address,
              assemblyNavigationTrigger:
                state.debuggerState.assemblyNavigationTrigger + 1,
            },
            lastUpdate: Date.now(),
          })),

        // Navigate to address with history tracking for Back button
        setAssemblyAddressWithHistory: (address) =>
          set((state) => {
            const currentAddress = state.debuggerState.assemblyAddress;
            const newHistory = currentAddress
              ? [
                  ...state.debuggerState.assemblyNavigationHistory,
                  currentAddress,
                ].slice(-50) // Keep last 50 entries
              : state.debuggerState.assemblyNavigationHistory;
            return {
              debuggerState: {
                ...state.debuggerState,
                assemblyAddress: address,
                assemblyNavigationTrigger:
                  state.debuggerState.assemblyNavigationTrigger + 1,
                assemblyNavigationHistory: newHistory,
              },
              lastUpdate: Date.now(),
            };
          }),

        // Go back to previous address
        goBackAssemblyNavigation: () =>
          set((state) => {
            const history = state.debuggerState.assemblyNavigationHistory;
            if (history.length === 0) return state;
            const previousAddress = history[history.length - 1];
            const newHistory = history.slice(0, -1);
            return {
              debuggerState: {
                ...state.debuggerState,
                assemblyAddress: previousAddress,
                assemblyNavigationTrigger:
                  state.debuggerState.assemblyNavigationTrigger + 1,
                assemblyNavigationHistory: newHistory,
              },
              lastUpdate: Date.now(),
            };
          }),

        // Clear navigation history
        clearAssemblyNavigationHistory: () =>
          set((state) => ({
            debuggerState: {
              ...state.debuggerState,
              assemblyNavigationHistory: [],
            },
            lastUpdate: Date.now(),
          })),

        setMemoryCurrentAddress: (address) =>
          set((state) => ({
            debuggerState: {
              ...state.debuggerState,
              memoryCurrentAddress: address,
            },
            lastUpdate: Date.now(),
          })),

        setMemoryInputAddress: (address) =>
          set((state) => ({
            debuggerState: {
              ...state.debuggerState,
              memoryInputAddress: address,
            },
            lastUpdate: Date.now(),
          })),

        setMemoryAddress: (address) =>
          set((state) => ({
            debuggerState: {
              ...state.debuggerState,
              memoryAddress: address,
            },
            lastUpdate: Date.now(),
          })),

        setBreakpointInputValue: (value) =>
          set((state) => ({
            debuggerState: {
              ...state.debuggerState,
              breakpointInputValue: value,
            },
            lastUpdate: Date.now(),
          })),

        setGotoAddress: (address) =>
          set((state) => ({
            debuggerState: {
              ...state.debuggerState,
              gotoAddress: address,
            },
            lastUpdate: Date.now(),
          })),

        setAddressDisplayFormat: (format) =>
          set((state) => ({
            debuggerState: {
              ...state.debuggerState,
              addressDisplayFormat: format,
            },
            lastUpdate: Date.now(),
          })),

        toggleAddressDisplayFormat: () =>
          set((state) => ({
            debuggerState: {
              ...state.debuggerState,
              addressDisplayFormat:
                state.debuggerState.addressDisplayFormat === "library"
                  ? "function"
                  : "library",
            },
            lastUpdate: Date.now(),
          })),

        setAssemblyDemangleEnabled: (enabled) =>
          set((state) => ({
            debuggerState: {
              ...state.debuggerState,
              assemblyDemangleEnabled: enabled,
            },
            lastUpdate: Date.now(),
          })),

        toggleAssemblyDemangle: () =>
          set((state) => ({
            debuggerState: {
              ...state.debuggerState,
              assemblyDemangleEnabled:
                !state.debuggerState.assemblyDemangleEnabled,
            },
            lastUpdate: Date.now(),
          })),

        setDebuggerSettingsOpen: (open) =>
          set((state) => ({
            debuggerState: {
              ...state.debuggerState,
              debuggerSettingsOpen: open,
            },
            lastUpdate: Date.now(),
          })),

        setSourceCodeLevelDebug: (enabled) =>
          set((state) => ({
            debuggerState: {
              ...state.debuggerState,
              sourceCodeLevelDebug: enabled,
            },
            lastUpdate: Date.now(),
          })),

        toggleSourceCodeLevelDebug: () =>
          set((state) => ({
            debuggerState: {
              ...state.debuggerState,
              sourceCodeLevelDebug: !state.debuggerState.sourceCodeLevelDebug,
            },
            lastUpdate: Date.now(),
          })),

        showBreakpointNotification: (message) =>
          set((state) => ({
            debuggerState: {
              ...state.debuggerState,
              breakpointNotification: { open: true, message },
            },
            lastUpdate: Date.now(),
          })),

        hideBreakpointNotification: () =>
          set((state) => ({
            debuggerState: {
              ...state.debuggerState,
              breakpointNotification: {
                ...state.debuggerState.breakpointNotification,
                open: false,
              },
            },
            lastUpdate: Date.now(),
          })),

        updateDebuggerState: (updates) =>
          set((state) => {
            const newDebuggerState = { ...state.debuggerState, ...updates };
            try {
              localStorage.setItem(
                "debugger-ui-state",
                JSON.stringify(newDebuggerState)
              );
            } catch (error) {
              console.error(
                "Failed to save debugger UI state to localStorage:",
                error
              );
            }
            return {
              debuggerState: newDebuggerState,
              lastUpdate: Date.now(),
            };
          }),

        updateScannerState: (updates) =>
          set((state) => ({
            scannerState: { ...state.scannerState, ...updates },
            lastUpdate: Date.now(),
          })),

        setScanResults: (results) =>
          set((state) => ({
            scannerState: { ...state.scannerState, scanResults: results },
            lastUpdate: Date.now(),
          })),

        clearScanResults: () =>
          set((state) => ({
            scannerState: {
              ...state.scannerState,
              scanResults: [],
              totalResults: 0,
            },
            lastUpdate: Date.now(),
          })),

        setScanSettings: (settings) =>
          set((state) => {
            try {
              localStorage.setItem(
                "scanner-ui-settings",
                JSON.stringify(settings)
              );
            } catch (error) {
              console.error(
                "Failed to save scan UI settings to localStorage:",
                error
              );
            }
            return {
              scannerState: { ...state.scannerState, scanSettings: settings },
              lastUpdate: Date.now(),
            };
          }),

        updateScanSettings: (updates) =>
          set((state) => {
            const newSettings = {
              ...state.scannerState.scanSettings,
              ...updates,
            };
            try {
              localStorage.setItem(
                "scanner-ui-settings",
                JSON.stringify(newSettings)
              );
            } catch (error) {
              console.error(
                "Failed to save scan UI settings to localStorage:",
                error
              );
            }
            return {
              scannerState: {
                ...state.scannerState,
                scanSettings: newSettings,
              },
              lastUpdate: Date.now(),
            };
          }),

        setInformationTab: (tab) =>
          set((state) => {
            const newInformationState = {
              ...state.informationState,
              currentTab: tab,
            };
            try {
              localStorage.setItem(
                "information-ui-state",
                JSON.stringify(newInformationState)
              );
            } catch (error) {
              console.error(
                "Failed to save information UI state to localStorage:",
                error
              );
            }
            return {
              informationState: newInformationState,
              lastUpdate: Date.now(),
            };
          }),

        setInformationNameFilter: (filter) =>
          set((state) => {
            const newInformationState = {
              ...state.informationState,
              nameFilter: filter,
            };
            try {
              localStorage.setItem(
                "information-ui-state",
                JSON.stringify(newInformationState)
              );
            } catch (error) {
              console.error(
                "Failed to save information UI state to localStorage:",
                error
              );
            }
            return {
              informationState: newInformationState,
              lastUpdate: Date.now(),
            };
          }),

        setInformationSort: (field, direction) =>
          set((state) => {
            const newInformationState = {
              ...state.informationState,
              sortField: field,
              sortDirection: direction,
            };
            try {
              localStorage.setItem(
                "information-ui-state",
                JSON.stringify(newInformationState)
              );
            } catch (error) {
              console.error(
                "Failed to save information UI state to localStorage:",
                error
              );
            }
            return {
              informationState: newInformationState,
              lastUpdate: Date.now(),
            };
          }),

        updateInformationState: (updates) =>
          set((state) => {
            const newInformationState = {
              ...state.informationState,
              ...updates,
            };
            try {
              localStorage.setItem(
                "information-ui-state",
                JSON.stringify(newInformationState)
              );
            } catch (error) {
              console.error(
                "Failed to save information UI state to localStorage:",
                error
              );
            }
            return {
              informationState: newInformationState,
              lastUpdate: Date.now(),
            };
          }),

        setInformationThreads: (threads) =>
          set((state) => ({
            informationState: {
              ...state.informationState,
              threads,
            },
            lastUpdate: Date.now(),
          })),

        setInformationThreadFilter: (filter) =>
          set((state) => ({
            informationState: {
              ...state.informationState,
              threadFilter: filter,
            },
            lastUpdate: Date.now(),
          })),

        setInformationRegions: (regions) =>
          set((state) => ({
            informationState: {
              ...state.informationState,
              regions,
            },
            lastUpdate: Date.now(),
          })),

        setInformationRegionFilter: (filter) =>
          set((state) => ({
            informationState: {
              ...state.informationState,
              regionFilter: filter,
            },
            lastUpdate: Date.now(),
          })),

        setRegionProtectionFilter: (filter) =>
          set((state) => ({
            informationState: {
              ...state.informationState,
              regionProtectionFilter: filter,
            },
            lastUpdate: Date.now(),
          })),

        setNetworkConnections: (connections) =>
          set((state) => ({
            informationState: {
              ...state.informationState,
              networkConnections: connections,
            },
            lastUpdate: Date.now(),
          })),

        setNetworkFilter: (filter) =>
          set((state) => ({
            informationState: {
              ...state.informationState,
              networkFilter: filter,
            },
            lastUpdate: Date.now(),
          })),

        setSymbolsSelectedModule: (moduleBase) =>
          set((state) => ({
            informationState: {
              ...state.informationState,
              selectedModuleBase: moduleBase,
            },
            lastUpdate: Date.now(),
          })),

        setSymbols: (symbols) =>
          set((state) => ({
            informationState: {
              ...state.informationState,
              symbols,
            },
            lastUpdate: Date.now(),
          })),

        setSymbolFilter: (filter) =>
          set((state) => ({
            informationState: {
              ...state.informationState,
              symbolFilter: filter,
            },
            lastUpdate: Date.now(),
          })),

        setSymbolDemangleEnabled: (enabled) =>
          set((state) => ({
            informationState: {
              ...state.informationState,
              symbolDemangleEnabled: enabled,
            },
            lastUpdate: Date.now(),
          })),

        setSymbolSortField: (field) =>
          set((state) => ({
            informationState: {
              ...state.informationState,
              symbolSortField: field,
            },
            lastUpdate: Date.now(),
          })),

        setSymbolSortDirection: (direction) =>
          set((state) => ({
            informationState: {
              ...state.informationState,
              symbolSortDirection: direction,
            },
            lastUpdate: Date.now(),
          })),

        setSymbolTypeFilter: (filter) =>
          set((state) => ({
            informationState: {
              ...state.informationState,
              symbolTypeFilter: filter,
            },
            lastUpdate: Date.now(),
          })),

        setSymbolScopeFilter: (filter) =>
          set((state) => ({
            informationState: {
              ...state.informationState,
              symbolScopeFilter: filter,
            },
            lastUpdate: Date.now(),
          })),

        setSymbolColumnWidth: (column, width) =>
          set((state) => ({
            informationState: {
              ...state.informationState,
              symbolColumnWidths: {
                ...state.informationState.symbolColumnWidths,
                [column]: width,
              },
            },
            lastUpdate: Date.now(),
          })),

        setModuleColumnWidth: (column, width) =>
          set((state) => ({
            informationState: {
              ...state.informationState,
              moduleColumnWidths: {
                ...state.informationState.moduleColumnWidths,
                [column]: width,
              },
            },
            lastUpdate: Date.now(),
          })),

        setRegionColumnWidth: (column, width) =>
          set((state) => ({
            informationState: {
              ...state.informationState,
              regionColumnWidths: {
                ...state.informationState.regionColumnWidths,
                [column]: width,
              },
            },
            lastUpdate: Date.now(),
          })),

        setThreadColumnWidth: (column, width) =>
          set((state) => ({
            informationState: {
              ...state.informationState,
              threadColumnWidths: {
                ...state.informationState.threadColumnWidths,
                [column]: width,
              },
            },
            lastUpdate: Date.now(),
          })),

        setAssemblyViewCache: (cache) =>
          set(() => {
            console.log("[UI STORE] Setting assembly view cache:", cache);
            return {
              assemblyViewCache: cache,
              lastUpdate: Date.now(),
            };
          }),

        clearAssemblyViewCache: () =>
          set(() => {
            console.log("[UI STORE] Clearing assembly view cache");
            return {
              assemblyViewCache: null,
              lastUpdate: Date.now(),
            };
          }),

        addSymbolsToCache: (symbols) =>
          set((state) => {
            const existingSymbols = state.globalSymbolCache.symbols;

            const sortedNewSymbols = [...symbols].sort(
              (a, b) => a.address - b.address
            );

            if (existingSymbols.length === 0) {
              return {
                globalSymbolCache: {
                  ...state.globalSymbolCache,
                  symbols: sortedNewSymbols,
                },
                lastUpdate: Date.now(),
              };
            }

            const mergedSymbols: typeof existingSymbols = [];
            let i = 0,
              j = 0;
            while (i < existingSymbols.length && j < sortedNewSymbols.length) {
              if (existingSymbols[i].address <= sortedNewSymbols[j].address) {
                mergedSymbols.push(existingSymbols[i]);
                i++;
              } else {
                mergedSymbols.push(sortedNewSymbols[j]);
                j++;
              }
            }
            while (i < existingSymbols.length) {
              mergedSymbols.push(existingSymbols[i]);
              i++;
            }
            while (j < sortedNewSymbols.length) {
              mergedSymbols.push(sortedNewSymbols[j]);
              j++;
            }

            return {
              globalSymbolCache: {
                ...state.globalSymbolCache,
                symbols: mergedSymbols,
              },
              lastUpdate: Date.now(),
            };
          }),

        markModuleAsLoaded: (moduleBase) =>
          set((state) => {
            const newLoadedModules = new Set(
              state.globalSymbolCache.loadedModules
            );
            newLoadedModules.add(moduleBase);
            return {
              globalSymbolCache: {
                ...state.globalSymbolCache,
                loadedModules: newLoadedModules,
              },
              lastUpdate: Date.now(),
            };
          }),

        setSymbolCacheLoading: (isLoading, progress = 0) =>
          set((state) => ({
            globalSymbolCache: {
              ...state.globalSymbolCache,
              isLoading,
              loadingProgress: progress,
            },
            lastUpdate: Date.now(),
          })),

        clearSymbolCache: () =>
          set(() => ({
            globalSymbolCache: {
              symbols: [],
              loadedModules: new Set<number>(),
              isLoading: false,
              loadingProgress: 0,
            },
            lastUpdate: Date.now(),
          })),

        findSymbolForAddress: (address) => {
          const state = useUIStore.getState();
          const symbols = state.globalSymbolCache.symbols;

          if (symbols.length === 0) return null;

          let left = 0;
          let right = symbols.length - 1;

          while (left <= right) {
            const mid = Math.floor((left + right) / 2);
            const symbol = symbols[mid];

            if (address >= symbol.address && address < symbol.endAddress) {
              return symbol;
            } else if (address < symbol.address) {
              right = mid - 1;
            } else {
              left = mid + 1;
            }
          }

          return null;
        },

        setScanHistory: (history: any[]) =>
          set(() => ({
            scanHistory: history,
            lastUpdate: Date.now(),
          })),

        addScanHistory: (item: any) =>
          set((state) => {
            const existingIndex = state.scanHistory.findIndex(
              (existing) =>
                existing.valueType === item.valueType &&
                existing.scanType === item.scanType &&
                existing.value === item.value
            );

            let newHistory: any[];
            if (existingIndex !== -1) {
              newHistory = [
                item,
                ...state.scanHistory.filter((_, i) => i !== existingIndex),
              ];
            } else {
              newHistory = [item, ...state.scanHistory];
            }

            if (newHistory.length > 100) {
              newHistory = newHistory.slice(0, 100);
            }

            try {
              localStorage.setItem("scan-history", JSON.stringify(newHistory));
            } catch (error) {
              console.error(
                "Failed to save scan history to localStorage:",
                error
              );
            }

            return {
              scanHistory: newHistory,
              lastUpdate: Date.now(),
            };
          }),

        removeScanHistory: (index: number) =>
          set((state) => {
            const newHistory = state.scanHistory.filter((_, i) => i !== index);
            try {
              localStorage.setItem("scan-history", JSON.stringify(newHistory));
            } catch (error) {
              console.error(
                "Failed to save scan history to localStorage:",
                error
              );
            }
            return {
              scanHistory: newHistory,
              lastUpdate: Date.now(),
            };
          }),

        clearScanHistory: () =>
          set(() => {
            try {
              localStorage.removeItem("scan-history");
            } catch (error) {
              console.error(
                "Failed to clear scan history from localStorage:",
                error
              );
            }
            return {
              scanHistory: [],
              lastUpdate: Date.now(),
            };
          }),

        setBookmarks: (bookmarks: any[]) =>
          set(() => ({
            bookmarks: bookmarks,
            lastUpdate: Date.now(),
          })),

        addBookmark: (bookmark: any) =>
          set((state) => {
            const exists = state.bookmarks.some(
              (b) => b.address === bookmark.address
            );
            if (exists) {
              return state;
            }

            const newBookmarks = [...state.bookmarks, bookmark];
            try {
              localStorage.setItem("bookmarks", JSON.stringify(newBookmarks));
            } catch (error) {
              console.error("Failed to save bookmarks to localStorage:", error);
            }
            return {
              bookmarks: newBookmarks,
              lastUpdate: Date.now(),
            };
          }),

        updateBookmark: (bookmarkId: string, updates: Partial<any>) =>
          set((state) => {
            const newBookmarks = state.bookmarks.map((b) =>
              b.id === bookmarkId ? { ...b, ...updates } : b
            );
            try {
              localStorage.setItem("bookmarks", JSON.stringify(newBookmarks));
            } catch (error) {
              console.error("Failed to save bookmarks to localStorage:", error);
            }
            return {
              bookmarks: newBookmarks,
              lastUpdate: Date.now(),
            };
          }),

        removeBookmark: (bookmarkId: string) =>
          set((state) => {
            const newBookmarks = state.bookmarks.filter(
              (b) => b.id !== bookmarkId
            );
            try {
              localStorage.setItem("bookmarks", JSON.stringify(newBookmarks));
            } catch (error) {
              console.error("Failed to save bookmarks to localStorage:", error);
            }
            return {
              bookmarks: newBookmarks,
              lastUpdate: Date.now(),
            };
          }),

        setToolsTab: (tab: number) =>
          set((state) => ({
            toolsState: {
              ...state.toolsState,
              currentTab: tab,
            },
            lastUpdate: Date.now(),
          })),

        updateToolsState: (updates: Partial<ToolsUIState>) =>
          set((state) => {
            const newToolsState = {
              ...state.toolsState,
              ...updates,
            };

            // Persist DWARF settings to localStorage if debugState was updated
            if (updates.debugState) {
              try {
                const settingsToSave = {
                  sourceCodeLevelDebug:
                    updates.debugState.sourceCodeLevelDebug || false,
                  selectedModulePath:
                    updates.debugState.selectedModulePath || null,
                  sourceRootPath: updates.debugState.sourceRootPath || "",
                  ndkPath: updates.debugState.ndkPath || "",
                };
                localStorage.setItem(
                  "dynadbg_dwarf_settings",
                  JSON.stringify(settingsToSave)
                );
              } catch (e) {
                console.error(
                  "Failed to save DWARF settings to localStorage:",
                  e
                );
              }
            }

            return {
              toolsState: newToolsState,
              lastUpdate: Date.now(),
            };
          }),

        setFileExplorerPath: (path: string) =>
          set((state) => ({
            toolsState: {
              ...state.toolsState,
              fileExplorerCurrentPath: path,
            },
            lastUpdate: Date.now(),
          })),

        setFileExplorerItems: (items: FileExplorerItem[]) =>
          set((state) => ({
            toolsState: {
              ...state.toolsState,
              fileExplorerItems: items,
            },
            lastUpdate: Date.now(),
          })),

        toggleFileExplorerExpanded: (path: string) =>
          set((state) => {
            const expanded = state.toolsState.fileExplorerExpandedPaths;
            const isExpanded = expanded.includes(path);
            return {
              toolsState: {
                ...state.toolsState,
                fileExplorerExpandedPaths: isExpanded
                  ? expanded.filter((p) => p !== path)
                  : [...expanded, path],
              },
              lastUpdate: Date.now(),
            };
          }),

        setFileExplorerSelectedPath: (path: string | null) =>
          set((state) => ({
            toolsState: {
              ...state.toolsState,
              fileExplorerSelectedPath: path,
            },
            lastUpdate: Date.now(),
          })),

        setFileExplorerViewerContent: (content: FileViewerContent | null) =>
          set((state) => ({
            toolsState: {
              ...state.toolsState,
              fileExplorerViewerContent: content,
            },
            lastUpdate: Date.now(),
          })),

        setFileExplorerIsLoading: (loading: boolean) =>
          set((state) => ({
            toolsState: {
              ...state.toolsState,
              fileExplorerIsLoading: loading,
            },
            lastUpdate: Date.now(),
          })),

        // Source-level breakpoint actions
        addSourceBreakpoint: (breakpoint: SourceBreakpoint) =>
          set((state) => {
            const currentBreakpoints =
              state.toolsState.debugState?.sourceBreakpoints || [];
            // Check if already exists
            const exists = currentBreakpoints.some(
              (bp) =>
                bp.filePath === breakpoint.filePath &&
                bp.line === breakpoint.line
            );
            if (exists) return state;
            return {
              toolsState: {
                ...state.toolsState,
                debugState: state.toolsState.debugState
                  ? {
                      ...state.toolsState.debugState,
                      sourceBreakpoints: [...currentBreakpoints, breakpoint],
                    }
                  : null,
              },
              lastUpdate: Date.now(),
            };
          }),

        removeSourceBreakpoint: (filePath: string, line: number) =>
          set((state) => {
            const currentBreakpoints =
              state.toolsState.debugState?.sourceBreakpoints || [];
            return {
              toolsState: {
                ...state.toolsState,
                debugState: state.toolsState.debugState
                  ? {
                      ...state.toolsState.debugState,
                      sourceBreakpoints: currentBreakpoints.filter(
                        (bp) => !(bp.filePath === filePath && bp.line === line)
                      ),
                    }
                  : null,
              },
              lastUpdate: Date.now(),
            };
          }),

        toggleSourceBreakpoint: (filePath: string, line: number) =>
          set((state) => {
            const currentBreakpoints =
              state.toolsState.debugState?.sourceBreakpoints || [];
            const existingIndex = currentBreakpoints.findIndex(
              (bp) => bp.filePath === filePath && bp.line === line
            );
            if (existingIndex >= 0) {
              // Toggle enabled state
              const updated = [...currentBreakpoints];
              updated[existingIndex] = {
                ...updated[existingIndex],
                enabled: !updated[existingIndex].enabled,
              };
              return {
                toolsState: {
                  ...state.toolsState,
                  debugState: state.toolsState.debugState
                    ? {
                        ...state.toolsState.debugState,
                        sourceBreakpoints: updated,
                      }
                    : null,
                },
                lastUpdate: Date.now(),
              };
            }
            return state;
          }),

        setCurrentHitAddress: (address: number | null) =>
          set((state) => ({
            toolsState: {
              ...state.toolsState,
              debugState: state.toolsState.debugState
                ? {
                    ...state.toolsState.debugState,
                    currentHitAddress: address,
                  }
                : null,
            },
            lastUpdate: Date.now(),
          })),

        clearSourceBreakpoints: () =>
          set((state) => ({
            toolsState: {
              ...state.toolsState,
              debugState: state.toolsState.debugState
                ? {
                    ...state.toolsState.debugState,
                    sourceBreakpoints: [],
                    currentHitAddress: null,
                  }
                : null,
            },
            lastUpdate: Date.now(),
          })),

        setPendingSourceJump: (jump: PendingSourceJump | null) =>
          set((state) => ({
            toolsState: {
              ...state.toolsState,
              debugState: state.toolsState.debugState
                ? {
                    ...state.toolsState.debugState,
                    pendingSourceJump: jump,
                  }
                : null,
            },
            lastUpdate: Date.now(),
          })),

        // Debugger Sidebar Cache
        setDebuggerSidebarModules: (modules: any[], processPid: number) =>
          set((state) => ({
            debuggerSidebarCache: {
              ...state.debuggerSidebarCache,
              modules,
              cachedProcessPid: processPid,
            },
            lastUpdate: Date.now(),
          })),

        setDebuggerSidebarSymbols: (symbols: any[], modulePath: string) =>
          set((state) => ({
            debuggerSidebarCache: {
              ...state.debuggerSidebarCache,
              selectedModuleSymbols: symbols,
              cachedModulePath: modulePath,
            },
            lastUpdate: Date.now(),
          })),

        setDebuggerSidebarGhidraFunctions: (
          functions: any[],
          modulePath: string
        ) =>
          set((state) => ({
            debuggerSidebarCache: {
              ...state.debuggerSidebarCache,
              ghidraFunctions: functions,
              cachedModulePath: modulePath,
            },
            lastUpdate: Date.now(),
          })),

        setDebuggerSidebarGhidraData: (dataItems: any[], modulePath: string) =>
          set((state) => ({
            debuggerSidebarCache: {
              ...state.debuggerSidebarCache,
              ghidraDataItems: dataItems,
              cachedModulePath: modulePath,
            },
            lastUpdate: Date.now(),
          })),

        clearDebuggerSidebarCache: () =>
          set(() => ({
            debuggerSidebarCache: {
              modules: [],
              selectedModuleSymbols: [],
              ghidraFunctions: [],
              ghidraDataItems: [],
              cachedProcessPid: null,
              cachedModulePath: null,
            },
            lastUpdate: Date.now(),
          })),

        touch: () =>
          set(() => ({
            lastUpdate: Date.now(),
          })),
      },
    }),
    {
      name: "ui-store",
    }
  )
);

export const useCurrentMode = () => useUIStore((state) => state.currentMode);
export const useSidebarWidth = () => useUIStore((state) => state.sidebarWidth);
export const useShowRegisters = () =>
  useUIStore((state) => state.showRegisters);
export const useShowToolbar = () => useUIStore((state) => state.showToolbar);

export const useDebuggerTab = () =>
  useUIStore((state) => state.debuggerState.tabValue);
export const useActiveFunction = () =>
  useUIStore((state) => state.debuggerState.activeFunction);
export const useSelectedFunction = () =>
  useUIStore((state) => state.debuggerState.selectedFunction);
export const useSelectedModule = () =>
  useUIStore((state) => state.debuggerState.selectedModule);
export const useAssemblyAddress = () =>
  useUIStore((state) => state.debuggerState.assemblyAddress);
export const useMemoryAddress = () =>
  useUIStore((state) => state.debuggerState.memoryAddress);
export const useBreakpointNotification = () =>
  useUIStore((state) => state.debuggerState.breakpointNotification);
export const useBreakpointInputValue = () =>
  useUIStore((state) => state.debuggerState.breakpointInputValue);

export const useScannerState = () => useUIStore((state) => state.scannerState);
export const useScanResults = () =>
  useUIStore((state) => state.scannerState.scanResults);
export const useScanSettings = () =>
  useUIStore((state) => state.scannerState.scanSettings);

export const useInformationState = () =>
  useUIStore((state) => state.informationState);

export const useScanHistory = () => useUIStore((state) => state.scanHistory);
export const useBookmarks = () => useUIStore((state) => state.bookmarks);

export const useUIActions = () => useUIStore((state) => state.actions);

export const useUIUpdate = () => useUIStore((state) => state.lastUpdate);

```

`src/client/src/types/index.ts`:

```ts
// TypeScript interfaces and types
export interface Operand {
  type: "reg" | "imm" | "mem" | "shift" | "cond" | "label";
  value?: string;
  base?: string;
  disp?: string;
  index?: string;
  scale?: number;
  shift?: string;
  amount?: string | number;
}

export interface Instruction {
  address: string;
  bytes: string;
  opcode: string;
  operands: Operand[];
  comment: string;
  active: boolean;
  breakpoint: boolean;
  jumpTarget: boolean;
  isFunction?: boolean;
  isFunctionStart?: boolean;
  isFunctionEnd?: boolean;
}

export interface HexRow {
  address: string;
  bytes: string[];
  ascii: string;
  modified: number[];
  highlighted: number[];
}

export interface MemoryRegion {
  start: string;
  end: string;
  protection: string;
  name: string;
  type: "code" | "data" | "heap" | "stack" | "unknown";
}

export interface Register {
  name: string;
  value: string;
  changed: boolean;
  type: "gpr" | "fpr" | "vector" | "special";
}

export interface ThreadInfo {
  id: string;
  name: string;
  state: "running" | "stopped" | "waiting";
  pc: string;
}

export interface FunctionInfo {
  name: string;
  address: string;
  size: number;
  instructions: Instruction[];
}

export interface DebuggerState {
  connected: boolean;
  state: "running" | "paused" | "stopped";
  currentAddress: string;
  currentFunction: string;
}

export interface UIState {
  currentMode: "debugger" | "server";
  tabValue: number;
  showToolbar: boolean;
  showRegisters: boolean;
  currentEndianness: "little" | "big";
  currentCodePage: string;
}

export type AppMode = "debugger" | "server" | "scanner" | "home" | "tools";

// Scanner Types (Backend-compatible)
export interface ScanResult {
  address: string;
  value: string | number;
  description?: string;
  type: ScanValueType;
}

// YARA scan types
export interface YaraMatch {
  rule_name: string;
  address: number;
  length: number;
  pattern_id: string;
  matched_data: string;
}

export interface YaraScanResponse {
  success: boolean;
  message: string;
  scan_id: string;
  matches: YaraMatch[];
  total_matches: number;
  scanned_bytes: number;
}

export type ScanValueType =
  | "int8"
  | "uint8"
  | "int16"
  | "uint16"
  | "int32"
  | "uint32"
  | "int64"
  | "uint64"
  | "float"
  | "double"
  | "string"
  | "bytes"
  | "regex"
  | "ptr";

export interface ScanSettings {
  valueType: ScanValueType;
  scanType: ScanType;
  value: string;
  valueMax?: string; // For range search: max value (value is min)
  valueInputFormat?: "dec" | "hex"; // Input format for integer values (decimal or hexadecimal)
  startAddress?: string;
  endAddress?: string;
  scanMode: "manual" | "regions"; // manual uses start/end addresses, regions uses selected memory regions
  selectedRegions: string[]; // array of region identifiers when scanMode is 'regions'
  alignment: number;
  writable: boolean | null; // true = required, false = excluded, null = don't care
  executable: boolean | null; // true = required, false = excluded, null = don't care
  readable: boolean | null; // true = required, false = excluded, null = don't care
  doSuspend: boolean;
  searchMode: "normal" | "yara" | "ptr"; // Toggle between normal value search, YARA rule search, and pointer scan
  yaraRule?: string; // YARA rule source code
  ptrMaxDepth?: number; // Max depth for pointer scan (default: 5)
  ptrMaxOffset?: number; // Max offset for pointer scan (default: 4096)
  ptrMapFiles?: string[]; // Selected .dptr file names for pointer scan
  ptrMapFilePaths?: { path: string; name: string; targetAddress?: string }[]; // Full paths, names and target addresses for pointer scan files
  ptrMapFileHandles?: File[]; // File handles for the selected .dptr files (legacy browser mode)
}

export type ScanType =
  | "exact"
  | "bigger"
  | "smaller"
  | "range"
  | "greater_or_equal"
  | "less_than"
  | "unknown"
  | "changed"
  | "unchanged"
  | "increased"
  | "decreased";

export interface FilterRequest {
  pattern: string;
  pattern_max?: string; // For range filter: pattern is min, pattern_max is max
  data_type: string;
  scan_id: string;
  filter_method: string;
  return_as_json: boolean;
  do_suspend: boolean;
}

export interface FilterResponse {
  success: boolean;
  message: string;
  filter_id: string;
  scan_id: string;
}

export interface FilterProgressResponse {
  filter_id: string;
  progress_percentage: number;
  processed_results: number;
  total_results: number;
  is_filtering: boolean;
  current_region?: string;
}

export interface ScannerState {
  isScanning: boolean;
  scanResults: ScanResult[];
  scanHistory: ScanResult[][];
  currentScanIndex: number;
  totalResults: number;
  scanSettings: ScanSettings;
  scanId: string;
  scanProgress: number;
  scannedBytes: number;
  totalBytes: number;
  currentRegion?: string;
  searchPatternLength?: number; // Length of the search pattern in bytes (for bytes type)
  errorMessage?: string; // Error message to display to user
  unknownScanId?: string; // Unique ID for unknown scan temp file storage
  unknownScanTempDir?: string; // Temp directory for unknown scan data
}

export interface FunctionData {
  name: string;
  address: string;
  type: string;
  size: string;
  flags: string[];
  scope?: "global" | "local" | "weak";
}

export interface VariableData {
  name: string;
  address: string;
  type: string;
  flags: string[];
  scope?: "global" | "local" | "weak";
}

export interface ModuleData {
  name: string;
  address: string;
  functions: string[];
}

export interface StructureData {
  name: string;
  size: string;
  fields: string[];
}

export interface ChipData {
  label: string;
  color?:
    | "default"
    | "primary"
    | "secondary"
    | "error"
    | "info"
    | "success"
    | "warning";
  variant?: "filled" | "outlined";
}

export interface ContextMenuItem {
  label?: string;
  icon?: React.ReactNode;
  onClick?: () => void;
  disabled?: boolean;
  divider?: boolean;
}

export interface TreeItemProps {
  children: React.ReactNode;
  details?: string;
  icon?: React.ComponentType<any>;
  color?: string;
  active?: boolean;
  highlighted?: boolean;
  onClick?: () => void;
  chips?: ChipData[];
  contextMenu?: ContextMenuItem[];
}

export interface FunctionTreeItemProps {
  data: FunctionData;
  active: boolean;
  onClick: () => void;
}

export interface SidebarPanelAction {
  icon: React.ReactNode;
  tooltip: string;
  onClick: () => void;
}

export interface SidebarPanelProps {
  title: string;
  icon: React.ComponentType<any>;
  badge?: string;
  actions?: SidebarPanelAction[];
  defaultExpanded?: boolean;
  children: React.ReactNode;
}

// Additional interface definitions for scanner components
export interface RegisterViewData {
  name: string;
  value: string;
  description?: string;
}

// Bookmark interface
// Scan history item for storing search history
export interface ScanHistoryItem {
  id: string;
  valueType: ScanValueType;
  scanType: ScanType;
  value: string;
  description: string;
  timestamp: Date;
  scanSettings: Omit<ScanSettings, "valueType" | "scanType" | "value">;
}

export interface BookmarkItem {
  id: string;
  address: string; // Resolved numeric address (e.g., "0x100120000") or pointer expression (e.g., "BASE+0x100 → [0x10] → [0x18]")
  libraryExpression?: string; // Optional library+offset format (e.g., "UnityFramework + 0x120000")
  value: string;
  type: ScanValueType;
  ptrValueType?: Exclude<ScanValueType, "ptr" | "string" | "bytes" | "regex">; // For ptr type: the underlying value type to read
  size?: number; // Size in bytes for string/bytes types
  description?: string;
  displayFormat?: "dec" | "hex"; // Display format for integer values (also applies to ptr type)
  createdAt: Date;
  tags?: string[];
}

// Watchpoint interface
export interface WatchpointInfo {
  id: string;
  address: string;
  size: number;
  accessType: "r" | "w" | "rw"; // Trigger conditions
  hitCount: number;
  createdAt: Date;
  description?: string;
}

export type WatchpointSize = 1 | 2 | 4 | 8; // Valid sizes for hardware watchpoints
export type WatchpointAccessType = "r" | "w" | "rw";

// Exception information for watchpoint triggers
export interface ExceptionInfo {
  index: number;
  count: number;
  address: string;
  bytecode: string;
  opcode?: string; // Will be populated by disassembly
  timestamp: Date;
  watchpointId?: string;
  thread_id?: number; // Thread ID from exception info
  exception_type?:
    | "breakpoint"
    | "watchpoint"
    | "singlestep"
    | "signal"
    | "sigsegv"
    | "sigbus"
    | "sigfpe"
    | "sigill"
    | "sigabrt"
    | "sigtrap"
    | "unknown"
    | 0
    | 1
    | 2
    | 3
    | 4
    | 5
    | 6
    | 7
    | 8
    | 9
    | 10; // From C++ enum (string or numeric) - 3 is singlestep, 4-10 are signals
  singlestep_mode?: number; // SingleStepMode from server (2 = Breakpoint/Tracing mode)
  memory_address?: number; // Memory address for watchpoint exceptions
  // ARM64 Register values as individual fields (flattened from server processing)
  x0?: string | number;
  x1?: string | number;
  x2?: string | number;
  x3?: string | number;
  x4?: string | number;
  x5?: string | number;
  x6?: string | number;
  x7?: string | number;
  x8?: string | number;
  x9?: string | number;
  x10?: string | number;
  x11?: string | number;
  x12?: string | number;
  x13?: string | number;
  x14?: string | number;
  x15?: string | number;
  x16?: string | number;
  x17?: string | number;
  x18?: string | number;
  x19?: string | number;
  x20?: string | number;
  x21?: string | number;
  x22?: string | number;
  x23?: string | number;
  x24?: string | number;
  x25?: string | number;
  x26?: string | number;
  x27?: string | number;
  x28?: string | number;
  x29?: string | number;
  lr?: string | number;
  fp?: string | number;
  sp?: string | number;
  pc?: string | number;
  cpsr?: string | number;
  // x86_64 Register values
  rax?: string | number;
  rbx?: string | number;
  rcx?: string | number;
  rdx?: string | number;
  rsi?: string | number;
  rdi?: string | number;
  rbp?: string | number;
  rsp?: string | number;
  r8?: string | number;
  r9?: string | number;
  r10?: string | number;
  r11?: string | number;
  r12?: string | number;
  r13?: string | number;
  r14?: string | number;
  r15?: string | number;
  rip?: string | number;
  rflags?: string | number;
  cs?: string | number;
  ss?: string | number;
  ds?: string | number;
  es?: string | number;
  fs?: string | number;
  gs?: string | number;
  instruction?: string; // Added by server processing
}

export interface ExceptionInfoResponse {
  success: boolean;
  exceptions: ExceptionInfo[];
  message?: string;
}

// ObjC Dynamic Analyzer Types
export interface ObjcClassInfo {
  name: string;
  address: string;
  superclass?: string;
  instance_size: number;
  method_count: number;
  ivar_count: number;
  property_count: number;
}

export interface ObjcMethodInfo {
  name: string;
  selector: string;
  implementation: string;
  type_encoding: string;
  is_class_method: boolean;
}

export interface ObjcIvarInfo {
  name: string;
  type_encoding: string;
  offset: number;
}

export interface ObjcPropertyInfo {
  name: string;
  attributes: string;
  getter?: string;
  setter?: string;
}

export interface ObjcProtocolInfo {
  name: string;
}

```

`src/client/src/utils/addressEncoder.ts`:

```ts
import { ModuleInfo, getApiClient } from "../lib/api";
import { useUIStore, CachedSymbol } from "../stores/uiStore";

async function loadModuleSymbolsOnDemand(
  serverInfo: { ip: string; port: number },
  module: ModuleInfo
): Promise<CachedSymbol[]> {
  const globalSymbolCache = useUIStore.getState().globalSymbolCache;
  const actions = useUIStore.getState().actions;

  if (globalSymbolCache.loadedModules.has(module.base)) {
    return globalSymbolCache.symbols.filter(
      (s) => s.moduleBase === module.base
    );
  }

  try {
    const client = getApiClient();
    client.updateConnection(serverInfo.ip, serverInfo.port);
    const symbols = await client.enumerateSymbolsForModule(module);

    if (!symbols || symbols.length === 0) {
      actions.markModuleAsLoaded(module.base);
      return [];
    }

    const fullModuleName = module.modulename || module.name || "unknown";
    const moduleName = fullModuleName.split(/[\/\\]/).pop() || fullModuleName;

    const functionSymbols = symbols.filter(
      (s) => s.type === "Function" || s.type === "FUNC"
    );

    const cachedSymbols: CachedSymbol[] = functionSymbols
      .map((symbol) => {
        const address = parseInt(symbol.address, 16);
        if (isNaN(address)) return null;

        return {
          address,
          endAddress: address + (symbol.size || 1),
          name: symbol.name,
          moduleName,
          moduleBase: module.base,
        };
      })
      .filter((s): s is CachedSymbol => s !== null);

    if (cachedSymbols.length > 0) {
      actions.addSymbolsToCache(cachedSymbols);
    }

    actions.markModuleAsLoaded(module.base);
    console.log(
      `[addressEncoder] Loaded ${cachedSymbols.length} symbols for ${moduleName}`
    );
    return cachedSymbols;
  } catch (error) {
    console.error(
      `Failed to load symbols for module ${module.modulename}:`,
      error
    );
    actions.markModuleAsLoaded(module.base);
    return [];
  }
}

/**
 * Parses a library+offset or library@function+offset expression and converts it to a numeric address
 * Supports formats:
 * - "lib.so + 0x1234" or "lib.so+0x1234" (library + offset)
 * - "lib.so@func + 0x10" or "lib.so@func+0x10" (library@function + offset)
 * - "lib.so@func" (library@function without offset)
 * @param expression - The expression to parse
 * @param modules - Array of loaded modules with their base addresses
 * @returns The numeric address or null if parsing fails
 */
export function decodeLibraryExpression(
  expression: string,
  modules: ModuleInfo[]
): number | null {
  if (!expression || !modules || modules.length === 0) {
    return null;
  }

  // Trim whitespace
  const trimmed = expression.trim();

  // Check if it's a library@function format (contains @ before the + sign or no + sign)
  const atIndex = trimmed.indexOf("@");
  const plusIndex = trimmed.indexOf("+");

  if (atIndex > 0 && (plusIndex === -1 || atIndex < plusIndex)) {
    // This is a library@function format
    return decodeLibraryFunctionExpression(trimmed, modules);
  }

  // Match pattern: "LibraryName + 0xOffset" or "LibraryName+0xOffset"
  const match = trimmed.match(/^(.+?)\s*\+\s*(0x[0-9a-fA-F]+|\d+)$/);

  if (!match) {
    return null;
  }

  const libraryName = match[1].trim();
  const offsetStr = match[2].trim();

  // Parse offset (supports both hex and decimal)
  let offset: number;
  if (offsetStr.startsWith("0x") || offsetStr.startsWith("0X")) {
    offset = parseInt(offsetStr, 16);
  } else {
    offset = parseInt(offsetStr, 10);
  }

  if (isNaN(offset)) {
    return null;
  }

  // Find the module by name (case-insensitive, partial match)
  // Support both filename and full module path
  const module = modules.find((mod) => {
    const fullModuleName = mod.modulename || mod.name || "";
    const fileName = fullModuleName.split("/").pop() || fullModuleName;

    // Try exact match first
    if (
      fullModuleName.toLowerCase() === libraryName.toLowerCase() ||
      fileName.toLowerCase() === libraryName.toLowerCase()
    ) {
      return true;
    }

    // Try partial match (library name contains the search term)
    if (
      fullModuleName.toLowerCase().includes(libraryName.toLowerCase()) ||
      fileName.toLowerCase().includes(libraryName.toLowerCase())
    ) {
      return true;
    }

    return false;
  });

  if (!module) {
    console.warn(
      `Module "${libraryName}" not found in loaded modules. Available modules:`,
      modules.map((m) => m.modulename || m.name)
    );
    return null;
  }

  // Calculate final address
  const address = module.base + offset;

  console.log(
    `Decoded library expression: "${expression}" -> Module: ${module.modulename || module.name} (base: 0x${module.base.toString(16)}) + offset: 0x${offset.toString(16)} = 0x${address.toString(16)}`
  );

  return address;
}

/**
 * Parses a library@function+offset expression
 * Supports formats:
 * - "lib.so@func + 0x10" or "lib.so@func+0x10"
 * - "lib.so@func" (without offset)
 */
function decodeLibraryFunctionExpression(
  expression: string,
  modules: ModuleInfo[]
): number | null {
  // Match patterns:
  // "lib.so@func + 0x10" -> lib.so, func, 0x10
  // "lib.so@func" -> lib.so, func, null
  const matchWithOffset = expression.match(
    /^(.+?)@(.+?)\s*\+\s*(0x[0-9a-fA-F]+|\d+)$/
  );
  const matchWithoutOffset = expression.match(/^(.+?)@([^+\s]+)$/);

  let libraryName: string;
  let funcName: string;
  let offset = 0;

  if (matchWithOffset) {
    libraryName = matchWithOffset[1].trim();
    funcName = matchWithOffset[2].trim();
    const offsetStr = matchWithOffset[3].trim();
    if (offsetStr.startsWith("0x") || offsetStr.startsWith("0X")) {
      offset = parseInt(offsetStr, 16);
    } else {
      offset = parseInt(offsetStr, 10);
    }
    if (isNaN(offset)) offset = 0;
  } else if (matchWithoutOffset) {
    libraryName = matchWithoutOffset[1].trim();
    funcName = matchWithoutOffset[2].trim();
  } else {
    return null;
  }

  // Find the module
  const module = modules.find((mod) => {
    const fullModuleName = mod.modulename || mod.name || "";
    const fileName = fullModuleName.split(/[\/\\]/).pop() || fullModuleName;
    return (
      fullModuleName.toLowerCase() === libraryName.toLowerCase() ||
      fileName.toLowerCase() === libraryName.toLowerCase() ||
      fullModuleName.toLowerCase().includes(libraryName.toLowerCase()) ||
      fileName.toLowerCase().includes(libraryName.toLowerCase())
    );
  });

  if (!module) {
    console.warn(`Module "${libraryName}" not found`);
    return null;
  }

  // Search for the function in the symbol cache
  const symbolCache = useUIStore.getState().globalSymbolCache;
  const symbol = symbolCache.symbols.find((s) => {
    // Check if the symbol belongs to this module and matches the function name
    if (s.moduleBase !== module.base) return false;
    // Case-insensitive partial match for function name
    return (
      s.name.toLowerCase().includes(funcName.toLowerCase()) ||
      funcName.toLowerCase().includes(s.name.toLowerCase())
    );
  });

  if (symbol) {
    const address = symbol.address + offset;
    console.log(
      `Decoded library@function expression: "${expression}" -> ${symbol.name} @ 0x${symbol.address.toString(16)} + 0x${offset.toString(16)} = 0x${address.toString(16)}`
    );
    return address;
  }

  console.warn(`Function "${funcName}" not found in module "${libraryName}"`);
  return null;
}

/**
 * Converts a numeric address to a library+offset expression if the address is within a loaded module
 * @param address - The numeric address to encode
 * @param modules - Array of loaded modules with their base addresses
 * @param preferShortName - If true, use only the filename instead of full path (default: true)
 * @returns The library+offset expression or null if address is not within any module
 */
export function encodeAddressToLibraryExpression(
  address: number,
  modules: ModuleInfo[],
  preferShortName: boolean = true
): string | null {
  if (!modules || modules.length === 0 || isNaN(address)) {
    return null;
  }

  // Find the module that contains this address
  for (const module of modules) {
    const moduleBase = module.base;
    const moduleEnd = moduleBase + module.size;

    if (address >= moduleBase && address < moduleEnd) {
      const offset = address - moduleBase;
      const fullModuleName = module.modulename || module.name || "unknown";

      // Use short filename if preferred
      const displayName = preferShortName
        ? fullModuleName.split(/[\/\\]/).pop() || fullModuleName
        : fullModuleName;

      const expression = `${displayName} + 0x${offset.toString(16)}`;

      console.log(
        `Encoded address 0x${address.toString(16)} to library expression: "${expression}"`
      );

      return expression;
    }
  }

  // Address is not within any module
  return null;
}

/**
 * Normalizes an address string to a consistent hex format (0xABCDEF)
 * Supports both direct addresses and library+offset expressions
 * @param addressStr - The address string to normalize (hex address or library+offset)
 * @param modules - Array of loaded modules (required for library+offset expressions)
 * @returns Normalized hex address string or null if invalid
 */
export function normalizeAddressString(
  addressStr: string,
  modules?: ModuleInfo[]
): string | null {
  if (!addressStr) {
    return null;
  }

  const trimmed = addressStr.trim();

  // Check if it's a library+offset or library@function expression
  if (trimmed.includes("+") || trimmed.includes("@")) {
    if (!modules || modules.length === 0) {
      console.warn(
        "Cannot parse library expression without module information"
      );
      return null;
    }

    const decodedAddress = decodeLibraryExpression(trimmed, modules);
    if (decodedAddress === null) {
      return null;
    }

    return `0x${decodedAddress.toString(16)}`;
  }

  // Parse as direct address (hex or decimal)
  let address: number;
  if (trimmed.startsWith("0x") || trimmed.startsWith("0X")) {
    address = parseInt(trimmed, 16);
  } else if (/^\d+$/.test(trimmed)) {
    // All digits - treat as decimal
    address = parseInt(trimmed, 10);
  } else if (/^[0-9a-fA-F]+$/.test(trimmed)) {
    // All hex digits without 0x prefix
    address = parseInt(trimmed, 16);
  } else {
    return null;
  }

  if (isNaN(address)) {
    return null;
  }

  return `0x${address.toString(16)}`;
}

/**
 * Checks if a string is a valid library+offset or library@function+offset expression
 * @param expression - The string to check
 * @returns true if the string matches a supported pattern
 */
export function isLibraryExpression(expression: string): boolean {
  if (!expression) {
    return false;
  }

  const trimmed = expression.trim();
  // Match patterns:
  // - "LibraryName + 0xOffset" or "LibraryName+0xOffset" (library + offset)
  // - "lib.so@func + 0x10" or "lib.so@func+0x10" (library@function + offset)
  // - "lib.so@func" (library@function without offset)
  return (
    /^.+?\s*\+\s*(0x[0-9a-fA-F]+|\d+)$/.test(trimmed) ||
    /^.+?@[^+\s]+(\s*\+\s*(0x[0-9a-fA-F]+|\d+))?$/.test(trimmed)
  );
}

/**
 * 非同期版: library@function+offset形式をパースしてアドレスに変換
 * シンボルがキャッシュにない場合はオンデマンドでロードする
 */
async function decodeLibraryFunctionExpressionAsync(
  expression: string,
  modules: ModuleInfo[],
  serverInfo: { ip: string; port: number }
): Promise<number | null> {
  const matchWithOffset = expression.match(
    /^(.+?)@(.+?)\s*\+\s*(0x[0-9a-fA-F]+|\d+)$/
  );
  const matchWithoutOffset = expression.match(/^(.+?)@([^+\s]+)$/);

  let libraryName: string;
  let funcName: string;
  let offset = 0;

  if (matchWithOffset) {
    libraryName = matchWithOffset[1].trim();
    funcName = matchWithOffset[2].trim();
    const offsetStr = matchWithOffset[3].trim();
    if (offsetStr.startsWith("0x") || offsetStr.startsWith("0X")) {
      offset = parseInt(offsetStr, 16);
    } else {
      offset = parseInt(offsetStr, 10);
    }
    if (isNaN(offset)) offset = 0;
  } else if (matchWithoutOffset) {
    libraryName = matchWithoutOffset[1].trim();
    funcName = matchWithoutOffset[2].trim();
  } else {
    return null;
  }

  // Find the module
  const module = modules.find((mod) => {
    const fullModuleName = mod.modulename || mod.name || "";
    const fileName = fullModuleName.split(/[\/\\]/).pop() || fullModuleName;
    return (
      fullModuleName.toLowerCase() === libraryName.toLowerCase() ||
      fileName.toLowerCase() === libraryName.toLowerCase() ||
      fullModuleName.toLowerCase().includes(libraryName.toLowerCase()) ||
      fileName.toLowerCase().includes(libraryName.toLowerCase())
    );
  });

  if (!module) {
    console.warn(`Module "${libraryName}" not found`);
    return null;
  }

  const globalSymbolCache = useUIStore.getState().globalSymbolCache;
  if (!globalSymbolCache.loadedModules.has(module.base)) {
    console.log(`[addressEncoder] Loading symbols for ${libraryName}...`);
    await loadModuleSymbolsOnDemand(serverInfo, module);
  }

  const updatedCache = useUIStore.getState().globalSymbolCache;
  const symbol = updatedCache.symbols.find((s) => {
    if (s.moduleBase !== module.base) return false;
    return (
      s.name.toLowerCase().includes(funcName.toLowerCase()) ||
      funcName.toLowerCase().includes(s.name.toLowerCase())
    );
  });

  if (symbol) {
    const address = symbol.address + offset;
    console.log(
      `Decoded library@function expression: "${expression}" -> ${symbol.name} @ 0x${symbol.address.toString(16)} + 0x${offset.toString(16)} = 0x${address.toString(16)}`
    );
    return address;
  }

  console.warn(`Function "${funcName}" not found in module "${libraryName}"`);
  return null;
}

export async function decodeLibraryExpressionAsync(
  expression: string,
  modules: ModuleInfo[],
  serverInfo: { ip: string; port: number }
): Promise<number | null> {
  if (!expression || !modules || modules.length === 0) {
    return null;
  }

  const trimmed = expression.trim();

  // Check if it's a library@function format
  const atIndex = trimmed.indexOf("@");
  const plusIndex = trimmed.indexOf("+");

  if (atIndex > 0 && (plusIndex === -1 || atIndex < plusIndex)) {
    return decodeLibraryFunctionExpressionAsync(trimmed, modules, serverInfo);
  }

  return decodeLibraryExpression(trimmed, modules);
}

/**
 * @param addressStr
 * @param modules
 * @param serverInfo
 * @returns
 */
export async function normalizeAddressStringAsync(
  addressStr: string,
  modules: ModuleInfo[],
  serverInfo: { ip: string; port: number }
): Promise<string | null> {
  if (!addressStr) {
    return null;
  }

  const trimmed = addressStr.trim();

  // Check if it's a library+offset or library@function expression
  if (trimmed.includes("+") || trimmed.includes("@")) {
    if (!modules || modules.length === 0) {
      console.warn(
        "Cannot parse library expression without module information"
      );
      return null;
    }

    const decodedAddress = await decodeLibraryExpressionAsync(
      trimmed,
      modules,
      serverInfo
    );
    if (decodedAddress === null) {
      return null;
    }

    return `0x${decodedAddress.toString(16)}`;
  }

  return normalizeAddressString(addressStr, modules);
}

```

`src/client/src/utils/arm64BranchPredictor.ts`:

```ts
/**
 * ARM64 Branch Predictor
 * Predicts the next instruction address based on current instruction and register state.
 * Supports ~95% of common branch patterns.
 */

export interface RegisterState {
  // General purpose registers X0-X30
  x0?: bigint;
  x1?: bigint;
  x2?: bigint;
  x3?: bigint;
  x4?: bigint;
  x5?: bigint;
  x6?: bigint;
  x7?: bigint;
  x8?: bigint;
  x9?: bigint;
  x10?: bigint;
  x11?: bigint;
  x12?: bigint;
  x13?: bigint;
  x14?: bigint;
  x15?: bigint;
  x16?: bigint;
  x17?: bigint;
  x18?: bigint;
  x19?: bigint;
  x20?: bigint;
  x21?: bigint;
  x22?: bigint;
  x23?: bigint;
  x24?: bigint;
  x25?: bigint;
  x26?: bigint;
  x27?: bigint;
  x28?: bigint;
  x29?: bigint; // FP
  x30?: bigint; // LR
  sp?: bigint;
  pc?: bigint;
  // NZCV flags
  n?: boolean; // Negative
  z?: boolean; // Zero
  c?: boolean; // Carry
  v?: boolean; // Overflow
}

export interface BranchPrediction {
  type:
    | "unconditional" // Always taken (B, BL)
    | "conditional" // Depends on flags (B.cond)
    | "register" // Depends on register value (BR, BLR, RET)
    | "compare" // Depends on register comparison (CBZ, CBNZ, TBZ, TBNZ)
    | "fallthrough" // Not a branch, continue to next instruction
    | "unknown"; // Cannot determine
  targetAddress: bigint | null; // Predicted target (null if unknown)
  fallthrough: bigint; // Address of next sequential instruction
  willBranch: boolean | null; // null if unknown
  confidence: "high" | "medium" | "low";
  reason: string;
}

// Condition codes for B.cond
type ConditionCode =
  | "eq"
  | "ne"
  | "cs"
  | "hs"
  | "cc"
  | "lo"
  | "mi"
  | "pl"
  | "vs"
  | "vc"
  | "hi"
  | "ls"
  | "ge"
  | "lt"
  | "gt"
  | "le"
  | "al"
  | "nv";

/**
 * Evaluate ARM64 condition code based on NZCV flags
 */
function evaluateCondition(
  cond: ConditionCode,
  n: boolean,
  z: boolean,
  c: boolean,
  v: boolean
): boolean {
  switch (cond) {
    case "eq":
      return z === true; // Equal (Z=1)
    case "ne":
      return z === false; // Not equal (Z=0)
    case "cs":
    case "hs":
      return c === true; // Carry set / Unsigned higher or same (C=1)
    case "cc":
    case "lo":
      return c === false; // Carry clear / Unsigned lower (C=0)
    case "mi":
      return n === true; // Minus / Negative (N=1)
    case "pl":
      return n === false; // Plus / Positive or zero (N=0)
    case "vs":
      return v === true; // Overflow (V=1)
    case "vc":
      return v === false; // No overflow (V=0)
    case "hi":
      return c === true && z === false; // Unsigned higher (C=1 && Z=0)
    case "ls":
      return c === false || z === true; // Unsigned lower or same (C=0 || Z=1)
    case "ge":
      return n === v; // Signed greater or equal (N=V)
    case "lt":
      return n !== v; // Signed less than (N!=V)
    case "gt":
      return z === false && n === v; // Signed greater than (Z=0 && N=V)
    case "le":
      return z === true || n !== v; // Signed less or equal (Z=1 || N!=V)
    case "al":
    case "nv":
      return true; // Always
    default:
      return true;
  }
}

/**
 * Parse register name to get register value from state
 */
function getRegisterValue(
  regName: string,
  state: RegisterState
): bigint | null {
  const name = regName.toLowerCase().trim();

  // Handle W registers (32-bit, lower half of X)
  if (name.startsWith("w")) {
    const xReg = "x" + name.slice(1);
    const value = getRegisterValue(xReg, state);
    return value !== null ? value & BigInt(0xffffffff) : null;
  }

  // Handle X registers
  if (name === "x0") return state.x0 ?? null;
  if (name === "x1") return state.x1 ?? null;
  if (name === "x2") return state.x2 ?? null;
  if (name === "x3") return state.x3 ?? null;
  if (name === "x4") return state.x4 ?? null;
  if (name === "x5") return state.x5 ?? null;
  if (name === "x6") return state.x6 ?? null;
  if (name === "x7") return state.x7 ?? null;
  if (name === "x8") return state.x8 ?? null;
  if (name === "x9") return state.x9 ?? null;
  if (name === "x10") return state.x10 ?? null;
  if (name === "x11") return state.x11 ?? null;
  if (name === "x12") return state.x12 ?? null;
  if (name === "x13") return state.x13 ?? null;
  if (name === "x14") return state.x14 ?? null;
  if (name === "x15") return state.x15 ?? null;
  if (name === "x16" || name === "ip0") return state.x16 ?? null;
  if (name === "x17" || name === "ip1") return state.x17 ?? null;
  if (name === "x18") return state.x18 ?? null;
  if (name === "x19") return state.x19 ?? null;
  if (name === "x20") return state.x20 ?? null;
  if (name === "x21") return state.x21 ?? null;
  if (name === "x22") return state.x22 ?? null;
  if (name === "x23") return state.x23 ?? null;
  if (name === "x24") return state.x24 ?? null;
  if (name === "x25") return state.x25 ?? null;
  if (name === "x26") return state.x26 ?? null;
  if (name === "x27") return state.x27 ?? null;
  if (name === "x28") return state.x28 ?? null;
  if (name === "x29" || name === "fp") return state.x29 ?? null;
  if (name === "x30" || name === "lr") return state.x30 ?? null;
  if (name === "sp" || name === "xzr") return state.sp ?? null;
  if (name === "pc") return state.pc ?? null;
  if (name === "xzr" || name === "wzr") return BigInt(0);

  return null;
}

/**
 * Parse immediate value from operand string
 * Handles formats: #0, #0x10, 0, 0x10, etc.
 */
function parseImmediate(str: string): bigint | null {
  let trimmed = str.trim();
  // Remove # prefix if present
  if (trimmed.startsWith("#")) {
    trimmed = trimmed.slice(1);
  }
  try {
    if (trimmed.startsWith("0x") || trimmed.startsWith("0X")) {
      return BigInt(trimmed);
    }
    // Parse as decimal
    const num = parseInt(trimmed, 10);
    if (!isNaN(num)) {
      return BigInt(num);
    }
    return BigInt(trimmed);
  } catch {
    return null;
  }
}

/**
 * Parse address from operand (e.g., "0x100004000" or "#0x100")
 */
function parseAddress(str: string): bigint | null {
  const trimmed = str.trim().replace("#", "");
  try {
    if (trimmed.startsWith("0x") || trimmed.startsWith("0X")) {
      return BigInt(trimmed);
    }
    // Try parsing as decimal
    const num = parseInt(trimmed, 10);
    if (!isNaN(num)) {
      return BigInt(num);
    }
  } catch {
    return null;
  }
  return null;
}

/**
 * Predict the next instruction address for ARM64
 */
export function predictNextInstruction(
  currentAddress: bigint,
  opcode: string,
  operands: string,
  state: RegisterState
): BranchPrediction {
  const fallthrough = currentAddress + BigInt(4); // ARM64 instructions are 4 bytes
  const op = opcode.toLowerCase().trim();
  const ops = operands.trim();

  // ========== Unconditional branches ==========

  // B label - Unconditional branch
  if (op === "b" && !ops.includes(",")) {
    const target = parseAddress(ops);
    if (target !== null) {
      return {
        type: "unconditional",
        targetAddress: target,
        fallthrough,
        willBranch: true,
        confidence: "high",
        reason: "Unconditional branch (B)",
      };
    }
  }

  // BL label - Branch with link (call)
  if (op === "bl") {
    const target = parseAddress(ops);
    if (target !== null) {
      return {
        type: "unconditional",
        targetAddress: target,
        fallthrough,
        willBranch: true,
        confidence: "high",
        reason: "Branch with link (BL)",
      };
    }
  }

  // ========== Conditional branches (B.cond) ==========

  const condMatch = op.match(/^b\.(\w+)$/);
  if (condMatch) {
    const cond = condMatch[1] as ConditionCode;
    const target = parseAddress(ops);

    // Check if we have NZCV flags
    if (
      state.n !== undefined &&
      state.z !== undefined &&
      state.c !== undefined &&
      state.v !== undefined
    ) {
      const willBranch = evaluateCondition(
        cond,
        state.n,
        state.z,
        state.c,
        state.v
      );
      return {
        type: "conditional",
        targetAddress: target,
        fallthrough,
        willBranch,
        confidence: "high",
        reason: `Conditional branch B.${cond.toUpperCase()} - ${willBranch ? "will branch" : "will fallthrough"}`,
      };
    } else {
      return {
        type: "conditional",
        targetAddress: target,
        fallthrough,
        willBranch: null,
        confidence: "low",
        reason: `Conditional branch B.${cond.toUpperCase()} - NZCV flags unknown`,
      };
    }
  }

  // ========== Compare and branch ==========

  // CBZ Rt, label - Compare and branch if zero
  if (op === "cbz") {
    const parts = ops.split(",").map((s) => s.trim());
    if (parts.length >= 2) {
      const regValue = getRegisterValue(parts[0], state);
      const target = parseAddress(parts[1]);

      if (regValue !== null) {
        const willBranch = regValue === BigInt(0);
        return {
          type: "compare",
          targetAddress: target,
          fallthrough,
          willBranch,
          confidence: "high",
          reason: `CBZ ${parts[0]}=${regValue} - ${willBranch ? "zero, will branch" : "non-zero, fallthrough"}`,
        };
      } else {
        return {
          type: "compare",
          targetAddress: target,
          fallthrough,
          willBranch: null,
          confidence: "low",
          reason: `CBZ - register ${parts[0]} value unknown`,
        };
      }
    }
  }

  // CBNZ Rt, label - Compare and branch if not zero
  if (op === "cbnz") {
    const parts = ops.split(",").map((s) => s.trim());
    if (parts.length >= 2) {
      const regValue = getRegisterValue(parts[0], state);
      const target = parseAddress(parts[1]);

      if (regValue !== null) {
        const willBranch = regValue !== BigInt(0);
        return {
          type: "compare",
          targetAddress: target,
          fallthrough,
          willBranch,
          confidence: "high",
          reason: `CBNZ ${parts[0]}=${regValue} - ${willBranch ? "non-zero, will branch" : "zero, fallthrough"}`,
        };
      } else {
        return {
          type: "compare",
          targetAddress: target,
          fallthrough,
          willBranch: null,
          confidence: "low",
          reason: `CBNZ - register ${parts[0]} value unknown`,
        };
      }
    }
  }

  // TBZ Rt, #imm, label - Test bit and branch if zero
  if (op === "tbz") {
    const parts = ops.split(",").map((s) => s.trim());
    if (parts.length >= 3) {
      const regValue = getRegisterValue(parts[0], state);
      const bitPos = parseImmediate(parts[1]);
      const target = parseAddress(parts[2]);

      if (regValue !== null && bitPos !== null) {
        const bitValue = (regValue >> bitPos) & BigInt(1);
        const willBranch = bitValue === BigInt(0);
        return {
          type: "compare",
          targetAddress: target,
          fallthrough,
          willBranch,
          confidence: "high",
          reason: `TBZ ${parts[0]}[${bitPos}]=${bitValue} - ${willBranch ? "bit is 0, will branch" : "bit is 1, fallthrough"}`,
        };
      } else {
        return {
          type: "compare",
          targetAddress: target,
          fallthrough,
          willBranch: null,
          confidence: "low",
          reason: `TBZ - register or bit position unknown`,
        };
      }
    }
  }

  // TBNZ Rt, #imm, label - Test bit and branch if not zero
  if (op === "tbnz") {
    const parts = ops.split(",").map((s) => s.trim());
    if (parts.length >= 3) {
      const regValue = getRegisterValue(parts[0], state);
      const bitPos = parseImmediate(parts[1]);
      const target = parseAddress(parts[2]);

      if (regValue !== null && bitPos !== null) {
        const bitValue = (regValue >> bitPos) & BigInt(1);
        const willBranch = bitValue !== BigInt(0);
        return {
          type: "compare",
          targetAddress: target,
          fallthrough,
          willBranch,
          confidence: "high",
          reason: `TBNZ ${parts[0]}[${bitPos}]=${bitValue} - ${willBranch ? "bit is 1, will branch" : "bit is 0, fallthrough"}`,
        };
      } else {
        return {
          type: "compare",
          targetAddress: target,
          fallthrough,
          willBranch: null,
          confidence: "low",
          reason: `TBNZ - register or bit position unknown`,
        };
      }
    }
  }

  // ========== Register indirect branches ==========

  // BR Xn - Branch to register
  if (op === "br") {
    const regValue = getRegisterValue(ops, state);
    if (regValue !== null) {
      return {
        type: "register",
        targetAddress: regValue,
        fallthrough,
        willBranch: true,
        confidence: "high",
        reason: `BR ${ops}=0x${regValue.toString(16)}`,
      };
    } else {
      return {
        type: "register",
        targetAddress: null,
        fallthrough,
        willBranch: true,
        confidence: "low",
        reason: `BR - register ${ops} value unknown`,
      };
    }
  }

  // BLR Xn - Branch with link to register
  if (op === "blr") {
    const regValue = getRegisterValue(ops, state);
    if (regValue !== null) {
      return {
        type: "register",
        targetAddress: regValue,
        fallthrough,
        willBranch: true,
        confidence: "high",
        reason: `BLR ${ops}=0x${regValue.toString(16)}`,
      };
    } else {
      return {
        type: "register",
        targetAddress: null,
        fallthrough,
        willBranch: true,
        confidence: "low",
        reason: `BLR - register ${ops} value unknown`,
      };
    }
  }

  // RET {Xn} - Return (default LR/X30)
  if (op === "ret") {
    const regName = ops.trim() || "x30";
    const regValue = getRegisterValue(regName, state);
    if (regValue !== null) {
      return {
        type: "register",
        targetAddress: regValue,
        fallthrough,
        willBranch: true,
        confidence: "high",
        reason: `RET to ${regName}=0x${regValue.toString(16)}`,
      };
    } else {
      return {
        type: "register",
        targetAddress: null,
        fallthrough,
        willBranch: true,
        confidence: "low",
        reason: `RET - LR value unknown`,
      };
    }
  }

  // RETAA/RETAB - Return with pointer authentication
  if (op === "retaa" || op === "retab") {
    const regValue = state.x30 ?? null;
    if (regValue !== null) {
      // Note: PAC stripping would be needed for exact address
      return {
        type: "register",
        targetAddress: regValue,
        fallthrough,
        willBranch: true,
        confidence: "medium",
        reason: `${op.toUpperCase()} to LR=0x${regValue.toString(16)} (PAC may affect address)`,
      };
    } else {
      return {
        type: "register",
        targetAddress: null,
        fallthrough,
        willBranch: true,
        confidence: "low",
        reason: `${op.toUpperCase()} - LR value unknown`,
      };
    }
  }

  // BRAA/BRAB/BLRAA/BLRAB - Branch with pointer authentication
  if (
    op === "braa" ||
    op === "brab" ||
    op === "blraa" ||
    op === "blrab" ||
    op === "braaz" ||
    op === "brabz" ||
    op === "blraaz" ||
    op === "blrabz"
  ) {
    const parts = ops.split(",").map((s) => s.trim());
    const regValue = getRegisterValue(parts[0], state);
    if (regValue !== null) {
      return {
        type: "register",
        targetAddress: regValue,
        fallthrough,
        willBranch: true,
        confidence: "medium",
        reason: `${op.toUpperCase()} to ${parts[0]}=0x${regValue.toString(16)} (PAC may affect address)`,
      };
    } else {
      return {
        type: "register",
        targetAddress: null,
        fallthrough,
        willBranch: true,
        confidence: "low",
        reason: `${op.toUpperCase()} - register value unknown`,
      };
    }
  }

  // ========== Exception/system instructions that change control flow ==========

  if (op === "svc" || op === "hvc" || op === "smc") {
    return {
      type: "unknown",
      targetAddress: null,
      fallthrough,
      willBranch: null,
      confidence: "low",
      reason: `System call (${op.toUpperCase()}) - target depends on kernel`,
    };
  }

  if (op === "brk" || op === "hlt") {
    return {
      type: "unknown",
      targetAddress: null,
      fallthrough,
      willBranch: null,
      confidence: "low",
      reason: `Debug break (${op.toUpperCase()}) - execution may not continue`,
    };
  }

  if (op === "eret") {
    return {
      type: "register",
      targetAddress: null,
      fallthrough,
      willBranch: true,
      confidence: "low",
      reason: "Exception return - target in ELR_ELx",
    };
  }

  // ========== Not a branch instruction ==========

  return {
    type: "fallthrough",
    targetAddress: null,
    fallthrough,
    willBranch: false,
    confidence: "high",
    reason: "Not a branch instruction",
  };
}

/**
 * Convert register map from debug API to RegisterState
 */
export function convertRegistersToState(
  registers: Record<string, string | number | bigint>
): RegisterState {
  const state: RegisterState = {};

  for (const [key, value] of Object.entries(registers)) {
    const name = key.toLowerCase();
    let bigValue: bigint;

    if (typeof value === "bigint") {
      bigValue = value;
    } else if (typeof value === "number") {
      bigValue = BigInt(value);
    } else if (typeof value === "string") {
      try {
        if (value.startsWith("0x") || value.startsWith("0X")) {
          bigValue = BigInt(value);
        } else {
          bigValue = BigInt(value);
        }
      } catch {
        continue;
      }
    } else {
      continue;
    }

    // Map register names
    if (name === "x0" || name === "w0") state.x0 = bigValue;
    else if (name === "x1" || name === "w1") state.x1 = bigValue;
    else if (name === "x2" || name === "w2") state.x2 = bigValue;
    else if (name === "x3" || name === "w3") state.x3 = bigValue;
    else if (name === "x4" || name === "w4") state.x4 = bigValue;
    else if (name === "x5" || name === "w5") state.x5 = bigValue;
    else if (name === "x6" || name === "w6") state.x6 = bigValue;
    else if (name === "x7" || name === "w7") state.x7 = bigValue;
    else if (name === "x8" || name === "w8") state.x8 = bigValue;
    else if (name === "x9" || name === "w9") state.x9 = bigValue;
    else if (name === "x10" || name === "w10") state.x10 = bigValue;
    else if (name === "x11" || name === "w11") state.x11 = bigValue;
    else if (name === "x12" || name === "w12") state.x12 = bigValue;
    else if (name === "x13" || name === "w13") state.x13 = bigValue;
    else if (name === "x14" || name === "w14") state.x14 = bigValue;
    else if (name === "x15" || name === "w15") state.x15 = bigValue;
    else if (name === "x16" || name === "w16" || name === "ip0")
      state.x16 = bigValue;
    else if (name === "x17" || name === "w17" || name === "ip1")
      state.x17 = bigValue;
    else if (name === "x18" || name === "w18") state.x18 = bigValue;
    else if (name === "x19" || name === "w19") state.x19 = bigValue;
    else if (name === "x20" || name === "w20") state.x20 = bigValue;
    else if (name === "x21" || name === "w21") state.x21 = bigValue;
    else if (name === "x22" || name === "w22") state.x22 = bigValue;
    else if (name === "x23" || name === "w23") state.x23 = bigValue;
    else if (name === "x24" || name === "w24") state.x24 = bigValue;
    else if (name === "x25" || name === "w25") state.x25 = bigValue;
    else if (name === "x26" || name === "w26") state.x26 = bigValue;
    else if (name === "x27" || name === "w27") state.x27 = bigValue;
    else if (name === "x28" || name === "w28") state.x28 = bigValue;
    else if (name === "x29" || name === "w29" || name === "fp")
      state.x29 = bigValue;
    else if (name === "x30" || name === "w30" || name === "lr")
      state.x30 = bigValue;
    else if (name === "sp") state.sp = bigValue;
    else if (name === "pc") state.pc = bigValue;
    // CPSR/NZCV flags
    else if (name === "cpsr" || name === "nzcv" || name === "pstate") {
      // Extract NZCV from bits 31-28
      const flags = Number(bigValue >> BigInt(28)) & 0xf;
      state.n = (flags & 0x8) !== 0;
      state.z = (flags & 0x4) !== 0;
      state.c = (flags & 0x2) !== 0;
      state.v = (flags & 0x1) !== 0;
    }
  }

  return state;
}

/**
 * Check if an opcode is a branch instruction
 */
export function isBranchInstruction(opcode: string): boolean {
  const op = opcode.toLowerCase().trim();

  // Direct branches
  if (op === "b" || op === "bl") return true;

  // Conditional branches
  if (op.startsWith("b.")) return true;

  // Compare and branch
  if (op === "cbz" || op === "cbnz") return true;
  if (op === "tbz" || op === "tbnz") return true;

  // Register indirect
  if (op === "br" || op === "blr" || op === "ret") return true;
  if (op === "retaa" || op === "retab") return true;
  if (op === "braa" || op === "brab" || op === "blraa" || op === "blrab")
    return true;
  if (op === "braaz" || op === "brabz" || op === "blraaz" || op === "blrabz")
    return true;

  // System
  if (op === "svc" || op === "hvc" || op === "smc") return true;
  if (op === "brk" || op === "hlt" || op === "eret") return true;

  return false;
}

```

`src/client/src/utils/constants.ts`:

```ts
import { styled, alpha } from "@mui/material/styles";
import { Box, Button, IconButton, Typography } from "@mui/material";
import { darkTheme, borderColors, customBackgrounds } from "./theme";

// Original styled components from page-old.tsx
export const AppGrid = styled(Box, {
  shouldForwardProp: (prop) =>
    prop !== "sidebarWidth" &&
    prop !== "showRegisters" &&
    prop !== "registerWidth",
})<{ sidebarWidth?: number; showRegisters?: boolean; registerWidth?: number }>(
  ({ sidebarWidth = 240, showRegisters = false, registerWidth = 300 }) => {
    if (showRegisters && sidebarWidth > 0) {
      return {
        height: "100vh",
        display: "grid",
        gridTemplateRows: "40px auto 1fr 22px",
        gridTemplateColumns: `${sidebarWidth}px 1fr ${registerWidth}px`,
        gridTemplateAreas: `
        "header header header"
        "toolbar toolbar toolbar"
        "sidebar main registers"
        "status status status"
      `,
        "--sidebar-width": `${sidebarWidth}px`,
      };
    } else if (showRegisters) {
      return {
        height: "100vh",
        display: "grid",
        gridTemplateRows: "40px auto 1fr 22px",
        gridTemplateColumns: `1fr ${registerWidth}px`,
        gridTemplateAreas: `
        "header header"
        "toolbar toolbar"
        "main registers"
        "status status"
      `,
        "--sidebar-width": "0px",
        // Remove transitions to prevent redraw issues
        // transition: 'grid-template-columns 0.3s ease-in-out',
      };
    } else if (sidebarWidth > 0) {
      return {
        height: "100vh",
        display: "grid",
        gridTemplateRows: "40px auto 1fr 22px",
        gridTemplateColumns: `${sidebarWidth}px 1fr`,
        gridTemplateAreas: `
        "header header"
        "toolbar toolbar"
        "sidebar main"
        "status status"
      `,
        "--sidebar-width": `${sidebarWidth}px`,
      };
    } else {
      return {
        height: "100vh",
        display: "grid",
        gridTemplateRows: "40px auto 1fr 22px",
        gridTemplateColumns: "1fr",
        gridTemplateAreas: `
        "header"
        "toolbar"
        "main"
        "status"
      `,
        "--sidebar-width": "0px",
      };
    }
  }
);

export const Header = styled(Box)(() => ({
  gridArea: "header",
  backgroundColor: darkTheme.palette.background.paper,
  borderBottom: `1px solid ${borderColors.main}`,
  display: "flex",
  alignItems: "center",
  justifyContent: "space-between",
  height: "100%",
  padding: "0 10px",
}));

export const ToolbarArea = styled(Box)(() => ({
  gridArea: "toolbar",
  backgroundColor: darkTheme.palette.background.paper,
  borderBottom: `1px solid ${borderColors.main}`,
}));

export const HeaderLeft = styled(Box)(() => ({
  display: "flex",
  alignItems: "center",
}));

export const HeaderRight = styled(Box)(() => ({
  display: "flex",
  alignItems: "center",
  gap: "8px",
}));

export const Logo = styled(Typography)(() => ({
  fontWeight: "bold",
  fontSize: "18px",
  marginRight: "20px",
  color: darkTheme.palette.primary.main,
  letterSpacing: "-0.5px",
  display: "flex",
  alignItems: "center",
  lineHeight: 1,
  "& .MuiSvgIcon-root": {
    marginRight: "8px",
    fontSize: "22px",
    display: "flex",
    alignItems: "center",
  },
}));

export const ToolbarButton = styled(Button)(({ theme }) => ({
  backgroundColor: "transparent",
  color: theme.palette.text.primary,
  padding: "4px 8px",
  borderRadius: "4px",
  minWidth: "auto",
  "&:hover": {
    backgroundColor: customBackgrounds.hover,
  },
  "&.active": {
    backgroundColor: alpha(theme.palette.primary.main, 0.15),
    color: theme.palette.primary.main,
  },
}));

export const HeaderIconButton = styled(IconButton)(({ theme }) => ({
  color: theme.palette.text.primary,
  "&:hover": {
    backgroundColor: customBackgrounds.hover,
  },
}));

export const Sidebar = styled(Box)(() => ({
  gridArea: "sidebar",
  backgroundColor: darkTheme.palette.background.paper,
  borderRight: `1px solid ${borderColors.main}`,
  overflow: "auto",
  "&::-webkit-scrollbar": {
    width: "8px",
  },
  "&::-webkit-scrollbar-track": {
    background: darkTheme.palette.background.default,
  },
  "&::-webkit-scrollbar-thumb": {
    background: borderColors.main,
    borderRadius: "4px",
  },
  "&::-webkit-scrollbar-thumb:hover": {
    background: "#5a5a5e",
  },
}));

export const PanelHeader = styled(Box)(() => ({
  padding: "8px 10px",
  backgroundColor: customBackgrounds.light,
  borderBottom: `1px solid ${borderColors.main}`,
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
}));

export const MainContent = styled(Box)(() => ({
  gridArea: "main",
  display: "flex",
  flexDirection: "column",
  overflow: "hidden",
  backgroundColor: darkTheme.palette.background.default,
}));

export const TabContent = styled(Box)(() => ({
  flex: 1,
  overflow: "hidden",
  display: "flex",
  flexDirection: "column",
}));

export const StatusBar = styled(Box)(() => ({
  gridArea: "status",
  backgroundColor: darkTheme.palette.background.paper,
  borderTop: `1px solid ${borderColors.main}`,
  display: "flex",
  alignItems: "center",
  justifyContent: "space-between",
  padding: "0 10px",
  fontSize: "12px",
  color: darkTheme.palette.text.primary,
}));

export const RegisterViewContainer = styled(Box)(({ theme }) => ({
  gridArea: "registers",
  width: "300px",
  height: "100%",
  backgroundColor: theme.palette.background.paper,
  borderLeft: `1px solid ${borderColors.main}`,
  display: "flex",
  flexDirection: "column",
  overflow: "hidden",
  transition: "transform 0.2s ease-in-out",
}));

export const RegisterArea = styled(Box)(() => ({
  gridArea: "registers",
  backgroundColor: darkTheme.palette.background.paper,
  borderLeft: `1px solid ${borderColors.main}`,
  overflow: "auto",
  "&::-webkit-scrollbar": {
    width: "8px",
  },
  "&::-webkit-scrollbar-track": {
    background: darkTheme.palette.background.default,
  },
  "&::-webkit-scrollbar-thumb": {
    background: borderColors.main,
    borderRadius: "4px",
  },
  "&::-webkit-scrollbar-thumb:hover": {
    background: "#5a5a5e",
  },
}));

// Backwards compatibility aliases
export const HeaderBox = Header;
export const SidebarArea = Sidebar;
export const MainArea = MainContent;
export const StatusBarLeft = styled(Box)(() => ({
  display: "flex",
  alignItems: "center",
  gap: "12px",
}));

export const StatusBarRight = styled(Box)(() => ({
  display: "flex",
  alignItems: "center",
  gap: "12px",
}));

// Constants
export const SAMPLE_FUNCTIONS = [
  "initialize",
  "processInput",
  "calculateResult",
  "validateData",
  "handleError",
  "cleanup",
];

export const ENDIANNESS_OPTIONS = ["little", "big"];
export const CODEPAGE_OPTIONS = ["ASCII", "UTF-8", "UTF-16", "Shift-JIS"];

// Color constants
export const COLORS = {
  breakpoint: "#ff5252",
  currentLine: "#4caf50",
  modified: "#2196f3",
  highlighted: "#ff9800",
  jump: "#9c27b0",
  call: "#3f51b5",
} as const;

// Tab panel props interface
export interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

```

`src/client/src/utils/theme.ts`:

```ts
import { createTheme } from "@mui/material/styles";

// Original dark theme from page-old.tsx
export const darkTheme = createTheme({
  palette: {
    mode: "dark",
    primary: {
      main: "#4fc1ff",
      light: "#7fd1ff",
      dark: "#3a92c2",
      contrastText: "#ffffff",
    },
    secondary: {
      main: "#89d185",
      light: "#a7dea4",
      dark: "#6bb067",
      contrastText: "#ffffff",
    },
    error: {
      main: "#f44747",
      light: "#f77070",
      dark: "#c53636",
    },
    warning: {
      main: "#dcdcaa",
      light: "#e5e5c3",
      dark: "#b8b887",
    },
    info: {
      main: "#c586c0",
      light: "#d4a0d0",
      dark: "#a66ca1",
    },
    success: {
      main: "#89d185",
      light: "#a7dea4",
      dark: "#6bb067",
    },
    text: {
      primary: "#d4d4d4",
      secondary: "#9b9b9b",
      disabled: "#6c6c6c",
    },
    background: {
      default: "#1e1e1e",
      paper: "#171717",
    },
    divider: "#3e3e42",
    action: {
      active: "#ffffff",
      hover: "rgba(255, 255, 255, 0.1)",
      selected: "rgba(255, 255, 255, 0.08)",
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      focus: "rgba(255, 255, 255, 0.12)",
    },
  },
  typography: {
    fontFamily: "'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif",
    fontSize: 12,
    button: {
      textTransform: "none",
      fontWeight: 400,
    },
  },
  shape: {
    borderRadius: 4,
  },
  components: {
    MuiCssBaseline: {
      styleOverrides: {
        body: {
          margin: 0,
          padding: 0,
          boxSizing: "border-box",
          height: "100vh",
          overflow: "hidden",
          lineHeight: "normal",
          fontSize: "12px",
          "& *": {
            boxSizing: "border-box",
          },
          "&::-webkit-scrollbar": {
            width: "10px",
            height: "10px",
          },
          "&::-webkit-scrollbar-track": {
            background: "#1e1e1e",
          },
          "&::-webkit-scrollbar-thumb": {
            background: "#3e3e42",
            borderRadius: "4px",
            "&:hover": {
              background: "#5a5a5e",
            },
          },
          "&::-webkit-scrollbar-corner": {
            background: "#1e1e1e",
          },
        },
        "*": {
          "&::-webkit-scrollbar": {
            width: "10px",
            height: "10px",
          },
          "&::-webkit-scrollbar-track": {
            background: "#1e1e1e",
            borderRadius: "4px",
          },
          "&::-webkit-scrollbar-thumb": {
            background: "#3e3e42",
            borderRadius: "4px",
            "&:hover": {
              background: "#5a5a5e",
            },
            "&:active": {
              background: "#6a6a6e",
            },
          },
          "&::-webkit-scrollbar-corner": {
            background: "#1e1e1e",
          },
        },
      },
    },
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: "none",
          fontSize: "12px",
          padding: "4px 8px",
          minWidth: "auto",
        },
        containedPrimary: {
          backgroundColor: "#4fc1ff",
          "&:hover": {
            backgroundColor: "#3a92c2",
          },
        },
      },
    },
    MuiTab: {
      styleOverrides: {
        root: {
          textTransform: "none",
          fontSize: "12px",
          minWidth: "auto",
          padding: "6px 12px",
          minHeight: "32px",
        },
      },
    },
    MuiTabs: {
      styleOverrides: {
        root: {
          minHeight: "32px",
          "& .MuiTabs-indicator": {
            backgroundColor: "#4fc1ff",
          },
        },
      },
    },
    MuiIconButton: {
      styleOverrides: {
        root: {
          padding: "4px",
          fontSize: "16px",
        },
      },
    },
    MuiTooltip: {
      styleOverrides: {
        tooltip: {
          fontSize: "11px",
          backgroundColor: "#171717",
          border: "1px solid #3e3e42",
        },
      },
    },
    MuiTableCell: {
      styleOverrides: {
        root: {
          fontSize: "12px",
          padding: "4px 8px",
          borderBottom: "1px solid #3e3e42",
        },
        head: {
          fontWeight: 600,
          backgroundColor: "#171717",
        },
      },
    },
  },
});

// Theme colors for styled components
export const borderColors = {
  main: "#3e3e42",
  light: "#5a5a5e",
};

export const customBackgrounds = {
  hover: "rgba(255, 255, 255, 0.1)",
  selected: "rgba(255, 255, 255, 0.08)",
  light: "rgba(255, 255, 255, 0.05)",
};

```

`src/client/src/utils/traceFileParser.ts`:

```ts
/**
 * Trace File Parser for DynaDbg Binary Trace Format
 *
 * File Format:
 * - Header (32 bytes): Magic, Version, Entry Count, Architecture
 * - Entries (1920 bytes each): Timestamp, PC, Registers, Instruction, Memory
 */

// Magic number for validation
export const TRACE_FILE_MAGIC = "DYNATRC\0";
export const TRACE_FILE_VERSION = 1;
export const TRACE_ARCH_ARM64 = 1;
export const TRACE_ARCH_X86_64 = 2;

// Size constants
export const TRACE_HEADER_SIZE = 32;
export const TRACE_ENTRY_SIZE = 1920;
export const TRACE_INSTRUCTION_SIZE = 64;
export const TRACE_MEMORY_DUMP_SIZE = 256;
export const TRACE_MEMORY_REG_COUNT = 6;

// Header structure
export interface TraceFileHeader {
  magic: string;
  version: number;
  entryCount: number;
  architecture: number;
}

// ARM64 trace entry
export interface TraceEntryArm64 {
  timestamp: bigint;
  pc: bigint;
  x: bigint[]; // x0-x29
  lr: bigint;
  sp: bigint;
  cpsr: bigint;
  instructionLength: number;
  instruction: string;
  memory: Uint8Array[]; // Memory at x0-x5 (256 bytes each)
}

// Converted trace entry for UI
export interface ParsedTraceEntry {
  id: number;
  timestamp: number;
  address: string;
  registers: Record<string, string>;
  instruction: string;
  opcode: string;
  operands: string;
  memory: { register: string; data: Uint8Array }[];
  isCall: boolean;
  isReturn: boolean;
  depth: number;
}

/**
 * Parse trace file header
 */
export function parseTraceHeader(data: ArrayBuffer): TraceFileHeader | null {
  if (data.byteLength < TRACE_HEADER_SIZE) {
    console.error("Trace file too small for header");
    return null;
  }

  const view = new DataView(data);
  const decoder = new TextDecoder("utf-8");

  // Read magic (8 bytes)
  const magicBytes = new Uint8Array(data, 0, 8);
  const magic = decoder.decode(magicBytes);

  // Validate magic (check without null terminator)
  if (!magic.startsWith("DYNATRC")) {
    console.error("Invalid trace file magic:", magic);
    return null;
  }

  // Read version (4 bytes, little-endian)
  const version = view.getUint32(8, true);
  if (version !== TRACE_FILE_VERSION) {
    console.error("Unsupported trace file version:", version);
    return null;
  }

  // Read entry count (4 bytes, little-endian)
  const entryCount = view.getUint32(12, true);

  // Read architecture (4 bytes, little-endian)
  const architecture = view.getUint32(16, true);

  return {
    magic,
    version,
    entryCount,
    architecture,
  };
}

/**
 * Parse a single ARM64 trace entry
 */
export function parseTraceEntryArm64(
  data: ArrayBuffer,
  offset: number
): TraceEntryArm64 | null {
  if (data.byteLength < offset + TRACE_ENTRY_SIZE) {
    console.error("Insufficient data for trace entry at offset:", offset);
    return null;
  }

  const view = new DataView(data, offset, TRACE_ENTRY_SIZE);
  const decoder = new TextDecoder("utf-8");

  let pos = 0;

  // Timestamp (8 bytes)
  const timestamp = view.getBigUint64(pos, true);
  pos += 8;

  // PC (8 bytes)
  const pc = view.getBigUint64(pos, true);
  pos += 8;

  // x0-x29 (30 * 8 = 240 bytes)
  const x: bigint[] = [];
  for (let i = 0; i < 30; i++) {
    x.push(view.getBigUint64(pos, true));
    pos += 8;
  }

  // LR (8 bytes)
  const lr = view.getBigUint64(pos, true);
  pos += 8;

  // SP (8 bytes)
  const sp = view.getBigUint64(pos, true);
  pos += 8;

  // CPSR (8 bytes)
  const cpsr = view.getBigUint64(pos, true);
  pos += 8;

  // Instruction length (4 bytes)
  const instructionLength = view.getUint32(pos, true);
  pos += 4;

  // Instruction string (64 bytes)
  const instructionBytes = new Uint8Array(
    data,
    offset + pos,
    TRACE_INSTRUCTION_SIZE
  );
  // Find null terminator
  let nullPos = instructionBytes.indexOf(0);
  if (nullPos === -1) nullPos = TRACE_INSTRUCTION_SIZE;
  const instruction = decoder.decode(instructionBytes.slice(0, nullPos));
  pos += TRACE_INSTRUCTION_SIZE;

  // Memory at x0-x5 (6 * 256 = 1536 bytes)
  const memory: Uint8Array[] = [];
  for (let i = 0; i < TRACE_MEMORY_REG_COUNT; i++) {
    const memData = new Uint8Array(data, offset + pos, TRACE_MEMORY_DUMP_SIZE);
    memory.push(memData.slice()); // Copy the data
    pos += TRACE_MEMORY_DUMP_SIZE;
  }

  return {
    timestamp,
    pc,
    x,
    lr,
    sp,
    cpsr,
    instructionLength,
    instruction,
    memory,
  };
}

/**
 * Parse instruction string to extract opcode and operands
 * Format from disassembler: "0xADDRESS|BYTECODE|OPCODE OPERANDS"
 */
function parseInstruction(instruction: string): {
  opcode: string;
  operands: string;
} {
  if (!instruction) {
    return { opcode: "", operands: "" };
  }

  // Try to parse disassembler output format
  const parts = instruction.split("|");
  if (parts.length >= 3) {
    const opcodeOperands = parts[2].trim();
    const spaceIndex = opcodeOperands.indexOf(" ");
    if (spaceIndex !== -1) {
      return {
        opcode: opcodeOperands.substring(0, spaceIndex),
        operands: opcodeOperands.substring(spaceIndex + 1).trim(),
      };
    }
    return { opcode: opcodeOperands, operands: "" };
  }

  // Fallback: treat as raw instruction
  const spaceIndex = instruction.indexOf(" ");
  if (spaceIndex !== -1) {
    return {
      opcode: instruction.substring(0, spaceIndex),
      operands: instruction.substring(spaceIndex + 1).trim(),
    };
  }

  return { opcode: instruction, operands: "" };
}

/**
 * Check if instruction is a call/branch
 */
function isCallInstruction(opcode: string): boolean {
  const callOpcodes = ["bl", "blr", "blx"];
  return callOpcodes.includes(opcode.toLowerCase());
}

/**
 * Check if instruction is a return
 */
function isReturnInstruction(opcode: string): boolean {
  const retOpcodes = ["ret", "eret"];
  return retOpcodes.includes(opcode.toLowerCase());
}

/**
 * Convert raw entry to UI-friendly format
 */
export function convertToUIEntry(
  entry: TraceEntryArm64,
  id: number
): ParsedTraceEntry {
  const { opcode, operands } = parseInstruction(entry.instruction);

  // Build registers object
  const registers: Record<string, string> = {};
  for (let i = 0; i < 30; i++) {
    registers[`x${i}`] = `0x${entry.x[i].toString(16)}`;
  }
  registers.lr = `0x${entry.lr.toString(16)}`;
  registers.sp = `0x${entry.sp.toString(16)}`;
  registers.pc = `0x${entry.pc.toString(16)}`;
  registers.cpsr = `0x${entry.cpsr.toString(16)}`;
  registers.fp = `0x${entry.x[29].toString(16)}`; // fp = x29

  // Build memory array for x0-x5
  const memory = entry.memory.slice(0, 6).map((data, i) => ({
    register: `x${i}`,
    data,
  }));

  return {
    id,
    timestamp: Number(entry.timestamp),
    address: `0x${entry.pc.toString(16)}`,
    registers,
    instruction: entry.instruction,
    opcode,
    operands,
    memory,
    isCall: isCallInstruction(opcode),
    isReturn: isReturnInstruction(opcode),
    depth: 0, // Can be calculated based on call/return tracking
  };
}

/**
 * Parse entire trace file and return all entries
 */
export function parseTraceFile(data: ArrayBuffer): {
  header: TraceFileHeader;
  entries: ParsedTraceEntry[];
} | null {
  const header = parseTraceHeader(data);
  if (!header) {
    return null;
  }

  const entries: ParsedTraceEntry[] = [];
  let depth = 0;

  for (let i = 0; i < header.entryCount; i++) {
    const offset = TRACE_HEADER_SIZE + i * TRACE_ENTRY_SIZE;
    const rawEntry = parseTraceEntryArm64(data, offset);

    if (!rawEntry) {
      console.warn(`Failed to parse entry ${i} at offset ${offset}`);
      continue;
    }

    const entry = convertToUIEntry(rawEntry, i + 1);

    // Track call depth
    if (entry.isReturn && depth > 0) {
      depth--;
    }
    entry.depth = depth;
    if (entry.isCall) {
      depth++;
    }

    entries.push(entry);
  }

  return { header, entries };
}

/**
 * Format memory dump as hex string with optional ASCII display
 */
export function formatMemoryDump(
  data: Uint8Array,
  bytesPerLine: number = 16
): string {
  const lines: string[] = [];

  for (let i = 0; i < data.length; i += bytesPerLine) {
    const chunk = data.slice(i, Math.min(i + bytesPerLine, data.length));

    // Hex representation
    const hex = Array.from(chunk)
      .map((b) => b.toString(16).padStart(2, "0"))
      .join(" ");

    // ASCII representation
    const ascii = Array.from(chunk)
      .map((b) => (b >= 32 && b < 127 ? String.fromCharCode(b) : "."))
      .join("");

    lines.push(
      `${i.toString(16).padStart(4, "0")}  ${hex.padEnd(bytesPerLine * 3)}  ${ascii}`
    );
  }

  return lines.join("\n");
}

```

`src/client/src/vite-env.d.ts`:

```ts
/// <reference types="vite/client" />

// アセットファイルの型定義
declare module '*.png' {
  const src: string;
  export default src;
}

declare module '*.jpg' {
  const src: string;
  export default src;
}

declare module '*.jpeg' {
  const src: string;
  export default src;
}

declare module '*.mp4' {
  const src: string;
  export default src;
}

declare module '*.webm' {
  const src: string;
  export default src;
}

declare module '*.svg' {
  const src: string;
  export default src;
}

```

`src/client/tsconfig.json`:

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}

```

`src/client/vite.config.ts`:

```ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

// @ts-expect-error process is a nodejs global
const host = process.env.TAURI_DEV_HOST;

// https://vitejs.dev/config/
export default defineConfig(async () => ({
  plugins: [react()],

  // Vite options tailored for Tauri development and only applied in `tauri dev` or `tauri build`
  //
  // 1. prevent vite from obscuring rust errors
  clearScreen: false,
  // 2. tauri expects a fixed port, fail if that port is not available
  server: {
    port: 1420,
    strictPort: true,
    host: host || false,
    hmr: host
      ? {
          protocol: "ws",
          host,
          port: 1421,
        }
      : undefined,
    watch: {
      // 3. tell vite to ignore watching `src-tauri`
      ignored: ["**/src-tauri/**"],
    },
  },

  assetsInclude: ["**/*.mp4", "**/*.webm", "**/*.png", "**/*.jpg", "**/*.jpeg"],

  build: {
    assetsInlineLimit: 0,
  },
}));

```

`src/client/yarn.lock`:

```lock
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1


"@ampproject/remapping@^2.2.0":
  version "2.3.0"
  resolved "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz"
  integrity sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==
  dependencies:
    "@jridgewell/gen-mapping" "^0.3.5"
    "@jridgewell/trace-mapping" "^0.3.24"

"@babel/code-frame@^7.0.0", "@babel/code-frame@^7.27.1":
  version "7.27.1"
  resolved "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.27.1.tgz"
  integrity sha512-cjQ7ZlQ0Mv3b47hABuTevyTuYN4i+loJKGeV9flcCgIK37cCXRh+L1bd3iBHlynerhQ7BhCkn2BPbQUL+rGqFg==
  dependencies:
    "@babel/helper-validator-identifier" "^7.27.1"
    js-tokens "^4.0.0"
    picocolors "^1.1.1"

"@babel/compat-data@^7.27.2":
  version "7.28.0"
  resolved "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.28.0.tgz"
  integrity sha512-60X7qkglvrap8mn1lh2ebxXdZYtUcpd7gsmy9kLaBJ4i/WdY8PqTSdxyA8qraikqKQK5C1KRBKXqznrVapyNaw==

"@babel/core@^7.0.0", "@babel/core@^7.0.0-0", "@babel/core@^7.28.0":
  version "7.28.0"
  resolved "https://registry.npmjs.org/@babel/core/-/core-7.28.0.tgz"
  integrity sha512-UlLAnTPrFdNGoFtbSXwcGFQBtQZJCNjaN6hQNP3UPvuNXT1i82N26KL3dZeIpNalWywr9IuQuncaAfUaS1g6sQ==
  dependencies:
    "@ampproject/remapping" "^2.2.0"
    "@babel/code-frame" "^7.27.1"
    "@babel/generator" "^7.28.0"
    "@babel/helper-compilation-targets" "^7.27.2"
    "@babel/helper-module-transforms" "^7.27.3"
    "@babel/helpers" "^7.27.6"
    "@babel/parser" "^7.28.0"
    "@babel/template" "^7.27.2"
    "@babel/traverse" "^7.28.0"
    "@babel/types" "^7.28.0"
    convert-source-map "^2.0.0"
    debug "^4.1.0"
    gensync "^1.0.0-beta.2"
    json5 "^2.2.3"
    semver "^6.3.1"

"@babel/generator@^7.28.0":
  version "7.28.0"
  resolved "https://registry.npmjs.org/@babel/generator/-/generator-7.28.0.tgz"
  integrity sha512-lJjzvrbEeWrhB4P3QBsH7tey117PjLZnDbLiQEKjQ/fNJTjuq4HSqgFA+UNSwZT8D7dxxbnuSBMsa1lrWzKlQg==
  dependencies:
    "@babel/parser" "^7.28.0"
    "@babel/types" "^7.28.0"
    "@jridgewell/gen-mapping" "^0.3.12"
    "@jridgewell/trace-mapping" "^0.3.28"
    jsesc "^3.0.2"

"@babel/helper-compilation-targets@^7.27.2":
  version "7.27.2"
  resolved "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.27.2.tgz"
  integrity sha512-2+1thGUUWWjLTYTHZWK1n8Yga0ijBz1XAhUXcKy81rd5g6yh7hGqMp45v7cadSbEHc9G3OTv45SyneRN3ps4DQ==
  dependencies:
    "@babel/compat-data" "^7.27.2"
    "@babel/helper-validator-option" "^7.27.1"
    browserslist "^4.24.0"
    lru-cache "^5.1.1"
    semver "^6.3.1"

"@babel/helper-globals@^7.28.0":
  version "7.28.0"
  resolved "https://registry.npmjs.org/@babel/helper-globals/-/helper-globals-7.28.0.tgz"
  integrity sha512-+W6cISkXFa1jXsDEdYA8HeevQT/FULhxzR99pxphltZcVaugps53THCeiWA8SguxxpSp3gKPiuYfSWopkLQ4hw==

"@babel/helper-module-imports@^7.16.7", "@babel/helper-module-imports@^7.27.1":
  version "7.27.1"
  resolved "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.27.1.tgz"
  integrity sha512-0gSFWUPNXNopqtIPQvlD5WgXYI5GY2kP2cCvoT8kczjbfcfuIljTbcWrulD1CIPIX2gt1wghbDy08yE1p+/r3w==
  dependencies:
    "@babel/traverse" "^7.27.1"
    "@babel/types" "^7.27.1"

"@babel/helper-module-transforms@^7.27.3":
  version "7.27.3"
  resolved "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.27.3.tgz"
  integrity sha512-dSOvYwvyLsWBeIRyOeHXp5vPj5l1I011r52FM1+r1jCERv+aFXYk4whgQccYEGYxK2H3ZAIA8nuPkQ0HaUo3qg==
  dependencies:
    "@babel/helper-module-imports" "^7.27.1"
    "@babel/helper-validator-identifier" "^7.27.1"
    "@babel/traverse" "^7.27.3"

"@babel/helper-plugin-utils@^7.27.1":
  version "7.27.1"
  resolved "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.27.1.tgz"
  integrity sha512-1gn1Up5YXka3YYAHGKpbideQ5Yjf1tDa9qYcgysz+cNCXukyLl6DjPXhD3VRwSb8c0J9tA4b2+rHEZtc6R0tlw==

"@babel/helper-string-parser@^7.27.1":
  version "7.27.1"
  resolved "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz"
  integrity sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==

"@babel/helper-validator-identifier@^7.27.1":
  version "7.27.1"
  resolved "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.27.1.tgz"
  integrity sha512-D2hP9eA+Sqx1kBZgzxZh0y1trbuU+JoDkiEwqhQ36nodYqJwyEIhPSdMNd7lOm/4io72luTPWH20Yda0xOuUow==

"@babel/helper-validator-option@^7.27.1":
  version "7.27.1"
  resolved "https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.27.1.tgz"
  integrity sha512-YvjJow9FxbhFFKDSuFnVCe2WxXk1zWc22fFePVNEaWJEu8IrZVlda6N0uHwzZrUM1il7NC9Mlp4MaJYbYd9JSg==

"@babel/helpers@^7.27.6":
  version "7.27.6"
  resolved "https://registry.npmjs.org/@babel/helpers/-/helpers-7.27.6.tgz"
  integrity sha512-muE8Tt8M22638HU31A3CgfSUciwz1fhATfoVai05aPXGor//CdWDCbnlY1yvBPo07njuVOCNGCSp/GTt12lIug==
  dependencies:
    "@babel/template" "^7.27.2"
    "@babel/types" "^7.27.6"

"@babel/parser@^7.1.0", "@babel/parser@^7.20.7", "@babel/parser@^7.27.2", "@babel/parser@^7.28.0":
  version "7.28.0"
  resolved "https://registry.npmjs.org/@babel/parser/-/parser-7.28.0.tgz"
  integrity sha512-jVZGvOxOuNSsuQuLRTh13nU0AogFlw32w/MT+LV6D3sP5WdbW61E77RnkbaO2dUvmPAYrBDJXGn5gGS6tH4j8g==
  dependencies:
    "@babel/types" "^7.28.0"

"@babel/plugin-transform-react-jsx-self@^7.27.1":
  version "7.27.1"
  resolved "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-self/-/plugin-transform-react-jsx-self-7.27.1.tgz"
  integrity sha512-6UzkCs+ejGdZ5mFFC/OCUrv028ab2fp1znZmCZjAOBKiBK2jXD1O+BPSfX8X2qjJ75fZBMSnQn3Rq2mrBJK2mw==
  dependencies:
    "@babel/helper-plugin-utils" "^7.27.1"

"@babel/plugin-transform-react-jsx-source@^7.27.1":
  version "7.27.1"
  resolved "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-source/-/plugin-transform-react-jsx-source-7.27.1.tgz"
  integrity sha512-zbwoTsBruTeKB9hSq73ha66iFeJHuaFkUbwvqElnygoNbj/jHRsSeokowZFN3CZ64IvEqcmmkVe89OPXc7ldAw==
  dependencies:
    "@babel/helper-plugin-utils" "^7.27.1"

"@babel/runtime@^7.12.5", "@babel/runtime@^7.18.3", "@babel/runtime@^7.27.6", "@babel/runtime@^7.5.5", "@babel/runtime@^7.8.7":
  version "7.27.6"
  resolved "https://registry.npmjs.org/@babel/runtime/-/runtime-7.27.6.tgz"
  integrity sha512-vbavdySgbTTrmFE+EsiqUTzlOr5bzlnJtUv9PynGCAKvfQqjIXbvFdumPM/GxMDfyuGMJaJAU6TO4zc1Jf1i8Q==

"@babel/template@^7.27.2":
  version "7.27.2"
  resolved "https://registry.npmjs.org/@babel/template/-/template-7.27.2.tgz"
  integrity sha512-LPDZ85aEJyYSd18/DkjNh4/y1ntkE5KwUHWTiqgRxruuZL2F1yuHligVHLvcHY2vMHXttKFpJn6LwfI7cw7ODw==
  dependencies:
    "@babel/code-frame" "^7.27.1"
    "@babel/parser" "^7.27.2"
    "@babel/types" "^7.27.1"

"@babel/traverse@^7.27.1", "@babel/traverse@^7.27.3", "@babel/traverse@^7.28.0":
  version "7.28.0"
  resolved "https://registry.npmjs.org/@babel/traverse/-/traverse-7.28.0.tgz"
  integrity sha512-mGe7UK5wWyh0bKRfupsUchrQGqvDbZDbKJw+kcRGSmdHVYrv+ltd0pnpDTVpiTqnaBru9iEvA8pz8W46v0Amwg==
  dependencies:
    "@babel/code-frame" "^7.27.1"
    "@babel/generator" "^7.28.0"
    "@babel/helper-globals" "^7.28.0"
    "@babel/parser" "^7.28.0"
    "@babel/template" "^7.27.2"
    "@babel/types" "^7.28.0"
    debug "^4.3.1"

"@babel/types@^7.0.0", "@babel/types@^7.20.7", "@babel/types@^7.27.1", "@babel/types@^7.27.6", "@babel/types@^7.28.0":
  version "7.28.1"
  resolved "https://registry.npmjs.org/@babel/types/-/types-7.28.1.tgz"
  integrity sha512-x0LvFTekgSX+83TI28Y9wYPUfzrnl2aT5+5QLnO6v7mSJYtEEevuDRN0F0uSHRk1G1IWZC43o00Y0xDDrpBGPQ==
  dependencies:
    "@babel/helper-string-parser" "^7.27.1"
    "@babel/helper-validator-identifier" "^7.27.1"

"@emotion/babel-plugin@^11.13.5":
  version "11.13.5"
  resolved "https://registry.npmjs.org/@emotion/babel-plugin/-/babel-plugin-11.13.5.tgz"
  integrity sha512-pxHCpT2ex+0q+HH91/zsdHkw/lXd468DIN2zvfvLtPKLLMo6gQj7oLObq8PhkrxOZb/gGCq03S3Z7PDhS8pduQ==
  dependencies:
    "@babel/helper-module-imports" "^7.16.7"
    "@babel/runtime" "^7.18.3"
    "@emotion/hash" "^0.9.2"
    "@emotion/memoize" "^0.9.0"
    "@emotion/serialize" "^1.3.3"
    babel-plugin-macros "^3.1.0"
    convert-source-map "^1.5.0"
    escape-string-regexp "^4.0.0"
    find-root "^1.1.0"
    source-map "^0.5.7"
    stylis "4.2.0"

"@emotion/cache@^11.14.0":
  version "11.14.0"
  resolved "https://registry.npmjs.org/@emotion/cache/-/cache-11.14.0.tgz"
  integrity sha512-L/B1lc/TViYk4DcpGxtAVbx0ZyiKM5ktoIyafGkH6zg/tj+mA+NE//aPYKG0k8kCHSHVJrpLpcAlOBEXQ3SavA==
  dependencies:
    "@emotion/memoize" "^0.9.0"
    "@emotion/sheet" "^1.4.0"
    "@emotion/utils" "^1.4.2"
    "@emotion/weak-memoize" "^0.4.0"
    stylis "4.2.0"

"@emotion/hash@^0.9.2":
  version "0.9.2"
  resolved "https://registry.npmjs.org/@emotion/hash/-/hash-0.9.2.tgz"
  integrity sha512-MyqliTZGuOm3+5ZRSaaBGP3USLw6+EGykkwZns2EPC5g8jJ4z9OrdZY9apkl3+UP9+sdz76YYkwCKP5gh8iY3g==

"@emotion/is-prop-valid@^1.3.0":
  version "1.3.1"
  resolved "https://registry.npmjs.org/@emotion/is-prop-valid/-/is-prop-valid-1.3.1.tgz"
  integrity sha512-/ACwoqx7XQi9knQs/G0qKvv5teDMhD7bXYns9N/wM8ah8iNb8jZ2uNO0YOgiq2o2poIvVtJS2YALasQuMSQ7Kw==
  dependencies:
    "@emotion/memoize" "^0.9.0"

"@emotion/memoize@^0.9.0":
  version "0.9.0"
  resolved "https://registry.npmjs.org/@emotion/memoize/-/memoize-0.9.0.tgz"
  integrity sha512-30FAj7/EoJ5mwVPOWhAyCX+FPfMDrVecJAM+Iw9NRoSl4BBAQeqj4cApHHUXOVvIPgLVDsCFoz/hGD+5QQD1GQ==

"@emotion/react@^11.0.0-rc.0", "@emotion/react@^11.14.0", "@emotion/react@^11.4.1", "@emotion/react@^11.5.0":
  version "11.14.0"
  resolved "https://registry.npmjs.org/@emotion/react/-/react-11.14.0.tgz"
  integrity sha512-O000MLDBDdk/EohJPFUqvnp4qnHeYkVP5B0xEG0D/L7cOKP9kefu2DXn8dj74cQfsEzUqh+sr1RzFqiL1o+PpA==
  dependencies:
    "@babel/runtime" "^7.18.3"
    "@emotion/babel-plugin" "^11.13.5"
    "@emotion/cache" "^11.14.0"
    "@emotion/serialize" "^1.3.3"
    "@emotion/use-insertion-effect-with-fallbacks" "^1.2.0"
    "@emotion/utils" "^1.4.2"
    "@emotion/weak-memoize" "^0.4.0"
    hoist-non-react-statics "^3.3.1"

"@emotion/serialize@^1.3.3":
  version "1.3.3"
  resolved "https://registry.npmjs.org/@emotion/serialize/-/serialize-1.3.3.tgz"
  integrity sha512-EISGqt7sSNWHGI76hC7x1CksiXPahbxEOrC5RjmFRJTqLyEK9/9hZvBbiYn70dw4wuwMKiEMCUlR6ZXTSWQqxA==
  dependencies:
    "@emotion/hash" "^0.9.2"
    "@emotion/memoize" "^0.9.0"
    "@emotion/unitless" "^0.10.0"
    "@emotion/utils" "^1.4.2"
    csstype "^3.0.2"

"@emotion/sheet@^1.4.0":
  version "1.4.0"
  resolved "https://registry.npmjs.org/@emotion/sheet/-/sheet-1.4.0.tgz"
  integrity sha512-fTBW9/8r2w3dXWYM4HCB1Rdp8NLibOw2+XELH5m5+AkWiL/KqYX6dc0kKYlaYyKjrQ6ds33MCdMPEwgs2z1rqg==

"@emotion/styled@^11.14.1", "@emotion/styled@^11.3.0":
  version "11.14.1"
  resolved "https://registry.npmjs.org/@emotion/styled/-/styled-11.14.1.tgz"
  integrity sha512-qEEJt42DuToa3gurlH4Qqc1kVpNq8wO8cJtDzU46TjlzWjDlsVyevtYCRijVq3SrHsROS+gVQ8Fnea108GnKzw==
  dependencies:
    "@babel/runtime" "^7.18.3"
    "@emotion/babel-plugin" "^11.13.5"
    "@emotion/is-prop-valid" "^1.3.0"
    "@emotion/serialize" "^1.3.3"
    "@emotion/use-insertion-effect-with-fallbacks" "^1.2.0"
    "@emotion/utils" "^1.4.2"

"@emotion/unitless@^0.10.0":
  version "0.10.0"
  resolved "https://registry.npmjs.org/@emotion/unitless/-/unitless-0.10.0.tgz"
  integrity sha512-dFoMUuQA20zvtVTuxZww6OHoJYgrzfKM1t52mVySDJnMSEa08ruEvdYQbhvyu6soU+NeLVd3yKfTfT0NeV6qGg==

"@emotion/use-insertion-effect-with-fallbacks@^1.2.0":
  version "1.2.0"
  resolved "https://registry.npmjs.org/@emotion/use-insertion-effect-with-fallbacks/-/use-insertion-effect-with-fallbacks-1.2.0.tgz"
  integrity sha512-yJMtVdH59sxi/aVJBpk9FQq+OR8ll5GT8oWd57UpeaKEVGab41JWaCFA7FRLoMLloOZF/c/wsPoe+bfGmRKgDg==

"@emotion/utils@^1.4.2":
  version "1.4.2"
  resolved "https://registry.npmjs.org/@emotion/utils/-/utils-1.4.2.tgz"
  integrity sha512-3vLclRofFziIa3J2wDh9jjbkUz9qk5Vi3IZ/FSTKViB0k+ef0fPV7dYrUIugbgupYDx7v9ud/SjrtEP8Y4xLoA==

"@emotion/weak-memoize@^0.4.0":
  version "0.4.0"
  resolved "https://registry.npmjs.org/@emotion/weak-memoize/-/weak-memoize-0.4.0.tgz"
  integrity sha512-snKqtPW01tN0ui7yu9rGv69aJXr/a/Ywvl11sUjNtEcRc+ng/mQriFL0wLXMef74iHa/EkftbDzU9F8iFbH+zg==

"@esbuild/darwin-arm64@0.25.8":
  version "0.25.8"
  resolved "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.25.8.tgz"
  integrity sha512-Jw0mxgIaYX6R8ODrdkLLPwBqHTtYHJSmzzd+QeytSugzQ0Vg4c5rDky5VgkoowbZQahCbsv1rT1KW72MPIkevw==

"@jridgewell/gen-mapping@^0.3.12", "@jridgewell/gen-mapping@^0.3.5":
  version "0.3.12"
  resolved "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.12.tgz"
  integrity sha512-OuLGC46TjB5BbN1dH8JULVVZY4WTdkF7tV9Ys6wLL1rubZnCMstOhNHueU5bLCrnRuDhKPDM4g6sw4Bel5Gzqg==
  dependencies:
    "@jridgewell/sourcemap-codec" "^1.5.0"
    "@jridgewell/trace-mapping" "^0.3.24"

"@jridgewell/resolve-uri@^3.1.0":
  version "3.1.2"
  resolved "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz"
  integrity sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==

"@jridgewell/sourcemap-codec@^1.4.14", "@jridgewell/sourcemap-codec@^1.5.0":
  version "1.5.4"
  resolved "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.4.tgz"
  integrity sha512-VT2+G1VQs/9oz078bLrYbecdZKs912zQlkelYpuf+SXF+QvZDYJlbx/LSx+meSAwdDFnF8FVXW92AVjjkVmgFw==

"@jridgewell/trace-mapping@^0.3.24", "@jridgewell/trace-mapping@^0.3.28":
  version "0.3.29"
  resolved "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.29.tgz"
  integrity sha512-uw6guiW/gcAGPDhLmd77/6lW8QLeiV5RUTsAX46Db6oLhGaVj4lhnPwb184s1bkc8kdVg/+h988dro8GRDpmYQ==
  dependencies:
    "@jridgewell/resolve-uri" "^3.1.0"
    "@jridgewell/sourcemap-codec" "^1.4.14"

"@mui/core-downloads-tracker@^7.2.0":
  version "7.2.0"
  resolved "https://registry.npmjs.org/@mui/core-downloads-tracker/-/core-downloads-tracker-7.2.0.tgz"
  integrity sha512-d49s7kEgI5iX40xb2YPazANvo7Bx0BLg/MNRwv+7BVpZUzXj1DaVCKlQTDex3gy/0jsCb4w7AY2uH4t4AJvSog==

"@mui/icons-material@^7.2.0":
  version "7.2.0"
  resolved "https://registry.npmjs.org/@mui/icons-material/-/icons-material-7.2.0.tgz"
  integrity sha512-gRCspp3pfjHQyTmSOmYw7kUQTd9Udpdan4R8EnZvqPeoAtHnPzkvjBrBqzKaoAbbBp5bGF7BcD18zZJh4nwu0A==
  dependencies:
    "@babel/runtime" "^7.27.6"

"@mui/material@^7.2.0":
  version "7.2.0"
  resolved "https://registry.npmjs.org/@mui/material/-/material-7.2.0.tgz"
  integrity sha512-NTuyFNen5Z2QY+I242MDZzXnFIVIR6ERxo7vntFi9K1wCgSwvIl0HcAO2OOydKqqKApE6omRiYhpny1ZhGuH7Q==
  dependencies:
    "@babel/runtime" "^7.27.6"
    "@mui/core-downloads-tracker" "^7.2.0"
    "@mui/system" "^7.2.0"
    "@mui/types" "^7.4.4"
    "@mui/utils" "^7.2.0"
    "@popperjs/core" "^2.11.8"
    "@types/react-transition-group" "^4.4.12"
    clsx "^2.1.1"
    csstype "^3.1.3"
    prop-types "^15.8.1"
    react-is "^19.1.0"
    react-transition-group "^4.4.5"

"@mui/private-theming@^7.2.0":
  version "7.2.0"
  resolved "https://registry.npmjs.org/@mui/private-theming/-/private-theming-7.2.0.tgz"
  integrity sha512-y6N1Yt3T5RMxVFnCh6+zeSWBuQdNDm5/UlM0EAYZzZR/1u+XKJWYQmbpx4e+F+1EpkYi3Nk8KhPiQDi83M3zIw==
  dependencies:
    "@babel/runtime" "^7.27.6"
    "@mui/utils" "^7.2.0"
    prop-types "^15.8.1"

"@mui/styled-engine@^7.2.0":
  version "7.2.0"
  resolved "https://registry.npmjs.org/@mui/styled-engine/-/styled-engine-7.2.0.tgz"
  integrity sha512-yq08xynbrNYcB1nBcW9Fn8/h/iniM3ewRguGJXPIAbHvxEF7Pz95kbEEOAAhwzxMX4okhzvHmk0DFuC5ayvgIQ==
  dependencies:
    "@babel/runtime" "^7.27.6"
    "@emotion/cache" "^11.14.0"
    "@emotion/serialize" "^1.3.3"
    "@emotion/sheet" "^1.4.0"
    csstype "^3.1.3"
    prop-types "^15.8.1"

"@mui/system@^7.2.0":
  version "7.2.0"
  resolved "https://registry.npmjs.org/@mui/system/-/system-7.2.0.tgz"
  integrity sha512-PG7cm/WluU6RAs+gNND2R9vDwNh+ERWxPkqTaiXQJGIFAyJ+VxhyKfzpdZNk0z0XdmBxxi9KhFOpgxjehf/O0A==
  dependencies:
    "@babel/runtime" "^7.27.6"
    "@mui/private-theming" "^7.2.0"
    "@mui/styled-engine" "^7.2.0"
    "@mui/types" "^7.4.4"
    "@mui/utils" "^7.2.0"
    clsx "^2.1.1"
    csstype "^3.1.3"
    prop-types "^15.8.1"

"@mui/types@^7.4.4":
  version "7.4.4"
  resolved "https://registry.npmjs.org/@mui/types/-/types-7.4.4.tgz"
  integrity sha512-p63yhbX52MO/ajXC7hDHJA5yjzJekvWD3q4YDLl1rSg+OXLczMYPvTuSuviPRCgRX8+E42RXz1D/dz9SxPSlWg==
  dependencies:
    "@babel/runtime" "^7.27.6"

"@mui/utils@^7.2.0":
  version "7.2.0"
  resolved "https://registry.npmjs.org/@mui/utils/-/utils-7.2.0.tgz"
  integrity sha512-O0i1GQL6MDzhKdy9iAu5Yr0Sz1wZjROH1o3aoztuivdCXqEeQYnEjTDiRLGuFxI9zrUbTHBwobMyQH5sNtyacw==
  dependencies:
    "@babel/runtime" "^7.27.6"
    "@mui/types" "^7.4.4"
    "@types/prop-types" "^15.7.15"
    clsx "^2.1.1"
    prop-types "^15.8.1"
    react-is "^19.1.0"

"@popperjs/core@^2.11.8":
  version "2.11.8"
  resolved "https://registry.npmjs.org/@popperjs/core/-/core-2.11.8.tgz"
  integrity sha512-P1st0aksCrn9sGZhp8GMYwBnQsbvAWsZAX44oXNNvLHGqAOcoVxmjZiohstwQ7SqKnbR47akdNi+uleWD8+g6A==

"@rolldown/pluginutils@1.0.0-beta.27":
  version "1.0.0-beta.27"
  resolved "https://registry.npmjs.org/@rolldown/pluginutils/-/pluginutils-1.0.0-beta.27.tgz"
  integrity sha512-+d0F4MKMCbeVUJwG96uQ4SgAznZNSq93I3V+9NHA4OpvqG8mRCpGdKmK8l/dl02h2CCDHwW2FqilnTyDcAnqjA==

"@rollup/rollup-darwin-arm64@4.45.1":
  version "4.45.1"
  resolved "https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.45.1.tgz"
  integrity sha512-FSncqHvqTm3lC6Y13xncsdOYfxGSLnP+73k815EfNmpewPs+EyM49haPS105Rh4aF5mJKywk9X0ogzLXZzN9lA==

"@tauri-apps/api@^2", "@tauri-apps/api@^2.6.0", "@tauri-apps/api@^2.8.0":
  version "2.9.1"
  resolved "https://registry.npmjs.org/@tauri-apps/api/-/api-2.9.1.tgz"
  integrity sha512-IGlhP6EivjXHepbBic618GOmiWe4URJiIeZFlB7x3czM0yDHHYviH1Xvoiv4FefdkQtn6v7TuwWCRfOGdnVUGw==

"@tauri-apps/cli-darwin-arm64@2.7.1":
  version "2.7.1"
  resolved "https://registry.npmjs.org/@tauri-apps/cli-darwin-arm64/-/cli-darwin-arm64-2.7.1.tgz"
  integrity sha512-j2NXQN6+08G03xYiyKDKqbCV2Txt+hUKg0a8hYr92AmoCU8fgCjHyva/p16lGFGUG3P2Yu0xiNe1hXL9ZuRMzA==

"@tauri-apps/cli@^2":
  version "2.7.1"
  resolved "https://registry.npmjs.org/@tauri-apps/cli/-/cli-2.7.1.tgz"
  integrity sha512-RcGWR4jOUEl92w3uvI0h61Llkfj9lwGD1iwvDRD2isMrDhOzjeeeVn9aGzeW1jubQ/kAbMYfydcA4BA0Cy733Q==
  optionalDependencies:
    "@tauri-apps/cli-darwin-arm64" "2.7.1"
    "@tauri-apps/cli-darwin-x64" "2.7.1"
    "@tauri-apps/cli-linux-arm-gnueabihf" "2.7.1"
    "@tauri-apps/cli-linux-arm64-gnu" "2.7.1"
    "@tauri-apps/cli-linux-arm64-musl" "2.7.1"
    "@tauri-apps/cli-linux-riscv64-gnu" "2.7.1"
    "@tauri-apps/cli-linux-x64-gnu" "2.7.1"
    "@tauri-apps/cli-linux-x64-musl" "2.7.1"
    "@tauri-apps/cli-win32-arm64-msvc" "2.7.1"
    "@tauri-apps/cli-win32-ia32-msvc" "2.7.1"
    "@tauri-apps/cli-win32-x64-msvc" "2.7.1"

"@tauri-apps/plugin-opener@^2":
  version "2.4.0"
  resolved "https://registry.npmjs.org/@tauri-apps/plugin-opener/-/plugin-opener-2.4.0.tgz"
  integrity sha512-43VyN8JJtvKWJY72WI/KNZszTpDpzHULFxQs0CJBIYUdCRowQ6Q1feWTDb979N7nldqSuDOaBupZ6wz2nvuWwQ==
  dependencies:
    "@tauri-apps/api" "^2.6.0"

"@tauri-apps/plugin-shell@^2.3.3":
  version "2.3.3"
  resolved "https://registry.npmjs.org/@tauri-apps/plugin-shell/-/plugin-shell-2.3.3.tgz"
  integrity sha512-Xod+pRcFxmOWFWEnqH5yZcA7qwAMuaaDkMR1Sply+F8VfBj++CGnj2xf5UoialmjZ2Cvd8qrvSCbU+7GgNVsKQ==
  dependencies:
    "@tauri-apps/api" "^2.8.0"

"@types/babel__core@^7.20.5":
  version "7.20.5"
  resolved "https://registry.npmjs.org/@types/babel__core/-/babel__core-7.20.5.tgz"
  integrity sha512-qoQprZvz5wQFJwMDqeseRXWv3rqMvhgpbXFfVyWhbx9X47POIA6i/+dXefEmZKoAgOaTdaIgNSMqMIU61yRyzA==
  dependencies:
    "@babel/parser" "^7.20.7"
    "@babel/types" "^7.20.7"
    "@types/babel__generator" "*"
    "@types/babel__template" "*"
    "@types/babel__traverse" "*"

"@types/babel__generator@*":
  version "7.27.0"
  resolved "https://registry.npmjs.org/@types/babel__generator/-/babel__generator-7.27.0.tgz"
  integrity sha512-ufFd2Xi92OAVPYsy+P4n7/U7e68fex0+Ee8gSG9KX7eo084CWiQ4sdxktvdl0bOPupXtVJPY19zk6EwWqUQ8lg==
  dependencies:
    "@babel/types" "^7.0.0"

"@types/babel__template@*":
  version "7.4.4"
  resolved "https://registry.npmjs.org/@types/babel__template/-/babel__template-7.4.4.tgz"
  integrity sha512-h/NUaSyG5EyxBIp8YRxo4RMe2/qQgvyowRwVMzhYhBCONbW8PUsg4lkFMrhgZhUe5z3L3MiLDuvyJ/CaPa2A8A==
  dependencies:
    "@babel/parser" "^7.1.0"
    "@babel/types" "^7.0.0"

"@types/babel__traverse@*":
  version "7.20.7"
  resolved "https://registry.npmjs.org/@types/babel__traverse/-/babel__traverse-7.20.7.tgz"
  integrity sha512-dkO5fhS7+/oos4ciWxyEyjWe48zmG6wbCheo/G2ZnHx4fs3EU6YC6UM8rk56gAjNJ9P3MTH2jo5jb92/K6wbng==
  dependencies:
    "@babel/types" "^7.20.7"

"@types/crypto-js@^4.2.2":
  version "4.2.2"
  resolved "https://registry.npmjs.org/@types/crypto-js/-/crypto-js-4.2.2.tgz"
  integrity sha512-sDOLlVbHhXpAUAL0YHDUUwDZf3iN4Bwi4W6a0W0b+QcAezUbRtH4FVb+9J4h+XFPW7l/gQ9F8qC7P+Ec4k8QVQ==

"@types/estree@1.0.8":
  version "1.0.8"
  resolved "https://registry.npmjs.org/@types/estree/-/estree-1.0.8.tgz"
  integrity sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==

"@types/history@^4.7.11":
  version "4.7.11"
  resolved "https://registry.npmjs.org/@types/history/-/history-4.7.11.tgz"
  integrity sha512-qjDJRrmvBMiTx+jyLxvLfJU7UznFuokDv4f3WRuriHKERccVpFU+8XMQUAbDzoiJCsmexxRExQeMwwCdamSKDA==

"@types/parse-json@^4.0.0":
  version "4.0.2"
  resolved "https://registry.npmjs.org/@types/parse-json/-/parse-json-4.0.2.tgz"
  integrity sha512-dISoDXWWQwUquiKsyZ4Ng+HX2KsPL7LyHKHQwgGFEA3IaKac4Obd+h2a/a6waisAoepJlBcx9paWqjA8/HVjCw==

"@types/prismjs@^1.26.5":
  version "1.26.5"
  resolved "https://registry.npmjs.org/@types/prismjs/-/prismjs-1.26.5.tgz"
  integrity sha512-AUZTa7hQ2KY5L7AmtSiqxlhWxb4ina0yd8hNbl4TWuqnv/pFP0nDMb3YrfSBf4hJVGLh2YEIBfKaBW/9UEl6IQ==

"@types/prop-types@^15.7.15":
  version "15.7.15"
  resolved "https://registry.npmjs.org/@types/prop-types/-/prop-types-15.7.15.tgz"
  integrity sha512-F6bEyamV9jKGAFBEmlQnesRPGOQqS2+Uwi0Em15xenOxHaf2hv6L8YCVn3rPdPJOiJfPiCnLIRyvwVaqMY3MIw==

"@types/react-dom@^19.1.6":
  version "19.1.6"
  resolved "https://registry.npmjs.org/@types/react-dom/-/react-dom-19.1.6.tgz"
  integrity sha512-4hOiT/dwO8Ko0gV1m/TJZYk3y0KBnY9vzDh7W+DH17b2HFSOGgdj33dhihPeuy3l0q23+4e+hoXHV6hCC4dCXw==

"@types/react-router-dom@^5.3.3":
  version "5.3.3"
  resolved "https://registry.npmjs.org/@types/react-router-dom/-/react-router-dom-5.3.3.tgz"
  integrity sha512-kpqnYK4wcdm5UaWI3fLcELopqLrHgLqNsdpHauzlQktfkHL3npOSwtj1Uz9oKBAzs7lFtVkV8j83voAz2D8fhw==
  dependencies:
    "@types/history" "^4.7.11"
    "@types/react" "*"
    "@types/react-router" "*"

"@types/react-router@*":
  version "5.1.20"
  resolved "https://registry.npmjs.org/@types/react-router/-/react-router-5.1.20.tgz"
  integrity sha512-jGjmu/ZqS7FjSH6owMcD5qpq19+1RS9DeVRqfl1FeBMxTDQAGwlMWOcs52NDoXaNKyG3d1cYQFMs9rCrb88o9Q==
  dependencies:
    "@types/history" "^4.7.11"
    "@types/react" "*"

"@types/react-transition-group@^4.4.12":
  version "4.4.12"
  resolved "https://registry.npmjs.org/@types/react-transition-group/-/react-transition-group-4.4.12.tgz"
  integrity sha512-8TV6R3h2j7a91c+1DXdJi3Syo69zzIZbz7Lg5tORM5LEJG7X/E6a1V3drRyBRZq7/utz7A+c4OgYLiLcYGHG6w==

"@types/react-window@^1.8.8":
  version "1.8.8"
  resolved "https://registry.npmjs.org/@types/react-window/-/react-window-1.8.8.tgz"
  integrity sha512-8Ls660bHR1AUA2kuRvVG9D/4XpRC6wjAaPT9dil7Ckc76eP9TKWZwwmgfq8Q1LANX3QNDnoU4Zp48A3w+zK69Q==
  dependencies:
    "@types/react" "*"

"@types/react@*", "@types/react@^17.0.0 || ^18.0.0 || ^19.0.0", "@types/react@^19.0.0", "@types/react@^19.1.8", "@types/react@>=18.0.0":
  version "19.1.8"
  resolved "https://registry.npmjs.org/@types/react/-/react-19.1.8.tgz"
  integrity sha512-AwAfQ2Wa5bCx9WP8nZL2uMZWod7J7/JSplxbTmBQ5ms6QpqNYm672H0Vu9ZVKVngQ+ii4R/byguVEUZQyeg44g==
  dependencies:
    csstype "^3.0.2"

"@types/xterm@^2.0.3":
  version "2.0.3"
  resolved "https://registry.npmjs.org/@types/xterm/-/xterm-2.0.3.tgz"
  integrity sha512-Owlz29ThHtn2RQry87juaNYeIc4Dr8ykLLX0JKKt4SdO6ujwJnsXCpBAr6bwo/f4L3xSfM9KA7OnPPf9Xit6tA==

"@vitejs/plugin-react@^4.7.0":
  version "4.7.0"
  resolved "https://registry.npmjs.org/@vitejs/plugin-react/-/plugin-react-4.7.0.tgz"
  integrity sha512-gUu9hwfWvvEDBBmgtAowQCojwZmJ5mcLn3aufeCsitijs3+f2NsrPtlAWIR6OPiqljl96GVCUbLe0HyqIpVaoA==
  dependencies:
    "@babel/core" "^7.28.0"
    "@babel/plugin-transform-react-jsx-self" "^7.27.1"
    "@babel/plugin-transform-react-jsx-source" "^7.27.1"
    "@rolldown/pluginutils" "1.0.0-beta.27"
    "@types/babel__core" "^7.20.5"
    react-refresh "^0.17.0"

"@xterm/addon-fit@^0.10.0":
  version "0.10.0"
  resolved "https://registry.npmjs.org/@xterm/addon-fit/-/addon-fit-0.10.0.tgz"
  integrity sha512-UFYkDm4HUahf2lnEyHvio51TNGiLK66mqP2JoATy7hRZeXaGMRDr00JiSF7m63vR5WKATF605yEggJKsw0JpMQ==

"@xterm/xterm@^5.0.0", "@xterm/xterm@^5.5.0":
  version "5.5.0"
  resolved "https://registry.npmjs.org/@xterm/xterm/-/xterm-5.5.0.tgz"
  integrity sha512-hqJHYaQb5OptNunnyAnkHyM8aCjZ1MEIDTQu1iIbbTD/xops91NB5yq1ZK/dC2JDbVWtF23zUtl9JE2NqwT87A==

babel-plugin-macros@^3.1.0:
  version "3.1.0"
  resolved "https://registry.npmjs.org/babel-plugin-macros/-/babel-plugin-macros-3.1.0.tgz"
  integrity sha512-Cg7TFGpIr01vOQNODXOOaGz2NpCU5gl8x1qJFbb6hbZxR7XrcE2vtbAsTAbJ7/xwJtUuJEw8K8Zr/AE0LHlesg==
  dependencies:
    "@babel/runtime" "^7.12.5"
    cosmiconfig "^7.0.0"
    resolve "^1.19.0"

browserslist@^4.24.0, "browserslist@>= 4.21.0":
  version "4.25.1"
  resolved "https://registry.npmjs.org/browserslist/-/browserslist-4.25.1.tgz"
  integrity sha512-KGj0KoOMXLpSNkkEI6Z6mShmQy0bc1I+T7K9N81k4WWMrfz+6fQ6es80B/YLAeRoKvjYE1YSHHOW1qe9xIVzHw==
  dependencies:
    caniuse-lite "^1.0.30001726"
    electron-to-chromium "^1.5.173"
    node-releases "^2.0.19"
    update-browserslist-db "^1.1.3"

callsites@^3.0.0:
  version "3.1.0"
  resolved "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz"
  integrity sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==

caniuse-lite@^1.0.30001726:
  version "1.0.30001727"
  resolved "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001727.tgz"
  integrity sha512-pB68nIHmbN6L/4C6MH1DokyR3bYqFwjaSs/sWDHGj4CTcFtQUQMuJftVwWkXq7mNWOybD3KhUv3oWHoGxgP14Q==

clsx@^2.1.1:
  version "2.1.1"
  resolved "https://registry.npmjs.org/clsx/-/clsx-2.1.1.tgz"
  integrity sha512-eYm0QWBtUrBWZWG0d386OGAw16Z995PiOVo2B7bjWSbHedGl5e0ZWaq65kOGgUSNesEIDkB9ISbTg/JK9dhCZA==

convert-source-map@^1.5.0:
  version "1.9.0"
  resolved "https://registry.npmjs.org/convert-source-map/-/convert-source-map-1.9.0.tgz"
  integrity sha512-ASFBup0Mz1uyiIjANan1jzLQami9z1PoYSZCiiYW2FczPbenXc45FZdBZLzOT+r6+iciuEModtmCti+hjaAk0A==

convert-source-map@^2.0.0:
  version "2.0.0"
  resolved "https://registry.npmjs.org/convert-source-map/-/convert-source-map-2.0.0.tgz"
  integrity sha512-Kvp459HrV2FEJ1CAsi1Ku+MY3kasH19TFykTz2xWmMeq6bk2NU3XXvfJ+Q61m0xktWwt+1HSYf3JZsTms3aRJg==

cookie@^1.0.1:
  version "1.1.1"
  resolved "https://registry.npmjs.org/cookie/-/cookie-1.1.1.tgz"
  integrity sha512-ei8Aos7ja0weRpFzJnEA9UHJ/7XQmqglbRwnf2ATjcB9Wq874VKH9kfjjirM6UhU2/E5fFYadylyhFldcqSidQ==

cosmiconfig@^7.0.0:
  version "7.1.0"
  resolved "https://registry.npmjs.org/cosmiconfig/-/cosmiconfig-7.1.0.tgz"
  integrity sha512-AdmX6xUzdNASswsFtmwSt7Vj8po9IuqXm0UXz7QKPuEUmPB4XyjGfaAr2PSuELMwkRMVH1EpIkX5bTZGRB3eCA==
  dependencies:
    "@types/parse-json" "^4.0.0"
    import-fresh "^3.2.1"
    parse-json "^5.0.0"
    path-type "^4.0.0"
    yaml "^1.10.0"

crypto-js@^4.2.0:
  version "4.2.0"
  resolved "https://registry.npmjs.org/crypto-js/-/crypto-js-4.2.0.tgz"
  integrity sha512-KALDyEYgpY+Rlob/iriUtjV6d5Eq+Y191A5g4UqLAi8CyGP9N1+FdVbkc1SxKc2r4YAYqG8JzO2KGL+AizD70Q==

csstype@^3.0.2, csstype@^3.1.3:
  version "3.1.3"
  resolved "https://registry.npmjs.org/csstype/-/csstype-3.1.3.tgz"
  integrity sha512-M1uQkMl8rQK/szD0LNhtqxIPLpimGm8sOBwU7lLnCpSbTyY3yeU1Vc7l4KT5zT4s/yOxHH5O7tIuuLOCnLADRw==

debug@^4.1.0, debug@^4.3.1:
  version "4.4.1"
  resolved "https://registry.npmjs.org/debug/-/debug-4.4.1.tgz"
  integrity sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==
  dependencies:
    ms "^2.1.3"

dom-helpers@^5.0.1:
  version "5.2.1"
  resolved "https://registry.npmjs.org/dom-helpers/-/dom-helpers-5.2.1.tgz"
  integrity sha512-nRCa7CK3VTrM2NmGkIy4cbK7IZlgBE/PYMn55rrXefr5xXDP0LdtfPnblFDoVdcAfslJ7or6iqAUnx0CCGIWQA==
  dependencies:
    "@babel/runtime" "^7.8.7"
    csstype "^3.0.2"

electron-to-chromium@^1.5.173:
  version "1.5.190"
  resolved "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.190.tgz"
  integrity sha512-k4McmnB2091YIsdCgkS0fMVMPOJgxl93ltFzaryXqwip1AaxeDqKCGLxkXODDA5Ab/D+tV5EL5+aTx76RvLRxw==

error-ex@^1.3.1:
  version "1.3.2"
  resolved "https://registry.npmjs.org/error-ex/-/error-ex-1.3.2.tgz"
  integrity sha512-7dFHNmqeFSEt2ZBsCriorKnn3Z2pj+fd9kmI6QoWw4//DL+icEBfc0U7qJCisqrTsKTjw4fNFy2pW9OqStD84g==
  dependencies:
    is-arrayish "^0.2.1"

esbuild@^0.25.0:
  version "0.25.8"
  resolved "https://registry.npmjs.org/esbuild/-/esbuild-0.25.8.tgz"
  integrity sha512-vVC0USHGtMi8+R4Kz8rt6JhEWLxsv9Rnu/lGYbPR8u47B+DCBksq9JarW0zOO7bs37hyOK1l2/oqtbciutL5+Q==
  optionalDependencies:
    "@esbuild/aix-ppc64" "0.25.8"
    "@esbuild/android-arm" "0.25.8"
    "@esbuild/android-arm64" "0.25.8"
    "@esbuild/android-x64" "0.25.8"
    "@esbuild/darwin-arm64" "0.25.8"
    "@esbuild/darwin-x64" "0.25.8"
    "@esbuild/freebsd-arm64" "0.25.8"
    "@esbuild/freebsd-x64" "0.25.8"
    "@esbuild/linux-arm" "0.25.8"
    "@esbuild/linux-arm64" "0.25.8"
    "@esbuild/linux-ia32" "0.25.8"
    "@esbuild/linux-loong64" "0.25.8"
    "@esbuild/linux-mips64el" "0.25.8"
    "@esbuild/linux-ppc64" "0.25.8"
    "@esbuild/linux-riscv64" "0.25.8"
    "@esbuild/linux-s390x" "0.25.8"
    "@esbuild/linux-x64" "0.25.8"
    "@esbuild/netbsd-arm64" "0.25.8"
    "@esbuild/netbsd-x64" "0.25.8"
    "@esbuild/openbsd-arm64" "0.25.8"
    "@esbuild/openbsd-x64" "0.25.8"
    "@esbuild/openharmony-arm64" "0.25.8"
    "@esbuild/sunos-x64" "0.25.8"
    "@esbuild/win32-arm64" "0.25.8"
    "@esbuild/win32-ia32" "0.25.8"
    "@esbuild/win32-x64" "0.25.8"

escalade@^3.2.0:
  version "3.2.0"
  resolved "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz"
  integrity sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==

escape-string-regexp@^4.0.0:
  version "4.0.0"
  resolved "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz"
  integrity sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==

fdir@^6.4.4:
  version "6.4.6"
  resolved "https://registry.npmjs.org/fdir/-/fdir-6.4.6.tgz"
  integrity sha512-hiFoqpyZcfNm1yc4u8oWCf9A2c4D3QjCrks3zmoVKVxpQRzmPNar1hUJcBG2RQHvEVGDN+Jm81ZheVLAQMK6+w==

find-root@^1.1.0:
  version "1.1.0"
  resolved "https://registry.npmjs.org/find-root/-/find-root-1.1.0.tgz"
  integrity sha512-NKfW6bec6GfKc0SGx1e07QZY9PE99u0Bft/0rzSD5k3sO/vwkVUpDUKVm5Gpp5Ue3YfShPFTX2070tDs5kB9Ng==

fsevents@~2.3.2, fsevents@~2.3.3:
  version "2.3.3"
  resolved "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz"
  integrity sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==

function-bind@^1.1.2:
  version "1.1.2"
  resolved "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz"
  integrity sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==

gensync@^1.0.0-beta.2:
  version "1.0.0-beta.2"
  resolved "https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.2.tgz"
  integrity sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==

hasown@^2.0.2:
  version "2.0.2"
  resolved "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz"
  integrity sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==
  dependencies:
    function-bind "^1.1.2"

hoist-non-react-statics@^3.3.1:
  version "3.3.2"
  resolved "https://registry.npmjs.org/hoist-non-react-statics/-/hoist-non-react-statics-3.3.2.tgz"
  integrity sha512-/gGivxi8JPKWNm/W0jSmzcMPpfpPLc3dY/6GxhX2hQ9iGj3aDfklV4ET7NjKpSinLpJ5vafa9iiGIEZg10SfBw==
  dependencies:
    react-is "^16.7.0"

import-fresh@^3.2.1:
  version "3.3.1"
  resolved "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.1.tgz"
  integrity sha512-TR3KfrTZTYLPB6jUjfx6MF9WcWrHL9su5TObK4ZkYgBdWKPOFoSoQIdEuTuR82pmtxH2spWG9h6etwfr1pLBqQ==
  dependencies:
    parent-module "^1.0.0"
    resolve-from "^4.0.0"

is-arrayish@^0.2.1:
  version "0.2.1"
  resolved "https://registry.npmjs.org/is-arrayish/-/is-arrayish-0.2.1.tgz"
  integrity sha512-zz06S8t0ozoDXMG+ube26zeCTNXcKIPJZJi8hBrF4idCLms4CG9QtK7qBl1boi5ODzFpjswb5JPmHCbMpjaYzg==

is-core-module@^2.16.0:
  version "2.16.1"
  resolved "https://registry.npmjs.org/is-core-module/-/is-core-module-2.16.1.tgz"
  integrity sha512-UfoeMA6fIJ8wTYFEUjelnaGI67v6+N7qXJEvQuIGa99l4xsCruSYOVSQ0uPANn4dAzm8lkYPaKLrrijLq7x23w==
  dependencies:
    hasown "^2.0.2"

"js-tokens@^3.0.0 || ^4.0.0", js-tokens@^4.0.0:
  version "4.0.0"
  resolved "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz"
  integrity sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==

jsesc@^3.0.2:
  version "3.1.0"
  resolved "https://registry.npmjs.org/jsesc/-/jsesc-3.1.0.tgz"
  integrity sha512-/sM3dO2FOzXjKQhJuo0Q173wf2KOo8t4I8vHy6lF9poUp7bKT0/NHE8fPX23PwfhnykfqnC2xRxOnVw5XuGIaA==

json-parse-even-better-errors@^2.3.0:
  version "2.3.1"
  resolved "https://registry.npmjs.org/json-parse-even-better-errors/-/json-parse-even-better-errors-2.3.1.tgz"
  integrity sha512-xyFwyhro/JEof6Ghe2iz2NcXoj2sloNsWr/XsERDK/oiPCfaNhl5ONfp+jQdAZRQQ0IJWNzH9zIZF7li91kh2w==

json5@^2.2.3:
  version "2.2.3"
  resolved "https://registry.npmjs.org/json5/-/json5-2.2.3.tgz"
  integrity sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==

lines-and-columns@^1.1.6:
  version "1.2.4"
  resolved "https://registry.npmjs.org/lines-and-columns/-/lines-and-columns-1.2.4.tgz"
  integrity sha512-7ylylesZQ/PV29jhEDl3Ufjo6ZX7gCqJr5F7PKrqc93v7fzSymt1BpwEU8nAUXs8qzzvqhbjhK5QZg6Mt/HkBg==

loose-envify@^1.4.0:
  version "1.4.0"
  resolved "https://registry.npmjs.org/loose-envify/-/loose-envify-1.4.0.tgz"
  integrity sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==
  dependencies:
    js-tokens "^3.0.0 || ^4.0.0"

lru-cache@^5.1.1:
  version "5.1.1"
  resolved "https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz"
  integrity sha512-KpNARQA3Iwv+jTA0utUVVbrh+Jlrr1Fv0e56GGzAFOXN7dk/FviaDW8LHmK52DlcH4WP2n6gI8vN1aesBFgo9w==
  dependencies:
    yallist "^3.0.2"

ms@^2.1.3:
  version "2.1.3"
  resolved "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz"
  integrity sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==

nanoid@^3.3.11:
  version "3.3.11"
  resolved "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz"
  integrity sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==

node-releases@^2.0.19:
  version "2.0.19"
  resolved "https://registry.npmjs.org/node-releases/-/node-releases-2.0.19.tgz"
  integrity sha512-xxOWJsBKtzAq7DY0J+DTzuz58K8e7sJbdgwkbMWQe8UYB6ekmsQ45q0M/tJDsGaZmbC+l7n57UV8Hl5tHxO9uw==

object-assign@^4.1.1:
  version "4.1.1"
  resolved "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz"
  integrity sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==

parent-module@^1.0.0:
  version "1.0.1"
  resolved "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz"
  integrity sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==
  dependencies:
    callsites "^3.0.0"

parse-json@^5.0.0:
  version "5.2.0"
  resolved "https://registry.npmjs.org/parse-json/-/parse-json-5.2.0.tgz"
  integrity sha512-ayCKvm/phCGxOkYRSCM82iDwct8/EonSEgCSxWxD7ve6jHggsFl4fZVQBPRNgQoKiuV/odhFrGzQXZwbifC8Rg==
  dependencies:
    "@babel/code-frame" "^7.0.0"
    error-ex "^1.3.1"
    json-parse-even-better-errors "^2.3.0"
    lines-and-columns "^1.1.6"

path-parse@^1.0.7:
  version "1.0.7"
  resolved "https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz"
  integrity sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==

path-type@^4.0.0:
  version "4.0.0"
  resolved "https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz"
  integrity sha512-gDKb8aZMDeD/tZWs9P6+q0J9Mwkdl6xMV8TjnGP3qJVJ06bdMgkbBlLU8IdfOsIsFz2BW1rNVT3XuNEl8zPAvw==

picocolors@^1.1.1:
  version "1.1.1"
  resolved "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz"
  integrity sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==

"picomatch@^3 || ^4", picomatch@^4.0.2:
  version "4.0.3"
  resolved "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz"
  integrity sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==

postcss@^8.5.3:
  version "8.5.6"
  resolved "https://registry.npmjs.org/postcss/-/postcss-8.5.6.tgz"
  integrity sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==
  dependencies:
    nanoid "^3.3.11"
    picocolors "^1.1.1"
    source-map-js "^1.2.1"

prettier@3.6.2:
  version "3.6.2"
  resolved "https://registry.npmjs.org/prettier/-/prettier-3.6.2.tgz"
  integrity sha512-I7AIg5boAr5R0FFtJ6rCfD+LFsWHp81dolrFD8S79U9tb8Az2nGrJncnMSnys+bpQJfRUzqs9hnA81OAA3hCuQ==

prismjs@^1.30.0:
  version "1.30.0"
  resolved "https://registry.npmjs.org/prismjs/-/prismjs-1.30.0.tgz"
  integrity sha512-DEvV2ZF2r2/63V+tK8hQvrR2ZGn10srHbXviTlcv7Kpzw8jWiNTqbVgjO3IY8RxrrOUF8VPMQQFysYYYv0YZxw==

prop-types@^15.6.2, prop-types@^15.8.1:
  version "15.8.1"
  resolved "https://registry.npmjs.org/prop-types/-/prop-types-15.8.1.tgz"
  integrity sha512-oj87CgZICdulUohogVAR7AjlC0327U4el4L6eAvOqCeudMDVU0NThNaV+b9Df4dXgSP1gXMTnPdhfe/2qDH5cg==
  dependencies:
    loose-envify "^1.4.0"
    object-assign "^4.1.1"
    react-is "^16.13.1"

"react-dom@^17.0.0 || ^18.0.0 || ^19.0.0", "react-dom@^18.0.0 || ^19.0.0", react-dom@^19.1.0, react-dom@>=16.6.0, react-dom@>=16.8.0, react-dom@>=18:
  version "19.1.0"
  resolved "https://registry.npmjs.org/react-dom/-/react-dom-19.1.0.tgz"
  integrity sha512-Xs1hdnE+DyKgeHJeJznQmYMIBG3TKIHJJT95Q58nHLSrElKlGQqDTR2HQ9fx5CN/Gk6Vh/kupBTDLU11/nDk/g==
  dependencies:
    scheduler "^0.26.0"

react-is@^16.13.1:
  version "16.13.1"
  resolved "https://registry.npmjs.org/react-is/-/react-is-16.13.1.tgz"
  integrity sha512-24e6ynE2H+OKt4kqsOvNd8kBpV65zoxbA4BVsEOB3ARVWQki/DHzaUoC5KuON/BiccDaCCTZBuOcfZs70kR8bQ==

react-is@^16.7.0:
  version "16.13.1"
  resolved "https://registry.npmjs.org/react-is/-/react-is-16.13.1.tgz"
  integrity sha512-24e6ynE2H+OKt4kqsOvNd8kBpV65zoxbA4BVsEOB3ARVWQki/DHzaUoC5KuON/BiccDaCCTZBuOcfZs70kR8bQ==

react-is@^19.1.0:
  version "19.1.0"
  resolved "https://registry.npmjs.org/react-is/-/react-is-19.1.0.tgz"
  integrity sha512-Oe56aUPnkHyyDxxkvqtd7KkdQP5uIUfHxd5XTb3wE9d/kRnZLmKbDB0GWk919tdQ+mxxPtG6EAs6RMT6i1qtHg==

react-refresh@^0.17.0:
  version "0.17.0"
  resolved "https://registry.npmjs.org/react-refresh/-/react-refresh-0.17.0.tgz"
  integrity sha512-z6F7K9bV85EfseRCp2bzrpyQ0Gkw1uLoCel9XBVWPg/TjRj94SkJzUTGfOa4bs7iJvBWtQG0Wq7wnI0syw3EBQ==

react-router-dom@^7.7.1:
  version "7.12.0"
  resolved "https://registry.npmjs.org/react-router-dom/-/react-router-dom-7.12.0.tgz"
  integrity sha512-pfO9fiBcpEfX4Tx+iTYKDtPbrSLLCbwJ5EqP+SPYQu1VYCXdy79GSj0wttR0U4cikVdlImZuEZ/9ZNCgoaxwBA==
  dependencies:
    react-router "7.12.0"

react-router@7.12.0:
  version "7.12.0"
  resolved "https://registry.npmjs.org/react-router/-/react-router-7.12.0.tgz"
  integrity sha512-kTPDYPFzDVGIIGNLS5VJykK0HfHLY5MF3b+xj0/tTyNYL1gF1qs7u67Z9jEhQk2sQ98SUaHxlG31g1JtF7IfVw==
  dependencies:
    cookie "^1.0.1"
    set-cookie-parser "^2.6.0"

react-simple-code-editor@^0.14.1:
  version "0.14.1"
  resolved "https://registry.npmjs.org/react-simple-code-editor/-/react-simple-code-editor-0.14.1.tgz"
  integrity sha512-BR5DtNRy+AswWJECyA17qhUDvrrCZ6zXOCfkQY5zSmb96BVUbpVAv03WpcjcwtCwiLbIANx3gebHOcXYn1EHow==

react-transition-group@^4.4.5:
  version "4.4.5"
  resolved "https://registry.npmjs.org/react-transition-group/-/react-transition-group-4.4.5.tgz"
  integrity sha512-pZcd1MCJoiKiBR2NRxeCRg13uCXbydPnmB4EOeRrY7480qNWO8IIgQG6zlDkm6uRMsURXPuKq0GWtiM59a5Q6g==
  dependencies:
    "@babel/runtime" "^7.5.5"
    dom-helpers "^5.0.1"
    loose-envify "^1.4.0"
    prop-types "^15.6.2"

react-window@^2.2.3:
  version "2.2.3"
  resolved "https://registry.npmjs.org/react-window/-/react-window-2.2.3.tgz"
  integrity sha512-gTRqQYC8ojbiXyd9duYFiSn2TJw0ROXCgYjenOvNKITWzK0m0eCvkUsEUM08xvydkMh7ncp+LE0uS3DeNGZxnQ==

"react@^17.0.0 || ^18.0.0 || ^19.0.0", "react@^18.0.0 || ^19.0.0", react@^19.1.0, react@>=16.6.0, react@>=16.8.0, react@>=18, react@>=18.0.0:
  version "19.1.0"
  resolved "https://registry.npmjs.org/react/-/react-19.1.0.tgz"
  integrity sha512-FS+XFBNvn3GTAWq26joslQgWNoFu08F4kl0J4CgdNKADkdSGXQyTCnKteIAJy96Br6YbpEU1LSzV5dYtjMkMDg==

resolve-from@^4.0.0:
  version "4.0.0"
  resolved "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz"
  integrity sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==

resolve@^1.19.0:
  version "1.22.10"
  resolved "https://registry.npmjs.org/resolve/-/resolve-1.22.10.tgz"
  integrity sha512-NPRy+/ncIMeDlTAsuqwKIiferiawhefFJtkNSW0qZJEqMEb+qBt/77B/jGeeek+F0uOeN05CDa6HXbbIgtVX4w==
  dependencies:
    is-core-module "^2.16.0"
    path-parse "^1.0.7"
    supports-preserve-symlinks-flag "^1.0.0"

rollup@^4.34.9:
  version "4.45.1"
  resolved "https://registry.npmjs.org/rollup/-/rollup-4.45.1.tgz"
  integrity sha512-4iya7Jb76fVpQyLoiVpzUrsjQ12r3dM7fIVz+4NwoYvZOShknRmiv+iu9CClZml5ZLGb0XMcYLutK6w9tgxHDw==
  dependencies:
    "@types/estree" "1.0.8"
  optionalDependencies:
    "@rollup/rollup-android-arm-eabi" "4.45.1"
    "@rollup/rollup-android-arm64" "4.45.1"
    "@rollup/rollup-darwin-arm64" "4.45.1"
    "@rollup/rollup-darwin-x64" "4.45.1"
    "@rollup/rollup-freebsd-arm64" "4.45.1"
    "@rollup/rollup-freebsd-x64" "4.45.1"
    "@rollup/rollup-linux-arm-gnueabihf" "4.45.1"
    "@rollup/rollup-linux-arm-musleabihf" "4.45.1"
    "@rollup/rollup-linux-arm64-gnu" "4.45.1"
    "@rollup/rollup-linux-arm64-musl" "4.45.1"
    "@rollup/rollup-linux-loongarch64-gnu" "4.45.1"
    "@rollup/rollup-linux-powerpc64le-gnu" "4.45.1"
    "@rollup/rollup-linux-riscv64-gnu" "4.45.1"
    "@rollup/rollup-linux-riscv64-musl" "4.45.1"
    "@rollup/rollup-linux-s390x-gnu" "4.45.1"
    "@rollup/rollup-linux-x64-gnu" "4.45.1"
    "@rollup/rollup-linux-x64-musl" "4.45.1"
    "@rollup/rollup-win32-arm64-msvc" "4.45.1"
    "@rollup/rollup-win32-ia32-msvc" "4.45.1"
    "@rollup/rollup-win32-x64-msvc" "4.45.1"
    fsevents "~2.3.2"

scheduler@^0.26.0:
  version "0.26.0"
  resolved "https://registry.npmjs.org/scheduler/-/scheduler-0.26.0.tgz"
  integrity sha512-NlHwttCI/l5gCPR3D1nNXtWABUmBwvZpEQiD4IXSbIDq8BzLIK/7Ir5gTFSGZDUu37K5cMNp0hFtzO38sC7gWA==

semver@^6.3.1:
  version "6.3.1"
  resolved "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz"
  integrity sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==

set-cookie-parser@^2.6.0:
  version "2.7.2"
  resolved "https://registry.npmjs.org/set-cookie-parser/-/set-cookie-parser-2.7.2.tgz"
  integrity sha512-oeM1lpU/UvhTxw+g3cIfxXHyJRc/uidd3yK1P242gzHds0udQBYzs3y8j4gCCW+ZJ7ad0yctld8RYO+bdurlvw==

source-map-js@^1.2.1:
  version "1.2.1"
  resolved "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz"
  integrity sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==

source-map@^0.5.7:
  version "0.5.7"
  resolved "https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz"
  integrity sha512-LbrmJOMUSdEVxIKvdcJzQC+nQhe8FUZQTXQy6+I75skNgn3OoQ0DZA8YnFa7gp8tqtL3KPf1kmo0R5DoApeSGQ==

stylis@4.2.0:
  version "4.2.0"
  resolved "https://registry.npmjs.org/stylis/-/stylis-4.2.0.tgz"
  integrity sha512-Orov6g6BB1sDfYgzWfTHDOxamtX1bE/zo104Dh9e6fqJ3PooipYyfJ0pUmrZO2wAvO8YbEyeFrkV91XTsGMSrw==

supports-preserve-symlinks-flag@^1.0.0:
  version "1.0.0"
  resolved "https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz"
  integrity sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==

tinyglobby@^0.2.13:
  version "0.2.14"
  resolved "https://registry.npmjs.org/tinyglobby/-/tinyglobby-0.2.14.tgz"
  integrity sha512-tX5e7OM1HnYr2+a2C/4V0htOcSQcoSTH9KgJnVvNm5zm/cyEWKJ7j7YutsH9CxMdtOkkLFy2AHrMci9IM8IPZQ==
  dependencies:
    fdir "^6.4.4"
    picomatch "^4.0.2"

typescript@~5.6.2:
  version "5.6.3"
  resolved "https://registry.npmjs.org/typescript/-/typescript-5.6.3.tgz"
  integrity sha512-hjcS1mhfuyi4WW8IWtjP7brDrG2cuDZukyrYrSauoXGNgx0S7zceP07adYkJycEr56BOUTNPzbInooiN3fn1qw==

update-browserslist-db@^1.1.3:
  version "1.1.3"
  resolved "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.1.3.tgz"
  integrity sha512-UxhIZQ+QInVdunkDAaiazvvT/+fXL5Osr0JZlJulepYu6Jd7qJtDZjlur0emRlT71EN3ScPoE7gvsuIKKNavKw==
  dependencies:
    escalade "^3.2.0"
    picocolors "^1.1.1"

"vite@^4.2.0 || ^5.0.0 || ^6.0.0 || ^7.0.0", vite@^6.0.3:
  version "6.4.1"
  resolved "https://registry.npmjs.org/vite/-/vite-6.4.1.tgz"
  integrity sha512-+Oxm7q9hDoLMyJOYfUYBuHQo+dkAloi33apOPP56pzj+vsdJDzr+j1NISE5pyaAuKL4A3UD34qd0lx5+kfKp2g==
  dependencies:
    esbuild "^0.25.0"
    fdir "^6.4.4"
    picomatch "^4.0.2"
    postcss "^8.5.3"
    rollup "^4.34.9"
    tinyglobby "^0.2.13"
  optionalDependencies:
    fsevents "~2.3.3"

xterm-addon-fit@^0.8.0:
  version "0.8.0"
  resolved "https://registry.npmjs.org/xterm-addon-fit/-/xterm-addon-fit-0.8.0.tgz"
  integrity sha512-yj3Np7XlvxxhYF/EJ7p3KHaMt6OdwQ+HDu573Vx1lRXsVxOcnVJs51RgjZOouIZOczTsskaS+CpXspK81/DLqw==

xterm@^5.0.0, xterm@^5.3.0:
  version "5.3.0"
  resolved "https://registry.npmjs.org/xterm/-/xterm-5.3.0.tgz"
  integrity sha512-8QqjlekLUFTrU6x7xck1MsPzPA571K5zNqWm0M0oroYEWVOptZ0+ubQSkQ3uxIEhcIHRujJy6emDWX4A7qyFzg==

yallist@^3.0.2:
  version "3.1.1"
  resolved "https://registry.npmjs.org/yallist/-/yallist-3.1.1.tgz"
  integrity sha512-a4UGQaWPH59mOXUYnAG2ewncQS4i4F43Tv3JoAM+s2VDAmS9NsK8GpDMLrCHPksFT7h3K6TOoUNn2pb7RoXx4g==

yaml@^1.10.0:
  version "1.10.2"
  resolved "https://registry.npmjs.org/yaml/-/yaml-1.10.2.tgz"
  integrity sha512-r3vXyErRCYJ7wg28yvBY5VSoAF8ZvlcW9/BwUzEtUsjvX/DKs24dIkuwjtuprwJJHsbyUbLApepYTR1BN4uHrg==

yaml@^2.4.2:
  version "2.8.0"
  resolved "https://registry.npmjs.org/yaml/-/yaml-2.8.0.tgz"
  integrity sha512-4lLa/EcQCB0cJkyts+FpIRx5G/llPxfP6VQU5KByHEhLxY3IJCH0f0Hy1MHI8sClTvsIb8qwRJ6R/ZdlDJ/leQ==

zustand@^5.0.8:
  version "5.0.8"
  resolved "https://registry.npmjs.org/zustand/-/zustand-5.0.8.tgz"
  integrity sha512-gyPKpIaxY9XcO2vSMrLbiER7QMAMGOQZVRdJ6Zi782jkbzZygq5GI9nG8g+sMgitRtndwaBSl7uiqC49o1SSiw==

```

`src/server/Cargo.toml`:

```toml
[package]
name = "dyna-dbg"
version = "0.1.0"
edition = "2021"

[build-dependencies]
cc = "1.0"
serde_json = "=1.0.140"

[dependencies]
rayon = "1.5.0"
warp = "0.3"
bytes = "1"
tokio = { version = "1", features = ["full"] }
libc = "0.2"
lazy_static = "1.4"
serde = {version="1.0", features = ["derive"] }
serde_derive = "1.0"
serde_json = "=1.0.140"
hyper = "0.14"
regex = "1.8.4"
hex = "0.4.3"
byteorder = "1.4.3"
memchr = "2.7.2"
ctor = "0.2.6"
lz4_flex = "0.11.3"
log = "0.4"
env_logger = "0.9"
chrono = { version = "0.4", features = ["serde"] }
percent-encoding = "2.3.1"
clap = { version = "4.0", features = ["derive"] }
colored = "2.0.0"
capstone = "0.12"
libloading = "0.8"
paste = "1.0"
flate2 = "1.0"
rand = "0.8"
base64 = "0.22"
tokio-tungstenite = "0.24"
futures-util = "0.3"

# yara-x is only available on platforms that support wasmtime
# (not iOS)
[target.'cfg(not(target_os = "ios"))'.dependencies]
yara-x = "0.12"

[features]
default = []
yara = []
ENABLE_LOG_DEVELOP = []

[[bin]]
name = "dbgsrv"
path = "src/main.rs"

# dbg_inspector is only built for macOS, not iOS
# Use: cargo build --lib --target aarch64-apple-darwin
# [lib]
# name = "dbg_inspector"
# crate-type = ["cdylib"]

[lints.rust]
unexpected_cfgs = { level = "warn", check-cfg = ['cfg(host_os, values("windows"))'] }
```

`src/server/build.bat`:

```bat
@echo off
setlocal enabledelayedexpansion

REM NDK toolchain path
set NDK_TOOLCHAIN=%ANDROID_NDK_HOME%\toolchains\llvm\prebuilt\windows-x86_64\bin

REM aarch64
set TARGET=aarch64-linux-android
set TARGET_CC=%NDK_TOOLCHAIN%\aarch64-linux-android33-clang.cmd
set TARGET_CXX=%NDK_TOOLCHAIN%\aarch64-linux-android33-clang++.cmd
set TARGET_AR=%NDK_TOOLCHAIN%\llvm-ar
set TARGET_LINKER=%NDK_TOOLCHAIN%\aarch64-linux-android33-clang.cmd

set CARGO_TARGET_AARCH64_LINUX_ANDROID_LINKER=!TARGET_LINKER!
cargo build --target=!TARGET! --release

endlocal

```

`src/server/build.rs`:

```rs
extern crate cc;
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;

/// Build MachOKit as a static library for the target platform
fn build_machokit(target_os: &str, target_arch: &str) -> Option<PathBuf> {
    let machokit_dir = Path::new("../MachOKit");
    
    if !machokit_dir.exists() {
        println!("cargo:warning=MachOKit directory not found at {:?}", machokit_dir);
        return None;
    }

    // Determine the build directory based on target
    let (swift_target, build_subdir) = match (target_os, target_arch) {
        ("macos", "aarch64") => ("arm64-apple-macosx", "arm64-apple-macosx"),
        ("macos", "x86_64") => ("x86_64-apple-macosx", "x86_64-apple-macosx"),
        ("ios", "aarch64") => ("arm64-apple-ios", "arm64-apple-ios"),
        _ => {
            println!("cargo:warning=Unsupported target for MachOKit: {}-{}", target_os, target_arch);
            return None;
        }
    };

    let release_dir = machokit_dir.join(".build-xcode").join(build_subdir).join("release");
    let static_lib = release_dir.join("libMachOKit.a");

    // Check if we need to rebuild
    let needs_rebuild = !static_lib.exists();

    if needs_rebuild {
        println!("cargo:warning=Building MachOKit for {} ({})...", target_os, target_arch);
        
        // Build MachOKit using Swift Package Manager
        let mut swift_build_cmd = Command::new("swift");
        swift_build_cmd
            .current_dir(machokit_dir)
            .args(&["build", "-c", "release"]);
        
        // For iOS, we need to specify the target and SDK
        if target_os == "ios" {
            // Get iOS SDK path
            if let Ok(sdk_output) = Command::new("xcrun")
                .args(&["--sdk", "iphoneos", "--show-sdk-path"])
                .output()
            {
                let sdk_path = String::from_utf8_lossy(&sdk_output.stdout).trim().to_string();
                swift_build_cmd.args(&["--sdk", &sdk_path, "--triple", swift_target]);
            } else {
                swift_build_cmd.args(&["--triple", swift_target]);
            }
        }
        
        let build_result = swift_build_cmd.output();
        
        match build_result {
            Ok(output) => {
                if !output.status.success() {
                    println!("cargo:warning=MachOKit build failed: {}", String::from_utf8_lossy(&output.stderr));
                    return None;
                }
                println!("cargo:warning=MachOKit build completed successfully");
            }
            Err(e) => {
                println!("cargo:warning=Failed to run swift build: {}", e);
                return None;
            }
        }

        // Create static library from object files
        let machokit_build_dir = release_dir.join("MachOKit.build");
        let machokitc_build_dir = release_dir.join("MachOKitC.build");
        let fileio_build_dir = release_dir.join("FileIO.build");

        if machokit_build_dir.exists() {
            // Collect all .o files
            let mut object_files: Vec<PathBuf> = Vec::new();
            
            for dir in &[&machokit_build_dir, &machokitc_build_dir, &fileio_build_dir] {
                if dir.exists() {
                    if let Ok(entries) = fs::read_dir(dir) {
                        for entry in entries.flatten() {
                            let path = entry.path();
                            if path.extension().map_or(false, |ext| ext == "o") {
                                object_files.push(path);
                            }
                        }
                    }
                }
            }

            if !object_files.is_empty() {
                // Create static library using ar
                let mut ar_cmd = Command::new("ar");
                ar_cmd
                    .current_dir(&release_dir)
                    .arg("-crs")
                    .arg("libMachOKit.a");
                for obj in &object_files {
                    ar_cmd.arg(obj);
                }

                match ar_cmd.output() {
                    Ok(output) => {
                        if output.status.success() {
                            println!("cargo:warning=Created libMachOKit.a with {} object files", object_files.len());
                        } else {
                            println!("cargo:warning=Failed to create static library: {}", String::from_utf8_lossy(&output.stderr));
                            return None;
                        }
                    }
                    Err(e) => {
                        println!("cargo:warning=Failed to run ar: {}", e);
                        return None;
                    }
                }
            }
        }
    }

    if static_lib.exists() {
        Some(release_dir.canonicalize().unwrap_or(release_dir))
    } else {
        None
    }
}

/// Build MachOBridge Swift wrapper using xcodebuild
fn build_macho_bridge(target_os: &str, target_arch: &str) -> Option<PathBuf> {
    let bridge_dir = Path::new("src/swift");
    
    if !bridge_dir.exists() {
        println!("cargo:warning=MachOBridge directory not found at {:?}", bridge_dir);
        return None;
    }

    // Determine destination, SDK, and paths based on target
    // Use separate build directories for each platform to avoid conflicts
    let (destination, sdk, derived_data_suffix, products_subpath) = match (target_os, target_arch) {
        ("macos", "aarch64") | ("macos", "x86_64") => {
            ("generic/platform=macOS", "macosx", "macos", "Build/Products/Release")
        }
        ("ios", "aarch64") => {
            ("generic/platform=iOS", "iphoneos", "ios", "Build/Products/Release-iphoneos")
        }
        _ => {
            println!("cargo:warning=Unsupported target for MachOBridge: {}-{}", target_os, target_arch);
            return None;
        }
    };

    let derived_data_dir = format!(".build-xcode-{}", derived_data_suffix);
    let build_xcode_dir = bridge_dir.join(&derived_data_dir);
    let products_dir = build_xcode_dir.join(products_subpath);
    let static_lib = products_dir.join("libMachOBridge.a");

    // Check if library already exists and has reasonable size (> 1MB) - skip build if valid
    if static_lib.exists() {
        if let Ok(metadata) = fs::metadata(&static_lib) {
            if metadata.len() > 1_000_000 {
                println!("cargo:warning=Using existing libMachOBridge.a at {} ({} bytes)", 
                         static_lib.display(), metadata.len());
                return Some(products_dir.canonicalize().unwrap_or(products_dir));
            } else {
                println!("cargo:warning=Existing libMachOBridge.a is too small ({} bytes), rebuilding...", 
                         metadata.len());
            }
        }
    }

    println!("cargo:warning=Building MachOBridge for {} ({}) using xcodebuild...", target_os, target_arch);
    
    // Build using xcodebuild with code signing disabled for CI environments
    let xcodebuild_args: Vec<String> = vec![
        "-scheme".to_string(), "MachOBridge".to_string(),
        "-configuration".to_string(), "Release".to_string(),
        "-destination".to_string(), destination.to_string(),
        "-sdk".to_string(), sdk.to_string(),
        "-derivedDataPath".to_string(), derived_data_dir.clone(),
        "SKIP_INSTALL=NO".to_string(),
        // Disable code signing for CI builds
        "CODE_SIGN_IDENTITY=".to_string(),
        "CODE_SIGNING_REQUIRED=NO".to_string(),
        "CODE_SIGNING_ALLOWED=NO".to_string(),
        "build".to_string(),
    ];
    
    let build_result = Command::new("xcodebuild")
        .current_dir(bridge_dir)
        .args(&xcodebuild_args)
        .output();
    
    match build_result {
        Ok(output) => {
            if !output.status.success() {
                println!("cargo:warning=MachOBridge xcodebuild failed: {}", String::from_utf8_lossy(&output.stderr));
                println!("cargo:warning=stdout: {}", String::from_utf8_lossy(&output.stdout));
                return None;
            }
            println!("cargo:warning=MachOBridge xcodebuild completed successfully");
        }
        Err(e) => {
            println!("cargo:warning=Failed to run xcodebuild for MachOBridge: {}", e);
            return None;
        }
    }

    // xcodebuild generates .o files in Products dir - we need to create static library manually
    // Convert to absolute paths
    let abs_products_dir = bridge_dir.canonicalize()
        .unwrap_or_else(|_| bridge_dir.to_path_buf())
        .join(&derived_data_dir)
        .join(products_subpath);
    let abs_static_lib = abs_products_dir.join("libMachOBridge.a");
    
    // Collect .o files from Products directory (MachOBridge.o, MachOKit.o, FileIO.o, MachOKitC.o)
    let object_files: Vec<PathBuf> = ["MachOBridge.o", "MachOKit.o", "FileIO.o", "MachOKitC.o"]
        .iter()
        .map(|name| abs_products_dir.join(name))
        .filter(|p| p.exists())
        .collect();
    
    if object_files.is_empty() {
        println!("cargo:warning=No object files found in {:?}", abs_products_dir);
        return None;
    }
    
    println!("cargo:warning=Found {} object files to archive: {:?}", object_files.len(), 
             object_files.iter().map(|p| p.file_name().unwrap_or_default()).collect::<Vec<_>>());
    
    // Remove existing library if present (may have wrong permissions)
    if abs_static_lib.exists() {
        let _ = fs::remove_file(&abs_static_lib);
    }
    
    // Create the static library using ar
    let mut ar_cmd = Command::new("ar");
    ar_cmd
        .arg("-crs")
        .arg(&abs_static_lib);
    
    for obj in &object_files {
        ar_cmd.arg(obj);
    }
    
    match ar_cmd.output() {
        Ok(output) => {
            if output.status.success() {
                println!("cargo:warning=Created libMachOBridge.a with {} object files", object_files.len());
            } else {
                println!("cargo:warning=Failed to create libMachOBridge.a: {}", String::from_utf8_lossy(&output.stderr));
                return None;
            }
        }
        Err(e) => {
            println!("cargo:warning=Failed to run ar: {}", e);
            return None;
        }
    }

    if abs_static_lib.exists() {
        println!("cargo:warning=libMachOBridge.a created at {}", abs_static_lib.display());
        return Some(abs_products_dir);
    }
    
    None
}

/// Setup MachOKit linking for macOS/iOS targets
fn setup_machokit_linking(target_os: &str, target_arch: &str) {
    let mut machokit_lib_path: Option<PathBuf> = None;
    let mut macho_bridge_lib_path: Option<PathBuf> = None;
    
    // Build MachOKit
    if let Some(lib_path) = build_machokit(target_os, target_arch) {
        machokit_lib_path = Some(lib_path.clone());
        println!("cargo:warning=MachOKit built at {}", lib_path.display());
    }
    
    // Build MachOBridge
    if let Some(bridge_lib_path) = build_macho_bridge(target_os, target_arch) {
        macho_bridge_lib_path = Some(bridge_lib_path.clone());
        println!("cargo:warning=MachOBridge built at {}", bridge_lib_path.display());
    }
    
    // Link Swift libraries directly using linker args for proper ordering
    // Order matters: MachOBridge depends on MachOKit
    if let Some(ref bridge_path) = macho_bridge_lib_path {
        let lib_file = bridge_path.join("libMachOBridge.a");
        if lib_file.exists() {
            // Use -force_load to ensure all symbols are included
            println!("cargo:rustc-link-arg=-force_load");
            println!("cargo:rustc-link-arg={}", lib_file.display());
            println!("cargo:warning=MachOBridge linked via -force_load: {}", lib_file.display());
        }
    }
    
    if let Some(ref machokit_path) = machokit_lib_path {
        let lib_file = machokit_path.join("libMachOKit.a");
        if lib_file.exists() {
            println!("cargo:rustc-link-arg=-force_load");
            println!("cargo:rustc-link-arg={}", lib_file.display());
            println!("cargo:warning=MachOKit linked via -force_load: {}", lib_file.display());
        }
    }
    
    // Swift runtime libraries needed for MachOKit/MachOBridge
    println!("cargo:rustc-link-arg=-Xlinker");
    println!("cargo:rustc-link-arg=-rpath");
    println!("cargo:rustc-link-arg=-Xlinker");
    println!("cargo:rustc-link-arg=/usr/lib/swift");
    
    // Get Swift library paths based on target
    let swift_platform = if target_os == "ios" { "iphoneos" } else { "macosx" };
    let sdk_name = if target_os == "ios" { "iphoneos" } else { "macosx" };
    
    // Link Swift standard library from SDK
    if let Ok(sdk_output) = Command::new("xcrun")
        .args(&["--sdk", sdk_name, "--show-sdk-path"])
        .output() {
        let sdk_path = String::from_utf8_lossy(&sdk_output.stdout).trim().to_string();
        let swift_lib_sdk = format!("{}/usr/lib/swift", sdk_path);
        println!("cargo:rustc-link-search=native={}", swift_lib_sdk);
    }
    
    // Get Swift toolchain library path and link static Swift runtime
    if let Ok(swift_lib_path) = Command::new("xcrun")
        .args(&["--toolchain", "default", "--find", "swift"])
        .output() {
        let swift_path = String::from_utf8_lossy(&swift_lib_path.stdout).trim().to_string();
        if let Some(parent) = Path::new(&swift_path).parent().and_then(|p| p.parent()) {
            let swift_lib = parent.join(format!("lib/swift/{}", swift_platform));
            if swift_lib.exists() {
                println!("cargo:rustc-link-search=native={}", swift_lib.display());
            }
            // Add static lib path for Swift runtime (only if libswiftCore.a exists)
            let swift_lib_static = parent.join(format!("lib/swift_static/{}", swift_platform));
            let swift_core_static = swift_lib_static.join("libswiftCore.a");
            if swift_core_static.exists() {
                println!("cargo:rustc-link-search=native={}", swift_lib_static.display());
                // Link Swift static runtime libraries
                println!("cargo:rustc-link-lib=static=swiftCore");
                println!("cargo:rustc-link-lib=static=swiftCompatibility50");
                println!("cargo:rustc-link-lib=static=swiftCompatibility51");
                println!("cargo:rustc-link-lib=static=swiftCompatibilityConcurrency");
                println!("cargo:rustc-link-lib=static=swift_Concurrency");
                println!("cargo:warning=Linked Swift static runtime from {}", swift_lib_static.display());
            } else {
                // Fall back to dynamic Swift runtime
                println!("cargo:warning=Swift static runtime not found, using dynamic linking");
            }
            
            // Also check clang lib for __chkstk_darwin
            let clang_lib = parent.join("lib/clang");
            if clang_lib.exists() {
                // Find the clang version directory
                if let Ok(entries) = fs::read_dir(&clang_lib) {
                    for entry in entries.flatten() {
                        let clang_rt_path = entry.path().join(format!("lib/darwin/libclang_rt.{}.a", swift_platform));
                        if clang_rt_path.exists() {
                            println!("cargo:rustc-link-arg={}", clang_rt_path.display());
                            println!("cargo:warning=Linked clang runtime: {}", clang_rt_path.display());
                            break;
                        }
                        // Also try ios.a format
                        let clang_rt_ios = entry.path().join("lib/darwin/libclang_rt.ios.a");
                        if clang_rt_ios.exists() {
                            println!("cargo:rustc-link-arg={}", clang_rt_ios.display());
                            println!("cargo:warning=Linked clang runtime: {}", clang_rt_ios.display());
                            break;
                        }
                    }
                }
            }
        }
    }
    
    // Link system libraries required by Swift
    println!("cargo:rustc-link-lib=c++");
}

fn main() {
    println!("cargo:rustc-link-search=native=/usr/local/lib");

    let target_os = std::env::var("CARGO_CFG_TARGET_OS").unwrap();
    let target_arch = std::env::var("CARGO_CFG_TARGET_ARCH").unwrap_or_else(|_| "aarch64".to_string());
    
    // Build and link MachOKit for macOS/iOS targets
    if target_os == "macos" || target_os == "ios" {
        setup_machokit_linking(&target_os, &target_arch);
    }


    let mut build = cc::Build::new();
    println!("cargo:rustc-env=TARGET_OS={}", target_os);
    
    // Set GIT_HASH
    let git_hash = std::process::Command::new("git")
        .args(&["rev-parse", "--short", "HEAD"])
        .output()
        .ok()
        .and_then(|o| String::from_utf8(o.stdout).ok())
        .map(|s| s.trim().to_string())
        .unwrap_or_else(|| "unknown".to_string());
    println!("cargo:rustc-env=GIT_HASH={}", git_hash);

    if cfg!(windows) {
        println!("cargo:rustc-cfg=host_os=\"windows\"");
    }

    if target_os == "windows" {
        build.flag("/std:c++17").flag("/W4").flag("/Zi");
    } else {
        build.flag("-std=c++17").flag("-Wall").flag("-v").flag("-g");
    }

    // Check if LOG_DEVELOP should be enabled
    let enable_log_develop = std::env::var("ENABLE_LOG_DEVELOP").is_ok();
    if enable_log_develop {
        build.flag_if_supported("-DENABLE_LOG_DEVELOP");
        // Rustコード用のcfgフラグを設定
        println!("cargo:rustc-cfg=feature=\"ENABLE_LOG_DEVELOP\"");
    } 

    match target_os.as_str() {
        "windows" => {
            if build.get_compiler().is_like_msvc() {
                build.flag("/FS"); // Fixes the PDB write issue
                build.flag("/EHsc"); // Enables proper exception handling
            }
            // Link with Windows debug help library for symbol enumeration
            println!("cargo:rustc-link-lib=dbghelp");
            
            // Track source file changes for incremental builds
            println!("cargo:rerun-if-changed=src/cpp/src/windows/core/native_api.cpp");
            println!("cargo:rerun-if-changed=src/cpp/src/windows/core/native_api.h");
            println!("cargo:rerun-if-changed=src/cpp/src/windows/core/memory_io.cpp");
            println!("cargo:rerun-if-changed=src/cpp/src/windows/core/memory_io.h");
            println!("cargo:rerun-if-changed=src/cpp/src/windows/core/file_api.cpp");
            println!("cargo:rerun-if-changed=src/cpp/src/windows/core/file_api.h");
            println!("cargo:rerun-if-changed=src/cpp/src/windows/core/callback_stubs.cpp");
            println!("cargo:rerun-if-changed=src/cpp/src/windows/debugger/debugger.cpp");
            println!("cargo:rerun-if-changed=src/cpp/src/windows/debugger/debugger.h");
            println!("cargo:rerun-if-changed=src/cpp/src/common/exception_info.h");
            
            build.file("src/cpp/src/windows/core/native_api.cpp");
            build.file("src/cpp/src/windows/core/memory_io.cpp");
            build.file("src/cpp/src/windows/core/file_api.cpp");
            build.file("src/cpp/src/windows/core/callback_stubs.cpp");
            build.file("src/cpp/src/windows/debugger/debugger.cpp");
        }
        "macos" => {
            println!("cargo:rustc-link-arg=-lc++");
            println!("cargo:rustc-link-arg=-framework");
            println!("cargo:rustc-link-arg=Foundation");
            println!("cargo:rustc-link-arg=-framework");
            println!("cargo:rustc-link-arg=AVFoundation");
            println!("cargo:rustc-link-arg=-framework");
            println!("cargo:rustc-link-arg=CoreMedia");
            println!("cargo:rustc-link-arg=-framework");
            println!("cargo:rustc-link-arg=BackgroundTasks");
            println!("cargo:rustc-link-arg=-framework");
            println!("cargo:rustc-link-arg=SystemConfiguration");

            // Set macOS deployment target
            build.flag("-mmacosx-version-min=10.12");

            build.file("src/cpp/src/darwin/core/native_api.mm");
            build.file("src/cpp/src/darwin/core/file_api.mm");
            build.file("src/cpp/src/darwin/core/memory_io.mm");
            build.file("src/cpp/src/darwin/core/process_api.mm");
            // Debugger (split into multiple files)
            build.file("src/cpp/src/darwin/debugger/debugger_core.mm");
            build.file("src/cpp/src/darwin/debugger/debugger_breakpoint.mm");
            build.file("src/cpp/src/darwin/debugger/debugger_watchpoint.mm");
            build.file("src/cpp/src/darwin/debugger/debugger_exception.mm");
            build.file("src/cpp/src/darwin/debugger/debugger_register.mm");
            build.file("src/cpp/src/darwin/debugger/debugger_trace.mm");
            build.file("src/cpp/src/darwin/debugger/debugger_native_api.mm");
            build.file("src/cpp/src/common/util.cpp");
            build.file("src/cpp/src/common/trace_file.cpp");
            build.file("src/cpp/src/common/arm64_decoder.cpp");
        }
        "ios" => {
            println!("cargo:rustc-link-arg=-lc++");
            println!("cargo:rustc-link-arg=-framework");
            println!("cargo:rustc-link-arg=Foundation");
            println!("cargo:rustc-link-arg=-framework");
            println!("cargo:rustc-link-arg=UIKit");
            println!("cargo:rustc-link-arg=-framework");
            println!("cargo:rustc-link-arg=AVFoundation");
            println!("cargo:rustc-link-arg=-framework");
            println!("cargo:rustc-link-arg=CoreMedia");
            println!("cargo:rustc-link-arg=-framework");
            println!("cargo:rustc-link-arg=BackgroundTasks");
            println!("cargo:rustc-link-arg=-framework");
            println!("cargo:rustc-link-arg=SystemConfiguration");

            // Set iOS deployment target to match Rust's target
            build.flag("-mios-version-min=10.0");

            build.file("src/cpp/src/darwin/core/native_api.mm");
            build.file("src/cpp/src/darwin/core/file_api.mm");
            build.file("src/cpp/src/darwin/core/memory_io.mm");
            build.file("src/cpp/src/darwin/core/process_api.mm");
            // Debugger (split into multiple files)
            build.file("src/cpp/src/darwin/debugger/debugger_core.mm");
            build.file("src/cpp/src/darwin/debugger/debugger_breakpoint.mm");
            build.file("src/cpp/src/darwin/debugger/debugger_watchpoint.mm");
            build.file("src/cpp/src/darwin/debugger/debugger_exception.mm");
            build.file("src/cpp/src/darwin/debugger/debugger_register.mm");
            build.file("src/cpp/src/darwin/debugger/debugger_trace.mm");
            build.file("src/cpp/src/darwin/debugger/debugger_native_api.mm");
            build.file("src/cpp/src/common/util.cpp");
            build.file("src/cpp/src/common/trace_file.cpp");
            build.file("src/cpp/src/common/arm64_decoder.cpp");
        }


        "android" => {
            build.cpp_link_stdlib("c++");
            println!("cargo:rustc-link-lib=dylib=c++_shared");
            println!("cargo:rustc-link-lib=dylib=c++abi");
            println!("cargo:rustc-link-arg=-Wl,-rpath={}", "$ORIGIN");
            build.flag_if_supported("-DTARGET_IS_ANDROID");
            // Core
            build.file("src/cpp/src/linux/core/native_api.cpp");
            build.file("src/cpp/src/linux/core/file_api.cpp");
            build.file("src/cpp/src/linux/core/memory_io.cpp");
            build.file("src/cpp/src/linux/core/callback_stubs.cpp");
            build.file("src/cpp/src/linux/core/process_api.cpp");
            // Debugger (split into multiple files)
            build.file("src/cpp/src/linux/debugger/debugger_core.cpp");
            build.file("src/cpp/src/linux/debugger/debugger_breakpoint.cpp");
            build.file("src/cpp/src/linux/debugger/debugger_watchpoint.cpp");
            build.file("src/cpp/src/linux/debugger/debugger_exception.cpp");
            build.file("src/cpp/src/linux/debugger/debugger_register.cpp");
            build.file("src/cpp/src/linux/debugger/debugger_thread.cpp");
            build.file("src/cpp/src/linux/debugger/debugger_spawn.cpp");
            build.file("src/cpp/src/linux/debugger/debugger_memory.cpp");
            build.file("src/cpp/src/linux/debugger/debugger_native_api.cpp");
            // ELF
            build.file("src/cpp/src/linux/elf/elf_parser.cpp");
            // PTY
            build.file("src/cpp/src/linux/pty/pty_manager.cpp");
            // Common
            build.file("src/cpp/src/common/util.cpp");
        }

        "linux" => {
            build.cpp(true);
            println!("cargo:rustc-link-arg=-lstdc++");
            // Export symbols from executable so dynamic library can resolve them via dlsym
            println!("cargo:rustc-link-arg=-rdynamic");
            // Add debug symbols and additional debugging info
            build.flag("-DDEBUG_MEMORY_ACCESS");
            build.flag("-DVERBOSE_LOGGING");
            // Core
            build.file("src/cpp/src/linux/core/native_api.cpp");
            build.file("src/cpp/src/linux/core/file_api.cpp");
            build.file("src/cpp/src/linux/core/memory_io.cpp");
            build.file("src/cpp/src/linux/core/callback_stubs.cpp");
            build.file("src/cpp/src/linux/core/process_api.cpp");
            // Debugger (split into multiple files)
            build.file("src/cpp/src/linux/debugger/debugger_core.cpp");
            build.file("src/cpp/src/linux/debugger/debugger_breakpoint.cpp");
            build.file("src/cpp/src/linux/debugger/debugger_watchpoint.cpp");
            build.file("src/cpp/src/linux/debugger/debugger_exception.cpp");
            build.file("src/cpp/src/linux/debugger/debugger_register.cpp");
            build.file("src/cpp/src/linux/debugger/debugger_thread.cpp");
            build.file("src/cpp/src/linux/debugger/debugger_spawn.cpp");
            build.file("src/cpp/src/linux/debugger/debugger_memory.cpp");
            build.file("src/cpp/src/linux/debugger/debugger_native_api.cpp");
            // ELF
            build.file("src/cpp/src/linux/elf/elf_parser.cpp");
            // PTY
            build.file("src/cpp/src/linux/pty/pty_manager.cpp");
            // Common
            build.file("src/cpp/src/common/util.cpp");
        }

        _ => {
            panic!("Unsupported target OS");
        }
    }

    build.compile("libnative.a");
}

```

`src/server/build.sh`:

```sh
#!/bin/bash

# Parse arguments
CPP_ONLY=false
SWIFT_ONLY=false
TARGET=""
TARGET_PLATFORM=""

# Set LOG_DEVELOP flag based on environment variable
if [ -n "$ENABLE_LOG_DEVELOP" ]; then
    BUILD_TIMESTAMP=$(date "+%Y-%m-%dT%H:%M:%S")
    LOG_DEVELOP_FLAG="-DENABLE_LOG_DEVELOP -DBUILD_TIMESTAMP='\"$BUILD_TIMESTAMP\"'"
    echo "Build timestamp: $BUILD_TIMESTAMP"
else
    LOG_DEVELOP_FLAG=""
fi

while [[ $# -gt 0 ]]; do
    case $1 in
        --cpp-only)
            CPP_ONLY=true
            shift
            ;;
        --swift-only)
            SWIFT_ONLY=true
            shift
            ;;
        --target)
            TARGET_PLATFORM="$2"
            shift 2
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Function to clone MachOKit if not present
# MachOKit is cloned to src/MachOKit (relative to repo root) because
# Package.swift references ../../../MachOKit from src/server/src/swift
ensure_machokit() {
    # From src/server, go up to repo root then to src/MachOKit
    MACHOKIT_DIR="../MachOKit"
    if [ ! -d "$MACHOKIT_DIR" ]; then
        echo "MachOKit not found at $MACHOKIT_DIR. Cloning from GitHub..."
        git clone --depth 1 https://github.com/p-x9/MachOKit.git "$MACHOKIT_DIR"
        if [ $? -ne 0 ]; then
            echo "Error: Failed to clone MachOKit"
            exit 1
        fi
        echo "MachOKit cloned successfully to $MACHOKIT_DIR"
    fi
}

# Function to build MachOKit for iOS
build_machokit_ios() {
    echo "Building MachOKit for iOS..."
    
    ensure_machokit
    MACHOKIT_DIR="../MachOKit"
    
    SDK_PATH=$(xcrun --sdk iphoneos --show-sdk-path)
    
    cd "$MACHOKIT_DIR"
    swift build -c release --sdk "$SDK_PATH" --triple arm64-apple-ios
    cd - > /dev/null
    
    echo "MachOKit build complete."
}

# Function to build MachOKit for macOS
build_machokit_mac() {
    echo "Building MachOKit for macOS..."
    
    ensure_machokit
    MACHOKIT_DIR="../MachOKit"
    
    cd "$MACHOKIT_DIR"
    swift build -c release
    cd - > /dev/null
    
    echo "MachOKit build complete."
}

# Function to build MachOBridge for iOS
build_macho_bridge_ios() {
    echo "Building MachOBridge for iOS..."
    
    BRIDGE_DIR="src/swift"
    if [ ! -d "$BRIDGE_DIR" ]; then
        echo "Error: MachOBridge directory not found at $BRIDGE_DIR"
        exit 1
    fi
    
    cd "$BRIDGE_DIR"
    xcodebuild -scheme MachOBridge \
        -configuration Release \
        -destination "generic/platform=iOS" \
        -sdk iphoneos \
        -derivedDataPath .build-xcode-ios \
        SKIP_INSTALL=NO \
        CODE_SIGN_IDENTITY="" \
        CODE_SIGNING_REQUIRED=NO \
        CODE_SIGNING_ALLOWED=NO \
        build
    
    # Create static library from object files
    PRODUCTS_DIR=".build-xcode-ios/Build/Products/Release-iphoneos"
    if [ -d "$PRODUCTS_DIR" ]; then
        echo "Creating libMachOBridge.a..."
        cd "$PRODUCTS_DIR"
        ar -crs libMachOBridge.a MachOBridge.o MachOKit.o FileIO.o MachOKitC.o
        echo "Created libMachOBridge.a ($(ls -la libMachOBridge.a | awk '{print $5}') bytes)"
        cd - > /dev/null
    fi
    
    cd - > /dev/null
    
    echo "MachOBridge build complete."
}

# Function to build MachOBridge for macOS
build_macho_bridge_mac() {
    echo "Building MachOBridge for macOS..."
    
    BRIDGE_DIR="src/swift"
    if [ ! -d "$BRIDGE_DIR" ]; then
        echo "Error: MachOBridge directory not found at $BRIDGE_DIR"
        exit 1
    fi
    
    cd "$BRIDGE_DIR"
    xcodebuild -scheme MachOBridge \
        -configuration Release \
        -destination "generic/platform=macOS" \
        -sdk macosx \
        -derivedDataPath .build-xcode-macos \
        SKIP_INSTALL=NO \
        CODE_SIGN_IDENTITY="" \
        CODE_SIGNING_REQUIRED=NO \
        CODE_SIGNING_ALLOWED=NO \
        build
    
    # Create static library from object files
    PRODUCTS_DIR=".build-xcode-macos/Build/Products/Release"
    if [ -d "$PRODUCTS_DIR" ]; then
        echo "Creating libMachOBridge.a..."
        cd "$PRODUCTS_DIR"
        ar -crs libMachOBridge.a MachOBridge.o MachOKit.o FileIO.o MachOKitC.o
        echo "Created libMachOBridge.a ($(ls -la libMachOBridge.a | awk '{print $5}') bytes)"
        cd - > /dev/null
    fi
    
    cd - > /dev/null
    
    echo "MachOBridge build complete."
}

# Function to build Swift components only for iOS
build_swift_ios() {
    echo "Building Swift components for iOS..."
    build_machokit_ios
    build_macho_bridge_ios
    echo "Swift build complete for iOS."
}

# Function to build Swift components only for macOS
build_swift_mac() {
    echo "Building Swift components for macOS..."
    build_machokit_mac
    build_macho_bridge_mac
    echo "Swift build complete for macOS."
}

# Function to build C++ only for iOS
build_cpp_ios() {
    echo "Building C++ only for iOS..."
    
    SDK_PATH=$(xcrun --sdk iphoneos --show-sdk-path)
    TARGET_CC=$(xcrun --sdk iphoneos --find clang)
    TARGET_CXX=$(xcrun --sdk iphoneos --find clang++)
    
    CPP_DIR="src/cpp/src"
    OUT_DIR="target/aarch64-apple-ios/debug"
    
    # Create output directory if it doesn't exist
    mkdir -p "$OUT_DIR"
    
    # Compile each .mm file
    OBJECTS=""
    for file in "$CPP_DIR/darwin/core/native_api.mm" "$CPP_DIR/darwin/core/file_api.mm" \
                "$CPP_DIR/darwin/debugger/debugger_core.mm" \
                "$CPP_DIR/darwin/debugger/debugger_breakpoint.mm" \
                "$CPP_DIR/darwin/debugger/debugger_watchpoint.mm" \
                "$CPP_DIR/darwin/debugger/debugger_exception.mm" \
                "$CPP_DIR/darwin/debugger/debugger_register.mm" \
                "$CPP_DIR/darwin/debugger/debugger_trace.mm" \
                "$CPP_DIR/darwin/debugger/debugger_native_api.mm" \
                "$CPP_DIR/common/util.cpp"; do
        if [ -f "$file" ]; then
            basename=$(basename "$file")
            objname="${basename%.*}.o"
            echo "Compiling $file..."
            $TARGET_CXX -c "$file" \
                -target arm64-apple-ios \
                -isysroot "$SDK_PATH" \
                -std=c++17 \
                -Wall \
                -g \
                -mios-version-min=10.0 \
                $LOG_DEVELOP_FLAG \
                -I"$CPP_DIR" \
                -o "$OUT_DIR/$objname"
            OBJECTS="$OBJECTS $OUT_DIR/$objname"
        fi
    done
    
    # Create static library
    echo "Creating libnative.a..."
    $(xcrun --sdk iphoneos --find ar) rcs "$OUT_DIR/libnative.a" $OBJECTS
    
    echo "C++ build complete. Library at: $OUT_DIR/libnative.a"
    
    # Now run cargo with minimal rebuild (touching only native bridge)
    echo "Running cargo build to link..."
    ENABLE_LOG_DEVELOP=1 \
        CARGO_TARGET_AARCH64_APPLE_IOS_LINKER=$(xcrun --sdk iphoneos --find clang) \
        TARGET_AR=$(xcrun --sdk iphoneos --find ar) \
        TARGET_CC=$TARGET_CC \
        TARGET_CXX=$TARGET_CXX \
        cargo build --target=aarch64-apple-ios
}

# Function to build C++ only for macOS
build_cpp_mac() {
    echo "Building C++ only for macOS..."
    
    CPP_DIR="src/cpp/src"
    OUT_DIR="target/aarch64-apple-darwin/debug"
    
    mkdir -p "$OUT_DIR"
    
    OBJECTS=""
    for file in "$CPP_DIR/darwin/core/native_api.mm" "$CPP_DIR/darwin/core/file_api.mm" \
                "$CPP_DIR/darwin/debugger/debugger_core.mm" \
                "$CPP_DIR/darwin/debugger/debugger_breakpoint.mm" \
                "$CPP_DIR/darwin/debugger/debugger_watchpoint.mm" \
                "$CPP_DIR/darwin/debugger/debugger_exception.mm" \
                "$CPP_DIR/darwin/debugger/debugger_register.mm" \
                "$CPP_DIR/darwin/debugger/debugger_trace.mm" \
                "$CPP_DIR/darwin/debugger/debugger_native_api.mm" \
                "$CPP_DIR/common/util.cpp"; do
        if [ -f "$file" ]; then
            basename=$(basename "$file")
            objname="${basename%.*}.o"
            echo "Compiling $file..."
            clang++ -c "$file" \
                -target arm64-apple-macos \
                -std=c++17 \
                -Wall \
                -g \
                -mmacosx-version-min=10.12 \
                $LOG_DEVELOP_FLAG \
                -I"$CPP_DIR" \
                -o "$OUT_DIR/$objname"
            OBJECTS="$OBJECTS $OUT_DIR/$objname"
        fi
    done
    
    echo "Creating libnative.a..."
    ar rcs "$OUT_DIR/libnative.a" $OBJECTS
    
    echo "C++ build complete. Library at: $OUT_DIR/libnative.a"
    
    echo "Running cargo build to link..."
    ENABLE_LOG_DEVELOP=1 cargo build --target=aarch64-apple-darwin
}

# Function to build C++ only for Android
build_cpp_android() {
    echo "Building C++ only for Android..."
    
    # Find the actual prebuilt directory (darwin-x86_64 or linux-x86_64)
    NDK_PREBUILT_DIR=$(ls -d "$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/"*/ 2>/dev/null | head -1)
    if [ -z "$NDK_PREBUILT_DIR" ]; then
        echo "Error: Could not find NDK prebuilt directory"
        exit 1
    fi
    NDK_BIN_PATH="${NDK_PREBUILT_DIR}bin"
    TARGET=aarch64-linux-android
    TARGET_CC=$NDK_BIN_PATH/aarch64-linux-android33-clang
    TARGET_CXX=$NDK_BIN_PATH/aarch64-linux-android33-clang++
    TARGET_AR=$NDK_BIN_PATH/llvm-ar
    
    CPP_DIR="src/cpp/src"
    OUT_DIR="target/$TARGET/release"
    
    mkdir -p "$OUT_DIR"
    
    OBJECTS=""
    for file in "$CPP_DIR/linux/native_api.cpp" "$CPP_DIR/linux/file_api.cpp" "$CPP_DIR/linux/debugger.cpp" "$CPP_DIR/common/util.cpp"; do
        if [ -f "$file" ]; then
            basename=$(basename "$file")
            objname="${basename%.*}.o"
            echo "Compiling $file..."
            $TARGET_CXX -c "$file" \
                -target aarch64-linux-android33 \
                -std=c++17 \
                -Wall \
                -g \
                -DTARGET_IS_ANDROID \
                $LOG_DEVELOP_FLAG \
                -I"$CPP_DIR" \
                -o "$OUT_DIR/$objname"
            OBJECTS="$OBJECTS $OUT_DIR/$objname"
        fi
    done
    
    echo "Creating libnative.a..."
    $TARGET_AR rcs "$OUT_DIR/libnative.a" $OBJECTS
    
    echo "C++ build complete. Library at: $OUT_DIR/libnative.a"
    
    echo "Running cargo build to link..."
    ENABLE_LOG_DEVELOP=1 \
        CARGO_TARGET_AARCH64_LINUX_ANDROID_LINKER=$NDK_BIN_PATH/aarch64-linux-android33-clang \
        TARGET_AR=$TARGET_AR \
        TARGET_CC=$TARGET_CC \
        TARGET_CXX=$TARGET_CXX \
        cargo build --target=$TARGET --release
}

# Function to build C++ only for Linux x86_64
build_cpp_linux_x86_64() {
    echo "Building C++ only for Linux x86_64..."
    
    CPP_DIR="src/cpp/src"
    OUT_DIR="target/x86_64-unknown-linux-gnu/debug"
    
    mkdir -p "$OUT_DIR"
    
    OBJECTS=""
    for file in "$CPP_DIR/linux/native_api.cpp" "$CPP_DIR/linux/file_api.cpp" "$CPP_DIR/linux/debugger.cpp" "$CPP_DIR/common/util.cpp"; do
        if [ -f "$file" ]; then
            basename=$(basename "$file")
            objname="${basename%.*}.o"
            echo "Compiling $file..."
            g++ -c "$file" \
                -std=c++17 \
                -Wall \
                -g \
                -fPIC \
                $LOG_DEVELOP_FLAG \
                -I"$CPP_DIR" \
                -o "$OUT_DIR/$objname"
            OBJECTS="$OBJECTS $OUT_DIR/$objname"
        fi
    done
    
    echo "Creating libnative.a..."
    ar rcs "$OUT_DIR/libnative.a" $OBJECTS
    
    echo "C++ build complete. Library at: $OUT_DIR/libnative.a"
    
    echo "Running cargo build to link..."
    ENABLE_LOG_DEVELOP=1 cargo build --target=x86_64-unknown-linux-gnu
}

# Function to build C++ only for Linux aarch64
build_cpp_linux_aarch64() {
    echo "Building C++ only for Linux aarch64..."
    
    CPP_DIR="src/cpp/src"
    OUT_DIR="target/aarch64-unknown-linux-gnu/debug"
    
    mkdir -p "$OUT_DIR"
    
    OBJECTS=""
    for file in "$CPP_DIR/linux/native_api.cpp" "$CPP_DIR/linux/file_api.cpp" "$CPP_DIR/linux/debugger.cpp" "$CPP_DIR/common/util.cpp"; do
        if [ -f "$file" ]; then
            basename=$(basename "$file")
            objname="${basename%.*}.o"
            echo "Compiling $file..."
            g++ -c "$file" \
                -std=c++17 \
                -Wall \
                -g \
                -fPIC \
                $LOG_DEVELOP_FLAG \
                -I"$CPP_DIR" \
                -o "$OUT_DIR/$objname"
            OBJECTS="$OBJECTS $OUT_DIR/$objname"
        fi
    done
    
    echo "Creating libnative.a..."
    ar rcs "$OUT_DIR/libnative.a" $OBJECTS
    
    echo "C++ build complete. Library at: $OUT_DIR/libnative.a"
    
    echo "Running cargo build to link..."
    ENABLE_LOG_DEVELOP=1 cargo build --target=aarch64-unknown-linux-gnu
}

# Main logic
if [ -z "$TARGET_PLATFORM" ]; then
    echo "Usage: ./build.sh --target <target> [--cpp-only] [--swift-only]"
    echo "Available targets: android, ios, mac, linux, linux-x86_64, linux-aarch64"
    echo "Options:"
    echo "  --cpp-only    Build only C++ files and relink"
    echo "  --swift-only  Build only Swift/MachOKit components (iOS/macOS only)"
    exit 1
fi

case $TARGET_PLATFORM in
    android)
        if [ "$CPP_ONLY" = true ]; then
            build_cpp_android
        elif [ "$SWIFT_ONLY" = true ]; then
            echo "Swift components are not available for Android."
            exit 1
        else
            # aarch64
            # Find the actual prebuilt directory (darwin-x86_64 or linux-x86_64)
            NDK_PREBUILT_DIR=$(ls -d "$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/"*/ 2>/dev/null | head -1)
            if [ -z "$NDK_PREBUILT_DIR" ]; then
                echo "Error: Could not find NDK prebuilt directory"
                exit 1
            fi
            NDK_BIN_PATH="${NDK_PREBUILT_DIR}bin"
            TARGET=aarch64-linux-android
            TARGET_CC=$NDK_BIN_PATH/aarch64-linux-android33-clang
            TARGET_CXX=$NDK_BIN_PATH/aarch64-linux-android33-clang++
            TARGET_AR=$NDK_BIN_PATH/llvm-ar
            TARGET_LINKER=$NDK_BIN_PATH/aarch64-linux-android33-clang

            ENABLE_LOG_DEVELOP=1 \
                 CARGO_TARGET_AARCH64_LINUX_ANDROID_LINKER=$TARGET_LINKER \
                 TARGET_AR=$TARGET_AR \
                 TARGET_CC=$TARGET_CC \
                 TARGET_CXX=$TARGET_CXX \
                 cargo build --target=$TARGET --release
        fi
        ;;
    ios)
        if [ "$CPP_ONLY" = true ]; then
            build_cpp_ios
        elif [ "$SWIFT_ONLY" = true ]; then
            build_swift_ios
        else
            # Build Swift components (MachOKit + MachOBridge) first
            build_swift_ios
            
            TARGET=aarch64-apple-ios
            TARGET_CC=$(xcrun --sdk iphoneos --find clang)
            TARGET_CXX=$(xcrun --sdk iphoneos --find clang++)
            TARGET_AR=$(xcrun --sdk iphoneos --find ar)
            TARGET_LINKER=$(xcrun --sdk iphoneos --find clang)

            ENABLE_LOG_DEVELOP=1 \
                    CARGO_TARGET_AARCH64_APPLE_IOS_LINKER=$TARGET_LINKER \
                    TARGET_AR=$TARGET_AR \
                    TARGET_CC=$TARGET_CC \
                    TARGET_CXX=$TARGET_CXX \
                    cargo build --target=$TARGET --release
        fi
        ;;
    mac)
        if [ "$CPP_ONLY" = true ]; then
            build_cpp_mac
        elif [ "$SWIFT_ONLY" = true ]; then
            build_swift_mac
        else
            # Build Swift components (MachOKit + MachOBridge) first
            build_swift_mac
            
            TARGET=aarch64-apple-darwin
            ENABLE_LOG_DEVELOP=1 cargo build --target=$TARGET
        fi
        ;;
    linux|linux-x86_64)
        if [ "$CPP_ONLY" = true ]; then
            build_cpp_linux_x86_64
        elif [ "$SWIFT_ONLY" = true ]; then
            echo "Swift components are not available for Linux."
            exit 1
        else
            TARGET=x86_64-unknown-linux-gnu
            ENABLE_LOG_DEVELOP=1 cargo build --target=$TARGET
        fi
        ;;
    linux-aarch64)
        if [ "$CPP_ONLY" = true ]; then
            build_cpp_linux_aarch64
        elif [ "$SWIFT_ONLY" = true ]; then
            echo "Swift components are not available for Linux."
            exit 1
        else
            TARGET=aarch64-unknown-linux-gnu
            ENABLE_LOG_DEVELOP=1 cargo build --target=$TARGET
        fi
        ;;
    *)
        echo "Unknown target: $TARGET_PLATFORM"
        exit 1
        ;;
esac
```

`src/server/deny.toml`:

```toml
# cargo-deny configuration for server
# Run with: cargo deny check
# Install with: cargo install cargo-deny

[advisories]
db-path = "~/.cargo/advisory-db"
db-urls = ["https://github.com/rustsec/advisory-db"]
version = 2

# Use 'ignore' to specify advisories to skip
ignore = [
    # Example: "RUSTSEC-2020-0001"
]

[licenses]
# List of explicitly allowed licenses
allow = [
    "MIT",
    "Apache-2.0",
    "Apache-2.0 WITH LLVM-exception",
    "BSD-2-Clause",
    "BSD-3-Clause",
    "ISC",
    "Zlib",
    "0BSD",
    "CC0-1.0",
    "Unlicense",
    "BSL-1.0",        # Boost Software License
    "Unicode-DFS-2016",
    "MPL-2.0",        # Mozilla Public License (weak copyleft, file-level only)
]

# Confidence threshold for detecting a license
confidence-threshold = 0.8

# Allow 1 or more licenses on a per-crate basis
exceptions = [
    # Example: { allow = ["LGPL-3.0"], name = "some-crate" }
]

# Deny copyleft licenses that would require open-sourcing proprietary code
[licenses.private]
ignore = false
registries = []

# Some crates don't have (easily) machine readable licensing
[[licenses.clarify]]
name = "ring"
expression = "MIT AND ISC AND OpenSSL"
license-files = [{ path = "LICENSE", hash = 0xbd0eed23 }]

[[licenses.clarify]]
name = "encoding_rs"
expression = "(Apache-2.0 OR MIT) AND BSD-3-Clause"
license-files = [{ path = "LICENSE", hash = 0x19881434 }]

[bans]
# Lint level for when multiple versions of the same crate are detected
multiple-versions = "warn"
# Lint level for when a crate version has been yanked from crates.io
wildcards = "allow"
highlight = "all"

# List of crates to deny
deny = []

# List of crates to allow
allow = []

# Certain crates/versions that will be skipped when doing duplicate detection
skip = []

skip-tree = []

[sources]
# Lint level for what to happen when a crate from a crate registry is not found
unknown-registry = "warn"
# Lint level for what to happen when a crate from a git repository is not found
unknown-git = "warn"
# List of URLs for allowed crate registries
allow-registry = ["https://github.com/rust-lang/crates.io-index"]
# List of URLs for allowed Git repositories
allow-git = []

```

`src/server/src/allocator.rs`:

```rs
use std::alloc::{GlobalAlloc, Layout, System};
use std::backtrace::Backtrace;
use std::panic;

#[global_allocator]
static A: MyAllocator = MyAllocator;

struct MyAllocator;

unsafe impl GlobalAlloc for MyAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        let ptr = System.alloc(layout);
        if ptr.is_null() {
            handle_alloc_error(layout)
        }
        ptr
    }

    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout)
    }
}

fn handle_alloc_error(layout: Layout) -> ! {
    let backtrace = Backtrace::force_capture();
    eprintln!(
        "memory allocation of {} bytes failed\nBacktrace:\n{:?}",
        layout.size(),
        backtrace
    );
    panic!("memory allocation of {} bytes failed", layout.size());
}

```

`src/server/src/api.rs`:

```rs
#![allow(dead_code)]
#[allow(non_snake_case)]

use bytes::Bytes;
use byteorder::{ByteOrder, LittleEndian};
use chrono;
use hex;
use lazy_static::lazy_static;
use libc::{self, c_char, c_int, c_void};
use lz4_flex::block::compress_prepend_size;

use memchr::memmem;
use percent_encoding::percent_decode_str;
use rayon::prelude::*;
use regex::bytes::Regex;
use serde::{Deserialize, Serialize};
use serde_json::json;
use serde_json::Value;
use std::collections::HashMap;

use log::{debug, error, info, trace, warn};

use std::collections::VecDeque;
use std::env;
use std::ffi::CStr;
use std::ffi::CString;
use std::fs::{self, File, OpenOptions};
use std::io::Read;
use std::io::Write;
use std::io::{BufReader, BufWriter};
use std::mem::size_of;
use std::panic;
use std::path::{Path, PathBuf};
use std::process;
use std::slice;
use std::str;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::RwLock;
use std::sync::{Arc, Mutex};
use warp::hyper::Body;
use warp::{http::Response, http::StatusCode, Filter, Rejection, Reply};

use crate::native_bridge::{self, ExceptionType};
use crate::ptrscan;
use crate::request;
use crate::util;
use crate::wasm_bridge;

// Unified API response structures
#[derive(Serialize)]
struct ApiResponse<T> {
    success: bool,
    data: Option<T>,
    message: Option<String>,
}

impl<T> ApiResponse<T> {
    fn success(data: T) -> Self {
        Self {
            success: true,
            data: Some(data),
            message: None,
        }
    }
    
    fn success_with_message(data: T, message: String) -> Self {
        Self {
            success: true,
            data: Some(data),
            message: Some(message),
        }
    }
    
    fn error(message: String) -> Self {
        Self {
            success: false,
            data: None,
            message: Some(message),
        }
    }
}

#[derive(Serialize)]
struct SimpleResponse {
    success: bool,
    message: String,
}

impl SimpleResponse {
    fn success(message: String) -> Self {
        Self {
            success: true,
            message,
        }
    }
    
    fn error(message: String) -> Self {
        Self {
            success: false,
            message,
        }
    }
}

lazy_static! {
    static ref GLOBAL_POSITIONS: RwLock<HashMap<String, Vec<(usize, String)>>> =
        RwLock::new(HashMap::new());
    static ref GLOBAL_MEMORY: RwLock<HashMap<String, Vec<(usize, Vec<u8>, usize, Vec<u8>, usize, bool)>>> =
        RwLock::new(HashMap::new());
    static ref GLOBAL_SCAN_OPTION: RwLock<HashMap<String, request::MemoryScanRequest>> =
        RwLock::new(HashMap::new());
    static ref GLOBAL_SCAN_PROGRESS: RwLock<HashMap<String, request::ScanProgressResponse>> =
        RwLock::new(HashMap::new());
    static ref GLOBAL_FILTER_PROGRESS: RwLock<HashMap<String, request::FilterProgressResponse>> =
        RwLock::new(HashMap::new());
    static ref GLOBAL_POINTERMAP_PROGRESS: RwLock<HashMap<String, request::PointerMapProgressResponse>> =
        RwLock::new(HashMap::new());
    static ref GLOBAL_POINTERMAP_DATA: RwLock<HashMap<String, Vec<u8>>> =
        RwLock::new(HashMap::new());
    static ref JSON_QUEUE: Arc<Mutex<VecDeque<String>>> = Arc::new(Mutex::new(VecDeque::new()));
    static ref GLOBAL_PROCESS_STATE: RwLock<bool> = RwLock::new(false);
    static ref SCAN_STOP_FLAGS: RwLock<HashMap<String, Arc<Mutex<bool>>>> = RwLock::new(HashMap::new());
}

/// Push a message to the JSON queue for UI consumption
pub fn push_to_json_queue(message: String) {
    let mut queue = JSON_QUEUE.lock().unwrap();
    queue.push_back(message);
}

#[no_mangle]
pub extern "C" fn native_log(level: c_int, message: *const c_char) {
    let log_message = unsafe { CStr::from_ptr(message).to_string_lossy().into_owned() };

    match level {
        1 => error!("{}", log_message),  // LOG_ERROR = 1
        2 => warn!("{}", log_message),   // LOG_WARN = 2
        3 => info!("{}", log_message),   // LOG_INFO = 3
        4 => debug!("{}", log_message),  // LOG_DEBUG = 4
        5 => trace!("{}", log_message),  // LOG_TRACE = 5
        _ => info!("{}", log_message),   // default
    }
}

#[derive(Serialize)]
struct ExceptionInfo {
    exception_type: String,
    thread_id: u64,
    memory_address: Option<u64>,
    singlestep_mode: Option<u64>,
    is_trace: bool,
    registers: Value,
    instruction: Option<String>,
    timestamp: String,
}

// Architecture constants
pub const ARCH_UNKNOWN: u64 = 0;
pub const ARCH_ARM64: u64 = 1;
pub const ARCH_X86_64: u64 = 2;

// ARM64 registers structure
#[repr(C)]
#[derive(Clone, Copy)]
pub struct Arm64Registers {
    pub x: [u64; 30],
    pub lr: u64,
    pub sp: u64,
    pub pc: u64,
    pub cpsr: u64,
    pub fp: u64,
}

// x86_64 registers structure
#[repr(C)]
#[derive(Clone, Copy)]
pub struct X86_64Registers {
    pub rax: u64,
    pub rbx: u64,
    pub rcx: u64,
    pub rdx: u64,
    pub rsi: u64,
    pub rdi: u64,
    pub rbp: u64,
    pub rsp: u64,
    pub r8: u64,
    pub r9: u64,
    pub r10: u64,
    pub r11: u64,
    pub r12: u64,
    pub r13: u64,
    pub r14: u64,
    pub r15: u64,
    pub rip: u64,
    pub rflags: u64,
    pub cs: u64,
    pub ss: u64,
    pub ds: u64,
    pub es: u64,
    pub fs: u64,
    pub gs: u64,
    pub fs_base: u64,
    pub gs_base: u64,
}

// Union for architecture-specific registers
#[repr(C)]
#[derive(Clone, Copy)]
pub union RegistersUnion {
    pub arm64: Arm64Registers,
    pub x86_64: X86_64Registers,
}

// Architecture-independent exception info structure
// Must match C++ NativeExceptionInfo in exception_info.h
#[repr(C)]
pub struct NativeExceptionInfo {
    pub architecture: u64,
    pub regs: RegistersUnion,
    pub exception_type: u64,
    pub thread_id: u64,
    pub memory_address: u64,
    pub singlestep_mode: u64,
    pub is_trace: u64,
}

#[no_mangle]
pub extern "C" fn send_exception_info(info_ptr: *const NativeExceptionInfo, pid: i32) -> bool {
    if info_ptr.is_null() {
        error!("Received null pointer for exception info");
        return false;
    }

    let info = unsafe { &*info_ptr };

    // Convert exception type
    let exception_type = match info.exception_type {
        1 => ExceptionType::Breakpoint,
        2 => ExceptionType::Watchpoint,
        3 => ExceptionType::SingleStep,
        4 => ExceptionType::Signal,
        5 => ExceptionType::Sigsegv,
        6 => ExceptionType::Sigbus,
        7 => ExceptionType::Sigfpe,
        8 => ExceptionType::Sigill,
        9 => ExceptionType::Sigabrt,
        10 => ExceptionType::Sigtrap,
        _ => ExceptionType::Unknown,
    };

    let exception_type_str = exception_type.to_str();
    let thread_id = info.thread_id;
    
    // Extract single step mode
    let singlestep_mode = if info.exception_type == 3 {
        Some(info.singlestep_mode)
    } else {
        None
    };
    
    // Extract memory address for watchpoint and signal exceptions
    let memory_address = if info.exception_type == 2 || info.exception_type >= 4 {
        Some(info.memory_address)
    } else {
        None
    };

    // Build registers map - architecture specific
    let mut registers_map = serde_json::Map::new();
    
    // Determine PC address based on architecture field from C++
    let pc_address = if info.architecture == ARCH_ARM64 {
        let arm64 = unsafe { info.regs.arm64 };
        for (i, val) in arm64.x.iter().enumerate() {
            registers_map.insert(format!("x{}", i), json!(val));
        }
        registers_map.insert("lr".to_string(), json!(arm64.lr));
        registers_map.insert("fp".to_string(), json!(arm64.fp));
        registers_map.insert("sp".to_string(), json!(arm64.sp));
        registers_map.insert("pc".to_string(), json!(arm64.pc));
        registers_map.insert("cpsr".to_string(), json!(arm64.cpsr));
        arm64.pc
    } else if info.architecture == ARCH_X86_64 {
        let x86_64 = unsafe { info.regs.x86_64 };
        registers_map.insert("rax".to_string(), json!(x86_64.rax));
        registers_map.insert("rbx".to_string(), json!(x86_64.rbx));
        registers_map.insert("rcx".to_string(), json!(x86_64.rcx));
        registers_map.insert("rdx".to_string(), json!(x86_64.rdx));
        registers_map.insert("rsi".to_string(), json!(x86_64.rsi));
        registers_map.insert("rdi".to_string(), json!(x86_64.rdi));
        registers_map.insert("rbp".to_string(), json!(x86_64.rbp));
        registers_map.insert("rsp".to_string(), json!(x86_64.rsp));
        registers_map.insert("r8".to_string(), json!(x86_64.r8));
        registers_map.insert("r9".to_string(), json!(x86_64.r9));
        registers_map.insert("r10".to_string(), json!(x86_64.r10));
        registers_map.insert("r11".to_string(), json!(x86_64.r11));
        registers_map.insert("r12".to_string(), json!(x86_64.r12));
        registers_map.insert("r13".to_string(), json!(x86_64.r13));
        registers_map.insert("r14".to_string(), json!(x86_64.r14));
        registers_map.insert("r15".to_string(), json!(x86_64.r15));
        registers_map.insert("rip".to_string(), json!(x86_64.rip));
        // Add 'pc' alias for x86_64 to ensure frontend compatibility
        registers_map.insert("pc".to_string(), json!(x86_64.rip));
        registers_map.insert("rflags".to_string(), json!(x86_64.rflags));
        registers_map.insert("cs".to_string(), json!(x86_64.cs));
        registers_map.insert("ss".to_string(), json!(x86_64.ss));
        registers_map.insert("ds".to_string(), json!(x86_64.ds));
        registers_map.insert("es".to_string(), json!(x86_64.es));
        registers_map.insert("fs".to_string(), json!(x86_64.fs));
        registers_map.insert("gs".to_string(), json!(x86_64.gs));
        x86_64.rip
    } else {
        error!("Unknown architecture: {}", info.architecture);
        return false;
    };
    
    // Create pure registers value for ExceptionInfo
    let registers_value = Value::Object(registers_map.clone());


    // Determine buffer size based on architecture
    // For x86_64 watchpoints, we need to look backwards to find the instruction that caused the access
    let instruction = {
        let is_x86_64_watchpoint = info.architecture == ARCH_X86_64 && info.exception_type == 2;
        
        if is_x86_64_watchpoint {
            // x86_64 watchpoint: RIP points to the NEXT instruction after the one that triggered
            // We need to scan backwards to find the instruction that ends at RIP
            let scan_size: u64 = 16; // x86_64 max instruction length is 15 bytes
            let scan_start = pc_address.saturating_sub(scan_size);
            let mut buffer = vec![0u8; (pc_address - scan_start) as usize + 15];
            
            match native_bridge::read_process_memory_with_method(
                pid,
                scan_start as *mut libc::c_void,
                buffer.len(),
                &mut buffer,
                1,
            ) {
                Ok(_) => {
                    // Find the instruction that ends at pc_address
                    // Try disassembling from different offsets to find one that ends at RIP
                    // Scan from furthest back (longest possible instruction) to avoid matching suffixes like "00 00"
                    let mut found_instruction: Option<String> = None;
                    
                    for offset in 0..scan_size as usize {
                        let try_addr = scan_start + offset as u64;
                        let sub_buffer = &buffer[offset..];
                        
                        let disasm = util::disassemble_internal(
                            sub_buffer.as_ptr(),
                            sub_buffer.len().min(15),
                            try_addr,
                            "x86_64"
                        );
                        
                        // Parse the disassembly to get instruction length
                        // Format: "0xADDRESS|BYTECODE|OPCODE"
                        if let Some(first_line) = disasm.lines().next() {
                            let parts: Vec<&str> = first_line.split('|').collect();
                            if parts.len() >= 2 {
                                let bytecode = parts[1].trim();
                                // Count bytes (each byte is 2 hex chars)
                                let byte_count = bytecode.replace(" ", "").len() / 2;
                                let instr_end = try_addr + byte_count as u64;
                                
                                if instr_end == pc_address {
                                    // Found the instruction that ends at RIP
                                    // Since we scan from furthest back, this is the longest instruction ending at RIP
                                    found_instruction = Some(disasm);
                                    break;
                                }
                            }
                        }
                    }
                    
                    found_instruction.or_else(|| {
                        // Fallback: just show the instruction at RIP (next instruction)
                        Some(util::disassemble_internal(
                            buffer[(pc_address - scan_start) as usize..].as_ptr(),
                            15,
                            pc_address,
                            "x86_64"
                        ))
                    })
                }
                Err(e) => {
                    warn!("Failed to read memory for disassembly: {}", e);
                    None
                }
            }
        } else {
            // Normal case: disassemble at PC
            let buffer_size = if info.architecture == ARCH_ARM64 { 4 } else { 15 };
            let mut buffer = vec![0u8; buffer_size];
            
            match native_bridge::read_process_memory_with_method(
                pid,
                pc_address as *mut libc::c_void,
                buffer.len(),
                &mut buffer,
                1,
            ) {
                Ok(_) => {
                    let arch = if info.architecture == ARCH_ARM64 {
                        "arm64"
                    } else {
                        "x86_64"
                    };
                    Some(util::disassemble_internal(buffer.as_ptr(), buffer.len(), pc_address, arch))
                }
                Err(e) => {
                    warn!("Failed to read memory for disassembly: {}", e);
                    None
                }
            }
        }
    };

    // Create structured exception info with pure registers
    let exception_info = ExceptionInfo {
        exception_type: exception_type_str.to_string(),
        thread_id,
        memory_address,
        singlestep_mode,
        is_trace: info.is_trace != 0,
        registers: registers_value,
        instruction: instruction.clone(),
        timestamp: chrono::Utc::now().to_rfc3339(),
    };

    // Add extra fields to registers map for backward compatibility (flat structure)
    registers_map.insert("exception_type".to_string(), json!(info.exception_type));
    registers_map.insert("thread_id".to_string(), json!(info.thread_id));
    registers_map.insert("is_trace".to_string(), json!(info.is_trace != 0));
    
    // Add address field as hex string for frontend compatibility
    // This is the PC address where the exception occurred
    registers_map.insert("address".to_string(), json!(format!("0x{:016x}", pc_address)));
    
    if let Some(addr) = memory_address {
         registers_map.insert("memory".to_string(), json!(addr));
         // For watchpoints, also add memory_address as number for frontend filtering
         registers_map.insert("memory_address".to_string(), json!(addr));
    }
    if let Some(mode) = singlestep_mode {
         registers_map.insert("singlestep_mode".to_string(), json!(mode));
    }
    if let Some(ref instr) = instruction {
        registers_map.insert("instruction".to_string(), json!(instr));
    }
    
    // Add breakpoint address explicitly for UI to recognize BP hits
    if info.exception_type == 1 {
        registers_map.insert("breakpoint_address".to_string(), json!(pc_address));
    }
    
    // Add structured info
    registers_map.insert("exception_info".to_string(), serde_json::to_value(&exception_info).unwrap_or(Value::Null));

    // Always notify UI for all exceptions (lua_engine removed)
    let should_notify = true;

    if should_notify {
        let mut queue = JSON_QUEUE.lock().unwrap();
        queue.push_back(Value::Object(registers_map.clone()).to_string());
        drop(queue);
    }
    
    // Return whether to notify UI (true = break, false = silent continue)
    should_notify
}

/// Void version of send_exception_info for DLL callback (C++ expects void)
#[no_mangle]
pub unsafe extern "C" fn send_exception_info_void(info_ptr: *const NativeExceptionInfo, pid: i32) {
    let _ = send_exception_info(info_ptr, pid);
}

pub fn with_state(
    state: Arc<Mutex<Option<i32>>>,
) -> impl Filter<Extract = (Arc<Mutex<Option<i32>>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || state.clone())
}

// Auth middleware - simplified (no authentication required)
pub fn with_auth() -> impl Filter<Extract = (), Error = std::convert::Infallible> + Clone {
    warp::any()
}

pub async fn handle_auth_rejection(err: warp::Rejection) -> Result<warp::reply::Json, warp::Rejection> {
    Err(err)
}

pub async fn verify_client_handler(
    _verification_request: request::ClientVerificationRequest,
) -> Result<impl Reply, Rejection> {
    // Authentication disabled - always succeed
    let response = request::ClientVerificationResponse {
        success: true,
        message: "Client verification skipped (auth disabled)".to_string(),
        server_info: None,
        access_token: None,
    };
    Ok(warp::reply::json(&response))
}

const MAX_RESULTS: usize = 100_000;

pub async fn get_exception_info_handler(
    exception_type_filter: Option<String>,
    singlestep_mode_filter: Option<String>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut queue = JSON_QUEUE.lock().unwrap();

    // Parse all exceptions from queue and separate into matched and unmatched
    let all_exceptions: Vec<Value> = queue
        .drain(..)
        .filter_map(|json_str| serde_json::from_str(&json_str).ok())
        .collect();
    
    let mut matched_exceptions = Vec::new();
    let mut unmatched_exceptions = Vec::new();

    // If no filters are specified, return all exceptions
    if exception_type_filter.is_none() && singlestep_mode_filter.is_none() {
        // Return in the expected API response format
        let response = ApiResponse::success(json!({
            "exceptions": all_exceptions
        }));
        return Ok(warp::reply::json(&response));
    }

    // Process each exception and check against filters
    for (idx, exception) in all_exceptions.into_iter().enumerate() {
        let mut matches_filters = true;

        // Check if this is a special event type that always passes filters
        // (script_breakpoint, script_output events from Lua scripts)
        let event_type = exception.get("event_type").and_then(|v| v.as_str());
        let is_script_event = matches!(event_type, Some("script_breakpoint") | Some("script_output"));
        
        if is_script_event {
            // Script events always pass through filters
            debug!("[Exception {}] Script event type {:?}, bypassing filters", idx, event_type);
            matched_exceptions.push(exception);
            continue;
        }

        // Debug log for each exception being processed
        debug!("[Exception {}] Processing: type_from_info={:?}, type_from_top={:?}, singlestep_mode_top={:?}, singlestep_mode_info={:?}, singlestep_mode_regs={:?}", 
            idx,
            exception.get("exception_info").and_then(|info| info.get("exception_type")),
            exception.get("exception_type"),
            exception.get("singlestep_mode"),
            exception.get("exception_info").and_then(|info| info.get("singlestep_mode")),
            exception.get("registers").and_then(|regs| regs.get("singlestep_mode"))
        );

        // Apply exception type filter if specified
        if let Some(ref filter_type) = exception_type_filter {
            let filter_types: Vec<String> = filter_type
                .split(',')
                .map(|s| s.trim().to_lowercase())
                .collect();

            let type_matches = {
                // First try to get from exception_info
                let from_exception_info = exception.get("exception_info")
                    .and_then(|info| info.get("exception_type"))
                    .and_then(|exc_type| exc_type.as_str())
                    .map(|exc_type_str| {
                        let exc_type_lower = exc_type_str.to_lowercase();
                        filter_types.iter().any(|filter| {
                            match filter.as_str() {
                                "breakpoint" => exc_type_lower == "breakpoint",
                                "watchpoint" => exc_type_lower == "watchpoint",
                                "single_step" => exc_type_lower == "single_step" || exc_type_lower == "singlestep",
                                "signal" => exc_type_lower == "signal",
                                "sigsegv" => exc_type_lower == "sigsegv",
                                "sigbus" => exc_type_lower == "sigbus",
                                "sigfpe" => exc_type_lower == "sigfpe",
                                "sigill" => exc_type_lower == "sigill",
                                "sigabrt" => exc_type_lower == "sigabrt",
                                "sigtrap" => exc_type_lower == "sigtrap",
                                _ => false,
                            }
                        })
                    });

                // If not found in exception_info, try from top-level exception_type (enum value)
                let from_top_level = exception.get("exception_type")
                    .and_then(|exc_type| exc_type.as_u64())
                    .map(|type_value| {
                        filter_types.iter().any(|filter| {
                            match filter.as_str() {
                                "breakpoint" => type_value == 1,  // ExceptionType::Breakpoint
                                "watchpoint" => type_value == 2,  // ExceptionType::Watchpoint
                                "single_step" => type_value == 3, // ExceptionType::SingleStep
                                "signal" => type_value == 4,      // ExceptionType::Signal
                                "sigsegv" => type_value == 5,     // ExceptionType::Sigsegv
                                "sigbus" => type_value == 6,      // ExceptionType::Sigbus
                                "sigfpe" => type_value == 7,      // ExceptionType::Sigfpe
                                "sigill" => type_value == 8,      // ExceptionType::Sigill
                                "sigabrt" => type_value == 9,     // ExceptionType::Sigabrt
                                "sigtrap" => type_value == 10,    // ExceptionType::Sigtrap
                                _ => false,
                            }
                        })
                    });

                // Return true if either source matches
                from_exception_info.unwrap_or(false) || from_top_level.unwrap_or(false)
            };

            if !type_matches {
                matches_filters = false;
            }
        }

        // Apply singlestep_mode filter if specified AND only for single_step exceptions
        if matches_filters {
            if let Some(ref singlestep_mode) = singlestep_mode_filter {
                // Check if this is a single_step exception before applying singlestep_mode filter
                let is_single_step_exception = {
                    // Check from exception_info first
                    let from_exception_info = exception.get("exception_info")
                        .and_then(|info| info.get("exception_type"))
                        .and_then(|exc_type| exc_type.as_str())
                        .map(|exc_type_str| {
                            let exc_type_lower = exc_type_str.to_lowercase();
                            exc_type_lower == "single_step" || exc_type_lower == "singlestep"
                        });

                    // Check from top-level exception_type (enum value)
                    let from_top_level = exception.get("exception_type")
                        .and_then(|exc_type| exc_type.as_u64())
                        .map(|type_value| type_value == 3); // ExceptionType::SingleStep

                    from_exception_info.unwrap_or(false) || from_top_level.unwrap_or(false)
                };

                // Only apply singlestep_mode filter for single_step exceptions
                // For breakpoint/watchpoint, the singlestep_mode filter is ignored and they pass through
                if is_single_step_exception {
                    let filter_modes: Vec<u64> = singlestep_mode
                        .split(',')
                        .filter_map(|s| {
                            let trimmed = s.trim();
                            // Support both decimal and hexadecimal formats
                            if trimmed.starts_with("0x") || trimmed.starts_with("0X") {
                                u64::from_str_radix(&trimmed[2..], 16).ok()
                            } else {
                                trimmed.parse::<u64>().ok()
                            }
                        })
                        .collect();

                    if !filter_modes.is_empty() {
                        // Try to get singlestep_mode from multiple sources
                        let singlestep_mode_value = exception.get("singlestep_mode")
                            .and_then(|v| {
                                // Handle both u64 and string values
                                v.as_u64().or_else(|| {
                                    v.as_str().and_then(|s| {
                                        let trimmed = s.trim();
                                        if trimmed.starts_with("0x") || trimmed.starts_with("0X") {
                                            u64::from_str_radix(&trimmed[2..], 16).ok()
                                        } else {
                                            trimmed.parse::<u64>().ok()
                                        }
                                    })
                                })
                            })
                            .or_else(|| {
                                // Try from exception_info
                                exception.get("exception_info")
                                    .and_then(|info| info.get("singlestep_mode"))
                                    .and_then(|v| {
                                        v.as_u64().or_else(|| {
                                            v.as_str().and_then(|s| {
                                                let trimmed = s.trim();
                                                if trimmed.starts_with("0x") || trimmed.starts_with("0X") {
                                                    u64::from_str_radix(&trimmed[2..], 16).ok()
                                                } else {
                                                    trimmed.parse::<u64>().ok()
                                                }
                                            })
                                        })
                                    })
                            })
                            .or_else(|| {
                                // Try from registers.singlestep_mode
                                exception.get("registers")
                                    .and_then(|regs| regs.get("singlestep_mode"))
                                    .and_then(|v| {
                                        v.as_u64().or_else(|| {
                                            v.as_str().and_then(|s| {
                                                let trimmed = s.trim();
                                                if trimmed.starts_with("0x") || trimmed.starts_with("0X") {
                                                    u64::from_str_radix(&trimmed[2..], 16).ok()
                                                } else {
                                                    trimmed.parse::<u64>().ok()
                                                }
                                            })
                                        })
                                    })
                            });

                        let mode_matches = if let Some(mode_value) = singlestep_mode_value {
                            let matches = filter_modes.contains(&mode_value);
                            debug!("Singlestep mode filter applied to single_step exception: value={}, filter_modes={:?}, matches={}", 
                                   mode_value, filter_modes, matches);
                            matches
                        } else {
                            debug!("No singlestep_mode value found in single_step exception");
                            false
                        };

                        if !mode_matches {
                            matches_filters = false;
                        }
                    }
                } else {
                    // For non-single_step exceptions (breakpoint, watchpoint), 
                    // singlestep_mode filter is ignored - they continue to match
                    debug!("[Exception {}] Non-single_step exception, singlestep_mode filter ignored", idx);
                }
            }
        }

        // Separate matched and unmatched exceptions
        if matches_filters {
            matched_exceptions.push(exception);
        } else {
            unmatched_exceptions.push(exception);
        }
    }

    debug!("Filter results: {} matched, {} unmatched", 
           matched_exceptions.len(), unmatched_exceptions.len());

    // Put unmatched exceptions back into the queue
    for exception in unmatched_exceptions {
        queue.push_back(exception.to_string());
    }

    debug!("Returning {} matched exceptions", matched_exceptions.len());

    // Return only the matched exceptions in the expected API response format
    let response = ApiResponse::success(json!({
        "exceptions": matched_exceptions
    }));

    Ok(warp::reply::json(&response))
}

#[derive(Serialize)]
struct ServerInfo {
    git_hash: String,
    target_os: String,
    arch: String,
    pid: u32,
    mode: String,
}

pub async fn server_info_handler() -> Result<impl warp::Reply, warp::Rejection> {
    let git_hash = env!("GIT_HASH");
    let target_os = env!("TARGET_OS");

    // In WASM mode, report wasm32 as the architecture
    let arch = if wasm_bridge::is_wasm_mode() {
        "wasm32"
    } else if cfg!(target_arch = "x86_64") {
        "x86_64"
    } else if cfg!(target_arch = "aarch64") {
        "aarch64"
    } else if cfg!(target_arch = "arm") {
        "arm"
    } else if cfg!(target_arch = "x86") {
        "x86"
    } else {
        "unknown"
    };

    let pid = process::id();

    let server_info = ServerInfo {
        git_hash: git_hash.to_string(),
        target_os: target_os.to_string(),
        arch: arch.to_string(),
        pid: pid,
        mode: std::env::var("DBGSRV_RUNNING_MODE").unwrap_or_else(|_| "unknown".to_string()),
    };

    Ok(warp::reply::json(&server_info))
}

pub async fn open_process_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    open_process: request::OpenProcessRequest,
) -> Result<Box<dyn warp::Reply>, warp::Rejection> {
    // Set the pid first with the lock, then release it before any async operations
    let wasm_mode_active;
    let attached_pid;
    {
        match pid_state.lock() {
            Ok(mut pid) => {
                *pid = Some(open_process.pid);
                attached_pid = open_process.pid;
                wasm_mode_active = wasm_bridge::is_wasm_mode();
            }
            Err(_) => {
                let response = SimpleResponse::error("Failed to acquire process state lock".to_string());
                return Ok(Box::new(warp::reply::with_status(
                    warp::reply::json(&response),
                    warp::http::StatusCode::INTERNAL_SERVER_ERROR,
                )));
            }
        }
    } // Lock is released here
    
    // In WASM mode, we don't need signature scan - just use WebSocket for memory access
    if wasm_mode_active {
        log::info!("WASM mode: Process attached (PID {} is virtual, using WebSocket bridge)", attached_pid);
        
        // No signature scan needed - memory access goes through WebSocket
        // Initial snapshot can be taken later via explicit API call if needed
        
        let response = SimpleResponse::success(
            "WASM process attached successfully via WebSocket bridge".to_string()
        );
        return Ok(Box::new(warp::reply::json(&response)));
    }
    
    let response = SimpleResponse::success("Process attached successfully".to_string());
    Ok(Box::new(warp::reply::json(&response)))
}

/// Scan process memory to find the WASM signature
fn scan_for_wasm_signature(pid: i32, signature: &[u8]) -> Result<usize, String> {
    if signature.len() != 64 {
        return Err(format!("Invalid signature length: {} (expected 64)", signature.len()));
    }
    
    // Get memory regions
    let mut count: usize = 0;
    let region_info_ptr = unsafe { 
        native_bridge::enumerate_regions(pid, &mut count, false) 
    };
    
    if region_info_ptr.is_null() || count == 0 {
        return Err("Failed to enumerate memory regions".to_string());
    }
    
    let regions = unsafe { std::slice::from_raw_parts(region_info_ptr, count) };
    let mut found_address: Option<usize> = None;
    
    // Scan each readable region
    for region in regions {
        // Check if region is readable (protection & 1 = read)
        if region.protection & 1 == 0 {
            continue;
        }
        
        let region_size = region.end - region.start;
        
        // Skip very large regions to avoid excessive memory usage
        // WASM heap is typically a few MB to a few hundred MB
        if region_size > 1024 * 1024 * 1024 {
            continue;
        }
        
        // Skip very small regions
        if region_size < 64 {
            continue;
        }
        
        // Read region memory
        let mut buffer = vec![0u8; region_size];
        let result = unsafe {
            native_bridge::read_memory_native(
                pid,
                region.start as libc::uintptr_t,
                region_size,
                buffer.as_mut_ptr(),
            )
        };
        
        if result < 0 {
            continue;
        }
        
        // Search for signature in buffer
        if let Some(offset) = find_signature_in_buffer(&buffer, signature) {
            found_address = Some(region.start + offset);
            log::info!(
                "Found WASM signature at 0x{:x} (region 0x{:x}-0x{:x}, offset 0x{:x})",
                region.start + offset, region.start, region.end, offset
            );
            break;
        }
    }
    
    // Free region info
    unsafe { native_bridge::free_region_info(region_info_ptr, count) };
    
    found_address.ok_or_else(|| "WASM signature not found in process memory".to_string())
}

/// Find signature bytes in a buffer
fn find_signature_in_buffer(buffer: &[u8], signature: &[u8]) -> Option<usize> {
    if buffer.len() < signature.len() {
        return None;
    }
    
    // Use memchr for efficient searching
    let first_byte = signature[0];
    let mut search_start = 0;
    
    while search_start + signature.len() <= buffer.len() {
        // Find next occurrence of first byte
        if let Some(pos) = memchr::memchr(first_byte, &buffer[search_start..]) {
            let abs_pos = search_start + pos;
            if abs_pos + signature.len() <= buffer.len() {
                // Check if full signature matches
                if &buffer[abs_pos..abs_pos + signature.len()] == signature {
                    return Some(abs_pos);
                }
            }
            search_start = abs_pos + 1;
        } else {
            break;
        }
    }
    
    None
}

pub async fn resolve_addr_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    resolve_addr: request::ResolveAddrRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    match pid_state.lock() {
        Ok(pid) => {
            if let Some(pid) = *pid {
                match native_bridge::enum_modules(pid) {
                    Ok(modules) => {
                        match util::resolve_symbolic_address(pid, &resolve_addr.query, &modules) {
                            Ok(resolved_address) => {
                                let response = ApiResponse::success(json!({ "address": resolved_address }));
                                Ok(warp::reply::json(&response))
                            }
                            Err(e) => {
                                let response = ApiResponse::<Value>::error(format!("Failed to resolve address: {}", e));
                                Ok(warp::reply::json(&response))
                            }
                        }
                    }
                    Err(e) => {
                        let response = ApiResponse::<Value>::error(format!("Failed to enumerate modules: {}", e));
                        Ok(warp::reply::json(&response))
                    }
                }
            } else {
                let response = ApiResponse::<Value>::error("Process not attached".to_string());
                Ok(warp::reply::json(&response))
            }
        }
        Err(_) => {
            let response = ApiResponse::<Value>::error("Failed to acquire process state lock".to_string());
            Ok(warp::reply::json(&response))
        }
    }
}

pub async fn read_memory_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    read_memory: request::ReadMemoryRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    // In WASM mode, all memory access goes through WebSocket bridge
    if wasm_bridge::is_wasm_mode() {
        // Use async read for all WASM memory (heap, code region, or snapshot)
        match wasm_bridge::read_wasm_memory_async(read_memory.address, read_memory.size).await {
            Ok(buffer) => {
                let response = Response::builder()
                    .header("Content-Type", "application/octet-stream")
                    .body(hyper::Body::from(buffer))
                    .unwrap();
                return Ok(response);
            }
            Err(e) => {
                log::error!("WASM read_memory failed: {}", e);
                let empty_buffer = Vec::new();
                let response = Response::builder()
                    .header("Content-Type", "application/octet-stream")
                    .body(hyper::Body::from(empty_buffer))
                    .unwrap();
                return Ok(response);
            }
        }
    }

    match pid_state.lock() {
        Ok(pid) => {
            if let Some(pid) = *pid {
                let mut buffer: Vec<u8> = vec![0; read_memory.size];
                let nread = if read_memory.use_ptrace {
                    native_bridge::read_process_memory_with_method(
                        pid,
                        read_memory.address as *mut libc::c_void,
                        read_memory.size,
                        &mut buffer,
                        1, // mode 1 = /proc/pid/mem
                    )
                } else {
                    native_bridge::read_process_memory(
                        pid,
                        read_memory.address as *mut libc::c_void,
                        read_memory.size,
                        &mut buffer,
                    )
                };
                match nread {
                    Ok(_) => {
                        let response = Response::builder()
                            .header("Content-Type", "application/octet-stream")
                            .body(hyper::Body::from(buffer))
                            .unwrap();
                        return Ok(response);
                    }
                    Err(_) => {
                        let empty_buffer = Vec::new();
                        let response = Response::builder()
                            .header("Content-Type", "application/octet-stream")
                            .body(hyper::Body::from(empty_buffer))
                            .unwrap();
                        return Ok(response);
                    }
                }
            } else {
                let response = Response::builder()
                    .status(StatusCode::BAD_REQUEST)
                    .body(hyper::Body::from("Process not attached"))
                    .unwrap();
                Ok(response)
            }
        }
        Err(_) => {
            let response = Response::builder()
                .status(StatusCode::INTERNAL_SERVER_ERROR)
                .body(hyper::Body::from("Failed to acquire process state lock"))
                .unwrap();
            Ok(response)
        }
    }
}

pub async fn read_memory_multiple_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    read_memory_requests: Vec<request::ReadMemoryRequest>,
) -> Result<impl warp::Reply, warp::Rejection> {
    // In WASM mode, use async WebSocket bridge
    if wasm_bridge::is_wasm_mode() {
        let mut compressed_buffers: Vec<Vec<u8>> = Vec::new();
        
        for request in &read_memory_requests {
            match wasm_bridge::read_wasm_memory_async(request.address, request.size).await {
                Ok(buffer) => {
                    let compressed_buffer = compress_prepend_size(&buffer);
                    let mut result_buffer = Vec::with_capacity(8 + compressed_buffer.len());
                    let compressed_buffer_size: u32 = compressed_buffer.len() as u32;
                    result_buffer.extend_from_slice(&1u32.to_le_bytes());
                    result_buffer.extend_from_slice(&compressed_buffer_size.to_le_bytes());
                    result_buffer.extend_from_slice(&compressed_buffer);
                    compressed_buffers.push(result_buffer);
                }
                Err(_) => {
                    let mut result_buffer = Vec::with_capacity(4);
                    result_buffer.extend_from_slice(&0u32.to_le_bytes());
                    compressed_buffers.push(result_buffer);
                }
            }
        }
        
        let mut concatenated_buffer = Vec::new();
        for buffer in compressed_buffers {
            concatenated_buffer.extend(buffer);
        }
        
        let response = Response::builder()
            .header("Content-Type", "application/octet-stream")
            .body(hyper::Body::from(concatenated_buffer))
            .unwrap();
        return Ok(response);
    }

    let pid = pid_state.lock().unwrap();
    if let Some(pid) = *pid {
        let compressed_buffers: Vec<Vec<u8>> = read_memory_requests
            .par_iter()
            .map(|request| {
                let mut buffer: Vec<u8> = vec![0; request.size];
                let nread = native_bridge::read_process_memory(
                    pid,
                    request.address as *mut libc::c_void,
                    request.size,
                    &mut buffer,
                );
                match nread {
                    Ok(_) => {
                        let compressed_buffer = compress_prepend_size(&buffer);
                        let mut result_buffer = Vec::with_capacity(8 + compressed_buffer.len());
                        let compresed_buffer_size: u32 = compressed_buffer.len() as u32;
                        result_buffer.extend_from_slice(&1u32.to_le_bytes());
                        result_buffer.extend_from_slice(&compresed_buffer_size.to_le_bytes());
                        result_buffer.extend_from_slice(&compressed_buffer);
                        result_buffer
                    }
                    Err(_) => {
                        let mut result_buffer = Vec::with_capacity(4);
                        result_buffer.extend_from_slice(&0u32.to_le_bytes());
                        result_buffer
                    }
                }
            })
            .collect();

        let mut concatenated_buffer = Vec::new();
        for buffer in compressed_buffers {
            concatenated_buffer.extend(buffer);
        }

        let response = Response::builder()
            .header("Content-Type", "application/octet-stream")
            .body(hyper::Body::from(concatenated_buffer))
            .unwrap();
        Ok(response)
    } else {
        let response = Response::builder()
            .status(StatusCode::BAD_REQUEST)
            .body(hyper::Body::from("Pid not set"))
            .unwrap();
        Ok(response)
    }
}

pub async fn write_memory_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    write_memory: request::WriteMemoryRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    // In WASM mode, use async WebSocket bridge
    if wasm_bridge::is_wasm_mode() {
        match wasm_bridge::write_wasm_memory_async(write_memory.address, &write_memory.buffer).await {
            Ok(success) => {
                if success {
                    let response = Response::builder()
                        .header("Content-Type", "application/json")
                        .body(hyper::Body::from(r#"{"success":true,"message":"Memory successfully written"}"#))
                        .unwrap();
                    return Ok(response);
                } else {
                    let response = Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .header("Content-Type", "application/json")
                        .body(hyper::Body::from(r#"{"success":false,"error":"WASM memory write failed"}"#))
                        .unwrap();
                    return Ok(response);
                }
            }
            Err(e) => {
                log::error!("WASM write_memory failed: {}", e);
                let response = Response::builder()
                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                    .header("Content-Type", "application/json")
                    .body(hyper::Body::from(format!(r#"{{"success":false,"error":"{}"}}"#, e)))
                    .unwrap();
                return Ok(response);
            }
        }
    }

    let pid = pid_state.lock().unwrap();

    if let Some(pid) = *pid {
        let nwrite = native_bridge::write_process_memory(
            pid,
            write_memory.address as *mut libc::c_void,
            write_memory.buffer.len(),
            &write_memory.buffer,
        );
        match nwrite {
            Ok(_) => {
                let response = Response::builder()
                    .header("Content-Type", "application/json")
                    .body(hyper::Body::from(r#"{"success":true,"message":"Memory successfully written"}"#))
                    .unwrap();
                return Ok(response);
            }
            Err(_) => {
                let response = Response::builder()
                    .status(StatusCode::BAD_REQUEST)
                    .header("Content-Type", "application/json")
                    .body(hyper::Body::from(r#"{"success":false,"error":"WriteProcessMemory error"}"#))
                    .unwrap();
                return Ok(response);
            }
        };
    } else {
        let response = Response::builder()
            .status(StatusCode::BAD_REQUEST)
            .header("Content-Type", "application/json")
            .body(hyper::Body::from(r#"{"success":false,"error":"Pid not set"}"#))
            .unwrap();
        Ok(response)
    }
}

pub async fn memory_scan_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    scan_request: request::MemoryScanRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    let pid = pid_state.lock().unwrap();

    let mut is_suspend_success: bool = false;
    let do_suspend = scan_request.do_suspend;
    if let Some(pid) = *pid {
        if do_suspend {
            unsafe {
                is_suspend_success = native_bridge::suspend_process(pid);
            }
        }
        // Clear global_positions for the given scan_id
        {
            let mut global_positions = GLOBAL_POSITIONS.write().unwrap();
            if let Some(positions) = global_positions.get_mut(&scan_request.scan_id) {
                positions.clear();
            }
            let mut global_memory = GLOBAL_MEMORY.write().unwrap();
            if let Some(memory) = global_memory.get_mut(&scan_request.scan_id) {
                memory.clear();
            } else {
            }
            let mut global_scan_option = GLOBAL_SCAN_OPTION.write().unwrap();
            global_scan_option.insert(scan_request.scan_id.clone(), scan_request.clone());
            
            // Initialize scan progress
            let total_bytes: u64 = scan_request.address_ranges.iter()
                .map(|(start, end)| (end - start) as u64)
                .sum();
            let mut global_scan_progress = GLOBAL_SCAN_PROGRESS.write().unwrap();
            global_scan_progress.insert(scan_request.scan_id.clone(), request::ScanProgressResponse {
                scan_id: scan_request.scan_id.clone(),
                progress_percentage: 0.0,
                scanned_bytes: 0,
                total_bytes,
                is_scanning: true,
                current_region: None,
            });
        }
        
        // Create stop flag for this scan
        let stop_flag = Arc::new(Mutex::new(false));
        {
            let mut scan_stop_flags = SCAN_STOP_FLAGS.write().unwrap();
            scan_stop_flags.insert(scan_request.scan_id.clone(), stop_flag.clone());
        }
        // dbgsrv-data-dir/Scan_xxx cleanup and create
        let mut scan_folder_path = PathBuf::from("");
        let mode =
            std::env::var("DBGSRV_RUNNING_MODE").unwrap_or_else(|_| "unknown".to_string());
        if mode == "embedded" {
            let cache_directory = util::get_cache_directory(pid);
            scan_folder_path = PathBuf::from(&cache_directory);
        }
        let sanitized_scan_id = scan_request.scan_id.trim().replace(" ", "_");
        scan_folder_path.push("dbgsrv-data-dir");
        scan_folder_path.push(&sanitized_scan_id);
        let scan_folder = Path::new(&scan_folder_path);

        if scan_folder.exists() {
            fs::remove_dir_all(&scan_folder).expect("Failed to remove directory");
        }
        fs::create_dir_all(&scan_folder_path).expect("Failed to create directory");

        let _is_number = match scan_request.data_type.as_str() {
            "int16" | "uint16" | "int32" | "uint32" | "float" | "int64" | "uint64" | "double" => {
                true
            }
            _ => false,
        };
        let found_count = Arc::new(AtomicUsize::new(0));
        let scanned_bytes = Arc::new(AtomicUsize::new(0));
        let total_bytes_to_scan: usize = scan_request.address_ranges.iter()
            .map(|(start, end)| end - start)
            .sum();
        let scan_align = scan_request.align;
        let is_error_occurred = Arc::new(Mutex::new(false));
        let error_message = Arc::new(Mutex::new(String::new()));

        // Start a background task to update progress
        let scan_id_progress = scan_request.scan_id.clone();
        let scanned_bytes_clone = Arc::clone(&scanned_bytes);
        let total_bytes_to_scan_clone = total_bytes_to_scan;
        let _progress_task = std::thread::spawn(move || {
            loop {
                let current_scanned = scanned_bytes_clone.load(Ordering::SeqCst);
                let progress_percentage = if total_bytes_to_scan_clone > 0 {
                    (current_scanned as f64 / total_bytes_to_scan_clone as f64) * 100.0
                } else {
                    0.0
                };

                // Update progress
                if let Ok(mut global_scan_progress) = GLOBAL_SCAN_PROGRESS.try_write() {
                    if let Some(progress) = global_scan_progress.get_mut(&scan_id_progress) {
                        progress.scanned_bytes = current_scanned as u64;
                        progress.progress_percentage = progress_percentage;
                    }
                }

                // Check if scan is complete
                if current_scanned >= total_bytes_to_scan_clone {
                    break;
                }

                // Sleep for 100ms before next update
                std::thread::sleep(std::time::Duration::from_millis(100));
            }
        });

        // Get tokio handle for WASM mode (needed for rayon threads)
        let tokio_handle = if wasm_bridge::is_wasm_mode() {
            tokio::runtime::Handle::try_current().ok()
        } else {
            None
        };
        let tokio_handle = Arc::new(tokio_handle);

        // Start scanning in background thread
        let scan_request_clone = scan_request.clone();
        let scan_folder_path_clone = scan_folder_path.clone();
        let stop_flag_clone = stop_flag.clone();
        std::thread::spawn(move || {
            let tokio_handle_clone = Arc::clone(&tokio_handle);
            let thread_results: Vec<Vec<(usize, String)>> = scan_request_clone
                .address_ranges
                .par_iter()
                .enumerate()
                .flat_map(|(index, &(ref start_address, ref end_address))| {
                    let found_count = Arc::clone(&found_count);
                    let tokio_handle = Arc::clone(&tokio_handle_clone);
                    let size = end_address - start_address;
                    let chunk_size = 1024 * 1024 * 16; // 16MB
                    let num_chunks = (size + chunk_size - 1) / chunk_size;

                    (0..num_chunks)
                        .map(|i| {
                            // Check stop flag
                            if let Ok(should_stop) = stop_flag_clone.lock() {
                                if *should_stop {
                                    return vec![];
                                }
                            }
                            
                            let mut error_occurred = is_error_occurred.lock().unwrap();
                            let mut error_msg = error_message.lock().unwrap();

                            if *error_occurred == true {
                                return vec![];
                            }
                            let chunk_start = start_address + i * chunk_size;
                            let chunk_end = std::cmp::min(chunk_start + chunk_size, *end_address);
                            let chunk_size_actual = chunk_end - chunk_start;
                            let mut buffer: Vec<u8> = vec![0; chunk_size_actual];

                            let mut local_positions = vec![];
                            let mut local_values = vec![];

                            let nread = match native_bridge::read_process_memory_with_handle(
                                pid,
                                chunk_start as *mut libc::c_void,
                                chunk_size_actual,
                                &mut buffer,
                                tokio_handle.as_ref().as_ref(),
                            ) {
                                Ok(nread) => nread,
                                Err(_) => -1,
                            };

                            if nread != -1 {
                                if scan_request_clone.find_type == "exact" {
                                    if scan_request_clone.data_type == "regex" {
                                        let regex_pattern = &scan_request_clone.pattern;
                                        let re = match Regex::new(regex_pattern) {
                                            Ok(re) => re,
                                            Err(_) => return vec![],
                                        };

                                        for cap in re.captures_iter(&buffer) {
                                            let start = cap.get(0).unwrap().start();
                                            let absolute_address = chunk_start + start;
                                            if absolute_address % scan_align == 0 {
                                                let end = cap.get(0).unwrap().end();
                                                let value = hex::encode(&buffer[start..end]);
                                                local_positions.push(absolute_address);
                                                local_values.push(value);
                                                found_count.fetch_add(1, Ordering::SeqCst);
                                            }
                                        }
                                    } else {
                                        let search_bytes = match hex::decode(&scan_request_clone.pattern) {
                                            Ok(bytes) => bytes,
                                            Err(_) => {
                                                println!("Failed to decode hex pattern: {}", scan_request_clone.pattern);
                                                return vec![];
                                            }
                                        };

                                        for pos in memmem::find_iter(&buffer, &search_bytes) {
                                            let absolute_address = chunk_start + pos;
                                            if absolute_address % scan_align == 0 {
                                                // Get the actual bytes found at this position
                                                let value = hex::encode(&buffer[pos..pos + search_bytes.len()]);
                                                local_positions.push(absolute_address);
                                                local_values.push(value);
                                                found_count.fetch_add(1, Ordering::SeqCst);
                                            }
                                        }
                                    }
                                } else if scan_request_clone.find_type == "range" {
                                    // Range search: find values between min (pattern) and max (pattern_max)
                                    let data_type = scan_request_clone.data_type.as_str();
                                    let min_bytes = match hex::decode(&scan_request_clone.pattern) {
                                        Ok(bytes) => bytes,
                                        Err(_) => {
                                            println!("Failed to decode hex min pattern: {}", scan_request_clone.pattern);
                                            return vec![];
                                        }
                                    };
                                    let max_bytes = match &scan_request_clone.pattern_max {
                                        Some(max_pattern) => match hex::decode(max_pattern) {
                                            Ok(bytes) => bytes,
                                            Err(_) => {
                                                println!("Failed to decode hex max pattern: {}", max_pattern);
                                                return vec![];
                                            }
                                        },
                                        None => {
                                            println!("Range search requires pattern_max");
                                            return vec![];
                                        }
                                    };

                                    let type_size = match data_type {
                                        "int8" | "uint8" => 1,
                                        "int16" | "uint16" => 2,
                                        "int32" | "uint32" | "float" => 4,
                                        "int64" | "uint64" | "double" => 8,
                                        _ => return vec![],
                                    };

                                    for pos in (0..buffer.len().saturating_sub(type_size - 1)).step_by(scan_align) {
                                        let absolute_address = chunk_start + pos;
                                        let in_range = match data_type {
                                            "int8" => {
                                                let val = buffer[pos] as i8;
                                                let min = i8::from_le_bytes([min_bytes[0]]);
                                                let max = i8::from_le_bytes([max_bytes[0]]);
                                                val >= min && val <= max
                                            }
                                            "uint8" => {
                                                let val = buffer[pos];
                                                let min = min_bytes[0];
                                                let max = max_bytes[0];
                                                val >= min && val <= max
                                            }
                                            "int16" => {
                                                if pos + 2 > buffer.len() { false } else {
                                                    let val = LittleEndian::read_i16(&buffer[pos..]);
                                                    let min = LittleEndian::read_i16(&min_bytes);
                                                    let max = LittleEndian::read_i16(&max_bytes);
                                                    val >= min && val <= max
                                                }
                                            }
                                            "uint16" => {
                                                if pos + 2 > buffer.len() { false } else {
                                                    let val = LittleEndian::read_u16(&buffer[pos..]);
                                                    let min = LittleEndian::read_u16(&min_bytes);
                                                    let max = LittleEndian::read_u16(&max_bytes);
                                                    val >= min && val <= max
                                                }
                                            }
                                            "int32" => {
                                                if pos + 4 > buffer.len() { false } else {
                                                    let val = LittleEndian::read_i32(&buffer[pos..]);
                                                    let min = LittleEndian::read_i32(&min_bytes);
                                                    let max = LittleEndian::read_i32(&max_bytes);
                                                    val >= min && val <= max
                                                }
                                            }
                                            "uint32" => {
                                                if pos + 4 > buffer.len() { false } else {
                                                    let val = LittleEndian::read_u32(&buffer[pos..]);
                                                    let min = LittleEndian::read_u32(&min_bytes);
                                                    let max = LittleEndian::read_u32(&max_bytes);
                                                    val >= min && val <= max
                                                }
                                            }
                                            "int64" => {
                                                if pos + 8 > buffer.len() { false } else {
                                                    let val = LittleEndian::read_i64(&buffer[pos..]);
                                                    let min = LittleEndian::read_i64(&min_bytes);
                                                    let max = LittleEndian::read_i64(&max_bytes);
                                                    val >= min && val <= max
                                                }
                                            }
                                            "uint64" => {
                                                if pos + 8 > buffer.len() { false } else {
                                                    let val = LittleEndian::read_u64(&buffer[pos..]);
                                                    let min = LittleEndian::read_u64(&min_bytes);
                                                    let max = LittleEndian::read_u64(&max_bytes);
                                                    val >= min && val <= max
                                                }
                                            }
                                            "float" => {
                                                if pos + 4 > buffer.len() { false } else {
                                                    let val = LittleEndian::read_f32(&buffer[pos..]);
                                                    let min = LittleEndian::read_f32(&min_bytes);
                                                    let max = LittleEndian::read_f32(&max_bytes);
                                                    !val.is_nan() && val >= min && val <= max
                                                }
                                            }
                                            "double" => {
                                                if pos + 8 > buffer.len() { false } else {
                                                    let val = LittleEndian::read_f64(&buffer[pos..]);
                                                    let min = LittleEndian::read_f64(&min_bytes);
                                                    let max = LittleEndian::read_f64(&max_bytes);
                                                    !val.is_nan() && val >= min && val <= max
                                                }
                                            }
                                            _ => false,
                                        };

                                        if in_range {
                                            let value = hex::encode(&buffer[pos..pos + type_size]);
                                            local_positions.push(absolute_address);
                                            local_values.push(value);
                                            found_count.fetch_add(1, Ordering::SeqCst);
                                        }
                                    }
                                } else if scan_request_clone.find_type == "greater_or_equal" || scan_request_clone.find_type == "less_than" {
                                    // Greater than or equal / Less than search
                                    let data_type = scan_request_clone.data_type.as_str();
                                    let cmp_bytes = match hex::decode(&scan_request_clone.pattern) {
                                        Ok(bytes) => bytes,
                                        Err(_) => {
                                            println!("Failed to decode hex pattern: {}", scan_request_clone.pattern);
                                            return vec![];
                                        }
                                    };
                                    let is_greater_or_equal = scan_request_clone.find_type == "greater_or_equal";

                                    let type_size = match data_type {
                                        "int8" | "uint8" => 1,
                                        "int16" | "uint16" => 2,
                                        "int32" | "uint32" | "float" => 4,
                                        "int64" | "uint64" | "double" => 8,
                                        _ => return vec![],
                                    };

                                    for pos in (0..buffer.len().saturating_sub(type_size - 1)).step_by(scan_align) {
                                        let absolute_address = chunk_start + pos;
                                        let matches = match data_type {
                                            "int8" => {
                                                let val = buffer[pos] as i8;
                                                let cmp = i8::from_le_bytes([cmp_bytes[0]]);
                                                if is_greater_or_equal { val >= cmp } else { val < cmp }
                                            }
                                            "uint8" => {
                                                let val = buffer[pos];
                                                let cmp = cmp_bytes[0];
                                                if is_greater_or_equal { val >= cmp } else { val < cmp }
                                            }
                                            "int16" => {
                                                if pos + 2 > buffer.len() { false } else {
                                                    let val = LittleEndian::read_i16(&buffer[pos..]);
                                                    let cmp = LittleEndian::read_i16(&cmp_bytes);
                                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                                }
                                            }
                                            "uint16" => {
                                                if pos + 2 > buffer.len() { false } else {
                                                    let val = LittleEndian::read_u16(&buffer[pos..]);
                                                    let cmp = LittleEndian::read_u16(&cmp_bytes);
                                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                                }
                                            }
                                            "int32" => {
                                                if pos + 4 > buffer.len() { false } else {
                                                    let val = LittleEndian::read_i32(&buffer[pos..]);
                                                    let cmp = LittleEndian::read_i32(&cmp_bytes);
                                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                                }
                                            }
                                            "uint32" => {
                                                if pos + 4 > buffer.len() { false } else {
                                                    let val = LittleEndian::read_u32(&buffer[pos..]);
                                                    let cmp = LittleEndian::read_u32(&cmp_bytes);
                                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                                }
                                            }
                                            "int64" => {
                                                if pos + 8 > buffer.len() { false } else {
                                                    let val = LittleEndian::read_i64(&buffer[pos..]);
                                                    let cmp = LittleEndian::read_i64(&cmp_bytes);
                                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                                }
                                            }
                                            "uint64" => {
                                                if pos + 8 > buffer.len() { false } else {
                                                    let val = LittleEndian::read_u64(&buffer[pos..]);
                                                    let cmp = LittleEndian::read_u64(&cmp_bytes);
                                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                                }
                                            }
                                            "float" => {
                                                if pos + 4 > buffer.len() { false } else {
                                                    let val = LittleEndian::read_f32(&buffer[pos..]);
                                                    let cmp = LittleEndian::read_f32(&cmp_bytes);
                                                    !val.is_nan() && if is_greater_or_equal { val >= cmp } else { val < cmp }
                                                }
                                            }
                                            "double" => {
                                                if pos + 8 > buffer.len() { false } else {
                                                    let val = LittleEndian::read_f64(&buffer[pos..]);
                                                    let cmp = LittleEndian::read_f64(&cmp_bytes);
                                                    !val.is_nan() && if is_greater_or_equal { val >= cmp } else { val < cmp }
                                                }
                                            }
                                            _ => false,
                                        };

                                        if matches {
                                            let value = hex::encode(&buffer[pos..pos + type_size]);
                                            local_positions.push(absolute_address);
                                            local_values.push(value);
                                            found_count.fetch_add(1, Ordering::SeqCst);
                                        }
                                    }
                                } else if scan_request_clone.find_type == "unknown" {
                                    let alignment = match scan_request_clone.data_type.as_str() {
                                        "int16" | "uint16" => 2,
                                        "int32" | "uint32" | "float" => 4,
                                        "int64" | "uint64" | "double" => 8,
                                        _ => 1,
                                    };

                                    let mut file_path = scan_folder_path_clone.clone();
                                    file_path.push(format!("{}.dump", index));
                                    let file_exists = file_path.exists();

                                    let file = match OpenOptions::new()
                                        .create(true)
                                        .append(true)
                                        .open(file_path)
                                    {
                                        Ok(file) => file,
                                        Err(e) => {
                                            *error_occurred = true;
                                            *error_msg = format!("Failed to open file: {}", e);
                                            return vec![];
                                        }
                                    };

                                    let mut writer = BufWriter::new(file);

                                    if !file_exists {
                                        // status flag
                                        let zero_bytes = [0x00, 0x00, 0x00, 0x00];
                                        if let Err(e) = writer.write_all(&zero_bytes) {
                                            *error_occurred = true;
                                            *error_msg = format!("Failed to write 4 zero bytes: {}", e);
                                            return vec![];
                                        }
                                    }

                                    if let Err(e) = writer.write_all(&chunk_start.to_le_bytes()) {
                                        *error_occurred = true;
                                        *error_msg = format!("Failed to write chunk_start: {}", e);
                                        return vec![];
                                    }

                                    let compressed_buffer = lz4_flex::block::compress(&buffer);

                                    if let Err(e) = writer
                                        .write_all(&(compressed_buffer.len() as u64).to_le_bytes())
                                    {
                                        *error_occurred = true;
                                        *error_msg =
                                            format!("Failed to write compressed buffer length: {}", e);
                                        return vec![];
                                    }

                                    if let Err(e) =
                                        writer.write_all(&(buffer.len() as u64).to_le_bytes())
                                    {
                                        *error_occurred = true;
                                        *error_msg = format!(
                                            "Failed to write uncompressed buffer length: {}",
                                            e
                                        );
                                        return vec![];
                                    }

                                    if let Err(e) = writer.write_all(&compressed_buffer) {
                                        *error_occurred = true;
                                        *error_msg = format!("Failed to write buffer data: {}", e);
                                        return vec![];
                                    }

                                    if let Err(e) = writer.flush() {
                                        *error_occurred = true;
                                        *error_msg = format!("Failed to flush buffer: {}", e);
                                        return vec![];
                                    }
                                    found_count.fetch_add(buffer.len() / alignment, Ordering::SeqCst);
                                }
                                // Check if local_positions exceed MAX_RESULTS and insert into global_positions
                                if local_positions.len() > MAX_RESULTS {
                                    let mut global_positions = GLOBAL_POSITIONS.write().unwrap();
                                    let combined: Vec<(usize, String)> = local_positions
                                        .into_iter()
                                        .zip(local_values.into_iter())
                                        .collect();
                                    if let Some(positions) =
                                        global_positions.get_mut(&scan_request_clone.scan_id)
                                    {
                                        positions.extend(combined);
                                    } else {
                                        global_positions.insert(scan_request_clone.scan_id.clone(), combined);
                                    }
                                    local_positions = vec![];
                                    local_values = vec![];
                                }
                            }

                            // Update progress for this chunk
                            let _bytes_processed = scanned_bytes.fetch_add(chunk_size_actual, Ordering::SeqCst) + chunk_size_actual;

                            let combined: Vec<(usize, String)> = local_positions
                                .into_iter()
                                .zip(local_values.into_iter())
                                .collect();
                            combined
                        })
                        .collect::<Vec<_>>()
                })
                .collect();
            
            let do_play = GLOBAL_PROCESS_STATE.write().unwrap();
            if do_suspend && is_suspend_success && *do_play {
                unsafe {
                    native_bridge::resume_process(pid);
                }
            }

            let flattened_results: Vec<(usize, String)> =
                thread_results.into_iter().flatten().collect();
            {
                let mut global_positions = GLOBAL_POSITIONS.write().unwrap();
                if let Some(positions) = global_positions.get_mut(&scan_request_clone.scan_id) {
                    positions.extend(flattened_results);
                } else {
                    global_positions.insert(scan_request_clone.scan_id.clone(), flattened_results);
                }
            }
            // Update scan progress to completed
            {
                let mut global_scan_progress = GLOBAL_SCAN_PROGRESS.write().unwrap();
                if let Some(progress) = global_scan_progress.get_mut(&scan_request_clone.scan_id) {
                    progress.progress_percentage = 100.0;
                    progress.is_scanning = false;
                    progress.current_region = None;
                    progress.scanned_bytes = total_bytes_to_scan as u64;
                }
            }
            
            // Clean up stop flag
            {
                let mut scan_stop_flags = SCAN_STOP_FLAGS.write().unwrap();
                scan_stop_flags.remove(&scan_request_clone.scan_id);
            }
        });

        // Return immediately with scan started status
        let result = json!({
            "scan_id": scan_request.scan_id,
            "status": "started",
            "message": "Scan started in background. Use progress API to check status."
        });
        let result_string = result.to_string();
        let response = Response::builder()
            .header("Content-Type", "application/json")
            .body(hyper::Body::from(result_string))
            .unwrap();
        Ok(response)
    } else {
        let response = Response::builder()
            .status(StatusCode::BAD_REQUEST)
            .body(hyper::Body::from("Pid not set"))
            .unwrap();
        Ok(response)
    }
}

macro_rules! compare_values {
    ($val:expr, $old_val:expr, $filter_method:expr) => {
        match $filter_method {
            "changed" => $val != $old_val,
            "unchanged" => $val == $old_val,
            "increased" => $val > $old_val,
            "decreased" => $val < $old_val,
            _ => false,
        }
    };
}

pub async fn memory_filter_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    filter_request: request::MemoryFilterRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    let pid = {
        let pid_guard = pid_state.lock().unwrap();
        *pid_guard
    };

    if let Some(_pid) = pid {
        let filter_id = format!("filter_{}", filter_request.scan_id);
        
        // Initialize filter progress
        {
            let mut global_filter_progress = GLOBAL_FILTER_PROGRESS.write().unwrap();
            global_filter_progress.insert(filter_id.clone(), request::FilterProgressResponse {
                filter_id: filter_id.clone(),
                progress_percentage: 0.0,
                processed_results: 0,
                total_results: 0,
                is_filtering: true,
                current_region: Some("Starting filter...".to_string()),
            });
        }

        // Start background filter processing
        let filter_request_clone = filter_request.clone();
        let pid_state_clone = pid_state.clone();
        let filter_id_clone = filter_id.clone();
        
        tokio::spawn(async move {
            if let Err(e) = perform_memory_filter_async(pid_state_clone, filter_request_clone, filter_id_clone.clone()).await {
                eprintln!("Filter error: {}", e);
                // Mark as completed with error
                let mut global_filter_progress = GLOBAL_FILTER_PROGRESS.write().unwrap();
                if let Some(progress) = global_filter_progress.get_mut(&filter_id_clone) {
                    progress.is_filtering = false;
                    progress.current_region = Some(format!("Error: {}", e));
                }
            }
        });

        // Return immediate response
        let response = json!({
            "success": true,
            "message": "Filter started",
            "filter_id": filter_id,
            "scan_id": filter_request.scan_id
        });
        
        let response = Response::builder()
            .header("Content-Type", "application/json")
            .status(StatusCode::ACCEPTED)
            .body(Body::from(response.to_string()))
            .unwrap();
        
        return Ok(response);
    }

    let response = Response::builder()
        .status(StatusCode::BAD_REQUEST)
        .body(Body::from("No process attached"))
        .unwrap();
    Ok(response)
}

// Original filter logic moved to async function
async fn perform_memory_filter_async(
    pid_state: Arc<Mutex<Option<i32>>>,
    filter_request: request::MemoryFilterRequest,
    filter_id: String,
) -> Result<(), String> {
    let pid = {
        let pid_guard = pid_state.lock().unwrap();
        pid_guard.ok_or("No process attached")?
    };

    let mut is_suspend_success: bool = false;
    let do_suspend = filter_request.do_suspend;
    
    // Get the total number of items to process for progress calculation
    let total_items = {
        let global_positions = GLOBAL_POSITIONS.read().unwrap();
        if let Some(positions) = global_positions.get(&filter_request.scan_id) {
            positions.len()
        } else {
            // For unknown scan type, estimate from file sizes
            let mut scan_folder_path = PathBuf::from("");
            let mode = std::env::var("DBGSRV_RUNNING_MODE").unwrap_or_else(|_| "unknown".to_string());
            if mode == "embedded" {
                let cache_directory = util::get_cache_directory(pid);
                scan_folder_path = PathBuf::from(&cache_directory);
            }
            let sanitized_scan_id = filter_request.scan_id.trim().replace(" ", "_");
            scan_folder_path.push("dbgsrv-data-dir");
            scan_folder_path.push(&sanitized_scan_id);
            
            if let Ok(entries) = fs::read_dir(&scan_folder_path) {
                entries.count()
            } else {
                1 // Default minimum
            }
        }
    };

    // Update initial progress with total count
    {
        let mut global_filter_progress = GLOBAL_FILTER_PROGRESS.write().unwrap();
        if let Some(progress) = global_filter_progress.get_mut(&filter_id) {
            progress.total_results = total_items as u64;
            progress.current_region = Some("Initializing filter...".to_string());
        }
    }

        #[allow(unused_assignments)]
        let mut new_positions = Vec::new();
        let mut global_positions = GLOBAL_POSITIONS.write().unwrap();
        let global_scan_option = GLOBAL_SCAN_OPTION.write().unwrap();
        let scan_option: request::MemoryScanRequest = global_scan_option
            .get(&filter_request.scan_id)
            .unwrap()
            .clone();
        let found_count = Arc::new(AtomicUsize::new(0));
        let processed_count = Arc::new(AtomicUsize::new(0)); // Track processed items
        let size = match filter_request.data_type.as_str() {
            "int16" | "uint16" => 2,
            "int32" | "uint32" | "float" => 4,
            "int64" | "uint64" | "double" => 8,
            "bytes" => {
                // For bytes type, use the actual pattern length
                match hex::decode(&filter_request.pattern) {
                    Ok(bytes) => bytes.len(),
                    Err(_) => 1, // Fallback to 1 if pattern is invalid
                }
            },
            _ => 1,
        };
        let is_error_occurred = Arc::new(Mutex::new(false));
        let error_message = Arc::new(Mutex::new(String::new()));

        let mut scan_folder_path = PathBuf::from("");
        let mode =
            std::env::var("DBGSRV_RUNNING_MODE").unwrap_or_else(|_| "unknown".to_string());
        if mode == "embedded" {
            let cache_directory = util::get_cache_directory(pid);
            scan_folder_path = PathBuf::from(&cache_directory);
        }
        let sanitized_scan_id = filter_request.scan_id.trim().replace(" ", "_");
        scan_folder_path.push("dbgsrv-data-dir");
        scan_folder_path.push(&sanitized_scan_id);

        // Start progress monitoring task
        let filter_id_progress = filter_id.clone();
        let processed_count_progress = Arc::clone(&processed_count);
        let total_items_progress = total_items;
        let _progress_task = std::thread::spawn(move || {
            loop {
                let current_processed = processed_count_progress.load(Ordering::SeqCst);
                let progress_percentage = if total_items_progress > 0 {
                    (current_processed as f64 / total_items_progress as f64) * 100.0
                } else {
                    0.0
                };

                // Update progress
                if let Ok(mut global_filter_progress) = GLOBAL_FILTER_PROGRESS.try_write() {
                    if let Some(progress) = global_filter_progress.get_mut(&filter_id_progress) {
                        progress.processed_results = current_processed as u64;
                        progress.progress_percentage = progress_percentage;
                        if current_processed >= total_items_progress {
                            break;
                        }
                    }
                }

                // Sleep for 50ms before next update
                std::thread::sleep(std::time::Duration::from_millis(50));
            }
        });

        // Get tokio handle for WASM mode (needed for rayon threads)
        let tokio_handle = if wasm_bridge::is_wasm_mode() {
            tokio::runtime::Handle::try_current().ok()
        } else {
            None
        };
        let tokio_handle = Arc::new(tokio_handle);

        // unknown search
        if scan_option.find_type == "unknown" {
            if do_suspend {
                unsafe {
                    is_suspend_success = native_bridge::suspend_process(pid);
                }
            }

            let paths = match fs::read_dir(&scan_folder_path) {
                Ok(entries) => entries
                    .filter_map(|entry| entry.ok().map(|e| e.path()))
                    .collect::<Vec<_>>(),
                Err(e) => {
                    let mut error_occurred = is_error_occurred.lock().unwrap();
                    let mut error_msg = error_message.lock().unwrap();
                    *error_occurred = true;
                    *error_msg = format!("Failed to read directory: {}", e);
                    vec![]
                }
            };

            let scan_align = scan_option.align;

            let mut exact_bytes: Vec<u8> = vec![];
            // Decode pattern for exact, range, greater_or_equal, and less_than filters
            if filter_request.filter_method.as_str() == "exact" 
                || filter_request.filter_method.as_str() == "range"
                || filter_request.filter_method.as_str() == "greater_or_equal"
                || filter_request.filter_method.as_str() == "less_than" {
                exact_bytes = match hex::decode(&filter_request.pattern) {
                    Ok(bytes) => bytes,
                    Err(_) => vec![],
                };
            }

            if !*is_error_occurred.lock().unwrap() {
                let tokio_handle_clone = Arc::clone(&tokio_handle);
                paths.par_iter().enumerate().for_each(|(_index, file_path)| {
                    let tokio_handle = Arc::clone(&tokio_handle_clone);
                    let mut error_occurred = is_error_occurred.lock().unwrap();
                    let mut error_msg = error_message.lock().unwrap();
                    if *error_occurred {
                        return;
                    }
                    
                    // Update progress
                    processed_count.fetch_add(1, Ordering::SeqCst);
                    
                    let mut serialized_data: Vec<u8> = Vec::new();
                    if let Ok(file) = File::open(file_path) {
                        let mut reader = BufReader::new(file);
                        let mut data_buffer: Vec<u8> = Vec::new();
                        if let Err(e) = reader.read_to_end(&mut data_buffer) {
                            *error_occurred = true;
                            *error_msg = format!("Failed to read file: {}", e);
                            return;
                        }
                        let status_flag: [u8; 4] = match data_buffer[0..4].try_into() {
                            Ok(flag) => flag,
                            Err(e) => {
                                *error_occurred = true;
                                *error_msg = format!("Invalid address format: {}", e);
                                return;
                            }
                        };
                        let mut offset = 4;
                        let usize_size = size_of::<usize>();
                        if status_flag == [0x00, 0x00, 0x00, 0x00] {
                            while offset + 3 * usize_size <= data_buffer.len() {
                                let address = usize::from_le_bytes(
                                    data_buffer[offset..offset + usize_size]
                                        .try_into()
                                        .expect("Invalid address format"),
                                );

                                offset += usize_size;

                                let compressed_data_size = usize::from_le_bytes(
                                    data_buffer[offset..offset + usize_size]
                                        .try_into()
                                        .expect("Invalid length format"),
                                );
                                offset += usize_size;

                                let uncompressed_data_size = usize::from_le_bytes(
                                    data_buffer[offset..offset + usize_size]
                                        .try_into()
                                        .expect("Invalid length format"),
                                );
                                offset += usize_size;

                                if offset + compressed_data_size <= data_buffer.len() {
                                    let compressed_data =
                                        &data_buffer[offset..offset + compressed_data_size];
                                    offset += compressed_data_size;
                                    let decompressed_data = match lz4_flex::block::decompress(
                                        &compressed_data,
                                        uncompressed_data_size,
                                    ) {
                                        Ok(data) => data,
                                        Err(e) => {
                                            *error_occurred = true;
                                            *error_msg =
                                                format!("Failed to decompress data: {}", e);
                                            return;
                                        }
                                    };

                                    let mut buffer: Vec<u8> =
                                        vec![0; (decompressed_data.len()) as usize];
                                    let _nread = match native_bridge::read_process_memory_with_handle(
                                        pid,
                                        address as *mut libc::c_void,
                                        decompressed_data.len(),
                                        &mut buffer,
                                        tokio_handle.as_ref().as_ref(),
                                    ) {
                                        Ok(nread) => nread,
                                        Err(_err) => -1,
                                    };

                                    if _nread == -1 {
                                        return;
                                    }
                                    for offset in (0..decompressed_data.len()).step_by(1) {
                                        if (address + offset) % scan_align != 0 {
                                            continue;
                                        }
                                        if offset + size > decompressed_data.len() {
                                            break;
                                        }
                                        let old_val = &decompressed_data[offset..offset + size];
                                        let new_val = &buffer[offset..offset + size];

                                        let mut pass_filter: bool = false;
                                        if filter_request.filter_method.as_str() == "exact" {
                                            if exact_bytes == new_val {
                                                pass_filter = true;
                                            }
                                        } else if filter_request.filter_method.as_str() == "range" {
                                            // Range filter: check if value is between min and max
                                            let min_bytes = &exact_bytes;
                                            let max_bytes = match &filter_request.pattern_max {
                                                Some(max_pattern) => match hex::decode(max_pattern) {
                                                    Ok(bytes) => bytes,
                                                    Err(_) => continue,
                                                },
                                                None => continue,
                                            };
                                            
                                            pass_filter = match filter_request.data_type.as_str() {
                                                "int8" => {
                                                    let val = new_val[0] as i8;
                                                    let min = i8::from_le_bytes([min_bytes[0]]);
                                                    let max = i8::from_le_bytes([max_bytes[0]]);
                                                    val >= min && val <= max
                                                }
                                                "uint8" => {
                                                    let val = new_val[0];
                                                    val >= min_bytes[0] && val <= max_bytes[0]
                                                }
                                                "int16" => {
                                                    let val = LittleEndian::read_i16(new_val);
                                                    let min = LittleEndian::read_i16(min_bytes);
                                                    let max = LittleEndian::read_i16(&max_bytes);
                                                    val >= min && val <= max
                                                }
                                                "uint16" => {
                                                    let val = LittleEndian::read_u16(new_val);
                                                    let min = LittleEndian::read_u16(min_bytes);
                                                    let max = LittleEndian::read_u16(&max_bytes);
                                                    val >= min && val <= max
                                                }
                                                "int32" => {
                                                    let val = LittleEndian::read_i32(new_val);
                                                    let min = LittleEndian::read_i32(min_bytes);
                                                    let max = LittleEndian::read_i32(&max_bytes);
                                                    val >= min && val <= max
                                                }
                                                "uint32" => {
                                                    let val = LittleEndian::read_u32(new_val);
                                                    let min = LittleEndian::read_u32(min_bytes);
                                                    let max = LittleEndian::read_u32(&max_bytes);
                                                    val >= min && val <= max
                                                }
                                                "int64" => {
                                                    let val = LittleEndian::read_i64(new_val);
                                                    let min = LittleEndian::read_i64(min_bytes);
                                                    let max = LittleEndian::read_i64(&max_bytes);
                                                    val >= min && val <= max
                                                }
                                                "uint64" => {
                                                    let val = LittleEndian::read_u64(new_val);
                                                    let min = LittleEndian::read_u64(min_bytes);
                                                    let max = LittleEndian::read_u64(&max_bytes);
                                                    val >= min && val <= max
                                                }
                                                "float" => {
                                                    let val = LittleEndian::read_f32(new_val);
                                                    let min = LittleEndian::read_f32(min_bytes);
                                                    let max = LittleEndian::read_f32(&max_bytes);
                                                    !val.is_nan() && val >= min && val <= max
                                                }
                                                "double" => {
                                                    let val = LittleEndian::read_f64(new_val);
                                                    let min = LittleEndian::read_f64(min_bytes);
                                                    let max = LittleEndian::read_f64(&max_bytes);
                                                    !val.is_nan() && val >= min && val <= max
                                                }
                                                _ => false,
                                            };
                                        } else if filter_request.filter_method.as_str() == "greater_or_equal" || filter_request.filter_method.as_str() == "less_than" {
                                            // Greater than or equal / Less than filter
                                            let cmp_bytes = &exact_bytes;
                                            let is_greater_or_equal = filter_request.filter_method.as_str() == "greater_or_equal";
                                            
                                            pass_filter = match filter_request.data_type.as_str() {
                                                "int8" => {
                                                    let val = new_val[0] as i8;
                                                    let cmp = i8::from_le_bytes([cmp_bytes[0]]);
                                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                                }
                                                "uint8" => {
                                                    let val = new_val[0];
                                                    let cmp = cmp_bytes[0];
                                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                                }
                                                "int16" => {
                                                    let val = LittleEndian::read_i16(new_val);
                                                    let cmp = LittleEndian::read_i16(cmp_bytes);
                                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                                }
                                                "uint16" => {
                                                    let val = LittleEndian::read_u16(new_val);
                                                    let cmp = LittleEndian::read_u16(cmp_bytes);
                                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                                }
                                                "int32" => {
                                                    let val = LittleEndian::read_i32(new_val);
                                                    let cmp = LittleEndian::read_i32(cmp_bytes);
                                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                                }
                                                "uint32" => {
                                                    let val = LittleEndian::read_u32(new_val);
                                                    let cmp = LittleEndian::read_u32(cmp_bytes);
                                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                                }
                                                "int64" => {
                                                    let val = LittleEndian::read_i64(new_val);
                                                    let cmp = LittleEndian::read_i64(cmp_bytes);
                                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                                }
                                                "uint64" => {
                                                    let val = LittleEndian::read_u64(new_val);
                                                    let cmp = LittleEndian::read_u64(cmp_bytes);
                                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                                }
                                                "float" => {
                                                    let val = LittleEndian::read_f32(new_val);
                                                    let cmp = LittleEndian::read_f32(cmp_bytes);
                                                    !val.is_nan() && if is_greater_or_equal { val >= cmp } else { val < cmp }
                                                }
                                                "double" => {
                                                    let val = LittleEndian::read_f64(new_val);
                                                    let cmp = LittleEndian::read_f64(cmp_bytes);
                                                    !val.is_nan() && if is_greater_or_equal { val >= cmp } else { val < cmp }
                                                }
                                                _ => false,
                                            };
                                        } else {
                                            pass_filter = match filter_request.data_type.as_str() {
                                                _ => compare_values!(
                                                    new_val,
                                                    old_val,
                                                    filter_request.filter_method.as_str()
                                                ),
                                            };
                                        }
                                        if pass_filter {
                                            serialized_data.extend_from_slice(
                                                &(address + offset).to_le_bytes(),
                                            );
                                            serialized_data.extend_from_slice(new_val);
                                            found_count.fetch_add(1, Ordering::SeqCst);
                                        }
                                    }
                                } else {
                                    break;
                                }
                            }
                        } else {
                            while offset + usize_size + size <= data_buffer.len() {
                                let address = match data_buffer.get(offset..offset + usize_size) {
                                    Some(slice) => usize::from_le_bytes(
                                        slice.try_into().expect("Invalid address format"),
                                    ),
                                    None => break,
                                };
                                offset += usize_size;

                                let old_val = &data_buffer[offset..offset + size];
                                offset += size;

                                let mut new_val_vec: Vec<u8> = vec![0; size];
                                let nread = match native_bridge::read_process_memory_with_handle(
                                    pid,
                                    address as *mut libc::c_void,
                                    size,
                                    &mut new_val_vec,
                                    tokio_handle.as_ref().as_ref(),
                                ) {
                                    Ok(nread) => nread,
                                    Err(_) => {
                                        continue;
                                    }
                                };

                                if nread != size as isize {
                                    println!("Incomplete read at address {:x}", address);
                                    continue;
                                }
                                let new_val: &[u8] = &new_val_vec;

                                let mut pass_filter: bool = false;
                                if filter_request.filter_method.as_str() == "exact" {
                                    if exact_bytes == new_val {
                                        pass_filter = true;
                                    }
                                } else if filter_request.filter_method.as_str() == "range" {
                                    // Range filter: check if value is between min and max
                                    let min_bytes = &exact_bytes;
                                    let max_bytes = match &filter_request.pattern_max {
                                        Some(max_pattern) => match hex::decode(max_pattern) {
                                            Ok(bytes) => bytes,
                                            Err(_) => continue,
                                        },
                                        None => continue,
                                    };
                                    
                                    pass_filter = match filter_request.data_type.as_str() {
                                        "int8" => {
                                            let val = new_val[0] as i8;
                                            let min = i8::from_le_bytes([min_bytes[0]]);
                                            let max = i8::from_le_bytes([max_bytes[0]]);
                                            val >= min && val <= max
                                        }
                                        "uint8" => {
                                            let val = new_val[0];
                                            val >= min_bytes[0] && val <= max_bytes[0]
                                        }
                                        "int16" => {
                                            let val = LittleEndian::read_i16(new_val);
                                            let min = LittleEndian::read_i16(min_bytes);
                                            let max = LittleEndian::read_i16(&max_bytes);
                                            val >= min && val <= max
                                        }
                                        "uint16" => {
                                            let val = LittleEndian::read_u16(new_val);
                                            let min = LittleEndian::read_u16(min_bytes);
                                            let max = LittleEndian::read_u16(&max_bytes);
                                            val >= min && val <= max
                                        }
                                        "int32" => {
                                            let val = LittleEndian::read_i32(new_val);
                                            let min = LittleEndian::read_i32(min_bytes);
                                            let max = LittleEndian::read_i32(&max_bytes);
                                            val >= min && val <= max
                                        }
                                        "uint32" => {
                                            let val = LittleEndian::read_u32(new_val);
                                            let min = LittleEndian::read_u32(min_bytes);
                                            let max = LittleEndian::read_u32(&max_bytes);
                                            val >= min && val <= max
                                        }
                                        "int64" => {
                                            let val = LittleEndian::read_i64(new_val);
                                            let min = LittleEndian::read_i64(min_bytes);
                                            let max = LittleEndian::read_i64(&max_bytes);
                                            val >= min && val <= max
                                        }
                                        "uint64" => {
                                            let val = LittleEndian::read_u64(new_val);
                                            let min = LittleEndian::read_u64(min_bytes);
                                            let max = LittleEndian::read_u64(&max_bytes);
                                            val >= min && val <= max
                                        }
                                        "float" => {
                                            let val = LittleEndian::read_f32(new_val);
                                            let min = LittleEndian::read_f32(min_bytes);
                                            let max = LittleEndian::read_f32(&max_bytes);
                                            !val.is_nan() && val >= min && val <= max
                                        }
                                        "double" => {
                                            let val = LittleEndian::read_f64(new_val);
                                            let min = LittleEndian::read_f64(min_bytes);
                                            let max = LittleEndian::read_f64(&max_bytes);
                                            !val.is_nan() && val >= min && val <= max
                                        }
                                        _ => false,
                                    };
                                } else if filter_request.filter_method.as_str() == "greater_or_equal" || filter_request.filter_method.as_str() == "less_than" {
                                    // Greater than or equal / Less than filter
                                    let cmp_bytes = &exact_bytes;
                                    let is_greater_or_equal = filter_request.filter_method.as_str() == "greater_or_equal";
                                    
                                    pass_filter = match filter_request.data_type.as_str() {
                                        "int8" => {
                                            let val = new_val[0] as i8;
                                            let cmp = i8::from_le_bytes([cmp_bytes[0]]);
                                            if is_greater_or_equal { val >= cmp } else { val < cmp }
                                        }
                                        "uint8" => {
                                            let val = new_val[0];
                                            let cmp = cmp_bytes[0];
                                            if is_greater_or_equal { val >= cmp } else { val < cmp }
                                        }
                                        "int16" => {
                                            let val = LittleEndian::read_i16(new_val);
                                            let cmp = LittleEndian::read_i16(cmp_bytes);
                                            if is_greater_or_equal { val >= cmp } else { val < cmp }
                                        }
                                        "uint16" => {
                                            let val = LittleEndian::read_u16(new_val);
                                            let cmp = LittleEndian::read_u16(cmp_bytes);
                                            if is_greater_or_equal { val >= cmp } else { val < cmp }
                                        }
                                        "int32" => {
                                            let val = LittleEndian::read_i32(new_val);
                                            let cmp = LittleEndian::read_i32(cmp_bytes);
                                            if is_greater_or_equal { val >= cmp } else { val < cmp }
                                        }
                                        "uint32" => {
                                            let val = LittleEndian::read_u32(new_val);
                                            let cmp = LittleEndian::read_u32(cmp_bytes);
                                            if is_greater_or_equal { val >= cmp } else { val < cmp }
                                        }
                                        "int64" => {
                                            let val = LittleEndian::read_i64(new_val);
                                            let cmp = LittleEndian::read_i64(cmp_bytes);
                                            if is_greater_or_equal { val >= cmp } else { val < cmp }
                                        }
                                        "uint64" => {
                                            let val = LittleEndian::read_u64(new_val);
                                            let cmp = LittleEndian::read_u64(cmp_bytes);
                                            if is_greater_or_equal { val >= cmp } else { val < cmp }
                                        }
                                        "float" => {
                                            let val = LittleEndian::read_f32(new_val);
                                            let cmp = LittleEndian::read_f32(cmp_bytes);
                                            !val.is_nan() && if is_greater_or_equal { val >= cmp } else { val < cmp }
                                        }
                                        "double" => {
                                            let val = LittleEndian::read_f64(new_val);
                                            let cmp = LittleEndian::read_f64(cmp_bytes);
                                            !val.is_nan() && if is_greater_or_equal { val >= cmp } else { val < cmp }
                                        }
                                        _ => false,
                                    };
                                } else {
                                    pass_filter = match filter_request.data_type.as_str() {
                                        _ => compare_values!(
                                            new_val,
                                            old_val,
                                            filter_request.filter_method.as_str()
                                        ),
                                    };
                                }

                                if pass_filter {
                                    serialized_data.extend_from_slice(&address.to_le_bytes());
                                    serialized_data.extend_from_slice(&new_val);
                                    found_count.fetch_add(1, Ordering::SeqCst);
                                }
                            }
                        }
                    }

                    // rewrite file
                    let mut file = match OpenOptions::new()
                        .write(true)
                        .truncate(true)
                        .open(file_path)
                    {
                        Ok(file) => file,
                        Err(e) => {
                            *error_occurred = true;
                            *error_msg = format!("Failed to open file for writing: {}", e);
                            return;
                        }
                    };

                    let number: u32 = 0x00000001;
                    if let Err(e) = file.write_all(&number.to_le_bytes()) {
                        *error_occurred = true;
                        *error_msg = format!("Failed to write status flag: {}", e);
                        return;
                    }

                    if let Err(e) = file.write_all(&serialized_data) {
                        *error_occurred = true;
                        *error_msg = format!("Failed to write data: {}", e);
                        return;
                    }
                });
            }

            new_positions = if found_count.load(Ordering::SeqCst) < 1_000_000 {
                let results: Vec<(usize, String)> = paths
                    .par_iter()
                    .flat_map(|file_path| {
                        let mut file = match File::open(file_path) {
                            Ok(file) => file,
                            Err(e) => {
                                eprintln!("Failed to open file {:?}: {}", file_path, e);
                                return Vec::new();
                            }
                        };

                        let mut flag = [0u8; 4];
                        if let Err(e) = file.read_exact(&mut flag) {
                            eprintln!("Failed to read flag from {:?}: {}", file_path, e);
                            return Vec::new();
                        }

                        if u32::from_le_bytes(flag) != 0x00000001 {
                            return Vec::new();
                        }

                        let mut data = Vec::new();
                        if let Err(e) = file.read_to_end(&mut data) {
                            eprintln!("Failed to read data from {:?}: {}", file_path, e);
                            return Vec::new();
                        }

                        let mut local_results = Vec::new();
                        let mut offset = 0;
                        while offset + std::mem::size_of::<usize>() + size <= data.len() {
                            let address = usize::from_le_bytes(
                                data[offset..offset + std::mem::size_of::<usize>()]
                                    .try_into()
                                    .unwrap(),
                            );
                            offset += std::mem::size_of::<usize>();
                            let value = hex::encode(&data[offset..offset + size]);
                            offset += size;
                            local_results.push((address, value));
                        }

                        local_results
                    })
                    .collect();
                results
            } else {
                Vec::new()
            };
            new_positions.par_sort_unstable_by_key(|&(address, _)| address);
        } else if let Some(positions) = global_positions.get(&filter_request.scan_id) {
            // For exact scan: use existing processed_count for consistency
            
            if do_suspend {
                unsafe {
                    is_suspend_success = native_bridge::suspend_process(pid);
                }
            }
            let tokio_handle_clone = Arc::clone(&tokio_handle);
            let results: Result<Vec<_>, _> = positions
                .par_iter()
                .enumerate()
                .map(|(_index, (address, value))| {
                    let tokio_handle = Arc::clone(&tokio_handle_clone);
                    // Calculate the correct size based on data type instead of pattern length
                    let size = match filter_request.data_type.as_str() {
                        "int8" | "uint8" => 1,
                        "int16" | "uint16" => 2,
                        "int32" | "uint32" | "float" => 4,
                        "int64" | "uint64" | "double" => 8,
                        "bytes" => hex::decode(&filter_request.pattern).map(|bytes| bytes.len()).unwrap_or(1),
                        _ => value.len() / 2, // For string, use the original value length
                    };
                    
                    let mut buffer: Vec<u8> = vec![0; size];
                    let _nread = match native_bridge::read_process_memory_with_handle(
                        pid,
                        *address as *mut libc::c_void,
                        size,
                        &mut buffer,
                        tokio_handle.as_ref().as_ref(),
                    ) {
                        Ok(nread) => nread,
                        Err(_err) => -1,
                    };

                    if _nread == -1 {
                        // Update progress count even for failed reads
                        processed_count.fetch_add(1, Ordering::Relaxed);
                        return Ok(None);
                    }

                    if filter_request.data_type == "regex" {
                        let regex_pattern = &filter_request.pattern;
                        let re = match Regex::new(regex_pattern) {
                            Ok(re) => re,
                            Err(_) => {
                                processed_count.fetch_add(1, Ordering::Relaxed);
                                return Ok(None);
                            }
                        };
                        if re.is_match(&buffer) {
                            found_count.fetch_add(1, Ordering::SeqCst);
                            processed_count.fetch_add(1, Ordering::Relaxed);
                            return Ok(Some((*address, hex::encode(&buffer))));
                        }
                        processed_count.fetch_add(1, Ordering::Relaxed);
                        return Ok(None);
                    } else {
                        if filter_request.filter_method == "exact" {
                            let result = hex::decode(&filter_request.pattern);
                            let bytes = match result {
                                Ok(bytes) => bytes,
                                Err(_) => {
                                    processed_count.fetch_add(1, Ordering::Relaxed);
                                    return Err("Invalid hex pattern".to_string());
                                }
                            };
                            if buffer == bytes {
                                found_count.fetch_add(1, Ordering::SeqCst);
                                processed_count.fetch_add(1, Ordering::Relaxed);
                                return Ok(Some((*address, hex::encode(&buffer))));
                            }
                            processed_count.fetch_add(1, Ordering::Relaxed);
                            return Ok(None);
                        } else if filter_request.filter_method == "range" {
                            // Range filter for non-unknown scans
                            let min_bytes = match hex::decode(&filter_request.pattern) {
                                Ok(bytes) => bytes,
                                Err(_) => {
                                    processed_count.fetch_add(1, Ordering::Relaxed);
                                    return Err("Invalid hex min pattern".to_string());
                                }
                            };
                            let max_bytes = match &filter_request.pattern_max {
                                Some(max_pattern) => match hex::decode(max_pattern) {
                                    Ok(bytes) => bytes,
                                    Err(_) => {
                                        processed_count.fetch_add(1, Ordering::Relaxed);
                                        return Err("Invalid hex max pattern".to_string());
                                    }
                                },
                                None => {
                                    processed_count.fetch_add(1, Ordering::Relaxed);
                                    return Err("Range filter requires pattern_max".to_string());
                                }
                            };
                            
                            let pass_filter = match filter_request.data_type.as_str() {
                                "int8" => {
                                    let val = buffer[0] as i8;
                                    let min = i8::from_le_bytes([min_bytes[0]]);
                                    let max = i8::from_le_bytes([max_bytes[0]]);
                                    val >= min && val <= max
                                }
                                "uint8" => {
                                    let val = buffer[0];
                                    val >= min_bytes[0] && val <= max_bytes[0]
                                }
                                "int16" => {
                                    let val = LittleEndian::read_i16(&buffer);
                                    let min = LittleEndian::read_i16(&min_bytes);
                                    let max = LittleEndian::read_i16(&max_bytes);
                                    val >= min && val <= max
                                }
                                "uint16" => {
                                    let val = LittleEndian::read_u16(&buffer);
                                    let min = LittleEndian::read_u16(&min_bytes);
                                    let max = LittleEndian::read_u16(&max_bytes);
                                    val >= min && val <= max
                                }
                                "int32" => {
                                    let val = LittleEndian::read_i32(&buffer);
                                    let min = LittleEndian::read_i32(&min_bytes);
                                    let max = LittleEndian::read_i32(&max_bytes);
                                    val >= min && val <= max
                                }
                                "uint32" => {
                                    let val = LittleEndian::read_u32(&buffer);
                                    let min = LittleEndian::read_u32(&min_bytes);
                                    let max = LittleEndian::read_u32(&max_bytes);
                                    val >= min && val <= max
                                }
                                "int64" => {
                                    let val = LittleEndian::read_i64(&buffer);
                                    let min = LittleEndian::read_i64(&min_bytes);
                                    let max = LittleEndian::read_i64(&max_bytes);
                                    val >= min && val <= max
                                }
                                "uint64" => {
                                    let val = LittleEndian::read_u64(&buffer);
                                    let min = LittleEndian::read_u64(&min_bytes);
                                    let max = LittleEndian::read_u64(&max_bytes);
                                    val >= min && val <= max
                                }
                                "float" => {
                                    let val = LittleEndian::read_f32(&buffer);
                                    let min = LittleEndian::read_f32(&min_bytes);
                                    let max = LittleEndian::read_f32(&max_bytes);
                                    !val.is_nan() && val >= min && val <= max
                                }
                                "double" => {
                                    let val = LittleEndian::read_f64(&buffer);
                                    let min = LittleEndian::read_f64(&min_bytes);
                                    let max = LittleEndian::read_f64(&max_bytes);
                                    !val.is_nan() && val >= min && val <= max
                                }
                                _ => false,
                            };
                            
                            if pass_filter {
                                found_count.fetch_add(1, Ordering::SeqCst);
                                processed_count.fetch_add(1, Ordering::Relaxed);
                                return Ok(Some((*address, hex::encode(&buffer))));
                            }
                            processed_count.fetch_add(1, Ordering::Relaxed);
                            return Ok(None);
                        } else if filter_request.filter_method == "greater_or_equal" || filter_request.filter_method == "less_than" {
                            // Greater than or equal / Less than filter for non-unknown scans
                            let cmp_bytes = match hex::decode(&filter_request.pattern) {
                                Ok(bytes) => bytes,
                                Err(_) => {
                                    processed_count.fetch_add(1, Ordering::Relaxed);
                                    return Err("Invalid hex pattern".to_string());
                                }
                            };
                            let is_greater_or_equal = filter_request.filter_method == "greater_or_equal";
                            
                            let pass_filter = match filter_request.data_type.as_str() {
                                "int8" => {
                                    let val = buffer[0] as i8;
                                    let cmp = i8::from_le_bytes([cmp_bytes[0]]);
                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                }
                                "uint8" => {
                                    let val = buffer[0];
                                    let cmp = cmp_bytes[0];
                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                }
                                "int16" => {
                                    let val = LittleEndian::read_i16(&buffer);
                                    let cmp = LittleEndian::read_i16(&cmp_bytes);
                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                }
                                "uint16" => {
                                    let val = LittleEndian::read_u16(&buffer);
                                    let cmp = LittleEndian::read_u16(&cmp_bytes);
                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                }
                                "int32" => {
                                    let val = LittleEndian::read_i32(&buffer);
                                    let cmp = LittleEndian::read_i32(&cmp_bytes);
                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                }
                                "uint32" => {
                                    let val = LittleEndian::read_u32(&buffer);
                                    let cmp = LittleEndian::read_u32(&cmp_bytes);
                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                }
                                "int64" => {
                                    let val = LittleEndian::read_i64(&buffer);
                                    let cmp = LittleEndian::read_i64(&cmp_bytes);
                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                }
                                "uint64" => {
                                    let val = LittleEndian::read_u64(&buffer);
                                    let cmp = LittleEndian::read_u64(&cmp_bytes);
                                    if is_greater_or_equal { val >= cmp } else { val < cmp }
                                }
                                "float" => {
                                    let val = LittleEndian::read_f32(&buffer);
                                    let cmp = LittleEndian::read_f32(&cmp_bytes);
                                    !val.is_nan() && if is_greater_or_equal { val >= cmp } else { val < cmp }
                                }
                                "double" => {
                                    let val = LittleEndian::read_f64(&buffer);
                                    let cmp = LittleEndian::read_f64(&cmp_bytes);
                                    !val.is_nan() && if is_greater_or_equal { val >= cmp } else { val < cmp }
                                }
                                _ => false,
                            };
                            
                            if pass_filter {
                                found_count.fetch_add(1, Ordering::SeqCst);
                                processed_count.fetch_add(1, Ordering::Relaxed);
                                return Ok(Some((*address, hex::encode(&buffer))));
                            }
                            processed_count.fetch_add(1, Ordering::Relaxed);
                            return Ok(None);
                        } else {
                            let result = hex::decode(&value);
                            let bytes = match result {
                                Ok(bytes) => bytes,
                                Err(_) => {
                                    return Err("Invalid hex pattern in stored value".to_string());
                                }
                            };
                            let pass_filter: bool;

                            pass_filter = match filter_request.data_type.as_str() {
                                "int8" => {
                                    let old_val = i8::from_le_bytes(bytes.try_into().unwrap());
                                    let val = i8::from_le_bytes(buffer.clone().try_into().unwrap());
                                    
                                    compare_values!(
                                        val,
                                        old_val,
                                        filter_request.filter_method.as_str()
                                    )
                                }
                                "uint8" => {
                                    let old_val = u8::from_le_bytes(bytes.try_into().unwrap());
                                    let val = u8::from_le_bytes(buffer.clone().try_into().unwrap());
                                    compare_values!(
                                        val,
                                        old_val,
                                        filter_request.filter_method.as_str()
                                    )
                                }
                                "int16" => {
                                    let old_val = i16::from_le_bytes(bytes.try_into().unwrap());
                                    let val =
                                        i16::from_le_bytes(buffer.clone().try_into().unwrap());
                                    compare_values!(
                                        val,
                                        old_val,
                                        filter_request.filter_method.as_str()
                                    )
                                }
                                "uint16" => {
                                    let old_val = u16::from_le_bytes(bytes.try_into().unwrap());
                                    let val =
                                        u16::from_le_bytes(buffer.clone().try_into().unwrap());
                                    compare_values!(
                                        val,
                                        old_val,
                                        filter_request.filter_method.as_str()
                                    )
                                }
                                "int32" => {
                                    let old_val = i32::from_le_bytes(bytes.try_into().unwrap());
                                    let val =
                                        i32::from_le_bytes(buffer.clone().try_into().unwrap());
                                    
                                    compare_values!(
                                        val,
                                        old_val,
                                        filter_request.filter_method.as_str()
                                    )
                                }
                                "uint32" => {
                                    let old_val = u32::from_le_bytes(bytes.try_into().unwrap());
                                    let val =
                                        u32::from_le_bytes(buffer.clone().try_into().unwrap());
                                    compare_values!(
                                        val,
                                        old_val,
                                        filter_request.filter_method.as_str()
                                    )
                                }
                                "int64" => {
                                    let old_val = i64::from_le_bytes(bytes.try_into().unwrap());
                                    let val =
                                        i64::from_le_bytes(buffer.clone().try_into().unwrap());
                                    compare_values!(
                                        val,
                                        old_val,
                                        filter_request.filter_method.as_str()
                                    )
                                }
                                "uint64" => {
                                    let old_val = u64::from_le_bytes(bytes.try_into().unwrap());
                                    let val =
                                        u64::from_le_bytes(buffer.clone().try_into().unwrap());
                                    compare_values!(
                                        val,
                                        old_val,
                                        filter_request.filter_method.as_str()
                                    )
                                }
                                "float" => {
                                    let old_val = LittleEndian::read_f32(&bytes);
                                    let val = LittleEndian::read_f32(&buffer.clone());
                                    compare_values!(
                                        val,
                                        old_val,
                                        filter_request.filter_method.as_str()
                                    )
                                }
                                "double" => {
                                    let old_val = LittleEndian::read_f64(&bytes);
                                    let val = LittleEndian::read_f64(&buffer.clone());
                                    compare_values!(
                                        val,
                                        old_val,
                                        filter_request.filter_method.as_str()
                                    )
                                }
                                "utf-8" => {
                                    let old_val = str::from_utf8(&bytes).unwrap_or("");
                                    let val = str::from_utf8(&buffer).unwrap_or("");
                                    match filter_request.filter_method.as_str() {
                                        "changed" => val != old_val,
                                        "unchanged" => val == old_val,
                                        _ => false,
                                    }
                                }
                                "utf-16" => {
                                    let buffer_u16: Vec<u16> = buffer
                                        .clone()
                                        .chunks_exact(2)
                                        .map(|b| u16::from_ne_bytes([b[0], b[1]]))
                                        .collect();
                                    match filter_request.filter_method.as_str() {
                                        "changed" => {
                                            let old_value: Vec<u16> = hex::decode(&value)
                                                .unwrap()
                                                .chunks_exact(2)
                                                .map(|b| u16::from_ne_bytes([b[0], b[1]]))
                                                .collect();
                                            buffer_u16 != old_value
                                        }
                                        "unchanged" => {
                                            let old_value: Vec<u16> = hex::decode(&value)
                                                .unwrap()
                                                .chunks_exact(2)
                                                .map(|b| u16::from_ne_bytes([b[0], b[1]]))
                                                .collect();
                                            buffer_u16 == old_value
                                        }
                                        _ => false,
                                    }
                                }
                                "aob" => match filter_request.filter_method.as_str() {
                                    "changed" => buffer != bytes,
                                    "unchanged" => buffer == bytes,
                                    _ => false,
                                },
                                _ => false,
                            };

                            if pass_filter {
                                found_count.fetch_add(1, Ordering::SeqCst);
                                processed_count.fetch_add(1, Ordering::Relaxed);
                                return Ok(Some((*address, hex::encode(&buffer))));
                            }
                        }
                    }
                    
                    // Update progress count for items that don't pass filter
                    processed_count.fetch_add(1, Ordering::Relaxed);
                    
                    Ok(None)
                })
                .collect();

            match results {
                Ok(results) => {
                    new_positions = results.into_iter().filter_map(|x| x).collect();
                }
                Err(_) => {
                    let do_play = GLOBAL_PROCESS_STATE.write().unwrap();
                    if do_suspend && is_suspend_success && *do_play {
                        unsafe {
                            native_bridge::resume_process(pid);
                        }
                    }
                    return Err("Failed to process filter results".to_string());
                }
            }
        } else {
            return Err("Scan ID not found".to_string());
        }
        let do_play = GLOBAL_PROCESS_STATE.write().unwrap();
        if do_suspend && is_suspend_success && *do_play {
            unsafe {
                native_bridge::resume_process(pid);
            }
        }
        global_positions.insert(filter_request.scan_id.clone(), new_positions.clone());

        // Update filter progress to completed
        {
            let mut global_filter_progress = GLOBAL_FILTER_PROGRESS.write().unwrap();
            if let Some(progress) = global_filter_progress.get_mut(&filter_id) {
                progress.is_filtering = false;
                progress.progress_percentage = 100.0;
                progress.current_region = Some(format!("Filter completed. Found {} results", found_count.load(Ordering::SeqCst)));
            }
        }
        
        Ok(())
}

#[derive(Serialize)]
struct Region {
    start_address: String,
    end_address: String,
    protection: String,
    file_path: Option<String>,
}

#[derive(Debug, Deserialize)]
pub struct EnumerateRegionsQuery {
    pub include_file_path: Option<bool>,
}

pub async fn enumerate_regions_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    include_file_path: bool,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Check if WASM mode is enabled
    if wasm_bridge::is_wasm_mode() {
        // In WASM mode, return regions using Cetus-style enumeration
        // This returns 2 regions if an initial snapshot exists:
        // 1. Live linear memory (heap)
        // 2. Initial snapshot (frozen at initialization)
        let regions = wasm_bridge::get_wasm_regions_json();
        let result = json!({ "regions": regions });
        let result_string = result.to_string();
        let response = Response::builder()
            .header("Content-Type", "application/json")
            .body(hyper::Body::from(result_string))
            .unwrap();
        return Ok(response);
    }

    let pid = pid_state.lock().unwrap();

    if let Some(pid) = *pid {
        let mut count: usize = 0;
        let region_info_ptr = unsafe { 
            native_bridge::enumerate_regions(pid, &mut count, include_file_path) 
        };

        let mut regions = Vec::new();

        if !region_info_ptr.is_null() && count > 0 {
            let region_info_slice = unsafe { std::slice::from_raw_parts(region_info_ptr, count) };

            for i in 0..count {
                let region_info = &region_info_slice[i];
                let file_path = if !region_info.pathname.is_null() {
                    Some(unsafe { CStr::from_ptr(region_info.pathname).to_string_lossy().into_owned() })
                } else {
                    None
                };

                let region = Region {
                    start_address: format!("{:x}", region_info.start),
                    end_address: format!("{:x}", region_info.end),
                    protection: format_protection(region_info.protection),
                    file_path,
                };
                regions.push(region);
            }

            // Free allocated memory
            unsafe { native_bridge::free_region_info(region_info_ptr, count) };
        }

        let result = json!({ "regions": regions });
        let result_string = result.to_string();
        let response = Response::builder()
            .header("Content-Type", "application/json")
            .body(hyper::Body::from(result_string))
            .unwrap();
        Ok(response)
    } else {
        let response = Response::builder()
            .status(StatusCode::BAD_REQUEST)
            .body(hyper::Body::from("Pid not set"))
            .unwrap();
        Ok(response)
    }
}

/// Format protection bits to string (e.g., "rwx", "r-x", etc.)
fn format_protection(protection: u32) -> String {
    let mut prot = String::with_capacity(3);
    prot.push(if protection & 1 != 0 { 'r' } else { '-' });
    prot.push(if protection & 2 != 0 { 'w' } else { '-' });
    prot.push(if protection & 4 != 0 { 'x' } else { '-' });
    prot
}

pub async fn enumerate_process_handler() -> Result<impl Reply, Rejection> {
    let mut count: usize = 0;
    let process_info_ptr = unsafe { native_bridge::enumerate_processes(&mut count) };
    let process_info_slice = unsafe { std::slice::from_raw_parts(process_info_ptr, count) };

    let mut json_array = Vec::new();
    for i in 0..count {
        let process_name = unsafe {
            CStr::from_ptr(process_info_slice[i].processname)
                .to_string_lossy()
                .into_owned()
        };
        json_array.push(json!({
            "pid": process_info_slice[i].pid,
            "processname": process_name
        }));
        unsafe { libc::free(process_info_slice[i].processname as *mut libc::c_void) };
    }

    // for cdylib
    if count == 0 {
        let pid = unsafe { native_bridge::get_pid_native() };
        json_array.push(json!({
            "pid": pid,
            "processname": "self".to_string()
        }));
    } else {
        unsafe {
            libc::free(process_info_ptr as *mut libc::c_void);
        }
    }

    let json_response = warp::reply::json(&json_array);
    Ok(json_response)
}

pub async fn enumerate_modules_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Check if WASM mode is enabled - return WASM module info (Cetus-style)
    if wasm_bridge::is_wasm_mode() {
        let modules = wasm_bridge::get_wasm_modules_json();
        let response = ApiResponse::success(json!({ "modules": modules }));
        return Ok(warp::reply::json(&response));
    }

    match pid_state.lock() {
        Ok(pid) => {
            if let Some(pid) = *pid {
                match native_bridge::enum_modules(pid) {
                    Ok(modules) => {
                        let response = ApiResponse::success(json!({ "modules": modules }));
                        Ok(warp::reply::json(&response))
                    }
                    Err(e) => {
                        let response = ApiResponse::<Value>::error(format!("Failed to enumerate modules: {}", e));
                        Ok(warp::reply::json(&response))
                    }
                }
            } else {
                let response = ApiResponse::<Value>::error("Process not attached".to_string());
                Ok(warp::reply::json(&response))
            }
        }
        Err(_) => {
            let response = ApiResponse::<Value>::error("Failed to acquire process state lock".to_string());
            Ok(warp::reply::json(&response))
        }
    }
}

pub async fn enumerate_threads_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    // In WASM mode, return empty threads list (WASM has no native threads)
    if wasm_bridge::is_wasm_mode() {
        let response = ApiResponse::success(json!({ "threads": Vec::<serde_json::Value>::new() }));
        return Ok(warp::reply::json(&response));
    }

    match pid_state.lock() {
        Ok(pid) => {
            if let Some(pid) = *pid {
                match native_bridge::enum_threads(pid) {
                    Ok(threads) => {
                        let response = ApiResponse::success(json!({ "threads": threads }));
                        Ok(warp::reply::json(&response))
                    }
                    Err(e) => {
                        let response = ApiResponse::<Value>::error(format!("Failed to enumerate threads: {}", e));
                        Ok(warp::reply::json(&response))
                    }
                }
            } else {
                let response = ApiResponse::<Value>::error("Process not attached".to_string());
                Ok(warp::reply::json(&response))
            }
        }
        Err(_) => {
            let response = ApiResponse::<Value>::error("Failed to acquire process state lock".to_string());
            Ok(warp::reply::json(&response))
        }
    }
}

pub async fn enumerate_symbols_handler(
    module_base: usize,
    pid_state: Arc<Mutex<Option<i32>>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    // In WASM mode, return symbols from Cetus-style instrumentation
    if wasm_bridge::is_wasm_mode() {
        let symbols = wasm_bridge::get_wasm_symbols_json();
        let response = ApiResponse::success(json!({ "symbols": symbols }));
        return Ok(warp::reply::json(&response));
    }

    let pid = pid_state.lock().unwrap();
    if let Some(pid) = *pid {
        match native_bridge::enum_symbols(pid, module_base) {
            Ok(symbols) => {
                let response = ApiResponse::success(json!({ "symbols": symbols }));
                Ok(warp::reply::json(&response))
            }
            Err(error) => {
                // Instead of returning 500, return success with empty symbols and a message
                info!("No symbols found for module at 0x{:X}: {}", module_base, error);
                let response = ApiResponse::success_with_message(
                    json!({ "symbols": Vec::<serde_json::Value>::new() }),
                    format!("No symbols found: {}", error)
                );
                Ok(warp::reply::json(&response))
            }
        }
    } else {
        let response = ApiResponse::<Value>::error("No process attached".to_string());
        Ok(warp::reply::json(&response))
    }
}

pub async fn disassemble_handler(
    req: request::DisassembleRequest,
    state: Arc<Mutex<Option<i32>>>,
) -> Result<impl Reply, Rejection> {
    let pid = match state.lock().unwrap().as_ref() {
        Some(pid) => *pid,
        None => {
            return Ok(warp::reply::with_status(
                warp::reply::json(&json!({
                    "success": false,
                    "message": "No process is attached"
                })),
                warp::http::StatusCode::BAD_REQUEST,
            ));
        }
    };

    // Read memory from the specified address
    let mut buffer = vec![0u8; req.size];
    
    // Use /proc/pid/mem for Linux/Android systems during disassembly
    #[cfg(any(target_os = "linux", target_os = "android"))]
    let read_result = native_bridge::read_process_memory_with_method(
        pid,
        req.address as *mut libc::c_void,
        req.size,
        &mut buffer,
        1, // mode 1 = /proc/pid/mem (no thread stop needed)
    );
    
    // Use regular memory reading for other platforms
    #[cfg(not(any(target_os = "linux", target_os = "android")))]
    let read_result = native_bridge::read_process_memory(
        pid,
        req.address as *mut libc::c_void,
        req.size,
        &mut buffer,
    );

    match read_result {
        Ok(_) => {
            // Disassemble the read memory
            let disassembled = util::disassemble_internal(
                buffer.as_ptr(),
                buffer.len(),
                req.address,
                &req.architecture,
            );

            // Parse metadata from disassembly result
            let mut actual_size = req.size; // Default to requested size
            let mut clean_disassembly = String::new();
            
            for line in disassembled.lines() {
                if line.starts_with("__METADATA__|") {
                    // Parse metadata line: __METADATA__|actual_size:240|requested_size:256
                    if let Some(actual_part) = line.split('|').find(|s| s.starts_with("actual_size:")) {
                        if let Some(size_str) = actual_part.strip_prefix("actual_size:") {
                            if let Ok(size) = size_str.parse::<usize>() {
                                actual_size = size;
                            }
                        }
                    }
                } else {
                    // Regular instruction line
                    clean_disassembly.push_str(line);
                    clean_disassembly.push('\n');
                }
            }

            let response = json!({
                "success": true,
                "address": format!("0x{:x}", req.address),
                "size": actual_size,  // Return actual size, not requested size
                "requested_size": req.size,  // Also provide requested size for reference
                "architecture": req.architecture,
                "disassembly": clean_disassembly.trim_end()  // Remove trailing newline
            });

            Ok(warp::reply::with_status(
                warp::reply::json(&response),
                warp::http::StatusCode::OK,
            ))
        }
        Err(e) => {
            let response = json!({
                "success": false,
                "message": format!("Failed to read memory: {}", e)
            });

            Ok(warp::reply::with_status(
                warp::reply::json(&response),
                warp::http::StatusCode::INTERNAL_SERVER_ERROR,
            ))
        }
    }
}

pub async fn explore_directory_handler(
    req: request::ExploreDirectoryRequest,
) -> Result<impl Reply, Rejection> {
    let decoded_path = percent_decode_str(&req.path)
        .decode_utf8_lossy()
        .into_owned();

    let c_path = match CString::new(decoded_path.clone()) {
        Ok(path) => path,
        Err(_) => {
            return Ok(warp::reply::with_status(
                warp::reply::json(&json!({
                    "error": "Invalid path: contains null byte",
                    "path": decoded_path,
                    "max_depth": req.max_depth
                })),
                warp::http::StatusCode::BAD_REQUEST,
            ))
        }
    };

    let result = panic::catch_unwind(|| unsafe {
        let result_ptr = native_bridge::explore_directory(c_path.as_ptr(), req.max_depth as c_int);
        if result_ptr.is_null() {
            return Err("Null pointer returned from explore_directory");
        }
        let result_str = CStr::from_ptr(result_ptr).to_string_lossy().into_owned();
        libc::free(result_ptr as *mut libc::c_void);
        Ok(result_str)
    });

    let result = match result {
        Ok(Ok(result)) => result,
        Ok(Err(err)) => {
            return Ok(warp::reply::with_status(
                warp::reply::json(&json!({
                    "error": err,
                    "path": decoded_path,
                    "max_depth": req.max_depth
                })),
                warp::http::StatusCode::INTERNAL_SERVER_ERROR,
            ))
        }
        Err(_) => {
            return Ok(warp::reply::with_status(
                warp::reply::json(&json!({
                    "error": "Process panicked during directory exploration",
                    "path": decoded_path,
                    "max_depth": req.max_depth
                })),
                warp::http::StatusCode::INTERNAL_SERVER_ERROR,
            ))
        }
    };

    if result.starts_with("Error:") {
        return Ok(warp::reply::with_status(
            warp::reply::json(&json!({
                "error": result,
                "path": decoded_path,
                "max_depth": req.max_depth
            })),
            warp::http::StatusCode::BAD_REQUEST,
        ));
    }

    match panic::catch_unwind(|| util::parse_directory_structure(&result)) {
        Ok(items) => Ok(warp::reply::with_status(
            warp::reply::json(&items),
            warp::http::StatusCode::OK,
        )),
        Err(_) => Ok(warp::reply::with_status(
            warp::reply::json(&json!({
                "error": "Process panicked during parsing of directory structure",
                "path": decoded_path,
                "max_depth": req.max_depth
            })),
            warp::http::StatusCode::INTERNAL_SERVER_ERROR,
        )),
    }
}

pub async fn read_file_handler(req: request::ReadFileRequest) -> Result<Response<Body>, Rejection> {
    let decoded_path = percent_decode_str(&req.path)
        .decode_utf8_lossy()
        .into_owned();

    let c_path = CString::new(decoded_path.clone()).unwrap();
    let mut size: usize = 0;
    let mut error_ptr: *mut c_char = std::ptr::null_mut();

    let data_ptr = unsafe {
        native_bridge::read_file(
            c_path.as_ptr(),
            &mut size as *mut usize,
            &mut error_ptr as *mut *mut c_char,
        )
    };

    if !error_ptr.is_null() {
        let error_message = unsafe { CStr::from_ptr(error_ptr).to_string_lossy().into_owned() };
        unsafe { libc::free(error_ptr as *mut c_void) };
        return Ok(Response::builder()
            .status(StatusCode::INTERNAL_SERVER_ERROR)
            .body(Body::from(error_message))
            .unwrap());
    }

    if data_ptr.is_null() || size == 0 {
        return Ok(Response::builder()
            .status(StatusCode::NOT_FOUND)
            .body(Body::from("File not found or empty"))
            .unwrap());
    }

    let data = unsafe { slice::from_raw_parts(data_ptr as *const u8, size) }.to_vec();
    unsafe { libc::free(data_ptr as *mut c_void) };

    Ok(Response::builder()
        .header("Content-Type", "application/octet-stream")
        .body(Body::from(data))
        .unwrap())
}

pub async fn upload_file_handler(
    path: String,
    body: Bytes,
) -> Result<impl Reply, Rejection> {
    let decoded_path = percent_decode_str(&path)
        .decode_utf8_lossy()
        .into_owned();

    // Write file using std::fs
    match std::fs::write(&decoded_path, &body) {
        Ok(_) => {
            Ok(warp::reply::with_status(
                warp::reply::json(&json!({
                    "success": true,
                    "path": decoded_path,
                    "size": body.len()
                })),
                StatusCode::OK,
            ))
        }
        Err(e) => {
            Ok(warp::reply::with_status(
                warp::reply::json(&json!({
                    "success": false,
                    "error": format!("Failed to write file: {}", e),
                    "path": decoded_path
                })),
                StatusCode::INTERNAL_SERVER_ERROR,
            ))
        }
    }
}

// ============================================================================
// Script Execution API (disabled - lua_engine removed)
// ============================================================================

pub async fn execute_script_handler(
    _pid_state: Arc<Mutex<Option<i32>>>,
    _script_request: request::ExecuteScriptRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Script execution disabled - lua_engine removed
    Ok(warp::reply::with_status(
        warp::reply::json(&request::ExecuteScriptResponse {
            success: false,
            job_id: String::new(),
            message: "Script execution is not available (lua_engine removed)".to_string(),
        }),
        StatusCode::NOT_IMPLEMENTED,
    ))
}

pub async fn script_status_handler(
    job_id: String,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Script execution disabled - lua_engine removed
    Ok(warp::reply::with_status(
        warp::reply::json(&request::ScriptStatusResponse {
            success: false,
            job_id,
            status: request::ScriptJobStatus::Failed,
            output: String::new(),
            error: Some("Script execution is not available (lua_engine removed)".to_string()),
            trace_callback_registered: false,
            files: Vec::new(),
        }),
        StatusCode::NOT_IMPLEMENTED,
    ))
}

pub async fn script_cancel_handler(
    job_id: String,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Script execution disabled - lua_engine removed
    Ok(warp::reply::with_status(
        warp::reply::json(&request::ScriptCancelResponse {
            success: false,
            message: format!("Script execution is not available (lua_engine removed). Job {} not found.", job_id),
        }),
        StatusCode::NOT_IMPLEMENTED,
    ))
}

/// Handler to disable the current script session
/// This removes all script-owned breakpoints and clears shared state
pub async fn script_disable_handler() -> Result<impl warp::Reply, warp::Rejection> {
    // Script execution disabled - lua_engine removed
    Ok(warp::reply::with_status(
        warp::reply::json(&request::ScriptDisableResponse {
            success: true,
            message: "Script execution is not available (lua_engine removed)".to_string(),
        }),
        StatusCode::OK,
    ))
}

pub async fn get_app_info_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
) -> Result<Box<dyn warp::Reply>, warp::Rejection> {
    match pid_state.lock() {
        Ok(pid) => {
            if let Some(pid) = *pid {
                let result = native_bridge::get_application_info(pid);
                match result {
                    Ok(message) => {
                        match serde_json::from_str::<Value>(&message) {
                            Ok(parsed_result) => {
                                let response = ApiResponse::success(parsed_result);
                                Ok(Box::new(warp::reply::json(&response)))
                            }
                            Err(e) => {
                                let response = ApiResponse::<Value>::error(format!("Failed to parse application info: {}", e));
                                Ok(Box::new(warp::reply::with_status(
                                    warp::reply::json(&response),
                                    StatusCode::INTERNAL_SERVER_ERROR,
                                )))
                            }
                        }
                    }
                    Err(e) => {
                        let response = ApiResponse::<Value>::error(e.to_string());
                        Ok(Box::new(warp::reply::with_status(
                            warp::reply::json(&response),
                            StatusCode::INTERNAL_SERVER_ERROR,
                        )))
                    }
                }
            } else {
                let response = ApiResponse::<Value>::error("Process not attached".to_string());
                Ok(Box::new(warp::reply::with_status(
                    warp::reply::json(&response),
                    StatusCode::BAD_REQUEST,
                )))
            }
        }
        Err(_) => {
            let response = ApiResponse::<Value>::error("Failed to acquire process state lock".to_string());
            Ok(Box::new(warp::reply::with_status(
                warp::reply::json(&response),
                StatusCode::INTERNAL_SERVER_ERROR,
            )))
        }
    }
}

pub async fn set_watchpoint_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    watchpoint: request::SetWatchPointRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    let pid = pid_state.lock().unwrap();

    if let Some(pid) = *pid {
        // Parse access type with enhanced support for combinations
        let _type = match watchpoint._type.to_lowercase().as_str() {
            "r" => 1,
            "w" => 2, 
            "rw" | "wr" => 3,
            "x" => 4,
            "rx" | "xr" => 5,
            "wx" | "xw" => 6,
            "rwx" | "wrx" | "xrw" | "xwr" | "rxw" | "wxr" => 7,
            "a" => 3, // backward compatibility - "a" means read/write access
            _ => {
                return Ok(warp::reply::with_status(
                    warp::reply::json(&request::SetWatchPointResponse {
                        success: false,
                        message: format!("Unknown access type '{}'. Valid types: r, w, rw, x, rx, wx, rwx, a", watchpoint._type),
                        watchpoint_id: None,
                    }),
                    StatusCode::BAD_REQUEST,
                ))
            }
        };

        // Validate watchpoint size - must be 1, 2, 4, or 8 bytes
        match watchpoint.size {
            1 | 2 | 4 | 8 => {}, // Valid sizes
            _ => {
                return Ok(warp::reply::with_status(
                    warp::reply::json(&request::SetWatchPointResponse {
                        success: false,
                        message: format!("Invalid watchpoint size {}. Valid sizes: 1, 2, 4, 8 bytes", watchpoint.size),
                        watchpoint_id: None,
                    }),
                    StatusCode::BAD_REQUEST,
                ))
            }
        }

        let result = native_bridge::set_watchpoint(pid, watchpoint.address, watchpoint.size, _type);

        let ret = match result {
            Ok(_) => {
                // Generate a unique watchpoint ID
                let watchpoint_id = format!("wp_{}_{}", watchpoint.address, chrono::Utc::now().timestamp_millis());
                Ok(warp::reply::with_status(
                    warp::reply::json(&request::SetWatchPointResponse {
                        success: true,
                        message: "Watchpoint set successfully".to_string(),
                        watchpoint_id: Some(watchpoint_id),
                    }),
                    StatusCode::OK,
                ))
            },
            Err(e) => Ok(warp::reply::with_status(
                warp::reply::json(&request::SetWatchPointResponse {
                    success: false,
                    message: format!("Failed to set watchpoint. Error: {}", e),
                    watchpoint_id: None,
                }),
                StatusCode::INTERNAL_SERVER_ERROR,
            )),
        };
        return ret;
    } else {
        Ok(warp::reply::with_status(
            warp::reply::json(&request::SetWatchPointResponse {
                success: false,
                message: format!("Pid not set"),
                watchpoint_id: None,
            }),
            StatusCode::BAD_REQUEST,
        ))
    }
}

pub async fn remove_watchpoint_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    watchpoint: request::RemoveWatchPointRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    let pid = pid_state.lock().unwrap();

    if let Some(_pid) = *pid {
        let result = native_bridge::remove_watchpoint(watchpoint.address);

        let ret = match result {
            Ok(_) => Ok(warp::reply::with_status(
                warp::reply::json(&request::RemoveWatchPointResponse {
                    success: true,
                    message: "Remove Watchpoint set successfully".to_string(),
                }),
                StatusCode::OK,
            )),
            Err(e) => Ok(warp::reply::with_status(
                warp::reply::json(&request::RemoveWatchPointResponse {
                    success: false,
                    message: format!("Failed to remove watchpoint. Error: {}", e),
                }),
                StatusCode::INTERNAL_SERVER_ERROR,
            )),
        };
        return ret;
    } else {
        Ok(warp::reply::with_status(
            warp::reply::json(&request::RemoveWatchPointResponse {
                success: false,
                message: format!("Pid not set"),
            }),
            StatusCode::BAD_REQUEST,
        ))
    }
}

pub async fn list_watchpoints_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    _request: request::ListWatchPointsRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    let pid = pid_state.lock().unwrap();

    if let Some(_pid) = *pid {
        // For now, return empty list as the underlying system doesn't support listing
        // In a real implementation, you would query the actual watchpoints from the debug system
        let watchpoints = Vec::new();
        
        Ok(warp::reply::with_status(
            warp::reply::json(&request::ListWatchPointsResponse {
                success: true,
                watchpoints,
                message: Some("Watchpoint listing not fully implemented".to_string()),
            }),
            StatusCode::OK,
        ))
    } else {
        Ok(warp::reply::with_status(
            warp::reply::json(&request::ListWatchPointsResponse {
                success: false,
                watchpoints: Vec::new(),
                message: Some("Pid not set".to_string()),
            }),
            StatusCode::BAD_REQUEST,
        ))
    }
}

pub async fn set_breakpoint_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    breakpoint: request::SetBreakPointRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    let pid = pid_state.lock().unwrap();
    if let Some(pid) = *pid {
        // Handle trace file output if requested
        let trace_file_path = if breakpoint.trace_to_file {
            if let Some(ref path) = breakpoint.trace_file_path {
                // Enable trace file output
                native_bridge::enable_trace_file_output(path);
                Some(path.clone())
            } else {
                // Generate default path if not provided
                let default_path = format!("/tmp/dynadbg_trace_{}.bin", chrono::Utc::now().timestamp());
                native_bridge::enable_trace_file_output(&default_path);
                Some(default_path)
            }
        } else {
            // Disable trace file output if it was enabled
            native_bridge::disable_trace_file_output();
            None
        };

        // Handle full memory cache if requested
        // Note: Memory dump will be performed on first breakpoint hit in debugger.mm
        if breakpoint.full_memory_cache && breakpoint.trace_to_file {
            let base_path = trace_file_path.as_ref()
                .map(|p| p.trim_end_matches(".bin").to_string())
                .unwrap_or_else(|| format!("/tmp/dynadbg_trace_{}", chrono::Utc::now().timestamp()));
            
            let dump_path = format!("{}.memdump", base_path);
            let log_path = format!("{}.memlog", base_path);
            
            native_bridge::enable_full_memory_cache(&dump_path, &log_path);
        }

        

        let is_software = breakpoint.is_software.unwrap_or(false);
        let result = native_bridge::set_breakpoint(pid, breakpoint.address, breakpoint.hit_count, is_software);
        let ret = match result {
            Ok(_) => Ok(warp::reply::with_status(
                warp::reply::json(&request::SetBreakPointResponse {
                    success: true,
                    message: "Breakpoint set successfully".to_string(),
                    trace_file_path,
                }),
                StatusCode::OK,
            )),
            Err(e) => {
                // Disable trace file on error
                if breakpoint.trace_to_file {
                    native_bridge::disable_trace_file_output();
                }
                // Disable full memory cache on error
                if breakpoint.full_memory_cache {
                    native_bridge::disable_full_memory_cache();
                }
                Ok(warp::reply::with_status(
                    warp::reply::json(&request::SetBreakPointResponse {
                        success: false,
                        message: format!("Failed to set breakpoint. Error: {}", e),
                        trace_file_path: None,
                    }),
                    StatusCode::INTERNAL_SERVER_ERROR,
                ))
            }
        };
        return ret;
    } else {
        Ok(warp::reply::with_status(
            warp::reply::json(&request::SetBreakPointResponse {
                success: false,
                message: format!("Pid not set"),
                trace_file_path: None,
            }),
            StatusCode::BAD_REQUEST,
        ))
    }
}

pub async fn remove_breakpoint_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    breakpoint: request::RemoveBreakPointRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    let pid = pid_state.lock().unwrap();
    if let Some(_pid) = *pid {
        let result = native_bridge::remove_breakpoint(breakpoint.address);
        let ret = match result {
            Ok(_) => Ok(warp::reply::with_status(
                warp::reply::json(&request::RemoveBreakPointResponse {
                    success: true,
                    message: "Breakpoint removed successfully".to_string(),
                }),
                StatusCode::OK,
            )),
            Err(e) => Ok(warp::reply::with_status(
                warp::reply::json(&request::RemoveBreakPointResponse {
                    success: false,
                    message: format!("Failed to remove breakpoint. Error: {}", e),
                }),
                StatusCode::INTERNAL_SERVER_ERROR,
            )),
        };
        return ret;
    } else {
        Ok(warp::reply::with_status(
            warp::reply::json(&request::RemoveBreakPointResponse {
                success: false,
                message: format!("Pid not set"),
            }),
            StatusCode::BAD_REQUEST,
        ))
    }
}

// Get original instruction bytes for a software breakpoint
pub async fn get_software_breakpoint_bytes_handler(
    address: usize,
) -> Result<impl warp::Reply, warp::Rejection> {
    if let Some(bytes) = native_bridge::get_software_breakpoint_original_bytes(address) {
        Ok(warp::reply::with_status(
            warp::reply::json(&request::SoftwareBreakpointBytesResponse {
                success: true,
                address,
                original_bytes: bytes.iter().map(|b| format!("{:02x}", b)).collect::<Vec<_>>().join(" "),
                size: bytes.len(),
                message: None,
            }),
            StatusCode::OK,
        ))
    } else {
        Ok(warp::reply::with_status(
            warp::reply::json(&request::SoftwareBreakpointBytesResponse {
                success: false,
                address,
                original_bytes: String::new(),
                size: 0,
                message: Some("No software breakpoint found at this address".to_string()),
            }),
            StatusCode::NOT_FOUND,
        ))
    }
}

// Signal configuration handlers (catch/pass behavior)
pub async fn get_signal_configs_handler() -> Result<impl warp::Reply, warp::Rejection> {
    let configs = native_bridge::get_all_signal_configs();
    let config_list: Vec<request::SignalConfigEntry> = configs
        .iter()
        .map(|(signal, config)| request::SignalConfigEntry {
            signal: *signal,
            catch_signal: config.catch_signal,
            pass_signal: config.pass_signal,
        })
        .collect();
    Ok(warp::reply::with_status(
        warp::reply::json(&request::GetSignalConfigsResponse {
            success: true,
            configs: config_list,
        }),
        StatusCode::OK,
    ))
}

pub async fn set_signal_config_handler(
    request: request::SetSignalConfigRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    let config = native_bridge::SignalConfig {
        catch_signal: request.catch_signal,
        pass_signal: request.pass_signal,
    };
    native_bridge::set_signal_config(request.signal, config);

    // Return updated configs list
    let configs = native_bridge::get_all_signal_configs();
    let config_entries: Vec<request::SignalConfigEntry> = configs
        .iter()
        .map(|(signal, cfg)| request::SignalConfigEntry {
            signal: *signal,
            catch_signal: cfg.catch_signal,
            pass_signal: cfg.pass_signal,
        })
        .collect();

    Ok(warp::reply::with_status(
        warp::reply::json(&request::GetSignalConfigsResponse {
            success: true,
            configs: config_entries,
        }),
        StatusCode::OK,
    ))
}

pub async fn set_all_signal_configs_handler(
    request: request::SetAllSignalConfigsRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    for entry in &request.configs {
        let config = native_bridge::SignalConfig {
            catch_signal: entry.catch_signal,
            pass_signal: entry.pass_signal,
        };
        native_bridge::set_signal_config(entry.signal, config);
    }

    // Return updated configs list
    let configs = native_bridge::get_all_signal_configs();
    let config_entries: Vec<request::SignalConfigEntry> = configs
        .iter()
        .map(|(signal, cfg)| request::SignalConfigEntry {
            signal: *signal,
            catch_signal: cfg.catch_signal,
            pass_signal: cfg.pass_signal,
        })
        .collect();

    Ok(warp::reply::with_status(
        warp::reply::json(&request::GetSignalConfigsResponse {
            success: true,
            configs: config_entries,
        }),
        StatusCode::OK,
    ))
}

pub async fn remove_signal_config_handler(
    request: request::RemoveSignalConfigRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    native_bridge::remove_signal_config(request.signal);

    // Return updated configs list
    let configs = native_bridge::get_all_signal_configs();
    let config_entries: Vec<request::SignalConfigEntry> = configs
        .iter()
        .map(|(signal, cfg)| request::SignalConfigEntry {
            signal: *signal,
            catch_signal: cfg.catch_signal,
            pass_signal: cfg.pass_signal,
        })
        .collect();

    Ok(warp::reply::with_status(
        warp::reply::json(&request::GetSignalConfigsResponse {
            success: true,
            configs: config_entries,
        }),
        StatusCode::OK,
    ))
}

// Trace status handler
pub async fn get_trace_status_handler() -> Result<impl warp::Reply, warp::Rejection> {
    let enabled = native_bridge::is_trace_file_output_enabled();
    let file_path = if enabled {
        let path = native_bridge::get_trace_file_path();
        if path.is_empty() { None } else { Some(path) }
    } else {
        None
    };
    let entry_count = native_bridge::get_trace_file_entry_count();
    let ended_by_end_address = native_bridge::is_trace_ended_by_end_address();
    
    Ok(warp::reply::with_status(
        warp::reply::json(&request::TraceStatusResponse {
            success: true,
            enabled,
            file_path,
            entry_count,
            ended_by_end_address,
            message: if ended_by_end_address {
                "Trace ended by reaching end address".to_string()
            } else if enabled { 
                format!("Trace file active with {} entries", entry_count) 
            } else { 
                "Trace file output disabled".to_string() 
            },
        }),
        StatusCode::OK,
    ))
}

// Trace file download handler
pub async fn download_trace_file_handler() -> Result<impl warp::Reply, warp::Rejection> {
    let enabled = native_bridge::is_trace_file_output_enabled();
    let file_path = native_bridge::get_trace_file_path();
    
    if file_path.is_empty() {
        return Ok(Response::builder()
            .status(StatusCode::NOT_FOUND)
            .header("Content-Type", "application/json")
            .body(hyper::Body::from(r#"{"success":false,"message":"No trace file available"}"#))
            .unwrap());
    }
    
    // If still recording, close the file first
    if enabled {
        native_bridge::disable_trace_file_output();
    }
    
    // Read the file
    match std::fs::read(&file_path) {
        Ok(data) => {
            let filename = std::path::Path::new(&file_path)
                .file_name()
                .and_then(|n| n.to_str())
                .unwrap_or("trace.bin");
            
            Ok(Response::builder()
                .status(StatusCode::OK)
                .header("Content-Type", "application/octet-stream")
                .header("Content-Disposition", format!("attachment; filename=\"{}\"", filename))
                .header("X-Trace-Entry-Count", native_bridge::get_trace_file_entry_count().to_string())
                .body(hyper::Body::from(data))
                .unwrap())
        }
        Err(e) => {
            Ok(Response::builder()
                .status(StatusCode::INTERNAL_SERVER_ERROR)
                .header("Content-Type", "application/json")
                .body(hyper::Body::from(format!(r#"{{"success":false,"message":"Failed to read trace file: {}"}}"#, e)))
                .unwrap())
        }
    }
}

pub async fn change_process_state_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    state_request: request::ChangeProcessStateRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    let pid = pid_state.lock().unwrap();

    if let Some(_pid) = *pid {
        let result = if state_request.do_play {
            unsafe { native_bridge::resume_process(_pid) }
        } else {
            unsafe { native_bridge::suspend_process(_pid) }
        };

        let ret = match result {
            true => Ok(warp::reply::with_status(
                warp::reply::json(&request::ChangeProcessStateResponse {
                    success: true,
                    message: format!(
                        "Process {} successfully",
                        if state_request.do_play {
                            "resumed"
                        } else {
                            "suspend"
                        }
                    ),
                }),
                StatusCode::OK,
            )),
            false => Ok(warp::reply::with_status(
                warp::reply::json(&request::ChangeProcessStateResponse {
                    success: false,
                    message: format!("Failed to change process state. Error"),
                }),
                StatusCode::INTERNAL_SERVER_ERROR,
            )),
        };
        return ret;
    } else {
        Ok(warp::reply::with_status(
            warp::reply::json(&request::ChangeProcessStateResponse {
                success: false,
                message: "Pid not set".to_string(),
            }),
            StatusCode::BAD_REQUEST,
        ))
    }
}

pub async fn get_process_icon_handler(
    _pid: i32,
) -> Result<impl warp::Reply, warp::Rejection> {
    #[cfg(target_os = "windows")]
    {
        
        match native_bridge::get_process_icon(_pid) {
            Ok(icon_data) => {
                let response = Response::builder()
                    .header("Content-Type", "image/png")
                    .header("Cache-Control", "public, max-age=3600")
                    .body(hyper::Body::from(icon_data))
                    .unwrap();
                Ok(response)
            }
            Err(_) => {
                // Return empty response for processes without icons
                let response = Response::builder()
                    .status(StatusCode::NOT_FOUND)
                    .body(hyper::Body::from("Icon not found"))
                    .unwrap();
                Ok(response)
            }
        }
    }
    
    #[cfg(not(target_os = "windows"))]
    {
        let response = Response::builder()
            .status(StatusCode::NOT_IMPLEMENTED)
            .body(hyper::Body::from("Icon extraction not supported on this platform"))
            .unwrap();
        Ok(response)
    }
}

pub async fn get_scan_progress_handler(
    scan_progress_request: request::ScanProgressRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    let global_scan_progress = GLOBAL_SCAN_PROGRESS.read().unwrap();
    
    if let Some(progress) = global_scan_progress.get(&scan_progress_request.scan_id) {
        let response = ApiResponse::success(progress.clone());
        Ok(warp::reply::json(&response))
    } else {
        // Return default progress if scan_id not found
        let default_progress = request::ScanProgressResponse {
            scan_id: scan_progress_request.scan_id.clone(),
            progress_percentage: 0.0,
            scanned_bytes: 0,
            total_bytes: 0,
            is_scanning: false,
            current_region: None,
        };
        let response = ApiResponse::success(default_progress);
        Ok(warp::reply::json(&response))
    }
}

pub async fn get_filter_progress_handler(
    filter_progress_request: request::FilterProgressRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    let global_filter_progress = GLOBAL_FILTER_PROGRESS.read().unwrap();
    
    if let Some(progress) = global_filter_progress.get(&filter_progress_request.filter_id) {
        let response = ApiResponse::success(progress.clone());
        Ok(warp::reply::json(&response))
    } else {
        // Return default progress if filter_id not found
        let default_progress = request::FilterProgressResponse {
            filter_id: filter_progress_request.filter_id.clone(),
            progress_percentage: 0.0,
            processed_results: 0,
            total_results: 0,
            is_filtering: false,
            current_region: Some("Filter not found or not started".to_string()),
        };
        let response = ApiResponse::success(default_progress);
        Ok(warp::reply::json(&response))
    }
}

pub async fn get_scan_results_handler(
    scan_results_request: request::ScanProgressRequest, // Reuse same request structure
) -> Result<impl warp::Reply, warp::Rejection> {
    // Check if scan is completed first
    let global_scan_progress = GLOBAL_SCAN_PROGRESS.read().unwrap();
    if let Some(progress) = global_scan_progress.get(&scan_results_request.scan_id) {
        if progress.is_scanning {
            let response = ApiResponse::<Value>::error("Scan is still in progress".to_string());
            return Ok(warp::reply::json(&response));
        }
    } else {
        let response = ApiResponse::<Value>::error("Scan ID not found".to_string());
        return Ok(warp::reply::json(&response));
    }
    
    // Get scan results
    let global_positions = GLOBAL_POSITIONS.read().unwrap();
    if let Some(positions) = global_positions.get(&scan_results_request.scan_id) {
        let limited_positions = &positions[..std::cmp::min(MAX_RESULTS, positions.len())];
        let total_count = positions.len();
        let is_rounded = limited_positions.len() != positions.len();
        
        let matched_addresses: Vec<serde_json::Value> = limited_positions
            .iter()
            .map(|(address, value)| {
                json!({
                    "address": address,
                    "value": value
                })
            })
            .collect();
            
        let result = json!({
            "matched_addresses": matched_addresses,
            "found": total_count,
            "is_rounded": is_rounded
        });
        
        let response = ApiResponse::success(result);
        Ok(warp::reply::json(&response))
    } else {
        let response = ApiResponse::<Value>::error("No results found for scan ID".to_string());
        Ok(warp::reply::json(&response))
    }
}

pub async fn stop_scan_handler(
    stop_request: request::ScanProgressRequest, // Reuse same request structure for scan_id
) -> Result<impl warp::Reply, warp::Rejection> {
    // Set stop flag for the scan
    let scan_stop_flags = SCAN_STOP_FLAGS.write().unwrap();
    if let Some(stop_flag) = scan_stop_flags.get(&stop_request.scan_id) {
        if let Ok(mut should_stop) = stop_flag.lock() {
            *should_stop = true;
        }
        
        // Update scan progress to stopped
        let mut global_scan_progress = GLOBAL_SCAN_PROGRESS.write().unwrap();
        if let Some(progress) = global_scan_progress.get_mut(&stop_request.scan_id) {
            progress.is_scanning = false;
            progress.current_region = Some("Scan stopped by user".to_string());
        }
        
        let response = ApiResponse::success(json!({
            "message": "Scan stop signal sent successfully",
            "scan_id": stop_request.scan_id
        }));
        Ok(warp::reply::json(&response))
    } else {
        let response = ApiResponse::<Value>::error("Scan ID not found or already completed".to_string());
        Ok(warp::reply::json(&response))
    }
}

pub async fn clear_scan_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    clear_request: request::ScanProgressRequest, // Reuse same request structure for scan_id
) -> Result<impl warp::Reply, warp::Rejection> {
    let pid = {
        let pid_guard = pid_state.lock().unwrap();
        *pid_guard
    };

    if let Some(pid) = pid {
        // Clear scan data from memory
        {
            let mut global_positions = GLOBAL_POSITIONS.write().unwrap();
            global_positions.remove(&clear_request.scan_id);
            
            let mut global_memory = GLOBAL_MEMORY.write().unwrap();
            global_memory.remove(&clear_request.scan_id);
            
            let mut global_scan_option = GLOBAL_SCAN_OPTION.write().unwrap();
            global_scan_option.remove(&clear_request.scan_id);
            
            let mut global_scan_progress = GLOBAL_SCAN_PROGRESS.write().unwrap();
            global_scan_progress.remove(&clear_request.scan_id);
            
            let mut scan_stop_flags = SCAN_STOP_FLAGS.write().unwrap();
            scan_stop_flags.remove(&clear_request.scan_id);
        }
        
        // Clean up scan files on disk
        let mut scan_folder_path = PathBuf::from("");
        let mode = std::env::var("DBGSRV_RUNNING_MODE").unwrap_or_else(|_| "unknown".to_string());
        if mode == "embedded" {
            let cache_directory = util::get_cache_directory(pid);
            scan_folder_path = PathBuf::from(&cache_directory);
        }
        let sanitized_scan_id = clear_request.scan_id.trim().replace(" ", "_");
        scan_folder_path.push("dbgsrv-data-dir");
        scan_folder_path.push(&sanitized_scan_id);
        
        if scan_folder_path.exists() {
            match fs::remove_dir_all(&scan_folder_path) {
                Ok(_) => {
                    let response = ApiResponse::success(json!({
                        "message": "Scan data cleared successfully",
                        "scan_id": clear_request.scan_id
                    }));
                    Ok(warp::reply::json(&response))
                }
                Err(e) => {
                    let response = ApiResponse::<Value>::error(format!("Failed to remove scan directory: {}", e));
                    Ok(warp::reply::json(&response))
                }
            }
        } else {
            let response = ApiResponse::success(json!({
                "message": "Scan data cleared successfully (no files to remove)",
                "scan_id": clear_request.scan_id
            }));
            Ok(warp::reply::json(&response))
        }
    } else {
        let response = ApiResponse::<Value>::error("No process attached".to_string());
        Ok(warp::reply::json(&response))
    }
}

// New break state control handlers
pub async fn continue_execution_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    request: request::ContinueExecutionRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    let _pid = pid_state.lock().unwrap();

    if let Some(_pid) = *_pid {
        // Build thread ID list (use thread_ids if present, otherwise thread_id)
        let thread_ids: Vec<u64> = if let Some(ids) = request.thread_ids {
            ids
        } else if let Some(id) = request.thread_id {
            vec![id]
        } else {
            let response = request::ContinueExecutionResponse {
                success: false,
                message: "No thread_id or thread_ids specified".to_string(),
                results: None,
            };
            return Ok(warp::reply::with_status(
                warp::reply::json(&response),
                StatusCode::BAD_REQUEST,
            ));
        };

        // Multiple threads
        if thread_ids.len() > 1 {
            let mut results: Vec<request::ThreadContinueResult> = Vec::new();
            let mut all_success = true;
            let mut success_count = 0;
            let mut fail_count = 0;

            for thread_id in &thread_ids {
                match native_bridge::continue_execution(*thread_id as libc::uintptr_t) {
                    Ok(_) => {
                        results.push(request::ThreadContinueResult {
                            thread_id: *thread_id,
                            success: true,
                            message: "Continued successfully".to_string(),
                        });
                        success_count += 1;
                    }
                    Err(e) => {
                        results.push(request::ThreadContinueResult {
                            thread_id: *thread_id,
                            success: false,
                            message: format!("Failed: {}", e),
                        });
                        all_success = false;
                        fail_count += 1;
                    }
                }
            }

            let response = request::ContinueExecutionResponse {
                success: all_success,
                message: format!(
                    "Continued {} threads ({} success, {} failed)",
                    thread_ids.len(),
                    success_count,
                    fail_count
                ),
                results: Some(results),
            };
            Ok(warp::reply::with_status(
                warp::reply::json(&response),
                if all_success { StatusCode::OK } else { StatusCode::PARTIAL_CONTENT },
            ))
        } else {
            // Single thread (backward compatibility)
            let thread_id = thread_ids[0];
            match native_bridge::continue_execution(thread_id as libc::uintptr_t) {
                Ok(_) => {
                    let response = request::ContinueExecutionResponse {
                        success: true,
                        message: format!("Execution continued successfully for thread {}", thread_id),
                        results: None,
                    };
                    Ok(warp::reply::with_status(
                        warp::reply::json(&response),
                        StatusCode::OK,
                    ))
                }
                Err(e) => {
                    let response = request::ContinueExecutionResponse {
                        success: false,
                        message: format!("Failed to continue execution for thread {}: {}", thread_id, e),
                        results: None,
                    };
                    Ok(warp::reply::with_status(
                        warp::reply::json(&response),
                        StatusCode::INTERNAL_SERVER_ERROR,
                    ))
                }
            }
        }
    } else {
        let response = request::ContinueExecutionResponse {
            success: false,
            message: "Process not attached".to_string(),
            results: None,
        };
        Ok(warp::reply::with_status(
            warp::reply::json(&response),
            StatusCode::BAD_REQUEST,
        ))
    }
}

pub async fn single_step_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    request: request::SingleStepRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    let _pid = pid_state.lock().unwrap();

    
    if let Some(_pid) = *_pid {
        match native_bridge::single_step(request.thread_id as libc::uintptr_t) {
            Ok(_) => {
                let response = request::SingleStepResponse {
                    success: true,
                    message: format!("Single step executed successfully for thread {}", request.thread_id),
                };
                Ok(warp::reply::with_status(
                    warp::reply::json(&response),
                    StatusCode::OK,
                ))
            }
            Err(e) => {
                let response = request::SingleStepResponse {
                    success: false,
                    message: format!("Failed to execute single step for thread {}: {}", request.thread_id, e),
                };
                Ok(warp::reply::with_status(
                    warp::reply::json(&response),
                    StatusCode::INTERNAL_SERVER_ERROR,
                ))
            }
        }
    } else {
        let response = request::SingleStepResponse {
            success: false,
            message: "Process not attached".to_string(),
        };
        Ok(warp::reply::with_status(
            warp::reply::json(&response),
            StatusCode::BAD_REQUEST,
        ))
    }
}

pub async fn read_register_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    request: request::ReadRegisterRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    let _pid = pid_state.lock().unwrap();

    if let Some(_pid) = *_pid {
        match native_bridge::read_register(request.thread_id as libc::uintptr_t, &request.register_name) {
            Ok(value) => {
                let response = request::ReadRegisterResponse {
                    success: true,
                    register_name: request.register_name.clone(),
                    value: Some(value),
                    message: format!("Register {} read successfully from thread {}", request.register_name, request.thread_id),
                };
                Ok(warp::reply::with_status(
                    warp::reply::json(&response),
                    StatusCode::OK,
                ))
            }
            Err(e) => {
                let response = request::ReadRegisterResponse {
                    success: false,
                    register_name: request.register_name.clone(),
                    value: None,
                    message: format!("Failed to read register from thread {}: {}", request.thread_id, e),
                };
                Ok(warp::reply::with_status(
                    warp::reply::json(&response),
                    StatusCode::INTERNAL_SERVER_ERROR,
                ))
            }
        }
    } else {
        let response = request::ReadRegisterResponse {
            success: false,
            register_name: request.register_name.clone(),
            value: None,
            message: "Process not attached".to_string(),
        };
        Ok(warp::reply::with_status(
            warp::reply::json(&response),
            StatusCode::BAD_REQUEST,
        ))
    }
}

pub async fn write_register_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    request: request::WriteRegisterRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    let _pid = pid_state.lock().unwrap();

    if let Some(_pid) = *_pid {
        match native_bridge::write_register(request.thread_id as libc::uintptr_t, &request.register_name, request.value) {
            Ok(_) => {
                let response = request::WriteRegisterResponse {
                    success: true,
                    message: format!("Register {} written successfully to thread {}", request.register_name, request.thread_id),
                };
                Ok(warp::reply::with_status(
                    warp::reply::json(&response),
                    StatusCode::OK,
                ))
            }
            Err(e) => {
                let response = request::WriteRegisterResponse {
                    success: false,
                    message: format!("Failed to write register to thread {}: {}", request.thread_id, e),
                };
                Ok(warp::reply::with_status(
                    warp::reply::json(&response),
                    StatusCode::INTERNAL_SERVER_ERROR,
                ))
            }
        }
    } else {
        let response = request::WriteRegisterResponse {
            success: false,
            message: "Process not attached".to_string(),
        };
        Ok(warp::reply::with_status(
            warp::reply::json(&response),
            StatusCode::BAD_REQUEST,
        ))
    }
}

pub async fn debug_state_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    _request: request::DebugStateRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    let _pid = pid_state.lock().unwrap();

    if let Some(_pid) = *_pid {
        let is_in_break_state = native_bridge::is_in_break_state();
        let response = request::DebugStateResponse {
            success: true,
            is_in_break_state,
            message: format!("Debug state: {}", 
                if is_in_break_state { "In break state" } else { "Running" }),
        };
        Ok(warp::reply::with_status(
            warp::reply::json(&response),
            StatusCode::OK,
        ))
    } else {
        let response = request::DebugStateResponse {
            success: false,
            is_in_break_state: false,
            message: "Process not attached".to_string(),
        };
        Ok(warp::reply::with_status(
            warp::reply::json(&response),
            StatusCode::BAD_REQUEST,
        ))
    }
}

pub async fn get_installed_apps_handler() -> Result<impl warp::Reply, warp::Rejection> {
    #[cfg(any(target_os = "ios", target_os = "macos"))]
    {
        match native_bridge::get_installed_apps() {
            Ok(apps_json) => {
                // Parse JSON string to Value for proper response formatting
                match serde_json::from_str::<serde_json::Value>(&apps_json) {
                    Ok(apps) => {
                        let response = ApiResponse::success(json!({
                            "apps": apps
                        }));
                        Ok(warp::reply::json(&response))
                    }
                    Err(e) => {
                        let response = ApiResponse::<Value>::error(format!("Failed to parse apps JSON: {}", e));
                        Ok(warp::reply::json(&response))
                    }
                }
            }
            Err(e) => {
                let response = ApiResponse::<Value>::error(format!("Failed to get installed apps: {}", e));
                Ok(warp::reply::json(&response))
            }
        }
    }
    
    #[cfg(not(any(target_os = "ios", target_os = "macos")))]
    {
        let response = ApiResponse::<Value>::error("Installed apps listing not supported on this platform".to_string());
        Ok(warp::reply::json(&response))
    }
}

pub async fn get_app_icon_handler(
    _request: request::GetAppIconRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    #[cfg(any(target_os = "ios", target_os = "macos"))]
    {
        match native_bridge::get_app_icon(&_request.bundle_identifier) {
            Ok(icon_data) => {
                let response = Response::builder()
                    .header("Content-Type", "image/png")
                    .header("Cache-Control", "public, max-age=3600")
                    .body(hyper::Body::from(icon_data))
                    .unwrap();
                Ok(response)
            }
            Err(_) => {
                // Return empty response for apps without icons
                let response = Response::builder()
                    .status(StatusCode::NOT_FOUND)
                    .body(hyper::Body::from("Icon not found"))
                    .unwrap();
                Ok(response)
            }
        }
    }
    
    #[cfg(not(any(target_os = "ios", target_os = "macos")))]
    {
        let response = Response::builder()
            .status(StatusCode::NOT_IMPLEMENTED)
            .body(hyper::Body::from("App icon extraction not supported on this platform"))
            .unwrap();
        Ok(response)
    }
}

// Spawn app via FBSSystemService (iOS/macOS)
pub async fn spawn_app_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    _request: request::SpawnAppRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    #[cfg(any(target_os = "ios", target_os = "macos"))]
    {
        match native_bridge::spawn_app(&_request.bundle_identifier, _request.suspended) {
            Ok(result_json) => {
                // Parse JSON string to Value for proper response formatting
                match serde_json::from_str::<serde_json::Value>(&result_json) {
                    Ok(result) => {
                        // Auto-attach if spawn was successful and PID is valid
                        if let Some(success) = result.get("success").and_then(|v| v.as_bool()) {
                            if success {
                                if let Some(pid) = result.get("pid").and_then(|v| v.as_i64()) {
                                    if pid > 0 {
                                        // Auto-attach to the spawned process
                                        if let Ok(mut state) = pid_state.lock() {
                                            *state = Some(pid as i32);
                                            info!("Auto-attached to spawned process with PID: {}", pid);
                                        }
                                    }
                                }
                            }
                        }
                        
                        let response = ApiResponse::success(result);
                        Ok(warp::reply::json(&response))
                    }
                    Err(e) => {
                        let response = ApiResponse::<Value>::error(format!("Failed to parse spawn result: {}", e));
                        Ok(warp::reply::json(&response))
                    }
                }
            }
            Err(e) => {
                let response = ApiResponse::<Value>::error(format!("Failed to spawn app: {}", e));
                Ok(warp::reply::json(&response))
            }
        }
    }
    
    #[cfg(not(any(target_os = "ios", target_os = "macos")))]
    {
        let response = ApiResponse::<Value>::error("App spawn not supported on this platform".to_string());
        Ok(warp::reply::json(&response))
    }
}

// Spawn process via fork/exec (Linux)
pub async fn spawn_process_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    _request: request::SpawnProcessRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    #[cfg(target_os = "linux")]
    {
        use std::ffi::CString;
        use std::path::Path;
        
        // Check if executable exists
        let path = Path::new(&_request.executable_path);
        if !path.exists() {
            let response = ApiResponse::<Value>::error(format!(
                "Executable not found: {}", _request.executable_path
            ));
            return Ok(warp::reply::json(&response));
        }
        
        // Use C++ native function for spawn
        let exe_cstr = match CString::new(_request.executable_path.as_str()) {
            Ok(s) => s,
            Err(e) => {
                let response = ApiResponse::<Value>::error(format!("Invalid executable path: {}", e));
                return Ok(warp::reply::json(&response));
            }
        };
        
        // Convert args to CStrings
        let args_cstr: Vec<CString> = _request.args.iter()
            .filter_map(|s| CString::new(s.as_str()).ok())
            .collect();
        let args_ptrs: Vec<*const libc::c_char> = args_cstr.iter()
            .map(|s| s.as_ptr())
            .collect();
        
        let mut out_pid: libc::pid_t = 0;
        
        let result = unsafe {
            native_bridge::spawn_process_native(
                exe_cstr.as_ptr(),
                args_ptrs.as_ptr(),
                args_ptrs.len() as libc::c_int,
                &mut out_pid
            )
        };
        
        if result == 0 && out_pid > 0 {
            // Auto-attach to the spawned process
            if let Ok(mut state) = pid_state.lock() {
                *state = Some(out_pid);
                info!("Attached to spawned process with PID: {}", out_pid);
            }
            
            let response = ApiResponse::success(json!({
                "success": true,
                "pid": out_pid,
                "message": "Process spawned and stopped at entry point"
            }));
            Ok(warp::reply::json(&response))
        } else {
            let response = ApiResponse::<Value>::error(format!("Failed to spawn process, result: {}", result));
            Ok(warp::reply::json(&response))
        }
    }
    
    #[cfg(not(target_os = "linux"))]
    {
        let response = ApiResponse::<Value>::error("Process spawn not supported on this platform".to_string());
        Ok(warp::reply::json(&response))
    }
}

// Spawn process with PTY (Linux)
pub async fn spawn_process_with_pty_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    _request: request::SpawnProcessWithPtyRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    #[cfg(target_os = "linux")]
    {
        use std::ffi::CString;
        use std::path::Path;
        
        // Check if executable exists
        let path = Path::new(&_request.executable_path);
        if !path.exists() {
            let response = ApiResponse::<Value>::error(format!(
                "Executable not found: {}", _request.executable_path
            ));
            return Ok(warp::reply::json(&response));
        }
        
        let exe_cstr = match CString::new(_request.executable_path.as_str()) {
            Ok(s) => s,
            Err(e) => {
                let response = ApiResponse::<Value>::error(format!("Invalid executable path: {}", e));
                return Ok(warp::reply::json(&response));
            }
        };
        
        let args_cstr: Vec<CString> = _request.args.iter()
            .filter_map(|s| CString::new(s.as_str()).ok())
            .collect();
        let args_ptrs: Vec<*const libc::c_char> = args_cstr.iter()
            .map(|s| s.as_ptr())
            .collect();
        
        let mut out_pid: i32 = 0;
        let mut out_pty_fd: libc::c_int = 0;
        
        let result = unsafe {
            native_bridge::spawn_process_with_pty(
                exe_cstr.as_ptr(),
                args_ptrs.as_ptr(),
                args_ptrs.len() as libc::c_int,
                &mut out_pid,
                &mut out_pty_fd
            )
        };
        
        if result == 0 && out_pid > 0 {
            if let Ok(mut state) = pid_state.lock() {
                *state = Some(out_pid);
                info!("Attached to PTY spawned process with PID: {}, PTY FD: {}", out_pid, out_pty_fd);
            }
            
            let response = ApiResponse::success(json!({
                "success": true,
                "pid": out_pid,
                "pty_fd": out_pty_fd,
                "message": "Process spawned with PTY and stopped at entry point"
            }));
            Ok(warp::reply::json(&response))
        } else {
            let response = ApiResponse::<Value>::error(format!("Failed to spawn process with PTY, result: {}", result));
            Ok(warp::reply::json(&response))
        }
    }
    
    #[cfg(not(target_os = "linux"))]
    {
        let response = ApiResponse::<Value>::error("PTY spawn not supported on this platform".to_string());
        Ok(warp::reply::json(&response))
    }
}

pub async fn pty_read_handler(
    _pty_fd: i32,
) -> Result<impl warp::Reply, warp::Rejection> {
    #[cfg(target_os = "linux")]
    {
        let mut buffer = vec![0u8; 4096];
        let bytes_read = unsafe {
            native_bridge::read_pty(
                _pty_fd,
                buffer.as_mut_ptr() as *mut libc::c_char,
                buffer.len()
            )
        };
        
        if bytes_read > 0 {
            buffer.truncate(bytes_read as usize);
            // Convert to base64 for safe JSON transport (handles binary/control chars)
            let encoded = base64::Engine::encode(&base64::engine::general_purpose::STANDARD, &buffer);
            let response = ApiResponse::success(json!({
                "data": encoded,
                "bytes": bytes_read
            }));
            Ok(warp::reply::json(&response))
        } else if bytes_read == 0 {
            // No data available
            let response = ApiResponse::success(json!({
                "data": "",
                "bytes": 0
            }));
            Ok(warp::reply::json(&response))
        } else {
            let response = ApiResponse::<Value>::error("Failed to read from PTY".to_string());
            Ok(warp::reply::json(&response))
        }
    }
    
    #[cfg(not(target_os = "linux"))]
    {
        let response = ApiResponse::<Value>::error("PTY not supported on this platform".to_string());
        Ok(warp::reply::json(&response))
    }
}

pub async fn pty_write_handler(
    _request: request::PtyWriteRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    #[cfg(target_os = "linux")]
    {
        use std::ffi::CString;
        
        let data = match CString::new(_request.data.as_str()) {
            Ok(s) => s,
            Err(_) => {
                // Handle null bytes - write raw bytes instead
                let bytes = _request.data.as_bytes();
                let bytes_written = unsafe {
                    native_bridge::write_pty(
                        _request.pty_fd,
                        bytes.as_ptr() as *const libc::c_char,
                        bytes.len()
                    )
                };
                
                if bytes_written >= 0 {
                    let response = ApiResponse::success(json!({
                        "bytes_written": bytes_written
                    }));
                    return Ok(warp::reply::json(&response));
                } else {
                    let response = ApiResponse::<Value>::error("Failed to write to PTY".to_string());
                    return Ok(warp::reply::json(&response));
                }
            }
        };
        
        let bytes_written = unsafe {
            native_bridge::write_pty(
                _request.pty_fd,
                data.as_ptr(),
                data.as_bytes().len()
            )
        };
        
        if bytes_written >= 0 {
            let response = ApiResponse::success(json!({
                "bytes_written": bytes_written
            }));
            Ok(warp::reply::json(&response))
        } else {
            let response = ApiResponse::<Value>::error("Failed to write to PTY".to_string());
            Ok(warp::reply::json(&response))
        }
    }
    
    #[cfg(not(target_os = "linux"))]
    {
        let response = ApiResponse::<Value>::error("PTY not supported on this platform".to_string());
        Ok(warp::reply::json(&response))
    }
}

pub async fn pty_resize_handler(
    _request: request::PtyResizeRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    #[cfg(target_os = "linux")]
    {
        let result = unsafe {
            native_bridge::set_pty_size(_request.pty_fd, _request.rows, _request.cols)
        };
        
        if result == 0 {
            let response = ApiResponse::success(json!({
                "success": true
            }));
            Ok(warp::reply::json(&response))
        } else {
            let response = ApiResponse::<Value>::error("Failed to resize PTY".to_string());
            Ok(warp::reply::json(&response))
        }
    }
    
    #[cfg(not(target_os = "linux"))]
    {
        let response = ApiResponse::<Value>::error("PTY not supported on this platform".to_string());
        Ok(warp::reply::json(&response))
    }
}

pub async fn pty_close_handler(
    _pty_fd: i32,
) -> Result<impl warp::Reply, warp::Rejection> {
    #[cfg(target_os = "linux")]
    {
        unsafe {
            native_bridge::close_pty(_pty_fd);
        }
        
        let response = ApiResponse::success(json!({
            "success": true
        }));
        Ok(warp::reply::json(&response))
    }
    
    #[cfg(not(target_os = "linux"))]
    {
        let response = ApiResponse::<Value>::error("PTY not supported on this platform".to_string());
        Ok(warp::reply::json(&response))
    }
}

pub async fn terminate_app_handler(
    _request: request::TerminateAppRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    #[cfg(any(target_os = "ios", target_os = "macos"))]
    {
        match native_bridge::terminate_app(_request.pid) {
            Ok(success) => {
                let response = ApiResponse::success(json!({
                    "terminated": success,
                    "pid": _request.pid
                }));
                Ok(warp::reply::json(&response))
            }
            Err(e) => {
                let response = ApiResponse::<Value>::error(format!("Failed to terminate app: {}", e));
                Ok(warp::reply::json(&response))
            }
        }
    }
    
    #[cfg(not(any(target_os = "ios", target_os = "macos")))]
    {
        let response = ApiResponse::<Value>::error("App termination not supported on this platform".to_string());
        Ok(warp::reply::json(&response))
    }
}

// Resume suspended app (iOS/macOS)
pub async fn resume_app_handler(
    _pid_state: Arc<Mutex<Option<i32>>>,
    _request: request::ResumeAppRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    #[cfg(any(target_os = "ios", target_os = "macos"))]
    {
        // Verify the PID matches the attached process
        let attached_pid = _pid_state.lock().unwrap();
        if let Some(current_pid) = *attached_pid {
            if current_pid != _request.pid {
                let response = ApiResponse::<Value>::error(format!(
                    "PID mismatch: requested {} but attached to {}",
                    _request.pid, current_pid
                ));
                return Ok(warp::reply::json(&response));
            }
        }
        drop(attached_pid);

        match native_bridge::resume_app(_request.pid) {
            Ok(result_json) => {
                match serde_json::from_str::<serde_json::Value>(&result_json) {
                    Ok(result) => {
                        let response = ApiResponse::success(result);
                        Ok(warp::reply::json(&response))
                    }
                    Err(e) => {
                        let response = ApiResponse::<Value>::error(format!("Failed to parse resume result: {}", e));
                        Ok(warp::reply::json(&response))
                    }
                }
            }
            Err(e) => {
                let response = ApiResponse::<Value>::error(format!("Failed to resume app: {}", e));
                Ok(warp::reply::json(&response))
            }
        }
    }
    
    #[cfg(not(any(target_os = "ios", target_os = "macos")))]
    {
        let response = ApiResponse::<Value>::error("App resume not supported on this platform".to_string());
        Ok(warp::reply::json(&response))
    }
}

// Check app running status (iOS/macOS)
pub async fn get_app_running_status_handler(
    _request: request::AppRunningStatusRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    #[cfg(any(target_os = "ios", target_os = "macos"))]
    {
        match native_bridge::get_app_running_status(&_request.bundle_identifier) {
            Ok(result_json) => {
                match serde_json::from_str::<serde_json::Value>(&result_json) {
                    Ok(result) => {
                        let response = ApiResponse::success(result);
                        Ok(warp::reply::json(&response))
                    }
                    Err(e) => {
                        let response = ApiResponse::<Value>::error(format!("Failed to parse result: {}", e));
                        Ok(warp::reply::json(&response))
                    }
                }
            }
            Err(e) => {
                let response = ApiResponse::<Value>::error(format!("Failed to get app running status: {}", e));
                Ok(warp::reply::json(&response))
            }
        }
    }
    
    #[cfg(not(any(target_os = "ios", target_os = "macos")))]
    {
        let response = ApiResponse::<Value>::error("App running status not supported on this platform".to_string());
        Ok(warp::reply::json(&response))
    }
}

// ============================================================================
// WASM Binary Dump Handlers
// ============================================================================

/// Dump entire WASM binary for Ghidra analysis
/// Returns raw binary data (application/octet-stream)
pub async fn wasm_dump_handler() -> Result<impl warp::Reply, warp::Rejection> {
    if !wasm_bridge::is_wasm_mode() {
        return Ok(Response::builder()
            .status(StatusCode::BAD_REQUEST)
            .header("Content-Type", "application/json")
            .body(Body::from(r#"{"success":false,"error":"Not in WASM mode"}"#))
            .unwrap());
    }
    
    match wasm_bridge::dump_wasm_binary().await {
        Ok(binary) => {
            info!("WASM dump: returning {} bytes", binary.len());
            Ok(Response::builder()
                .status(StatusCode::OK)
                .header("Content-Type", "application/octet-stream")
                .header("Content-Disposition", "attachment; filename=\"module.wasm\"")
                .header("Content-Length", binary.len().to_string())
                .body(Body::from(binary))
                .unwrap())
        }
        Err(e) => {
            error!("WASM dump failed: {}", e);
            Ok(Response::builder()
                .status(StatusCode::INTERNAL_SERVER_ERROR)
                .header("Content-Type", "application/json")
                .body(Body::from(format!(r#"{{"success":false,"error":"{}"}}"#, e)))
                .unwrap())
        }
    }
}

/// Get WASM module info
pub async fn wasm_info_handler() -> Result<impl warp::Reply, warp::Rejection> {
    if !wasm_bridge::is_wasm_mode() {
        let response = json!({
            "success": false,
            "error": "Not in WASM mode"
        });
        return Ok(warp::reply::json(&response));
    }
    
    let code_size = wasm_bridge::get_wasm_code_size();
    let module_info = wasm_bridge::get_wasm_module_info();
    
    let response = json!({
        "success": true,
        "module_info": module_info,
        "code_size": code_size,
        "has_binary": code_size > 0
    });
    
    Ok(warp::reply::json(&response))
}

/// YARA memory scan handler
/// Scans process memory using YARA rules with progress tracking
#[cfg(not(target_os = "ios"))]
pub async fn yara_scan_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
    scan_request: request::YaraScanRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    let pid = pid_state.lock().unwrap();

    let mut is_suspend_success: bool = false;
    let do_suspend = scan_request.do_suspend;
    
    if let Some(pid) = *pid {
        if do_suspend {
            unsafe {
                is_suspend_success = native_bridge::suspend_process(pid);
            }
        }

        // Compile YARA rules first to validate
        let mut compiler = yara_x::Compiler::new();
        if let Err(e) = compiler.add_source(scan_request.rule.as_str()) {
            if do_suspend && is_suspend_success {
                unsafe {
                    native_bridge::resume_process(pid);
                }
            }
            let response = request::YaraScanResponse {
                success: false,
                message: format!("YARA compilation error: {}", e),
                scan_id: scan_request.scan_id.clone(),
                matches: vec![],
                total_matches: 0,
                scanned_bytes: 0,
            };
            return Ok(warp::reply::json(&response));
        }

        // Initialize progress tracking
        let total_bytes: u64 = scan_request.address_ranges.iter()
            .map(|(start, end)| (end - start) as u64)
            .sum();
        
        {
            let mut global_scan_progress = GLOBAL_SCAN_PROGRESS.write().unwrap();
            global_scan_progress.insert(scan_request.scan_id.clone(), request::ScanProgressResponse {
                scan_id: scan_request.scan_id.clone(),
                progress_percentage: 0.0,
                scanned_bytes: 0,
                total_bytes,
                is_scanning: true,
                current_region: Some("YARA scan".to_string()),
            });
        }

        // Clear previous results
        {
            let mut global_positions = GLOBAL_POSITIONS.write().unwrap();
            global_positions.insert(scan_request.scan_id.clone(), Vec::new());
            let mut global_memory = GLOBAL_MEMORY.write().unwrap();
            global_memory.insert(scan_request.scan_id.clone(), Vec::new());
        }

        // Create stop flag
        let stop_flag = Arc::new(Mutex::new(false));
        {
            let mut scan_stop_flags = SCAN_STOP_FLAGS.write().unwrap();
            scan_stop_flags.insert(scan_request.scan_id.clone(), stop_flag.clone());
        }

        let scan_id = scan_request.scan_id.clone();
        let address_ranges = scan_request.address_ranges.clone();
        let rule_source = scan_request.rule.clone();
        let align = scan_request.align;

        // Start background scan thread
        std::thread::spawn(move || {
            // Recompile rules in this thread
            let mut compiler = yara_x::Compiler::new();
            if compiler.add_source(rule_source.as_str()).is_err() {
                return;
            }
            let rules = compiler.build();
            let mut scanner = yara_x::Scanner::new(&rules);
            
            // Use the same types as GLOBAL_POSITIONS and GLOBAL_MEMORY
            let mut all_positions: Vec<(usize, String)> = Vec::new();
            let mut all_memory: Vec<(usize, Vec<u8>, usize, Vec<u8>, usize, bool)> = Vec::new();
            let mut scanned_bytes: u64 = 0;

            // Scan each memory region
            for (start_address, end_address) in &address_ranges {
                // Check stop flag
                if *stop_flag.lock().unwrap() {
                    break;
                }

                let size = end_address - start_address;
                if size == 0 {
                    continue;
                }

                // Read memory in chunks
                let chunk_size: usize = 16 * 1024 * 1024; // 16MB chunks
                let mut offset: usize = 0;

                while offset < size {
                    // Check stop flag
                    if *stop_flag.lock().unwrap() {
                        break;
                    }

                    let current_chunk_size = std::cmp::min(chunk_size, size - offset);
                    let current_address = start_address + offset;
                    
                    let mut buffer = vec![0u8; current_chunk_size];
                    let bytes_read = match native_bridge::read_process_memory(
                        pid,
                        current_address as *mut c_void,
                        current_chunk_size,
                        &mut buffer,
                    ) {
                        Ok(n) => n as usize,
                        Err(_) => 0,
                    };

                    if bytes_read > 0 {
                        buffer.truncate(bytes_read);
                        scanned_bytes += bytes_read as u64;

                        // Update progress
                        {
                            if let Ok(mut progress) = GLOBAL_SCAN_PROGRESS.write() {
                                if let Some(p) = progress.get_mut(&scan_id) {
                                    p.scanned_bytes = scanned_bytes;
                                    p.progress_percentage = (scanned_bytes as f64 / total_bytes as f64) * 100.0;
                                }
                            }
                        }

                        // Scan buffer with YARA
                        if let Ok(results) = scanner.scan(&buffer) {
                            for matched_rule in results.matching_rules() {
                                for pattern in matched_rule.patterns() {
                                    for m in pattern.matches() {
                                        let match_offset = m.range().start;
                                        let match_len = m.range().len();
                                        let match_address = current_address + match_offset;
                                        
                                        // Apply alignment filter
                                        if align > 1 && match_address % align != 0 {
                                            continue;
                                        }
                                        
                                        // Get matched data (exact match length)
                                        if match_offset + match_len <= buffer.len() {
                                            // Create hex string with rule info
                                            let matched_data = &buffer[match_offset..match_offset + match_len];
                                            let rule_info = format!("{}::{}", matched_rule.identifier(), pattern.identifier());
                                            let hex_value = format!("{}|{}", rule_info, hex::encode(matched_data));
                                            
                                            all_positions.push((match_address, hex_value.clone()));
                                            
                                            // For GLOBAL_MEMORY: (address, current_bytes, size, original_bytes, value_size, is_freeze)
                                            all_memory.push((
                                                match_address,
                                                matched_data.to_vec(),
                                                match_len,
                                                matched_data.to_vec(),
                                                match_len,
                                                false,
                                            ));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    offset += current_chunk_size;
                }
            }

            // Resume process if suspended
            if do_suspend && is_suspend_success {
                unsafe {
                    native_bridge::resume_process(pid);
                }
            }

            // Store results
            {
                let mut global_positions = GLOBAL_POSITIONS.write().unwrap();
                global_positions.insert(scan_id.clone(), all_positions);
                let mut global_memory = GLOBAL_MEMORY.write().unwrap();
                global_memory.insert(scan_id.clone(), all_memory);
            }

            // Mark scan as complete
            {
                if let Ok(mut progress) = GLOBAL_SCAN_PROGRESS.write() {
                    if let Some(p) = progress.get_mut(&scan_id) {
                        p.scanned_bytes = scanned_bytes;
                        p.progress_percentage = 100.0;
                        p.is_scanning = false;
                    }
                }
            }
        });

        // Return immediately with scan started response
        let response = request::YaraScanResponse {
            success: true,
            message: "YARA scan started".to_string(),
            scan_id: scan_request.scan_id,
            matches: vec![],
            total_matches: 0,
            scanned_bytes: 0,
        };

        Ok(warp::reply::json(&response))
    } else {
        let response = request::YaraScanResponse {
            success: false,
            message: "No process attached".to_string(),
            scan_id: scan_request.scan_id,
            matches: vec![],
            total_matches: 0,
            scanned_bytes: 0,
        };
        Ok(warp::reply::json(&response))
    }
}

/// YARA memory scan handler stub for iOS (not supported)
#[cfg(target_os = "ios")]
pub async fn yara_scan_handler(
    _pid_state: Arc<Mutex<Option<i32>>>,
    scan_request: request::YaraScanRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    let response = request::YaraScanResponse {
        success: false,
        message: "YARA scanning is not supported on this platform".to_string(),
        scan_id: scan_request.scan_id,
        matches: vec![],
        total_matches: 0,
        scanned_bytes: 0,
    };
    Ok(warp::reply::json(&response))
}

/// Handler for generating full pointermap (entire process memory)
pub async fn generate_pointermap_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    if let Some(pid) = *pid_state.lock().unwrap() {
        match ptrscan::generate_pointermap(pid) {
            Ok(data) => {
                // Return as binary data with proper content type
                Ok(Response::builder()
                    .status(StatusCode::OK)
                    .header("Content-Type", "application/octet-stream")
                    .header("Content-Disposition", "attachment; filename=\"pointermap.dptr\"")
                    .body(Body::from(data))
                    .unwrap())
            }
            Err(e) => {
                let response = serde_json::json!({
                    "success": false,
                    "message": format!("Failed to generate pointermap: {}", e)
                });
                Ok(Response::builder()
                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                    .header("Content-Type", "application/json")
                    .body(Body::from(serde_json::to_string(&response).unwrap()))
                    .unwrap())
            }
        }
    } else {
        let response = serde_json::json!({
            "success": false,
            "message": "No process attached"
        });
        Ok(Response::builder()
            .status(StatusCode::BAD_REQUEST)
            .header("Content-Type", "application/json")
            .body(Body::from(serde_json::to_string(&response).unwrap()))
            .unwrap())
    }
}
/// Handler for starting pointermap generation with progress tracking
pub async fn start_pointermap_handler(
    pid_state: Arc<Mutex<Option<i32>>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let pid = match *pid_state.lock().unwrap() {
        Some(pid) => pid,
        None => {
            let response = request::PointerMapStartResponse {
                success: false,
                task_id: String::new(),
                message: "No process attached".to_string(),
            };
            return Ok(warp::reply::json(&response));
        }
    };

    // Generate a unique task ID
    let task_id = format!("ptrmap_{}", chrono::Utc::now().timestamp_millis());
    let task_id_clone = task_id.clone();

    // Initialize progress
    {
        let mut progress_map = GLOBAL_POINTERMAP_PROGRESS.write().unwrap();
        progress_map.insert(task_id.clone(), request::PointerMapProgressResponse {
            task_id: task_id.clone(),
            progress_percentage: 0.0,
            current_phase: "Starting".to_string(),
            processed_regions: 0,
            total_regions: 0,
            processed_bytes: 0,
            total_bytes: 0,
            is_generating: true,
            is_complete: false,
            error: None,
        });
    }

    // Start background thread for generation
    let task_id_thread = task_id.clone();
    std::thread::spawn(move || {
        let progress_callback = {
            let task_id = task_id_thread.clone();
            std::sync::Arc::new(move |phase: &str, regions_done: u64, total_regions: u64, bytes_done: u64, total_bytes: u64| {
                if let Ok(mut progress_map) = GLOBAL_POINTERMAP_PROGRESS.write() {
                    if let Some(progress) = progress_map.get_mut(&task_id) {
                        progress.current_phase = phase.to_string();
                        progress.processed_regions = regions_done;
                        progress.total_regions = total_regions;
                        progress.processed_bytes = bytes_done;
                        progress.total_bytes = total_bytes;
                        if total_bytes > 0 {
                            progress.progress_percentage = (bytes_done as f64 / total_bytes as f64) * 100.0;
                        }
                    }
                }
            })
        };

        match ptrscan::generate_pointermap_with_progress(pid, Some(progress_callback)) {
            Ok(data) => {
                // Store the generated data
                {
                    let mut data_map = GLOBAL_POINTERMAP_DATA.write().unwrap();
                    data_map.insert(task_id_thread.clone(), data);
                }
                // Mark as complete
                if let Ok(mut progress_map) = GLOBAL_POINTERMAP_PROGRESS.write() {
                    if let Some(progress) = progress_map.get_mut(&task_id_thread) {
                        progress.is_generating = false;
                        progress.is_complete = true;
                        progress.progress_percentage = 100.0;
                        progress.current_phase = "Complete".to_string();
                    }
                }
            }
            Err(e) => {
                // Mark as error
                if let Ok(mut progress_map) = GLOBAL_POINTERMAP_PROGRESS.write() {
                    if let Some(progress) = progress_map.get_mut(&task_id_thread) {
                        progress.is_generating = false;
                        progress.is_complete = false;
                        progress.error = Some(e);
                    }
                }
            }
        }
    });

    let response = request::PointerMapStartResponse {
        success: true,
        task_id: task_id_clone,
        message: "PointerMap generation started".to_string(),
    };
    Ok(warp::reply::json(&response))
}

/// Handler for getting pointermap generation progress
pub async fn pointermap_progress_handler(
    progress_request: request::PointerMapProgressRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    let progress_map = GLOBAL_POINTERMAP_PROGRESS.read().unwrap();
    if let Some(progress) = progress_map.get(&progress_request.task_id) {
        Ok(warp::reply::json(progress))
    } else {
        let response = request::PointerMapProgressResponse {
            task_id: progress_request.task_id,
            progress_percentage: 0.0,
            current_phase: "Unknown".to_string(),
            processed_regions: 0,
            total_regions: 0,
            processed_bytes: 0,
            total_bytes: 0,
            is_generating: false,
            is_complete: false,
            error: Some("Task not found".to_string()),
        };
        Ok(warp::reply::json(&response))
    }
}

/// Handler for downloading completed pointermap data
pub async fn pointermap_download_handler(
    progress_request: request::PointerMapProgressRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Check if complete
    let is_complete = {
        let progress_map = GLOBAL_POINTERMAP_PROGRESS.read().unwrap();
        progress_map.get(&progress_request.task_id)
            .map(|p| p.is_complete)
            .unwrap_or(false)
    };

    if !is_complete {
        let response = serde_json::json!({
            "success": false,
            "message": "PointerMap generation not complete"
        });
        return Ok(Response::builder()
            .status(StatusCode::BAD_REQUEST)
            .header("Content-Type", "application/json")
            .body(Body::from(serde_json::to_string(&response).unwrap()))
            .unwrap());
    }

    // Get and remove data
    let data = {
        let mut data_map = GLOBAL_POINTERMAP_DATA.write().unwrap();
        data_map.remove(&progress_request.task_id)
    };

    // Clean up progress
    {
        let mut progress_map = GLOBAL_POINTERMAP_PROGRESS.write().unwrap();
        progress_map.remove(&progress_request.task_id);
    }

    match data {
        Some(data) => {
            Ok(Response::builder()
                .status(StatusCode::OK)
                .header("Content-Type", "application/octet-stream")
                .header("Content-Disposition", "attachment; filename=\"pointermap.dptr\"")
                .body(Body::from(data))
                .unwrap())
        }
        None => {
            let response = serde_json::json!({
                "success": false,
                "message": "PointerMap data not found"
            });
            Ok(Response::builder()
                .status(StatusCode::NOT_FOUND)
                .header("Content-Type", "application/json")
                .body(Body::from(serde_json::to_string(&response).unwrap()))
                .unwrap())
        }
    }
}
```

`src/server/src/cpp/src/common/arm64_decoder.cpp`:

```cpp
#include "arm64_decoder.h"

// ARM64 instruction encoding helpers
#define EXTRACT_BITS(val, start, len) (((val) >> (start)) & ((1ULL << (len)) - 1))
#define SIGN_EXTEND(val, bits) ((int64_t)((val) << (64 - (bits))) >> (64 - (bits)))

// Get register value (handling SP specially for register 31)
static inline uint64_t get_reg_or_sp(const uint64_t* registers, uint64_t sp, uint32_t reg_num)
{
    if (reg_num == 31)
    {
        return sp;  // Register 31 is SP in addressing context
    }
    return registers[reg_num];
}

// Get register value (ZR for register 31)
static inline uint64_t get_reg_or_zr(const uint64_t* registers, uint32_t reg_num)
{
    if (reg_num == 31)
    {
        return 0;  // Register 31 is ZR in data context
    }
    return registers[reg_num];
}

Arm64MemoryAccess decode_arm64_memory_access(uint32_t instruction, const uint64_t* registers,
                                             uint64_t sp, uint64_t pc)
{
    Arm64MemoryAccess result = {0};
    result.is_valid = 0;

    // Extract top-level opcode bits
    uint32_t op0 = EXTRACT_BITS(instruction, 25, 4);  // bits [28:25]
    uint32_t op1 = EXTRACT_BITS(instruction, 23, 2);  // bits [24:23]

    // Load/Store encoding: op0 = x1x0 (bits 28:25)
    // This covers most load/store instructions
    if ((op0 & 0b0101) != 0b0100)
    {
        return result;  // Not a load/store instruction
    }

    // Extract common fields
    uint32_t size = EXTRACT_BITS(instruction, 30, 2);  // bits [31:30]
    uint32_t v = EXTRACT_BITS(instruction, 26, 1);     // bit 26 (SIMD/FP)
    uint32_t opc = EXTRACT_BITS(instruction, 22, 2);   // bits [23:22]
    uint32_t rn = EXTRACT_BITS(instruction, 5, 5);     // bits [9:5] base register
    uint32_t rt = EXTRACT_BITS(instruction, 0, 5);     // bits [4:0] target register

    uint64_t base_addr = get_reg_or_sp(registers, sp, rn);
    uint64_t effective_addr = 0;
    uint32_t access_size = 0;
    uint8_t is_write = 0;

    // Determine instruction class from bits [29:28] and [24]
    uint32_t op2 = EXTRACT_BITS(instruction, 28, 2);  // bits [29:28]
    uint32_t op3 = EXTRACT_BITS(instruction, 24, 1);  // bit 24

    // Load/Store Register (all variants) - op0 = 1x00, bit 24 determines indexing type
    if ((op0 & 0b1011) == 0b1000)
    {
        // Determine access size based on size field and V bit
        if (v == 0)
        {
            // General purpose register
            switch (size)
            {
                case 0:
                    access_size = 1;
                    break;  // B (byte)
                case 1:
                    access_size = 2;
                    break;  // H (halfword)
                case 2:
                    access_size = 4;
                    break;  // W (word)
                case 3:
                    access_size = 8;
                    break;  // X (doubleword)
            }
            // opc[0] determines load/store for most cases
            is_write = (opc & 1) == 0;
        }
        else
        {
            // SIMD/FP register
            switch (size)
            {
                case 0:
                    access_size = (opc == 0) ? 1 : ((opc == 2) ? 16 : 1);
                    break;  // B or Q
                case 1:
                    access_size = 2;
                    break;  // H
                case 2:
                    access_size = 4;
                    break;  // S
                case 3:
                    access_size = 8;
                    break;  // D
            }
            is_write = (opc & 1) == 0;
        }

        // Check specific encoding patterns
        uint32_t op4 = EXTRACT_BITS(instruction, 10, 2);  // bits [11:10]

        if (op3 == 1)
        {
            // Unsigned offset: LDR/STR (immediate, unsigned offset)
            // Format: [Xn, #imm12]
            uint32_t imm12 = EXTRACT_BITS(instruction, 10, 12);
            uint32_t scale = (v == 0) ? size : ((size == 0 && opc == 2) ? 4 : size);
            effective_addr = base_addr + (imm12 << scale);
            result.is_valid = 1;
        }
        else if (op4 == 0b01)
        {
            // Post-index: [Xn], #imm9
            int64_t imm9 = SIGN_EXTEND(EXTRACT_BITS(instruction, 12, 9), 9);
            effective_addr = base_addr;  // Post-index uses original base
            result.is_valid = 1;
        }
        else if (op4 == 0b11)
        {
            // Pre-index: [Xn, #imm9]!
            int64_t imm9 = SIGN_EXTEND(EXTRACT_BITS(instruction, 12, 9), 9);
            effective_addr = base_addr + imm9;
            result.is_valid = 1;
        }
        else if (op4 == 0b00)
        {
            // Unscaled: LDUR/STUR
            int64_t imm9 = SIGN_EXTEND(EXTRACT_BITS(instruction, 12, 9), 9);
            effective_addr = base_addr + imm9;
            result.is_valid = 1;
        }
        else if (op4 == 0b10)
        {
            // Register offset: [Xn, Rm{, extend {#amount}}]
            uint32_t rm = EXTRACT_BITS(instruction, 16, 5);
            uint32_t option = EXTRACT_BITS(instruction, 13, 3);
            uint32_t s = EXTRACT_BITS(instruction, 12, 1);

            uint64_t offset = get_reg_or_zr(registers, rm);

            // Apply extension
            switch (option)
            {
                case 0b010:  // UXTW
                    offset = (uint32_t)offset;
                    break;
                case 0b011:  // LSL (default)
                    break;
                case 0b110:  // SXTW
                    offset = (int64_t)(int32_t)offset;
                    break;
                case 0b111:  // SXTX
                    break;
            }

            // Apply shift
            if (s)
            {
                uint32_t scale = (v == 0) ? size : ((size == 0 && opc == 2) ? 4 : size);
                offset <<= scale;
            }

            effective_addr = base_addr + offset;
            result.is_valid = 1;
        }
    }

    // Load/Store Pair - op0 = 0x10
    if ((op0 & 0b1011) == 0b0010)
    {
        uint32_t rt2 = EXTRACT_BITS(instruction, 10, 5);  // Second target register
        int64_t imm7 = SIGN_EXTEND(EXTRACT_BITS(instruction, 15, 7), 7);

        // Determine size based on opc and V
        if (v == 0)
        {
            // General purpose: STP/LDP
            access_size = (opc & 2) ? 8 : 4;  // X or W
        }
        else
        {
            // SIMD/FP: STP/LDP for S/D/Q
            switch (opc)
            {
                case 0:
                    access_size = 4;
                    break;  // S
                case 1:
                    access_size = 8;
                    break;  // D
                case 2:
                    access_size = 16;
                    break;  // Q
            }
        }

        uint32_t scale = (v == 0) ? ((opc & 2) ? 3 : 2) : (2 + opc);
        int64_t offset = imm7 << scale;

        // Determine addressing mode from bits [24:23]
        uint32_t l = EXTRACT_BITS(instruction, 22, 1);  // Load/Store bit
        is_write = (l == 0);

        switch (op1)
        {
            case 0b01:  // Post-index
                effective_addr = base_addr;
                break;
            case 0b10:  // Signed offset (no writeback)
                effective_addr = base_addr + offset;
                break;
            case 0b11:  // Pre-index
                effective_addr = base_addr + offset;
                break;
            default:
                return result;  // Non-temporal pairs (0b00) not commonly used
        }

        result.is_valid = 1;
        result.is_pair = 1;
        result.address2 = effective_addr + access_size;
    }

    // Load/Store Exclusive - op0 = 0x00, bits [23:21] determine variant
    if (op0 == 0b0000 || op0 == 0b0100)
    {
        uint32_t o2 = EXTRACT_BITS(instruction, 23, 1);
        uint32_t l = EXTRACT_BITS(instruction, 22, 1);
        uint32_t o1 = EXTRACT_BITS(instruction, 21, 1);
        uint32_t o0 = EXTRACT_BITS(instruction, 15, 1);

        if (o2 == 0)
        {
            // Exclusive load/store
            access_size = 1 << size;
            is_write = (l == 0);
            effective_addr = base_addr;
            result.is_valid = 1;

            // LDXP/STXP (pair)
            if (o1 == 1)
            {
                result.is_pair = 1;
                result.address2 = effective_addr + access_size;
            }
        }
    }

    if (result.is_valid)
    {
        result.address = effective_addr;
        result.size = access_size;
        result.is_write = is_write;
    }

    return result;
}

```

`src/server/src/cpp/src/common/arm64_decoder.h`:

```h
#ifndef ARM64_DECODER_H
#define ARM64_DECODER_H

#include <stdbool.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C"
{
#endif

    // Memory access information extracted from ARM64 instruction
    typedef struct
    {
        uint64_t address;   // Computed effective address
        uint32_t size;      // Size of access in bytes
        uint8_t is_write;   // 1 if store, 0 if load
        uint8_t is_pair;    // 1 if pair load/store (STP/LDP)
        uint8_t is_valid;   // 1 if this is a valid memory access instruction
        uint8_t reserved;   // Padding
        uint64_t address2;  // Second address for pair operations
    } Arm64MemoryAccess;

    /**
     * Decode ARM64 instruction and compute memory access address
     *
     * @param instruction   The 32-bit ARM64 instruction
     * @param registers     Array of 31 registers (x0-x30, where x30 is LR)
     * @param sp            Stack pointer value
     * @param pc            Program counter value
     * @return              Memory access information
     */
    Arm64MemoryAccess decode_arm64_memory_access(uint32_t instruction, const uint64_t* registers,
                                                 uint64_t sp, uint64_t pc);

#ifdef __cplusplus
}
#endif

#endif  // ARM64_DECODER_H

```

`src/server/src/cpp/src/common/dll_export.h`:

```h
#ifndef DLL_EXPORT_H
#define DLL_EXPORT_H

// DLL export/import macros for Windows
#ifdef _WIN32
#ifdef NATIVE_DLL_EXPORT
#define NATIVE_API __declspec(dllexport)
#elif defined(NATIVE_DLL_IMPORT)
#define NATIVE_API __declspec(dllimport)
#else
#define NATIVE_API  // Static linking
#endif
#else
#define NATIVE_API
#endif

#endif  // DLL_EXPORT_H

```

`src/server/src/cpp/src/common/exception_info.h`:

```h
#ifndef EXCEPTION_INFO_H
#define EXCEPTION_INFO_H

#include <stdint.h>

#ifdef __cplusplus
extern "C"
{
#endif

    // Architecture-independent exception info structure
    // Contains a union of architecture-specific register sets
    typedef struct
    {
        // Architecture type: 0 = unknown, 1 = ARM64, 2 = x86_64
        uint64_t architecture;

        // ARM64 registers (used when architecture == 1)
        union
        {
            struct
            {
                uint64_t x[30];  // x0-x29
                uint64_t lr;     // x30
                uint64_t sp;
                uint64_t pc;
                uint64_t cpsr;
                uint64_t fp;  // x29 (duplicate but kept for clarity)
            } arm64;

            struct
            {
                uint64_t rax;
                uint64_t rbx;
                uint64_t rcx;
                uint64_t rdx;
                uint64_t rsi;
                uint64_t rdi;
                uint64_t rbp;
                uint64_t rsp;
                uint64_t r8;
                uint64_t r9;
                uint64_t r10;
                uint64_t r11;
                uint64_t r12;
                uint64_t r13;
                uint64_t r14;
                uint64_t r15;
                uint64_t rip;
                uint64_t rflags;
                uint64_t cs;
                uint64_t ss;
                uint64_t ds;
                uint64_t es;
                uint64_t fs;
                uint64_t gs;
                uint64_t fs_base;
                uint64_t gs_base;
            } x86_64;
        } regs;

        uint64_t exception_type;
        uint64_t thread_id;
        uint64_t memory_address;  // FAR for ARM64, fault address for x86_64
        uint64_t singlestep_mode;
        uint64_t is_trace;  // 1 if this is a trace exception (hit_count > 0)
    } NativeExceptionInfo;

// Architecture constants
#define ARCH_UNKNOWN 0
#define ARCH_ARM64 1
#define ARCH_X86_64 2

#ifdef __cplusplus
}
#endif

#endif  // EXCEPTION_INFO_H

```

`src/server/src/cpp/src/common/trace_file.cpp`:

```cpp
#include "trace_file.h"

#include <chrono>
#include <cstring>

// TraceFileWriter implementation

TraceFileWriter::TraceFileWriter() : entry_count_(0), architecture_(TRACE_ARCH_ARM64) {}

TraceFileWriter::~TraceFileWriter()
{
    if (file_.is_open())
    {
        close();
    }
}

bool TraceFileWriter::open(const std::string& filepath, uint32_t architecture)
{
    std::lock_guard<std::mutex> lock(write_mutex_);

    if (file_.is_open())
    {
        file_.close();
    }

    filepath_ = filepath;
    architecture_ = architecture;
    entry_count_ = 0;

    file_.open(filepath, std::ios::binary | std::ios::out | std::ios::trunc);
    if (!file_.is_open())
    {
        return false;
    }

    // Write initial header with entry_count = 0
    TraceFileHeader header;
    memset(&header, 0, sizeof(header));
    memcpy(header.magic, TRACE_FILE_MAGIC, 8);
    header.version = TRACE_FILE_VERSION;
    header.entry_count = 0;
    header.architecture = architecture;

    file_.write(reinterpret_cast<const char*>(&header), sizeof(header));
    file_.flush();

    return file_.good();
}

bool TraceFileWriter::write_entry(const TraceEntryArm64& entry)
{
    std::lock_guard<std::mutex> lock(write_mutex_);

    if (!file_.is_open())
    {
        return false;
    }

    file_.write(reinterpret_cast<const char*>(&entry), sizeof(entry));
    if (!file_.good())
    {
        return false;
    }

    entry_count_++;
    return true;
}

bool TraceFileWriter::close()
{
    std::lock_guard<std::mutex> lock(write_mutex_);

    if (!file_.is_open())
    {
        return false;
    }

    // Seek back to header and update entry count
    file_.seekp(0, std::ios::beg);

    TraceFileHeader header;
    memset(&header, 0, sizeof(header));
    memcpy(header.magic, TRACE_FILE_MAGIC, 8);
    header.version = TRACE_FILE_VERSION;
    header.entry_count = entry_count_;
    header.architecture = architecture_;

    file_.write(reinterpret_cast<const char*>(&header), sizeof(header));
    file_.close();

    return true;
}

// TraceFileReader implementation

TraceFileReader::TraceFileReader()
{
    memset(&header_, 0, sizeof(header_));
}

TraceFileReader::~TraceFileReader()
{
    close();
}

bool TraceFileReader::open(const std::string& filepath)
{
    close();

    file_.open(filepath, std::ios::binary | std::ios::in);
    if (!file_.is_open())
    {
        return false;
    }

    // Read and validate header
    if (!read_header(header_))
    {
        file_.close();
        return false;
    }

    // Validate magic
    if (memcmp(header_.magic, TRACE_FILE_MAGIC, 8) != 0)
    {
        file_.close();
        return false;
    }

    // Validate version
    if (header_.version != TRACE_FILE_VERSION)
    {
        file_.close();
        return false;
    }

    return true;
}

bool TraceFileReader::read_header(TraceFileHeader& header)
{
    if (!file_.is_open())
    {
        return false;
    }

    file_.seekg(0, std::ios::beg);
    file_.read(reinterpret_cast<char*>(&header), sizeof(header));

    return file_.good();
}

bool TraceFileReader::read_entry(uint32_t index, TraceEntryArm64& entry)
{
    if (!file_.is_open() || index >= header_.entry_count)
    {
        return false;
    }

    // Calculate entry offset (header + index * entry_size)
    std::streamoff offset =
        sizeof(TraceFileHeader) + static_cast<std::streamoff>(index) * TRACE_ENTRY_SIZE;
    file_.seekg(offset, std::ios::beg);
    file_.read(reinterpret_cast<char*>(&entry), sizeof(entry));

    return file_.good();
}

void TraceFileReader::close()
{
    if (file_.is_open())
    {
        file_.close();
    }
    memset(&header_, 0, sizeof(header_));
}

// MemoryDumpWriter implementation

MemoryDumpWriter::MemoryDumpWriter() : region_count_(0), total_size_(0) {}

MemoryDumpWriter::~MemoryDumpWriter()
{
    if (file_.is_open())
    {
        close();
    }
}

bool MemoryDumpWriter::open(const std::string& filepath)
{
    std::lock_guard<std::mutex> lock(write_mutex_);

    if (file_.is_open())
    {
        file_.close();
    }

    filepath_ = filepath;
    region_count_ = 0;
    total_size_ = 0;

    file_.open(filepath, std::ios::binary | std::ios::out | std::ios::trunc);
    if (!file_.is_open())
    {
        return false;
    }

    // Write initial header with region_count = 0
    MemoryDumpHeader header;
    memset(&header, 0, sizeof(header));
    memcpy(header.magic, MEMORY_DUMP_MAGIC, 8);
    header.version = 1;
    header.region_count = 0;
    header.total_size = 0;

    file_.write(reinterpret_cast<const char*>(&header), sizeof(header));
    file_.flush();

    return file_.good();
}

bool MemoryDumpWriter::write_region(uint64_t address, uint64_t size, uint32_t protection,
                                    const uint8_t* data)
{
    std::lock_guard<std::mutex> lock(write_mutex_);

    if (!file_.is_open() || !data)
    {
        return false;
    }

    // Write region header
    MemoryRegionHeader region_header;
    memset(&region_header, 0, sizeof(region_header));
    region_header.address = address;
    region_header.size = size;
    region_header.protection = protection;

    file_.write(reinterpret_cast<const char*>(&region_header), sizeof(region_header));
    if (!file_.good())
    {
        return false;
    }

    // Write region data
    file_.write(reinterpret_cast<const char*>(data), size);
    if (!file_.good())
    {
        return false;
    }

    region_count_++;
    total_size_ += size;
    return true;
}

bool MemoryDumpWriter::close()
{
    std::lock_guard<std::mutex> lock(write_mutex_);

    if (!file_.is_open())
    {
        return false;
    }

    // Seek back to header and update counts
    file_.seekp(0, std::ios::beg);

    MemoryDumpHeader header;
    memset(&header, 0, sizeof(header));
    memcpy(header.magic, MEMORY_DUMP_MAGIC, 8);
    header.version = 1;
    header.region_count = region_count_;
    header.total_size = total_size_;

    file_.write(reinterpret_cast<const char*>(&header), sizeof(header));
    file_.close();

    return true;
}

// MemoryAccessLogWriter implementation

MemoryAccessLogWriter::MemoryAccessLogWriter() : access_count_(0) {}

MemoryAccessLogWriter::~MemoryAccessLogWriter()
{
    if (file_.is_open())
    {
        close();
    }
}

bool MemoryAccessLogWriter::open(const std::string& filepath)
{
    std::lock_guard<std::mutex> lock(write_mutex_);

    if (file_.is_open())
    {
        file_.close();
    }

    filepath_ = filepath;
    access_count_ = 0;

    file_.open(filepath, std::ios::binary | std::ios::out | std::ios::trunc);
    if (!file_.is_open())
    {
        return false;
    }

    // Write initial header with access_count = 0
    MemoryAccessLogHeader header;
    memset(&header, 0, sizeof(header));
    memcpy(header.magic, MEMORY_ACCESS_LOG_MAGIC, 8);
    header.version = 1;
    header.access_count = 0;

    file_.write(reinterpret_cast<const char*>(&header), sizeof(header));
    file_.flush();

    return file_.good();
}

bool MemoryAccessLogWriter::write_access(uint32_t entry_index, uint64_t address, uint32_t size,
                                         bool is_write, const uint8_t* data)
{
    std::lock_guard<std::mutex> lock(write_mutex_);

    if (!file_.is_open() || !data || size == 0)
    {
        return false;
    }

    // Write access header
    MemoryAccessHeader access_header;
    memset(&access_header, 0, sizeof(access_header));
    access_header.entry_index = entry_index;
    access_header.address = address;
    access_header.size = size;
    access_header.is_write = is_write ? 1 : 0;

    file_.write(reinterpret_cast<const char*>(&access_header), sizeof(access_header));
    if (!file_.good())
    {
        return false;
    }

    // Write access data
    file_.write(reinterpret_cast<const char*>(data), size);
    if (!file_.good())
    {
        return false;
    }

    access_count_++;
    return true;
}

bool MemoryAccessLogWriter::close()
{
    std::lock_guard<std::mutex> lock(write_mutex_);

    if (!file_.is_open())
    {
        return false;
    }

    // Seek back to header and update access count
    file_.seekp(0, std::ios::beg);

    MemoryAccessLogHeader header;
    memset(&header, 0, sizeof(header));
    memcpy(header.magic, MEMORY_ACCESS_LOG_MAGIC, 8);
    header.version = 1;
    header.access_count = access_count_;

    file_.write(reinterpret_cast<const char*>(&header), sizeof(header));
    file_.close();

    return true;
}

```

`src/server/src/cpp/src/common/trace_file.h`:

```h
#ifndef TRACE_FILE_H
#define TRACE_FILE_H

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

#include <fstream>
#include <mutex>
#include <string>

#ifdef __cplusplus
extern "C"
{
#endif

// Magic number for trace file identification
#define TRACE_FILE_MAGIC "DYNATRC\0"
#define TRACE_FILE_VERSION 1
#define TRACE_ARCH_ARM64 1
#define TRACE_ARCH_X86_64 2

// Memory dump size for each register (x0-x5)
#define TRACE_MEMORY_DUMP_SIZE 256
#define TRACE_MEMORY_REG_COUNT 6

// Instruction buffer size (null-terminated)
#define TRACE_INSTRUCTION_SIZE 64

    // File header structure (32 bytes)
    typedef struct __attribute__((packed))
    {
        char magic[8];          // "DYNATRC\0"
        uint32_t version;       // File format version
        uint32_t entry_count;   // Number of trace entries
        uint32_t architecture;  // 1 = ARM64, 2 = x86_64
        uint32_t reserved[3];   // Reserved for future use
    } TraceFileHeader;

    // ARM64 trace entry structure (fixed size for efficient reading)
    // Total size: 1920 bytes (aligned)
    typedef struct __attribute__((packed))
    {
        uint64_t timestamp;                        // Microseconds since epoch (8 bytes)
        uint64_t pc;                               // Program counter (8 bytes)
        uint64_t x[30];                            // x0-x29 registers (240 bytes)
        uint64_t lr;                               // Link register (8 bytes)
        uint64_t sp;                               // Stack pointer (8 bytes)
        uint64_t cpsr;                             // CPSR flags (8 bytes)
        uint32_t instruction_length;               // Instruction string length (4 bytes)
        char instruction[TRACE_INSTRUCTION_SIZE];  // Instruction string (64 bytes)
        uint8_t memory[TRACE_MEMORY_REG_COUNT]
                      [TRACE_MEMORY_DUMP_SIZE];  // Memory at x0-x5 (1536 bytes)
        uint8_t padding[36];                     // Padding to 1920 bytes
    } TraceEntryArm64;

#define TRACE_ENTRY_SIZE 1920

    // Memory access entry for full memory cache feature
    // Records memory read/write operations during trace
    typedef struct __attribute__((packed))
    {
        uint32_t entry_index;  // Index of the trace entry this belongs to (4 bytes)
        uint64_t address;      // Memory address accessed (8 bytes)
        uint32_t size;         // Size of data in bytes (4 bytes)
        uint8_t is_write;      // 1 if write, 0 if read (1 byte)
        uint8_t reserved[3];   // Padding (3 bytes)
        // Followed by 'size' bytes of data
    } MemoryAccessHeader;

#define MEMORY_ACCESS_HEADER_SIZE 20

    // Memory region header for initial memory dump
    typedef struct __attribute__((packed))
    {
        uint64_t address;     // Region start address (8 bytes)
        uint64_t size;        // Region size in bytes (8 bytes)
        uint32_t protection;  // Memory protection flags (4 bytes)
        uint32_t reserved;    // Reserved (4 bytes)
        // Followed by 'size' bytes of memory data
    } MemoryRegionHeader;

#define MEMORY_REGION_HEADER_SIZE 24

    // Memory dump file header
    typedef struct __attribute__((packed))
    {
        char magic[8];          // "DYNAMEM\0"
        uint32_t version;       // File format version
        uint32_t region_count;  // Number of memory regions
        uint64_t total_size;    // Total memory size
        uint32_t reserved[2];   // Reserved for future use
    } MemoryDumpHeader;

#define MEMORY_DUMP_MAGIC "DYNAMEM\0"
#define MEMORY_DUMP_HEADER_SIZE 32

    // Memory access log file header
    typedef struct __attribute__((packed))
    {
        char magic[8];          // "DYNALOG\0"
        uint32_t version;       // File format version
        uint32_t access_count;  // Number of memory accesses
        uint32_t reserved[4];   // Reserved for future use
    } MemoryAccessLogHeader;

#define MEMORY_ACCESS_LOG_MAGIC "DYNALOG\0"
#define MEMORY_ACCESS_LOG_HEADER_SIZE 32

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus

// C++ Trace file writer class
class TraceFileWriter
{
public:
    TraceFileWriter();
    ~TraceFileWriter();

    // Open a new trace file for writing
    bool open(const std::string& filepath, uint32_t architecture);

    // Write a single trace entry
    bool write_entry(const TraceEntryArm64& entry);

    // Close the file and finalize header
    bool close();

    // Get the current file path
    const std::string& get_filepath() const
    {
        return filepath_;
    }

    // Get the number of entries written
    uint32_t get_entry_count() const
    {
        return entry_count_;
    }

    // Check if file is open
    bool is_open() const
    {
        return file_.is_open();
    }

private:
    std::ofstream file_;
    std::string filepath_;
    uint32_t entry_count_;
    uint32_t architecture_;
    std::mutex write_mutex_;
};

// C++ Trace file reader class
class TraceFileReader
{
public:
    TraceFileReader();
    ~TraceFileReader();

    // Open a trace file for reading
    bool open(const std::string& filepath);

    // Read the header
    bool read_header(TraceFileHeader& header);

    // Read a specific entry by index
    bool read_entry(uint32_t index, TraceEntryArm64& entry);

    // Get the number of entries
    uint32_t get_entry_count() const
    {
        return header_.entry_count;
    }

    // Get the architecture
    uint32_t get_architecture() const
    {
        return header_.architecture;
    }

    // Close the file
    void close();

    // Check if file is open
    bool is_open() const
    {
        return file_.is_open();
    }

private:
    std::ifstream file_;
    TraceFileHeader header_;
};

// C++ Memory dump writer class - writes initial memory snapshot
class MemoryDumpWriter
{
public:
    MemoryDumpWriter();
    ~MemoryDumpWriter();

    // Open a new memory dump file for writing
    bool open(const std::string& filepath);

    // Write a memory region
    bool write_region(uint64_t address, uint64_t size, uint32_t protection, const uint8_t* data);

    // Close the file and finalize header
    bool close();

    // Get the current file path
    const std::string& get_filepath() const
    {
        return filepath_;
    }

    // Get the number of regions written
    uint32_t get_region_count() const
    {
        return region_count_;
    }

    // Check if file is open
    bool is_open() const
    {
        return file_.is_open();
    }

private:
    std::ofstream file_;
    std::string filepath_;
    uint32_t region_count_;
    uint64_t total_size_;
    std::mutex write_mutex_;
};

// C++ Memory access log writer class - logs memory accesses during trace
class MemoryAccessLogWriter
{
public:
    MemoryAccessLogWriter();
    ~MemoryAccessLogWriter();

    // Open a new memory access log file for writing
    bool open(const std::string& filepath);

    // Write a memory access entry
    bool write_access(uint32_t entry_index, uint64_t address, uint32_t size, bool is_write,
                      const uint8_t* data);

    // Close the file and finalize header
    bool close();

    // Get the current file path
    const std::string& get_filepath() const
    {
        return filepath_;
    }

    // Get the number of accesses written
    uint32_t get_access_count() const
    {
        return access_count_;
    }

    // Check if file is open
    bool is_open() const
    {
        return file_.is_open();
    }

private:
    std::ofstream file_;
    std::string filepath_;
    uint32_t access_count_;
    std::mutex write_mutex_;
};

#endif  // __cplusplus

#endif  // TRACE_FILE_H

```

`src/server/src/cpp/src/common/util.cpp`:

```cpp
#include "util.h"

std::string map_vector_to_json_string(
    const std::vector<std::map<std::string, uint64_t>>& map_vector)
{
    std::ostringstream json;
    json << "{";

    bool first = true;
    for (size_t i = 0; i < map_vector.size(); ++i)
    {
        const auto& map = map_vector[i];
        for (const auto& [key, value] : map)
        {
            if (!first)
            {
                json << ",";
            }
            first = false;

            // Special handling for exception_type - convert to number instead of hex string
            if (key == "exception_type")
            {
                json << "\"" << key << "\":" << std::dec << value;
            }
            // Special handling for thread_id - convert to number instead of hex string
            else if (key == "thread_id")
            {
                json << "\"" << key << "\":" << std::dec << value;
            }
            // Special handling for memory - convert to number instead of hex string
            else if (key == "memory")
            {
                json << "\"" << key << "\":" << std::dec << value;
            }
            // All other values (registers) as hex strings
            else
            {
                json << "\"" << key << "\":\"0x" << std::hex << std::uppercase << std::setw(16)
                     << std::setfill('0') << value << "\"";
            }
        }
    }

    json << "}";
    return json.str();
}
```

`src/server/src/cpp/src/common/util.h`:

```h
#ifndef UTIL_H
#define UTIL_H

#include <cstdint>
#include <iomanip>
#include <map>
#include <sstream>
#include <string>
#include <vector>

std::string map_vector_to_json_string(
    const std::vector<std::map<std::string, uint64_t>>& map_vector);
#endif
```

`src/server/src/cpp/src/darwin/Makefile`:

```
# Makefile for building libdbgsrv_native.dylib standalone (Darwin/macOS)
# Usage:
#   make                    # Build for native macOS (arm64)
#   make ARCH=arm64         # Build for arm64
#   make ARCH=x86_64        # Build for x86_64
#   make clean              # Clean build artifacts

# Output
LIB_NAME = libdbgsrv_native.dylib
BUILD_DIR = build

# Detect architecture if not specified
ifndef ARCH
UNAME_M := $(shell uname -m)
ifeq ($(UNAME_M),x86_64)
ARCH = x86_64
else ifeq ($(UNAME_M),arm64)
ARCH = arm64
else
ARCH = $(UNAME_M)
endif
endif

# Compiler settings
CXX ?= clang++
CC ?= clang

# Common flags
COMMON_CXXFLAGS = -std=c++17 -fPIC -Wall -Wextra
COMMON_CFLAGS = -fPIC -Wall -Wextra
COMMON_LDFLAGS = -dynamiclib -fPIC

# Architecture-specific flags
ifeq ($(ARCH),arm64)
    ARCH_FLAGS = -arch arm64
else ifeq ($(ARCH),x86_64)
    ARCH_FLAGS = -arch x86_64
endif

# Platform-specific settings
PLATFORM_CXXFLAGS = -DDYNAMIC_LIB_BUILD
PLATFORM_LDFLAGS = -lpthread -ldl -framework Foundation -framework CoreServices

# Debug/Release
ifdef DEBUG
    OPT_FLAGS = -g -O0 -DDEBUG -DENABLE_LOG_DEVELOP -DVERBOSE_LOGGING
else
    OPT_FLAGS = -O2 -DNDEBUG
endif

# Final flags
CXXFLAGS = $(COMMON_CXXFLAGS) $(ARCH_FLAGS) $(PLATFORM_CXXFLAGS) $(OPT_FLAGS)
CFLAGS = $(COMMON_CFLAGS) $(ARCH_FLAGS) $(OPT_FLAGS)
LDFLAGS = $(COMMON_LDFLAGS) $(ARCH_FLAGS) $(PLATFORM_LDFLAGS)

# Include paths
INCLUDES = -I. -I../common -I..

# Source files
CORE_SOURCES = \
    core/native_api.mm \
    core/file_api.mm \
    core/memory_io.mm \
    core/process_api.mm

DEBUGGER_SOURCES = \
    debugger/debugger_core.mm \
    debugger/debugger_breakpoint.mm \
    debugger/debugger_watchpoint.mm \
    debugger/debugger_exception.mm \
    debugger/debugger_register.mm \
    debugger/debugger_trace.mm \
    debugger/debugger_native_api.mm

COMMON_SOURCES = \
    ../common/util.cpp \
    ../common/trace_file.cpp \
    ../common/arm64_decoder.cpp

ALL_SOURCES = $(CORE_SOURCES) $(DEBUGGER_SOURCES) $(COMMON_SOURCES)

# Object files (handle both .mm and .cpp)
OBJECTS = $(patsubst %.mm,$(BUILD_DIR)/%.o,$(patsubst %.cpp,$(BUILD_DIR)/%.o,$(ALL_SOURCES)))

# Default target
all: $(BUILD_DIR)/$(LIB_NAME)

# Create build directories
$(BUILD_DIR):
	mkdir -p $(BUILD_DIR)/core
	mkdir -p $(BUILD_DIR)/debugger
	mkdir -p $(BUILD_DIR)/../common

# Compile Objective-C++ sources (.mm)
$(BUILD_DIR)/%.o: %.mm | $(BUILD_DIR)
	@mkdir -p $(dir $@)
	$(CXX) $(CXXFLAGS) $(INCLUDES) -c $< -o $@

# Compile C++ sources (.cpp)
$(BUILD_DIR)/%.o: %.cpp | $(BUILD_DIR)
	@mkdir -p $(dir $@)
	$(CXX) $(CXXFLAGS) $(INCLUDES) -c $< -o $@

# Link shared library
$(BUILD_DIR)/$(LIB_NAME): $(OBJECTS)
	$(CXX) $(LDFLAGS) -o $@ $^
	@echo ""
	@echo "Built: $(BUILD_DIR)/$(LIB_NAME)"
	@echo "Architecture: $(ARCH)"
	@echo "Target: darwin"

# Clean
clean:
	rm -rf $(BUILD_DIR)

# Install (optional)
install: $(BUILD_DIR)/$(LIB_NAME)
	install -D -m 755 $(BUILD_DIR)/$(LIB_NAME) $(DESTDIR)/usr/local/lib/$(LIB_NAME)

# Print configuration
info:
	@echo "Configuration:"
	@echo "  ARCH:     $(ARCH)"
	@echo "  TARGET:   darwin"
	@echo "  CXX:      $(CXX)"
	@echo "  CXXFLAGS: $(CXXFLAGS)"
	@echo "  LDFLAGS:  $(LDFLAGS)"
	@echo ""
	@echo "Sources:"
	@for src in $(ALL_SOURCES); do echo "  $$src"; done

.PHONY: all clean install info

```

`src/server/src/cpp/src/darwin/core/callback_stubs.mm`:

```mm
/**
 * @file callback_stubs.mm
 * @brief Callback stubs for dynamic library mode (Darwin/macOS)
 *
 * These functions allow users to replace callback implementations
 * by setting function pointers after loading the library.
 *
 * In static linking mode, the host application provides native_log and
 * send_exception_info implementations directly.
 *
 * In dynamic library mode (DYNAMIC_LIB_BUILD), this file provides:
 * 1. Default fallback implementations
 * 2. Setter functions for users to inject custom callbacks
 */

#import <Foundation/Foundation.h>
#include <cstdio>

#include "../../common/dll_export.h"
#include "../../common/exception_info.h"
#include "native_api.h"

#ifdef DYNAMIC_LIB_BUILD

// =============================================================================
// Function pointer types
// =============================================================================

typedef void (*native_log_fn)(int level, const char* message);
typedef bool (*send_exception_info_fn)(const NativeExceptionInfo* info, pid_t pid);

// =============================================================================
// Global function pointers (can be set by user after library load)
// =============================================================================

static native_log_fn g_native_log = nullptr;
static send_exception_info_fn g_send_exception_info = nullptr;

// =============================================================================
// Callback setter/getter functions
// =============================================================================

extern "C" NATIVE_API void set_native_log_callback(native_log_fn fn)
{
    g_native_log = fn;
}

extern "C" NATIVE_API void set_send_exception_info_callback(send_exception_info_fn fn)
{
    g_send_exception_info = fn;
}

extern "C" NATIVE_API native_log_fn get_native_log_callback()
{
    return g_native_log;
}

extern "C" NATIVE_API send_exception_info_fn get_send_exception_info_callback()
{
    return g_send_exception_info;
}

// =============================================================================
// Callback implementations
// =============================================================================

/**
 * Implementation of native_log
 * If callback is set, calls user's function; otherwise prints to stderr
 */
extern "C" void native_log(int level, const char* message)
{
    if (g_native_log)
    {
        g_native_log(level, message);
    }
    else
    {
        // Fallback: print to stderr with level string
        const char* level_str = "UNKNOWN";
        switch (level)
        {
            case 1:
                level_str = "ERROR";
                break;
            case 2:
                level_str = "WARN";
                break;
            case 3:
                level_str = "INFO";
                break;
            case 4:
                level_str = "DEBUG";
                break;
            case 5:
                level_str = "TRACE";
                break;
        }
        fprintf(stderr, "[%s] %s\n", level_str, message);
    }
}

/**
 * Implementation of send_exception_info
 * If callback is set, calls user's function; otherwise prints summary to stderr
 * @return true = notify UI and break, false = silent continue
 */
extern "C" bool send_exception_info(const NativeExceptionInfo* info, pid_t pid)
{
    if (g_send_exception_info)
    {
        return g_send_exception_info(info, pid);
    }
    else
    {
        // Fallback: print basic info to stderr and return true to notify
        const char* exception_type_str = "UNKNOWN";
        switch (info->exception_type)
        {
            case EXCEPTION_BREAKPOINT:
                exception_type_str = "BREAKPOINT";
                break;
            case EXCEPTION_WATCHPOINT:
                exception_type_str = "WATCHPOINT";
                break;
            case EXCEPTION_SINGLESTEP:
                exception_type_str = "SINGLESTEP";
                break;
            case EXCEPTION_SIGNAL:
                exception_type_str = "SIGNAL";
                break;
            default:
                break;
        }
        
        fprintf(stderr, "[EXCEPTION] Type: %s, Thread: %llu, PID: %d\n",
                exception_type_str, info->thread_id, pid);
        
        if (info->architecture == ARCH_ARM64)
        {
            fprintf(stderr, "  PC: 0x%llx\n", info->regs.arm64.pc);
        }
        
        return true;  // Default: notify UI
    }
}

#endif  // DYNAMIC_LIB_BUILD

```

`src/server/src/cpp/src/darwin/core/file_api.h`:

```h
#ifndef FILEAPI_H
#define FILEAPI_H

#import <Foundation/Foundation.h>
#include "native_api.h"

#ifdef DYNAMIC_LIB_BUILD
#define DirectoryExplorer DirectoryExplorer_Dynamic
#define FileReader FileReader_Dynamic
#define ProcessInfoRetriever ProcessInfoRetriever_Dynamic
#define InstalledAppRetriever InstalledAppRetriever_Dynamic
#define AppIconRetriever AppIconRetriever_Dynamic
#endif

// =============================================================================
// File/Directory Operations
// =============================================================================

@interface DirectoryExplorer : NSObject

+ (NSString *)exploreDirectory:(NSString *)path maxDepth:(int)maxDepth error:(NSError **)error;

@end

@interface FileReader : NSObject

+ (NSData *)readFile:(NSString *)path error:(NSError **)error;

@end

// =============================================================================
// Application Information Retrieval
// =============================================================================

@interface ProcessInfoRetriever : NSObject

+ (NSDictionary *)getProcessInfo:(pid_t)pid;

@end

@interface InstalledAppRetriever : NSObject

+ (NSArray<NSDictionary *> *)getInstalledApps;
+ (NSDictionary *)getAppInfoFromPath:(NSString *)appPath;
+ (NSString *)getDataContainerForBundleIdentifier:(NSString *)bundleIdentifier;

@end

@interface AppIconRetriever : NSObject

+ (NSData *)getIconForApp:(NSString *)bundleIdentifier;
+ (NSData *)getIconFromAppPath:(NSString *)appPath;
+ (NSString *)findAppPathForBundleIdentifier:(NSString *)bundleIdentifier;

@end

// =============================================================================
// proc_pidpath declaration
// =============================================================================

#define PROC_PIDPATHINFO_MAXSIZE (4 * MAXPATHLEN)
#define PROC_ALL_PIDS 1
#define PROC_PIDTBSDINFO 3
#define PROC_PIDTASKINFO 4

// =============================================================================
// C API Exports - File/Directory Operations
// =============================================================================

extern "C" const char *explore_directory(const char *path, int maxDepth);
extern "C" const void *read_file(const char *path, size_t *size, char **error_message);

// =============================================================================
// C API Exports - Application Information
// =============================================================================

extern "C" const char *get_application_info_native(pid_t pid);
extern "C" const char *get_installed_apps_native(void);
extern "C" const void *get_app_icon_native(const char *bundle_identifier, size_t *size);

// =============================================================================
// Process Management APIs are in process_api.h
// =============================================================================

#endif
```

`src/server/src/cpp/src/darwin/core/file_api.mm`:

```mm
#import "file_api.h"
#import <mach/mach.h>
#import <sys/sysctl.h>

@implementation DirectoryExplorer

+ (NSString *)exploreDirectory:(NSString *)path maxDepth:(int)maxDepth error:(NSError **)error
{
    @try
    {
        NSFileManager *fileManager = [NSFileManager defaultManager];
        NSMutableString *result = [NSMutableString string];

        [self exploreDirectoryRecursive:path
                                  depth:0
                               maxDepth:maxDepth
                            fileManager:fileManager
                                 result:result
                                 indent:@""];

        return result;
    }
    @catch (NSException *exception)
    {
        if (error)
        {
            *error = [NSError
                errorWithDomain:@"DirectoryExplorerErrorDomain"
                           code:500
                       userInfo:@{
                           NSLocalizedDescriptionKey : [NSString
                               stringWithFormat:@"Exception occurred: %@", exception.reason]
                       }];
        }
        return nil;
    }
}

+ (void)exploreDirectoryRecursive:(NSString *)path
                            depth:(int)depth
                         maxDepth:(int)maxDepth
                      fileManager:(NSFileManager *)fileManager
                           result:(NSMutableString *)result
                           indent:(NSString *)indent
{
    if (depth > maxDepth) return;

    NSError *localError = nil;
    NSArray *contents = [fileManager contentsOfDirectoryAtPath:path error:&localError];

    if (localError)
    {
        [result appendFormat:@"%@error:%@\n", indent, localError.localizedDescription];
        return;
    }

    for (NSString *item in contents)
    {
        NSString *fullPath = [path stringByAppendingPathComponent:item];
        BOOL isDirectory;
        [fileManager fileExistsAtPath:fullPath isDirectory:&isDirectory];

        if (isDirectory)
        {
            [result appendFormat:@"%@dir:%@\n", indent, item];
            [self exploreDirectoryRecursive:fullPath
                                      depth:depth + 1
                                   maxDepth:maxDepth
                                fileManager:fileManager
                                     result:result
                                     indent:[indent stringByAppendingString:@"  "]];
        }
        else
        {
            NSDictionary *attributes = [fileManager attributesOfItemAtPath:fullPath error:nil];
            NSNumber *fileSize = attributes[NSFileSize];
            NSDate *lastOpenedDate = attributes[NSFileModificationDate];
            NSTimeInterval timestamp = [lastOpenedDate timeIntervalSince1970];

            [result appendFormat:@"%@file:%@,%lld,%lld\n", indent, item, [fileSize longLongValue],
                                 (long long)timestamp];
        }
    }
}

@end

@implementation FileReader

+ (NSData *)readFile:(NSString *)path error:(NSError **)error
{
    NSFileManager *fileManager = [NSFileManager defaultManager];

    if (![fileManager fileExistsAtPath:path])
    {
        if (error)
        {
            *error = [NSError errorWithDomain:@"FileReaderErrorDomain"
                                         code:404
                                     userInfo:@{NSLocalizedDescriptionKey : @"File not found"}];
        }
        return nil;
    }

    return [NSData dataWithContentsOfFile:path options:0 error:error];
}

@end

@implementation ProcessInfoRetriever

+ (NSDictionary *)getProcessInfo:(pid_t)pid
{
    NSMutableDictionary *info = [NSMutableDictionary dictionary];

    pid_t currentPid = getpid();
    debug_log(LOG_DEBUG, "Current PID: %d, Target PID: %d", currentPid, pid);

    if (pid == currentPid)
    {
        // debug_log("Fetching info for current process.");

        NSString *bundlePath = [[NSBundle mainBundle] bundlePath];
        info[@"BundlePath"] = bundlePath;
        debug_log(LOG_DEBUG, "Bundle path: %s", [bundlePath UTF8String]);

        NSArray *documentPaths =
            NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
        NSString *documentDirectory = [documentPaths firstObject];
        info[@"DocumentDirectory"] = documentDirectory;
        debug_log(LOG_DEBUG, "Document directory: %s", [documentDirectory UTF8String]);

        NSArray *libraryPaths =
            NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);
        NSString *libraryDirectory = [libraryPaths firstObject];
        info[@"LibraryDirectory"] = libraryDirectory;
        debug_log(LOG_DEBUG, "Library directory: %s", [libraryDirectory UTF8String]);

        NSArray *cachesPaths =
            NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
        NSString *cachesDirectory = [cachesPaths firstObject];
        info[@"CachesDirectory"] = cachesDirectory;
        debug_log(LOG_DEBUG, "Caches directory: %s", [cachesDirectory UTF8String]);
    }
    else
    {
        debug_log(LOG_DEBUG, "Fetching info for external process with PID: %d", pid);

        char pathbuf[PROC_PIDPATHINFO_MAXSIZE];
        int ret = proc_pidpath(pid, pathbuf, sizeof(pathbuf));

        if (ret > 0)
        {
            NSString *executablePath = [NSString stringWithUTF8String:pathbuf];
            if (executablePath != nil && executablePath.length > 0)
            {
                NSString *bundlePath = [executablePath stringByDeletingLastPathComponent];
                if ([bundlePath hasSuffix:@".app"])
                {
                    info[@"BundlePath"] = bundlePath;
                    debug_log(LOG_DEBUG, "External bundle path: %s", [bundlePath UTF8String]);

                    NSString *bundleIdentifier = [self bundleIdentifierForPath:bundlePath];
                    if (bundleIdentifier != nil)
                    {
                        debug_log(LOG_DEBUG, "Bundle Identifier: %s",
                                  [bundleIdentifier UTF8String]);

                        NSString *containerPath = @"/var/mobile/Containers/Data/Application";
                        NSArray *containerDirectories =
                            [[NSFileManager defaultManager] contentsOfDirectoryAtPath:containerPath
                                                                                error:nil];
                        // debug_log("Container directories: %@", containerDirectories);

                        for (NSString *directory in containerDirectories)
                        {
                            NSString *fullPath =
                                [containerPath stringByAppendingPathComponent:directory];
                            NSString *metadataPath = [fullPath
                                stringByAppendingPathComponent:
                                    @".com.apple.mobile_container_manager.metadata.plist"];
                            // debug_log("Checking metadata path: %s", [metadataPath UTF8String]);

                            NSDictionary *metadata =
                                [NSDictionary dictionaryWithContentsOfFile:metadataPath];
                            // debug_log("Metadata: %@", metadata);

                            if ([metadata[@"MCMMetadataIdentifier"]
                                    isEqualToString:bundleIdentifier])
                            {
                                info[@"DocumentDirectory"] =
                                    [fullPath stringByAppendingPathComponent:@"Documents"];
                                info[@"LibraryDirectory"] =
                                    [fullPath stringByAppendingPathComponent:@"Library"];
                                info[@"CachesDirectory"] =
                                    [fullPath stringByAppendingPathComponent:@"Library/Caches"];
                                debug_log(LOG_DEBUG, "Matched container directory: %s",
                                          [fullPath UTF8String]);
                                break;
                            }
                        }
                    }
                    else
                    {
                        debug_log(LOG_ERROR, "Failed to retrieve bundle identifier for path: %s",
                                  [bundlePath UTF8String]);
                    }
                }
                else
                {
                    debug_log(LOG_ERROR, "Unexpected path format: %s", [bundlePath UTF8String]);
                }
            }
            else
            {
                debug_log(LOG_ERROR, "Failed to convert path to NSString or empty string.");
            }
        }
        else
        {
            info[@"Error"] = @"Failed to retrieve bundle path.";
            debug_log(LOG_ERROR,
                      "Failed to retrieve bundle path for PID: %d, proc_pidpath returned: %d", pid,
                      ret);
        }
    }

    return info;
}

+ (NSString *)bundleIdentifierForPath:(NSString *)bundlePath
{
    // debug_log("Fetching bundle identifier for path: %s", [bundlePath UTF8String]);
    NSString *infoPlistPath = [bundlePath stringByAppendingPathComponent:@"Info.plist"];

    if ([[NSFileManager defaultManager] fileExistsAtPath:infoPlistPath])
    {
        NSDictionary *infoPlist = [NSDictionary dictionaryWithContentsOfFile:infoPlistPath];
        if (infoPlist != nil)
        {
            // debug_log("Info.plist contents: %@", infoPlist);
            return infoPlist[@"CFBundleIdentifier"];
        }
        else
        {
            debug_log(LOG_ERROR, "Failed to read Info.plist contents at path: %s",
                      [infoPlistPath UTF8String]);
        }
    }
    else
    {
        debug_log(LOG_ERROR, "Info.plist does not exist at path: %s", [infoPlistPath UTF8String]);
    }

    return nil;
}

@end

const char *explore_directory(const char *path, int maxDepth)
{
    @autoreleasepool
    {
        NSString *nsPath = [NSString stringWithUTF8String:path];
        NSError *error = nil;
        NSString *result = [DirectoryExplorer exploreDirectory:nsPath
                                                      maxDepth:maxDepth
                                                         error:&error];

        if (error)
        {
            NSString *errorString =
                [NSString stringWithFormat:@"Error: %@", [error localizedDescription]];
            return strdup([errorString UTF8String]);
        }

        return result ? strdup([result UTF8String]) : strdup("No results");
    }
}

const void *read_file(const char *path, size_t *size, char **error_message)
{
    @autoreleasepool
    {
        NSError *error = nil;
        NSString *nsPath = [NSString stringWithUTF8String:path];
        NSData *result = [FileReader readFile:nsPath error:&error];

        if (error)
        {
            NSString *errorString =
                [NSString stringWithFormat:@"Error: %@", [error localizedDescription]];
            *error_message = strdup([errorString UTF8String]);
            *size = 0;
            return NULL;
        }

        if (result)
        {
            *size = [result length];
            void *buffer = malloc(*size);
            memcpy(buffer, [result bytes], *size);
            return buffer;
        }
        else
        {
            *error_message = strdup("No content");
            *size = 0;
            return NULL;
        }
    }
}

const char *get_application_info_native(pid_t pid)
{
    @autoreleasepool
    {
        NSDictionary *info = [ProcessInfoRetriever getProcessInfo:pid];

        if (![NSJSONSerialization isValidJSONObject:info])
        {
            debug_log(LOG_ERROR, "info dictionary contains non-serializable objects");
            return strdup("Error: info dictionary contains non-serializable objects");
        }

        NSError *error = nil;
        NSData *jsonData = [NSJSONSerialization dataWithJSONObject:info options:0 error:&error];

        if (error)
        {
            NSString *errorString =
                [NSString stringWithFormat:@"Error: %@", [error localizedDescription]];
            return strdup([errorString UTF8String]);
        }

        NSString *jsonString = [[NSString alloc] initWithData:jsonData
                                                     encoding:NSUTF8StringEncoding];
        if (jsonString != nil)
        {
            return strdup([jsonString UTF8String]);
        }

        return strdup("Failed to generate JSON string");
    }
}

@implementation InstalledAppRetriever

+ (NSArray<NSDictionary *> *)getInstalledApps
{
    NSMutableArray<NSDictionary *> *apps = [NSMutableArray array];

    // iOS/tvOS Applications directory
    NSString *applicationsPath = @"/var/containers/Bundle/Application";
    NSFileManager *fileManager = [NSFileManager defaultManager];

    // Check if the directory exists
    if (![fileManager fileExistsAtPath:applicationsPath])
    {
        // Fallback for macOS or different iOS configurations
        applicationsPath = @"/Applications";
    }

    NSError *error = nil;
    NSArray *appContainers = [fileManager contentsOfDirectoryAtPath:applicationsPath error:&error];

    if (error)
    {
        debug_log(LOG_ERROR, "Failed to read applications directory: %s",
                  [[error localizedDescription] UTF8String]);
        return apps;
    }

    for (NSString *container in appContainers)
    {
        NSString *containerPath = [applicationsPath stringByAppendingPathComponent:container];
        BOOL isDirectory;

        if ([fileManager fileExistsAtPath:containerPath isDirectory:&isDirectory] && isDirectory)
        {
            // Find .app bundle inside the container
            NSArray *contents = [fileManager contentsOfDirectoryAtPath:containerPath error:nil];

            for (NSString *item in contents)
            {
                if ([item hasSuffix:@".app"])
                {
                    NSString *appPath = [containerPath stringByAppendingPathComponent:item];
                    NSDictionary *appInfo = [self getAppInfoFromPath:appPath];

                    if (appInfo)
                    {
                        [apps addObject:appInfo];
                    }
                }
            }
        }
        // Also handle direct .app bundles (for macOS)
        else if ([container hasSuffix:@".app"])
        {
            NSString *appPath = [applicationsPath stringByAppendingPathComponent:container];
            NSDictionary *appInfo = [self getAppInfoFromPath:appPath];

            if (appInfo)
            {
                [apps addObject:appInfo];
            }
        }
    }

    return apps;
}

+ (NSDictionary *)getAppInfoFromPath:(NSString *)appPath
{
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *infoPlistPath = [appPath stringByAppendingPathComponent:@"Info.plist"];

    if (![fileManager fileExistsAtPath:infoPlistPath])
    {
        return nil;
    }

    NSDictionary *infoPlist = [NSDictionary dictionaryWithContentsOfFile:infoPlistPath];

    if (!infoPlist)
    {
        return nil;
    }

    NSString *bundleIdentifier = infoPlist[@"CFBundleIdentifier"];
    NSString *displayName = infoPlist[@"CFBundleDisplayName"] ?: infoPlist[@"CFBundleName"];
    NSString *bundleVersion =
        infoPlist[@"CFBundleShortVersionString"] ?: infoPlist[@"CFBundleVersion"];
    NSString *executableName = infoPlist[@"CFBundleExecutable"];
    NSString *minimumOSVersion = infoPlist[@"MinimumOSVersion"];

    if (!bundleIdentifier)
    {
        return nil;
    }

    NSMutableDictionary *appInfo = [NSMutableDictionary dictionary];
    appInfo[@"bundleIdentifier"] = bundleIdentifier;
    appInfo[@"displayName"] = displayName ?: @"Unknown";
    appInfo[@"bundleVersion"] = bundleVersion ?: @"Unknown";
    appInfo[@"bundlePath"] = appPath;

    if (executableName)
    {
        appInfo[@"executableName"] = executableName;
        appInfo[@"executablePath"] = [appPath stringByAppendingPathComponent:executableName];
    }

    if (minimumOSVersion)
    {
        appInfo[@"minimumOSVersion"] = minimumOSVersion;
    }

    // Get data container path for FBS launch
    NSString *containerPath = [self getDataContainerForBundleIdentifier:bundleIdentifier];
    if (containerPath)
    {
        appInfo[@"dataContainerPath"] = containerPath;
    }

    // Get icon file name
    NSArray *iconFiles = infoPlist[@"CFBundleIconFiles"];
    if (!iconFiles)
    {
        NSDictionary *icons = infoPlist[@"CFBundleIcons"];
        if (icons)
        {
            NSDictionary *primaryIcon = icons[@"CFBundlePrimaryIcon"];
            if (primaryIcon)
            {
                iconFiles = primaryIcon[@"CFBundleIconFiles"];
            }
        }
    }

    if (iconFiles && iconFiles.count > 0)
    {
        // Get the largest icon
        appInfo[@"iconFile"] = [iconFiles lastObject];
    }

    return appInfo;
}

+ (NSString *)getDataContainerForBundleIdentifier:(NSString *)bundleIdentifier
{
    NSString *containerPath = @"/var/mobile/Containers/Data/Application";
    NSFileManager *fileManager = [NSFileManager defaultManager];

    if (![fileManager fileExistsAtPath:containerPath])
    {
        return nil;
    }

    NSArray *containerDirectories = [fileManager contentsOfDirectoryAtPath:containerPath error:nil];

    for (NSString *directory in containerDirectories)
    {
        NSString *fullPath = [containerPath stringByAppendingPathComponent:directory];
        NSString *metadataPath = [fullPath
            stringByAppendingPathComponent:@".com.apple.mobile_container_manager.metadata.plist"];

        NSDictionary *metadata = [NSDictionary dictionaryWithContentsOfFile:metadataPath];

        if ([metadata[@"MCMMetadataIdentifier"] isEqualToString:bundleIdentifier])
        {
            return fullPath;
        }
    }

    return nil;
}

@end

@implementation AppIconRetriever

+ (NSData *)getIconForApp:(NSString *)bundleIdentifier
{
    // Find app path from bundle identifier
    NSString *appPath = [self findAppPathForBundleIdentifier:bundleIdentifier];

    if (!appPath)
    {
        debug_log(LOG_ERROR, "App not found for bundle identifier: %s",
                  [bundleIdentifier UTF8String]);
        return nil;
    }

    return [self getIconFromAppPath:appPath];
}

+ (NSData *)getIconFromAppPath:(NSString *)appPath
{
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *infoPlistPath = [appPath stringByAppendingPathComponent:@"Info.plist"];

    NSDictionary *infoPlist = [NSDictionary dictionaryWithContentsOfFile:infoPlistPath];

    if (!infoPlist)
    {
        return nil;
    }

    // Get icon file names from Info.plist
    NSMutableArray *iconNames = [NSMutableArray array];

    // Try CFBundleIcons (iOS 5+)
    NSDictionary *icons = infoPlist[@"CFBundleIcons"];
    if (icons)
    {
        NSDictionary *primaryIcon = icons[@"CFBundlePrimaryIcon"];
        if (primaryIcon)
        {
            NSArray *iconFiles = primaryIcon[@"CFBundleIconFiles"];
            if (iconFiles)
            {
                [iconNames addObjectsFromArray:iconFiles];
            }
        }
    }

    // Try CFBundleIcons~ipad
    NSDictionary *iconsiPad = infoPlist[@"CFBundleIcons~ipad"];
    if (iconsiPad)
    {
        NSDictionary *primaryIcon = iconsiPad[@"CFBundlePrimaryIcon"];
        if (primaryIcon)
        {
            NSArray *iconFiles = primaryIcon[@"CFBundleIconFiles"];
            if (iconFiles)
            {
                [iconNames addObjectsFromArray:iconFiles];
            }
        }
    }

    // Try legacy CFBundleIconFiles
    NSArray *legacyIconFiles = infoPlist[@"CFBundleIconFiles"];
    if (legacyIconFiles)
    {
        [iconNames addObjectsFromArray:legacyIconFiles];
    }

    // Try CFBundleIconFile (single icon)
    NSString *singleIconFile = infoPlist[@"CFBundleIconFile"];
    if (singleIconFile)
    {
        [iconNames addObject:singleIconFile];
    }

    // Sort by size preference (larger icons first)
    NSArray *sizePreferences = @[ @"@3x", @"@2x", @"180", @"167", @"152", @"120", @"76", @"60" ];

    for (NSString *sizeSuffix in sizePreferences)
    {
        for (NSString *iconName in iconNames)
        {
            // Try with suffix
            NSArray *suffixes = @[
                [NSString stringWithFormat:@"%@%@", sizeSuffix, @".png"],
                [NSString stringWithFormat:@"%@", sizeSuffix], @".png", @""
            ];

            for (NSString *suffix in suffixes)
            {
                NSString *iconFileName = [iconName stringByAppendingString:suffix];
                NSString *iconPath = [appPath stringByAppendingPathComponent:iconFileName];

                if ([fileManager fileExistsAtPath:iconPath])
                {
                    NSData *iconData = [NSData dataWithContentsOfFile:iconPath];
                    if (iconData && iconData.length > 0)
                    {
                        debug_log(LOG_DEBUG, "Found icon at: %s", [iconPath UTF8String]);
                        return iconData;
                    }
                }
            }
        }
    }

    // Try default icon names
    NSArray *defaultIconNames = @[
        @"AppIcon60x60@3x.png", @"AppIcon60x60@2x.png", @"AppIcon76x76@2x.png", @"AppIcon.png",
        @"Icon.png", @"Icon@2x.png", @"Icon-60.png", @"Icon-60@2x.png", @"Icon-60@3x.png"
    ];

    for (NSString *defaultIconName in defaultIconNames)
    {
        NSString *iconPath = [appPath stringByAppendingPathComponent:defaultIconName];

        if ([fileManager fileExistsAtPath:iconPath])
        {
            NSData *iconData = [NSData dataWithContentsOfFile:iconPath];
            if (iconData && iconData.length > 0)
            {
                debug_log(LOG_DEBUG, "Found icon at default path: %s", [iconPath UTF8String]);
                return iconData;
            }
        }
    }

    debug_log(LOG_WARN, "No icon found for app: %s", [appPath UTF8String]);
    return nil;
}

+ (NSString *)findAppPathForBundleIdentifier:(NSString *)bundleIdentifier
{
    NSString *applicationsPath = @"/var/containers/Bundle/Application";
    NSFileManager *fileManager = [NSFileManager defaultManager];

    if (![fileManager fileExistsAtPath:applicationsPath])
    {
        applicationsPath = @"/Applications";
    }

    NSArray *appContainers = [fileManager contentsOfDirectoryAtPath:applicationsPath error:nil];

    for (NSString *container in appContainers)
    {
        NSString *containerPath = [applicationsPath stringByAppendingPathComponent:container];
        BOOL isDirectory;

        if ([fileManager fileExistsAtPath:containerPath isDirectory:&isDirectory] && isDirectory)
        {
            NSArray *contents = [fileManager contentsOfDirectoryAtPath:containerPath error:nil];

            for (NSString *item in contents)
            {
                if ([item hasSuffix:@".app"])
                {
                    NSString *appPath = [containerPath stringByAppendingPathComponent:item];
                    NSString *infoPlistPath =
                        [appPath stringByAppendingPathComponent:@"Info.plist"];
                    NSDictionary *infoPlist =
                        [NSDictionary dictionaryWithContentsOfFile:infoPlistPath];

                    if ([infoPlist[@"CFBundleIdentifier"] isEqualToString:bundleIdentifier])
                    {
                        return appPath;
                    }
                }
            }
        }
        else if ([container hasSuffix:@".app"])
        {
            NSString *appPath = [applicationsPath stringByAppendingPathComponent:container];
            NSString *infoPlistPath = [appPath stringByAppendingPathComponent:@"Info.plist"];
            NSDictionary *infoPlist = [NSDictionary dictionaryWithContentsOfFile:infoPlistPath];

            if ([infoPlist[@"CFBundleIdentifier"] isEqualToString:bundleIdentifier])
            {
                return appPath;
            }
        }
    }

    return nil;
}

@end

const char *get_installed_apps_native(void)
{
    @autoreleasepool
    {
        NSArray *apps = [InstalledAppRetriever getInstalledApps];

        if (![NSJSONSerialization isValidJSONObject:apps])
        {
            debug_log(LOG_ERROR, "Apps array contains non-serializable objects");
            return strdup("[]");
        }

        NSError *error = nil;
        NSData *jsonData = [NSJSONSerialization dataWithJSONObject:apps options:0 error:&error];

        if (error)
        {
            debug_log(LOG_ERROR, "JSON serialization error: %s",
                      [[error localizedDescription] UTF8String]);
            return strdup("[]");
        }

        NSString *jsonString = [[NSString alloc] initWithData:jsonData
                                                     encoding:NSUTF8StringEncoding];
        if (jsonString != nil)
        {
            return strdup([jsonString UTF8String]);
        }

        return strdup("[]");
    }
}

const void *get_app_icon_native(const char *bundle_identifier, size_t *size)
{
    @autoreleasepool
    {
        if (bundle_identifier == NULL || size == NULL)
        {
            *size = 0;
            return NULL;
        }

        NSString *bundleId = [NSString stringWithUTF8String:bundle_identifier];
        NSData *iconData = [AppIconRetriever getIconForApp:bundleId];

        if (iconData == nil || iconData.length == 0)
        {
            *size = 0;
            return NULL;
        }

        *size = [iconData length];
        void *buffer = malloc(*size);
        memcpy(buffer, [iconData bytes], *size);

        return buffer;
    }
}
```

`src/server/src/cpp/src/darwin/core/memory_io.h`:

```h
/**
 * @file memory_io.h
 * @brief Memory read/write operations for process memory access (Darwin/macOS)
 *
 * Provides memory access via Mach VM APIs:
 * - mach_vm_read_overwrite (primary method)
 * - mach_vm_write (for writing)
 * - Task port caching for performance
 */

#ifndef DARWIN_MEMORY_IO_H
#define DARWIN_MEMORY_IO_H

#include <mach/mach.h>
#include <mach/vm_map.h>
#include <sys/types.h>

#include <cstddef>
#include <cstdint>

// =============================================================================
// Mach VM function declarations
// =============================================================================

extern "C" kern_return_t mach_vm_read_overwrite(vm_map_t target_task,
                                                mach_vm_address_t address,
                                                mach_vm_size_t size,
                                                mach_vm_address_t data,
                                                mach_vm_size_t* outsize);

extern "C" kern_return_t mach_vm_write(vm_map_t target_task,
                                       mach_vm_address_t address,
                                       vm_offset_t data,
                                       mach_msg_type_number_t dataCnt);

extern "C" kern_return_t mach_vm_protect(vm_map_t target_task,
                                         mach_vm_address_t address,
                                         mach_vm_size_t size,
                                         boolean_t set_maximum,
                                         vm_prot_t new_protection);

extern "C" kern_return_t mach_vm_region(vm_map_t target_task,
                                        mach_vm_address_t* address,
                                        mach_vm_size_t* size,
                                        vm_region_flavor_t flavor,
                                        vm_region_info_t info,
                                        mach_msg_type_number_t* infoCnt,
                                        mach_port_t* object_name);

// =============================================================================
// External C API functions (called from Rust)
// =============================================================================

#ifdef __cplusplus
extern "C"
{
#endif

    /**
     * Read memory from target process using Mach VM API
     * @param pid Target process ID
     * @param address Memory address to read from
     * @param size Number of bytes to read
     * @param buffer Output buffer to store read data
     * @return Number of bytes read, or negative value on error
     */
    ssize_t read_memory_native(int pid, mach_vm_address_t address, mach_vm_size_t size,
                               unsigned char* buffer);

    /**
     * Read memory with specific method selection
     * @param pid Target process ID
     * @param address Memory address to read from
     * @param size Number of bytes to read
     * @param buffer Output buffer to store read data
     * @param mode Read method: 0=default (Mach VM), others reserved
     * @return Number of bytes read, or negative value on error
     */
    ssize_t read_memory_native_with_method(int pid, mach_vm_address_t address, mach_vm_size_t size,
                                           unsigned char* buffer, int mode);

    /**
     * Write memory to target process using Mach VM API
     * @param pid Target process ID
     * @param address Memory address to write to
     * @param size Number of bytes to write
     * @param buffer Data to write
     * @return Number of bytes written, or negative value on error
     */
    ssize_t write_memory_native(int pid, mach_vm_address_t address, mach_vm_size_t size,
                                unsigned char* buffer);

#ifdef __cplusplus
}
#endif

// =============================================================================
// Internal C++ helper functions
// =============================================================================

#ifdef __cplusplus

/**
 * Get or create cached task port for process
 * @param pid Target process ID
 * @return Task port, or MACH_PORT_NULL on failure
 */
mach_port_t get_task_port_for_pid(pid_t pid);

/**
 * Clear cached task port for process
 * @param pid Target process ID
 */
void clear_task_port_cache(pid_t pid);

#endif  // __cplusplus

#endif  // DARWIN_MEMORY_IO_H

```

`src/server/src/cpp/src/darwin/core/memory_io.mm`:

```mm
/**
 * @file memory_io.mm
 * @brief Memory read/write operations for Darwin/macOS using Mach VM APIs
 *
 * Implementation of process memory access functions. Uses mach_vm_read_overwrite
 * for reading and mach_vm_write for writing, with proper memory protection handling.
 */

#include "memory_io.h"
#include "native_api.h"

#include <errno.h>
#include <mach/mach_error.h>
#include <unistd.h>

#include <map>
#include <mutex>

// =============================================================================
// Task Port Cache
// =============================================================================

// Task port cache to avoid repeated task_for_pid calls
static std::map<pid_t, mach_port_t> g_memory_task_port_cache;
static std::mutex g_memory_task_port_mutex;

mach_port_t get_task_port_for_pid(pid_t pid)
{
    if (pid == getpid())
    {
        return mach_task_self();
    }

    std::lock_guard<std::mutex> lock(g_memory_task_port_mutex);

    auto it = g_memory_task_port_cache.find(pid);
    if (it != g_memory_task_port_cache.end())
    {
        debug_log(LOG_DEBUG, "Memory task port cache hit for pid %d: %d", pid, it->second);
        return it->second;
    }

    // debug_log_develop(LOG_DEBUG, "Memory task port cache miss for pid %d, calling task_for_pid",
    // pid);

    mach_port_t task;
    kern_return_t kr = task_for_pid(mach_task_self(), pid, &task);
    if (kr != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "task_for_pid failed for memory access: %d (%s)", kr,
                  mach_error_string(kr));
        return MACH_PORT_NULL;
    }

    g_memory_task_port_cache[pid] = task;
    // debug_log_develop(LOG_INFO, "Cached memory task port for pid %d: %d", pid, task);
    return task;
}

void clear_task_port_cache(pid_t pid)
{
    std::lock_guard<std::mutex> lock(g_memory_task_port_mutex);
    auto it = g_memory_task_port_cache.find(pid);
    if (it != g_memory_task_port_cache.end())
    {
        mach_port_deallocate(mach_task_self(), it->second);
        g_memory_task_port_cache.erase(it);
        debug_log(LOG_INFO, "Cleared memory task port cache for pid %d", pid);
    }
}

// =============================================================================
// Memory Read Operations
// =============================================================================

ssize_t read_memory_native(int pid, mach_vm_address_t address, mach_vm_size_t size,
                           unsigned char* buffer)
{
    return read_memory_native_with_method(pid, address, size, buffer, 0);
}

ssize_t read_memory_native_with_method(int pid, mach_vm_address_t address, mach_vm_size_t size,
                                       unsigned char* buffer, int mode __attribute__((unused)))
{
    // Darwin doesn't use mode parameter, always uses mach_vm_read
    mach_port_t task = get_task_port_for_pid(pid);
    if (task == MACH_PORT_NULL)
    {
        debug_log(LOG_ERROR, "read_memory_native_with_method: No task port for pid %d", pid);
        errno = ESRCH;  // Set proper errno for "No such process"
        return -1;
    }

    mach_vm_size_t out_size;
    kern_return_t kr =
        mach_vm_read_overwrite(task, address, size, (mach_vm_address_t)buffer, &out_size);
    if (kr != KERN_SUCCESS)
    {
        debug_log(LOG_DEBUG, "mach_vm_read_overwrite failed: %d (%s) at 0x%llx size %llu", kr,
                  mach_error_string(kr), address, size);
        return -1;
    }

    return static_cast<ssize_t>(out_size);
}

// =============================================================================
// Memory Write Operations
// =============================================================================

ssize_t write_memory_native(int pid, mach_vm_address_t address, mach_vm_size_t size,
                            unsigned char* buffer)
{
    vm_prot_t original_protection;
    vm_region_basic_info_data_64_t info;
    mach_msg_type_number_t info_count = VM_REGION_BASIC_INFO_COUNT_64;
    mach_port_t object_name;
    bool is_embedded_mode = pid == getpid();

    mach_port_t task = get_task_port_for_pid(pid);
    if (task == MACH_PORT_NULL)
    {
        debug_log(LOG_ERROR, "write_memory_native: No task port for pid %d", pid);
        return -1;
    }

    kern_return_t err;
    if (!is_embedded_mode)
    {
        task_suspend(task);
    }

    // Get region information to save original protection
    mach_vm_address_t region_address = address;
    mach_vm_size_t region_size = size;
    err = mach_vm_region(task, &region_address, &region_size, VM_REGION_BASIC_INFO_64,
                         (vm_region_info_t)&info, &info_count, &object_name);
    if (err != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "mach_vm_region failed: %d (%s) at 0x%llx size %llu", err,
                  mach_error_string(err), address, size);
        if (!is_embedded_mode)
        {
            task_resume(task);
        }
        return -1;
    }
    original_protection = info.protection;

    // Enable write access
    err = mach_vm_protect(task, address, size, false, VM_PROT_READ | VM_PROT_WRITE);
    if (err != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "mach_vm_protect (write enable) failed: %d (%s)", err,
                  mach_error_string(err));
        if (!is_embedded_mode)
        {
            task_resume(task);
        }
        return -1;
    }

    // Write memory
    err = mach_vm_write(task, address, (vm_offset_t)buffer, size);
    if (err != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "mach_vm_write failed: %d (%s) at 0x%llx size %llu", err,
                  mach_error_string(err), address, size);
        mach_vm_protect(task, address, size, false, original_protection);
        if (!is_embedded_mode)
        {
            task_resume(task);
        }
        return -1;
    }

    // Restore original protection
    err = mach_vm_protect(task, address, size, false, original_protection);
    if (err != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "mach_vm_protect (restore) failed: %d (%s)", err,
                  mach_error_string(err));
        if (!is_embedded_mode)
        {
            task_resume(task);
        }
        return -1;
    }

    if (!is_embedded_mode)
    {
        task_resume(task);
    }
    return static_cast<ssize_t>(size);
}

```

`src/server/src/cpp/src/darwin/core/native_api.h`:

```h
#ifndef NATIVEAPI_H
#define NATIVEAPI_H

#include <mach/mach.h>
#include <mach/vm_map.h>
#include <mach/vm_region.h>
#include <sys/sysctl.h>

#include <string>
#include <vector>

enum LogLevel
{
    LOG_ERROR = 1,
    LOG_WARN = 2,
    LOG_INFO = 3,
    LOG_DEBUG = 4,
    LOG_TRACE = 5
};

enum ServerMode
{
    NORMAL,
    EMBEDDED,
};

// Exception types for debugger
enum ExceptionType
{
    EXCEPTION_UNKNOWN = 0,
    EXCEPTION_BREAKPOINT = 1,
    EXCEPTION_WATCHPOINT = 2,
    EXCEPTION_SINGLESTEP = 3,
};

typedef struct
{
    int pid;
    const char *processname;
} ProcessInfo;

typedef struct
{
    uintptr_t base;
    size_t size;
    bool is_64bit;
    char *modulename;
} ModuleInfo;

typedef struct
{
    uintptr_t address;
    char *name;
    size_t size;
    char *type;             // Function, Variable, etc.
    char *scope;            // Global, Local, etc.
    uintptr_t module_base;  // Base address of containing module
    char *file_name;        // Source file name (if available)
    int line_number;        // Line number (if available)
} SymbolInfo;

typedef struct
{
    uint64_t thread_id;  // Mach thread port / thread ID
    char *name;          // Thread name (if available)
    uint64_t pc;         // Program counter
    uint64_t sp;         // Stack pointer
    uint64_t fp;         // Frame pointer
    int state;           // Thread state (running, waiting, etc.)
    int suspend_count;   // Suspend count
} ThreadInfo;

typedef struct
{
    uintptr_t start;
    uintptr_t end;
    uint32_t protection;  // PROT_READ=1, PROT_WRITE=2, PROT_EXEC=4
    char *pathname;
} RegionInfo;

typedef struct
{
    int mode;
} ServerState;

extern ServerState global_server_state;

typedef int (*PROC_REGIONFILENAME)(int pid, uint64_t address, void *buffer, uint32_t buffersize);
extern PROC_REGIONFILENAME proc_regionfilename;
typedef int (*PROC_PIDPATH)(int pid, void *buffer, uint32_t buffersize);
extern PROC_PIDPATH proc_pidpath;

extern "C" kern_return_t mach_vm_read_overwrite(vm_map_t, mach_vm_address_t, mach_vm_size_t,
                                                mach_vm_address_t, mach_vm_size_t *);

extern "C" kern_return_t mach_vm_write(vm_map_t, mach_vm_address_t, vm_offset_t,
                                       mach_msg_type_number_t);

extern "C" kern_return_t mach_vm_protect(vm_map_t, mach_vm_address_t, mach_vm_size_t, boolean_t,
                                         vm_prot_t);

extern "C" kern_return_t mach_vm_region(vm_map_t, mach_vm_address_t *, mach_vm_size_t *,
                                        vm_region_flavor_t, vm_region_info_t,
                                        mach_msg_type_number_t *, mach_port_t *);

extern "C" int native_init(int mode);

extern "C" pid_t get_pid_native();

extern "C" ssize_t read_memory_native(int pid, mach_vm_address_t address, mach_vm_size_t size,
                                      unsigned char *buffer);

extern "C" ssize_t read_memory_native_with_method(int pid, mach_vm_address_t address,
                                                  mach_vm_size_t size, unsigned char *buffer,
                                                  int mode);

extern "C" ssize_t write_memory_native(int pid, mach_vm_address_t address, mach_vm_size_t size,
                                       unsigned char *buffer);

extern "C" void enumerate_regions_to_buffer(pid_t pid, char *buffer, size_t buffer_size);
extern "C" void enumerate_regions_to_buffer_fast(pid_t pid, char *buffer, size_t buffer_size,
                                                 bool include_filenames);

extern "C" ProcessInfo *enumerate_processes(size_t *count);

extern "C" bool suspend_process(pid_t pid);

extern "C" bool resume_process(pid_t pid);

extern "C" ModuleInfo *enumerate_modules(pid_t pid, size_t *count);

extern "C" SymbolInfo *enumerate_symbols(int pid, uintptr_t module_base, size_t *count);

extern "C" ThreadInfo *enumerate_threads(pid_t pid, size_t *count);
extern "C" void free_thread_info(ThreadInfo *threads, size_t count);

extern "C" RegionInfo *enumerate_regions(pid_t pid, size_t *count);
extern "C" void free_region_info(RegionInfo *regions, size_t count);

int debug_log(LogLevel level, const char *format, ...);

// Development debug log function (compile-time option)
int _debug_log_develop_impl(const char *func, int line, LogLevel level, const char *format, ...);
#define debug_log_develop(level, format, ...) \
    _debug_log_develop_impl(__FUNCTION__, __LINE__, level, format, ##__VA_ARGS__)
#include "../../common/exception_info.h"

// Rust functions
extern "C" void native_log(int level, const char *message);
// Returns true if execution should auto-continue, false to enter break state
extern "C" bool send_exception_info(const NativeExceptionInfo *info, pid_t pid);
extern "C" void send_register_json(const char *register_json, pid_t pid);  // Backward compatibility
extern "C" char *disassemble(const uint8_t *bytecode, size_t length);
extern "C" char *disassemble_at_address(const uint8_t *bytecode, size_t length, uint64_t address);
extern "C" void free_string(char *s);

// MachOBridge functions (Swift)
extern "C" uint64_t macho_get_module_size_by_name(const char *name);
extern "C" uint64_t macho_get_module_size_by_address(uint64_t address);
extern "C" uint64_t macho_get_module_size_from_cache(const char *image_path);
extern "C" uint32_t macho_get_loaded_image_count();
extern "C" char *macho_get_loaded_image_path(uint32_t index);
extern "C" uint64_t macho_get_loaded_image_base(uint32_t index);
extern "C" uint64_t macho_get_loaded_image_size(uint32_t index);
extern "C" int64_t macho_get_loaded_image_slide(uint32_t index);
extern "C" void macho_free_string(char *s);

// Trace file output functions
extern "C" void enable_trace_file_output_native(const char *filepath);
extern "C" void disable_trace_file_output_native();
extern "C" bool is_trace_file_output_enabled_native();
extern "C" const char *get_trace_file_path_native();
extern "C" uint32_t get_trace_file_entry_count_native();

// Script trace control functions
extern "C" void request_script_trace_stop_native(bool notify_ui);
extern "C" void clear_script_trace_stop_request_native();
extern "C" bool is_script_trace_stop_requested_native();

#endif

```

`src/server/src/cpp/src/darwin/core/native_api.mm`:

```mm
#include "native_api.h"
#include <Foundation/Foundation.h>
#include <dlfcn.h>
#include <errno.h>
#include <mach-o/dyld_images.h>
#include <mach-o/fat.h>
#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#include <mach-o/stab.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/queue.h>
#include <sys/sysctl.h>
#include <algorithm>
#include <chrono>
#include <iostream>
#include <map>
#include <mutex>
#include <string>
#include <vector>

PROC_REGIONFILENAME proc_regionfilename = nullptr;
PROC_PIDPATH proc_pidpath = nullptr;
ServerState global_server_state = {0};

// Task port cache to avoid repeated task_for_pid calls
static std::map<pid_t, mach_port_t> g_task_port_cache;
static std::mutex g_task_port_mutex;

// Helper function to get cached task port
static mach_port_t get_cached_task_port(pid_t pid)
{
    if (pid == getpid())
    {
        return mach_task_self();
    }

    std::lock_guard<std::mutex> lock(g_task_port_mutex);

    auto it = g_task_port_cache.find(pid);
    if (it != g_task_port_cache.end())
    {
        debug_log(LOG_DEBUG, "Task port cache hit for pid %d: %d", pid, it->second);
        return it->second;
    }

    // debug_log_develop(LOG_DEBUG, "Task port cache miss for pid %d, calling task_for_pid", pid);
    mach_port_t task;
    kern_return_t kr = task_for_pid(mach_task_self(), pid, &task);
    if (kr != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "task_for_pid failed with error %d (%s)\n", kr, mach_error_string(kr));
        return MACH_PORT_NULL;
    }

    g_task_port_cache[pid] = task;
    // debug_log_develop(LOG_INFO, "Cached task port for pid %d: %d", pid, task);
    return task;
}

// Function to invalidate cached task port (call when process exits)
extern "C" void invalidate_task_port_cache(pid_t pid)
{
    std::lock_guard<std::mutex> lock(g_task_port_mutex);
    auto it = g_task_port_cache.find(pid);
    if (it != g_task_port_cache.end())
    {
        mach_port_deallocate(mach_task_self(), it->second);
        g_task_port_cache.erase(it);
        debug_log(LOG_INFO, "Invalidated task port cache for pid %d", pid);
    }
}

// Function to set cached task port from external source (e.g., debugger)
extern "C" void set_cached_task_port(pid_t pid, mach_port_t task)
{
    if (pid == getpid() || task == MACH_PORT_NULL)
    {
        return;
    }

    std::lock_guard<std::mutex> lock(g_task_port_mutex);

    // Only set if not already cached
    if (g_task_port_cache.find(pid) == g_task_port_cache.end())
    {
        g_task_port_cache[pid] = task;
        debug_log(LOG_INFO, "Set cached task port for pid %d: %d (from external)", pid, task);
    }
}

int debug_log(LogLevel level, const char *format, ...)
{
    va_list list;
    va_start(list, format);

    char buffer[1024];

    char tagged_format[1024];
    snprintf(tagged_format, sizeof(tagged_format), "[NATIVE] %s", format);

    vsnprintf(buffer, sizeof(buffer), tagged_format, list);
    native_log(level, buffer);

    NSString *nsFinalMessage = [NSString stringWithUTF8String:buffer];
    if (global_server_state.mode == ServerMode::EMBEDDED)
    {
        NSLog(@"%@", nsFinalMessage);
    }
    va_end(list);
    return 0;
}

#ifdef ENABLE_LOG_DEVELOP
int _debug_log_develop_impl(const char *func, int line, LogLevel level, const char *format, ...)
{
    va_list list;
    va_start(list, format);

    char buffer[1024];

    char tagged_format[1024];
    const char *build_type = "STATIC";
#ifdef DYNAMIC_LIB_BUILD
    build_type = "DYNAMIC";
#endif

    snprintf(tagged_format, sizeof(tagged_format), "[NATIVE][DEVELOP][%s] %s:%d %s", build_type,
             func, line, format);

    vsnprintf(buffer, sizeof(buffer), tagged_format, list);
    native_log(level, buffer);  // Output at specified level

    NSString *nsFinalMessage = [NSString stringWithUTF8String:buffer];
    if (global_server_state.mode == ServerMode::EMBEDDED)
    {
        NSLog(@"%@", nsFinalMessage);
    }
    va_end(list);
    return 0;
}
#else
// No-op function when ENABLE_LOG_DEVELOP is not defined
int _debug_log_develop_impl(const char *func __attribute__((unused)),
                            int line __attribute__((unused)),
                            LogLevel level __attribute__((unused)),
                            const char *format __attribute__((unused)), ...)
{
    // Do nothing
    return 0;
}
#endif

pid_t get_pid_native()
{
    return getpid();
}

ssize_t read_memory_native(int pid, mach_vm_address_t address, mach_vm_size_t size,
                           unsigned char *buffer)
{
    return read_memory_native_with_method(pid, address, size, buffer, 0);
}

ssize_t read_memory_native_with_method(int pid, mach_vm_address_t address, mach_vm_size_t size,
                                       unsigned char *buffer, int mode __attribute__((unused)))
{
    // Darwin doesn't use mode parameter, always uses mach_vm_read
    mach_port_t task = get_cached_task_port(pid);
    if (task == MACH_PORT_NULL)
    {
        debug_log(LOG_ERROR, "read_memory_native_with_method: No task port for pid %d\n", pid);
        errno = ESRCH;  // Set proper errno for "No such process"
        return -1;
    }

    mach_vm_size_t out_size;
    kern_return_t kr =
        mach_vm_read_overwrite(task, address, size, (mach_vm_address_t)buffer, &out_size);
    if (kr != KERN_SUCCESS)
    {
        debug_log(LOG_DEBUG, "mach_vm_read_overwrite failed with error %d (%s)\n", kr,
                  mach_error_string(kr));
        return -1;
    }

    return static_cast<ssize_t>(out_size);
}

ssize_t write_memory_native(int pid, mach_vm_address_t address, mach_vm_size_t size,
                            unsigned char *buffer)
{
    vm_prot_t original_protection;
    vm_region_basic_info_data_64_t info;
    mach_msg_type_number_t info_count = VM_REGION_BASIC_INFO_COUNT_64;
    mach_port_t object_name;
    bool is_embedded_mode = pid == getpid();

    mach_port_t task = get_cached_task_port(pid);
    if (task == MACH_PORT_NULL)
    {
        return -1;
    }

    kern_return_t err;
    if (!is_embedded_mode)
    {
        task_suspend(task);
    }

    mach_vm_address_t region_address = address;
    mach_vm_size_t region_size = size;
    err = mach_vm_region(task, &region_address, &region_size, VM_REGION_BASIC_INFO_64,
                         (vm_region_info_t)&info, &info_count, &object_name);
    if (err != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR,
                  "mach_vm_region failed with error %d (%s) at address "
                  "0x%llx, size 0x%llx\n",
                  err, mach_error_string(err), address, size);
        if (!is_embedded_mode)
        {
            task_resume(task);
        }
        return -1;
    }
    original_protection = info.protection;

    err = mach_vm_protect(task, address, size, false, VM_PROT_READ | VM_PROT_WRITE);
    if (err != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "mach_vm_protect (write enable) failed with error %d (%s)\n", err,
                  mach_error_string(err));
        if (!is_embedded_mode)
        {
            task_resume(task);
        }
        return -1;
    }

    err = mach_vm_write(task, address, (vm_offset_t)buffer, size);
    if (err != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR,
                  "mach_vm_write failed with error %d (%s) at address "
                  "0x%llx, size 0x%llx\n",
                  err, mach_error_string(err), address, size);
        mach_vm_protect(task, address, size, false, original_protection);
        if (!is_embedded_mode)
        {
            task_resume(task);
        }
        return -1;
    }

    err = mach_vm_protect(task, address, size, false, original_protection);
    if (err != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR,
                  "mach_vm_protect (restore protection) failed with error "
                  "%d (%s)\n",
                  err, mach_error_string(err));
        if (!is_embedded_mode)
        {
            task_resume(task);
        }
        return -1;
    }

    if (!is_embedded_mode)
    {
        task_resume(task);
    }
    return static_cast<ssize_t>(size);
}

void enumerate_regions_to_buffer(pid_t pid, char *buffer, size_t buffer_size)
{
    vm_address_t address = 0;
    vm_size_t size = 0;
    natural_t depth = 1;

    mach_port_t task = get_cached_task_port(pid);
    if (task == MACH_PORT_NULL)
    {
        snprintf(buffer, buffer_size, "Failed to get task for pid %d\n", pid);
        return;
    }

    size_t pos = 0;
    char buf[PATH_MAX];
    memset(buf, 0, PATH_MAX);
    while (true)
    {
        vm_region_submap_info_data_64_t info;
        mach_msg_type_number_t info_count = VM_REGION_SUBMAP_INFO_COUNT_64;

        if (vm_region_recurse_64(task, &address, &size, &depth, (vm_region_info_t)&info,
                                 &info_count) != KERN_SUCCESS)
        {
            break;
        }

        if (info.is_submap)
        {
            depth++;
        }
        else
        {
            char protection[4] = "---";
            if (info.protection & VM_PROT_READ) protection[0] = 'r';
            if (info.protection & VM_PROT_WRITE) protection[1] = 'w';
            if (info.protection & VM_PROT_EXECUTE) protection[2] = 'x';

            int ret = proc_regionfilename(pid, static_cast<unsigned long long>(address), buf,
                                          sizeof(buf));

            if (ret <= 0)
            {
                buf[0] = '\x00';
            }

            pos += snprintf(buffer + pos, buffer_size - pos, "%llx-%llx %s _ _ _ %s\n",
                            static_cast<unsigned long long>(address),
                            static_cast<unsigned long long>(address + size), protection, buf);

            if (pos >= buffer_size - 1) break;

            address += size;
        }
    }
}

// Fast version: optional filename retrieval
void enumerate_regions_to_buffer_fast(pid_t pid, char *buffer, size_t buffer_size,
                                      bool include_filenames)
{
    vm_address_t address = 0;
    vm_size_t size = 0;
    natural_t depth = 1;

    mach_port_t task = get_cached_task_port(pid);
    if (task == MACH_PORT_NULL)
    {
        snprintf(buffer, buffer_size, "Failed to get task for pid %d\n", pid);
        return;
    }

    size_t pos = 0;
    char buf[PATH_MAX] = {0};  // Zero-initialize
    int region_count = 0;
    auto filename_total_time = std::chrono::duration<double, std::milli>::zero();

    while (true)
    {
        vm_region_submap_info_data_64_t info;
        mach_msg_type_number_t info_count = VM_REGION_SUBMAP_INFO_COUNT_64;

        if (vm_region_recurse_64(task, &address, &size, &depth, (vm_region_info_t)&info,
                                 &info_count) != KERN_SUCCESS)
        {
            break;
        }

        if (info.is_submap)
        {
            depth++;
        }
        else
        {
            region_count++;
            char protection[4] = "---";
            if (info.protection & VM_PROT_READ) protection[0] = 'r';
            if (info.protection & VM_PROT_WRITE) protection[1] = 'w';
            if (info.protection & VM_PROT_EXECUTE) protection[2] = 'x';

            // Filename retrieval is conditional
            if (include_filenames && proc_regionfilename != nullptr)
            {
                auto filename_start = std::chrono::high_resolution_clock::now();
                int ret = proc_regionfilename(pid, static_cast<unsigned long long>(address), buf,
                                              sizeof(buf));
                auto filename_elapsed = std::chrono::high_resolution_clock::now() - filename_start;
                filename_total_time += filename_elapsed;

                if (ret <= 0)
                {
                    buf[0] = '\x00';
                }
            }
            else
            {
                buf[0] = '\x00';  // No filename
            }

            pos += snprintf(buffer + pos, buffer_size - pos, "%llx-%llx %s _ _ _ %s\n",
                            static_cast<unsigned long long>(address),
                            static_cast<unsigned long long>(address + size), protection, buf);

            if (pos >= buffer_size - 1) break;

            address += size;
        }
    }
}

ProcessInfo *enumerate_processes(size_t *count)
{
    int err;
    struct kinfo_proc *result;
    bool done;
    static const int name[] = {CTL_KERN, KERN_PROC, KERN_PROC_ALL, 0};
    size_t length;

    result = nullptr;
    done = false;

    do
    {
        length = 0;
        err = sysctl(const_cast<int *>(name), (sizeof(name) / sizeof(*name)) - 1, nullptr, &length,
                     nullptr, 0);
        if (err == -1)
        {
            err = errno;
        }

        if (err == 0)
        {
            result = static_cast<struct kinfo_proc *>(malloc(length));
            if (result == nullptr)
            {
                err = ENOMEM;
            }
        }

        if (err == 0)
        {
            err = sysctl(const_cast<int *>(name), (sizeof(name) / sizeof(*name)) - 1, result,
                         &length, nullptr, 0);
            if (err == -1)
            {
                err = errno;
            }
            if (err == 0)
            {
                done = true;
            }
            else if (err == ENOMEM)
            {
                free(result);
                result = nullptr;
                err = 0;
            }
        }
    } while (err == 0 && !done);

    if (err == 0 && result != nullptr)
    {
        *count = length / sizeof(struct kinfo_proc);
        ProcessInfo *processes = static_cast<ProcessInfo *>(malloc(*count * sizeof(ProcessInfo)));

        for (size_t i = 0; i < *count; i++)
        {
            processes[i].pid = result[i].kp_proc.p_pid;
            processes[i].processname = strdup(result[i].kp_proc.p_comm);
        }

        free(result);
        return processes;
    }
    else
    {
        if (result != nullptr)
        {
            free(result);
        }
        debug_log(LOG_ERROR, "Failed to enumerate processes, error %d\n", err);
        return nullptr;
    }
}

bool suspend_process(pid_t pid)
{
    bool is_embedded_mode = pid == getpid();
    if (is_embedded_mode)
    {
        debug_log(LOG_ERROR, "Cannot suspend self process\n");
        return false;
    }

    mach_port_t task = get_cached_task_port(pid);
    if (task == MACH_PORT_NULL)
    {
        return false;
    }

    kern_return_t err = task_suspend(task);
    if (err != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "task_suspend failed with error %d (%s)\n", err,
                  mach_error_string(err));
        return false;
    }

    return true;
}

bool resume_process(pid_t pid)
{
    bool is_embedded_mode = pid == getpid();
    if (is_embedded_mode)
    {
        debug_log(LOG_ERROR, "Cannot resume self process\n");
        return false;
    }

    mach_port_t task = get_cached_task_port(pid);
    if (task == MACH_PORT_NULL)
    {
        return false;
    }

    kern_return_t err = task_resume(task);
    if (err != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "task_resume failed with error %d (%s)\n", err,
                  mach_error_string(err));
        return false;
    }

    return true;
}

static std::uint64_t get_image_size_64(int pid, mach_vm_address_t base_address)
{
    mach_header_64 header;
    if (read_memory_native(pid, base_address, sizeof(mach_header_64),
                           reinterpret_cast<unsigned char *>(&header)) <= 0)
    {
        debug_log(LOG_ERROR, "Failed to read 64-bit Mach-O header\n");
        return 0;
    }

    std::uint64_t text_size = 0;
    mach_vm_address_t current_address = base_address + sizeof(mach_header_64);

    for (int i = 0; i < header.ncmds; i++)
    {
        load_command lc;
        if (read_memory_native(pid, current_address, sizeof(load_command),
                               reinterpret_cast<unsigned char *>(&lc)) <= 0)
        {
            debug_log(LOG_ERROR, "Failed to read load command\n");
            return 0;
        }

        if (lc.cmd == LC_SEGMENT_64)
        {
            segment_command_64 seg;
            if (read_memory_native(pid, current_address, sizeof(segment_command_64),
                                   reinterpret_cast<unsigned char *>(&seg)) <= 0)
            {
                debug_log(LOG_ERROR, "Failed to read segment command\n");
                return 0;
            }
            // For dyld shared cache libraries, segments are not contiguous.
            // Return __TEXT segment size only
            if (strncmp(seg.segname, "__TEXT", 16) == 0)
            {
                text_size = seg.vmsize;
                break;
            }
        }

        current_address += lc.cmdsize;
    }

    return text_size;
}

static std::uint64_t get_image_size_32(int pid, mach_vm_address_t base_address)
{
    mach_header header;
    if (read_memory_native(pid, base_address, sizeof(mach_header),
                           reinterpret_cast<unsigned char *>(&header)) <= 0)
    {
        debug_log(LOG_ERROR, "Failed to read 32-bit Mach-O header\n");
        return 0;
    }

    std::uint64_t image_size = 0;
    mach_vm_address_t current_address = base_address + sizeof(mach_header);

    for (int i = 0; i < header.ncmds; i++)
    {
        load_command lc;
        if (read_memory_native(pid, current_address, sizeof(load_command),
                               reinterpret_cast<unsigned char *>(&lc)) <= 0)
        {
            debug_log(LOG_ERROR, "Failed to read load command\n");
            return 0;
        }

        if (lc.cmd == LC_SEGMENT)
        {
            segment_command seg;
            if (read_memory_native(pid, current_address, sizeof(segment_command),
                                   reinterpret_cast<unsigned char *>(&seg)) <= 0)
            {
                debug_log(LOG_ERROR, "Failed to read segment command\n");
                return 0;
            }
            image_size += seg.vmsize;
        }

        current_address += lc.cmdsize;
    }

    return image_size;
}

// Try to get module size using MachOBridge (for embedded/local process)
static std::uint64_t get_module_size_via_macho_bridge(mach_vm_address_t address, bool *is_64bit)
{
    // Try to get size via MachOBridge (Swift/MachOKit)
    uint64_t size = macho_get_module_size_by_address(static_cast<uint64_t>(address));
    if (size > 0)
    {
        // Determine if 64-bit by reading magic
        std::uint32_t magic = 0;
        if (read_memory_native(getpid(), address, sizeof(std::uint32_t),
                               reinterpret_cast<unsigned char *>(&magic)) > 0)
        {
            *is_64bit = (magic == MH_MAGIC_64);
        }
        else
        {
            *is_64bit = true;  // Default to 64-bit on modern systems
        }
        return size;
    }
    return 0;
}

// Check if a path is a system library (likely to be in dyld shared cache)
static bool is_system_library_path(const char *path)
{
    if (path == nullptr || path[0] == '\0')
    {
        return false;
    }

    // System library paths on iOS/macOS
    static const char *system_prefixes[] = {"/System/",
                                            "/usr/lib/",
                                            "/Library/Apple/",
                                            "/Library/Frameworks/",
                                            "/private/preboot/",  // Cryptex paths
                                            nullptr};

    for (const char **prefix = system_prefixes; *prefix != nullptr; prefix++)
    {
        if (strncmp(path, *prefix, strlen(*prefix)) == 0)
        {
            return true;
        }
    }

    return false;
}

// Try to get module size from dyld shared cache
static std::uint64_t get_module_size_from_cache(const char *module_path, bool *is_64bit)
{
    if (module_path == nullptr || module_path[0] == '\0')
    {
        return 0;
    }

    uint64_t size = macho_get_module_size_from_cache(module_path);
    if (size > 0)
    {
        *is_64bit = true;  // System libraries in cache are typically 64-bit
        return size;
    }
    return 0;
}

static std::uint64_t get_module_size(int pid, mach_vm_address_t address, bool *is_64bit,
                                     const char *module_path)
{
    // Method 1: For embedded mode (same process), try MachOBridge by address first
    if (pid == getpid())
    {
        uint64_t size = get_module_size_via_macho_bridge(address, is_64bit);
        if (size > 0)
        {
            debug_log(LOG_DEBUG, "Got module size via MachOBridge by address: 0x%llx", size);
            return size;
        }
    }

    // Method 2: If we have a system library path, try dyld cache (works for any process)
    // The dyld cache is shared across all processes on the same iOS/macOS version
    if (is_system_library_path(module_path))
    {
        uint64_t size = get_module_size_from_cache(module_path, is_64bit);
        if (size > 0)
        {
            debug_log(LOG_DEBUG, "Got module size via dyld cache: 0x%llx for %s", size,
                      module_path);
            return size;
        }
    }

    // Fallback: read directly from memory
    std::uint32_t magic;
    if (read_memory_native(pid, address, sizeof(std::uint32_t),
                           reinterpret_cast<unsigned char *>(&magic)) <= 0)
    {
        debug_log(LOG_ERROR, "Failed to read Mach-O magic number\n");
        return 0;
    }

    if (magic == MH_MAGIC_64)
    {
        *is_64bit = true;
        return get_image_size_64(pid, address);
    }
    else if (magic == MH_MAGIC)
    {
        *is_64bit = false;
        return get_image_size_32(pid, address);
    }
    else if (magic == FAT_MAGIC || magic == FAT_CIGAM)
    {
        fat_header fatHeader;
        if (read_memory_native(pid, address, sizeof(fat_header),
                               reinterpret_cast<unsigned char *>(&fatHeader)) <= 0)
        {
            debug_log(LOG_ERROR, "Failed to read FAT header\n");
            return 0;
        }

        std::vector<fat_arch> archs(fatHeader.nfat_arch);
        if (read_memory_native(pid, address + sizeof(fat_header),
                               fatHeader.nfat_arch * sizeof(fat_arch),
                               reinterpret_cast<unsigned char *>(archs.data())) <= 0)
        {
            debug_log(LOG_ERROR, "Failed to read FAT architectures\n");
            return 0;
        }

        for (const auto &arch : archs)
        {
            if (read_memory_native(pid, address + arch.offset, sizeof(std::uint32_t),
                                   reinterpret_cast<unsigned char *>(&magic)) <= 0)
            {
                debug_log(LOG_ERROR, "Failed to read Mach-O magic "
                                     "number in FAT binary\n");
                continue;
            }
            if (magic == MH_MAGIC_64)
            {
                *is_64bit = true;
                return get_image_size_64(pid, address + arch.offset);
            }
            else if (magic == MH_MAGIC)
            {
                *is_64bit = false;
                return get_image_size_32(pid, address + arch.offset);
            }
        }
    }

    debug_log(LOG_ERROR, "Unknown Mach-O format\n");
    return 0;
}

// Overload without module_path parameter
static std::uint64_t get_module_size(int pid, mach_vm_address_t address, bool *is_64bit)
{
    return get_module_size(pid, address, is_64bit, nullptr);
}

// Embedded mode: Use MachOBridge APIs directly for the current process
static ModuleInfo *enummodule_native_embedded(size_t *count)
{
    uint32_t image_count = macho_get_loaded_image_count();
    if (image_count == 0)
    {
        *count = 0;
        return nullptr;
    }

    std::vector<ModuleInfo> moduleList;
    moduleList.reserve(image_count);

    for (uint32_t i = 0; i < image_count; i++)
    {
        char *path = macho_get_loaded_image_path(i);
        uint64_t base = macho_get_loaded_image_base(i);
        uint64_t macho_kit_size = macho_get_loaded_image_size(i);

        if (base == 0)
        {
            if (path) macho_free_string(path);
            continue;
        }

        // Calculate native size for comparison
        bool is_64bit = true;
        uint64_t native_size = get_image_size_64(getpid(), static_cast<mach_vm_address_t>(base));

        // Log comparison between MachOKit and native implementation
        const char *module_name = path ? path : "Unknown";
        debug_log(LOG_INFO,
                  "Module: %s, base: 0x%llx, MachOKit size: %llu (0x%llx), "
                  "Native size: %llu (0x%llx)\n",
                  module_name, base, macho_kit_size, macho_kit_size, native_size, native_size);

        ModuleInfo module;
        module.modulename = path ? strdup(path) : strdup("Unknown");
        module.base = static_cast<std::uintptr_t>(base);
        module.size = static_cast<std::int32_t>(macho_kit_size);

        // Determine if 64-bit by reading magic
        std::uint32_t magic = 0;
        if (read_memory_native(getpid(), base, sizeof(std::uint32_t),
                               reinterpret_cast<unsigned char *>(&magic)) > 0)
        {
            module.is_64bit = (magic == MH_MAGIC_64);
        }
        else
        {
            module.is_64bit = true;  // Default to 64-bit on modern systems
        }

        moduleList.push_back(module);

        if (path) macho_free_string(path);
    }

    *count = moduleList.size();
    ModuleInfo *result = static_cast<ModuleInfo *>(malloc(*count * sizeof(ModuleInfo)));
    std::copy(moduleList.begin(), moduleList.end(), result);

    return result;
}

ModuleInfo *enumerate_modules(pid_t pid, size_t *count)
{
    task_t task;
    kern_return_t err;
    bool is_embedded_mode = pid == getpid();

    // For embedded mode, try using MachOBridge APIs first
    if (is_embedded_mode)
    {
        ModuleInfo *result = enummodule_native_embedded(count);
        if (result != nullptr && *count > 0)
        {
            return result;
        }
        // Fallback to the standard method if MachOBridge fails
        task = mach_task_self();
    }
    else
    {
        task = get_cached_task_port(pid);
        if (task == MACH_PORT_NULL)
        {
            *count = 0;
            return nullptr;
        }
    }
    task_dyld_info dyld_info;
    mach_msg_type_number_t count_info = TASK_DYLD_INFO_COUNT;

    if (task_info(task, TASK_DYLD_INFO, reinterpret_cast<task_info_t>(&dyld_info), &count_info) !=
        KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "Failed to get task info\n");
        *count = 0;
        return nullptr;
    }

    dyld_all_image_infos all_image_infos;
    if (read_memory_native(pid, dyld_info.all_image_info_addr, sizeof(dyld_all_image_infos),
                           reinterpret_cast<unsigned char *>(&all_image_infos)) <= 0)
    {
        debug_log(LOG_ERROR, "Failed to read all_image_infos\n");
        *count = 0;
        return nullptr;
    }

    std::vector<dyld_image_info> image_infos(all_image_infos.infoArrayCount);
    if (read_memory_native(pid, reinterpret_cast<mach_vm_address_t>(all_image_infos.infoArray),
                           sizeof(dyld_image_info) * all_image_infos.infoArrayCount,
                           reinterpret_cast<unsigned char *>(image_infos.data())) <= 0)
    {
        debug_log(LOG_ERROR, "Failed to read image_infos\n");
        *count = 0;
        return nullptr;
    }

    std::vector<ModuleInfo> moduleList;
    moduleList.reserve(all_image_infos.infoArrayCount);

    for (const auto &info : image_infos)
    {
        char fpath[PATH_MAX];
        if (read_memory_native(pid, reinterpret_cast<mach_vm_address_t>(info.imageFilePath),
                               PATH_MAX, reinterpret_cast<unsigned char *>(fpath)) > 0)
        {
            ModuleInfo module;
            if (strlen(fpath) == 0 && proc_regionfilename != nullptr)
            {
                char buffer[PATH_MAX];
                int ret =
                    proc_regionfilename(pid, reinterpret_cast<std::uint64_t>(info.imageLoadAddress),
                                        buffer, sizeof(buffer));
                module.modulename = strdup(ret > 0 ? buffer : "None");
            }
            else
            {
                module.modulename = strdup(fpath);
            }

            module.base = reinterpret_cast<std::uintptr_t>(info.imageLoadAddress);
            // Pass module path to get_module_size for better size calculation
            module.size = static_cast<std::int32_t>(
                get_module_size(pid, static_cast<mach_vm_address_t>(module.base), &module.is_64bit,
                                module.modulename));

            moduleList.push_back(module);
        }
    }

    *count = moduleList.size();
    ModuleInfo *result = static_cast<ModuleInfo *>(malloc(*count * sizeof(ModuleInfo)));
    std::copy(moduleList.begin(), moduleList.end(), result);

    return result;
}

int native_init(int mode)
{
#if defined(ENABLE_LOG_DEVELOP) && defined(BUILD_TIMESTAMP)
    // debug_log_develop(LOG_INFO, "=== Native Library Initialized ===");
    // debug_log_develop(LOG_INFO, "Build timestamp: %s", BUILD_TIMESTAMP);
    // debug_log_develop(LOG_INFO, "==================================");
#endif

    global_server_state.mode = mode;
    void *libsystem_kernel = dlopen("/usr/lib/system/libsystem_kernel.dylib", RTLD_NOW);
    if (!libsystem_kernel)
    {
        debug_log(LOG_ERROR, "Failed to load libsystem_kernel.dylib: %s\n", dlerror());
        return -1;
    }

    // Clear any existing error
    dlerror();

    proc_pidpath = (PROC_PIDPATH)dlsym(libsystem_kernel, "proc_pidpath");
    char *dlsym_error = dlerror();
    if (dlsym_error)
    {
        debug_log(LOG_ERROR, "Failed to load proc_pidpath symbol: %s\n", dlsym_error);
        proc_pidpath = nullptr;
    }

    if (proc_pidpath == nullptr)
    {
        debug_log(LOG_ERROR, "proc_pidpath is not available. Some functionality "
                             "may be limited.\n");
    }

    proc_regionfilename = (PROC_REGIONFILENAME)dlsym(libsystem_kernel, "proc_regionfilename");
    dlsym_error = dlerror();
    if (dlsym_error)
    {
        debug_log(LOG_ERROR, "Failed to load proc_regionfilename symbol: %s\n", dlsym_error);
        proc_regionfilename = nullptr;
    }

    if (proc_regionfilename == nullptr)
    {
        debug_log(LOG_ERROR, "proc_regionfilename is not available. Some "
                             "functionality may be limited.\n");
    }
    return 1;
}

// Helper function to get symbol type string
static const char *get_symbol_type_string(uint8_t n_type)
{
    switch (n_type & N_TYPE)
    {
        case N_UNDF:
            return "Undefined";
        case N_ABS:
            return "Absolute";
        case N_SECT:
            return "Section";
        case N_PBUD:
            return "Prebound";
        case N_INDR:
            return "Indirect";
        default:
            return "Unknown";
    }
}

// Helper function to get symbol scope string
static const char *get_symbol_scope_string(uint8_t n_type)
{
    if (n_type & N_EXT)
    {
        return "Global";
    }
    else
    {
        return "Local";
    }
}

// Parse symbols from a Mach-O image in memory
static std::vector<SymbolInfo> parse_macho_symbols_in_memory(int pid,
                                                             mach_vm_address_t base_address,
                                                             bool is_64bit)
{
    std::vector<SymbolInfo> symbols;

    if (is_64bit)
    {
        mach_header_64 header;
        if (read_memory_native(pid, base_address, sizeof(mach_header_64),
                               reinterpret_cast<unsigned char *>(&header)) <= 0)
        {
            debug_log(LOG_ERROR, "Failed to read 64-bit Mach-O header");
            return symbols;
        }

        mach_vm_address_t current_address = base_address + sizeof(mach_header_64);

        for (uint32_t i = 0; i < header.ncmds; i++)
        {
            load_command lc;
            if (read_memory_native(pid, current_address, sizeof(load_command),
                                   reinterpret_cast<unsigned char *>(&lc)) <= 0)
            {
                debug_log(LOG_ERROR, "Failed to read load command");
                break;
            }

            if (lc.cmd == LC_SYMTAB)
            {
                symtab_command symtab;
                if (read_memory_native(pid, current_address, sizeof(symtab_command),
                                       reinterpret_cast<unsigned char *>(&symtab)) <= 0)
                {
                    debug_log(LOG_ERROR, "Failed to read symtab command");
                    current_address += lc.cmdsize;
                    continue;
                }

                // Read symbol table
                std::vector<nlist_64> symbol_table(symtab.nsyms);
                mach_vm_address_t symtab_addr = base_address + symtab.symoff;
                if (read_memory_native(pid, symtab_addr, symtab.nsyms * sizeof(nlist_64),
                                       reinterpret_cast<unsigned char *>(symbol_table.data())) <= 0)
                {
                    debug_log(LOG_ERROR, "Failed to read symbol table");
                    current_address += lc.cmdsize;
                    continue;
                }

                // Read string table
                std::vector<char> string_table(symtab.strsize);
                mach_vm_address_t strtab_addr = base_address + symtab.stroff;
                if (read_memory_native(pid, strtab_addr, symtab.strsize,
                                       reinterpret_cast<unsigned char *>(string_table.data())) <= 0)
                {
                    debug_log(LOG_ERROR, "Failed to read string table");
                    current_address += lc.cmdsize;
                    continue;
                }

                // Parse symbols
                for (uint32_t j = 0; j < symtab.nsyms; j++)
                {
                    const nlist_64 &sym = symbol_table[j];

                    // Skip debug symbols and undefined symbols
                    if ((sym.n_type & N_STAB) || (sym.n_type & N_TYPE) == N_UNDF)
                    {
                        continue;
                    }

                    // Skip symbols without names
                    if (sym.n_un.n_strx == 0 || sym.n_un.n_strx >= symtab.strsize)
                    {
                        continue;
                    }

                    SymbolInfo symbol_info;
                    symbol_info.address = sym.n_value;
                    symbol_info.name = strdup(&string_table[sym.n_un.n_strx]);
                    symbol_info.size = 0;  // Size information not directly
                                           // available in Mach-O
                    symbol_info.type = strdup(get_symbol_type_string(sym.n_type));
                    symbol_info.scope = strdup(get_symbol_scope_string(sym.n_type));
                    symbol_info.module_base = base_address;
                    symbol_info.file_name = strdup("");  // File name not easily available
                    symbol_info.line_number = 0;         // Line number not available in
                                                         // symbol table

                    symbols.push_back(symbol_info);
                }
            }

            current_address += lc.cmdsize;
        }
    }
    else
    {
        // Similar implementation for 32-bit Mach-O
        mach_header header;
        if (read_memory_native(pid, base_address, sizeof(mach_header),
                               reinterpret_cast<unsigned char *>(&header)) <= 0)
        {
            debug_log(LOG_ERROR, "Failed to read 32-bit Mach-O header");
            return symbols;
        }

        mach_vm_address_t current_address = base_address + sizeof(mach_header);

        for (uint32_t i = 0; i < header.ncmds; i++)
        {
            load_command lc;
            if (read_memory_native(pid, current_address, sizeof(load_command),
                                   reinterpret_cast<unsigned char *>(&lc)) <= 0)
            {
                debug_log(LOG_ERROR, "Failed to read load command");
                break;
            }

            if (lc.cmd == LC_SYMTAB)
            {
                symtab_command symtab;
                if (read_memory_native(pid, current_address, sizeof(symtab_command),
                                       reinterpret_cast<unsigned char *>(&symtab)) <= 0)
                {
                    debug_log(LOG_ERROR, "Failed to read symtab command");
                    current_address += lc.cmdsize;
                    continue;
                }

                // Read symbol table
                std::vector<struct nlist> symbol_table(symtab.nsyms);
                mach_vm_address_t symtab_addr = base_address + symtab.symoff;
                if (read_memory_native(pid, symtab_addr, symtab.nsyms * sizeof(struct nlist),
                                       reinterpret_cast<unsigned char *>(symbol_table.data())) <= 0)
                {
                    debug_log(LOG_ERROR, "Failed to read symbol table");
                    current_address += lc.cmdsize;
                    continue;
                }

                // Read string table
                std::vector<char> string_table(symtab.strsize);
                mach_vm_address_t strtab_addr = base_address + symtab.stroff;
                if (read_memory_native(pid, strtab_addr, symtab.strsize,
                                       reinterpret_cast<unsigned char *>(string_table.data())) <= 0)
                {
                    debug_log(LOG_ERROR, "Failed to read string table");
                    current_address += lc.cmdsize;
                    continue;
                }

                // Parse symbols
                for (uint32_t j = 0; j < symtab.nsyms; j++)
                {
                    const struct nlist &sym = symbol_table[j];

                    // Skip debug symbols and undefined symbols
                    if ((sym.n_type & N_STAB) || (sym.n_type & N_TYPE) == N_UNDF)
                    {
                        continue;
                    }

                    // Skip symbols without names
                    if (sym.n_un.n_strx == 0 || sym.n_un.n_strx >= symtab.strsize)
                    {
                        continue;
                    }

                    SymbolInfo symbol_info;
                    symbol_info.address = sym.n_value;
                    symbol_info.name = strdup(&string_table[sym.n_un.n_strx]);
                    symbol_info.size = 0;  // Size information not directly
                                           // available in Mach-O
                    symbol_info.type = strdup(get_symbol_type_string(sym.n_type));
                    symbol_info.scope = strdup(get_symbol_scope_string(sym.n_type));
                    symbol_info.module_base = base_address;
                    symbol_info.file_name = strdup("");  // File name not easily available
                    symbol_info.line_number = 0;         // Line number not available in
                                                         // symbol table

                    symbols.push_back(symbol_info);
                }
            }

            current_address += lc.cmdsize;
        }
    }

    return symbols;
}

SymbolInfo *enumerate_symbols(int pid, uintptr_t module_base, size_t *count)
{
    *count = 0;

    debug_log(LOG_INFO, "Enumerating symbols for module at base address 0x%lx in pid %d",
              module_base, pid);

    // First, determine if this is a 64-bit or 32-bit binary
    bool is_64bit = false;
    std::uint64_t module_size =
        get_module_size(pid, static_cast<mach_vm_address_t>(module_base), &is_64bit);

    if (module_size == 0)
    {
        debug_log(LOG_ERROR, "Failed to determine module size for base address 0x%lx", module_base);
        return nullptr;
    }

    debug_log(LOG_INFO, "Module is %s-bit, size: 0x%llx", is_64bit ? "64" : "32", module_size);

    // Parse symbols from the Mach-O image in memory
    std::vector<SymbolInfo> symbols =
        parse_macho_symbols_in_memory(pid, static_cast<mach_vm_address_t>(module_base), is_64bit);

    if (symbols.empty())
    {
        debug_log(LOG_WARN, "No symbols found in module at base address 0x%lx", module_base);
        return nullptr;
    }

    // Sort symbols by address
    std::sort(symbols.begin(), symbols.end(),
              [](const SymbolInfo &a, const SymbolInfo &b) { return a.address < b.address; });

    // Allocate C array for return
    SymbolInfo *result = static_cast<SymbolInfo *>(malloc(symbols.size() * sizeof(SymbolInfo)));
    if (!result)
    {
        debug_log(LOG_ERROR, "Failed to allocate memory for symbols array");
        // Free allocated strings
        for (auto &sym : symbols)
        {
            free(sym.name);
            free(sym.type);
            free(sym.scope);
            free(sym.file_name);
        }
        return nullptr;
    }

    // Copy symbols to C array
    for (size_t i = 0; i < symbols.size(); i++)
    {
        result[i] = symbols[i];
    }

    *count = symbols.size();
    debug_log(LOG_INFO, "Successfully enumerated %zu symbols from module at base address 0x%lx",
              *count, module_base);

    return result;
}

// Thread state names
static const char *get_thread_state_string(int state)
{
    switch (state)
    {
        case TH_STATE_RUNNING:
            return "Running";
        case TH_STATE_STOPPED:
            return "Stopped";
        case TH_STATE_WAITING:
            return "Waiting";
        case TH_STATE_UNINTERRUPTIBLE:
            return "Uninterruptible";
        case TH_STATE_HALTED:
            return "Halted";
        default:
            return "Unknown";
    }
}

ThreadInfo *enumerate_threads(pid_t pid, size_t *count)
{
    *count = 0;
    kern_return_t kr;

    mach_port_t task = get_cached_task_port(pid);
    if (task == MACH_PORT_NULL)
    {
        return nullptr;
    }

    thread_act_array_t thread_list;
    mach_msg_type_number_t thread_count;

    kr = task_threads(task, &thread_list, &thread_count);
    if (kr != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "task_threads failed: %s", mach_error_string(kr));
        return nullptr;
    }

    if (thread_count == 0)
    {
        vm_deallocate(mach_task_self(), (vm_address_t)thread_list,
                      thread_count * sizeof(thread_act_t));
        return nullptr;
    }

    ThreadInfo *threads = static_cast<ThreadInfo *>(malloc(thread_count * sizeof(ThreadInfo)));
    if (!threads)
    {
        debug_log(LOG_ERROR, "Failed to allocate memory for thread info");
        for (mach_msg_type_number_t i = 0; i < thread_count; i++)
        {
            mach_port_deallocate(mach_task_self(), thread_list[i]);
        }
        vm_deallocate(mach_task_self(), (vm_address_t)thread_list,
                      thread_count * sizeof(thread_act_t));
        return nullptr;
    }

    for (mach_msg_type_number_t i = 0; i < thread_count; i++)
    {
        thread_act_t thread = thread_list[i];
        ThreadInfo *info = &threads[i];

        // Initialize
        info->thread_id = thread;
        info->name = nullptr;
        info->pc = 0;
        info->sp = 0;
        info->fp = 0;
        info->state = 0;
        info->suspend_count = 0;

        // Get thread basic info
        thread_basic_info_data_t basic_info;
        mach_msg_type_number_t info_count = THREAD_BASIC_INFO_COUNT;
        kr = thread_info(thread, THREAD_BASIC_INFO, (thread_info_t)&basic_info, &info_count);
        if (kr == KERN_SUCCESS)
        {
            info->state = basic_info.run_state;
            info->suspend_count = basic_info.suspend_count;
        }

        // Get thread identifier info (for thread name)
        thread_identifier_info_data_t id_info;
        info_count = THREAD_IDENTIFIER_INFO_COUNT;
        kr = thread_info(thread, THREAD_IDENTIFIER_INFO, (thread_info_t)&id_info, &info_count);
        if (kr == KERN_SUCCESS)
        {
            // Keep using mach_port_t for thread_id (needed for debugger
            // operations) info->thread_id = id_info.thread_id;  // Don't override
            // - keep mach_port_t

            // Try to get pthread name first
            char pthread_name[64] = {0};
            bool got_name = false;

            // Get the pthread handle from the thread port
            pthread_t pthread_handle = pthread_from_mach_thread_np(thread);
            if (pthread_handle != NULL)
            {
                if (pthread_getname_np(pthread_handle, pthread_name, sizeof(pthread_name)) == 0 &&
                    pthread_name[0] != '\0')
                {
                    info->name = strdup(pthread_name);
                    got_name = true;
                }
            }

            // If no pthread name, try dispatch queue name (only for embedded
            // mode) For remote processes, dispatch_queue is a remote address and
            // cannot be dereferenced
            if (!got_name && id_info.dispatch_qaddr != 0)
            {
                bool is_embedded_mode = pid == getpid();
                if (is_embedded_mode)
                {
                    // Only safe to read dispatch queue in embedded mode
                    void *dispatch_queue = *(void **)id_info.dispatch_qaddr;
                    if (dispatch_queue != nullptr)
                    {
                        const char *queue_label =
                            dispatch_queue_get_label((dispatch_queue_t)dispatch_queue);
                        if (queue_label != nullptr && queue_label[0] != '\0')
                        {
                            info->name = strdup(queue_label);
                            got_name = true;
                        }
                    }
                }
                // For remote processes, skip dispatch queue reading to avoid
                // segfault
            }

            // Fallback to thread ID (use mach_port_t for consistency with
            // thread_id field)
            if (!got_name)
            {
                char name_buf[128];
                snprintf(name_buf, sizeof(name_buf), "Thread %u", thread);
                info->name = strdup(name_buf);
            }
        }
        else
        {
            char name_buf[64];
            snprintf(name_buf, sizeof(name_buf), "Thread %u", thread);
            info->name = strdup(name_buf);
        }

#if defined(__arm64__) || defined(__aarch64__)
        // Get ARM64 thread state for PC/SP/FP
        arm_thread_state64_t arm_state;
        mach_msg_type_number_t state_count = ARM_THREAD_STATE64_COUNT;
        kr = thread_get_state(thread, ARM_THREAD_STATE64, (thread_state_t)&arm_state, &state_count);
        if (kr == KERN_SUCCESS)
        {
            info->fp = arm_state.__fp;
            info->sp = arm_state.__sp;
            info->pc = arm_state.__pc;
        }
#elif defined(__x86_64__)
        // Get x86_64 thread state for PC/SP/FP
        x86_thread_state64_t x86_state;
        mach_msg_type_number_t state_count = x86_THREAD_STATE64_COUNT;
        kr = thread_get_state(thread, x86_THREAD_STATE64, (thread_state_t)&x86_state, &state_count);
        if (kr == KERN_SUCCESS)
        {
            info->pc = x86_state.__rip;
            info->sp = x86_state.__rsp;
            info->fp = x86_state.__rbp;
        }
#endif

        mach_port_deallocate(mach_task_self(), thread);
    }

    vm_deallocate(mach_task_self(), (vm_address_t)thread_list, thread_count * sizeof(thread_act_t));

    *count = thread_count;
    debug_log(LOG_INFO, "Successfully enumerated %zu threads for pid %d", *count, pid);

    return threads;
}

void free_thread_info(ThreadInfo *threads, size_t count)
{
    if (threads)
    {
        for (size_t i = 0; i < count; i++)
        {
            if (threads[i].name)
            {
                free(threads[i].name);
            }
        }
        free(threads);
    }
}

// ==================== Compatibility functions for Rust native_bridge.rs ====================

extern "C" RegionInfo *enumerate_regions(pid_t pid, size_t *count)
{
    *count = 0;

    mach_port_t task = get_cached_task_port(pid);
    if (task == MACH_PORT_NULL)
    {
        debug_log(LOG_ERROR, "Failed to get task for pid %d", pid);
        return nullptr;
    }

    std::vector<RegionInfo> regions;
    vm_address_t address = 0;
    vm_size_t size = 0;
    natural_t depth = 1;
    char buf[PATH_MAX];

    while (true)
    {
        vm_region_submap_info_data_64_t info;
        mach_msg_type_number_t info_count = VM_REGION_SUBMAP_INFO_COUNT_64;

        if (vm_region_recurse_64(task, &address, &size, &depth, (vm_region_info_t)&info,
                                 &info_count) != KERN_SUCCESS)
        {
            break;
        }

        if (info.is_submap)
        {
            depth++;
        }
        else
        {
            RegionInfo region;
            region.start = address;
            region.end = address + size;

            // Convert VM_PROT_* to PROT_* style (READ=1, WRITE=2, EXEC=4)
            region.protection = 0;
            if (info.protection & VM_PROT_READ) region.protection |= 1;
            if (info.protection & VM_PROT_WRITE) region.protection |= 2;
            if (info.protection & VM_PROT_EXECUTE) region.protection |= 4;

            // Get pathname
            memset(buf, 0, PATH_MAX);
            int ret = proc_regionfilename(pid, static_cast<unsigned long long>(address), buf,
                                          sizeof(buf));
            if (ret > 0 && buf[0] != '\0')
            {
                region.pathname = strdup(buf);
            }
            else
            {
                region.pathname = nullptr;
            }

            regions.push_back(region);
            address += size;
        }
    }

    if (regions.empty())
    {
        return nullptr;
    }

    RegionInfo *result = static_cast<RegionInfo *>(malloc(regions.size() * sizeof(RegionInfo)));
    if (!result)
    {
        debug_log(LOG_ERROR, "Failed to allocate memory for region info array");
        for (auto &r : regions)
        {
            if (r.pathname) free(r.pathname);
        }
        return nullptr;
    }

    for (size_t i = 0; i < regions.size(); i++)
    {
        result[i] = regions[i];
    }

    *count = regions.size();
    return result;
}

extern "C" void free_region_info(RegionInfo *regions, size_t count)
{
    if (regions)
    {
        for (size_t i = 0; i < count; i++)
        {
            if (regions[i].pathname)
            {
                free(regions[i].pathname);
            }
        }
        free(regions);
    }
}

```

`src/server/src/cpp/src/darwin/core/process_api.h`:

```h
/**
 * @file process_api.h
 * @brief Process spawning and management API for Darwin/iOS
 *
 * This header provides process lifecycle management:
 * - App spawning (via FrontBoardServices on iOS)
 * - Process termination
 * - Process resume
 * - Running status queries
 *
 * Note: These APIs are primarily for iOS. macOS stubs are provided
 * for compatibility.
 */

#ifndef DARWIN_PROCESS_API_H
#define DARWIN_PROCESS_API_H

#import <Foundation/Foundation.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * Spawn an application by bundle identifier
 * @param bundle_identifier The app's bundle identifier (e.g., "com.example.app")
 * @param suspended If non-zero, spawn the app in suspended state
 * @return JSON string with result: {"success":true,"pid":1234} or {"success":false,"error":"..."}
 *         Caller must free the returned string.
 */
const char* spawn_app_native(const char* bundle_identifier, int suspended);

/**
 * Terminate a process by PID
 * @param pid Process ID to terminate
 * @return 1 on success, 0 on failure
 */
int terminate_app_native(int pid);

/**
 * Resume a suspended process
 * @param pid Process ID to resume
 * @return JSON string with result: {"success":true,"pid":1234,"resumed":true} or error
 *         Caller must free the returned string.
 */
const char* resume_app_native(int pid);

/**
 * Get running status of an app by bundle identifier
 * @param bundle_identifier The app's bundle identifier
 * @return JSON string: {"success":true,"bundleIdentifier":"...","running":true/false,"pid":1234}
 *         Caller must free the returned string.
 */
const char* get_app_running_status_native(const char* bundle_identifier);

#ifdef __cplusplus
}
#endif

#ifdef __OBJC__

/**
 * Objective-C interface for app spawning
 */
@interface AppSpawner : NSObject

/**
 * Spawn an application
 * @param bundleIdentifier The app's bundle identifier
 * @param suspended Whether to spawn in suspended state
 * @return Dictionary with "success", "pid" or "error" keys
 */
+ (NSDictionary*)spawnApp:(NSString*)bundleIdentifier suspended:(BOOL)suspended;

/**
 * Terminate an application
 * @param bundleIdentifier The app's bundle identifier
 * @return YES on success, NO on failure
 */
+ (BOOL)terminateApp:(NSString*)bundleIdentifier;

@end

#endif  // __OBJC__

#endif  // DARWIN_PROCESS_API_H

```

`src/server/src/cpp/src/darwin/core/process_api.mm`:

```mm
/**
 * @file process_api.mm
 * @brief Process spawning and management API implementation for Darwin/iOS
 *
 * This file provides process lifecycle management for iOS using FrontBoardServices.
 * macOS stubs are provided for compatibility.
 */

#include "process_api.h"
#include "native_api.h"

#import <Foundation/Foundation.h>
#import <mach/mach.h>
#import <mach/mach_error.h>
#import <signal.h>
#import <unistd.h>

#if TARGET_OS_IPHONE || TARGET_OS_IOS

#import <dlfcn.h>
#import <objc/message.h>
#import <objc/runtime.h>

// Watchdog assertion type (from BackBoardServices)
typedef void* BKSWatchdogAssertionRef;

// Function pointer types for watchdog
typedef BKSWatchdogAssertionRef (*BKSWatchdogAssertionCreateForPIDFunc)(CFAllocatorRef, pid_t);
typedef void (*BKSWatchdogAssertionRenewFunc)(BKSWatchdogAssertionRef);
typedef CFTimeInterval (*BKSWatchdogAssertionGetRenewalIntervalFunc)(BKSWatchdogAssertionRef);

// SpringBoard API structure for dynamically loaded symbols
typedef struct
{
    void* fbsHandle;
    void* bbsHandle;

    // Classes
    Class FBSSystemService;

    // FBS constants (loaded via dlsym)
    NSString* FBSOpenApplicationOptionKeyUnlockDevice;
    NSString* FBSOpenApplicationOptionKeyDebuggingOptions;
    NSString* FBSDebugOptionKeyArguments;
    NSString* FBSDebugOptionKeyEnvironment;
    NSString* FBSDebugOptionKeyStandardOutPath;
    NSString* FBSDebugOptionKeyStandardErrorPath;
    NSString* FBSDebugOptionKeyDisableASLR;

    // Watchdog functions (loaded via dlsym from BBS)
    BKSWatchdogAssertionCreateForPIDFunc BKSWatchdogAssertionCreateForPID;
    BKSWatchdogAssertionRenewFunc BKSWatchdogAssertionRenew;
    BKSWatchdogAssertionGetRenewalIntervalFunc BKSWatchdogAssertionGetRenewalInterval;
} SpringBoardAPI;

static SpringBoardAPI* g_processSpringboardAPI = NULL;

// Helper macro to load FBS constant from framework
#define LOAD_FBS_CONSTANT(api, name)                                     \
    do                                                                   \
    {                                                                    \
        NSString** ptr = (NSString**)dlsym((api)->fbsHandle, #name);     \
        if (ptr != NULL)                                                 \
        {                                                                \
            (api)->name = *ptr;                                          \
        }                                                                \
        else                                                             \
        {                                                                \
            debug_log(LOG_WARN, "Failed to load FBS constant: " #name);  \
        }                                                                \
    } while (0)

static SpringBoardAPI* getProcessSpringBoardAPI(void)
{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
      g_processSpringboardAPI = (SpringBoardAPI*)calloc(1, sizeof(SpringBoardAPI));
      if (!g_processSpringboardAPI) return;

      // Load FrontBoardServices framework
      g_processSpringboardAPI->fbsHandle = dlopen(
          "/System/Library/PrivateFrameworks/FrontBoardServices.framework/FrontBoardServices",
          RTLD_NOW | RTLD_GLOBAL);

      if (!g_processSpringboardAPI->fbsHandle)
      {
          debug_log(LOG_ERROR, "Failed to load FrontBoardServices framework");
          free(g_processSpringboardAPI);
          g_processSpringboardAPI = NULL;
          return;
      }

      // Load BackBoardServices framework (optional)
      g_processSpringboardAPI->bbsHandle =
          dlopen("/System/Library/PrivateFrameworks/BackBoardServices.framework/BackBoardServices",
                 RTLD_NOW | RTLD_GLOBAL);

      // Load FBSSystemService class
      g_processSpringboardAPI->FBSSystemService = NSClassFromString(@"FBSSystemService");
      if (!g_processSpringboardAPI->FBSSystemService)
      {
          debug_log(LOG_ERROR, "FBSSystemService class not found");
      }

      // Load FBS constants dynamically
      LOAD_FBS_CONSTANT(g_processSpringboardAPI, FBSOpenApplicationOptionKeyUnlockDevice);
      LOAD_FBS_CONSTANT(g_processSpringboardAPI, FBSOpenApplicationOptionKeyDebuggingOptions);
      LOAD_FBS_CONSTANT(g_processSpringboardAPI, FBSDebugOptionKeyArguments);
      LOAD_FBS_CONSTANT(g_processSpringboardAPI, FBSDebugOptionKeyEnvironment);
      LOAD_FBS_CONSTANT(g_processSpringboardAPI, FBSDebugOptionKeyStandardOutPath);
      LOAD_FBS_CONSTANT(g_processSpringboardAPI, FBSDebugOptionKeyStandardErrorPath);
      LOAD_FBS_CONSTANT(g_processSpringboardAPI, FBSDebugOptionKeyDisableASLR);

      // Load watchdog functions from BackBoardServices
      if (g_processSpringboardAPI->bbsHandle)
      {
          g_processSpringboardAPI->BKSWatchdogAssertionCreateForPID =
              (BKSWatchdogAssertionCreateForPIDFunc)dlsym(g_processSpringboardAPI->bbsHandle,
                                                          "BKSWatchdogAssertionCreateForPID");
          g_processSpringboardAPI->BKSWatchdogAssertionRenew =
              (BKSWatchdogAssertionRenewFunc)dlsym(g_processSpringboardAPI->bbsHandle,
                                                   "BKSWatchdogAssertionRenew");
          g_processSpringboardAPI->BKSWatchdogAssertionGetRenewalInterval =
              (BKSWatchdogAssertionGetRenewalIntervalFunc)dlsym(
                  g_processSpringboardAPI->bbsHandle, "BKSWatchdogAssertionGetRenewalInterval");

          if (g_processSpringboardAPI->BKSWatchdogAssertionCreateForPID)
          {
              debug_log(LOG_INFO, "Watchdog assertion functions loaded successfully");
          }
          else
          {
              debug_log(LOG_WARN, "Failed to load watchdog assertion functions");
          }
      }

      debug_log(LOG_INFO, "Process SpringBoard API initialized successfully");
    });

    return g_processSpringboardAPI;
}

// Kill application before spawn
static void killApplicationBeforeSpawn(id systemService, NSString* bundleIdentifier)
{
    SEL pidSelector = @selector(pidForApplication:);

    if (![systemService respondsToSelector:pidSelector]) return;

    pid_t existingPid = (pid_t)((NSInteger(*)(id, SEL, NSString*))objc_msgSend)(
        systemService, pidSelector, bundleIdentifier);

    if (existingPid > 0)
    {
        debug_log(LOG_INFO, "Terminating existing instance of %s (PID: %d)",
                  [bundleIdentifier UTF8String], existingPid);

        // Use kill() to terminate the process
        if (kill(existingPid, SIGKILL) == 0)
        {
            // Wait for process to terminate
            for (int i = 0; i < 30; i++)  // 3 seconds max
            {
                usleep(100000);  // 100ms
                pid_t pid = (pid_t)((NSInteger(*)(id, SEL, NSString*))objc_msgSend)(
                    systemService, pidSelector, bundleIdentifier);
                if (pid <= 0)
                {
                    debug_log(LOG_INFO, "Application terminated successfully");
                    break;
                }
            }
        }
        else
        {
            debug_log(LOG_WARN, "Failed to kill process %d: %s", existingPid, strerror(errno));
        }
    }
}

@implementation AppSpawner

+ (NSDictionary*)spawnApp:(NSString*)bundleIdentifier suspended:(BOOL)suspended
{
    NSMutableDictionary* result = [NSMutableDictionary dictionary];

    @try
    {
        SpringBoardAPI* api = getProcessSpringBoardAPI();
        if (!api)
        {
            result[@"success"] = @NO;
            result[@"error"] = @"Failed to initialize SpringBoard API";
            return result;
        }

        if (!api->FBSSystemService)
        {
            result[@"success"] = @NO;
            result[@"error"] = @"FBSSystemService class not found";
            return result;
        }

        id systemService = [api->FBSSystemService sharedService];
        if (!systemService)
        {
            result[@"success"] = @NO;
            result[@"error"] = @"Failed to get FBSSystemService shared instance";
            return result;
        }

        // Kill existing instance first
        killApplicationBeforeSpawn(systemService, bundleIdentifier);

        // Build debug options dictionary
        NSMutableDictionary* debugOptions = [NSMutableDictionary dictionary];

        if (suspended && api->FBSDebugOptionKeyDisableASLR)
        {
            // Use FBSDebugOptionKeyDisableASLR as debug option
            // This triggers the debug path in SpringBoard
            debugOptions[api->FBSDebugOptionKeyDisableASLR] = @YES;
        }

        // Build the main options dictionary
        NSMutableDictionary* openOptions = [NSMutableDictionary dictionary];

        // Set unlock device option
        if (api->FBSOpenApplicationOptionKeyUnlockDevice)
        {
            openOptions[api->FBSOpenApplicationOptionKeyUnlockDevice] = @YES;
        }

        // Set debugging options
        if (debugOptions.count > 0 && api->FBSOpenApplicationOptionKeyDebuggingOptions)
        {
            openOptions[api->FBSOpenApplicationOptionKeyDebuggingOptions] = debugOptions;
        }

        debug_log(LOG_INFO, "Spawning app: %s (suspended: %d)", [bundleIdentifier UTF8String],
                  suspended);
        debug_log(LOG_DEBUG, "Options: %s", [[openOptions description] UTF8String]);

        // Create client port (critical for proper FBS communication)
        SEL createClientPortSelector = @selector(createClientPort);
        SEL cleanupClientPortSelector = @selector(cleanupClientPort:);

        mach_port_t clientPort = MACH_PORT_NULL;

        if ([systemService respondsToSelector:createClientPortSelector])
        {
            clientPort = (mach_port_t)((NSInteger(*)(id, SEL))objc_msgSend)(
                systemService, createClientPortSelector);
            debug_log(LOG_DEBUG, "Created client port: %d", clientPort);
        }
        else
        {
            debug_log(LOG_WARN, "createClientPort not available, trying without it");
        }

        // Use dispatch semaphore for synchronous operation
        __block NSError* launchError = nil;
        __block BOOL launchCompleted = NO;
        dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);

        // Result callback block
        void (^resultCallback)(NSError*) = ^(NSError* error) {
          launchError = error;
          launchCompleted = YES;
          dispatch_semaphore_signal(semaphore);
        };

        // Try openApplication:options:clientPort:withResult: first (4 argument version)
        SEL openWithClientPortSelector = @selector(openApplication:options:clientPort:withResult:);
        SEL openWithoutClientPortSelector = @selector(openApplication:options:withResult:);
        SEL pidSelector = @selector(pidForApplication:);

        // For suspended spawn, we need to start monitoring for PID immediately
        // and suspend the task as soon as we get it
        __block pid_t suspendedPid = 0;
        __block BOOL pidSuspended = NO;
        __block BOOL stopMonitoring = NO;

        dispatch_queue_t monitorQueue = NULL;

        if (suspended && [systemService respondsToSelector:pidSelector])
        {
            // Start PID monitoring in background BEFORE launching
            monitorQueue =
                dispatch_queue_create("com.dynadbg.pid_monitor", DISPATCH_QUEUE_SERIAL);

            dispatch_async(monitorQueue, ^{
              debug_log(LOG_DEBUG, "Starting PID monitor for suspended spawn");

              // Poll for PID at high frequency
              for (int i = 0; i < 500 && !stopMonitoring; i++)  // 5 seconds max
              {
                  pid_t pid = (pid_t)((NSInteger(*)(id, SEL, NSString*))objc_msgSend)(
                      systemService, pidSelector, bundleIdentifier);

                  if (pid > 0)
                  {
                      debug_log(LOG_DEBUG, "Monitor found PID: %d at iteration %d", pid, i);

                      // Immediately try to suspend
                      mach_port_t task = MACH_PORT_NULL;
                      kern_return_t kr = task_for_pid(mach_task_self(), pid, &task);

                      if (kr == KERN_SUCCESS && task != MACH_PORT_NULL)
                      {
                          // Suspend the task
                          kr = task_suspend(task);
                          if (kr == KERN_SUCCESS)
                          {
                              debug_log(LOG_INFO, "Task suspended successfully for PID: %d", pid);
                              suspendedPid = pid;
                              pidSuspended = YES;

                              // Create watchdog assertion to prevent iOS from killing
                              // the suspended app
                              if (api->BKSWatchdogAssertionCreateForPID)
                              {
                                  BKSWatchdogAssertionRef watchdog =
                                      api->BKSWatchdogAssertionCreateForPID(kCFAllocatorDefault,
                                                                            pid);
                                  if (watchdog)
                                  {
                                      debug_log(LOG_INFO,
                                                "Watchdog assertion created for PID: %d", pid);
                                      // Renew the assertion immediately
                                      if (api->BKSWatchdogAssertionRenew)
                                      {
                                          api->BKSWatchdogAssertionRenew(watchdog);
                                      }
                                      // Note: We intentionally don't release the watchdog here
                                      // It will be released when the process is resumed or
                                      // terminated
                                  }
                                  else
                                  {
                                      debug_log(LOG_WARN,
                                                "Failed to create watchdog assertion");
                                  }
                              }
                          }
                          else
                          {
                              debug_log(LOG_WARN, "Failed to suspend task: %s",
                                        mach_error_string(kr));
                          }
                          mach_port_deallocate(mach_task_self(), task);
                      }
                      break;
                  }
                  usleep(10000);  // 10ms polling interval
              }
            });
        }

        // Try launching with client port first
        BOOL launched = NO;
        if (clientPort != MACH_PORT_NULL &&
            [systemService respondsToSelector:openWithClientPortSelector])
        {
            ((void (*)(id, SEL, NSString*, NSDictionary*, mach_port_t,
                       void (^)(NSError*)))objc_msgSend)(systemService, openWithClientPortSelector,
                                                         bundleIdentifier, openOptions, clientPort,
                                                         resultCallback);
            launched = YES;
        }
        else if ([systemService respondsToSelector:openWithoutClientPortSelector])
        {
            ((void (*)(id, SEL, NSString*, NSDictionary*, void (^)(NSError*)))objc_msgSend)(
                systemService, openWithoutClientPortSelector, bundleIdentifier, openOptions,
                resultCallback);
            launched = YES;
        }

        if (!launched)
        {
            stopMonitoring = YES;
            result[@"success"] = @NO;
            result[@"error"] = @"No suitable openApplication method found";
            return result;
        }

        // Wait for launch completion with timeout
        dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, 10 * NSEC_PER_SEC);
        dispatch_semaphore_wait(semaphore, timeout);

        // Stop the monitoring thread
        stopMonitoring = YES;

        // Cleanup client port
        if (clientPort != MACH_PORT_NULL &&
            [systemService respondsToSelector:cleanupClientPortSelector])
        {
            ((void (*)(id, SEL, mach_port_t))objc_msgSend)(systemService, cleanupClientPortSelector,
                                                          clientPort);
        }

        if (!launchCompleted)
        {
            result[@"success"] = @NO;
            result[@"error"] = @"Launch timeout";
            return result;
        }

        if (launchError)
        {
            result[@"success"] = @NO;
            result[@"error"] = [launchError localizedDescription];
            return result;
        }

        // Get final PID
        pid_t finalPid = 0;
        if (suspended && pidSuspended)
        {
            finalPid = suspendedPid;
        }
        else if ([systemService respondsToSelector:pidSelector])
        {
            // Wait a bit for the app to fully launch
            usleep(100000);  // 100ms
            finalPid = (pid_t)((NSInteger(*)(id, SEL, NSString*))objc_msgSend)(
                systemService, pidSelector, bundleIdentifier);
        }

        result[@"success"] = @YES;
        result[@"pid"] = @(finalPid);
        result[@"suspended"] = @(suspended && pidSuspended);

        debug_log(LOG_INFO, "App spawned successfully: PID=%d, suspended=%d", finalPid,
                  suspended && pidSuspended);
    }
    @catch (NSException* exception)
    {
        debug_log(LOG_ERROR, "Exception during app spawn: %s", [[exception reason] UTF8String]);
        result[@"success"] = @NO;
        result[@"error"] = [exception reason];
    }

    return result;
}

+ (BOOL)terminateApp:(NSString*)bundleIdentifier
{
    @try
    {
        SpringBoardAPI* api = getProcessSpringBoardAPI();
        if (!api || !api->FBSSystemService)
        {
            return NO;
        }

        id systemService = [api->FBSSystemService sharedService];
        if (!systemService)
        {
            return NO;
        }

        SEL terminateSelector =
            @selector(terminateApplication:forReason:andReport:withDescription:);
        if ([systemService respondsToSelector:terminateSelector])
        {
            // FBProcessKillReasonUser = 1
            ((void (*)(id, SEL, NSString*, int, BOOL, NSString*))objc_msgSend)(
                systemService, terminateSelector, bundleIdentifier, 1, NO, @"DynaDbg termination");

            debug_log(LOG_INFO, "Terminated app: %s", [bundleIdentifier UTF8String]);
            return YES;
        }
        else
        {
            debug_log(LOG_ERROR, "terminateApplication method not available");
            return NO;
        }
    }
    @catch (NSException* exception)
    {
        debug_log(LOG_ERROR, "Exception during app terminate: %s",
                  [[exception reason] UTF8String]);
        return NO;
    }
}

@end

const char* spawn_app_native(const char* bundle_identifier, int suspended)
{
    @autoreleasepool
    {
        if (bundle_identifier == NULL)
        {
            return strdup("{\"success\":false,\"error\":\"Bundle identifier is null\"}");
        }

        NSString* bundleId = [NSString stringWithUTF8String:bundle_identifier];
        NSDictionary* result = [AppSpawner spawnApp:bundleId suspended:(suspended != 0)];

        if (![NSJSONSerialization isValidJSONObject:result])
        {
            debug_log(LOG_ERROR, "Spawn result is not serializable");
            return strdup("{\"success\":false,\"error\":\"Result not serializable\"}");
        }

        NSError* error = nil;
        NSData* jsonData = [NSJSONSerialization dataWithJSONObject:result options:0 error:&error];

        if (error)
        {
            debug_log(LOG_ERROR, "JSON serialization error: %s",
                      [[error localizedDescription] UTF8String]);
            return strdup("{\"success\":false,\"error\":\"JSON serialization failed\"}");
        }

        NSString* jsonString = [[NSString alloc] initWithData:jsonData
                                                     encoding:NSUTF8StringEncoding];
        if (jsonString != nil)
        {
            return strdup([jsonString UTF8String]);
        }

        return strdup("{\"success\":false,\"error\":\"Failed to create JSON string\"}");
    }
}

int terminate_app_native(int pid)
{
    @autoreleasepool
    {
        if (pid <= 0)
        {
            return 0;
        }

        // Use kill() system call to terminate the process
        int result = kill(pid, SIGKILL);
        if (result == 0)
        {
            debug_log(LOG_INFO, "Successfully terminated process PID %d", pid);
            return 1;
        }
        else
        {
            debug_log(LOG_ERROR, "Failed to terminate process PID %d: %s", pid, strerror(errno));
            return 0;
        }
    }
}

// Resume a suspended process by PID
const char* resume_app_native(int pid)
{
    @autoreleasepool
    {
        if (pid <= 0)
        {
            return strdup("{\"success\":false,\"error\":\"Invalid PID\"}");
        }

        mach_port_t task = MACH_PORT_NULL;
        kern_return_t kr = task_for_pid(mach_task_self(), pid, &task);

        if (kr != KERN_SUCCESS || task == MACH_PORT_NULL)
        {
            debug_log(LOG_ERROR, "Failed to get task for PID %d: %s", pid, mach_error_string(kr));
            char error_buf[256];
            snprintf(error_buf, sizeof(error_buf),
                     "{\"success\":false,\"error\":\"Failed to get task for PID: %s\"}",
                     mach_error_string(kr));
            return strdup(error_buf);
        }

        // Resume the task
        kr = task_resume(task);
        mach_port_deallocate(mach_task_self(), task);

        if (kr != KERN_SUCCESS)
        {
            debug_log(LOG_ERROR, "Failed to resume task for PID %d: %s", pid,
                      mach_error_string(kr));
            char error_buf[256];
            snprintf(error_buf, sizeof(error_buf),
                     "{\"success\":false,\"error\":\"Failed to resume task: %s\"}",
                     mach_error_string(kr));
            return strdup(error_buf);
        }

        debug_log(LOG_INFO, "Successfully resumed process PID %d", pid);

        char result_buf[128];
        snprintf(result_buf, sizeof(result_buf), "{\"success\":true,\"pid\":%d,\"resumed\":true}",
                 pid);
        return strdup(result_buf);
    }
}

// Get running status and PID of an app by bundle identifier
const char* get_app_running_status_native(const char* bundle_identifier)
{
    @autoreleasepool
    {
        if (bundle_identifier == NULL)
        {
            return strdup("{\"success\":false,\"error\":\"Bundle identifier is null\"}");
        }

        NSString* bundleId = [NSString stringWithUTF8String:bundle_identifier];

        @try
        {
            SpringBoardAPI* api = getProcessSpringBoardAPI();
            if (!api || !api->FBSSystemService)
            {
                return strdup("{\"success\":false,\"error\":\"SpringBoard API not available\"}");
            }

            id systemService = [api->FBSSystemService sharedService];
            if (!systemService)
            {
                return strdup("{\"success\":false,\"error\":\"Failed to get FBSSystemService\"}");
            }

            SEL pidSelector = @selector(pidForApplication:);
            if (![systemService respondsToSelector:pidSelector])
            {
                return strdup(
                    "{\"success\":false,\"error\":\"pidForApplication method not available\"}");
            }

            pid_t pid = (pid_t)((NSInteger(*)(id, SEL, NSString*))objc_msgSend)(
                systemService, pidSelector, bundleId);

            BOOL isRunning = (pid > 0);

            debug_log(LOG_DEBUG, "App %s running status: %s (PID: %d)", [bundleId UTF8String],
                      isRunning ? "running" : "not running", pid);

            char result_buf[256];
            snprintf(result_buf, sizeof(result_buf),
                     "{\"success\":true,\"bundleIdentifier\":\"%s\",\"running\":%s,\"pid\":%d}",
                     bundle_identifier, isRunning ? "true" : "false", pid);
            return strdup(result_buf);
        }
        @catch (NSException* exception)
        {
            debug_log(LOG_ERROR, "Exception getting app status: %s",
                      [[exception reason] UTF8String]);
            char error_buf[512];
            snprintf(error_buf, sizeof(error_buf),
                     "{\"success\":false,\"error\":\"Exception: %s\"}",
                     [[exception reason] UTF8String]);
            return strdup(error_buf);
        }
    }
}

#else

// macOS stub implementations
const char* spawn_app_native(const char* bundle_identifier, int suspended)
{
    (void)bundle_identifier;
    (void)suspended;
    return strdup("{\"success\":false,\"error\":\"Spawn not supported on macOS\"}");
}

int terminate_app_native(int pid)
{
    (void)pid;
    return 0;
}

const char* resume_app_native(int pid)
{
    (void)pid;
    return strdup("{\"success\":false,\"error\":\"Resume not supported on macOS\"}");
}

const char* get_app_running_status_native(const char* bundle_identifier)
{
    (void)bundle_identifier;
    return strdup("{\"success\":false,\"error\":\"App status not supported on macOS\"}");
}

#endif  // TARGET_OS_IPHONE || TARGET_OS_IOS

```

`src/server/src/cpp/src/darwin/debugger/arch_defs.h`:

```h
/**
 * @file arch_defs.h
 * @brief Architecture-specific definitions for Darwin/macOS debugger
 *
 * Provides ARM64-specific definitions for the Mach-based debugger.
 * Supports hardware breakpoints and watchpoints on ARM64.
 */

#ifndef DARWIN_ARCH_DEFS_H
#define DARWIN_ARCH_DEFS_H

#include <mach/mach.h>
#include <mach/arm/thread_status.h>

#include <cstddef>
#include <cstdint>

// =============================================================================
// ARM64 Debug Register Constants
// =============================================================================

// Maximum hardware breakpoints on ARM64
#define MAX_HW_BREAKPOINTS 16

// Maximum hardware watchpoints on ARM64
#define MAX_HW_WATCHPOINTS 4

// =============================================================================
// ARM64 Breakpoint Control Register (BCR) Bit Definitions
// =============================================================================

// BCR Enable bit (bit 0)
#define ARM64_BCR_ENABLE           (1ULL << 0)

// BCR Privilege Mode Control (bits 1-2)
// PMC = 2: EL0 only (user mode)
#define ARM64_BCR_PMC_EL0          (2ULL << 1)
// PMC = 1: EL1 only (kernel mode)
#define ARM64_BCR_PMC_EL1          (1ULL << 1)
// PMC = 3: EL0 and EL1
#define ARM64_BCR_PMC_EL0_EL1      (3ULL << 1)

// BCR Byte Address Select (bits 5-8)
// BAS = 0xF: Match all 4 bytes (for 4-byte aligned address)
#define ARM64_BCR_BAS_ALL          (0xFULL << 5)

// Standard hardware breakpoint control value
// Enable + EL0 mode + Match 4 bytes
#define ARM64_BCR_EXECUTE_BP       (ARM64_BCR_ENABLE | ARM64_BCR_PMC_EL0 | ARM64_BCR_BAS_ALL)

// =============================================================================
// ARM64 Watchpoint Control Register (WCR) Bit Definitions
// =============================================================================

// WCR Enable bit (bit 0)
#define ARM64_WCR_ENABLE           (1ULL << 0)

// WCR Privilege Mode Control (bits 1-2)
#define ARM64_WCR_PMC_EL0          (2ULL << 1)

// WCR Load/Store Control (bits 3-4)
// LSC = 1: Load (read)
#define ARM64_WCR_LSC_LOAD         (1ULL << 3)
// LSC = 2: Store (write)
#define ARM64_WCR_LSC_STORE        (2ULL << 3)
// LSC = 3: Load or Store (read/write)
#define ARM64_WCR_LSC_LOADSTORE    (3ULL << 3)

// WCR Byte Address Select (bits 5-12)
// Length encoding for watchpoints
#define ARM64_WCR_LEN_1            (0ULL << 5)   // 1 byte
#define ARM64_WCR_LEN_2            (1ULL << 5)   // 2 bytes
#define ARM64_WCR_LEN_4            (2ULL << 5)   // 4 bytes
#define ARM64_WCR_LEN_8            (3ULL << 5)   // 8 bytes

// =============================================================================
// ARM64 MDSCR_EL1 (Monitor Debug System Control Register) Bits
// =============================================================================

// Single-step enable bit
#define ARM64_MDSCR_SS             (1ULL << 0)

// Software step enable (bit 15)
#define ARM64_MDSCR_MDE            (1ULL << 15)

// =============================================================================
// Exception Class (EC) values from ESR_EL1
// =============================================================================

// EC for Software breakpoint (BRK instruction)
#define ARM64_EC_SOFTWARE_BP       0x3C

// EC for Hardware breakpoint
#define ARM64_EC_HW_BREAKPOINT_LO  0x30
#define ARM64_EC_HW_BREAKPOINT_HI  0x31

// EC for Watchpoint (read)
#define ARM64_EC_WATCHPOINT_LO     0x34
// EC for Watchpoint (write)
#define ARM64_EC_WATCHPOINT_HI     0x35

// EC for Software step
#define ARM64_EC_SOFTWARE_STEP_LO  0x32
#define ARM64_EC_SOFTWARE_STEP_HI  0x33

// =============================================================================
// Helper Functions
// =============================================================================

/**
 * Extract Exception Class from ESR value
 * @param esr Exception Syndrome Register value
 * @return Exception Class (bits 31:26)
 */
static inline uint32_t arm64_get_exception_class(uint32_t esr)
{
    return (esr >> 26) & 0x3F;
}

/**
 * Encode watchpoint control register value
 * @param size Watchpoint size (1, 2, 4, or 8 bytes)
 * @param type Load/Store control (1=load, 2=store, 3=both)
 * @return WCR value
 */
static inline uint64_t arm64_encode_wcr(int size, int type)
{
    uint64_t control = ARM64_WCR_ENABLE | ARM64_WCR_PMC_EL0;
    
    // Set LSC (Load/Store Control)
    control |= ((uint64_t)type << 3);
    
    // Set length field
    uint64_t len_field = 0;
    switch (size)
    {
        case 1: len_field = 0; break;
        case 2: len_field = 1; break;
        case 4: len_field = 2; break;
        case 8: len_field = 3; break;
        default: len_field = 2; break;  // Default to 4 bytes
    }
    control |= (len_field << 5);
    
    return control;
}

/**
 * Encode breakpoint control register value for execution breakpoint
 * @return BCR value for execution breakpoint
 */
static inline uint64_t arm64_encode_bcr_execute(void)
{
    return ARM64_BCR_EXECUTE_BP;
}

#endif  // DARWIN_ARCH_DEFS_H

```

`src/server/src/cpp/src/darwin/debugger/debugger.h`:

```h
#ifndef DEBUGGER_H
#define DEBUGGER_H

#include <mach/mach.h>
#include <mach/mach_error.h>
#include <mach/mach_traps.h>
#include <mach/task.h>
#include <mach/thread_act.h>
#include <mach/vm_map.h>
#include <unistd.h>

#include <array>
#include <condition_variable>
#include <cstdint>
#include <cstring>
#include <iostream>
#include <map>
#include <mutex>
#include <string>
#include <thread>
#include <vector>

#include "arch_defs.h"
#include "debugger_types.h"
#include "../../common/exception_info.h"
#include "../../common/trace_file.h"
#include "../../common/util.h"
#include "../core/native_api.h"

#define EXCEPTION_DEFAULT_BEHAVIOR 0x0

#ifdef DYNAMIC_LIB_BUILD
#define Debugger DebuggerDynamic

// Function pointer types for dynamically loaded functions
// Returns true if execution should auto-continue, false to enter break state
typedef bool (*send_exception_info_func_t)(const NativeExceptionInfo*, pid_t);

// Global function pointers (to be resolved at runtime)
extern send_exception_info_func_t g_send_exception_info;

// Initialization function to resolve function pointers
extern "C" void init_dynamic_functions();
#endif

class Debugger
{
public:
    Debugger(pid_t pid);
    ~Debugger();
    bool initialize();
    void run();
    kern_return_t set_watchpoint(mach_vm_address_t address, int size, WatchpointType type);
    kern_return_t remove_watchpoint(mach_vm_address_t address);
    kern_return_t set_breakpoint(mach_vm_address_t address, int hit_count, bool is_software = false,
                                 mach_vm_address_t end_address = 0);
    kern_return_t remove_breakpoint(mach_vm_address_t address);

    // Internal breakpoint methods
    kern_return_t set_hardware_breakpoint(mach_vm_address_t address, int hit_count,
                                          mach_vm_address_t end_address = 0);
    kern_return_t set_software_breakpoint(mach_vm_address_t address, int hit_count);
    kern_return_t remove_software_breakpoint(mach_vm_address_t address);

    // Software breakpoint original instruction query
    bool get_software_breakpoint_original_bytes(uint64_t address, uint8_t* out_bytes,
                                                size_t* out_size);

    // Trace file output mode
    void enable_trace_file_output(const std::string& filepath);
    void disable_trace_file_output();
    bool is_trace_file_output_enabled() const;
    const std::string& get_trace_file_path() const;
    uint32_t get_trace_file_entry_count() const;
    bool is_trace_ended_by_end_address() const;
    void reset_trace_ended_flag();

    // Script-initiated trace stop request
    void request_script_trace_stop(bool notify_ui = false);
    void clear_script_trace_stop_request();
    bool is_script_trace_stop_requested() const;
    bool should_notify_ui_on_stop() const
    {
        return script_trace_stop_with_ui_notification_.load();
    }

    // Full memory cache mode
    void enable_full_memory_cache(const std::string& dump_filepath,
                                  const std::string& log_filepath);
    void disable_full_memory_cache();
    bool is_full_memory_cache_enabled() const;
    bool dump_all_memory_regions();

    kern_return_t handle_exception(mach_port_t exception_port, mach_port_t thread, mach_port_t task,
                                   exception_type_t exception, mach_exception_data_t code,
                                   mach_msg_type_number_t code_count);

    // New API methods for break state control
    kern_return_t continue_execution(mach_port_t thread_id);
    kern_return_t single_step(mach_port_t thread_id);
    kern_return_t read_register(mach_port_t thread_id, const std::string& reg_name,
                                uint64_t* value);
    kern_return_t write_register(mach_port_t thread_id, const std::string& reg_name,
                                 uint64_t value);
    DebugState get_debug_state() const;
    bool is_in_break_state() const;

private:
    // Per-watchpoint/breakpoint synchronization (from debugger_types.h)
    std::array<WatchpointSync, MAX_WATCHPOINTS> watchpoint_sync_;
    std::array<BreakpointSync, MAX_BREAKPOINTS> breakpoint_sync_;
    std::mutex thread_states_mutex_;                  // Protects thread_states_
    mutable std::mutex watchpoint_data_mutex_;        // Protects watchpoint-related data
    mutable std::mutex breakpoint_data_mutex_;        // Protects breakpoint-related data

    // Trace file output
    bool trace_file_enabled_ = false;
    bool trace_session_ended_by_end_address_ =
        false;  // Flag to indicate trace ended due to end_address
    std::string trace_file_path_;
    std::unique_ptr<TraceFileWriter> trace_file_writer_;
    mutable std::mutex trace_file_mutex_;

    // Full memory cache
    bool full_memory_cache_enabled_ = false;
    bool memory_dump_completed_ = false;  // Flag to track if initial dump is done
    std::string memory_dump_path_;
    std::string memory_access_log_path_;
    std::unique_ptr<MemoryDumpWriter> memory_dump_writer_;
    std::unique_ptr<MemoryAccessLogWriter> memory_access_log_writer_;
    mutable std::mutex memory_cache_mutex_;

    // Hardware limits defined in debugger_types.h
    pid_t pid_;
    mach_port_t task_port_;
    mach_port_t exception_port_;
    std::vector<bool> watchpoint_used;
    std::vector<mach_vm_address_t> watchpoint_addresses;
    std::vector<int> watchpoint_sizes;
    std::vector<bool> breakpoint_used;
    std::vector<mach_vm_address_t> breakpoint_addresses;
    std::vector<int> breakpoint_hit_counts;
    std::vector<int> breakpoint_target_counts;
    std::vector<mach_vm_address_t>
        breakpoint_end_addresses;  // Optional end address to stop tracing

    // Software breakpoint data (stores original instruction bytes)
    std::vector<bool> software_breakpoint_used;
    std::vector<uint64_t> software_breakpoint_addresses;
    std::vector<uint8_t> software_breakpoint_original_bytes;  // Original instruction bytes (4 bytes
                                                              // per bp for ARM64)
    mutable std::mutex software_breakpoint_mutex_;

    // Tracing mode: track the first thread that hits the breakpoint
    // Only this thread will be single-stepped for tracing
    std::atomic<mach_port_t> tracked_trace_thread_{MACH_PORT_NULL};

    // Script-initiated trace stop request
    std::atomic<bool> script_trace_stop_requested_{false};
    std::atomic<bool> script_trace_stop_with_ui_notification_{false};

    // ThreadState and SingleStepMode defined in debugger_types.h
    std::map<mach_port_t, ThreadState> thread_states_;
    DebugState debug_state_ = DebugState::Running;
    mach_port_t current_thread = MACH_PORT_NULL;

    kern_return_t handle_single_step(mach_port_t thread, arm_debug_state64_t& debug_state,
                                     arm_thread_state64_t& thread_state,
                                     arm_exception_state64_t& exception_state);
    kern_return_t complete_watchpoint_single_step(mach_port_t thread,
                                                  arm_debug_state64_t& debug_state,
                                                  arm_thread_state64_t& thread_state,
                                                  arm_exception_state64_t& exception_state);
    kern_return_t continue_breakpoint_single_step(mach_port_t thread,
                                                  arm_debug_state64_t& debug_state,
                                                  arm_thread_state64_t& thread_state,
                                                  arm_exception_state64_t& exception_state);
    kern_return_t handle_watchpoint_hit(mach_port_t thread, arm_debug_state64_t& debug_state,
                                        arm_thread_state64_t& thread_state,
                                        arm_exception_state64_t& exception_state,
                                        int watchpoint_index);
    kern_return_t handle_breakpoint_hit(mach_port_t thread, arm_debug_state64_t& debug_state,
                                        arm_thread_state64_t& thread_state,
                                        arm_exception_state64_t& exception_state,
                                        int breakpoint_index);
    int find_free_watchpoint();
    int find_watchpoint_index(mach_vm_address_t address);
    int find_free_breakpoint();
    int find_breakpoint_index(mach_vm_address_t address);
    int get_available_watchpoints(mach_port_t thread);
    kern_return_t set_watchpoint_on_thread(mach_port_t thread, mach_vm_address_t address, int size,
                                           WatchpointType type, int index);
    kern_return_t clear_watchpoint_on_thread(thread_t thread, int index);
    kern_return_t remove_watchpoint_by_index(int index);
    static std::string kern_return_to_string(kern_return_t kr);
};

#ifdef DYNAMIC_LIB_BUILD
#define g_debugger g_debugger_dynamic

// Export non-mangled C function wrapper for handle_exception
extern "C" kern_return_t handle_exception_dynamic(Debugger* debugger, mach_port_t exception_port,
                                                  mach_port_t thread, mach_port_t task,
                                                  exception_type_t exception,
                                                  mach_exception_data_t code,
                                                  mach_msg_type_number_t code_count);
#endif

// Global pointer to the Debugger instance
extern "C" Debugger* g_debugger;

#endif  // DEBUGGER_H
```

`src/server/src/cpp/src/darwin/debugger/debugger_breakpoint.mm`:

```mm
/**
 * @file debugger_breakpoint.mm
 * @brief Breakpoint-related member functions for the Debugger class (Darwin/macOS)
 *
 * This file contains all breakpoint management functionality including:
 * - Hardware breakpoint set/remove operations
 * - Software breakpoint set/remove operations
 * - Breakpoint hit handling
 * - Single-step continuation for breakpoints
 *
 * Part of the DynaDbg Darwin debugger implementation.
 */

#include "debugger_internal.h"

// =============================================================================
// Public Breakpoint API
// =============================================================================

kern_return_t Debugger::set_breakpoint(mach_vm_address_t address, int hit_count, bool is_software,
                                       mach_vm_address_t end_address)
{
    if (is_software)
    {
        return set_software_breakpoint(address, hit_count);
    }
    else
    {
        return set_hardware_breakpoint(address, hit_count, end_address);
    }
}

kern_return_t Debugger::set_hardware_breakpoint(mach_vm_address_t address, int hit_count,
                                                mach_vm_address_t end_address)
{
    // Reset trace ended flag when setting a new breakpoint (new trace session)
    trace_session_ended_by_end_address_ = false;

    // Reset tracked trace thread for new trace session
    tracked_trace_thread_.store(MACH_PORT_NULL);

    thread_act_array_t thread_list;
    mach_msg_type_number_t thread_count;
    kern_return_t kr;

    kr = task_threads(task_port_, &thread_list, &thread_count);
    if (kr != KERN_SUCCESS || thread_count == 0)
    {
        debug_log(LOG_ERROR, "Failed to get threads: %s", kern_return_to_string(kr).c_str());
        return kr;
    }

    int index = find_free_breakpoint();
    if (index == -1)
    {
        debug_log(LOG_ERROR, "No free breakpoints available.");
        return KERN_NO_SPACE;
    }

    // Reset sync state for this breakpoint slot
    breakpoint_sync_[index].removing.store(false);
    breakpoint_sync_[index].active_handlers.store(0);

    // Use scope guard to ensure cleanup
    auto cleanup = [&](void*)
    {
        for (mach_msg_type_number_t i = 0; i < thread_count; i++)
        {
            mach_port_deallocate(mach_task_self(), thread_list[i]);
        }
        vm_deallocate(mach_task_self(), (vm_address_t)thread_list,
                      thread_count * sizeof(thread_act_t));
    };
    std::unique_ptr<void, decltype(cleanup)> guard(nullptr, cleanup);

    // Set breakpoint on all threads
    bool all_success = true;
    for (mach_msg_type_number_t i = 0; i < thread_count; i++)
    {
        arm_debug_state64_t debug_state;
        memset(&debug_state, 0, sizeof(debug_state));
        mach_msg_type_number_t count = ARM_DEBUG_STATE64_COUNT;
        kr = thread_get_state(thread_list[i], ARM_DEBUG_STATE64, (thread_state_t)&debug_state,
                              &count);
        if (kr != KERN_SUCCESS)
        {
            debug_log(LOG_ERROR, "Failed to get debug state for thread %d: %s", i,
                      kern_return_to_string(kr).c_str());
            all_success = false;
            continue;
        }

        debug_state.__bvr[index] = address;
        debug_state.__bcr[index] =
            (1ULL << 0) | (2ULL << 1) | (1ULL << 5);  // Enable, EL1, all sizes
        debug_state.__mdscr_el1 |= (1ULL << 15);      // Enable debug

        kr = thread_set_state(thread_list[i], ARM_DEBUG_STATE64, (thread_state_t)&debug_state,
                              count);
        if (kr != KERN_SUCCESS)
        {
            debug_log(LOG_ERROR, "Failed to set breakpoint on thread %d: %s", i,
                      kern_return_to_string(kr).c_str());
            all_success = false;
        }
    }

    if (all_success)
    {
        breakpoint_used[index] = true;
        breakpoint_addresses[index] = address;
        breakpoint_hit_counts[index] = 0;
        breakpoint_target_counts[index] = hit_count;
        breakpoint_end_addresses[index] = end_address;
        if (end_address != 0)
        {
            debug_log(LOG_INFO,
                      "Hardware breakpoint set successfully at address 0x%llx on all %d "
                      "threads (end_address: 0x%llx)",
                      address, thread_count, end_address);
        }
        else
        {
            debug_log(LOG_INFO,
                      "Hardware breakpoint set successfully at address 0x%llx on all %d threads",
                      address, thread_count);
        }
    }
    else
    {
        debug_log(LOG_ERROR, "Failed to set hardware breakpoint on some threads");
    }

    return all_success ? KERN_SUCCESS : kr;
}

kern_return_t Debugger::set_software_breakpoint(mach_vm_address_t address, int hit_count)
{
    // debug_log_develop(LOG_INFO, "Setting software breakpoint at 0x%llx", address);

    // Find free software breakpoint slot
    int index = -1;
    {
        std::lock_guard<std::mutex> lock(software_breakpoint_mutex_);
        for (int i = 0; i < MAX_SOFTWARE_BREAKPOINTS; i++)
        {
            if (!software_breakpoint_used[i])
            {
                index = i;
                break;
            }
        }
    }

    if (index == -1)
    {
        debug_log(LOG_ERROR, "No free software breakpoints available");
        return KERN_NO_SPACE;
    }

    // ARM64: 4 bytes per instruction
    const size_t bp_size = 4;
    const uint32_t brk_instruction = 0xD4200000;  // BRK #0

    // Read original instruction bytes
    uint8_t original_bytes[4] = {0};
    ssize_t bytes_read = read_memory_native(pid_, address, bp_size, original_bytes);
    if (bytes_read != (ssize_t)bp_size)
    {
        debug_log(LOG_ERROR, "Failed to read memory at 0x%llx for software breakpoint", address);
        return KERN_FAILURE;
    }

    // debug_log_develop(LOG_DEBUG, "Original bytes at 0x%llx: %02x %02x %02x %02x", address,
    //                  original_bytes[0], original_bytes[1], original_bytes[2], original_bytes[3]);

    // Write breakpoint instruction
    ssize_t bytes_written =
        write_memory_native(pid_, address, bp_size, (unsigned char*)&brk_instruction);
    if (bytes_written != (ssize_t)bp_size)
    {
        debug_log(LOG_ERROR, "Failed to write software breakpoint at 0x%llx", address);
        return KERN_FAILURE;
    }

    // Store breakpoint info
    {
        std::lock_guard<std::mutex> lock(software_breakpoint_mutex_);
        software_breakpoint_used[index] = true;
        software_breakpoint_addresses[index] = address;
        memcpy(&software_breakpoint_original_bytes[index * 4], original_bytes, 4);
    }

    // debug_log(
    //    LOG_INFO, "Software breakpoint set at 0x%llx (index %d), original: %02x %02x %02x %02x",
    //    address, index, original_bytes[0], original_bytes[1], original_bytes[2],
    //    original_bytes[3]);

    return KERN_SUCCESS;
}

kern_return_t Debugger::remove_software_breakpoint(mach_vm_address_t address)
{
    // debug_log_develop(LOG_INFO, "Removing software breakpoint at 0x%llx", address);

    // Find the software breakpoint
    int index = -1;
    uint8_t original_bytes[4] = {0};
    {
        std::lock_guard<std::mutex> lock(software_breakpoint_mutex_);
        for (int i = 0; i < MAX_SOFTWARE_BREAKPOINTS; i++)
        {
            if (software_breakpoint_used[i] && software_breakpoint_addresses[i] == address)
            {
                index = i;
                memcpy(original_bytes, &software_breakpoint_original_bytes[i * 4], 4);
                break;
            }
        }
    }

    if (index == -1)
    {
        debug_log(LOG_ERROR, "Software breakpoint not found at address 0x%llx", address);
        return KERN_INVALID_ARGUMENT;
    }

    // Restore original instruction
    const size_t bp_size = 4;
    ssize_t bytes_written = write_memory_native(pid_, address, bp_size, original_bytes);
    if (bytes_written != (ssize_t)bp_size)
    {
        debug_log(LOG_ERROR, "Failed to restore original instruction at 0x%llx", address);
        return KERN_FAILURE;
    }

    // Clear breakpoint info
    {
        std::lock_guard<std::mutex> lock(software_breakpoint_mutex_);
        software_breakpoint_used[index] = false;
        software_breakpoint_addresses[index] = 0;
        memset(&software_breakpoint_original_bytes[index * 4], 0, 4);
    }

    // debug_log_develop(LOG_INFO, "Software breakpoint removed at 0x%llx (index %d)", address,
    // index);

    return KERN_SUCCESS;
}

kern_return_t Debugger::remove_breakpoint(mach_vm_address_t address)
{
    // First, check if this is a software breakpoint
    bool is_software_bp = false;
    {
        std::lock_guard<std::mutex> lock(software_breakpoint_mutex_);
        for (int i = 0; i < MAX_SOFTWARE_BREAKPOINTS; i++)
        {
            if (software_breakpoint_used[i] && software_breakpoint_addresses[i] == address)
            {
                is_software_bp = true;
                break;
            }
        }
    }

    if (is_software_bp)
    {
        // Found as software breakpoint, remove it (outside of lock)
        return remove_software_breakpoint(address);
    }

    // Otherwise, try to remove as hardware breakpoint
    int index = find_breakpoint_index(address);
    if (index == -1)
    {
        debug_log(LOG_ERROR, "Breakpoint not found for address: 0x%llx", address);
        return KERN_INVALID_ARGUMENT;
    }

    // Set the removal flag for this specific breakpoint
    breakpoint_sync_[index].removing.store(true);

    // Wait for any in-progress hit handlers for this breakpoint to complete
    {
        std::unique_lock<std::mutex> lock(breakpoint_sync_[index].mutex);
        bool completed = breakpoint_sync_[index].cv.wait_for(
            lock, std::chrono::seconds(1),
            [this, index] { return breakpoint_sync_[index].active_handlers.load() == 0; });

        if (!completed)
        {
            debug_log(LOG_WARN,
                      "Timeout waiting for breakpoint %d handlers (count: %d), forcing reset",
                      index, breakpoint_sync_[index].active_handlers.load());
            // Force reset the counter to prevent accumulation
            breakpoint_sync_[index].active_handlers.store(0);
        }
    }

    thread_act_array_t thread_list;
    mach_msg_type_number_t thread_count;
    kern_return_t kr;

    kr = task_threads(task_port_, &thread_list, &thread_count);
    if (kr != KERN_SUCCESS || thread_count == 0)
    {
        debug_log(LOG_ERROR, "Failed to get threads: %s", kern_return_to_string(kr).c_str());
        breakpoint_sync_[index].removing.store(false);  // Clear the flag
        return kr;
    }

    // Use scope guard to ensure cleanup
    auto cleanup = [&](void*)
    {
        for (mach_msg_type_number_t i = 0; i < thread_count; i++)
        {
            mach_port_deallocate(mach_task_self(), thread_list[i]);
        }
        vm_deallocate(mach_task_self(), (vm_address_t)thread_list,
                      thread_count * sizeof(thread_act_t));
    };
    std::unique_ptr<void, decltype(cleanup)> guard(nullptr, cleanup);

    // Remove breakpoint from all threads
    bool all_success = true;
    for (mach_msg_type_number_t i = 0; i < thread_count; i++)
    {
        arm_debug_state64_t debug_state;
        memset(&debug_state, 0, sizeof(debug_state));
        mach_msg_type_number_t count = ARM_DEBUG_STATE64_COUNT;
        kr = thread_get_state(thread_list[i], ARM_DEBUG_STATE64, (thread_state_t)&debug_state,
                              &count);
        if (kr != KERN_SUCCESS)
        {
            debug_log(LOG_ERROR, "Failed to get debug state for thread %d: %s", i,
                      kern_return_to_string(kr).c_str());
            all_success = false;
            continue;
        }

        debug_state.__bcr[index] = 0;  // Disable the breakpoint
        kr = thread_set_state(thread_list[i], ARM_DEBUG_STATE64, (thread_state_t)&debug_state,
                              count);
        if (kr != KERN_SUCCESS)
        {
            debug_log(LOG_ERROR, "Failed to remove breakpoint from thread %d: %s", i,
                      kern_return_to_string(kr).c_str());
            all_success = false;
        }
    }

    if (all_success)
    {
        breakpoint_used[index] = false;
        breakpoint_addresses[index] = 0;
        breakpoint_hit_counts[index] = 0;
        breakpoint_target_counts[index] = 0;
        breakpoint_end_addresses[index] = 0;

        // Update thread states related to this breakpoint - clear breakpoint reference but keep
        // thread state
        for (auto& thread_state_pair : thread_states_)
        {
            if (thread_state_pair.second.current_breakpoint_index == index)
            {
                // debug_log(
                //    LOG_DEBUG,
                //    "Clearing breakpoint reference for thread %d but keeping thread in break
                //    state", thread_state_pair.first);

                // Clear the breakpoint index but keep the thread in break state
                thread_state_pair.second.current_breakpoint_index = -1;
            }
        }

        // debug_log_develop(LOG_INFO,
        //                  "Breakpoint removed successfully from address 0x%llx on all %d threads",
        //                  address, thread_count);
    }
    else
    {
        debug_log(LOG_ERROR, "Failed to remove breakpoint from some threads");
    }

    // Clear the removal flag for this breakpoint
    breakpoint_sync_[index].removing.store(false);

    return all_success ? KERN_SUCCESS : kr;
}

// Get original instruction bytes for software breakpoint
bool Debugger::get_software_breakpoint_original_bytes(uint64_t address, uint8_t* out_bytes,
                                                      size_t* out_size)
{
    if (!out_bytes || !out_size)
    {
        return false;
    }

    std::lock_guard<std::mutex> lock(software_breakpoint_mutex_);

    for (int i = 0; i < MAX_SOFTWARE_BREAKPOINTS; i++)
    {
        if (software_breakpoint_used[i] && software_breakpoint_addresses[i] == address)
        {
            // ARM64: 4 bytes per instruction
            memcpy(out_bytes, &software_breakpoint_original_bytes[i * 4], 4);
            *out_size = 4;

            return true;
        }
    }

    return false;
}

// =============================================================================
// Internal Breakpoint Operations
// =============================================================================

int Debugger::find_free_breakpoint()
{
    std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
    for (int i = 0; i < MAX_BREAKPOINTS; i++)
    {
        if (!breakpoint_used[i])
        {
            return i;
        }
    }
    return -1;
}

int Debugger::find_breakpoint_index(mach_vm_address_t address)
{
    std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
    for (int i = 0; i < MAX_BREAKPOINTS; i++)
    {
        if (breakpoint_used[i] && breakpoint_addresses[i] == address)
        {
            return i;
        }
    }
    return -1;
}

// =============================================================================
// Breakpoint Hit Handling
// =============================================================================

kern_return_t Debugger::handle_breakpoint_hit(mach_port_t thread, arm_debug_state64_t& debug_state,
                                              arm_thread_state64_t& thread_state,
                                              arm_exception_state64_t& exception_state,
                                              int breakpoint_index)
{
    // Increment active handler count for this specific breakpoint
    breakpoint_sync_[breakpoint_index].active_handlers.fetch_add(1);

    // Scope guard to ensure count is decremented and condition variable is notified
    auto decrement_guard = [this, breakpoint_index](int*)
    {
        breakpoint_sync_[breakpoint_index].active_handlers.fetch_sub(1);
        if (breakpoint_sync_[breakpoint_index].active_handlers.load() == 0)
        {
            std::lock_guard<std::mutex> lock(breakpoint_sync_[breakpoint_index].mutex);
            breakpoint_sync_[breakpoint_index].cv.notify_all();
        }
    };
    static int dummy = 0;
    std::unique_ptr<int, decltype(decrement_guard)> guard(&dummy, decrement_guard);

    // Check if this breakpoint is being removed
    if (breakpoint_sync_[breakpoint_index].removing.load())
    {
        return KERN_SUCCESS;
    }

    // Increment hit_count protected by breakpoint_data_mutex_
    int current_hit_count;
    int target_count;
    mach_vm_address_t end_address;
    {
        std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
        breakpoint_hit_counts[breakpoint_index]++;
        current_hit_count = breakpoint_hit_counts[breakpoint_index];
        target_count = breakpoint_target_counts[breakpoint_index];
        end_address = breakpoint_end_addresses[breakpoint_index];
    }

    // Check if PC has reached the end address (if set)
    mach_vm_address_t current_pc = thread_state.__pc;
    bool reached_end_address = (end_address != 0) && (current_pc == end_address);

    if (reached_end_address)
    {
        // debug_log_develop(LOG_INFO,
        //                  "PC reached end address 0x%llx, stopping trace",
        //                  end_address);

        // Set flag to indicate trace ended by end_address
        trace_session_ended_by_end_address_ = true;

        // Close trace file if enabled
        {
            std::lock_guard<std::mutex> lock(trace_file_mutex_);
            if (trace_file_enabled_ && trace_file_writer_)
            {
                trace_file_writer_->close();
                debug_log(LOG_INFO, "Trace file closed due to end_address reached (entries: %u)",
                          trace_file_writer_->get_entry_count());
                trace_file_enabled_ = false;
            }
        }

        // Also close memory cache files if enabled
        disable_full_memory_cache();

        mach_vm_address_t bp_address;
        {
            std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
            bp_address = breakpoint_addresses[breakpoint_index];
        }
        remove_breakpoint(bp_address);
        return KERN_SUCCESS;
    }

    if (current_hit_count < target_count)
    {
        // Set thread-specific single step mode
        {
            std::lock_guard<std::mutex> lock(thread_states_mutex_);

            // Re-check if being removed
            if (breakpoint_sync_[breakpoint_index].removing.load())
            {
                return KERN_SUCCESS;
            }

            thread_states_[thread] = ThreadState{.single_step_mode = SingleStepMode::Breakpoint,
                                                 .single_step_count = 0,
                                                 .current_breakpoint_index = breakpoint_index,
                                                 .current_watchpoint_index = -1,
                                                 .is_stopped = false,  // Running during single-step
                                                 .thread_state = thread_state,
                                                 .debug_state = debug_state,
                                                 .exception_state = exception_state};
        }

        // Enable single-step mode
        debug_state.__mdscr_el1 |= 1ULL;
        kern_return_t kr = thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&debug_state,
                                            ARM_DEBUG_STATE64_COUNT);
        if (kr != KERN_SUCCESS)
        {
            debug_log(LOG_ERROR, "Failed to set single-step mode: %s", mach_error_string(kr));
            return kr;
        }
    }
    else
    {
        mach_vm_address_t bp_address;
        {
            std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
            bp_address = breakpoint_addresses[breakpoint_index];
        }
        remove_breakpoint(bp_address);
    }

    return KERN_SUCCESS;
}

// =============================================================================
// Breakpoint Single-Step Continuation
// =============================================================================

kern_return_t Debugger::continue_breakpoint_single_step(mach_port_t thread,
                                                        arm_debug_state64_t& debug_state,
                                                        arm_thread_state64_t& thread_state,
                                                        arm_exception_state64_t& exception_state)
{
    // Disable single-step mode
    debug_state.__mdscr_el1 &= ~1ULL;

    // Get breakpoint index from thread state
    int bp_index = -1;
    {
        std::lock_guard<std::mutex> lock(thread_states_mutex_);
        auto it = thread_states_.find(thread);
        if (it != thread_states_.end())
        {
            bp_index = it->second.current_breakpoint_index;
            thread_states_.erase(it);
        }
    }

    kern_return_t kr = thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&debug_state,
                                        ARM_DEBUG_STATE64_COUNT);
    if (kr != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "Failed to disable single-step mode: %s", mach_error_string(kr));
        return kr;
    }

    return KERN_SUCCESS;
}

```

`src/server/src/cpp/src/darwin/debugger/debugger_core.mm`:

```mm
/**
 * @file debugger_core.mm
 * @brief Core debugger functionality - initialization, main loop, global state (Darwin/macOS)
 *
 * This file contains:
 * - Global debugger pointer and signal configuration
 * - Dynamic library initialization
 * - Exception handler callback
 * - Constructors and destructor
 * - Initialization methods
 * - Debug message loop
 * - Helper functions (kern_return_to_string)
 */

#include "debugger_internal.h"

// =============================================================================
// Exception handler callback
// =============================================================================

__attribute__((used)) extern "C" kern_return_t catch_exception_raise(
    mach_port_t exception_port, mach_port_t thread, mach_port_t task, exception_type_t exception,
    mach_exception_data_t code, mach_msg_type_number_t code_count)
{
    // debug_log(LOG_ERROR, "catch_exception_raise called with exception: %d", exception);
#ifndef DYNAMIC_LIB_BUILD
    typedef kern_return_t (*handle_exception_func_t)(Debugger*, mach_port_t, mach_port_t,
                                                     mach_port_t, exception_type_t,
                                                     mach_exception_data_t, mach_msg_type_number_t);
    static handle_exception_func_t dynamic_handle_exception = nullptr;
    static Debugger* dynamic_debugger_ptr = nullptr;
    static bool tried_resolve = false;

    if (!tried_resolve)
    {
        // Clear any existing error
        dlerror();

        // Try to open the dynamic library if it's already loaded
        void* handle = dlopen("libdbgsrv_native.dylib", RTLD_NOLOAD | RTLD_LAZY);
        if (!handle)
        {
            // Try alternative paths
            handle = dlopen("./libdbgsrv_native.dylib", RTLD_NOLOAD | RTLD_LAZY);
        }

        if (handle)
        {
            // debug_log_develop(LOG_INFO, "Found loaded dynamic library handle: %p", handle);

            // Get g_debugger_dynamic pointer
            Debugger** g_debugger_dynamic_addr = (Debugger**)dlsym(handle, "_g_debugger_dynamic");
            if (!g_debugger_dynamic_addr)
            {
                // Try without underscore prefix
                g_debugger_dynamic_addr = (Debugger**)dlsym(handle, "g_debugger_dynamic");
            }

            if (g_debugger_dynamic_addr)
            {
                dynamic_debugger_ptr = *g_debugger_dynamic_addr;
                // debug_log_develop(LOG_INFO, "Resolved g_debugger_dynamic at %p (value: %p)",
                //                   g_debugger_dynamic_addr, dynamic_debugger_ptr);
            }

            // Try to resolve handle_exception function symbol (non-mangled C function)
            dynamic_handle_exception =
                (handle_exception_func_t)dlsym(handle, "handle_exception_dynamic");
            if (!dynamic_handle_exception)
            {
                // Try with underscore prefix
                dynamic_handle_exception =
                    (handle_exception_func_t)dlsym(handle, "_handle_exception_dynamic");
            }

            if (dynamic_handle_exception)
            {
                // debug_log_develop(LOG_INFO, "Resolved dynamic handle_exception at %p",
                //                   dynamic_handle_exception);
            }
            else
            {
                const char* err = dlerror();
                debug_log(LOG_ERROR, "Failed to resolve handle_exception symbol in dynamic lib: %s",
                          err ? err : "unknown error");
            }
        }
        else
        {
            // debug_log_develop(LOG_DEBUG, "Dynamic library not loaded, using static version");
        }

        tried_resolve = true;
    }

    if (dynamic_handle_exception && dynamic_debugger_ptr)
    {
        return dynamic_handle_exception(dynamic_debugger_ptr, exception_port, thread, task,
                                        exception, code, code_count);
    }
    else
    {
        // debug_log_develop(LOG_DEBUG, "Dynamic handle_exception not available, using static");
    }
#endif

    if (g_debugger)
    {
        // debug_log_develop(LOG_INFO, "Using static debugger at %p", g_debugger);
        return g_debugger->handle_exception(exception_port, thread, task, exception, code,
                                            code_count);
    }
    return KERN_FAILURE;
}

// =============================================================================
// Global definitions
// =============================================================================

#ifdef DYNAMIC_LIB_BUILD
__attribute__((visibility("default"))) __attribute__((used))
#endif
extern "C" Debugger* g_debugger = nullptr;

// Global signal configuration (persists even when debugger is not attached)
std::map<int, SignalConfig> g_signal_config;
std::mutex g_signal_config_mutex;

// =============================================================================
// Dynamic library initialization
// =============================================================================

#ifdef DYNAMIC_LIB_BUILD
// Global function pointers for dynamically loaded functions
send_exception_info_func_t g_send_exception_info = nullptr;

// Initialization function to resolve all dynamic symbols
extern "C" void init_dynamic_functions()
{
    static bool initialized = false;
    if (initialized)
    {
        return;
    }

    // debug_log_develop(LOG_INFO, "Initializing dynamic library functions...");

    // Clear any existing error
    dlerror();

    // Try to resolve send_exception_info from main executable
    // RTLD_DEFAULT searches in the global symbol table
    g_send_exception_info = (send_exception_info_func_t)dlsym(RTLD_DEFAULT, "send_exception_info");
    if (!g_send_exception_info)
    {
        // Try with underscore prefix (macOS convention)
        g_send_exception_info =
            (send_exception_info_func_t)dlsym(RTLD_DEFAULT, "_send_exception_info");
    }

    if (g_send_exception_info)
    {
        // debug_log_develop(LOG_INFO, "Resolved send_exception_info at %p", g_send_exception_info);
    }
    else
    {
        const char* err = dlerror();
        debug_log(LOG_ERROR, "Failed to resolve send_exception_info: %s",
                  err ? err : "unknown error");
    }

    initialized = true;
    // debug_log_develop(LOG_INFO, "Dynamic library initialization complete");
}

// C function wrapper for handle_exception to avoid name mangling
extern "C" kern_return_t handle_exception_dynamic(Debugger* debugger, mach_port_t exception_port,
                                                  mach_port_t thread, mach_port_t task,
                                                  exception_type_t exception,
                                                  mach_exception_data_t code,
                                                  mach_msg_type_number_t code_count)
{
    if (debugger)
    {
        return debugger->handle_exception(exception_port, thread, task, exception, code,
                                          code_count);
    }
    return KERN_FAILURE;
}
#endif

// =============================================================================
// Constructor and Destructor
// =============================================================================

Debugger::Debugger(pid_t pid)
    : pid_(pid),
      task_port_(MACH_PORT_NULL),
      exception_port_(MACH_PORT_NULL),
      watchpoint_used(MAX_WATCHPOINTS, false),
      watchpoint_addresses(MAX_WATCHPOINTS, 0),
      watchpoint_sizes(MAX_WATCHPOINTS, 0),
      breakpoint_used(MAX_BREAKPOINTS, false),
      breakpoint_addresses(MAX_BREAKPOINTS, 0),
      breakpoint_hit_counts(MAX_BREAKPOINTS, 0),
      breakpoint_target_counts(MAX_BREAKPOINTS, 0),
      breakpoint_end_addresses(MAX_BREAKPOINTS, 0),
      software_breakpoint_used(MAX_SOFTWARE_BREAKPOINTS, false),
      software_breakpoint_addresses(MAX_SOFTWARE_BREAKPOINTS, 0),
      software_breakpoint_original_bytes(MAX_SOFTWARE_BREAKPOINTS * 4,
                                         0)  // 4 bytes per breakpoint for ARM64
{
}

Debugger::~Debugger()
{
    if (exception_port_ != MACH_PORT_NULL)
    {
        mach_port_deallocate(mach_task_self(), exception_port_);
    }
    if (task_port_ != MACH_PORT_NULL)
    {
        mach_port_deallocate(mach_task_self(), task_port_);
    }
}

// =============================================================================
// Initialization
// =============================================================================

// Forward declaration for task port cache function from native_api.mm
extern "C" void set_cached_task_port(pid_t pid, mach_port_t task);

bool Debugger::initialize()
{
    kern_return_t kr;

    kr = task_for_pid(mach_task_self(), pid_, &task_port_);
    if (kr != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "task_for_pid failed: %s", kern_return_to_string(kr).c_str());
        return false;
    }

    // Share the task port with native_api.mm's cache
    set_cached_task_port(pid_, task_port_);

    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &exception_port_);
    if (kr != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "mach_port_allocate failed: %s", kern_return_to_string(kr).c_str());
        return false;
    }

    kr = mach_port_insert_right(mach_task_self(), exception_port_, exception_port_,
                                MACH_MSG_TYPE_MAKE_SEND);
    if (kr != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "mach_port_insert_right failed: %s",
                  kern_return_to_string(kr).c_str());
        return false;
    }

    kr = task_set_exception_ports(task_port_, EXC_MASK_ALL, exception_port_, EXCEPTION_DEFAULT,
                                  ARM_THREAD_STATE64);
    if (kr != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "task_set_exception_ports failed: %s",
                  kern_return_to_string(kr).c_str());
        return false;
    }

    // debug_log_develop(LOG_INFO, "Debugger initialized for process %d", pid_);
    return true;
}

// =============================================================================
// Main Loop
// =============================================================================

void Debugger::run()
{
    kern_return_t kr = mach_msg_server(exc_server, 2048, exception_port_, MACH_MSG_OPTION_NONE);

    if (kr != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "mach_msg_server failed: %s", kern_return_to_string(kr).c_str());
    }
    else
    {
        // debug_log_develop(LOG_INFO, "mach_msg_server succeeded.");
    }
}

// =============================================================================
// Helper Functions
// =============================================================================

std::string Debugger::kern_return_to_string(kern_return_t kr)
{
    return mach_error_string(kr);
}

```

`src/server/src/cpp/src/darwin/debugger/debugger_exception.mm`:

```mm
/**
 * @file debugger_exception.mm
 * @brief Exception handling and single-step related Debugger class member functions (Darwin/macOS)
 *
 * This file contains the implementation of exception handling, execution control,
 * and single-step functionality for the Darwin debugger.
 *
 * Functions included:
 *   - handle_exception: Main exception handling function for Mach exceptions
 *   - handle_single_step: Dispatcher for single step completion handling
 */

#include "debugger_internal.h"

// =============================================================================
// Main Exception Handler
// =============================================================================

kern_return_t Debugger::handle_exception(mach_port_t exception_port, mach_port_t thread,
                                         mach_port_t task, exception_type_t exception,
                                         mach_exception_data_t code,
                                         mach_msg_type_number_t code_count)
{
    if (exception == EXC_SYSCALL)
    {
        debug_log_develop(LOG_INFO, "Received EXC_SYSCALL exception");
        return KERN_FAILURE;  // Ignore syscall exceptions
    }
    if (exception != EXC_BREAKPOINT && exception != EXC_GUARD)
    {
        return KERN_FAILURE;
    }

    arm_thread_state64_t thread_state;
    mach_msg_type_number_t thread_state_count = ARM_THREAD_STATE64_COUNT;
    kern_return_t kr = thread_get_state(thread, ARM_THREAD_STATE64, (thread_state_t)&thread_state,
                                        &thread_state_count);
    if (kr != KERN_SUCCESS)
    {
        debug_log_develop(LOG_ERROR, "Failed to get thread state: %s", mach_error_string(kr));
        return kr;
    }

    arm_debug_state64_t debug_state;
    mach_msg_type_number_t debug_state_count = ARM_DEBUG_STATE64_COUNT;
    kr = thread_get_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&debug_state,
                          &debug_state_count);
    if (kr != KERN_SUCCESS)
    {
        debug_log_develop(LOG_ERROR, "Failed to get debug state: %s", mach_error_string(kr));
        return kr;
    }

    arm_exception_state64_t exception_state;
    mach_msg_type_number_t exception_state_count = ARM_EXCEPTION_STATE64_COUNT;
    kr = thread_get_state(thread, ARM_EXCEPTION_STATE64, (thread_state_t)&exception_state,
                          &exception_state_count);
    if (kr != KERN_SUCCESS)
    {
        debug_log_develop(LOG_ERROR, "Failed to get exception state: %s", mach_error_string(kr));
        return kr;
    }

    NativeExceptionInfo info = {};
    info.architecture = ARCH_ARM64;
    for (int i = 0; i < 30; ++i)
    {
        info.regs.arm64.x[i] = thread_state.__x[i];
    }
    info.regs.arm64.lr = thread_state.__lr;
    info.regs.arm64.fp = thread_state.__fp;
    info.regs.arm64.sp = thread_state.__sp;
    info.regs.arm64.pc = thread_state.__pc;
    info.regs.arm64.cpsr = thread_state.__cpsr;
    info.thread_id = (uint64_t)thread;

    uint32_t esr = exception_state.__esr;
    uint32_t ec = (esr >> 26) & 0x3F;  // Exception Class

    // Handle single step mode - but only for the correct exception type
    // debug_log_develop(LOG_DEBUG, "handle_exception: Checking thread_states_ for thread %d",
    // thread);
    auto thread_it = thread_states_.find(thread);
    if (thread_it != thread_states_.end() &&
        thread_it->second.single_step_mode != SingleStepMode::None)
    {
        // debug_log_develop(LOG_ERROR, "Handling single step for thread %d, EC: 0x%02x", thread,
        // ec);

        // Only send exception info to UI for Breakpoint/SoftwareBreakpoint single steps
        int matched_sw_bp = -1;
        {
            for (int i = 0; i < MAX_SOFTWARE_BREAKPOINTS; i++)
            {
                if (software_breakpoint_used[i] &&
                    software_breakpoint_addresses[i] == thread_state.__pc)
                {
                    matched_sw_bp = i;
                    break;
                }
            }
        }
        if ((thread_it->second.single_step_mode == SingleStepMode::Breakpoint ||
             thread_it->second.single_step_mode == SingleStepMode::SoftwareBreakpoint) &&
            matched_sw_bp == -1)
        {
            info.exception_type = EXCEPTION_SINGLESTEP;
            info.singlestep_mode = (uint64_t)thread_it->second.single_step_mode;

            // Check if this is a trace exception (target_count > 0)
            int bp_index = thread_it->second.current_breakpoint_index;
            if (bp_index >= 0 && bp_index < MAX_BREAKPOINTS)
            {
                std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
                int target_count = breakpoint_target_counts[bp_index];
                info.is_trace = (target_count > 0) ? 1 : 0;
            }
            else
            {
                info.is_trace = 0;
            }

            // Check if trace file output is enabled
            bool write_to_file = false;
            {
                std::lock_guard<std::mutex> lock(trace_file_mutex_);
                write_to_file = trace_file_enabled_ && trace_file_writer_ && info.is_trace;
            }

            if (write_to_file)
            {
                // Write to trace file instead of sending to UI
                TraceEntryArm64 entry;
                memset(&entry, 0, sizeof(entry));

                auto now = std::chrono::system_clock::now();
                auto duration = now.time_since_epoch();
                entry.timestamp =
                    std::chrono::duration_cast<std::chrono::microseconds>(duration).count();

                entry.pc = thread_state.__pc;
                for (int i = 0; i < 30; ++i)
                {
                    entry.x[i] = thread_state.__x[i];
                }
                entry.lr = thread_state.__lr;
                entry.sp = thread_state.__sp;
                entry.cpsr = thread_state.__cpsr;

                // Read instruction at PC
                uint8_t instr_bytes[4];
                mach_vm_size_t bytes_read = 0;
                kern_return_t read_kr = mach_vm_read_overwrite(
                    task_port_, thread_state.__pc, 4, (mach_vm_address_t)instr_bytes, &bytes_read);

                if (read_kr == KERN_SUCCESS && bytes_read == 4)
                {
#ifdef DYNAMIC_LIB_BUILD
                    snprintf(entry.instruction, TRACE_INSTRUCTION_SIZE, "%02x %02x %02x %02x",
                             instr_bytes[0], instr_bytes[1], instr_bytes[2], instr_bytes[3]);
                    entry.instruction_length = strlen(entry.instruction);
#else
                    char* disasm = disassemble_at_address(instr_bytes, 4, thread_state.__pc);
                    if (disasm)
                    {
                        strncpy(entry.instruction, disasm, TRACE_INSTRUCTION_SIZE - 1);
                        entry.instruction[TRACE_INSTRUCTION_SIZE - 1] = '\0';
                        entry.instruction_length = strlen(entry.instruction);
                        free_string(disasm);
                    }
                    else
                    {
                        snprintf(entry.instruction, TRACE_INSTRUCTION_SIZE, "%02x %02x %02x %02x",
                                 instr_bytes[0], instr_bytes[1], instr_bytes[2], instr_bytes[3]);
                        entry.instruction_length = strlen(entry.instruction);
                    }
#endif
                }

                // Read memory at x0-x5
                for (int i = 0; i < TRACE_MEMORY_REG_COUNT; ++i)
                {
                    uint64_t addr = thread_state.__x[i];
                    if (addr != 0)
                    {
                        mach_vm_size_t mem_read = 0;
                        mach_vm_read_overwrite(task_port_, addr, TRACE_MEMORY_DUMP_SIZE,
                                               (mach_vm_address_t)entry.memory[i], &mem_read);
                    }
                }

                // Perform full memory dump on first breakpoint hit
                if (full_memory_cache_enabled_ && !memory_dump_completed_)
                {
                    debug_log_develop(LOG_INFO,
                                      "Performing initial memory dump on first breakpoint hit");
                    if (dump_all_memory_regions())
                    {
                        memory_dump_completed_ = true;
                    }
                }

                // Write entry to trace file
                uint32_t current_entry_index = 0;
                {
                    std::lock_guard<std::mutex> lock(trace_file_mutex_);
                    if (trace_file_writer_)
                    {
                        current_entry_index = trace_file_writer_->get_entry_count();
                        trace_file_writer_->write_entry(entry);
                    }
                }

                // Log memory access if full memory cache is enabled
                if (full_memory_cache_enabled_ && read_kr == KERN_SUCCESS && bytes_read == 4)
                {
                    uint32_t instruction = instr_bytes[0] | (instr_bytes[1] << 8) |
                                           (instr_bytes[2] << 16) | (instr_bytes[3] << 24);

                    Arm64MemoryAccess mem_access = decode_arm64_memory_access(
                        instruction, thread_state.__x, thread_state.__sp, thread_state.__pc);

                    if (mem_access.is_valid && mem_access.size > 0 && mem_access.size <= 256)
                    {
                        std::lock_guard<std::mutex> lock(memory_cache_mutex_);
                        if (memory_access_log_writer_)
                        {
                            uint8_t mem_data[256];
                            mach_vm_size_t mem_read = 0;
                            kern_return_t mem_kr = mach_vm_read_overwrite(
                                task_port_, mem_access.address, mem_access.size,
                                (mach_vm_address_t)mem_data, &mem_read);

                            if (mem_kr == KERN_SUCCESS && mem_read > 0)
                            {
                                memory_access_log_writer_->write_access(
                                    current_entry_index, mem_access.address, (uint32_t)mem_read,
                                    mem_access.is_write != 0, mem_data);

                                if (mem_access.is_pair && mem_access.address2 != 0)
                                {
                                    mem_kr = mach_vm_read_overwrite(
                                        task_port_, mem_access.address2, mem_access.size,
                                        (mach_vm_address_t)mem_data, &mem_read);

                                    if (mem_kr == KERN_SUCCESS && mem_read > 0)
                                    {
                                        memory_access_log_writer_->write_access(
                                            current_entry_index, mem_access.address2,
                                            (uint32_t)mem_read, mem_access.is_write != 0, mem_data);
                                    }
                                }
                            }
                        }
                    }
                }

                debug_log_develop(LOG_DEBUG, "Wrote trace entry to file (PC: 0x%llx)", entry.pc);
            }
            else
            {
#ifdef DYNAMIC_LIB_BUILD
                if (g_send_exception_info)
                {
                    g_send_exception_info(&info, pid_);
                }
#else
                send_exception_info(&info, pid_);
#endif
            }
        }

        // debug_log_develop(LOG_DEBUG, "handle_exception: Calling handle_single_step");
        return handle_single_step(thread, debug_state, thread_state, exception_state);
    }

    if (ec == 0x34 || ec == 0x35)
    {
        // Watchpoint exception
        uint64_t far = exception_state.__far;
        info.memory_address = far;
        info.exception_type = EXCEPTION_WATCHPOINT;

        int matched_watchpoint = -1;
        {
            std::lock_guard<std::mutex> lock(watchpoint_data_mutex_);
            for (int i = 0; i < MAX_WATCHPOINTS; i++)
            {
                if (watchpoint_used[i] && far >= watchpoint_addresses[i] &&
                    far < watchpoint_addresses[i] + watchpoint_sizes[i])
                {
                    matched_watchpoint = i;
                    break;
                }
            }
        }

        if (matched_watchpoint != -1)
        {
#ifdef DYNAMIC_LIB_BUILD
            if (g_send_exception_info)
            {
                g_send_exception_info(&info, pid_);
            }
#else
            send_exception_info(&info, pid_);
#endif
            return handle_watchpoint_hit(thread, debug_state, thread_state, exception_state,
                                         matched_watchpoint);
        }

        debug_log_develop(LOG_ERROR, "Watchpoint exception but no matching watchpoint found");
    }
    else if (ec == 0x3c)  // BRK instruction (software breakpoint)
    {
        info.exception_type = EXCEPTION_BREAKPOINT;

        int matched_sw_bp = -1;
        {
            std::lock_guard<std::mutex> lock(software_breakpoint_mutex_);
            for (int i = 0; i < MAX_SOFTWARE_BREAKPOINTS; i++)
            {
                if (software_breakpoint_used[i] &&
                    software_breakpoint_addresses[i] == thread_state.__pc)
                {
                    matched_sw_bp = i;
                    break;
                }
            }
        }

        if (matched_sw_bp != -1)
        {
            bool should_notify = false;
#ifdef DYNAMIC_LIB_BUILD
            if (g_send_exception_info)
            {
                should_notify = g_send_exception_info(&info, pid_);
            }
#else
            should_notify = send_exception_info(&info, pid_);
#endif

            if (!should_notify)
            {
                bool bp_still_exists = false;
                {
                    std::lock_guard<std::mutex> lock(software_breakpoint_mutex_);
                    bp_still_exists = software_breakpoint_used[matched_sw_bp];
                }

                if (bp_still_exists)
                {
                    uint8_t original_bytes[4];
                    memcpy(original_bytes, &software_breakpoint_original_bytes[matched_sw_bp * 4],
                           4);

                    ssize_t bytes_written =
                        write_memory_native(pid_, thread_state.__pc, 4, original_bytes);
                    if (bytes_written != 4)
                    {
                        debug_log_develop(LOG_ERROR,
                                          "Failed to restore original instruction for step-over");
                        return KERN_FAILURE;
                    }
                }

                debug_state.__mdscr_el1 |= 1ULL;
                kr = thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&debug_state,
                                      ARM_DEBUG_STATE64_COUNT);
                if (kr != KERN_SUCCESS)
                {
                    debug_log_develop(LOG_ERROR, "Failed to enable single-step: %s",
                                      mach_error_string(kr));
                    return kr;
                }

                thread_states_[thread] =
                    ThreadState{.single_step_mode = SingleStepMode::SoftwareBreakpointContinue,
                                .single_step_count = 0,
                                .current_breakpoint_index = -1,
                                .current_watchpoint_index = -1,
                                .current_software_breakpoint_index = matched_sw_bp,
                                .is_stopped = false,
                                .thread_state = thread_state,
                                .debug_state = debug_state,
                                .exception_state = exception_state};

                return KERN_SUCCESS;
            }

            // Enter break state
            current_thread = thread;
            thread_states_[thread] = ThreadState{.single_step_mode = SingleStepMode::None,
                                                 .single_step_count = 0,
                                                 .current_breakpoint_index = -1,
                                                 .current_watchpoint_index = -1,
                                                 .current_software_breakpoint_index = matched_sw_bp,
                                                 .is_stopped = true,
                                                 .thread_state = thread_state,
                                                 .debug_state = debug_state,
                                                 .exception_state = exception_state};
            debug_state_ = DebugState::BreakpointHit;

            kern_return_t suspend_result = thread_suspend(thread);
            if (suspend_result != KERN_SUCCESS)
            {
                debug_log(LOG_ERROR, "Failed to suspend thread: %s",
                          kern_return_to_string(suspend_result).c_str());
            }

            return KERN_SUCCESS;
        }
    }
    else if (ec == 0x30 || ec == 0x31)  // Hardware breakpoint
    {
        info.exception_type = EXCEPTION_BREAKPOINT;

        for (int i = 0; i < MAX_BREAKPOINTS; i++)
        {
            if (breakpoint_used[i] && thread_state.__pc == breakpoint_addresses[i])
            {
                int target_count = 0;
                {
                    std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
                    target_count = breakpoint_target_counts[i];
                }
                info.is_trace = (target_count > 0) ? 1 : 0;

                // Check tracked thread for tracing
                if (target_count > 0)
                {
                    mach_port_t expected = MACH_PORT_NULL;
                    bool is_tracked_thread =
                        tracked_trace_thread_.compare_exchange_strong(expected, thread);

                    if (!is_tracked_thread && tracked_trace_thread_.load() != thread)
                    {
                        debug_log_develop(LOG_INFO, "Thread %d not tracked, resuming", thread);
#ifdef DYNAMIC_LIB_BUILD
                        if (g_send_exception_info)
                        {
                            g_send_exception_info(&info, pid_);
                        }
#else
                        send_exception_info(&info, pid_);
#endif
                        return KERN_SUCCESS;
                    }
                }

                // Check if trace file output is enabled
                bool write_to_file = false;
                {
                    std::lock_guard<std::mutex> lock(trace_file_mutex_);
                    write_to_file = trace_file_enabled_ && trace_file_writer_ && info.is_trace;
                }

                if (write_to_file)
                {
                    // Write first trace entry to file
                    TraceEntryArm64 entry;
                    memset(&entry, 0, sizeof(entry));

                    auto now = std::chrono::system_clock::now();
                    auto duration = now.time_since_epoch();
                    entry.timestamp =
                        std::chrono::duration_cast<std::chrono::microseconds>(duration).count();

                    entry.pc = thread_state.__pc;
                    for (int j = 0; j < 30; ++j)
                    {
                        entry.x[j] = thread_state.__x[j];
                    }
                    entry.lr = thread_state.__lr;
                    entry.sp = thread_state.__sp;
                    entry.cpsr = thread_state.__cpsr;

                    // Read instruction at PC
                    uint8_t instr_bytes[4];
                    mach_vm_size_t bytes_read = 0;
                    kern_return_t read_kr =
                        mach_vm_read_overwrite(task_port_, thread_state.__pc, 4,
                                               (mach_vm_address_t)instr_bytes, &bytes_read);

                    if (read_kr == KERN_SUCCESS && bytes_read == 4)
                    {
#ifdef DYNAMIC_LIB_BUILD
                        snprintf(entry.instruction, TRACE_INSTRUCTION_SIZE, "%02x %02x %02x %02x",
                                 instr_bytes[0], instr_bytes[1], instr_bytes[2], instr_bytes[3]);
                        entry.instruction_length = strlen(entry.instruction);
#else
                        char* disasm = disassemble_at_address(instr_bytes, 4, thread_state.__pc);
                        if (disasm)
                        {
                            strncpy(entry.instruction, disasm, TRACE_INSTRUCTION_SIZE - 1);
                            entry.instruction[TRACE_INSTRUCTION_SIZE - 1] = '\0';
                            entry.instruction_length = strlen(entry.instruction);
                            free_string(disasm);
                        }
                        else
                        {
                            snprintf(entry.instruction, TRACE_INSTRUCTION_SIZE,
                                     "%02x %02x %02x %02x", instr_bytes[0], instr_bytes[1],
                                     instr_bytes[2], instr_bytes[3]);
                            entry.instruction_length = strlen(entry.instruction);
                        }
#endif
                    }

                    // Read memory at x0-x5
                    for (int j = 0; j < TRACE_MEMORY_REG_COUNT; ++j)
                    {
                        uint64_t addr = thread_state.__x[j];
                        if (addr != 0)
                        {
                            mach_vm_size_t mem_read = 0;
                            mach_vm_read_overwrite(task_port_, addr, TRACE_MEMORY_DUMP_SIZE,
                                                   (mach_vm_address_t)entry.memory[j], &mem_read);
                        }
                    }

                    // Perform full memory dump on first breakpoint hit
                    if (full_memory_cache_enabled_ && !memory_dump_completed_)
                    {
                        if (dump_all_memory_regions())
                        {
                            memory_dump_completed_ = true;
                        }
                    }

                    {
                        std::lock_guard<std::mutex> lock(trace_file_mutex_);
                        if (trace_file_writer_)
                        {
                            trace_file_writer_->write_entry(entry);
                        }
                    }
                }
                else
                {
                    // Check callback
                    bool should_notify = false;
#ifdef DYNAMIC_LIB_BUILD
                    if (g_send_exception_info)
                    {
                        should_notify = g_send_exception_info(&info, pid_);
                    }
#else
                    should_notify = send_exception_info(&info, pid_);
#endif
                    if (!should_notify)
                    {
                        debug_state.__bcr[i] = 0;
                        debug_state.__mdscr_el1 |= 1ULL;

                        kr =
                            thread_set_state(thread, ARM_DEBUG_STATE64,
                                             (thread_state_t)&debug_state, ARM_DEBUG_STATE64_COUNT);
                        if (kr != KERN_SUCCESS)
                        {
                            debug_log_develop(LOG_ERROR, "Failed to set debug state: %s",
                                              mach_error_string(kr));
                            return kr;
                        }

                        thread_states_[thread] = ThreadState{
                            .single_step_mode = SingleStepMode::HardwareBreakpointContinue,
                            .single_step_count = 0,
                            .current_breakpoint_index = i,
                            .current_watchpoint_index = -1,
                            .is_stopped = false,
                            .thread_state = thread_state,
                            .debug_state = debug_state,
                            .exception_state = exception_state};
                        debug_state_ = DebugState::SingleStepping;

                        return KERN_SUCCESS;
                    }
                }

                // Re-check hit count
                int current_hit_count = 0;
                {
                    std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
                    target_count = breakpoint_target_counts[i];
                    breakpoint_hit_counts[i]++;
                    current_hit_count = breakpoint_hit_counts[i];
                }

                if (target_count > 0 && current_hit_count < target_count)
                {
                    // Tracing mode: single-step and continue
                    debug_state.__bcr[i] = 0;
                    debug_state.__mdscr_el1 |= 1ULL;

                    kr = thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&debug_state,
                                          ARM_DEBUG_STATE64_COUNT);
                    if (kr != KERN_SUCCESS)
                    {
                        debug_log_develop(LOG_ERROR, "Failed to set debug state for tracing: %s",
                                          mach_error_string(kr));
                        return kr;
                    }

                    current_thread = thread;
                    thread_states_[thread] =
                        ThreadState{.single_step_mode = SingleStepMode::Breakpoint,
                                    .single_step_count = 0,
                                    .current_breakpoint_index = i,
                                    .current_watchpoint_index = -1,
                                    .is_stopped = false,
                                    .thread_state = thread_state,
                                    .debug_state = debug_state,
                                    .exception_state = exception_state};
                    debug_state_ = DebugState::SingleStepping;

                    return KERN_SUCCESS;
                }

                // Wait mode or tracing complete - enter break state
                current_thread = thread;
                thread_states_[thread] = ThreadState{.single_step_mode = SingleStepMode::None,
                                                     .single_step_count = 0,
                                                     .current_breakpoint_index = i,
                                                     .current_watchpoint_index = -1,
                                                     .is_stopped = true,
                                                     .thread_state = thread_state,
                                                     .debug_state = debug_state,
                                                     .exception_state = exception_state};
                debug_state_ = DebugState::BreakpointHit;

                kern_return_t suspend_result = thread_suspend(thread);
                if (suspend_result != KERN_SUCCESS)
                {
                    debug_log_develop(LOG_ERROR, "Failed to suspend thread: %s",
                                      kern_return_to_string(suspend_result).c_str());
                }

                return KERN_SUCCESS;
            }
        }
        debug_log_develop(LOG_ERROR, "Breakpoint exception but no matching breakpoint found");
    }
    else
    {
        debug_log_develop(LOG_ERROR, "Unhandled exception class: 0x%02x", ec);
    }

    return KERN_SUCCESS;
}

// =============================================================================
// Single Step Handler
// =============================================================================

kern_return_t Debugger::handle_single_step(mach_port_t thread, arm_debug_state64_t& debug_state,
                                           arm_thread_state64_t& thread_state,
                                           arm_exception_state64_t& exception_state)
{
    SingleStepMode mode;
    int bp_index = -1;
    int sw_bp_index = -1;

    {
        std::lock_guard<std::mutex> lock(thread_states_mutex_);
        auto thread_it = thread_states_.find(thread);
        if (thread_it == thread_states_.end())
        {
            debug_log(LOG_ERROR, "Thread %d not found in thread_states_", thread);
            return KERN_FAILURE;
        }

        thread_it->second.thread_state = thread_state;
        thread_it->second.debug_state = debug_state;
        thread_it->second.exception_state = exception_state;

        mode = thread_it->second.single_step_mode;
        bp_index = thread_it->second.current_breakpoint_index;
        sw_bp_index = thread_it->second.current_software_breakpoint_index;
    }

    switch (mode)
    {
        case SingleStepMode::Watchpoint:
            return complete_watchpoint_single_step(thread, debug_state, thread_state,
                                                   exception_state);
        case SingleStepMode::Breakpoint:
        {
            int target_count = 0;
            int current_hit_count = 0;
            mach_vm_address_t end_addr = 0;
            if (bp_index >= 0 && bp_index < MAX_BREAKPOINTS)
            {
                std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
                target_count = breakpoint_target_counts[bp_index];
                breakpoint_hit_counts[bp_index]++;
                current_hit_count = breakpoint_hit_counts[bp_index];
                end_addr = breakpoint_end_addresses[bp_index];
            }

            mach_vm_address_t current_pc = thread_state.__pc;
            bool reached_end = (end_addr != 0) && (current_pc == end_addr);

            // Script trace stop check
            bool script_stop_requested = script_trace_stop_requested_.load();
            if (script_stop_requested)
            {
                bool notify_ui = script_trace_stop_with_ui_notification_.load();

                clear_script_trace_stop_request();
                trace_session_ended_by_end_address_ = true;
                tracked_trace_thread_.store(MACH_PORT_NULL);

                {
                    std::lock_guard<std::mutex> lock(trace_file_mutex_);
                    if (trace_file_enabled_ && trace_file_writer_)
                    {
                        trace_file_writer_->close();
                        trace_file_enabled_ = false;
                    }
                }

                disable_full_memory_cache();

                if (bp_index >= 0 && bp_index < MAX_BREAKPOINTS)
                {
                    mach_vm_address_t bp_addr;
                    {
                        std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
                        bp_addr = breakpoint_addresses[bp_index];
                    }
                    remove_breakpoint(bp_addr);
                }

                {
                    std::lock_guard<std::mutex> lock(thread_states_mutex_);
                    thread_states_.erase(thread);
                }

                debug_state.__mdscr_el1 &= ~1ULL;
                thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&debug_state,
                                 ARM_DEBUG_STATE64_COUNT);

                debug_state_ = DebugState::Running;
                current_thread = MACH_PORT_NULL;

                if (notify_ui)
                {
                    NativeExceptionInfo info = {};
                    info.architecture = ARCH_ARM64;
                    info.exception_type = EXCEPTION_SINGLESTEP;
                    info.thread_id = thread;
                    info.regs.arm64.pc = current_pc;
                    send_exception_info(&info, pid_);
                }

                return KERN_SUCCESS;
            }

            if (reached_end)
            {
                debug_log(LOG_INFO, "PC 0x%llx reached end address 0x%llx", current_pc, end_addr);

                trace_session_ended_by_end_address_ = true;
                tracked_trace_thread_.store(MACH_PORT_NULL);

                {
                    std::lock_guard<std::mutex> lock(trace_file_mutex_);
                    if (trace_file_enabled_ && trace_file_writer_)
                    {
                        trace_file_writer_->close();
                        trace_file_enabled_ = false;
                    }
                }

                disable_full_memory_cache();

                if (bp_index >= 0 && bp_index < MAX_BREAKPOINTS)
                {
                    mach_vm_address_t bp_addr;
                    {
                        std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
                        bp_addr = breakpoint_addresses[bp_index];
                    }
                    remove_breakpoint(bp_addr);
                }

                {
                    std::lock_guard<std::mutex> lock(thread_states_mutex_);
                    thread_states_.erase(thread);
                }

                debug_state.__mdscr_el1 &= ~1ULL;
                thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&debug_state,
                                 ARM_DEBUG_STATE64_COUNT);

                debug_state_ = DebugState::Running;
                current_thread = MACH_PORT_NULL;

                return KERN_SUCCESS;
            }

            if (target_count > 0 && current_hit_count < target_count)
            {
                // Continue tracing
                debug_state_ = DebugState::SingleStepping;
                debug_state.__mdscr_el1 |= 1ULL;
                kern_return_t kr =
                    thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&debug_state,
                                     ARM_DEBUG_STATE64_COUNT);
                if (kr != KERN_SUCCESS)
                {
                    debug_log(LOG_ERROR, "Failed to re-enable single-step: %s",
                              mach_error_string(kr));
                    return kr;
                }
                return KERN_SUCCESS;
            }

            // Tracing complete
            if (target_count > 0)
            {
                tracked_trace_thread_.store(MACH_PORT_NULL);
                debug_state.__mdscr_el1 &= ~1ULL;
                thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&debug_state,
                                 ARM_DEBUG_STATE64_COUNT);

                {
                    std::lock_guard<std::mutex> lock(thread_states_mutex_);
                    thread_states_.erase(thread);
                }

                debug_state_ = DebugState::Running;
                current_thread = MACH_PORT_NULL;

                // Remove breakpoint from all threads
                mach_vm_address_t bp_address = breakpoint_addresses[bp_index];
                if (bp_address != 0)
                {
                    thread_act_array_t thread_list;
                    mach_msg_type_number_t thread_count;
                    if (task_threads(task_port_, &thread_list, &thread_count) == KERN_SUCCESS)
                    {
                        for (mach_msg_type_number_t i = 0; i < thread_count; i++)
                        {
                            arm_debug_state64_t thread_debug_state;
                            mach_msg_type_number_t count = ARM_DEBUG_STATE64_COUNT;
                            if (thread_get_state(thread_list[i], ARM_DEBUG_STATE64,
                                                 (thread_state_t)&thread_debug_state,
                                                 &count) == KERN_SUCCESS)
                            {
                                thread_debug_state.__bcr[bp_index] = 0;
                                thread_set_state(thread_list[i], ARM_DEBUG_STATE64,
                                                 (thread_state_t)&thread_debug_state, count);
                            }
                            mach_port_deallocate(mach_task_self(), thread_list[i]);
                        }
                        vm_deallocate(mach_task_self(), (vm_address_t)thread_list,
                                      thread_count * sizeof(thread_act_t));
                    }
                }

                {
                    std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
                    breakpoint_used[bp_index] = false;
                    breakpoint_addresses[bp_index] = 0;
                    breakpoint_hit_counts[bp_index] = 0;
                    breakpoint_target_counts[bp_index] = 0;
                }

                {
                    std::lock_guard<std::mutex> lock(trace_file_mutex_);
                    if (trace_file_enabled_ && trace_file_writer_)
                    {
                        trace_file_writer_->close();
                        trace_file_enabled_ = false;
                    }
                }

                return KERN_SUCCESS;
            }

            // Wait mode: re-enable breakpoint and suspend
            if (bp_index >= 0 && bp_index < MAX_BREAKPOINTS)
            {
                debug_state.__bcr[bp_index] = (1ULL << 0) | (2ULL << 1) | (1ULL << 5);
            }

            debug_state_ = DebugState::BreakpointHit;
            debug_state.__mdscr_el1 &= ~1ULL;
            thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&debug_state,
                             ARM_DEBUG_STATE64_COUNT);

            {
                std::lock_guard<std::mutex> lock(thread_states_mutex_);
                auto thread_it = thread_states_.find(thread);
                if (thread_it != thread_states_.end())
                {
                    thread_it->second.single_step_mode = SingleStepMode::None;
                    thread_it->second.is_stopped = true;
                }
            }

            thread_suspend(thread);
            return KERN_SUCCESS;
        }
        case SingleStepMode::SoftwareBreakpoint:
        case SingleStepMode::SoftwareBreakpointContinue:
        {
            // Re-insert BRK instruction
            if (sw_bp_index >= 0 && sw_bp_index < MAX_SOFTWARE_BREAKPOINTS)
            {
                mach_vm_address_t bp_addr;
                bool still_active = false;

                {
                    std::lock_guard<std::mutex> sw_lock(software_breakpoint_mutex_);
                    if (software_breakpoint_used[sw_bp_index])
                    {
                        bp_addr = software_breakpoint_addresses[sw_bp_index];
                        still_active = true;
                    }
                }

                if (still_active)
                {
                    const uint32_t brk_instruction = 0xD4200000;
                    write_memory_native(pid_, bp_addr, 4, (unsigned char*)&brk_instruction);
                }
            }

            debug_state.__mdscr_el1 &= ~1ULL;
            thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&debug_state,
                             ARM_DEBUG_STATE64_COUNT);

            if (mode == SingleStepMode::SoftwareBreakpointContinue)
            {
                std::lock_guard<std::mutex> lock(thread_states_mutex_);
                auto thread_it = thread_states_.find(thread);
                if (thread_it != thread_states_.end())
                {
                    thread_it->second.single_step_mode = SingleStepMode::None;
                    thread_it->second.current_software_breakpoint_index = -1;
                    thread_it->second.is_stopped = false;
                }
                debug_state_ = DebugState::Running;
                return KERN_SUCCESS;
            }

            // User-requested single step
            {
                std::lock_guard<std::mutex> lock(thread_states_mutex_);
                auto thread_it = thread_states_.find(thread);
                if (thread_it != thread_states_.end())
                {
                    thread_it->second.single_step_mode = SingleStepMode::None;
                    thread_it->second.current_software_breakpoint_index = -1;
                    thread_it->second.is_stopped = true;
                }
            }
            debug_state_ = DebugState::BreakpointHit;
            thread_suspend(thread);
            return KERN_SUCCESS;
        }
        case SingleStepMode::HardwareBreakpointContinue:
        {
            // Re-enable hardware breakpoint
            if (bp_index >= 0 && bp_index < MAX_BREAKPOINTS)
            {
                mach_vm_address_t bp_addr = 0;
                bool still_active = false;

                {
                    std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
                    if (breakpoint_used[bp_index])
                    {
                        bp_addr = breakpoint_addresses[bp_index];
                        still_active = true;
                    }
                }

                if (still_active)
                {
                    debug_state.__bcr[bp_index] = (0xFULL << 5) | (2ULL << 1) | (1ULL << 0);
                }
            }

            debug_state.__mdscr_el1 &= ~1ULL;
            thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&debug_state,
                             ARM_DEBUG_STATE64_COUNT);

            {
                std::lock_guard<std::mutex> lock(thread_states_mutex_);
                auto thread_it = thread_states_.find(thread);
                if (thread_it != thread_states_.end())
                {
                    thread_it->second.single_step_mode = SingleStepMode::None;
                    thread_it->second.current_breakpoint_index = -1;
                    thread_it->second.is_stopped = false;
                }
            }
            debug_state_ = DebugState::Running;
            return KERN_SUCCESS;
        }
        default:
            return KERN_FAILURE;
    }
}

// =============================================================================
// Debug State Query
// =============================================================================

DebugState Debugger::get_debug_state() const
{
    return debug_state_;
}

bool Debugger::is_in_break_state() const
{
    return debug_state_ == DebugState::BreakpointHit || debug_state_ == DebugState::WatchpointHit;
}

```

`src/server/src/cpp/src/darwin/debugger/debugger_internal.h`:

```h
/**
 * @file debugger_internal.h
 * @brief Internal header for debugger implementation files (Darwin/macOS)
 *
 * This header provides common includes and declarations used across
 * the split debugger implementation files. Include this in all
 * debugger_*.mm files instead of individual headers.
 */

#ifndef DEBUGGER_INTERNAL_H
#define DEBUGGER_INTERNAL_H

#include <dlfcn.h>
#include <chrono>
#include <cstring>

#include "debugger.h"
#include "../../common/arm64_decoder.h"
#include "../../common/trace_file.h"
#include "../../common/exception_info.h"
#include "../../common/util.h"
#include "../core/native_api.h"

// =============================================================================
// Dynamic library build support
// =============================================================================

#ifdef DYNAMIC_LIB_BUILD
#define catch_exception_raise catch_exception_raise_dynamic
#define g_debugger g_debugger_dynamic
#endif

// =============================================================================
// Global declarations (defined in debugger_core.mm)
// =============================================================================

extern std::map<int, SignalConfig> g_signal_config;
extern std::mutex g_signal_config_mutex;

// =============================================================================
// Exception server declaration
// =============================================================================

extern "C"
{
    boolean_t exc_server(mach_msg_header_t* InHeadP, mach_msg_header_t* OutHeadP);
}

#endif  // DEBUGGER_INTERNAL_H

```

`src/server/src/cpp/src/darwin/debugger/debugger_native_api.mm`:

```mm
/**
 * @file debugger_native_api.mm
 * @brief Native C API wrapper functions for Debugger class (Darwin/macOS)
 *
 * This file contains the extern "C" wrapper functions that expose the Debugger
 * class functionality to the Rust layer. These are the entry points for the
 * native bridge.
 *
 * Functions included:
 *   - debugger_new: Create and initialize new debugger instance
 *   - set_watchpoint_native, remove_watchpoint_native
 *   - set_breakpoint_native, remove_breakpoint_native
 *   - get_software_breakpoint_original_bytes_native
 *   - continue_execution_native, single_step_native
 *   - read_register_native, write_register_native
 *   - is_in_break_state_native
 *   - Trace file output APIs
 *   - Full memory cache APIs
 *   - Signal configuration APIs
 *   - Script trace control APIs
 */

#include "debugger_internal.h"

extern "C"
{
    bool debugger_new(pid_t pid)
    {
#ifdef DYNAMIC_LIB_BUILD
        // Initialize dynamic functions before creating debugger
        init_dynamic_functions();
#endif

        if (g_debugger == nullptr)
        {
            g_debugger = new Debugger(pid);
            if (g_debugger->initialize())
            {
                std::thread([&]() { g_debugger->run(); }).detach();
                return true;
            }
            else
            {
                delete g_debugger;
                g_debugger = nullptr;
                return false;
            }
        }
        return true;
    }

    kern_return_t set_watchpoint_native(mach_vm_address_t address, int size, WatchpointType type)
    {
        if (g_debugger)
        {
            return g_debugger->set_watchpoint(address, size, type);
        }
        return KERN_FAILURE;
    }

    kern_return_t remove_watchpoint_native(mach_vm_address_t address)
    {
        if (g_debugger)
        {
            return g_debugger->remove_watchpoint(address);
        }
        return KERN_FAILURE;
    }

    kern_return_t set_breakpoint_native(mach_vm_address_t address, int hit_count, bool is_software,
                                        mach_vm_address_t end_address)
    {
        if (g_debugger)
        {
            return g_debugger->set_breakpoint(address, hit_count, is_software, end_address);
        }
        return KERN_FAILURE;
    }

    kern_return_t remove_breakpoint_native(mach_vm_address_t address)
    {
        if (g_debugger)
        {
            return g_debugger->remove_breakpoint(address);
        }
        return KERN_FAILURE;
    }

    // Get original instruction bytes for software breakpoint
    bool get_software_breakpoint_original_bytes_native(uint64_t address, uint8_t* out_bytes,
                                                       size_t* out_size)
    {
        if (g_debugger)
        {
            return g_debugger->get_software_breakpoint_original_bytes(address, out_bytes, out_size);
        }
        return false;
    }

    // New break state control APIs
    kern_return_t continue_execution_native(mach_port_t thread_id)
    {
        if (g_debugger)
        {
            return g_debugger->continue_execution(thread_id);
        }
        return KERN_FAILURE;
    }

    kern_return_t single_step_native(mach_port_t thread_id)
    {
        if (g_debugger)
        {
            return g_debugger->single_step(thread_id);
        }
        return KERN_FAILURE;
    }

    kern_return_t read_register_native(mach_port_t thread_id, const char* reg_name, uint64_t* value)
    {
        if (g_debugger && reg_name && value)
        {
            std::string reg_str(reg_name);
            return g_debugger->read_register(thread_id, reg_str, value);
        }
        return KERN_FAILURE;
    }

    kern_return_t write_register_native(mach_port_t thread_id, const char* reg_name, uint64_t value)
    {
        if (g_debugger && reg_name)
        {
            std::string reg_str(reg_name);
            return g_debugger->write_register(thread_id, reg_str, value);
        }
        return KERN_FAILURE;
    }

    bool is_in_break_state_native()
    {
        if (g_debugger)
        {
            return g_debugger->is_in_break_state();
        }
        return false;
    }

    // Trace file output APIs
    void enable_trace_file_output_native(const char* filepath)
    {
        if (g_debugger && filepath)
        {
            g_debugger->enable_trace_file_output(std::string(filepath));
        }
    }

    void disable_trace_file_output_native()
    {
        if (g_debugger)
        {
            g_debugger->disable_trace_file_output();
        }
    }

    bool is_trace_file_output_enabled_native()
    {
        if (g_debugger)
        {
            return g_debugger->is_trace_file_output_enabled();
        }
        return false;
    }

    const char* get_trace_file_path_native()
    {
        static std::string cached_path;
        if (g_debugger)
        {
            cached_path = g_debugger->get_trace_file_path();
            return cached_path.c_str();
        }
        return "";
    }

    uint32_t get_trace_file_entry_count_native()
    {
        if (g_debugger)
        {
            return g_debugger->get_trace_file_entry_count();
        }
        return 0;
    }

    bool is_trace_ended_by_end_address_native()
    {
        if (g_debugger)
        {
            return g_debugger->is_trace_ended_by_end_address();
        }
        return false;
    }

    void reset_trace_ended_flag_native()
    {
        if (g_debugger)
        {
            g_debugger->reset_trace_ended_flag();
        }
    }

    // Full memory cache APIs
    void enable_full_memory_cache_native(const char* dump_filepath, const char* log_filepath)
    {
        if (g_debugger && dump_filepath && log_filepath)
        {
            g_debugger->enable_full_memory_cache(std::string(dump_filepath),
                                                 std::string(log_filepath));
        }
    }

    void disable_full_memory_cache_native()
    {
        if (g_debugger)
        {
            g_debugger->disable_full_memory_cache();
        }
    }

    bool is_full_memory_cache_enabled_native()
    {
        if (g_debugger)
        {
            return g_debugger->is_full_memory_cache_enabled();
        }
        return false;
    }

    bool dump_all_memory_regions_native()
    {
        if (g_debugger)
        {
            return g_debugger->dump_all_memory_regions();
        }
        return false;
    }

    // Signal configuration APIs (catch/pass behavior)
    // These use global state so settings persist even when debugger is not attached

    // Set signal configuration (catch/pass)
    void set_signal_config_native(int signal, bool catch_signal, bool pass_signal)
    {
        SignalConfig config(catch_signal, pass_signal);
        {
            std::lock_guard<std::mutex> lock(g_signal_config_mutex);
            g_signal_config[signal] = config;
        }
        // debug_log(LOG_INFO, "Set signal %d config: catch=%d, pass=%d (stored globally)", signal,
        //          catch_signal, pass_signal);
    }

    // Get signal configuration (catch/pass)
    void get_signal_config_native(int signal, bool* catch_signal, bool* pass_signal)
    {
        std::lock_guard<std::mutex> lock(g_signal_config_mutex);
        auto it = g_signal_config.find(signal);
        if (it != g_signal_config.end())
        {
            if (catch_signal) *catch_signal = it->second.catch_signal;
            if (pass_signal) *pass_signal = it->second.pass_signal;
        }
        else
        {
            // Default: don't catch, don't pass (suppress signal, like GDB)
            if (catch_signal) *catch_signal = false;
            if (pass_signal) *pass_signal = false;
        }
    }

    // Get all signal configurations
    // Returns number of configured signals, fills arrays with signal/catch/pass values
    size_t get_all_signal_configs_native(int* signals, bool* catch_signals, bool* pass_signals,
                                         size_t max_count)
    {
        std::lock_guard<std::mutex> lock(g_signal_config_mutex);
        size_t count = 0;
        for (const auto& pair : g_signal_config)
        {
            if (count >= max_count) break;
            if (signals) signals[count] = pair.first;
            if (catch_signals) catch_signals[count] = pair.second.catch_signal;
            if (pass_signals) pass_signals[count] = pair.second.pass_signal;
            ++count;
        }
        return count;
    }

    // Remove signal configuration (reset to default)
    void remove_signal_config_native(int signal)
    {
        {
            std::lock_guard<std::mutex> lock(g_signal_config_mutex);
            g_signal_config.erase(signal);
        }
        debug_log(LOG_INFO, "Removed signal %d config", signal);
    }

    // Script trace control APIs
    void request_script_trace_stop_native(bool notify_ui)
    {
        if (g_debugger)
        {
            g_debugger->request_script_trace_stop(notify_ui);
            debug_log(LOG_INFO, "Script trace stop requested (notify_ui=%d)", notify_ui);
        }
    }

    void clear_script_trace_stop_request_native()
    {
        if (g_debugger)
        {
            g_debugger->clear_script_trace_stop_request();
        }
    }

    bool is_script_trace_stop_requested_native()
    {
        if (g_debugger)
        {
            return g_debugger->is_script_trace_stop_requested();
        }
        return false;
    }
}

```

`src/server/src/cpp/src/darwin/debugger/debugger_register.mm`:

```mm
/**
 * @file debugger_register.mm
 * @brief Register read/write and execution control related Debugger class member functions
 * (Darwin/macOS)
 *
 * This file contains the implementation of register read/write, execution continuation,
 * and single-step functionality for the Darwin debugger.
 *
 * Functions included:
 *   - read_register: Read register value from stopped thread
 *   - write_register: Write register value to stopped thread
 *   - continue_execution: Continue execution from break state
 *   - single_step: Execute single step from break state
 */

#include "debugger_internal.h"

// =============================================================================
// Execution Control
// =============================================================================

kern_return_t Debugger::continue_execution(mach_port_t thread_id)
{
    std::lock_guard<std::mutex> lock(thread_states_mutex_);

    auto thread_it = thread_states_.find(thread_id);
    if (thread_it == thread_states_.end())
    {
        debug_log_develop(LOG_ERROR, "Thread %d not found in break state", thread_id);
        return KERN_INVALID_ARGUMENT;
    }

    // Check if thread is actually stopped
    if (!thread_it->second.is_stopped)
    {
        debug_log(LOG_WARN, "Thread %d is not in stopped state", thread_id);
        return KERN_INVALID_ARGUMENT;
    }

    int sw_bp_index = thread_it->second.current_software_breakpoint_index;

    // Handle software breakpoint: need to restore original, single step, then re-insert
    if (sw_bp_index >= 0 && sw_bp_index < MAX_SOFTWARE_BREAKPOINTS)
    {
        mach_vm_address_t bp_addr;
        uint8_t original_bytes[4];
        bool valid = false;

        {
            std::lock_guard<std::mutex> sw_lock(software_breakpoint_mutex_);
            if (software_breakpoint_used[sw_bp_index])
            {
                bp_addr = software_breakpoint_addresses[sw_bp_index];
                int offset = sw_bp_index * 4;
                for (int j = 0; j < 4; j++)
                {
                    original_bytes[j] = software_breakpoint_original_bytes[offset + j];
                }
                valid = true;
            }
        }

        if (valid)
        {
            // debug_log_develop(
            //     LOG_INFO,
            //     "Continuing from software breakpoint at 0x%llx - restoring original instruction",
            //     bp_addr);

            // Restore original instruction
            ssize_t bytes_written = write_memory_native(pid_, bp_addr, 4, original_bytes);
            if (bytes_written != 4)
            {
                debug_log(LOG_ERROR, "Failed to restore original instruction at 0x%llx", bp_addr);
            }

            // Enable single-step mode to step over and re-insert breakpoint
            thread_it->second.debug_state.__mdscr_el1 |= 1ULL;
            kern_return_t kr = thread_set_state(thread_id, ARM_DEBUG_STATE64,
                                                (thread_state_t)&thread_it->second.debug_state,
                                                ARM_DEBUG_STATE64_COUNT);
            if (kr != KERN_SUCCESS)
            {
                debug_log(LOG_ERROR, "Failed to enable single-step mode for continue: %s",
                          mach_error_string(kr));
            }

            // Set up for software breakpoint continue
            thread_it->second.single_step_mode = SingleStepMode::SoftwareBreakpointContinue;
            thread_it->second.is_stopped = false;
            debug_state_ = DebugState::SingleStepping;

            // Resume thread
            kr = thread_resume(thread_id);
            if (kr != KERN_SUCCESS)
            {
                debug_log(LOG_ERROR, "Failed to resume thread %d: %s", thread_id,
                          mach_error_string(kr));
                return kr;
            }

            // debug_log_develop(LOG_INFO, "Thread %d single-stepping over software breakpoint",
            //                   thread_id);
            return KERN_SUCCESS;
        }
    }

    // Always resume the suspended thread to continue execution
    kern_return_t kr = thread_resume(thread_id);
    if (kr != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "Failed to resume thread %d: %s", thread_id, mach_error_string(kr));
        return kr;
    }

    // Mark thread as running
    thread_it->second.is_stopped = false;

    if (thread_it->second.current_breakpoint_index >= 0)
    {
        // debug_log_develop(LOG_INFO,
        //                   "Thread %d resumed, execution "
        //                   "continuing from hardware breakpoint",
        //                   thread_id);
    }
    else
    {
        // debug_log_develop(LOG_INFO,
        //                   "Thread %d resumed, execution "
        //                   "continuing (breakpoint was removed)",
        //                   thread_id);
    }

    // If this was the current thread, reset global state
    if (current_thread == thread_id)
    {
        debug_state_ = DebugState::Running;
        current_thread = MACH_PORT_NULL;
    }

    return KERN_SUCCESS;
}

kern_return_t Debugger::single_step(mach_port_t thread_id)
{
    std::lock_guard<std::mutex> lock(thread_states_mutex_);

    auto thread_it = thread_states_.find(thread_id);
    if (thread_it == thread_states_.end())
    {
        // Log which threads are actually in break state
        debug_log(LOG_ERROR, "Thread %d not found in break state. Stopped threads:", thread_id);
        for (const auto& pair : thread_states_)
        {
            debug_log(LOG_ERROR, "  - Thread %d (is_stopped=%d, bp_index=%d)", pair.first,
                      pair.second.is_stopped, pair.second.current_breakpoint_index);
        }
        if (thread_states_.empty())
        {
            debug_log(LOG_ERROR, "  (no threads in break state)");
        }
        return KERN_INVALID_ARGUMENT;
    }

    // Check if thread is actually stopped
    if (!thread_it->second.is_stopped)
    {
        debug_log(LOG_WARN, "Thread %d is not in stopped state for single step", thread_id);
        return KERN_INVALID_ARGUMENT;
    }

    // Temporarily disable the current breakpoint to avoid re-triggering during
    // single step
    int bp_index = thread_it->second.current_breakpoint_index;
    int sw_bp_index = thread_it->second.current_software_breakpoint_index;

    if (bp_index >= 0 && bp_index < MAX_BREAKPOINTS)
    {
        debug_log(LOG_ERROR,
                  "Temporarily disabling breakpoint %d "
                  "for single step",
                  bp_index);
        thread_it->second.debug_state.__bcr[bp_index] = 0;  // Disable breakpoint
    }

    // Handle software breakpoint: restore original instruction before stepping
    if (sw_bp_index >= 0 && sw_bp_index < MAX_SOFTWARE_BREAKPOINTS)
    {
        mach_vm_address_t bp_addr;
        uint8_t original_bytes[4];
        bool valid = false;

        {
            std::lock_guard<std::mutex> sw_lock(software_breakpoint_mutex_);
            if (software_breakpoint_used[sw_bp_index])
            {
                bp_addr = software_breakpoint_addresses[sw_bp_index];
                int offset = sw_bp_index * 4;
                for (int j = 0; j < 4; j++)
                {
                    original_bytes[j] = software_breakpoint_original_bytes[offset + j];
                }
                valid = true;
            }
        }

        if (valid)
        {
            // debug_log_develop(
            //     LOG_INFO, "Temporarily restoring original instruction at 0x%llx for single step",
            //     bp_addr);

            // Restore original instruction
            ssize_t bytes_written = write_memory_native(pid_, bp_addr, 4, original_bytes);
            if (bytes_written != 4)
            {
                debug_log(LOG_ERROR, "Failed to restore original instruction at 0x%llx", bp_addr);
            }
        }
    }

    // Enable single-step mode
    thread_it->second.debug_state.__mdscr_el1 |= 1ULL;
    kern_return_t kr =
        thread_set_state(thread_id, ARM_DEBUG_STATE64,
                         (thread_state_t)&thread_it->second.debug_state, ARM_DEBUG_STATE64_COUNT);
    if (kr != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR,
                  "Failed to enable single-step mode "
                  "for thread %d: %s",
                  thread_id, mach_error_string(kr));
        return kr;
    }

    // Set debug state before resuming thread
    if (current_thread == thread_id)
    {
        debug_state_ = DebugState::SingleStepping;
    }
    // Use appropriate single step mode based on breakpoint type
    if (sw_bp_index >= 0)
    {
        thread_it->second.single_step_mode = SingleStepMode::SoftwareBreakpoint;
    }
    else
    {
        thread_it->second.single_step_mode = SingleStepMode::Breakpoint;
    }
    thread_it->second.single_step_count = 1;
    thread_it->second.is_stopped = false;  // Mark as running during single-step

    // Resume the suspended thread for single step execution
    kr = thread_resume(thread_id);
    if (kr != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "Failed to resume thread %d for single step: %s", thread_id,
                  mach_error_string(kr));
        thread_it->second.is_stopped = true;  // Restore stopped state on failure
        return kr;
    }

    // debug_log_develop(LOG_INFO, "Single step initiated for thread %d", thread_id);

    return KERN_SUCCESS;
}

// =============================================================================
// Register Read/Write
// =============================================================================

kern_return_t Debugger::read_register(mach_port_t thread_id, const std::string& reg_name,
                                      uint64_t* value)
{
    if (value == nullptr)
    {
        return KERN_INVALID_ARGUMENT;
    }

    std::lock_guard<std::mutex> lock(thread_states_mutex_);

    auto thread_it = thread_states_.find(thread_id);
    if (thread_it == thread_states_.end())
    {
        debug_log(LOG_ERROR, "Thread %d not found in break state", thread_id);
        return KERN_INVALID_ARGUMENT;
    }

    // Check if thread is stopped
    if (!thread_it->second.is_stopped)
    {
        debug_log(LOG_WARN, "Thread %d is not stopped, cannot read register", thread_id);
        return KERN_INVALID_ARGUMENT;
    }

    // Get the latest thread state directly from the thread
    arm_thread_state64_t thread_state;
    mach_msg_type_number_t count = ARM_THREAD_STATE64_COUNT;
    kern_return_t kr =
        thread_get_state(thread_id, ARM_THREAD_STATE64, (thread_state_t)&thread_state, &count);
    if (kr != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "Failed to get thread state for thread %d: %s", thread_id,
                  mach_error_string(kr));
        return kr;
    }

    // Also update the cached state
    thread_it->second.thread_state = thread_state;

    if (reg_name == "pc")
    {
        *value = thread_state.__pc;
    }
    else if (reg_name == "lr")
    {
        *value = thread_state.__lr;
    }
    else if (reg_name == "fp")
    {
        *value = thread_state.__fp;
    }
    else if (reg_name == "sp")
    {
        *value = thread_state.__sp;
    }
    else if (reg_name == "cpsr")
    {
        *value = thread_state.__cpsr;
    }
    else if (reg_name.length() >= 2 && reg_name[0] == 'x')
    {
        // Handle x0-x29 registers
        int reg_num = std::stoi(reg_name.substr(1));
        if (reg_num >= 0 && reg_num <= 29)
        {
            *value = thread_state.__x[reg_num];
        }
        else
        {
            return KERN_INVALID_ARGUMENT;
        }
    }
    else
    {
        return KERN_INVALID_ARGUMENT;
    }

    return KERN_SUCCESS;
}

kern_return_t Debugger::write_register(mach_port_t thread_id, const std::string& reg_name,
                                       uint64_t value)
{
    // debug_log_develop(LOG_INFO, "write_register: thread_id=%d, reg_name=%s, value=0x%llx",
    //                   thread_id, reg_name.c_str(), value);

    std::lock_guard<std::mutex> lock(thread_states_mutex_);

    auto thread_it = thread_states_.find(thread_id);
    if (thread_it == thread_states_.end())
    {
        debug_log(LOG_ERROR, "Thread %d not found in break state. Available threads:", thread_id);
        for (const auto& pair : thread_states_)
        {
            debug_log(LOG_ERROR, "  - Thread %d (is_stopped=%d)", pair.first,
                      pair.second.is_stopped);
        }
        return KERN_INVALID_ARGUMENT;
    }

    // Check if thread is stopped
    if (!thread_it->second.is_stopped)
    {
        debug_log(LOG_WARN, "Thread %d is not stopped, cannot write register", thread_id);
        return KERN_INVALID_ARGUMENT;
    }

    auto& thread_state = thread_it->second.thread_state;

    if (reg_name == "pc")
    {
        thread_state.__pc = value;
    }
    else if (reg_name == "lr")
    {
        thread_state.__lr = value;
    }
    else if (reg_name == "fp")
    {
        thread_state.__fp = value;
    }
    else if (reg_name == "sp")
    {
        thread_state.__sp = value;
    }
    else if (reg_name == "cpsr")
    {
        thread_state.__cpsr = value;
    }
    else if (reg_name.length() >= 2 && reg_name[0] == 'x')
    {
        // Handle x0-x29 registers
        int reg_num = std::stoi(reg_name.substr(1));
        if (reg_num >= 0 && reg_num <= 29)
        {
            thread_state.__x[reg_num] = value;
        }
        else
        {
            return KERN_INVALID_ARGUMENT;
        }
    }
    else
    {
        return KERN_INVALID_ARGUMENT;
    }

    // Apply the changes to the thread
    kern_return_t kr = thread_set_state(thread_id, ARM_THREAD_STATE64,
                                        (thread_state_t)&thread_state, ARM_THREAD_STATE64_COUNT);
    if (kr != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "Failed to write register for thread %d: %s", thread_id,
                  mach_error_string(kr));
        return kr;
    }

    // debug_log_develop(LOG_INFO, "write_register: SUCCESS thread_id=%d, reg_name=%s,
    // value=0x%llx",
    //                   thread_id, reg_name.c_str(), value);
    return KERN_SUCCESS;
}

```

`src/server/src/cpp/src/darwin/debugger/debugger_trace.mm`:

```mm
/**
 * @file debugger_trace.mm
 * @brief Trace file output and memory cache related Debugger class member functions (Darwin/macOS)
 *
 * This file contains the implementation of trace file output and full memory cache
 * functionality for the Darwin debugger.
 *
 * Functions included:
 *   - enable_trace_file_output: Enable trace file recording
 *   - disable_trace_file_output: Disable and close trace file
 *   - get_trace_file_entry_count: Get number of recorded trace entries
 *   - enable_full_memory_cache: Enable memory dump and access logging
 *   - disable_full_memory_cache: Disable and close memory cache files
 *   - dump_all_memory_regions: Dump all readable memory regions to file
 */

#include "debugger_internal.h"

// =============================================================================
// Trace File Output
// =============================================================================

void Debugger::enable_trace_file_output(const std::string& filepath)
{
    std::lock_guard<std::mutex> lock(trace_file_mutex_);

    // Close existing file if open
    if (trace_file_writer_)
    {
        trace_file_writer_->close();
        trace_file_writer_.reset();
    }

    // Reset trace ended flag when starting new trace
    trace_session_ended_by_end_address_ = false;

    trace_file_path_ = filepath;
    trace_file_writer_ = std::make_unique<TraceFileWriter>();

    if (trace_file_writer_->open(filepath, TRACE_ARCH_ARM64))
    {
        trace_file_enabled_ = true;
        // debug_log_develop(LOG_INFO, "Trace file output enabled: %s", filepath.c_str());
    }
    else
    {
        debug_log(LOG_ERROR, "Failed to open trace file: %s", filepath.c_str());
        trace_file_writer_.reset();
        trace_file_enabled_ = false;
    }
}

void Debugger::disable_trace_file_output()
{
    std::lock_guard<std::mutex> lock(trace_file_mutex_);

    if (trace_file_writer_)
    {
        trace_file_writer_->close();
        // debug_log_develop(LOG_INFO, "Trace file closed: %s (entries: %u)",
        // trace_file_path_.c_str(),
        //                   trace_file_writer_->get_entry_count());
        trace_file_writer_.reset();
    }

    trace_file_enabled_ = false;
}

uint32_t Debugger::get_trace_file_entry_count() const
{
    std::lock_guard<std::mutex> lock(trace_file_mutex_);
    if (trace_file_writer_)
    {
        return trace_file_writer_->get_entry_count();
    }
    return 0;
}

bool Debugger::is_trace_file_output_enabled() const
{
    std::lock_guard<std::mutex> lock(trace_file_mutex_);
    return trace_file_enabled_;
}

const std::string& Debugger::get_trace_file_path() const
{
    std::lock_guard<std::mutex> lock(trace_file_mutex_);
    return trace_file_path_;
}

bool Debugger::is_trace_ended_by_end_address() const
{
    return trace_session_ended_by_end_address_;
}

void Debugger::reset_trace_ended_flag()
{
    trace_session_ended_by_end_address_ = false;
}

// =============================================================================
// Script Trace Control
// =============================================================================

void Debugger::request_script_trace_stop(bool notify_ui)
{
    script_trace_stop_requested_.store(true);
    script_trace_stop_with_ui_notification_.store(notify_ui);
}

void Debugger::clear_script_trace_stop_request()
{
    script_trace_stop_requested_.store(false);
    script_trace_stop_with_ui_notification_.store(false);
}

bool Debugger::is_script_trace_stop_requested() const
{
    return script_trace_stop_requested_.load();
}

// =============================================================================
// Full Memory Cache
// =============================================================================

void Debugger::enable_full_memory_cache(const std::string& dump_filepath,
                                        const std::string& log_filepath)
{
    std::lock_guard<std::mutex> lock(memory_cache_mutex_);

    // Close existing files if open
    if (memory_dump_writer_)
    {
        memory_dump_writer_->close();
        memory_dump_writer_.reset();
    }
    if (memory_access_log_writer_)
    {
        memory_access_log_writer_->close();
        memory_access_log_writer_.reset();
    }

    memory_dump_path_ = dump_filepath;
    memory_access_log_path_ = log_filepath;

    // Open memory access log writer
    memory_access_log_writer_ = std::make_unique<MemoryAccessLogWriter>();
    if (!memory_access_log_writer_->open(log_filepath))
    {
        debug_log(LOG_ERROR, "Failed to open memory access log: %s", log_filepath.c_str());
        memory_access_log_writer_.reset();
        full_memory_cache_enabled_ = false;
        return;
    }

    full_memory_cache_enabled_ = true;
    // debug_log_develop(LOG_INFO, "Full memory cache enabled: dump=%s, log=%s",
    // dump_filepath.c_str(),
    //                   log_filepath.c_str());
}

void Debugger::disable_full_memory_cache()
{
    std::lock_guard<std::mutex> lock(memory_cache_mutex_);

    if (memory_dump_writer_)
    {
        memory_dump_writer_->close();
        // debug_log_develop(LOG_INFO, "Memory dump closed: %s (regions: %u)",
        //                   memory_dump_path_.c_str(), memory_dump_writer_->get_region_count());
        memory_dump_writer_.reset();
    }

    if (memory_access_log_writer_)
    {
        memory_access_log_writer_->close();
        // debug_log_develop(LOG_INFO, "Memory access log closed: %s (accesses: %u)",
        //                   memory_access_log_path_.c_str(),
        //                   memory_access_log_writer_->get_access_count());
        memory_access_log_writer_.reset();
    }

    full_memory_cache_enabled_ = false;
    memory_dump_completed_ = false;
}

bool Debugger::is_full_memory_cache_enabled() const
{
    std::lock_guard<std::mutex> lock(memory_cache_mutex_);
    return full_memory_cache_enabled_;
}

bool Debugger::dump_all_memory_regions()
{
    std::lock_guard<std::mutex> lock(memory_cache_mutex_);

    if (memory_dump_path_.empty())
    {
        debug_log(LOG_ERROR, "Memory dump path not set");
        return false;
    }

    // Create memory dump writer
    memory_dump_writer_ = std::make_unique<MemoryDumpWriter>();
    if (!memory_dump_writer_->open(memory_dump_path_))
    {
        debug_log(LOG_ERROR, "Failed to open memory dump file: %s", memory_dump_path_.c_str());
        memory_dump_writer_.reset();
        return false;
    }

    // debug_log_develop(LOG_INFO, "Starting memory region dump to: %s", memory_dump_path_.c_str());

    // Enumerate and dump all memory regions
    vm_address_t address = 0;
    vm_size_t size = 0;
    natural_t depth = 0;
    vm_region_submap_info_data_64_t info;
    mach_msg_type_number_t info_count;
    uint32_t regions_dumped = 0;
    uint64_t total_bytes = 0;

    while (true)
    {
        info_count = VM_REGION_SUBMAP_INFO_COUNT_64;
        kern_return_t kr = vm_region_recurse_64(task_port_, &address, &size, &depth,
                                                (vm_region_recurse_info_t)&info, &info_count);

        if (kr != KERN_SUCCESS)
        {
            break;  // End of regions
        }

        if (info.is_submap)
        {
            depth++;
            continue;
        }

        // Only dump readable regions
        if ((info.protection & VM_PROT_READ) != 0)
        {
            // Allocate buffer for region data
            std::vector<uint8_t> buffer(size);
            mach_vm_size_t bytes_read = 0;

            kr = mach_vm_read_overwrite(task_port_, address, size, (mach_vm_address_t)buffer.data(),
                                        &bytes_read);

            if (kr == KERN_SUCCESS && bytes_read > 0)
            {
                if (memory_dump_writer_->write_region(address, bytes_read, info.protection,
                                                      buffer.data()))
                {
                    regions_dumped++;
                    total_bytes += bytes_read;
                    // debug_log_develop(LOG_DEBUG, "Dumped region: 0x%llx - 0x%llx (%llu bytes)",
                    //                   address, address + bytes_read, bytes_read);
                }
            }
            else
            {
                // debug_log_develop(LOG_DEBUG, "Failed to read region 0x%llx: %s", address,
                //                   mach_error_string(kr));
            }
        }

        address += size;
    }

    memory_dump_writer_->close();
    // debug_log_develop(LOG_INFO, "Memory dump complete: %u regions, %llu bytes", regions_dumped,
    //                   total_bytes);

    return true;
}

```

`src/server/src/cpp/src/darwin/debugger/debugger_types.h`:

```h
/**
 * @file debugger_types.h
 * @brief Type definitions for Darwin/macOS debugger
 *
 * Separated from debugger.h for cleaner organization.
 * Contains common types, enums, and structures used by the debugger.
 */

#ifndef DARWIN_DEBUGGER_TYPES_H
#define DARWIN_DEBUGGER_TYPES_H

#include <mach/mach.h>

#include <condition_variable>
#include <cstdint>
#include <mutex>
#include <string>
#include <vector>

// =============================================================================
// Signal configuration
// =============================================================================

/**
 * Configuration for signal catch/pass behavior
 */
struct SignalConfig
{
    bool catch_signal;  // If true, stop and notify UI when signal received
    bool pass_signal;   // If true, deliver signal to process on continue

    // Default: catch=false (don't stop), pass=false (suppress signal, like GDB)
    SignalConfig() : catch_signal(false), pass_signal(false) {}
    SignalConfig(bool catch_sig, bool pass_sig) : catch_signal(catch_sig), pass_signal(pass_sig) {}
};

// =============================================================================
// Debugger enums
// =============================================================================

/**
 * Watchpoint type enumeration
 */
enum class WatchpointType
{
    READ = 1,
    WRITE = 2,
    READWRITE = 3
};

/**
 * Breakpoint type enumeration
 */
enum class BreakpointType
{
    HARDWARE = 0,
    SOFTWARE = 1
};

/**
 * Debug state enumeration
 */
enum class DebugState
{
    Running,
    BreakpointHit,
    WatchpointHit,
    SingleStepping
};

/**
 * Single step mode enumeration
 * Used to track the reason for single-stepping
 */
enum class SingleStepMode
{
    None,
    Watchpoint,                  // Single step to complete watchpoint handling
    Breakpoint,                  // Single step for tracing at hardware breakpoint
    HardwareBreakpointContinue,  // Single step to silently continue over hardware breakpoint
    SoftwareBreakpoint,          // Single step from software breakpoint (user requested)
    SoftwareBreakpointContinue   // Single step to continue over software breakpoint
};

// =============================================================================
// Thread state structure
// =============================================================================

/**
 * Per-thread debug state information
 */
struct ThreadState
{
    SingleStepMode single_step_mode = SingleStepMode::None;
    int single_step_count = 0;
    int current_breakpoint_index = -1;
    int current_watchpoint_index = -1;           // Track which watchpoint was hit
    int current_software_breakpoint_index = -1;  // Track which software breakpoint was hit
    bool is_stopped = false;  // True if thread is currently stopped/suspended
    arm_thread_state64_t thread_state;
    arm_debug_state64_t debug_state;
    arm_exception_state64_t exception_state;
};

// =============================================================================
// Synchronization structures
// =============================================================================

/**
 * Per-watchpoint synchronization structure
 * Used to safely handle concurrent watchpoint operations
 */
struct WatchpointSync
{
    std::atomic<bool> removing{false};    // Deletion in progress flag
    std::atomic<int> active_handlers{0};  // Number of active handlers for this watchpoint
    std::mutex mutex;                     // Per-watchpoint mutex
    std::condition_variable cv;           // Per-watchpoint condition variable
};

/**
 * Per-breakpoint synchronization structure
 * Used to safely handle concurrent breakpoint operations
 */
struct BreakpointSync
{
    std::atomic<bool> removing{false};    // Deletion in progress flag
    std::atomic<int> active_handlers{0};  // Number of active handlers for this breakpoint
    std::mutex mutex;                     // Per-breakpoint mutex
    std::condition_variable cv;           // Per-breakpoint condition variable
};

// =============================================================================
// Hardware limits
// =============================================================================

// Maximum number of hardware watchpoints on ARM64
constexpr int MAX_WATCHPOINTS = 4;

// Maximum number of hardware breakpoints on ARM64
constexpr int MAX_BREAKPOINTS = 16;

// Maximum number of software breakpoints (limited by memory/management)
constexpr int MAX_SOFTWARE_BREAKPOINTS = 1000000;

#endif  // DARWIN_DEBUGGER_TYPES_H

```

`src/server/src/cpp/src/darwin/debugger/debugger_watchpoint.mm`:

```mm
/**
 * @file debugger_watchpoint.mm
 * @brief Watchpoint-related member functions for the Debugger class (Darwin/macOS)
 *
 * This file contains all watchpoint management functionality including:
 * - Hardware watchpoint set/remove operations
 * - Watchpoint hit handling
 * - Thread-specific watchpoint application
 * - Single-step completion for watchpoints
 *
 * Part of the DynaDbg Darwin debugger implementation.
 */

#include "debugger_internal.h"

// =============================================================================
// Public Watchpoint API
// =============================================================================

kern_return_t Debugger::set_watchpoint(mach_vm_address_t address, int size, WatchpointType type)
{
    thread_act_array_t thread_list;
    mach_msg_type_number_t thread_count;
    kern_return_t kr;

    kr = task_threads(task_port_, &thread_list, &thread_count);
    if (kr != KERN_SUCCESS || thread_count == 0)
    {
        debug_log(LOG_ERROR, "Failed to get threads: %s", kern_return_to_string(kr).c_str());
        return kr;
    }

    int index = find_free_watchpoint();
    if (index == -1)
    {
        debug_log(LOG_ERROR, "No free watchpoints available.");
        vm_deallocate(mach_task_self(), (vm_address_t)thread_list,
                      thread_count * sizeof(thread_act_t));
        return KERN_NO_SPACE;
    }

    // Reset sync state for this watchpoint slot
    watchpoint_sync_[index].removing.store(false);
    watchpoint_sync_[index].active_handlers.store(0);

    // Set watchpoint on all threads
    bool all_success = true;
    for (mach_msg_type_number_t i = 0; i < thread_count; i++)
    {
        kr = set_watchpoint_on_thread(thread_list[i], address, size, type, index);
        if (kr != KERN_SUCCESS)
        {
            debug_log(LOG_ERROR, "Failed to set watchpoint on thread %d: %s", i,
                      kern_return_to_string(kr).c_str());
            all_success = false;
            // Clear watchpoints on threads that were already set
            for (mach_msg_type_number_t j = 0; j < i; j++)
            {
                clear_watchpoint_on_thread(thread_list[j], index);
            }
            break;
        }
    }

    if (all_success)
    {
        std::lock_guard<std::mutex> lock(watchpoint_data_mutex_);
        watchpoint_used[index] = true;
        watchpoint_addresses[index] = address;
        watchpoint_sizes[index] = size;
        debug_log(LOG_INFO, "Watchpoint set successfully on all %d threads at address 0x%llx",
                  thread_count, address);
    }

    // Cleanup thread list
    for (mach_msg_type_number_t i = 0; i < thread_count; i++)
    {
        mach_port_deallocate(mach_task_self(), thread_list[i]);
    }
    vm_deallocate(mach_task_self(), (vm_address_t)thread_list, thread_count * sizeof(thread_act_t));

    return all_success ? KERN_SUCCESS : kr;
}

// Remove watchpoint from all threads
kern_return_t Debugger::remove_watchpoint(mach_vm_address_t address)
{
    int index = find_watchpoint_index(address);
    if (index == -1)
    {
        debug_log(LOG_ERROR, "Watchpoint not found for address: 0x%llx", address);
        return KERN_INVALID_ARGUMENT;
    }

    return remove_watchpoint_by_index(index);
}

// Index-based removal (reusable)
kern_return_t Debugger::remove_watchpoint_by_index(int index)
{
    if (index < 0 || index >= MAX_WATCHPOINTS || !watchpoint_used[index])
    {
        return KERN_INVALID_ARGUMENT;
    }

    // Set the removal flag for this specific watchpoint
    watchpoint_sync_[index].removing.store(true);

    // Wait for any in-progress hit handlers for this watchpoint to complete
    {
        std::unique_lock<std::mutex> lock(watchpoint_sync_[index].mutex);
        bool completed = watchpoint_sync_[index].cv.wait_for(
            lock, std::chrono::seconds(1),
            [this, index] { return watchpoint_sync_[index].active_handlers.load() == 0; });

        if (!completed)
        {
            debug_log(LOG_WARN,
                      "Timeout waiting for watchpoint %d handlers (count: %d), forcing reset",
                      index, watchpoint_sync_[index].active_handlers.load());
            // Force reset the counter to prevent accumulation
            watchpoint_sync_[index].active_handlers.store(0);
        }
    }

    thread_act_array_t thread_list;
    mach_msg_type_number_t thread_count;

    kern_return_t kr = task_threads(task_port_, &thread_list, &thread_count);
    if (kr != KERN_SUCCESS)
    {
        watchpoint_sync_[index].removing.store(false);  // Clear the flag
        return kr;
    }

    // Use scope guard to ensure cleanup
    auto cleanup = [&](void*)
    {
        for (mach_msg_type_number_t i = 0; i < thread_count; i++)
        {
            mach_port_deallocate(mach_task_self(), thread_list[i]);
        }
        vm_deallocate(mach_task_self(), (vm_address_t)thread_list,
                      thread_count * sizeof(thread_act_t));
    };

    std::unique_ptr<void, decltype(cleanup)> guard(nullptr, cleanup);

    // Remove from all threads
    bool all_success = true;
    for (mach_msg_type_number_t i = 0; i < thread_count; i++)
    {
        kr = clear_watchpoint_on_thread(thread_list[i], index);
        if (kr != KERN_SUCCESS)
        {
            all_success = false;
        }
    }

    // Clear the removal flag for this watchpoint
    watchpoint_sync_[index].removing.store(false);

    if (all_success)
    {
        std::lock_guard<std::mutex> lock(watchpoint_data_mutex_);
        mach_vm_address_t old_address = watchpoint_addresses[index];
        watchpoint_used[index] = false;
        watchpoint_addresses[index] = 0;
        watchpoint_sizes[index] = 0;

        debug_log(LOG_INFO, "Watchpoint removed from address 0x%llx", old_address);
        return KERN_SUCCESS;
    }

    return kr;
}

// =============================================================================
// Internal Watchpoint Operations
// =============================================================================

int Debugger::find_free_watchpoint()
{
    std::lock_guard<std::mutex> lock(watchpoint_data_mutex_);
    for (int i = 0; i < MAX_WATCHPOINTS; i++)
    {
        if (!watchpoint_used[i])
        {
            return i;
        }
    }
    return -1;
}

int Debugger::find_watchpoint_index(mach_vm_address_t address)
{
    std::lock_guard<std::mutex> lock(watchpoint_data_mutex_);
    for (int i = 0; i < MAX_WATCHPOINTS; i++)
    {
        if (watchpoint_used[i] && watchpoint_addresses[i] == address)
        {
            return i;
        }
    }
    return -1;
}

int Debugger::get_available_watchpoints(mach_port_t thread)
{
    arm_debug_state64_t debug_state;
    mach_msg_type_number_t count = ARM_DEBUG_STATE64_COUNT;
    kern_return_t kr =
        thread_get_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&debug_state, &count);
    if (kr != KERN_SUCCESS)
    {
        return MAX_WATCHPOINTS;
    }

    int available = 0;
    for (int i = 0; i < MAX_WATCHPOINTS; i++)
    {
        if ((debug_state.__wcr[i] & 1) == 0)
        {
            available++;
        }
    }
    return available;
}

kern_return_t Debugger::set_watchpoint_on_thread(mach_port_t thread, mach_vm_address_t address,
                                                 int size, WatchpointType type, int index)
{
    arm_debug_state64_t debug_state;
    memset(&debug_state, 0, sizeof(debug_state));
    mach_msg_type_number_t count = ARM_DEBUG_STATE64_COUNT;

    kern_return_t kr =
        thread_get_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&debug_state, &count);
    if (kr != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "Failed to get thread debug state: %s",
                  kern_return_to_string(kr).c_str());
        return kr;
    }

    debug_state.__wvr[index] = address;

    uint64_t control = 0;
    switch (type)
    {
        case WatchpointType::READ:
            control = (1ULL << 0);
            break;  // Enable
        case WatchpointType::WRITE:
            control = (1ULL << 0) | (2ULL << 3);
            break;  // Enable + Write
        case WatchpointType::READWRITE:
            control = (1ULL << 0) | (3ULL << 3);
            break;  // Enable + Read/Write
    }

    // Set the LEN field based on the size
    uint64_t len_field = 0;
    switch (size)
    {
        case 1:
            len_field = 0;
            break;
        case 2:
            len_field = 1;
            break;
        case 4:
            len_field = 2;
            break;
        case 8:
            len_field = 3;
            break;
        default:
            debug_log(LOG_ERROR, "Invalid watchpoint size");
            return KERN_INVALID_ARGUMENT;
    }
    control |= (len_field << 5);

    // Set the security state bits
    control |= (2ULL << 1);  // Enable watchpoint for EL1 mode

    debug_state.__wcr[index] = control;

    // Set the MDSCR_EL1 bit (bit 15) to enable debug
    debug_state.__mdscr_el1 |= (1ULL << 15);

    kr = thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&debug_state, count);
    if (kr != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "thread_set_state failed: %s", kern_return_to_string(kr).c_str());
    }

    return kr;
}

// Helper function: Clear watchpoint from a single thread
kern_return_t Debugger::clear_watchpoint_on_thread(thread_t thread, int index)
{
    arm_debug_state64_t debug_state;
    memset(&debug_state, 0, sizeof(debug_state));
    mach_msg_type_number_t count = ARM_DEBUG_STATE64_COUNT;

    kern_return_t kr =
        thread_get_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&debug_state, &count);
    if (kr != KERN_SUCCESS)
    {
        return kr;
    }

    // Disable only the specified watchpoint
    debug_state.__wcr[index] = 0;
    debug_state.__wvr[index] = 0;

    return thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&debug_state, count);
}

// =============================================================================
// Watchpoint Hit Handling
// =============================================================================

kern_return_t Debugger::handle_watchpoint_hit(mach_port_t thread, arm_debug_state64_t& debug_state,
                                              arm_thread_state64_t& thread_state,
                                              arm_exception_state64_t& exception_state,
                                              int watchpoint_index)
{
    // Increment active handler count for this specific watchpoint
    watchpoint_sync_[watchpoint_index].active_handlers.fetch_add(1);

    // Scope guard to ensure count is decremented and condition variable is notified
    auto decrement_guard = [this, watchpoint_index](int*)
    {
        watchpoint_sync_[watchpoint_index].active_handlers.fetch_sub(1);
        if (watchpoint_sync_[watchpoint_index].active_handlers.load() == 0)
        {
            std::lock_guard<std::mutex> lock(watchpoint_sync_[watchpoint_index].mutex);
            watchpoint_sync_[watchpoint_index].cv.notify_all();
        }
    };
    static int dummy = 0;
    std::unique_ptr<int, decltype(decrement_guard)> guard(&dummy, decrement_guard);

    // Check if this watchpoint is being removed
    if (watchpoint_sync_[watchpoint_index].removing.load())
    {
        return KERN_SUCCESS;
    }

    // Temporarily disable the watchpoint
    debug_state.__wcr[watchpoint_index] &= ~(1ULL << 0);

    // Enable single-step mode
    debug_state.__mdscr_el1 |= 1ULL;

    kern_return_t kr = thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&debug_state,
                                        ARM_DEBUG_STATE64_COUNT);
    if (kr != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "Failed to set debug state: %s", mach_error_string(kr));
        return kr;
    }

    // debug_log_develop(LOG_INFO, "handle_watchpoint_hit: Updating thread_states_ map");

    // Update thread_states_ with mutex protection
    {
        std::lock_guard<std::mutex> lock(thread_states_mutex_);

        // Re-check if being removed (may have been removed while acquiring lock)
        if (watchpoint_sync_[watchpoint_index].removing.load())
        {
            debug_log(LOG_INFO, "Watchpoint %d removed during processing, aborting",
                      watchpoint_index);
            return KERN_SUCCESS;
        }

        thread_states_[thread] = ThreadState{.single_step_mode = SingleStepMode::Watchpoint,
                                             .single_step_count = 0,
                                             .current_breakpoint_index = -1,
                                             .current_watchpoint_index = watchpoint_index,
                                             .is_stopped = false,  // Running during single-step
                                             .thread_state = thread_state,
                                             .debug_state = debug_state,
                                             .exception_state = exception_state};
    }

    // debug_log_develop(
    //     LOG_INFO,
    //     "handle_watchpoint_hit: Thread state updated successfully with watchpoint index %d",
    //     watchpoint_index);

    return KERN_SUCCESS;
}

// =============================================================================
// Watchpoint Single-Step Completion
// =============================================================================

kern_return_t Debugger::complete_watchpoint_single_step(mach_port_t thread,
                                                        arm_debug_state64_t& debug_state,
                                                        arm_thread_state64_t& thread_state,
                                                        arm_exception_state64_t& exception_state)
{
    // Get stored state for this thread
    int watchpoint_index = -1;
    arm_thread_state64_t original_thread_state = {};
    {
        std::lock_guard<std::mutex> lock(thread_states_mutex_);
        auto it = thread_states_.find(thread);
        if (it != thread_states_.end())
        {
            watchpoint_index = it->second.current_watchpoint_index;
            original_thread_state = it->second.thread_state;  // PC at watchpoint hit
        }
    }

    if (watchpoint_index < 0 || watchpoint_index >= MAX_WATCHPOINTS)
    {
        debug_log(LOG_ERROR, "Invalid watchpoint index in single step completion");
        return KERN_INVALID_ARGUMENT;
    }

    // Check if this watchpoint is being removed
    if (watchpoint_sync_[watchpoint_index].removing.load())
    {
        debug_log(LOG_INFO, "Watchpoint %d is being removed, skipping re-enable", watchpoint_index);
        // Just disable single-step and return
        debug_state.__mdscr_el1 &= ~1ULL;
        return thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&debug_state,
                                ARM_DEBUG_STATE64_COUNT);
    }

    // Re-enable the watchpoint
    {
        std::lock_guard<std::mutex> lock(watchpoint_data_mutex_);
        if (watchpoint_used[watchpoint_index])
        {
            debug_state.__wcr[watchpoint_index] |= (1ULL << 0);
        }
    }

    // Disable single-step mode
    debug_state.__mdscr_el1 &= ~1ULL;

    // Clear thread state
    {
        std::lock_guard<std::mutex> lock(thread_states_mutex_);
        thread_states_.erase(thread);
    }

    kern_return_t kr = thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&debug_state,
                                        ARM_DEBUG_STATE64_COUNT);
    if (kr != KERN_SUCCESS)
    {
        debug_log(LOG_ERROR, "Failed to set debug state: %s", mach_error_string(kr));
        return kr;
    }

    // debug_log_develop(LOG_INFO, "Watchpoint hit notification sent for address 0x%llx",
    //                   watchpoint_address);

    return KERN_SUCCESS;
}

```

`src/server/src/cpp/src/linux/Makefile`:

```
# Makefile for building libdbgsrv_native.so standalone
# Usage:
#   make                    # Build for native Linux (x86_64 or aarch64)
#   make ARCH=arm64         # Build for arm64
#   make ARCH=x86_64        # Build for x86_64
#   make TARGET=android     # Build for Android (requires NDK)
#   make clean              # Clean build artifacts

# Output
LIB_NAME = libdbgsrv_native.so
BUILD_DIR = build

# Detect architecture if not specified
ifndef ARCH
UNAME_M := $(shell uname -m)
ifeq ($(UNAME_M),x86_64)
ARCH = x86_64
else ifeq ($(UNAME_M),aarch64)
ARCH = arm64
else
ARCH = $(UNAME_M)
endif
endif

# Compiler settings
CXX ?= g++
CC ?= gcc

# Common flags
COMMON_CXXFLAGS = -std=c++17 -fPIC -Wall -Wextra
COMMON_CFLAGS = -fPIC -Wall -Wextra
COMMON_LDFLAGS = -shared -fPIC

# Platform-specific settings
ifeq ($(TARGET),android)
    # Android NDK build
    ifndef NDK_HOME
        $(error NDK_HOME is not set. Please set it to your Android NDK path)
    endif
    
    ifeq ($(ARCH),arm64)
        TOOLCHAIN = $(NDK_HOME)/toolchains/llvm/prebuilt/linux-x86_64
        CXX = $(TOOLCHAIN)/bin/aarch64-linux-android30-clang++
        CC = $(TOOLCHAIN)/bin/aarch64-linux-android30-clang
        ARCH_FLAGS = -march=armv8-a
    else ifeq ($(ARCH),x86_64)
        TOOLCHAIN = $(NDK_HOME)/toolchains/llvm/prebuilt/linux-x86_64
        CXX = $(TOOLCHAIN)/bin/x86_64-linux-android30-clang++
        CC = $(TOOLCHAIN)/bin/x86_64-linux-android30-clang
        ARCH_FLAGS = -march=x86-64
    else
        $(error Unsupported Android architecture: $(ARCH))
    endif
    
    PLATFORM_CXXFLAGS = -DTARGET_IS_ANDROID -DDYNAMIC_LIB_BUILD
    PLATFORM_LDFLAGS = -llog
else
    # Native Linux build
    ifeq ($(ARCH),arm64)
        ARCH_FLAGS = -march=armv8-a
    else ifeq ($(ARCH),x86_64)
        ARCH_FLAGS = -march=x86-64
    endif
    
    PLATFORM_CXXFLAGS = -DDYNAMIC_LIB_BUILD
    PLATFORM_LDFLAGS = -lpthread -ldl
endif

# Debug/Release
ifdef DEBUG
    OPT_FLAGS = -g -O0 -DDEBUG -DDEBUG_MEMORY_ACCESS -DVERBOSE_LOGGING
else
    OPT_FLAGS = -O2 -DNDEBUG
endif

# Final flags
CXXFLAGS = $(COMMON_CXXFLAGS) $(ARCH_FLAGS) $(PLATFORM_CXXFLAGS) $(OPT_FLAGS)
CFLAGS = $(COMMON_CFLAGS) $(ARCH_FLAGS) $(OPT_FLAGS)
LDFLAGS = $(COMMON_LDFLAGS) $(PLATFORM_LDFLAGS)

# Include paths
INCLUDES = -I. -I../common -I..

# Source files
CORE_SOURCES = \
    core/native_api.cpp \
    core/file_api.cpp \
    core/memory_io.cpp \
    core/callback_stubs.cpp \
    core/process_api.cpp

DEBUGGER_SOURCES = \
    debugger/debugger_core.cpp \
    debugger/debugger_breakpoint.cpp \
    debugger/debugger_watchpoint.cpp \
    debugger/debugger_exception.cpp \
    debugger/debugger_register.cpp \
    debugger/debugger_thread.cpp \
    debugger/debugger_spawn.cpp \
    debugger/debugger_memory.cpp \
    debugger/debugger_native_api.cpp

ELF_SOURCES = \
    elf/elf_parser.cpp

PTY_SOURCES = \
    pty/pty_manager.cpp

COMMON_SOURCES = \
    ../common/util.cpp \
    ../common/trace_file.cpp \
    ../common/arm64_decoder.cpp

ALL_SOURCES = $(CORE_SOURCES) $(DEBUGGER_SOURCES) $(ELF_SOURCES) $(PTY_SOURCES) $(COMMON_SOURCES)

# Object files
OBJECTS = $(patsubst %.cpp,$(BUILD_DIR)/%.o,$(ALL_SOURCES))

# Default target
all: $(BUILD_DIR)/$(LIB_NAME)

# Create build directories
$(BUILD_DIR):
	mkdir -p $(BUILD_DIR)/core
	mkdir -p $(BUILD_DIR)/debugger
	mkdir -p $(BUILD_DIR)/elf
	mkdir -p $(BUILD_DIR)/pty
	mkdir -p $(BUILD_DIR)/../common

# Compile C++ sources
$(BUILD_DIR)/%.o: %.cpp | $(BUILD_DIR)
	@mkdir -p $(dir $@)
	$(CXX) $(CXXFLAGS) $(INCLUDES) -c $< -o $@

# Link shared library
$(BUILD_DIR)/$(LIB_NAME): $(OBJECTS)
	$(CXX) $(LDFLAGS) -o $@ $^
	@echo ""
	@echo "Built: $(BUILD_DIR)/$(LIB_NAME)"
	@echo "Architecture: $(ARCH)"
	@echo "Target: $(if $(TARGET),$(TARGET),linux)"

# Clean
clean:
	rm -rf $(BUILD_DIR)

# Install (optional)
install: $(BUILD_DIR)/$(LIB_NAME)
	install -D -m 755 $(BUILD_DIR)/$(LIB_NAME) $(DESTDIR)/usr/local/lib/$(LIB_NAME)

# Print configuration
info:
	@echo "Configuration:"
	@echo "  ARCH:     $(ARCH)"
	@echo "  TARGET:   $(if $(TARGET),$(TARGET),linux)"
	@echo "  CXX:      $(CXX)"
	@echo "  CXXFLAGS: $(CXXFLAGS)"
	@echo "  LDFLAGS:  $(LDFLAGS)"
	@echo ""
	@echo "Sources:"
	@for src in $(ALL_SOURCES); do echo "  $$src"; done

.PHONY: all clean install info

```

`src/server/src/cpp/src/linux/core/callback_stubs.cpp`:

```cpp
// Callback stubs for dynamic library mode
// These functions allow users to replace callback implementations
// by setting function pointers after loading the library.
//
// In static linking mode, the host application provides native_log and
// send_exception_info implementations directly.
//
// In dynamic library mode (DYNAMIC_LIB_BUILD), this file provides:
// 1. Default fallback implementations
// 2. Setter functions for users to inject custom callbacks

#include <cstdio>

#include "../../common/dll_export.h"
#include "../../common/exception_info.h"
#include "native_api.h"

#ifdef DYNAMIC_LIB_BUILD

// Function pointer types
typedef void (*native_log_fn)(int level, const char* message);
typedef bool (*send_exception_info_fn)(const NativeExceptionInfo* info, pid_t pid);

// Global function pointers (can be set by user after library load)
static native_log_fn g_native_log = nullptr;
static send_exception_info_fn g_send_exception_info = nullptr;

// Set callback functions (called by user after library load)
extern "C" NATIVE_API void set_native_log_callback(native_log_fn fn)
{
    g_native_log = fn;
}

extern "C" NATIVE_API void set_send_exception_info_callback(send_exception_info_fn fn)
{
    g_send_exception_info = fn;
}

// Get current callback (for checking if set)
extern "C" NATIVE_API native_log_fn get_native_log_callback()
{
    return g_native_log;
}

extern "C" NATIVE_API send_exception_info_fn get_send_exception_info_callback()
{
    return g_send_exception_info;
}

// Implementation of native_log
// If callback is set, calls user's function; otherwise prints to stderr
extern "C" void native_log(int level, const char* message)
{
    if (g_native_log)
    {
        g_native_log(level, message);
    }
    else
    {
        // Fallback: print to stderr with level string
        const char* level_str = "UNKNOWN";
        switch (level)
        {
            case 1:
                level_str = "ERROR";
                break;
            case 2:
                level_str = "WARN";
                break;
            case 3:
                level_str = "INFO";
                break;
            case 4:
                level_str = "DEBUG";
                break;
            case 5:
                level_str = "TRACE";
                break;
        }
        fprintf(stderr, "[%s] %s\n", level_str, message);
    }
}

// Implementation of send_exception_info
// If callback is set, calls user's function; otherwise prints summary to stderr
// Returns: true = notify UI and break, false = silent continue
extern "C" bool send_exception_info(const NativeExceptionInfo* info, pid_t pid)
{
    fprintf(stderr, "[DEBUG] send_exception_info called: g_send_exception_info=%p\n",
            (void*)g_send_exception_info);
    if (g_send_exception_info)
    {
        fprintf(stderr, "[DEBUG] Calling Rust callback...\n");
        bool result = g_send_exception_info(info, pid);
        fprintf(stderr, "[DEBUG] Rust callback returned: %d\n", result ? 1 : 0);
        return result;
    }
    else
    {
        // Fallback: print basic info to stderr
#if defined(__aarch64__)
        fprintf(
            stderr, "[WARN] send_exception_info: callback not set (pc=0x%llx, pid=%d, type=%llu)\n",
            (unsigned long long)info->regs.arm64.pc, pid, (unsigned long long)info->exception_type);
#elif defined(__x86_64__)
        fprintf(stderr,
                "[WARN] send_exception_info: callback not set (rip=0x%llx, pid=%d, type=%llu)\n",
                (unsigned long long)info->regs.x86_64.rip, pid,
                (unsigned long long)info->exception_type);
#else
        fprintf(stderr, "[WARN] send_exception_info: callback not set (pid=%d, type=%llu)\n", pid,
                (unsigned long long)info->exception_type);
#endif
        return true;  // Default: notify UI and break
    }
}

#endif  // DYNAMIC_LIB_BUILD

```

`src/server/src/cpp/src/linux/core/file_api.cpp`:

```cpp
#include "file_api.h"

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#include <fstream>
#include <iostream>
#include <sstream>

// Helper function to escape JSON strings (file-local utility)
static std::string escape_json_string(const std::string& input)
{
    std::ostringstream escaped;
    for (char c : input)
    {
        switch (c)
        {
            case '"':
                escaped << "\\\"";
                break;
            case '\\':
                escaped << "\\\\";
                break;
            case '\b':
                escaped << "\\b";
                break;
            case '\f':
                escaped << "\\f";
                break;
            case '\n':
                escaped << "\\n";
                break;
            case '\r':
                escaped << "\\r";
                break;
            case '\t':
                escaped << "\\t";
                break;
            default:
                escaped << c;
                break;
        }
    }
    return escaped.str();
}

void explore_directory_recursive(const char* path, int depth, int maxDepth,
                                 std::ostringstream& result, const std::string& indent = "")
{
    if (depth > maxDepth) return;

    DIR* dir = opendir(path);
    if (!dir)
    {
        result << indent << "Error: Failed to open directory " << path
               << ". Error: " << strerror(errno) << "\n";
        return;
    }

    struct dirent* entry;

    while ((entry = readdir(dir)) != nullptr)
    {
        std::string itemName = entry->d_name;

        if (itemName == "." || itemName == "..") continue;

        std::string fullPath = std::string(path) + "/" + itemName;

        // Use stat to properly handle symlinks and DT_UNKNOWN
        struct stat fileStat;
        bool isDirectory = false;
        bool statSuccess = (stat(fullPath.c_str(), &fileStat) == 0);

        if (statSuccess)
        {
            isDirectory = S_ISDIR(fileStat.st_mode);
        }
        else if (entry->d_type == DT_DIR)
        {
            // Fallback to d_type if stat fails
            isDirectory = true;
        }

        if (isDirectory)
        {
            result << indent << "dir:" << itemName << "\n";
            explore_directory_recursive(fullPath.c_str(), depth + 1, maxDepth, result,
                                        indent + "  ");
        }
        else if (statSuccess)
        {
            result << indent << "file:" << itemName << "," << fileStat.st_size << ","
                   << fileStat.st_mtime << "\n";
        }
    }

    closedir(dir);
}

const char* explore_directory(const char* path, int maxDepth)
{
    std::ostringstream result;
    explore_directory_recursive(path, 0, maxDepth, result);
    return strdup(result.str().c_str());
}

const void* read_file(const char* path, size_t* size, char** error_message)
{
    std::ifstream file(path, std::ios::binary | std::ios::ate);
    if (!file.is_open())
    {
        std::ostringstream error;
        error << "Error: Could not open file " << path << ". Error: " << strerror(errno);
        *error_message = strdup(error.str().c_str());
        *size = 0;
        return nullptr;
    }

    std::streamsize fileSize = file.tellg();
    file.seekg(0, std::ios::beg);

    unsigned char* buffer = (unsigned char*)malloc(fileSize);
    if (!buffer)
    {
        std::ostringstream error;
        error << "Error: Memory allocation failed for file " << path;
        *error_message = strdup(error.str().c_str());
        *size = 0;
        return nullptr;
    }

    if (!file.read((char*)buffer, fileSize))
    {
        std::ostringstream error;
        error << "Error: Failed to read file " << path;
        *error_message = strdup(error.str().c_str());
        *size = 0;
        free(buffer);
        return nullptr;
    }

    *size = fileSize;
    return buffer;
}

const char* get_application_info_native(pid_t pid)
{
    char exe_path[64];
    snprintf(exe_path, sizeof(exe_path), "/proc/%d/exe", pid);

    char binary_path[PATH_MAX];
    ssize_t len = readlink(exe_path, binary_path, sizeof(binary_path) - 1);

    if (len == -1)
    {
        std::ostringstream error;
        error << "{\"error\":\"Failed to retrieve binary path for PID " << pid
              << ". Error: " << escape_json_string(std::string(strerror(errno))) << "\"}";
        return strdup(error.str().c_str());
    }

    binary_path[len] = '\0';

    std::ostringstream json;
    json << "{"
         << "\"BinaryPath\":\"" << escape_json_string(std::string(binary_path)) << "\"}";

    return strdup(json.str().c_str());
}

```

`src/server/src/cpp/src/linux/core/file_api.h`:

```h
#ifndef FILE_API_H
#define FILE_API_H

#include <sys/types.h>  // For pid_t

#ifdef __cplusplus
extern "C"
{
#endif

    const char* explore_directory(const char* path, int maxDepth);
    const void* read_file(const char* path, size_t* size, char** error_message);
    const char* get_application_info_native(pid_t pid);

#ifdef __cplusplus
}
#endif

#endif
```

`src/server/src/cpp/src/linux/core/memory_io.cpp`:

```cpp
/**
 * @file memory_io.cpp
 * @brief Memory read/write operations for process memory access
 */

#include "memory_io.h"

#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <unistd.h>

#include <algorithm>
#include <cstring>

#include "native_api.h"  // For debug_log, get_pid_native (same folder)

#ifdef TARGET_IS_ANDROID
#include <dlfcn.h>
typedef ssize_t (*process_vm_readv_func)(pid_t, const struct iovec*, unsigned long,
                                         const struct iovec*, unsigned long, unsigned long);
typedef ssize_t (*process_vm_writev_func)(pid_t, const struct iovec*, unsigned long,
                                          const struct iovec*, unsigned long, unsigned long);
static process_vm_readv_func g_process_vm_readv = nullptr;
static process_vm_writev_func g_process_vm_writev = nullptr;

static bool init_android_memory_funcs()
{
    if (g_process_vm_readv && g_process_vm_writev) return true;

    void* handle = dlopen("libc.so", RTLD_NOW);
    if (!handle) return false;

    g_process_vm_readv = (process_vm_readv_func)dlsym(handle, "process_vm_readv");
    g_process_vm_writev = (process_vm_writev_func)dlsym(handle, "process_vm_writev");
    dlclose(handle);

    return (g_process_vm_readv && g_process_vm_writev);
}
#endif

// External declarations for debugger integration
extern "C" bool is_debugger_attached_native();
extern "C" ssize_t read_memory_debugger_native(uint64_t address, size_t size,
                                               unsigned char* buffer);

ssize_t read_memory_native(int pid, uintptr_t address, size_t size, unsigned char* buffer)
{
    return read_memory_native_with_method(pid, address, size, buffer, 0);
}

ssize_t read_memory_proc_mem(int pid, uintptr_t address, size_t size, unsigned char* buffer)
{
    char mem_path[64];
    snprintf(mem_path, sizeof(mem_path), "/proc/%d/mem", pid);

    int fd = open(mem_path, O_RDONLY);
    if (fd < 0)
    {
        debug_log(LOG_ERROR, "Failed to open %s: %d (%s)\n", mem_path, errno, strerror(errno));
        return -errno;
    }

    // Seek to the target address
    if (lseek64(fd, static_cast<off64_t>(address), SEEK_SET) == -1)
    {
        debug_log(LOG_ERROR, "Failed to seek to 0x%lx in %s: %d (%s)\n", address, mem_path, errno,
                  strerror(errno));
        close(fd);
        return -errno;
    }

    // Read the memory
    ssize_t bytes_read = read(fd, buffer, size);
    close(fd);

    if (bytes_read < 0)
    {
        return -errno;
    }

    return bytes_read;
}

ssize_t read_memory_native_with_method(int pid, uintptr_t address, size_t size,
                                       unsigned char* buffer, int mode)
{
    switch (mode)
    {
        case 0:  // process_vm_readv (default, fastest)
            return read_memory_vm_readv(pid, address, size, buffer);

        case 1:  // /proc/pid/mem (no thread stop needed)
            return read_memory_proc_mem(pid, address, size, buffer);

        case 2:  // ptrace PEEKDATA (requires attach or debugger)
            return read_memory_ptrace(pid, address, size, buffer);

        default:
            return read_memory_vm_readv(pid, address, size, buffer);
    }
}

ssize_t read_memory_vm_readv(int pid, uintptr_t address, size_t size, unsigned char* buffer)
{
    struct iovec local_iov;
    struct iovec remote_iov;

    local_iov.iov_base = buffer;
    local_iov.iov_len = size;
    remote_iov.iov_base = reinterpret_cast<void*>(address);
    remote_iov.iov_len = size;

#ifdef TARGET_IS_ANDROID
    if (!init_android_memory_funcs()) return -ENOSYS;
    ssize_t nread = g_process_vm_readv(pid, &local_iov, 1, &remote_iov, 1, 0);
#else
    ssize_t nread = process_vm_readv(pid, &local_iov, 1, &remote_iov, 1, 0);
#endif

    if (nread < 0)
    {
        return -errno;
    }

    if (static_cast<size_t>(nread) < size)
    {
        debug_log(LOG_WARN, "Partial read from process %d. Requested %zu bytes, read %zd bytes\n",
                  pid, size, nread);
    }

    return nread;
}

ssize_t read_memory_ptrace(int pid, uintptr_t address, size_t size, unsigned char* buffer)
{
    debug_log(LOG_DEBUG, "Using ptrace to read memory from process %d at address 0x%lx, size %zu\n",
              pid, address, size);

    // Check if process is still alive
    if (kill(pid, 0) != 0)
    {
        debug_log(LOG_ERROR, "Process %d is not accessible or has exited: %d (%s)\n", pid, errno,
                  strerror(errno));
        return -ESRCH;
    }

    // Check if debugger is already attached (debug mode)
    if (is_debugger_attached_native())
    {
        debug_log(LOG_DEBUG, "Debugger attached, using debugger queue for memory read\n");
        return read_memory_debugger_native(static_cast<uint64_t>(address), size, buffer);
    }

    // Non-debug mode: attach, read, detach
    if (ptrace(PTRACE_ATTACH, pid, nullptr, nullptr) == -1)
    {
        if (errno != EPERM && errno != ESRCH)
        {
            debug_log(LOG_ERROR, "Failed to attach to process %d: %d (%s)\n", pid, errno,
                      strerror(errno));
            return -errno;
        }
        debug_log(LOG_WARN, "Attach returned %d (%s), continuing anyway\n", errno, strerror(errno));
    }

    // Wait for process to stop (with timeout)
    int status;
    struct timespec timeout = {1, 0};  // 1 second timeout
    sigset_t mask, orig_mask;
    sigemptyset(&mask);
    sigaddset(&mask, SIGCHLD);

    if (sigprocmask(SIG_BLOCK, &mask, &orig_mask) == -1)
    {
        debug_log(LOG_WARN, "Failed to block SIGCHLD: %d (%s)\n", errno, strerror(errno));
    }

    pid_t wait_result = waitpid(pid, &status, WNOHANG);
    if (wait_result == 0)
    {
#ifdef TARGET_IS_ANDROID
        // Android doesn't have sigtimedwait, use poll-based approach
        for (int i = 0; i < 100; i++)
        {
            usleep(10000);  // 10ms
            wait_result = waitpid(pid, &status, WNOHANG);
            if (wait_result != 0) break;
        }
        if (wait_result == 0)
        {
            debug_log(LOG_WARN, "Timeout waiting for process %d to stop\n", pid);
        }
#else
        if (sigtimedwait(&mask, nullptr, &timeout) == -1)
        {
            if (errno == EAGAIN)
            {
                debug_log(LOG_WARN, "Timeout waiting for process %d to stop\n", pid);
            }
            else
            {
                debug_log(LOG_WARN, "Error waiting for process %d: %d (%s)\n", pid, errno,
                          strerror(errno));
            }
        }
        wait_result = waitpid(pid, &status, WNOHANG);
#endif
    }

    sigprocmask(SIG_SETMASK, &orig_mask, nullptr);

    if (wait_result == -1)
    {
        debug_log(LOG_ERROR, "Failed to wait for process %d: %d (%s)\n", pid, errno,
                  strerror(errno));
        ptrace(PTRACE_DETACH, pid, nullptr, nullptr);
        return -errno;
    }

    size_t bytes_read = 0;
    size_t word_size = sizeof(long);
    int consecutive_failures = 0;
    const int max_consecutive_failures = 3;

    while (bytes_read < size && consecutive_failures < max_consecutive_failures)
    {
        uintptr_t aligned_addr = (address + bytes_read) & ~(word_size - 1);
        size_t offset = (address + bytes_read) - aligned_addr;

        errno = 0;
        long word = ptrace(PTRACE_PEEKDATA, pid, reinterpret_cast<void*>(aligned_addr), nullptr);

        if (errno != 0)
        {
            consecutive_failures++;

            if (errno == EIO || errno == EFAULT)
            {
                size_t skip_bytes = word_size - offset;
                if (bytes_read + skip_bytes >= size) break;
                bytes_read += skip_bytes;
                continue;
            }
            else if (errno == ESRCH)
            {
                debug_log(LOG_ERROR, "Process %d no longer exists\n", pid);
                break;
            }
            else
            {
                bytes_read += 1;
                continue;
            }
        }

        consecutive_failures = 0;

        size_t bytes_to_copy = std::min(size - bytes_read, word_size - offset);
        unsigned char* word_bytes = reinterpret_cast<unsigned char*>(&word);

        memcpy(buffer + bytes_read, word_bytes + offset, bytes_to_copy);
        bytes_read += bytes_to_copy;
    }

    if (ptrace(PTRACE_DETACH, pid, nullptr, nullptr) == -1)
    {
        debug_log(LOG_WARN, "Failed to detach from process %d: %d (%s)\n", pid, errno,
                  strerror(errno));
    }

    if (bytes_read < size)
    {
        debug_log(
            LOG_WARN,
            "Partial read from process %d using ptrace. Requested %zu bytes, read %zu bytes\n", pid,
            size, bytes_read);
    }

    if (bytes_read == 0)
    {
        return -EIO;
    }

    return bytes_read;
}

ssize_t write_memory_native(int pid, void* address, size_t size, unsigned char* buffer)
{
    if (pid == get_pid_native())
    {
        // Writing to own process
        uintptr_t start = reinterpret_cast<uintptr_t>(address);
        uintptr_t end = start + size;
        uintptr_t page_size = getpagesize();
        uintptr_t page_start = start & ~(page_size - 1);
        uintptr_t page_end = (end + page_size - 1) & ~(page_size - 1);
        size_t protected_size = page_end - page_start;

        int result = mprotect(reinterpret_cast<void*>(page_start), protected_size,
                              PROT_READ | PROT_WRITE | PROT_EXEC);
        if (result != 0)
        {
            debug_log(LOG_ERROR, "mprotect failed with error %d (%s)\n", errno, strerror(errno));
            return -1;
        }

        iovec local_iov = {buffer, size};
        iovec remote_iov = {address, size};

#ifdef TARGET_IS_ANDROID
        if (!init_android_memory_funcs()) return -1;
        ssize_t written = g_process_vm_writev(pid, &local_iov, 1, &remote_iov, 1, 0);
#else
        ssize_t written = process_vm_writev(pid, &local_iov, 1, &remote_iov, 1, 0);
#endif
        if (written == -1)
        {
            debug_log(LOG_ERROR, "process_vm_writev failed with error %d (%s)\n", errno,
                      strerror(errno));
            return -1;
        }

        debug_log(LOG_DEBUG, "Successfully wrote %zd bytes to own process memory\n", written);
        return written;
    }
    else
    {
        // Writing to another process
        if (ptrace(PTRACE_ATTACH, pid, NULL, NULL) == -1)
        {
            debug_log(LOG_ERROR, "Failed to attach to process %d. Error: %d (%s)\n", pid, errno,
                      strerror(errno));
            return -1;
        }
        waitpid(pid, NULL, 0);

        ssize_t total_written = 0;
        for (size_t i = 0; i < size; i += sizeof(long))
        {
            if (size - i < sizeof(long))
            {
                errno = 0;
                long orig =
                    ptrace(PTRACE_PEEKDATA, pid, reinterpret_cast<char*>(address) + i, NULL);
                if (errno != 0)
                {
                    debug_log(LOG_ERROR, "ptrace PEEKDATA failed at offset %zu. Error: %d (%s)\n",
                              i, errno, strerror(errno));
                    ptrace(PTRACE_DETACH, pid, NULL, NULL);
                    return -1;
                }

                std::memcpy(&orig, reinterpret_cast<char*>(buffer) + i, size - i);

                if (ptrace(PTRACE_POKEDATA, pid, reinterpret_cast<char*>(address) + i, orig) == -1)
                {
                    debug_log(LOG_ERROR, "ptrace POKEDATA failed at offset %zu. Error: %d (%s)\n",
                              i, errno, strerror(errno));
                    ptrace(PTRACE_DETACH, pid, NULL, NULL);
                    return -1;
                }
                total_written += size - i;
            }
            else
            {
                long data;
                std::memcpy(&data, reinterpret_cast<char*>(buffer) + i, sizeof(long));
                if (ptrace(PTRACE_POKEDATA, pid, reinterpret_cast<char*>(address) + i, data) == -1)
                {
                    debug_log(LOG_ERROR, "ptrace POKEDATA failed at offset %zu. Error: %d (%s)\n",
                              i, errno, strerror(errno));
                    ptrace(PTRACE_DETACH, pid, NULL, NULL);
                    return -1;
                }
                total_written += sizeof(long);
            }
        }

        if (ptrace(PTRACE_DETACH, pid, NULL, NULL) == -1)
        {
            debug_log(LOG_WARN, "Failed to detach from process %d. Error: %d (%s)\n", pid, errno,
                      strerror(errno));
        }

        return total_written;
    }
}

```

`src/server/src/cpp/src/linux/core/memory_io.h`:

```h
/**
 * @file memory_io.h
 * @brief Memory read/write operations for process memory access
 *
 * Provides multiple methods for reading/writing process memory:
 * - process_vm_readv/writev (fastest, requires same UID or CAP_SYS_PTRACE)
 * - /proc/pid/mem (no thread stop needed with proper permissions)
 * - ptrace PEEKDATA/POKEDATA (requires attach, most compatible)
 */

#ifndef MEMORY_IO_H
#define MEMORY_IO_H

#include <sys/types.h>

#include <cstddef>
#include <cstdint>

// External C API functions (called from Rust)
#ifdef __cplusplus
extern "C"
{
#endif

    /**
     * Read memory from target process using default method (process_vm_readv)
     * @param pid Target process ID
     * @param address Memory address to read from
     * @param size Number of bytes to read
     * @param buffer Output buffer to store read data
     * @return Number of bytes read, or negative errno on error
     */
    ssize_t read_memory_native(int pid, uintptr_t address, size_t size, unsigned char* buffer);

    /**
     * Read memory with specific method selection
     * @param pid Target process ID
     * @param address Memory address to read from
     * @param size Number of bytes to read
     * @param buffer Output buffer to store read data
     * @param mode Read method: 0=process_vm_readv, 1=/proc/pid/mem, 2=ptrace
     * @return Number of bytes read, or negative errno on error
     */
    ssize_t read_memory_native_with_method(int pid, uintptr_t address, size_t size,
                                           unsigned char* buffer, int mode);

    /**
     * Write memory to target process
     * Uses process_vm_writev for own process, ptrace for others
     * @param pid Target process ID
     * @param address Memory address to write to
     * @param size Number of bytes to write
     * @param buffer Data to write
     * @return Number of bytes written, or -1 on error
     */
    ssize_t write_memory_native(int pid, void* address, size_t size, unsigned char* buffer);

#ifdef __cplusplus
}
#endif

// Internal C++ helper functions (not exposed to Rust)
#ifdef __cplusplus

/**
 * Read memory using process_vm_readv (fastest method)
 */
ssize_t read_memory_vm_readv(int pid, uintptr_t address, size_t size, unsigned char* buffer);

/**
 * Read memory using /proc/pid/mem (no thread stop required)
 */
ssize_t read_memory_proc_mem(int pid, uintptr_t address, size_t size, unsigned char* buffer);

/**
 * Read memory using ptrace PEEKDATA (requires attach or debugger)
 */
ssize_t read_memory_ptrace(int pid, uintptr_t address, size_t size, unsigned char* buffer);

#endif  // __cplusplus

#endif  // MEMORY_IO_H

```

`src/server/src/cpp/src/linux/core/native_api.cpp`:

```cpp
/**
 * @file native_api.cpp
 * @brief Core native API for Linux/Android debugger
 *
 * This file contains:
 * - Logging utilities
 * - Process/thread enumeration
 * - Memory region enumeration
 * - Process control (suspend/resume)
 * - Process spawning
 * - Initialization
 *
 * Memory I/O operations are in memory_io.cpp
 * ELF parsing is in elf_parser.cpp
 * PTY management is in pty_manager.cpp
 */

#include "native_api.h"

#include <dirent.h>
#include <dlfcn.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#include <fstream>
#include <sstream>
#include <string>
#include <vector>

#include "../debugger/debugger.h"
#include "../elf/elf_parser.h"
#include "../pty/pty_manager.h"
#include "memory_io.h"

#ifdef TARGET_IS_ANDROID
#include <android/log.h>
#endif

// Helper macro to call native_log conditionally for dynamic library builds
// In dynamic mode, native_log() in callback_stubs.cpp handles the callback check
#define NATIVE_LOG(level, msg) native_log(level, msg)

// ============================================================================
// Logging
// ============================================================================

int debug_log(LogLevel level, const char* format, ...)
{
    va_list args;
    va_start(args, format);

    char tagged_format[1024];
    char buffer[1024];
    snprintf(tagged_format, sizeof(tagged_format), "[NATIVE] %s", format);
    vsnprintf(buffer, sizeof(buffer), tagged_format, args);

    NATIVE_LOG(level, buffer);

#ifdef TARGET_IS_ANDROID
    __android_log_vprint(ANDROID_LOG_DEBUG, "DYNADBG", tagged_format, args);
#endif

    va_end(args);
    return 0;
}

// ============================================================================
// Process utilities
// ============================================================================

pid_t get_pid_native()
{
    return getpid();
}

// ============================================================================
// Memory region enumeration
// ============================================================================

void enumerate_regions_to_buffer(pid_t pid, char* buffer, size_t buffer_size,
                                 bool include_filenames)
{
    char maps_file_path[64];
    snprintf(maps_file_path, sizeof(maps_file_path), "/proc/%d/maps", pid);

    int fd = open(maps_file_path, O_RDONLY);
    if (fd < 0)
    {
        debug_log(LOG_ERROR, "Failed to open file: %s, error: %s\n", maps_file_path,
                  strerror(errno));
        snprintf(buffer, buffer_size, "Failed to open file: %s", maps_file_path);
        return;
    }

    size_t total_bytes_read = 0;
    ssize_t bytes_read;

    while (total_bytes_read < buffer_size - 1)
    {
        bytes_read = read(fd, buffer + total_bytes_read, buffer_size - 1 - total_bytes_read);

        if (bytes_read < 0)
        {
            if (errno == EINTR) continue;
            debug_log(LOG_ERROR, "Failed to read file: %s, error: %s\n", maps_file_path,
                      strerror(errno));
            snprintf(buffer, buffer_size, "Failed to read file: %s", maps_file_path);
            close(fd);
            return;
        }

        if (bytes_read == 0) break;

        total_bytes_read += bytes_read;
    }

    close(fd);

    if (total_bytes_read >= buffer_size - 1)
    {
        debug_log(
            LOG_WARN,
            "Buffer size %zu may not be enough to store all regions for pid %d (read %zu bytes)\n",
            buffer_size, pid, total_bytes_read);
    }

    buffer[total_bytes_read] = '\0';
}

// ============================================================================
// Process enumeration
// ============================================================================

ProcessInfo* enumerate_processes(size_t* count)
{
    DIR* proc_dir = opendir("/proc");
    if (!proc_dir)
    {
        debug_log(LOG_ERROR, "Failed to open /proc directory\n");
        return nullptr;
    }

    ProcessInfo* processes = nullptr;
    *count = 0;

    struct dirent* entry;
    while ((entry = readdir(proc_dir)) != nullptr)
    {
        int pid = atoi(entry->d_name);
        if (pid > 0)
        {
            std::string processname;

            // Try /proc/%d/cmdline first
            char cmdline_path[256];
            snprintf(cmdline_path, sizeof(cmdline_path), "/proc/%d/cmdline", pid);

            std::ifstream cmdline_file(cmdline_path, std::ios::binary);
            if (cmdline_file.is_open())
            {
                std::string cmdline;
                std::getline(cmdline_file, cmdline, '\0');
                cmdline_file.close();

                if (!cmdline.empty())
                {
                    size_t last_slash = cmdline.find_last_of('/');
                    if (last_slash != std::string::npos)
                    {
                        processname = cmdline.substr(last_slash + 1);
                    }
                    else
                    {
                        processname = cmdline;
                    }
                }
            }

            // Fallback to /proc/%d/comm
            if (processname.empty())
            {
                char comm_path[256];
                snprintf(comm_path, sizeof(comm_path), "/proc/%d/comm", pid);

                std::ifstream comm_file(comm_path);
                if (comm_file.is_open())
                {
                    std::getline(comm_file, processname);
                    comm_file.close();
                }
            }

            if (!processname.empty())
            {
                ProcessInfo process;
                process.pid = pid;

                size_t len = processname.length();
                process.processname = static_cast<char*>(malloc(len + 1));
                if (!process.processname)
                {
                    debug_log(LOG_ERROR, "Failed to allocate memory for process name (pid: %d)\n",
                              pid);
                    continue;
                }
                memcpy(process.processname, processname.c_str(), len);
                process.processname[len] = '\0';

                ProcessInfo* new_processes = static_cast<ProcessInfo*>(
                    realloc(processes, (*count + 1) * sizeof(ProcessInfo)));
                if (!new_processes)
                {
                    debug_log(LOG_ERROR, "Failed to reallocate memory for processes array\n");
                    free(process.processname);
                    break;
                }
                processes = new_processes;
                processes[*count] = process;
                (*count)++;
            }
            else
            {
                debug_log(LOG_WARN, "Failed to get process name for pid %d\n", pid);
            }
        }
    }

    closedir(proc_dir);
    return processes;
}

// ============================================================================
// Process control
// ============================================================================

bool suspend_process(pid_t pid)
{
    if (g_debugger != nullptr)
    {
        g_debugger->set_user_suspend_pending(true);
    }

    if (kill(pid, SIGSTOP) == -1)
    {
        debug_log(LOG_ERROR, "Failed to suspend process %d. Error: %d (%s)\n", pid, errno,
                  strerror(errno));
        if (g_debugger != nullptr)
        {
            g_debugger->set_user_suspend_pending(false);
        }
        return false;
    }
    return true;
}

bool resume_process(pid_t pid)
{
    if (g_debugger != nullptr)
    {
        g_debugger->set_user_suspend_pending(false);

        int result = g_debugger->resume_all_user_stopped_threads();
        if (result < 0)
        {
            debug_log(LOG_ERROR, "Failed to resume user-stopped threads\n");
            return false;
        }
        debug_log(LOG_INFO, "Resumed %d user-stopped threads\n", result);
        return true;
    }

    if (kill(pid, SIGCONT) == -1)
    {
        debug_log(LOG_ERROR, "Failed to resume process %d. Error: %d (%s)\n", pid, errno,
                  strerror(errno));
        return false;
    }
    return true;
}

// ============================================================================
// Module utilities
// ============================================================================

std::string get_module_path(int pid, uintptr_t module_base)
{
    char maps_path[256];
    snprintf(maps_path, sizeof(maps_path), "/proc/%d/maps", pid);

    std::ifstream maps_file(maps_path);
    if (!maps_file.is_open())
    {
        debug_log(LOG_ERROR, "Failed to open maps file for pid %d", pid);
        return "";
    }

    std::string line;
    while (std::getline(maps_file, line))
    {
        std::istringstream iss(line);
        std::string addr_range, perms, offset, dev, inode, pathname;

        if (!(iss >> addr_range >> perms >> offset >> dev >> inode))
        {
            continue;
        }

        size_t dash_pos = addr_range.find('-');
        if (dash_pos == std::string::npos) continue;

        uintptr_t start_addr = std::stoull(addr_range.substr(0, dash_pos), nullptr, 16);

        if (start_addr == module_base)
        {
            std::getline(iss, pathname);
            pathname.erase(0, pathname.find_first_not_of(" \t"));
            if (!pathname.empty() && pathname[0] == '/')
            {
                return pathname;
            }
        }
    }

    return "";
}

// ============================================================================
// Thread enumeration
// ============================================================================

enum ThreadState
{
    THREAD_STATE_RUNNING = 0,
    THREAD_STATE_SLEEPING = 1,
    THREAD_STATE_DISK_SLEEP = 2,
    THREAD_STATE_STOPPED = 3,
    THREAD_STATE_ZOMBIE = 4,
    THREAD_STATE_DEAD = 5,
    THREAD_STATE_UNKNOWN = 6
};

static int parse_thread_state(char state_char)
{
    switch (state_char)
    {
        case 'R':
            return THREAD_STATE_RUNNING;
        case 'S':
            return THREAD_STATE_SLEEPING;
        case 'D':
            return THREAD_STATE_DISK_SLEEP;
        case 'T':
        case 't':
            return THREAD_STATE_STOPPED;
        case 'Z':
            return THREAD_STATE_ZOMBIE;
        case 'X':
        case 'x':
            return THREAD_STATE_DEAD;
        default:
            return THREAD_STATE_UNKNOWN;
    }
}

ThreadInfo* enumerate_threads(pid_t pid, size_t* count)
{
    *count = 0;

    char task_path[64];
    snprintf(task_path, sizeof(task_path), "/proc/%d/task", pid);

    DIR* task_dir = opendir(task_path);
    if (!task_dir)
    {
        debug_log(LOG_ERROR, "Failed to open task directory: %s, error: %s", task_path,
                  strerror(errno));
        return nullptr;
    }

    std::vector<ThreadInfo> threads;
    struct dirent* entry;

    while ((entry = readdir(task_dir)) != nullptr)
    {
        int tid = atoi(entry->d_name);
        if (tid <= 0) continue;

        ThreadInfo info;
        memset(&info, 0, sizeof(ThreadInfo));
        info.thread_id = tid;
        info.name = nullptr;
        info.pc = 0;
        info.sp = 0;
        info.fp = 0;
        info.state = THREAD_STATE_UNKNOWN;
        info.suspend_count = 0;

        // Read thread name
        char comm_path[128];
        snprintf(comm_path, sizeof(comm_path), "/proc/%d/task/%d/comm", pid, tid);
        std::ifstream comm_file(comm_path);
        if (comm_file.is_open())
        {
            std::string name;
            std::getline(comm_file, name);
            if (!name.empty())
            {
                info.name = strdup(name.c_str());
            }
            comm_file.close();
        }

        if (!info.name)
        {
            char name_buf[64];
            snprintf(name_buf, sizeof(name_buf), "Thread %d", tid);
            info.name = strdup(name_buf);
        }

        // Read thread state
        char stat_path[128];
        snprintf(stat_path, sizeof(stat_path), "/proc/%d/task/%d/stat", pid, tid);
        std::ifstream stat_file(stat_path);
        if (stat_file.is_open())
        {
            std::string stat_line;
            std::getline(stat_file, stat_line);
            stat_file.close();

            size_t comm_end = stat_line.rfind(')');
            if (comm_end != std::string::npos && comm_end + 2 < stat_line.size())
            {
                char state_char = stat_line[comm_end + 2];
                info.state = parse_thread_state(state_char);

                if (state_char == 'T' || state_char == 't')
                {
                    info.suspend_count = 1;
                }
            }
        }

        threads.push_back(info);
    }

    closedir(task_dir);

    if (threads.empty())
    {
        debug_log(LOG_WARN, "No threads found for pid %d", pid);
        return nullptr;
    }

    ThreadInfo* result = static_cast<ThreadInfo*>(malloc(threads.size() * sizeof(ThreadInfo)));
    if (!result)
    {
        debug_log(LOG_ERROR, "Failed to allocate memory for thread info array");
        for (auto& t : threads)
        {
            if (t.name) free(t.name);
        }
        return nullptr;
    }

    for (size_t i = 0; i < threads.size(); i++)
    {
        result[i] = threads[i];
    }

    *count = threads.size();
    debug_log(LOG_INFO, "Successfully enumerated %zu threads for pid %d", *count, pid);

    return result;
}

void free_thread_info(ThreadInfo* threads, size_t count)
{
    if (threads)
    {
        for (size_t i = 0; i < count; i++)
        {
            if (threads[i].name)
            {
                free(threads[i].name);
            }
        }
        free(threads);
    }
}

// ============================================================================
// Memory region enumeration (structured)
// ============================================================================

static uint32_t parse_protection(const char* perms)
{
    uint32_t prot = 0;
    if (perms[0] == 'r') prot |= 1;  // PROT_READ
    if (perms[1] == 'w') prot |= 2;  // PROT_WRITE
    if (perms[2] == 'x') prot |= 4;  // PROT_EXEC
    return prot;
}

RegionInfo* enumerate_regions(pid_t pid, size_t* count)
{
    *count = 0;

    char maps_path[64];
    snprintf(maps_path, sizeof(maps_path), "/proc/%d/maps", pid);

    std::ifstream maps_file(maps_path);
    if (!maps_file.is_open())
    {
        debug_log(LOG_ERROR, "Failed to open maps file: %s", maps_path);
        return nullptr;
    }

    std::vector<RegionInfo> regions;
    std::string line;

    while (std::getline(maps_file, line))
    {
        std::istringstream iss(line);
        std::string addr_range, perms, offset, dev, inode, pathname;

        if (!(iss >> addr_range >> perms >> offset >> dev >> inode))
        {
            continue;
        }

        // Parse pathname (may contain spaces)
        std::getline(iss, pathname);
        // Trim leading whitespace
        size_t start = pathname.find_first_not_of(" \t");
        if (start != std::string::npos)
        {
            pathname = pathname.substr(start);
        }
        else
        {
            pathname.clear();
        }

        // Parse address range
        size_t dash_pos = addr_range.find('-');
        if (dash_pos == std::string::npos) continue;

        RegionInfo region;
        region.start = std::stoull(addr_range.substr(0, dash_pos), nullptr, 16);
        region.end = std::stoull(addr_range.substr(dash_pos + 1), nullptr, 16);
        region.protection = parse_protection(perms.c_str());

        if (!pathname.empty())
        {
            region.pathname = strdup(pathname.c_str());
        }
        else
        {
            region.pathname = nullptr;
        }

        regions.push_back(region);
    }

    if (regions.empty())
    {
        return nullptr;
    }

    RegionInfo* result = static_cast<RegionInfo*>(malloc(regions.size() * sizeof(RegionInfo)));
    if (!result)
    {
        debug_log(LOG_ERROR, "Failed to allocate memory for region info array");
        for (auto& r : regions)
        {
            if (r.pathname) free(r.pathname);
        }
        return nullptr;
    }

    for (size_t i = 0; i < regions.size(); i++)
    {
        result[i] = regions[i];
    }

    *count = regions.size();
    return result;
}

void free_region_info(RegionInfo* regions, size_t count)
{
    if (regions)
    {
        for (size_t i = 0; i < count; i++)
        {
            if (regions[i].pathname)
            {
                free(regions[i].pathname);
            }
        }
        free(regions);
    }
}

// ============================================================================
// Module enumeration (moved from elf_parser.cpp)
// ============================================================================

// Structure to hold parsed maps entry for module enumeration
struct MapsEntryForModule
{
    uintptr_t start;
    uintptr_t end;
    char perms[5];
    unsigned long offset;
    char module_path[PATH_MAX];
};

ModuleInfo* enumerate_modules(pid_t pid, size_t* count)
{
    std::vector<ModuleInfo> modules;
    std::vector<MapsEntryForModule> maps_entries;
    std::ostringstream maps_path;
    maps_path << "/proc/" << pid << "/maps";

    std::ifstream maps_file(maps_path.str());
    if (!maps_file.is_open())
    {
        *count = 0;
        return nullptr;
    }

    // First pass: read all maps entries
    std::string line;
    while (std::getline(maps_file, line))
    {
        std::istringstream iss(line);
        MapsEntryForModule entry;
        char dev[6];
        unsigned long long inode;

        iss >> std::hex >> entry.start;
        iss.ignore(1, '-');
        iss >> std::hex >> entry.end;
        iss >> entry.perms;
        iss >> std::hex >> entry.offset;
        iss >> dev >> std::dec >> inode;
        iss >> entry.module_path;

        if (strlen(entry.module_path) > 0)
        {
            maps_entries.push_back(entry);
        }
    }
    maps_file.close();

    // Second pass: find modules (requires ELF validation)
    for (size_t entry_idx = 0; entry_idx < maps_entries.size(); entry_idx++)
    {
        const auto& entry = maps_entries[entry_idx];

        if (entry.perms[0] != 'r') continue;

        // Use ELF parser helpers
        if (!is_elf(entry.module_path)) continue;
        if (!compare_elf_headers(pid, entry.start, entry.module_path)) continue;

        uintptr_t text_offset = get_text_section_offset(entry.module_path);
        if (text_offset == 0)
        {
            debug_log(LOG_WARN, "No .text section found in file: %s\n", entry.module_path);
            continue;
        }

        uintptr_t text_mem_address = entry.start + text_offset;

        bool text_executable = false;
        for (size_t check_idx = entry_idx; check_idx < maps_entries.size(); check_idx++)
        {
            const auto& check_entry = maps_entries[check_idx];

            if (check_entry.start > text_mem_address) break;

            if (text_mem_address >= check_entry.start && text_mem_address < check_entry.end)
            {
                if (check_entry.perms[2] == 'x')
                {
                    text_executable = true;
                    break;
                }
            }
        }

        if (!text_executable) continue;

        uintptr_t module_end = entry.end;
        for (size_t scan_idx = entry_idx + 1; scan_idx < maps_entries.size(); scan_idx++)
        {
            const auto& scan_entry = maps_entries[scan_idx];
            if (strcmp(scan_entry.module_path, entry.module_path) == 0)
            {
                const uintptr_t MAX_GAP = 0x100000;  // 1MB
                if (scan_entry.start > module_end + MAX_GAP)
                {
                    break;
                }
                module_end = scan_entry.end;
            }
            else
            {
                break;
            }
        }

        ModuleInfo info;
        info.base = entry.start;
        info.size = module_end - entry.start;
        info.is_64bit = is_elf64(entry.module_path);

        size_t nameLength = strlen(entry.module_path) + 1;
        info.modulename = new char[nameLength];
        strcpy(info.modulename, entry.module_path);

        modules.push_back(info);
    }

    *count = modules.size();
    if (*count == 0)
    {
        return nullptr;
    }

    ModuleInfo* result = new ModuleInfo[*count];
    std::copy(modules.begin(), modules.end(), result);

    return result;
}

// ============================================================================
// Process spawning
// ============================================================================

int spawn_process_native(const char* executable_path, const char** args, int argc, pid_t* out_pid)
{
    debug_log(LOG_INFO, "Spawning process: %s with %d args", executable_path, argc);

    if (g_debugger != nullptr)
    {
        debug_log(LOG_INFO, "Destroying existing debugger before spawn");
        delete g_debugger;
        g_debugger = nullptr;
    }

    g_debugger = new Debugger();
    if (!g_debugger->initialize())
    {
        debug_log(LOG_ERROR, "Failed to initialize debugger");
        delete g_debugger;
        g_debugger = nullptr;
        return -1;
    }

    g_debugger->run();

    std::vector<std::string> spawn_args;
    for (int i = 0; i < argc; i++)
    {
        spawn_args.push_back(args[i]);
    }

    pid_t pid = 0;
    int result = g_debugger->spawn_process(executable_path, spawn_args, &pid);

    if (result == 0 && out_pid != nullptr)
    {
        *out_pid = pid;
        debug_log(LOG_INFO, "Spawn successful: pid=%d", pid);
    }
    else if (result != 0)
    {
        debug_log(LOG_ERROR, "Spawn failed");
        delete g_debugger;
        g_debugger = nullptr;
    }

    return result;
}

// ============================================================================
// Initialization
// ============================================================================

int native_init(int mode)
{
#ifdef TARGET_IS_ANDROID
    void* handle = dlopen("libc.so", RTLD_NOW);
    if (!handle)
    {
        debug_log(LOG_ERROR, "Failed to open libc.so. Error: %s\n", dlerror());
        return -1;
    }

    // Note: process_vm_readv/writev are now initialized in memory_io.cpp
    dlclose(handle);
#endif
    return 1;
}

// ============================================================================
// Trace file stubs (Not implemented for Linux/Android)
// ============================================================================

extern "C" void enable_trace_file_output_native(const char* filepath)
{
    (void)filepath;
    // Not implemented for this platform
}

extern "C" void disable_trace_file_output_native()
{
    // Not implemented for this platform
}

extern "C" bool is_trace_file_output_enabled_native()
{
    // Not implemented for this platform
    return false;
}

extern "C" const char* get_trace_file_path_native()
{
    // Not implemented for this platform
    return "";
}

extern "C" uint32_t get_trace_file_entry_count_native()
{
    debug_log(LOG_WARN, "get_trace_file_entry_count_native: Not implemented for this platform");
    return 0;
}

extern "C" bool is_trace_ended_by_end_address_native()
{
    debug_log(LOG_WARN, "is_trace_ended_by_end_address_native: Not implemented for this platform");
    return false;
}

extern "C" void enable_full_memory_cache_native(const char* dump_filepath, const char* log_filepath)
{
    (void)dump_filepath;
    (void)log_filepath;
    debug_log(LOG_WARN, "enable_full_memory_cache_native: Not implemented for this platform");
}

extern "C" void disable_full_memory_cache_native()
{
    debug_log(LOG_WARN, "disable_full_memory_cache_native: Not implemented for this platform");
}

```

`src/server/src/cpp/src/linux/core/native_api.h`:

```h
/**
 * @file native_api.h
 * @brief Core native API definitions for Linux/Android debugger
 *
 * This header provides the main API interface for:
 * - Logging utilities
 * - Process/thread enumeration
 * - Memory operations (via memory_io.h)
 * - ELF parsing (via elf_parser.h)
 * - PTY management (via pty_manager.h)
 */

#ifndef NATIVEAPI_H
#define NATIVEAPI_H

#include <sys/types.h>
#include <unistd.h>

#include <cstdarg>
#include <cstddef>
#include <cstdint>

// ============================================================================
// Log levels
// ============================================================================

enum LogLevel
{
    LOG_ERROR = 1,
    LOG_WARN = 2,
    LOG_INFO = 3,
    LOG_DEBUG = 4,
    LOG_TRACE = 5
};

// ============================================================================
// Exception types
// ============================================================================

enum ExceptionType
{
    EXCEPTION_UNKNOWN = 0,
    EXCEPTION_BREAKPOINT = 1,
    EXCEPTION_WATCHPOINT = 2,
    EXCEPTION_SINGLESTEP = 3,
    EXCEPTION_SIGNAL = 4,
    EXCEPTION_SIGSEGV = 5,
    EXCEPTION_SIGBUS = 6,
    EXCEPTION_SIGFPE = 7,
    EXCEPTION_SIGILL = 8,
    EXCEPTION_SIGABRT = 9,
    EXCEPTION_SIGTRAP = 10,
};

// ============================================================================
// Data structures
// ============================================================================

typedef struct
{
    int pid;
    char* processname;
} ProcessInfo;

typedef struct
{
    uintptr_t base;
    size_t size;
    bool is_64bit;
    char* modulename;
} ModuleInfo;

typedef struct
{
    uintptr_t address;
    char* name;
    size_t size;
    char* type;
    char* scope;
    uintptr_t module_base;
    char* file_name;
    int line_number;
} SymbolInfo;

typedef struct
{
    uint64_t thread_id;
    char* name;
    uint64_t pc;
    uint64_t sp;
    uint64_t fp;
    int state;
    int suspend_count;
} ThreadInfo;

/**
 * Memory region information structure
 * Used for structured region enumeration
 */
typedef struct
{
    uintptr_t start;
    uintptr_t end;
    uint32_t protection;  // PROT_READ=1, PROT_WRITE=2, PROT_EXEC=4
    char* pathname;
} RegionInfo;

#include <string>

#include "../../common/exception_info.h"

// ============================================================================
// Logging API
// ============================================================================

extern "C" void native_log(int level, const char* message);
extern "C" bool send_exception_info(const NativeExceptionInfo* info, pid_t pid);

int debug_log(LogLevel level, const char* format, ...);

// ============================================================================
// Process enumeration
// ============================================================================

extern "C" pid_t get_pid_native();
extern "C" ProcessInfo* enumerate_processes(size_t* count);
extern "C" bool suspend_process(pid_t pid);
extern "C" bool resume_process(pid_t pid);

// ============================================================================
// Module utilities
// ============================================================================

/**
 * Get module path from process maps
 * @param pid Process ID
 * @param module_base Base address of the module
 * @return Module file path, or empty string if not found
 */
std::string get_module_path(int pid, uintptr_t module_base);

// ============================================================================
// Memory region enumeration
// ============================================================================

// Preferred API: Returns structured array
extern "C" RegionInfo* enumerate_regions(pid_t pid, size_t* count);
extern "C" void free_region_info(RegionInfo* regions, size_t count);

// Legacy API: Returns raw /proc/pid/maps content to buffer (for backward compatibility)
extern "C" void enumerate_regions_to_buffer(pid_t pid, char* buffer, size_t buffer_size,
                                            bool include_filenames);

// ============================================================================
// Thread enumeration
// ============================================================================

extern "C" ThreadInfo* enumerate_threads(pid_t pid, size_t* count);
extern "C" void free_thread_info(ThreadInfo* threads, size_t count);

// ============================================================================
// Initialization
// ============================================================================

extern "C" int native_init(int mode);

// ============================================================================
// Process spawning
// ============================================================================

extern "C" int spawn_process_native(const char* executable_path, const char** args, int argc,
                                    pid_t* out_pid);

// ============================================================================
// Memory I/O (implemented in memory_io.cpp)
// ============================================================================

extern "C" ssize_t read_memory_native(int pid, uintptr_t address, size_t size,
                                      unsigned char* buffer);
extern "C" ssize_t read_memory_native_with_method(int pid, uintptr_t address, size_t size,
                                                  unsigned char* buffer, int mode);
ssize_t read_memory_vm_readv(int pid, uintptr_t address, size_t size, unsigned char* buffer);
ssize_t read_memory_ptrace(int pid, uintptr_t address, size_t size, unsigned char* buffer);
ssize_t read_memory_proc_mem(int pid, uintptr_t address, size_t size, unsigned char* buffer);
extern "C" ssize_t write_memory_native(int pid, void* address, size_t size, unsigned char* buffer);

// ============================================================================
// Module enumeration (implemented in native_api.cpp, uses elf_parser.h helpers)
// ============================================================================

extern "C" ModuleInfo* enumerate_modules(pid_t pid, size_t* count);
extern "C" SymbolInfo* enum_symbols_native(int pid, uintptr_t module_base, size_t* count);

// ============================================================================
// PTY operations (implemented in pty_manager.cpp)
// ============================================================================

extern "C" int spawn_process_with_pty(const char* executable_path, const char** args, int argc,
                                      pid_t* out_pid, int* out_pty_fd);
extern "C" ssize_t read_pty(int pty_fd, char* buffer, size_t buffer_size);
extern "C" ssize_t write_pty(int pty_fd, const char* data, size_t data_len);
extern "C" void close_pty(int pty_fd);
extern "C" int get_pty_size(int pty_fd, int* rows, int* cols);
extern "C" int set_pty_size(int pty_fd, int rows, int cols);

#endif  // NATIVEAPI_H

```

`src/server/src/cpp/src/linux/core/process_api.cpp`:

```cpp
/**
 * @file process_api.cpp
 * @brief Process spawning and management API for Linux/Android
 *
 * This file provides basic process lifecycle management functions.
 * For debugger-integrated spawning with ptrace support, see debugger_spawn.cpp.
 */

#include "process_api.h"

#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#ifndef TARGET_IS_ANDROID
#include <pty.h>
#endif

#include "native_api.h"

// =============================================================================
// Process Spawning
// =============================================================================

// Internal helper for spawning with argv/envp arrays (not used by Rust FFI)
static pid_t spawn_process_internal(const char* executable_path, char* const argv[],
                                    char* const envp[], int suspended)
{
    pid_t pid = fork();

    if (pid < 0)
    {
        debug_log(LOG_ERROR, "fork() failed: %s", strerror(errno));
        return -1;
    }

    if (pid == 0)
    {
        // Child process

        // If suspended, stop self immediately
        if (suspended)
        {
            raise(SIGSTOP);
        }

        // Execute the target
        if (envp != NULL)
        {
            execve(executable_path, argv, envp);
        }
        else
        {
            execv(executable_path, argv);
        }

        // If exec returns, it failed
        fprintf(stderr, "exec failed for %s: %s\n", executable_path, strerror(errno));
        _exit(127);
    }

    // Parent process

    if (suspended)
    {
        // Wait for child to stop from SIGSTOP
        int status;
        pid_t result = waitpid(pid, &status, WUNTRACED);
        if (result != pid)
        {
            debug_log(LOG_ERROR, "waitpid failed for suspended child: %s", strerror(errno));
            kill(pid, SIGKILL);
            return -1;
        }

        if (!WIFSTOPPED(status))
        {
            debug_log(LOG_ERROR, "Child did not stop as expected");
            kill(pid, SIGKILL);
            return -1;
        }

        debug_log(LOG_INFO, "Spawned suspended process: %d", pid);
    }
    else
    {
        debug_log(LOG_INFO, "Spawned process: %d", pid);
    }

    return pid;
}

#ifndef TARGET_IS_ANDROID
pid_t spawn_process_with_pty_native(const char* executable_path, char* const argv[],
                                    char* const envp[], int* pty_fd_out)
{
    int master_fd;
    pid_t pid = forkpty(&master_fd, NULL, NULL, NULL);

    if (pid < 0)
    {
        debug_log(LOG_ERROR, "forkpty() failed: %s", strerror(errno));
        return -1;
    }

    if (pid == 0)
    {
        // Child process (in new PTY)

        // Execute the target
        if (envp != NULL)
        {
            execve(executable_path, argv, envp);
        }
        else
        {
            execv(executable_path, argv);
        }

        // If exec returns, it failed
        fprintf(stderr, "exec failed for %s: %s\n", executable_path, strerror(errno));
        _exit(127);
    }

    // Parent process
    if (pty_fd_out != NULL)
    {
        *pty_fd_out = master_fd;
    }

    debug_log(LOG_INFO, "Spawned process with PTY: pid=%d, pty_fd=%d", pid, master_fd);
    return pid;
}
#else
// Android stub
pid_t spawn_process_with_pty_native(const char* executable_path, char* const argv[],
                                    char* const envp[], int* pty_fd_out)
{
    (void)executable_path;
    (void)argv;
    (void)envp;
    if (pty_fd_out) *pty_fd_out = -1;
    debug_log(LOG_ERROR, "PTY spawn not supported on Android");
    return -1;
}
#endif

// =============================================================================
// Process Termination
// =============================================================================

int terminate_process_native(pid_t pid, int force)
{
    if (pid <= 0)
    {
        return -1;
    }

    int sig = force ? SIGKILL : SIGTERM;
    int result = kill(pid, sig);

    if (result < 0)
    {
        debug_log(LOG_ERROR, "kill(%d, %d) failed: %s", pid, sig, strerror(errno));
        return -1;
    }

    debug_log(LOG_INFO, "Sent signal %d to process %d", sig, pid);
    return 0;
}

// =============================================================================
// Process Suspend/Resume
// =============================================================================

int suspend_process_native(pid_t pid)
{
    if (pid <= 0)
    {
        return -1;
    }

    int result = kill(pid, SIGSTOP);
    if (result < 0)
    {
        debug_log(LOG_ERROR, "kill(%d, SIGSTOP) failed: %s", pid, strerror(errno));
        return -1;
    }

    debug_log(LOG_DEBUG, "Sent SIGSTOP to process %d", pid);
    return 0;
}

int resume_process_native(pid_t pid)
{
    if (pid <= 0)
    {
        return -1;
    }

    int result = kill(pid, SIGCONT);
    if (result < 0)
    {
        debug_log(LOG_ERROR, "kill(%d, SIGCONT) failed: %s", pid, strerror(errno));
        return -1;
    }

    debug_log(LOG_DEBUG, "Sent SIGCONT to process %d", pid);
    return 0;
}

// =============================================================================
// Process Status
// =============================================================================

int is_process_running_native(pid_t pid)
{
    if (pid <= 0)
    {
        return -1;
    }

    // Check if process exists by sending signal 0
    int result = kill(pid, 0);
    if (result < 0)
    {
        if (errno == ESRCH)
        {
            return 0;  // Process not found
        }
        else if (errno == EPERM)
        {
            return 1;  // Process exists but no permission
        }
        return -1;  // Error
    }

    return 1;  // Process exists
}

int get_process_exit_status_native(pid_t pid, int* status_out)
{
    if (pid <= 0)
    {
        return -1;
    }

    int status;
    pid_t result = waitpid(pid, &status, WNOHANG);

    if (result < 0)
    {
        debug_log(LOG_ERROR, "waitpid(%d) failed: %s", pid, strerror(errno));
        return -1;
    }

    if (result == 0)
    {
        // Process still running
        return 1;
    }

    // Process exited
    if (status_out != NULL)
    {
        if (WIFEXITED(status))
        {
            *status_out = WEXITSTATUS(status);
        }
        else if (WIFSIGNALED(status))
        {
            *status_out = -WTERMSIG(status);  // Negative to indicate signal
        }
        else
        {
            *status_out = -1;
        }
    }

    return 0;
}

```

`src/server/src/cpp/src/linux/core/process_api.h`:

```h
/**
 * @file process_api.h
 * @brief Process spawning and management API for Linux/Android
 *
 * This header provides process lifecycle management:
 * - Process spawning with PTY support
 * - Process termination
 * - Process suspend/resume
 *
 * Note: On Linux, process spawning is typically done via fork/exec
 * or through the debugger's spawn functionality.
 */

#ifndef LINUX_PROCESS_API_H
#define LINUX_PROCESS_API_H

#include <sys/types.h>

#ifdef __cplusplus
extern "C"
{
#endif

    /**
     * Spawn a new process with PTY
     * @param executable_path Path to the executable
     * @param argv NULL-terminated argument array
     * @param envp NULL-terminated environment array (NULL to inherit)
     * @param pty_fd_out Pointer to store the PTY master file descriptor
     * @return PID of spawned process, or -1 on error
     */
    pid_t spawn_process_with_pty_native(const char* executable_path, char* const argv[],
                                        char* const envp[], int* pty_fd_out);

    /**
     * Terminate a process by PID
     * @param pid Process ID to terminate
     * @param force If non-zero, use SIGKILL instead of SIGTERM
     * @return 0 on success, -1 on error
     */
    int terminate_process_native(pid_t pid, int force);

    /**
     * Suspend a process (send SIGSTOP)
     * @param pid Process ID to suspend
     * @return 0 on success, -1 on error
     */
    int suspend_process_native(pid_t pid);

    /**
     * Resume a suspended process (send SIGCONT)
     * @param pid Process ID to resume
     * @return 0 on success, -1 on error
     */
    int resume_process_native(pid_t pid);

    /**
     * Check if a process is running
     * @param pid Process ID to check
     * @return 1 if running, 0 if not running, -1 on error
     */
    int is_process_running_native(pid_t pid);

    /**
     * Get process exit status (for terminated processes)
     * @param pid Process ID
     * @param status_out Pointer to store exit status
     * @return 0 if exited, 1 if still running, -1 on error
     */
    int get_process_exit_status_native(pid_t pid, int* status_out);

#ifdef __cplusplus
}
#endif

#endif  // LINUX_PROCESS_API_H

```

`src/server/src/cpp/src/linux/debugger/arch_defs.h`:

```h
// Architecture-specific definitions for Linux debugger
// Supports ARM64 and x86_64 architectures

#ifndef ARCH_DEFS_H
#define ARCH_DEFS_H

#include <sys/ptrace.h>
#include <sys/user.h>

#include <cstddef>
#include <cstdint>

// =============================================================================
// PTRACE compatibility definitions
// =============================================================================

// ptrace request values - define unconditionally since they may be enums in system headers
#ifndef DYNA_PTRACE_GETREGSET
#define DYNA_PTRACE_GETREGSET 0x4204
#endif
#ifndef DYNA_PTRACE_SETREGSET
#define DYNA_PTRACE_SETREGSET 0x4205
#endif
#ifndef DYNA_PTRACE_SEIZE
#define DYNA_PTRACE_SEIZE 0x4206
#endif
#ifndef DYNA_PTRACE_INTERRUPT
#define DYNA_PTRACE_INTERRUPT 0x4207
#endif

// NT_PRSTATUS for register access (usually defined in elf.h, but define fallback)
#ifndef NT_PRSTATUS
#define NT_PRSTATUS 1
#endif

// Helper macro for ptrace calls to handle type casting
// Android (bionic) uses int for ptrace request, while glibc uses __ptrace_request enum
#ifdef __ANDROID__
#define PTRACE_CALL(request, ...) ptrace((int)(request), ##__VA_ARGS__)
#else
#define PTRACE_CALL(request, ...) ptrace((__ptrace_request)(request), ##__VA_ARGS__)
#endif

// PTRACE constants compatibility - some systems use PTRACE_PEEKUSR/POKEUSR
#ifndef PTRACE_PEEKUSR
#define PTRACE_PEEKUSR PTRACE_PEEKUSER
#endif
#ifndef PTRACE_POKEUSR
#define PTRACE_POKEUSR PTRACE_POKEUSER
#endif
#ifndef PTRACE_PEEKUSER
#define PTRACE_PEEKUSER PTRACE_PEEKUSR
#endif
#ifndef PTRACE_POKEUSER
#define PTRACE_POKEUSER PTRACE_POKEUSR
#endif

// PTRACE_SEIZE and PTRACE_INTERRUPT for modern ptrace API
#ifndef PTRACE_SEIZE
#define PTRACE_SEIZE 0x4206
#endif
#ifndef PTRACE_INTERRUPT
#define PTRACE_INTERRUPT 0x4207
#endif

// PTRACE_EVENT_STOP for PTRACE_INTERRUPT support
#ifndef PTRACE_EVENT_STOP
#define PTRACE_EVENT_STOP 128
#endif

// =============================================================================
// ARM64-specific definitions
// =============================================================================

#if defined(__aarch64__)

#include <asm/ptrace.h>
#include <linux/hw_breakpoint.h>

// Linux ARM64 hardware debug support
#ifndef PTRACE_GETHBPREGS
#define PTRACE_GETHBPREGS 29
#endif
#ifndef PTRACE_SETHBPREGS
#define PTRACE_SETHBPREGS 30
#endif

// Hardware breakpoint control register bits for ARM64
#define ARM_BREAKPOINT_EXECUTE 0x0
#define ARM_BREAKPOINT_LOAD 0x1
#define ARM_BREAKPOINT_STORE 0x2
#define ARM_BREAKPOINT_RW (ARM_BREAKPOINT_LOAD | ARM_BREAKPOINT_STORE)

// ARM64 breakpoint length encoding
#define ARM_BREAKPOINT_LEN_1 0x1
#define ARM_BREAKPOINT_LEN_2 0x3
#define ARM_BREAKPOINT_LEN_4 0xf
#define ARM_BREAKPOINT_LEN_8 0xff

// NT constants for ARM64 hardware debug
#ifndef NT_ARM_HW_BREAK
#define NT_ARM_HW_BREAK 0x402
#endif
#ifndef NT_ARM_HW_WATCH
#define NT_ARM_HW_WATCH 0x403
#endif

// Encode ARM64 debug control register
// Bit 0: E (Enable)
// Bits 1-2: PMC (Privilege mode control) - 0=User, 1=Privileged, 2=User, 3=Any
// Bits 3-4: LSC/Type (Load/Store Control for watchpoint, Type for breakpoint)
//   - Breakpoint: 0=Execute
//   - Watchpoint: 1=Load, 2=Store, 3=Load+Store
// Bits 5-12: BAS/LEN (Byte Address Select / Length)
//   - 0x1=1byte, 0x3=2bytes, 0xf=4bytes, 0xff=8bytes
// Bit 22: Mismatch (usually 0)
inline uint32_t encode_ctrl_reg(int mismatch, int len, int type, int privilege, int enabled)
{
    return (mismatch << 22) | (len << 5) | (type << 3) | (privilege << 1) | enabled;
}

// =============================================================================
// x86_64-specific definitions
// =============================================================================

#elif defined(__x86_64__)

// x86_64 hardware debug registers
// DR0-DR3: Address registers for breakpoints
// DR6: Debug status register
// DR7: Debug control register

// DR7 bit definitions for x86_64
#define X86_DR7_L0 (1 << 0)       // Local enable for DR0
#define X86_DR7_G0 (1 << 1)       // Global enable for DR0
#define X86_DR7_L1 (1 << 2)       // Local enable for DR1
#define X86_DR7_G1 (1 << 3)       // Global enable for DR1
#define X86_DR7_L2 (1 << 4)       // Local enable for DR2
#define X86_DR7_G2 (1 << 5)       // Global enable for DR2
#define X86_DR7_L3 (1 << 6)       // Local enable for DR3
#define X86_DR7_G3 (1 << 7)       // Global enable for DR3

// DR7 condition bits (bits 16-17, 20-21, 24-25, 28-29 for DR0-DR3)
#define X86_DR7_BREAK_ON_EXEC 0   // Break on execution
#define X86_DR7_BREAK_ON_WRITE 1  // Break on write
#define X86_DR7_BREAK_ON_IO 2     // Break on I/O (not typically used)
#define X86_DR7_BREAK_ON_RW 3     // Break on read/write

// DR7 length bits (bits 18-19, 22-23, 26-27, 30-31 for DR0-DR3)
#define X86_DR7_LEN_1 0           // 1 byte
#define X86_DR7_LEN_2 1           // 2 bytes
#define X86_DR7_LEN_8 2           // 8 bytes (only on 64-bit)
#define X86_DR7_LEN_4 3           // 4 bytes

// Debug register offsets in struct user for x86_64
#define X86_DR0_OFFSET offsetof(struct user, u_debugreg[0])
#define X86_DR1_OFFSET offsetof(struct user, u_debugreg[1])
#define X86_DR2_OFFSET offsetof(struct user, u_debugreg[2])
#define X86_DR3_OFFSET offsetof(struct user, u_debugreg[3])
#define X86_DR6_OFFSET offsetof(struct user, u_debugreg[6])
#define X86_DR7_OFFSET offsetof(struct user, u_debugreg[7])

// Helper function to get debug register offset by index
inline size_t x86_dr_offset(int index)
{
    static const size_t offsets[] = {X86_DR0_OFFSET,
                                     X86_DR1_OFFSET,
                                     X86_DR2_OFFSET,
                                     X86_DR3_OFFSET,
                                     0,
                                     0,  // DR4 and DR5 are reserved
                                     X86_DR6_OFFSET,
                                     X86_DR7_OFFSET};
    return (index >= 0 && index <= 7) ? offsets[index] : 0;
}

#endif  // Architecture selection

#endif  // ARCH_DEFS_H

```

`src/server/src/cpp/src/linux/debugger/debugger.h`:

```h
// Linux debugger core class
// Handles process attachment, breakpoints, watchpoints, and debug events

#ifndef DEBUGGER_H
#define DEBUGGER_H

#include <array>
#include <atomic>
#include <map>
#include <memory>
#include <queue>
#include <set>
#include <thread>

#include "../../common/util.h"
#include "../core/native_api.h"
#include "arch_defs.h"
#include "debugger_types.h"

// Architecture-specific register structure includes
#if defined(__aarch64__)
#include <asm/ptrace.h>
#elif defined(__x86_64__)
#include <sys/user.h>
#endif

#ifdef DYNAMIC_LIB_BUILD
// In dynamic library mode, use callback_stubs.cpp for native_log and send_exception_info
// Users can set custom callbacks via set_native_log_callback() and
// set_send_exception_info_callback()
#define Debugger DebuggerDynamic
#endif

// =============================================================================
// Debugger class
// =============================================================================

class Debugger
{
public:
    Debugger();  // Default constructor for spawn (pid will be set later)
    explicit Debugger(pid_t pid);
    ~Debugger();

    bool initialize();
    bool initialize_for_spawn();  // Initialize for PTRACE_TRACEME spawned process
    void run();

    // Spawn process in debugger thread (solves ptrace thread affinity)
    int spawn_process(const std::string& executable_path, const std::vector<std::string>& args,
                      pid_t* out_pid);
    int spawn_process_with_pty(const std::string& executable_path,
                               const std::vector<std::string>& args, pid_t* out_pid,
                               int* out_pty_fd);

    // Breakpoint and watchpoint management
    int set_watchpoint(uint64_t address, int size, WatchpointType type);
    int remove_watchpoint(uint64_t address);
    int set_breakpoint(uint64_t address, int hit_count, bool is_software = false);
    int remove_breakpoint(uint64_t address);

    // Software breakpoint original instruction query
    bool get_software_breakpoint_original_bytes(uint64_t address, uint8_t* out_bytes,
                                                size_t* out_size);

    // Exception handling
    int handle_exception(pid_t pid, int status);

    // Execution control
    int continue_execution(pid_t thread_id);
    int single_step(pid_t thread_id);

    // Register and memory access
    int read_register(pid_t thread_id, const std::string& reg_name, uint64_t* value);
    int write_register(pid_t thread_id, const std::string& reg_name, uint64_t value);
    ssize_t read_memory(uint64_t address, size_t size, unsigned char* buffer);

    // State queries
    DebugState get_debug_state() const;
    bool is_in_break_state() const;
    pid_t get_pid() const
    {
        return pid_;
    }
    bool is_running() const
    {
        return debug_loop_running_;
    }

    // Signal/Exception monitoring configuration
    void set_signal_config(int signal, const SignalConfig& config);
    SignalConfig get_signal_config(int signal) const;
    std::map<int, SignalConfig> get_all_signal_configs() const;
    void set_all_signal_configs(const std::map<int, SignalConfig>& configs);
    void remove_signal_config(int signal);

    // User suspend/resume control (called from native_api.cpp)
    void set_user_suspend_pending(bool pending)
    {
        user_suspend_pending_.store(pending);
    }
    bool is_user_suspend_pending() const
    {
        return user_suspend_pending_.load();
    }
    int resume_all_user_stopped_threads();

private:
    // =========================================================================
    // Synchronization structures
    // =========================================================================

    // Per-watchpoint/breakpoint synchronization structure
    // Uses atomics only to avoid pthread_cond_clockwait
    struct WatchpointSync
    {
        std::atomic<bool> removing{false};
        std::atomic<int> active_handlers{0};
    };

    struct BreakpointSync
    {
        std::atomic<bool> removing{false};
        std::atomic<int> active_handlers{0};
    };

    // =========================================================================
    // Constants
    // =========================================================================

    static const int MAX_WATCHPOINTS = 1;  // Limited to 1 for stability
    static const int MAX_BREAKPOINTS = 4;
    static const int MAX_SOFTWARE_BREAKPOINTS = 1000000;

    // =========================================================================
    // Single step mode
    // =========================================================================

    enum class SingleStepMode
    {
        None,
        Watchpoint,
        Breakpoint,
        HardwareBreakpointContinue,
        SoftwareBreakpoint,
        SoftwareBreakpointContinue
    };

    // =========================================================================
    // Thread state
    // =========================================================================

    struct ThreadState
    {
        SingleStepMode single_step_mode = SingleStepMode::None;
        int single_step_count = 0;
        int current_breakpoint_index = -1;
#if defined(__aarch64__)
        struct user_pt_regs regs;
#elif defined(__x86_64__)
        struct user_regs_struct regs;
#endif
        bool is_attached = false;
        bool is_stopped = false;
        bool stopped_by_user = false;
        uint32_t original_wcr = 0;
        int disabled_watchpoint_index = -1;
        int pending_signal = 0;
    };

    // =========================================================================
    // Member variables
    // =========================================================================

    // Synchronization
    std::array<WatchpointSync, 1> watchpoint_sync_;
    std::array<BreakpointSync, 4> breakpoint_sync_;
    std::mutex thread_states_mutex_;
    mutable std::mutex watchpoint_data_mutex_;
    mutable std::mutex breakpoint_data_mutex_;
    std::atomic<uint32_t> removing_mask_{0};

    // Process state
    pid_t pid_;
    std::set<pid_t> attached_threads_;
    bool debug_loop_running_;
    std::thread debug_thread_;
    std::atomic<bool> user_suspend_pending_{false};

    // Command queue
    std::queue<std::shared_ptr<DebugRequest>> debug_command_queue_;
    std::mutex queue_mutex_;
    std::condition_variable queue_cv_;
    bool threads_attached_ = false;

    // Watchpoint data
    std::vector<bool> watchpoint_used;
    std::vector<uint64_t> watchpoint_addresses;
    std::vector<int> watchpoint_sizes;
    std::vector<WatchpointType> watchpoint_types;

    // Hardware breakpoint data
    std::vector<bool> breakpoint_used;
    std::vector<uint64_t> breakpoint_addresses;
    std::vector<int> breakpoint_hit_counts;
    std::vector<int> breakpoint_target_counts;
    std::vector<BreakpointType> breakpoint_types;

    // Software breakpoint data
    std::vector<bool> software_breakpoint_used;
    std::vector<uint64_t> software_breakpoint_addresses;
    std::vector<uint8_t> software_breakpoint_original_bytes;
    mutable std::mutex software_breakpoint_mutex_;

    // Thread and debug state
    std::map<pid_t, ThreadState> thread_states_;
    DebugState debug_state_ = DebugState::Running;
    pid_t current_thread = 0;

    // Signal configuration
    std::map<int, SignalConfig> signal_config_;
    mutable std::mutex signal_config_mutex_;

    // =========================================================================
    // Private helper methods
    // =========================================================================

    std::vector<pid_t> get_thread_list();
    pid_t find_stopped_thread();
    int attach_to_threads();
    void debug_message_loop();
    int wait_for_debug_event(pid_t* thread_id, int* status);

    // Command queue processing
    void enqueue_command(std::shared_ptr<DebugRequest> request);
    void process_command_queue();
    int process_set_watchpoint_command(std::shared_ptr<DebugRequest> request);
    int process_remove_watchpoint_command(std::shared_ptr<DebugRequest> request);
    int process_set_breakpoint_command(std::shared_ptr<DebugRequest> request);
    int process_remove_breakpoint_command(std::shared_ptr<DebugRequest> request);
    int process_continue_execution_command(std::shared_ptr<DebugRequest> request);
    int process_single_step_command(std::shared_ptr<DebugRequest> request);
    int process_reapply_watchpoints_command(std::shared_ptr<DebugRequest> request);
    int process_read_register_command(std::shared_ptr<DebugRequest> request);
    int process_write_register_command(std::shared_ptr<DebugRequest> request);
    int process_read_memory_command(std::shared_ptr<DebugRequest> request);
    int process_spawn_command(std::shared_ptr<DebugRequest> request);
    int process_spawn_with_pty_command(std::shared_ptr<DebugRequest> request);

    // Internal implementations (called by debug thread)
    int set_watchpoint_internal(uint64_t address, int size, WatchpointType type);
    int remove_watchpoint_internal(uint64_t address);
    int set_breakpoint_internal(uint64_t address, int hit_count, BreakpointType bp_type);
    int set_hardware_breakpoint_internal(uint64_t address, int hit_count);
    int set_software_breakpoint_internal(uint64_t address, int hit_count);
    int remove_breakpoint_internal(uint64_t address);
    int remove_software_breakpoint_internal(uint64_t address);
    int continue_execution_internal(pid_t thread_id);
    int single_step_internal(pid_t thread_id);
    int reapply_all_watchpoints_internal();
    int reapply_all_watchpoints_internal(pid_t already_stopped_thread);
    int read_register_internal(pid_t thread_id, const std::string& reg_name, uint64_t* value);
    int write_register_internal(pid_t thread_id, const std::string& reg_name, uint64_t value);
    ssize_t read_memory_internal(uint64_t address, size_t size, unsigned char* buffer);
    int spawn_process_internal(std::shared_ptr<DebugRequest> request);
    int spawn_process_with_pty_internal(std::shared_ptr<DebugRequest> request);
    int resume_all_user_stopped_threads_internal();

    // Thread control
    std::vector<pid_t> stop_all_threads(pid_t exclude_thread_id = 0,
                                        std::vector<pid_t>* already_stopped_out = nullptr);
    void resume_threads(const std::vector<pid_t>& stopped_threads);
    void cancel_interrupt_for_non_stopped_threads(const std::vector<pid_t>& stopped_threads);
    bool verify_threads_stopped(std::vector<pid_t>& threads_to_verify);

    // Hardware register operations
    bool apply_watchpoint_to_threads(const std::vector<pid_t>& threads, int index, uint64_t address,
                                     int size, WatchpointType type);
    bool apply_watchpoint_to_thread(pid_t thread, int index, uint64_t address, int size,
                                    WatchpointType type);
    bool clear_watchpoint_from_threads(const std::vector<pid_t>& threads, int index);
    bool apply_breakpoint_to_threads(const std::vector<pid_t>& threads, int index,
                                     uint64_t address);
    bool apply_breakpoint_to_thread(pid_t thread, int index, uint64_t address);
    bool clear_breakpoint_from_threads(const std::vector<pid_t>& threads, int index);

    // Event handlers
    int handle_single_step(pid_t thread);
    int complete_watchpoint_single_step(pid_t thread);
    int continue_breakpoint_single_step(pid_t thread);
    int handle_watchpoint_hit(pid_t thread, int watchpoint_index);
    int handle_breakpoint_hit(pid_t thread, int breakpoint_index);
    int handle_software_breakpoint_continue(pid_t thread, int breakpoint_index);

    // Utility methods
    int find_free_watchpoint();
    int find_watchpoint_index(uint64_t address);
    int find_free_breakpoint();
    int find_breakpoint_index(uint64_t address);
    int get_available_watchpoints(pid_t thread);
    int set_watchpoint_on_thread(pid_t thread, uint64_t address, int size, WatchpointType type,
                                 int index);
    int clear_watchpoint_on_thread(pid_t thread, int index);
    int remove_watchpoint_by_index(int index);
};

// Global pointer to the Debugger instance
extern Debugger* g_debugger;

#endif  // DEBUGGER_H
```

`src/server/src/cpp/src/linux/debugger/debugger_breakpoint.cpp`:

```cpp
/**
 * @file debugger_breakpoint.cpp
 * @brief Breakpoint-related member functions for the Debugger class
 *
 * This file contains all breakpoint management functionality including:
 * - Hardware breakpoint set/remove operations
 * - Software breakpoint set/remove operations
 * - Breakpoint hit handling
 * - Thread-specific breakpoint application
 *
 * Part of the DynaDbg Linux debugger implementation.
 */

#include "debugger_internal.h"

// =============================================================================
// Public Breakpoint API
// =============================================================================

int Debugger::set_breakpoint(uint64_t address, int hit_count, bool is_software)
{
    // Create request and enqueue it to the debug thread
    auto request = std::make_shared<DebugRequest>(DebugCommand::SetBreakpoint);
    request->address = address;
    request->hit_count = hit_count;
    request->breakpoint_type = is_software ? BreakpointType::SOFTWARE : BreakpointType::HARDWARE;

    enqueue_command(request);

    // Wait for the result
    std::unique_lock<std::mutex> lock(request->result_mutex);
    request->result_cv.wait(lock, [request] { return request->completed; });

    return request->result;
}

int Debugger::remove_breakpoint(uint64_t address)
{
    // Create request and enqueue it to the debug thread
    auto request = std::make_shared<DebugRequest>(DebugCommand::RemoveBreakpoint);
    request->address = address;

    enqueue_command(request);

    // Wait for the result
    std::unique_lock<std::mutex> lock(request->result_mutex);
    request->result_cv.wait(lock, [request] { return request->completed; });

    return request->result;
}

// =============================================================================
// Internal Breakpoint Implementation
// =============================================================================

int Debugger::set_breakpoint_internal(uint64_t address, int hit_count, BreakpointType bp_type)
{
    // Route to appropriate implementation based on breakpoint type
    if (bp_type == BreakpointType::SOFTWARE)
    {
        return set_software_breakpoint_internal(address, hit_count);
    }
    else
    {
        return set_hardware_breakpoint_internal(address, hit_count);
    }
}

int Debugger::set_hardware_breakpoint_internal(uint64_t address, int hit_count)
{
    int index = find_free_breakpoint();
    if (index == -1)
    {
        debug_log(LOG_ERROR, "No free breakpoints available");
        return -1;
    }

    // Step 1: Stop all threads, tracking which were already stopped
    std::vector<pid_t> already_stopped;
    std::vector<pid_t> stopped_threads = stop_all_threads(0, &already_stopped);
    if (stopped_threads.empty())
    {
        debug_log(LOG_ERROR, "Failed to stop any threads for breakpoint setup");
        return -1;
    }

    // Step 2: Apply breakpoint to all stopped threads
    bool success = apply_breakpoint_to_threads(stopped_threads, index, address);

    // Step 3: Resume only threads that were NOT already stopped before this call
    std::set<pid_t> already_stopped_set(already_stopped.begin(), already_stopped.end());
    std::vector<pid_t> threads_to_resume;
    for (pid_t tid : stopped_threads)
    {
        if (already_stopped_set.find(tid) == already_stopped_set.end())
        {
            threads_to_resume.push_back(tid);
        }
    }
    resume_threads(threads_to_resume);

    if (success)
    {
        {
            std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
            breakpoint_used[index] = true;
            breakpoint_addresses[index] = address;
            // hit_count == 0 means wait mode (target_count = 0)
            // hit_count > 0 means trace mode (target_count = hit_count)
            breakpoint_target_counts[index] = hit_count;
            breakpoint_hit_counts[index] = 0;
            breakpoint_types[index] = BreakpointType::HARDWARE;
        }

        return 0;
    }
    else
    {
        debug_log(LOG_ERROR, "Failed to apply breakpoint to threads");
        return -1;
    }
}

int Debugger::set_software_breakpoint_internal(uint64_t address, int hit_count)
{
    // Find free software breakpoint slot
    int index = -1;
    {
        std::lock_guard<std::mutex> lock(software_breakpoint_mutex_);
        for (int i = 0; i < MAX_SOFTWARE_BREAKPOINTS; i++)
        {
            if (!software_breakpoint_used[i])
            {
                index = i;
                break;
            }
        }
    }

    if (index == -1)
    {
        debug_log(LOG_ERROR, "No free software breakpoints available");
        return -1;
    }

    // Step 1: Stop all threads, tracking which were already stopped
    std::vector<pid_t> already_stopped;
    std::vector<pid_t> stopped_threads = stop_all_threads(0, &already_stopped);
    if (stopped_threads.empty())
    {
        debug_log(LOG_ERROR, "Failed to stop any threads for software breakpoint setup");
        return -1;
    }

    // Step 2: Read original instruction bytes
#if defined(__aarch64__)
    const size_t bp_size = 4;                     // ARM64 instructions are 4 bytes
    const uint32_t brk_instruction = 0xD4200000;  // BRK #0
#elif defined(__x86_64__)
    const size_t bp_size = 1;              // x86 INT3 is 1 byte
    const uint8_t brk_instruction = 0xCC;  // INT3
#endif

    uint8_t original_bytes[4] = {0};

    // Read original instruction using PTRACE_PEEKDATA
    errno = 0;
    long word = ptrace(PTRACE_PEEKDATA, pid_, (void*)address, nullptr);
    if (errno != 0)
    {
        debug_log(LOG_ERROR, "Failed to read memory at 0x%lx for software breakpoint: %s", address,
                  strerror(errno));
        // Resume threads
        std::set<pid_t> already_stopped_set(already_stopped.begin(), already_stopped.end());
        std::vector<pid_t> threads_to_resume;
        for (pid_t tid : stopped_threads)
        {
            if (already_stopped_set.find(tid) == already_stopped_set.end())
            {
                threads_to_resume.push_back(tid);
            }
        }
        resume_threads(threads_to_resume);
        return -1;
    }

    memcpy(original_bytes, &word, bp_size);

    // Step 3: Write breakpoint instruction
#if defined(__aarch64__)
    // Replace first 4 bytes with BRK #0
    uint32_t new_word = brk_instruction;
    // Preserve rest of word if needed (for alignment)
    long patched_word = (word & ~0xFFFFFFFFUL) | new_word;
#elif defined(__x86_64__)
    // Replace first byte with INT3
    long patched_word = (word & ~0xFFUL) | brk_instruction;
#endif

    if (ptrace(PTRACE_POKEDATA, pid_, (void*)address, (void*)patched_word) == -1)
    {
        debug_log(LOG_ERROR, "Failed to write software breakpoint at 0x%lx: %s", address,
                  strerror(errno));
        // Resume threads
        std::set<pid_t> already_stopped_set(already_stopped.begin(), already_stopped.end());
        std::vector<pid_t> threads_to_resume;
        for (pid_t tid : stopped_threads)
        {
            if (already_stopped_set.find(tid) == already_stopped_set.end())
            {
                threads_to_resume.push_back(tid);
            }
        }
        resume_threads(threads_to_resume);
        return -1;
    }

    // Step 4: Resume threads
    std::set<pid_t> already_stopped_set(already_stopped.begin(), already_stopped.end());
    std::vector<pid_t> threads_to_resume;
    for (pid_t tid : stopped_threads)
    {
        if (already_stopped_set.find(tid) == already_stopped_set.end())
        {
            threads_to_resume.push_back(tid);
        }
    }
    resume_threads(threads_to_resume);

    // Step 5: Store breakpoint info
    {
        std::lock_guard<std::mutex> lock(software_breakpoint_mutex_);
        software_breakpoint_used[index] = true;
        software_breakpoint_addresses[index] = address;
        // Store original bytes (4 bytes per breakpoint)
        memcpy(&software_breakpoint_original_bytes[index * 4], original_bytes, 4);
    }

    // Also register in main breakpoint tracking (for hit detection)
    {
        std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
        // Find a hardware breakpoint slot to track this (use negative index or separate tracking)
        // For now, we track software breakpoints separately
    }

    return 0;
}

// =============================================================================
// Remove Breakpoint Functions
// =============================================================================

int Debugger::remove_software_breakpoint_internal(uint64_t address)
{
    // Find the software breakpoint
    int index = -1;
    uint8_t original_bytes[4] = {0};
    {
        std::lock_guard<std::mutex> lock(software_breakpoint_mutex_);
        for (int i = 0; i < MAX_SOFTWARE_BREAKPOINTS; i++)
        {
            if (software_breakpoint_used[i] && software_breakpoint_addresses[i] == address)
            {
                index = i;
                memcpy(original_bytes, &software_breakpoint_original_bytes[i * 4], 4);
                break;
            }
        }
    }

    if (index == -1)
    {
        debug_log(LOG_ERROR, "Software breakpoint not found at address 0x%lx", address);
        return -1;
    }

    // Stop all threads
    std::vector<pid_t> already_stopped;
    std::vector<pid_t> stopped_threads = stop_all_threads(0, &already_stopped);
    if (stopped_threads.empty())
    {
        debug_log(LOG_ERROR, "Failed to stop any threads for software breakpoint removal");
        return -1;
    }

    // Read current memory word
    errno = 0;
    long word = ptrace(PTRACE_PEEKDATA, pid_, (void*)address, nullptr);
    if (errno != 0)
    {
        debug_log(LOG_ERROR, "Failed to read memory at 0x%lx for software breakpoint removal: %s",
                  address, strerror(errno));
        // Resume threads
        std::set<pid_t> already_stopped_set(already_stopped.begin(), already_stopped.end());
        std::vector<pid_t> threads_to_resume;
        for (pid_t tid : stopped_threads)
        {
            if (already_stopped_set.find(tid) == already_stopped_set.end())
            {
                threads_to_resume.push_back(tid);
            }
        }
        resume_threads(threads_to_resume);
        return -1;
    }

    // Restore original bytes
#if defined(__aarch64__)
    const size_t bp_size = 4;
    uint32_t orig_instr;
    memcpy(&orig_instr, original_bytes, 4);
    long restored_word = (word & ~0xFFFFFFFFUL) | orig_instr;
#elif defined(__x86_64__)
    const size_t bp_size = 1;
    long restored_word = (word & ~0xFFUL) | original_bytes[0];
#endif

    if (ptrace(PTRACE_POKEDATA, pid_, (void*)address, (void*)restored_word) == -1)
    {
        debug_log(LOG_ERROR, "Failed to restore original instruction at 0x%lx: %s", address,
                  strerror(errno));
        // Resume threads
        std::set<pid_t> already_stopped_set(already_stopped.begin(), already_stopped.end());
        std::vector<pid_t> threads_to_resume;
        for (pid_t tid : stopped_threads)
        {
            if (already_stopped_set.find(tid) == already_stopped_set.end())
            {
                threads_to_resume.push_back(tid);
            }
        }
        resume_threads(threads_to_resume);
        return -1;
    }

    // Resume threads
    std::set<pid_t> already_stopped_set(already_stopped.begin(), already_stopped.end());
    std::vector<pid_t> threads_to_resume;
    for (pid_t tid : stopped_threads)
    {
        if (already_stopped_set.find(tid) == already_stopped_set.end())
        {
            threads_to_resume.push_back(tid);
        }
    }
    resume_threads(threads_to_resume);

    // Clear disabled_watchpoint_index for any threads that were stopped at this breakpoint
    int full_bp_index = index + 1000;  // Software breakpoint index format
    for (auto& [tid, state] : thread_states_)
    {
        if (state.disabled_watchpoint_index == full_bp_index)
        {
            debug_log(LOG_INFO,
                      "Clearing software breakpoint state for thread %d (breakpoint removed)", tid);
            state.disabled_watchpoint_index = -1;
        }
    }

    // Clear breakpoint info
    {
        std::lock_guard<std::mutex> lock(software_breakpoint_mutex_);
        software_breakpoint_used[index] = false;
        software_breakpoint_addresses[index] = 0;
        memset(&software_breakpoint_original_bytes[index * 4], 0, 4);
    }

    return 0;
}

bool Debugger::get_software_breakpoint_original_bytes(uint64_t address, uint8_t* out_bytes,
                                                      size_t* out_size)
{
    std::lock_guard<std::mutex> lock(software_breakpoint_mutex_);
    for (int i = 0; i < MAX_SOFTWARE_BREAKPOINTS; i++)
    {
        if (software_breakpoint_used[i] && software_breakpoint_addresses[i] == address)
        {
            memcpy(out_bytes, &software_breakpoint_original_bytes[i * 4], 4);
#if defined(__aarch64__)
            *out_size = 4;
#elif defined(__x86_64__)
            *out_size = 1;
#endif
            return true;
        }
    }
    return false;
}

int Debugger::remove_breakpoint_internal(uint64_t address)
{
    int index = find_breakpoint_index(address);
    if (index == -1)
    {
        debug_log(LOG_ERROR, "Breakpoint not found at address 0x%lx", address);
        return -1;
    }

    // Check if this is a software breakpoint (index >= 1000)
    if (index >= 1000)
    {
        return remove_software_breakpoint_internal(address);
    }

    // Set the removal flag
    breakpoint_sync_[index].removing.store(true);

    // Step 1: Stop all threads, tracking which were already stopped
    std::vector<pid_t> already_stopped;
    std::vector<pid_t> stopped_threads = stop_all_threads(0, &already_stopped);
    if (stopped_threads.empty())
    {
        debug_log(LOG_ERROR, "Failed to stop any threads for breakpoint removal");
        breakpoint_sync_[index].removing.store(false);
        return -1;
    }

    // Step 2: Clear breakpoint from all stopped threads
    bool success = clear_breakpoint_from_threads(stopped_threads, index);

    // Step 3: Resume only threads that were NOT already stopped before this call
    // Threads that were already stopped (e.g., at another breakpoint) should remain stopped
    std::set<pid_t> already_stopped_set(already_stopped.begin(), already_stopped.end());
    std::vector<pid_t> threads_to_resume;
    for (pid_t tid : stopped_threads)
    {
        if (already_stopped_set.find(tid) == already_stopped_set.end())
        {
            threads_to_resume.push_back(tid);
        }
    }
    resume_threads(threads_to_resume);

    if (success)
    {
        {
            std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
            breakpoint_used[index] = false;
            breakpoint_addresses[index] = 0;
            breakpoint_target_counts[index] = 0;
            breakpoint_hit_counts[index] = 0;
        }
        breakpoint_sync_[index].removing.store(false);

        return 0;
    }
    else
    {
        breakpoint_sync_[index].removing.store(false);
        debug_log(LOG_ERROR, "Failed to clear breakpoint from threads");
        return -1;
    }
}

// =============================================================================
// Breakpoint Index Management
// =============================================================================

int Debugger::find_free_breakpoint()
{
    std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
    for (int i = 0; i < MAX_BREAKPOINTS; i++)
    {
        if (!breakpoint_used[i])
        {
            return i;
        }
    }
    return -1;
}

int Debugger::find_breakpoint_index(uint64_t address)
{
    // First check hardware breakpoints
    {
        std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
        for (int i = 0; i < MAX_BREAKPOINTS; i++)
        {
            if (breakpoint_used[i] && breakpoint_addresses[i] == address)
            {
                return i;
            }
        }
    }

    // Then check software breakpoints (return index + 1000 to distinguish)
    // Note: On x86_64, when INT3 is hit, RIP points to the instruction AFTER INT3
    // So we check both the address and address-1 (for INT3 case)
    {
        std::lock_guard<std::mutex> lock(software_breakpoint_mutex_);
        for (int i = 0; i < MAX_SOFTWARE_BREAKPOINTS; i++)
        {
            if (software_breakpoint_used[i])
            {
                uint64_t bp_addr = software_breakpoint_addresses[i];
                if (bp_addr == address)
                {
                    return i + 1000;  // Offset to indicate software breakpoint
                }
#if defined(__x86_64__)
                // On x86_64, RIP points past the INT3 instruction
                if (address > 0 && bp_addr == address - 1)
                {
                    return i + 1000;  // Offset to indicate software breakpoint
                }
#endif
            }
        }
    }

    return -1;
}

// =============================================================================
// Breakpoint Hit Handling
// =============================================================================

int Debugger::handle_breakpoint_hit(pid_t thread, int breakpoint_index)
{
    // Note: hit count was already incremented in handle_exception
    // Check if this is a software breakpoint (index >= 1000)
    bool is_software_bp = (breakpoint_index >= 1000);
    int actual_index = is_software_bp ? (breakpoint_index - 1000) : breakpoint_index;

    // Read current registers
#if defined(__aarch64__)
    struct user_pt_regs regs;
    struct iovec iov = {.iov_base = &regs, .iov_len = sizeof(regs)};
    if (PTRACE_CALL(DYNA_PTRACE_GETREGSET, thread, NT_PRSTATUS, &iov) == -1)
#elif defined(__x86_64__)
    struct user_regs_struct regs;
    if (PTRACE_CALL(PTRACE_GETREGS, thread, nullptr, &regs) == -1)
#endif
    {
        debug_log(LOG_ERROR, "Failed to get registers for thread %d: %s", thread, strerror(errno));
        return -1;
    }

    // Get target_count and current_hit_count (only for hardware breakpoints)
    int target_count = 0;
    int current_hit_count = 0;
    if (!is_software_bp && actual_index >= 0 && actual_index < MAX_BREAKPOINTS)
    {
        std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
        target_count = breakpoint_target_counts[actual_index];
        current_hit_count = breakpoint_hit_counts[actual_index];
    }

    // Set thread-specific state
    // For software breakpoints, set current_breakpoint_index to -1 (no hardware bp)
    thread_states_[thread] =
        ThreadState{.single_step_mode = SingleStepMode::Breakpoint,
                    .single_step_count = 0,
                    .current_breakpoint_index = is_software_bp ? -1 : actual_index,
                    .regs = regs,
                    .is_attached = true,
                    .is_stopped = true,
                    .disabled_watchpoint_index = is_software_bp ? breakpoint_index : -1};

    // Software breakpoints don't support trace mode, so just return and wait for user action
    if (is_software_bp)
    {
        return 0;  // Stay stopped
    }

    // Check if this is trace mode (target_count > 0) - only for hardware breakpoints
    if (target_count > 0 && current_hit_count < target_count)
    {
        // Trace mode: set up single-step and continue without suspending

#if defined(__aarch64__)
        // Temporarily disable the breakpoint to avoid re-triggering
        struct user_hwdebug_state bp_state;
        memset(&bp_state, 0, sizeof(bp_state));
        struct iovec bp_iov = {.iov_base = &bp_state, .iov_len = 8 + 16 * MAX_BREAKPOINTS};

        if (ptrace(PTRACE_GETREGSET, thread, NT_ARM_HW_BREAK, &bp_iov) == 0)
        {
            bp_state.dbg_regs[actual_index].ctrl = 0;  // Disable breakpoint
            if (ptrace(PTRACE_SETREGSET, thread, NT_ARM_HW_BREAK, &bp_iov) == -1)
            {
                debug_log(LOG_ERROR, "Failed to disable breakpoint for tracing: %s",
                          strerror(errno));
            }
        }
#elif defined(__x86_64__)
        // x86_64: Temporarily disable the breakpoint
        unsigned long dr7 =
            PTRACE_CALL(PTRACE_PEEKUSER, thread, X86_DR7_OFFSET, nullptr);
        dr7 &= ~(1UL << (actual_index * 2));  // Clear local enable bit
        if (PTRACE_CALL(PTRACE_POKEUSER, thread, X86_DR7_OFFSET, (void*)dr7) == -1)
        {
            debug_log(LOG_ERROR, "Failed to disable breakpoint for tracing: %s", strerror(errno));
        }
#endif

        debug_state_ = DebugState::SingleStepping;

        // Mark thread as no longer stopped before single stepping
        thread_states_[thread].is_stopped = false;

        // Enable single step
        if (PTRACE_CALL(PTRACE_SINGLESTEP, thread, nullptr, nullptr) == -1)
        {
            debug_log(LOG_ERROR, "Failed to enable single step for thread %d: %s", thread,
                      strerror(errno));
            return -1;
        }

        return 0;
    }
    else
    {
        // Wait mode (target_count == 0): thread stays stopped at breakpoint
        thread_states_[thread].is_stopped = true;
    }

    return 0;
}

// =============================================================================
// Thread-Specific Breakpoint Operations
// =============================================================================

bool Debugger::apply_breakpoint_to_threads(const std::vector<pid_t>& threads, int index,
                                           uint64_t address)
{
    for (pid_t tid : threads)
    {
#if defined(__aarch64__)
        struct user_hwdebug_state bp_state;
        memset(&bp_state, 0, sizeof(bp_state));

        // Set proper iov length: 8 bytes header + 16 bytes per breakpoint * MAX_BREAKPOINTS
        struct iovec iov = {.iov_base = &bp_state, .iov_len = 8 + 16 * MAX_BREAKPOINTS};

        // Get current breakpoint state using ARM64 hardware breakpoint regset
        if (ptrace(PTRACE_GETREGSET, tid, NT_ARM_HW_BREAK, &iov) == -1)
        {
            int err = errno;
            if (err == ESRCH)
            {
                continue;
            }
            debug_log(LOG_ERROR, "Failed to get hardware breakpoint state for thread %d: %s", tid,
                      strerror(err));
            return false;
        }

        // Re-enable existing breakpoints that have addresses set
        for (int i = 0; i < MAX_BREAKPOINTS; i++)
        {
            if (bp_state.dbg_regs[i].addr != 0)
            {
                bp_state.dbg_regs[i].ctrl =
                    encode_ctrl_reg(0, ARM_BREAKPOINT_LEN_4, ARM_BREAKPOINT_EXECUTE, 0, 1);
            }
        }

        // encode_ctrl_reg(mismatch, len, type, privilege, enabled)
        // For execute breakpoint: mismatch=0, len=LEN_4, type=EXECUTE, privilege=0, enabled=1
        bp_state.dbg_regs[index].addr = address;
        bp_state.dbg_regs[index].ctrl =
            encode_ctrl_reg(0, ARM_BREAKPOINT_LEN_4, ARM_BREAKPOINT_EXECUTE, 0, 1);

        // Apply the breakpoint state using ARM64 hardware breakpoint regset
        if (ptrace(PTRACE_SETREGSET, tid, NT_ARM_HW_BREAK, &iov) == -1)
        {
            int err = errno;
            if (err == ESRCH)
            {
                continue;
            }
            debug_log(LOG_ERROR, "Failed to set hardware breakpoint for thread %d: %s", tid,
                      strerror(err));
            return false;
        }
#elif defined(__x86_64__)
        // x86_64: Use debug registers DR0-DR3 for breakpoints
        if (PTRACE_CALL(PTRACE_POKEUSER, tid, x86_dr_offset(index), (void*)address) ==
            -1)
        {
            int err = errno;
            if (err == ESRCH)
            {
                continue;
            }
            debug_log(LOG_ERROR, "Failed to set breakpoint address for thread %d: %s", tid,
                      strerror(err));
            return false;
        }

        // Configure DR7 for execution breakpoint
        unsigned long dr7 = PTRACE_CALL(PTRACE_PEEKUSER, tid, X86_DR7_OFFSET, nullptr);

        // Set local enable bit
        dr7 |= (1UL << (index * 2));

        // Set condition (execution) and length (1 byte for exec)
        int shift = 16 + index * 4;
        dr7 &= ~(0xFUL << shift);
        dr7 |= ((X86_DR7_BREAK_ON_EXEC | (X86_DR7_LEN_1 << 2)) << shift);

        if (PTRACE_CALL(PTRACE_POKEUSER, tid, X86_DR7_OFFSET, (void*)dr7) == -1)
        {
            int err = errno;
            if (err == ESRCH)
            {
                continue;
            }
            debug_log(LOG_ERROR, "Failed to set DR7 for thread %d: %s", tid, strerror(err));
            return false;
        }
#endif
    }

    return true;
}

// Apply breakpoint to a single thread (used when new thread is created)
bool Debugger::apply_breakpoint_to_thread(pid_t tid, int index, uint64_t address)
{
#if defined(__aarch64__)
    struct user_hwdebug_state bp_state;
    memset(&bp_state, 0, sizeof(bp_state));

    struct iovec iov = {.iov_base = &bp_state, .iov_len = 8 + 16 * MAX_BREAKPOINTS};

    if (ptrace(PTRACE_GETREGSET, tid, NT_ARM_HW_BREAK, &iov) == -1)
    {
        debug_log(LOG_ERROR, "Failed to get hardware breakpoint state for thread %d: %s", tid,
                  strerror(errno));
        return false;
    }

    bp_state.dbg_regs[index].addr = address;
    bp_state.dbg_regs[index].ctrl =
        encode_ctrl_reg(0, ARM_BREAKPOINT_LEN_4, ARM_BREAKPOINT_EXECUTE, 0, 1);

    if (ptrace(PTRACE_SETREGSET, tid, NT_ARM_HW_BREAK, &iov) == -1)
    {
        debug_log(LOG_ERROR, "Failed to set hardware breakpoint for thread %d: %s", tid,
                  strerror(errno));
        return false;
    }
#elif defined(__x86_64__)
    if (PTRACE_CALL(PTRACE_POKEUSER, tid, x86_dr_offset(index), (void*)address) == -1)
    {
        debug_log(LOG_ERROR, "Failed to set breakpoint address for thread %d: %s", tid,
                  strerror(errno));
        return false;
    }

    unsigned long dr7 = PTRACE_CALL(PTRACE_PEEKUSER, tid, X86_DR7_OFFSET, nullptr);
    dr7 |= (1UL << (index * 2));
    int shift = 16 + index * 4;
    dr7 &= ~(0xFUL << shift);
    dr7 |= ((X86_DR7_BREAK_ON_EXEC | (X86_DR7_LEN_1 << 2)) << shift);

    if (PTRACE_CALL(PTRACE_POKEUSER, tid, X86_DR7_OFFSET, (void*)dr7) == -1)
    {
        debug_log(LOG_ERROR, "Failed to set DR7 for thread %d: %s", tid, strerror(errno));
        return false;
    }
#endif

    return true;
}

bool Debugger::clear_breakpoint_from_threads(const std::vector<pid_t>& threads, int index)
{
    for (pid_t tid : threads)
    {
#if defined(__aarch64__)
        struct user_hwdebug_state bp_state;
        memset(&bp_state, 0, sizeof(bp_state));

        // Set proper iov length: 8 bytes header + 16 bytes per breakpoint * MAX_BREAKPOINTS
        struct iovec iov = {.iov_base = &bp_state, .iov_len = 8 + 16 * MAX_BREAKPOINTS};

        // Get current breakpoint state using ARM64 hardware breakpoint regset

        if (ptrace(PTRACE_GETREGSET, tid, NT_ARM_HW_BREAK, &iov) == -1)
        {
            int err = errno;
            if (err == ESRCH)
            {
                continue;
            }
            debug_log(LOG_ERROR, "Failed to get hardware breakpoint state for thread %d: %s", tid,
                      strerror(err));
            return false;
        }

        // Re-enable other breakpoints that have addresses set (they may have been disabled during
        // single-step)
        for (int i = 0; i < MAX_BREAKPOINTS; i++)
        {
            if (i != index && bp_state.dbg_regs[i].addr != 0)
            {
                bp_state.dbg_regs[i].ctrl =
                    encode_ctrl_reg(0, ARM_BREAKPOINT_LEN_4, ARM_BREAKPOINT_EXECUTE, 0, 1);
            }
        }

        // Clear the target breakpoint control register to disable
        bp_state.dbg_regs[index].ctrl = 0;
        bp_state.dbg_regs[index].addr = 0;

        // Apply the changes using ARM64 hardware breakpoint regset
        if (ptrace(PTRACE_SETREGSET, tid, NT_ARM_HW_BREAK, &iov) == -1)
        {
            int err = errno;
            if (err == ESRCH)
            {
                continue;
            }
            debug_log(LOG_ERROR, "Failed to clear hardware breakpoint for thread %d: %s", tid,
                      strerror(err));
            return false;
        }
#elif defined(__x86_64__)
        // x86_64: Clear the debug register for this breakpoint
        if (PTRACE_CALL(PTRACE_POKEUSER, tid, x86_dr_offset(index), (void*)0) == -1)
        {
            int err = errno;
            if (err == ESRCH)
            {
                continue;
            }
            debug_log(LOG_ERROR, "Failed to clear breakpoint address for thread %d: %s", tid,
                      strerror(err));
            return false;
        }

        // Clear enable bit in DR7
        unsigned long dr7 = PTRACE_CALL(PTRACE_PEEKUSER, tid, X86_DR7_OFFSET, nullptr);
        dr7 &= ~(1UL << (index * 2));  // Clear local enable bit
        // Clear condition and length bits
        int shift = 16 + index * 4;
        dr7 &= ~(0xFUL << shift);

        if (PTRACE_CALL(PTRACE_POKEUSER, tid, X86_DR7_OFFSET, (void*)dr7) == -1)
        {
            int err = errno;
            if (err == ESRCH)
            {
                continue;
            }
            debug_log(LOG_ERROR, "Failed to clear DR7 for thread %d: %s", tid, strerror(err));
            return false;
        }
#endif
    }

    return true;
}

// =============================================================================
// Software Breakpoint Continue (for callback-driven silent continue)
// =============================================================================

int Debugger::handle_software_breakpoint_continue(pid_t thread, int breakpoint_index)
{
    // Software breakpoint index is stored as >= 1000
    int actual_index = breakpoint_index - 1000;

    debug_log(LOG_INFO, "handle_software_breakpoint_continue: thread=%d, bp_index=%d, actual=%d",
              thread, breakpoint_index, actual_index);

    if (actual_index < 0 || actual_index >= MAX_SOFTWARE_BREAKPOINTS)
    {
        debug_log(LOG_ERROR, "Invalid software breakpoint index: %d", actual_index);
        return -1;
    }

    uint64_t bp_addr = 0;
    uint8_t original_bytes[4] = {0};

    {
        std::lock_guard<std::mutex> lock(software_breakpoint_mutex_);
        if (!software_breakpoint_used[actual_index])
        {
            debug_log(LOG_ERROR, "Software breakpoint %d not in use", actual_index);
            return -1;
        }
        bp_addr = software_breakpoint_addresses[actual_index];
        int offset = actual_index * 4;
        for (int j = 0; j < 4; j++)
        {
            original_bytes[j] = software_breakpoint_original_bytes[offset + j];
        }
    }

    // Step 1: Restore original instruction bytes using PTRACE_PEEKDATA/POKEDATA
    errno = 0;
    long word = ptrace(PTRACE_PEEKDATA, thread, (void*)bp_addr, nullptr);
    if (errno != 0)
    {
        debug_log(LOG_ERROR, "Failed to read memory at 0x%lx for restore: %s", bp_addr,
                  strerror(errno));
        return -1;
    }

#if defined(__aarch64__)
    // ARM64: Replace 4 bytes with original instruction
    long patched_word = (word & ~0xFFFFFFFFUL) | *reinterpret_cast<uint32_t*>(original_bytes);
#elif defined(__x86_64__)
    // x86_64: Replace 1 byte with original
    long patched_word = (word & ~0xFFUL) | original_bytes[0];
#endif

    if (ptrace(PTRACE_POKEDATA, thread, (void*)bp_addr, (void*)patched_word) == -1)
    {
        debug_log(LOG_ERROR, "Failed to restore original instruction at 0x%lx: %s", bp_addr,
                  strerror(errno));
        return -1;
    }

    // Step 2: Set up single-step to execute original instruction
    thread_states_[thread].single_step_mode = SingleStepMode::SoftwareBreakpointContinue;
    thread_states_[thread].disabled_watchpoint_index = breakpoint_index;  // Store for re-insertion
    thread_states_[thread].is_stopped = false;

    // Step 3: Single-step to execute the original instruction
    if (PTRACE_CALL(PTRACE_SINGLESTEP, thread, nullptr, nullptr) == -1)
    {
        debug_log(LOG_ERROR, "Failed to single-step thread %d: %s", thread, strerror(errno));
        return -1;
    }

    debug_log(LOG_INFO, "Software breakpoint continue: single-stepping thread %d", thread);
    return 0;
}

```

`src/server/src/cpp/src/linux/debugger/debugger_core.cpp`:

```cpp
/**
 * @file debugger_core.cpp
 * @brief Core debugger functionality - initialization, main loop, command queue
 *
 * This file contains:
 * - Constructors and destructor
 * - Initialization methods
 * - Debug message loop
 * - Command queue processing
 * - Memory read/write helpers
 */

#include "debugger_internal.h"

// =============================================================================
// Global definitions
// =============================================================================

Debugger* g_debugger = nullptr;

// Global signal configuration (persists even when debugger is not attached)
std::map<int, SignalConfig> g_signal_config;
std::mutex g_signal_config_mutex;

// =============================================================================
// Helper functions for exception info population
// =============================================================================

#if defined(__aarch64__)
void populate_exception_info(NativeExceptionInfo& info, const struct user_pt_regs& regs,
                             ExceptionType exception_type, pid_t thread_id, uint64_t memory_address,
                             uint64_t singlestep_mode, bool is_trace)
{
    memset(&info, 0, sizeof(info));

    info.architecture = ARCH_ARM64;

    // Copy general-purpose registers (x0-x29)
    for (int i = 0; i < 30; ++i)
    {
        info.regs.arm64.x[i] = regs.regs[i];
    }

    info.regs.arm64.lr = regs.regs[30];  // x30 is LR
    info.regs.arm64.sp = regs.sp;
    info.regs.arm64.pc = regs.pc;
    info.regs.arm64.cpsr = regs.pstate;
    info.regs.arm64.fp = regs.regs[29];  // x29 is FP

    info.exception_type = static_cast<uint64_t>(exception_type);
    info.thread_id = static_cast<uint64_t>(thread_id);
    info.memory_address = memory_address;
    info.singlestep_mode = singlestep_mode;
    info.is_trace = is_trace ? 1 : 0;
}

#elif defined(__x86_64__)
void populate_exception_info(NativeExceptionInfo& info, const struct user_regs_struct& regs,
                             ExceptionType exception_type, pid_t thread_id, uint64_t memory_address,
                             uint64_t singlestep_mode, bool is_trace)
{
    memset(&info, 0, sizeof(info));

    info.architecture = ARCH_X86_64;

    // Copy x86_64 registers
    info.regs.x86_64.rax = regs.rax;
    info.regs.x86_64.rbx = regs.rbx;
    info.regs.x86_64.rcx = regs.rcx;
    info.regs.x86_64.rdx = regs.rdx;
    info.regs.x86_64.rsi = regs.rsi;
    info.regs.x86_64.rdi = regs.rdi;
    info.regs.x86_64.rbp = regs.rbp;
    info.regs.x86_64.rsp = regs.rsp;
    info.regs.x86_64.r8 = regs.r8;
    info.regs.x86_64.r9 = regs.r9;
    info.regs.x86_64.r10 = regs.r10;
    info.regs.x86_64.r11 = regs.r11;
    info.regs.x86_64.r12 = regs.r12;
    info.regs.x86_64.r13 = regs.r13;
    info.regs.x86_64.r14 = regs.r14;
    info.regs.x86_64.r15 = regs.r15;
    info.regs.x86_64.rip = regs.rip;
    info.regs.x86_64.rflags = regs.eflags;
    info.regs.x86_64.cs = regs.cs;
    info.regs.x86_64.ss = regs.ss;
    info.regs.x86_64.ds = regs.ds;
    info.regs.x86_64.es = regs.es;
    info.regs.x86_64.fs = regs.fs;
    info.regs.x86_64.gs = regs.gs;
    info.regs.x86_64.fs_base = regs.fs_base;
    info.regs.x86_64.gs_base = regs.gs_base;

    info.exception_type = static_cast<uint64_t>(exception_type);
    info.thread_id = static_cast<uint64_t>(thread_id);
    info.memory_address = memory_address;
    info.singlestep_mode = singlestep_mode;
    info.is_trace = is_trace ? 1 : 0;
}
#endif

// =============================================================================
// Memory access helpers using ptrace
// =============================================================================

uint64_t read_memory_word(pid_t pid, uint64_t address)
{
    errno = 0;
    long data = PTRACE_CALL(PTRACE_PEEKDATA, pid, (void*)address, nullptr);
    if (errno != 0)
    {
        return 0;
    }
    return (uint64_t)data;
}

int write_memory_word(pid_t pid, uint64_t address, uint64_t data)
{
    if (PTRACE_CALL(PTRACE_POKEDATA, pid, (void*)address, (void*)data) == -1)
    {
        debug_log(LOG_ERROR, "Failed to write memory at 0x%lx: %s", address, strerror(errno));
        return -1;
    }
    return 0;
}

// =============================================================================
// Constructors and Destructor
// =============================================================================

Debugger::Debugger()
    : pid_(0),
      debug_loop_running_(false),
      watchpoint_used(MAX_WATCHPOINTS, false),
      watchpoint_addresses(MAX_WATCHPOINTS, 0),
      watchpoint_sizes(MAX_WATCHPOINTS, 0),
      watchpoint_types(MAX_WATCHPOINTS, WatchpointType::READWRITE),
      breakpoint_used(MAX_BREAKPOINTS, false),
      breakpoint_addresses(MAX_BREAKPOINTS, 0),
      breakpoint_hit_counts(MAX_BREAKPOINTS, 0),
      breakpoint_target_counts(MAX_BREAKPOINTS, 0),
      breakpoint_types(MAX_BREAKPOINTS, BreakpointType::HARDWARE),
      software_breakpoint_used(MAX_SOFTWARE_BREAKPOINTS, false),
      software_breakpoint_addresses(MAX_SOFTWARE_BREAKPOINTS, 0),
      software_breakpoint_original_bytes(MAX_SOFTWARE_BREAKPOINTS * 4, 0)
{
}

Debugger::Debugger(pid_t pid)
    : pid_(pid),
      debug_loop_running_(false),
      watchpoint_used(MAX_WATCHPOINTS, false),
      watchpoint_addresses(MAX_WATCHPOINTS, 0),
      watchpoint_sizes(MAX_WATCHPOINTS, 0),
      watchpoint_types(MAX_WATCHPOINTS, WatchpointType::READWRITE),
      breakpoint_used(MAX_BREAKPOINTS, false),
      breakpoint_addresses(MAX_BREAKPOINTS, 0),
      breakpoint_hit_counts(MAX_BREAKPOINTS, 0),
      breakpoint_target_counts(MAX_BREAKPOINTS, 0),
      breakpoint_types(MAX_BREAKPOINTS, BreakpointType::HARDWARE),
      software_breakpoint_used(MAX_SOFTWARE_BREAKPOINTS, false),
      software_breakpoint_addresses(MAX_SOFTWARE_BREAKPOINTS, 0),
      software_breakpoint_original_bytes(MAX_SOFTWARE_BREAKPOINTS * 4, 0)
{
}

Debugger::~Debugger()
{
    debug_loop_running_ = false;
    if (debug_thread_.joinable())
    {
        debug_thread_.join();
    }

    // Detach from all threads
    for (pid_t tid : attached_threads_)
    {
        PTRACE_CALL(PTRACE_DETACH, tid, nullptr, nullptr);
    }
}

// =============================================================================
// Initialization
// =============================================================================

bool Debugger::initialize()
{
    return true;
}

bool Debugger::initialize_for_spawn()
{
    attached_threads_.insert(pid_);
    thread_states_[pid_].is_attached = true;
    thread_states_[pid_].is_stopped = true;
    thread_states_[pid_].current_breakpoint_index = -1;
    thread_states_[pid_].single_step_mode = SingleStepMode::None;
    threads_attached_ = true;

    current_thread = pid_;
    debug_state_ = DebugState::Paused;

    return true;
}

void Debugger::run()
{
    debug_loop_running_ = true;
    debug_thread_ = std::thread(&Debugger::debug_message_loop, this);
}

// =============================================================================
// Debug State
// =============================================================================

DebugState Debugger::get_debug_state() const
{
    return debug_state_;
}

bool Debugger::is_in_break_state() const
{
    return debug_state_ == DebugState::BreakpointHit || debug_state_ == DebugState::WatchpointHit;
}

// =============================================================================
// Signal Configuration
// =============================================================================

void Debugger::set_signal_config(int signal, const SignalConfig& config)
{
    std::lock_guard<std::mutex> lock(signal_config_mutex_);
    signal_config_[signal] = config;
    debug_log(LOG_INFO, "Set signal %d (%s) config: catch=%d, pass=%d", signal, strsignal(signal),
              config.catch_signal, config.pass_signal);
}

SignalConfig Debugger::get_signal_config(int signal) const
{
    std::lock_guard<std::mutex> lock(signal_config_mutex_);
    auto it = signal_config_.find(signal);
    if (it != signal_config_.end())
    {
        return it->second;
    }
    return SignalConfig(false, false);
}

std::map<int, SignalConfig> Debugger::get_all_signal_configs() const
{
    std::lock_guard<std::mutex> lock(signal_config_mutex_);
    return signal_config_;
}

void Debugger::set_all_signal_configs(const std::map<int, SignalConfig>& configs)
{
    std::lock_guard<std::mutex> lock(signal_config_mutex_);
    signal_config_ = configs;
    debug_log(LOG_INFO, "Set %zu signal configs", configs.size());
}

void Debugger::remove_signal_config(int signal)
{
    std::lock_guard<std::mutex> lock(signal_config_mutex_);
    signal_config_.erase(signal);
    debug_log(LOG_INFO, "Removed signal %d (%s) config", signal, strsignal(signal));
}

// =============================================================================
// Command Queue
// =============================================================================

void Debugger::enqueue_command(std::shared_ptr<DebugRequest> request)
{
    std::lock_guard<std::mutex> lock(queue_mutex_);
    debug_command_queue_.push(request);
    queue_cv_.notify_one();
}

void Debugger::process_command_queue()
{
    std::unique_lock<std::mutex> lock(queue_mutex_);

    while (!debug_command_queue_.empty())
    {
        auto request = debug_command_queue_.front();
        debug_command_queue_.pop();
        lock.unlock();

        int result = -1;
        switch (request->command)
        {
            case DebugCommand::SetWatchpoint:
                result = process_set_watchpoint_command(request);
                break;
            case DebugCommand::RemoveWatchpoint:
                result = process_remove_watchpoint_command(request);
                break;
            case DebugCommand::SetBreakpoint:
                result = process_set_breakpoint_command(request);
                break;
            case DebugCommand::RemoveBreakpoint:
                result = process_remove_breakpoint_command(request);
                break;
            case DebugCommand::ContinueExecution:
                result = process_continue_execution_command(request);
                break;
            case DebugCommand::SingleStep:
                result = process_single_step_command(request);
                break;
            case DebugCommand::ReapplyWatchpoints:
                result = process_reapply_watchpoints_command(request);
                break;
            case DebugCommand::ReadRegister:
                result = process_read_register_command(request);
                break;
            case DebugCommand::WriteRegister:
                result = process_write_register_command(request);
                break;
            case DebugCommand::ReadMemory:
                result = process_read_memory_command(request);
                break;
            case DebugCommand::SpawnProcess:
                result = process_spawn_command(request);
                break;
            case DebugCommand::SpawnProcessWithPty:
                result = process_spawn_with_pty_command(request);
                break;
            case DebugCommand::ResumeUserStoppedThreads:
                result = resume_all_user_stopped_threads_internal();
                break;
            default:
                debug_log(LOG_ERROR, "Unknown debug command: %d",
                          static_cast<int>(request->command));
                break;
        }

        {
            std::lock_guard<std::mutex> result_lock(request->result_mutex);
            request->result = result;
            request->completed = true;
        }
        request->result_cv.notify_one();

        lock.lock();
    }
}

int Debugger::process_set_watchpoint_command(std::shared_ptr<DebugRequest> request)
{
    return set_watchpoint_internal(request->address, request->size, request->watchpoint_type);
}

int Debugger::process_remove_watchpoint_command(std::shared_ptr<DebugRequest> request)
{
    return remove_watchpoint_internal(request->address);
}

int Debugger::process_set_breakpoint_command(std::shared_ptr<DebugRequest> request)
{
    return set_breakpoint_internal(request->address, request->hit_count, request->breakpoint_type);
}

int Debugger::process_remove_breakpoint_command(std::shared_ptr<DebugRequest> request)
{
    return remove_breakpoint_internal(request->address);
}

int Debugger::process_continue_execution_command(std::shared_ptr<DebugRequest> request)
{
    return continue_execution_internal(request->thread_id);
}

int Debugger::process_single_step_command(std::shared_ptr<DebugRequest> request)
{
    return single_step_internal(request->thread_id);
}

int Debugger::process_reapply_watchpoints_command(std::shared_ptr<DebugRequest> request)
{
    return reapply_all_watchpoints_internal(request->thread_id);
}

int Debugger::process_read_register_command(std::shared_ptr<DebugRequest> request)
{
    return read_register_internal(request->thread_id, request->reg_name, request->reg_value_ptr);
}

int Debugger::process_write_register_command(std::shared_ptr<DebugRequest> request)
{
    return write_register_internal(request->thread_id, request->reg_name, request->reg_value);
}

int Debugger::process_read_memory_command(std::shared_ptr<DebugRequest> request)
{
    request->memory_bytes_read =
        read_memory_internal(request->address, request->memory_size, request->memory_buffer);
    return (request->memory_bytes_read > 0) ? 0 : -1;
}

int Debugger::process_spawn_command(std::shared_ptr<DebugRequest> request)
{
    return spawn_process_internal(request);
}

int Debugger::process_spawn_with_pty_command(std::shared_ptr<DebugRequest> request)
{
    return spawn_process_with_pty_internal(request);
}

```

`src/server/src/cpp/src/linux/debugger/debugger_exception.cpp`:

```cpp
/**
 * @file debugger_exception.cpp
 * @brief Exception handling and single-step related Debugger class member functions
 *
 * This file contains the implementation of exception handling, execution control,
 * and single-step functionality for the Linux debugger.
 *
 * Functions included:
 *   - handle_exception: Main exception handling function for ptrace events
 *   - continue_execution: Public API for resuming thread execution
 *   - continue_execution_internal: Internal implementation of continue
 *   - single_step: Public API for single-stepping a thread
 *   - single_step_internal: Internal implementation of single step
 *   - handle_single_step: Dispatcher for single step completion handling
 *   - complete_watchpoint_single_step: Completes watchpoint single step sequence
 *   - continue_breakpoint_single_step: Handles breakpoint single step continuation
 */

#include "debugger_internal.h"

int Debugger::handle_exception(pid_t pid, int status)
{
    if (WIFSTOPPED(status))
    {
        // Check for PTRACE_EVENT_CLONE (new thread created)
        if ((status >> 16) == PTRACE_EVENT_CLONE)
        {
            // Get the new thread's tid
            unsigned long new_tid = 0;
            if (PTRACE_CALL(PTRACE_GETEVENTMSG, pid, nullptr, &new_tid) == 0 && new_tid > 0)
            {
                // Register the new thread - it's automatically attached due to PTRACE_O_TRACECLONE
                // The new thread inherits the ptrace options from the parent
                // The new thread's first stop event (SIGSTOP) will be handled by the main waitpid
                // loop
                pid_t new_thread = static_cast<pid_t>(new_tid);
                attached_threads_.insert(new_thread);
                thread_states_[new_thread].is_attached = true;
            }
            else
            {
                debug_log(LOG_ERROR, "Failed to get new thread id from PTRACE_EVENT_CLONE: %s",
                          strerror(errno));
            }

            // Resume the parent thread that triggered the clone event
            if (PTRACE_CALL(PTRACE_CONT, pid, nullptr, nullptr) == -1)
            {
                debug_log(LOG_ERROR, "Failed to resume thread %d after PTRACE_EVENT_CLONE: %s", pid,
                          strerror(errno));
            }
            return 0;
        }

        // Check for PTRACE_EVENT_STOP (PTRACE_INTERRUPT induced stop)
        if ((status >> 16) == PTRACE_EVENT_STOP)
        {
            // This is a PTRACE_INTERRUPT induced stop
            // Resume the thread immediately - it was likely a late event from a completed operation
            if (PTRACE_CALL(PTRACE_CONT, pid, nullptr, nullptr) == -1)
            {
                debug_log(LOG_ERROR, "Failed to resume thread %d after PTRACE_EVENT_STOP: %s", pid,
                          strerror(errno));
            }
            return 0;
        }

        int signal = WSTOPSIG(status);

        switch (signal)
        {
            case SIGTRAP:
            {
                // Get register state
#if defined(__aarch64__)
                struct iovec iov;
                struct user_pt_regs regs;
                iov.iov_base = &regs;
                iov.iov_len = sizeof(regs);
                if (PTRACE_CALL(DYNA_PTRACE_GETREGSET, pid, NT_PRSTATUS, &iov) == -1)
#elif defined(__x86_64__)
                struct user_regs_struct regs;
                if (PTRACE_CALL(PTRACE_GETREGS, pid, nullptr, &regs) == -1)
#endif
                {
#if defined(__aarch64__)
                    // Test if hardware debug registers are accessible using ARM64 hardware
                    // breakpoint regset
                    struct user_hwdebug_state test_hw_state;
                    memset(&test_hw_state, 0, sizeof(test_hw_state));
                    struct iovec iov;
                    iov.iov_base = &test_hw_state;
                    iov.iov_len = sizeof(test_hw_state);
                    if (ptrace(PTRACE_GETREGSET, pid, NT_ARM_HW_BREAK, &iov) == 0)
                    {
                    }
                    else
                    {
                    }
#endif

                    // This is likely a PTRACE_INTERRUPT induced SIGTRAP
                    // The thread is stopped but register access might be temporarily unavailable
                    return 0;  // Don't continue, leave stopped for register access
                }

                // Check for single step completion first
                auto thread_it = thread_states_.find(pid);
                if (thread_it != thread_states_.end() &&
                    thread_it->second.single_step_mode != SingleStepMode::None)
                {
                    // Send exception info for single step using NativeExceptionInfo
                    NativeExceptionInfo exception_info;
                    populate_exception_info(
                        exception_info, regs, EXCEPTION_SINGLESTEP, pid, 0,
                        static_cast<uint64_t>(thread_it->second.single_step_mode));

                    // Check if this is a trace exception (target_count > 0)
                    int bp_index = thread_it->second.current_breakpoint_index;
                    if (bp_index >= 0 && bp_index < MAX_BREAKPOINTS)
                    {
                        std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
                        int target_count = breakpoint_target_counts[bp_index];
                        exception_info.is_trace = (target_count > 0) ? 1 : 0;
                    }
                    else
                    {
                        exception_info.is_trace = 0;
                    }

                    SEND_EXCEPTION_INFO(&exception_info, pid_);

                    return handle_single_step(pid);
                }

                // Get signal info to determine fault address for watchpoint detection
                siginfo_t siginfo;
                memset(&siginfo, 0, sizeof(siginfo));
                uint64_t fault_address = 0;
                bool has_fault_address = false;

                if (PTRACE_CALL(PTRACE_GETSIGINFO, pid, nullptr, &siginfo) == 0)
                {
                    // si_addr contains the fault address for hardware watchpoint/breakpoint
                    fault_address = reinterpret_cast<uint64_t>(siginfo.si_addr);
                    has_fault_address = true;
                }

                // Check if it's a watchpoint hit by examining fault address
                bool watchpoint_hit = false;
                int wp_index = -1;

#if defined(__x86_64__)
                // x86_64: Read DR6 to determine which watchpoint was hit
                // DR6 bits 0-3 indicate which watchpoint (DR0-DR3) triggered
                (void)has_fault_address;  // Unused on x86_64, suppress warning
                errno = 0;                // Clear errno before PTRACE_PEEKUSER
                unsigned long dr6 =
                    PTRACE_CALL(PTRACE_PEEKUSER, pid, X86_DR6_OFFSET, nullptr);
                if (errno == 0)
                {
                    std::lock_guard<std::mutex> lock(watchpoint_data_mutex_);
                    for (int i = 0; i < MAX_WATCHPOINTS; i++)
                    {
                        if ((dr6 & (1UL << i)) && watchpoint_used[i])
                        {
                            wp_index = i;
                            watchpoint_hit = true;
                            fault_address = watchpoint_addresses[i];
                            break;
                        }
                    }

                    // Clear DR6 after reading to prepare for next watchpoint
                    if (watchpoint_hit)
                    {
                        PTRACE_CALL(PTRACE_POKEUSER, pid, X86_DR6_OFFSET, (void*)0);
                    }
                }
#elif defined(__aarch64__)
                if (has_fault_address && fault_address != 0)
                {
                    // Check which watchpoint matches the fault address
                    std::lock_guard<std::mutex> lock(watchpoint_data_mutex_);
                    for (int i = 0; i < MAX_WATCHPOINTS; i++)
                    {
                        if (watchpoint_used[i])
                        {
                            uint64_t wp_start = watchpoint_addresses[i];
                            uint64_t wp_end = wp_start + watchpoint_sizes[i];

                            // Check if fault address falls within the watchpoint range
                            if (fault_address >= wp_start && fault_address < wp_end)
                            {
                                wp_index = i;
                                watchpoint_hit = true;
                                break;
                            }
                        }
                    }

                    // If no exact match found, check with aligned addresses
                    // Hardware watchpoints may report aligned addresses
                    if (!watchpoint_hit)
                    {
                        uint64_t aligned_fault = fault_address & ~0x7ULL;  // 8-byte alignment
                        for (int i = 0; i < MAX_WATCHPOINTS; i++)
                        {
                            if (watchpoint_used[i])
                            {
                                uint64_t wp_aligned = watchpoint_addresses[i] & ~0x7ULL;
                                if (aligned_fault == wp_aligned)
                                {
                                    wp_index = i;
                                    watchpoint_hit = true;
                                    break;
                                }
                            }
                        }
                    }
                }
#endif

                if (watchpoint_hit && wp_index != -1)
                {
                    debug_state_ = DebugState::WatchpointHit;
                    current_thread = pid;

                    // Store thread state
                    thread_states_[pid].regs = regs;
                    thread_states_[pid].current_breakpoint_index = -1;
                    thread_states_[pid].is_stopped = true;  // Mark as stopped

                    // Send exception info for watchpoint hit using NativeExceptionInfo
                    NativeExceptionInfo exception_info;
                    populate_exception_info(exception_info, regs, EXCEPTION_WATCHPOINT, pid,
                                            watchpoint_addresses[wp_index]);
                    SEND_EXCEPTION_INFO(&exception_info, pid_);

                    return handle_watchpoint_hit(pid, wp_index);
                }

                // Check if it's a breakpoint hit
#if defined(__aarch64__)
                uint64_t pc = regs.pc;
#elif defined(__x86_64__)
                uint64_t pc = regs.rip;
#endif
                int bp_index = find_breakpoint_index(pc);

                if (bp_index != -1)
                {
                    // Get target_count to determine if trace mode
                    // Software breakpoints (bp_index >= 1000) don't have target counts, so skip
                    int target_count = 0;
                    bool is_software_bp = (bp_index >= 1000);
                    int actual_index = is_software_bp ? (bp_index - 1000) : bp_index;

#if defined(__x86_64__)
                    // On x86_64, when INT3 is executed, RIP points past the INT3 instruction
                    // We need to set RIP back to the breakpoint address
                    if (is_software_bp)
                    {
                        std::lock_guard<std::mutex> lock(software_breakpoint_mutex_);
                        if (actual_index >= 0 && actual_index < MAX_SOFTWARE_BREAKPOINTS &&
                            software_breakpoint_used[actual_index])
                        {
                            uint64_t bp_addr = software_breakpoint_addresses[actual_index];
                            if (regs.rip != bp_addr)
                            {
                                debug_log(LOG_INFO,
                                          "Adjusting RIP from 0x%lx to breakpoint address 0x%lx",
                                          regs.rip, bp_addr);
                                regs.rip = bp_addr;
                                pc = bp_addr;
                                if (PTRACE_CALL(PTRACE_SETREGS, pid, nullptr, &regs) == -1)
                                {
                                    debug_log(LOG_ERROR, "Failed to adjust RIP: %s",
                                              strerror(errno));
                                }
                            }
                        }
                    }
#endif

                    if (!is_software_bp && actual_index >= 0 && actual_index < MAX_BREAKPOINTS)
                    {
                        std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
                        target_count = breakpoint_target_counts[actual_index];
                        breakpoint_hit_counts[actual_index]++;
                    }

                    debug_log(
                        LOG_DEBUG,
                        "Breakpoint hit at PC 0x%lx, bp_index=%d (software=%d, actual_index=%d)",
                        pc, bp_index, is_software_bp ? 1 : 0, actual_index);

                    debug_state_ = DebugState::BreakpointHit;
                    current_thread = pid;

                    // Store thread state
                    // For software breakpoints, store negative index to indicate software
                    thread_states_[pid].regs = regs;
                    thread_states_[pid].current_breakpoint_index =
                        is_software_bp ? -1 : actual_index;
                    thread_states_[pid].is_stopped = true;  // Mark as stopped

                    // For software breakpoints, store the software bp index for single-step
                    // handling
                    if (is_software_bp)
                    {
                        thread_states_[pid].disabled_watchpoint_index =
                            bp_index;  // Store full index (>= 1000)
                    }

                    // Send exception info for breakpoint hit using NativeExceptionInfo
                    // The return value indicates whether to notify UI and break (true)
                    // or to silently continue execution (false)
                    NativeExceptionInfo exception_info;
                    populate_exception_info(exception_info, regs, EXCEPTION_BREAKPOINT, pid);
                    exception_info.is_trace = (target_count > 0) ? 1 : 0;

                    bool should_break = SEND_EXCEPTION_INFO(&exception_info, pid_);

                    if (!should_break)
                    {
                        // Callback returned CONTINUE - silently continue execution
                        debug_log(LOG_INFO,
                                  "Breakpoint callback returned CONTINUE, resuming thread %d", pid);
                        thread_states_[pid].is_stopped = false;

                        // For software breakpoints, need to restore original instruction, step,
                        // then re-insert
                        if (is_software_bp)
                        {
                            return handle_software_breakpoint_continue(pid, bp_index);
                        }
                        else
                        {
                            // Hardware breakpoint - just continue
                            if (PTRACE_CALL(PTRACE_CONT, pid, nullptr, nullptr) == -1)
                            {
                                debug_log(LOG_ERROR,
                                          "Failed to continue thread %d after callback: %s", pid,
                                          strerror(errno));
                                return -1;
                            }
                            return 0;
                        }
                    }

                    return handle_breakpoint_hit(pid, bp_index);
                }
                else
                {
                    // For PTRACE_INTERRUPT induced SIGTRAP, leave the thread stopped
                    return 0;  // Don't continue, leave stopped
                }
                break;
            }

            case SIGSTOP:
            case SIGTSTP:
            {
                // Check if this SIGSTOP is from user API (suspend_process)
                // Use load() instead of exchange() - we don't consume the flag here
                // The flag will be cleared when resume_process is called
                bool is_user_suspend = user_suspend_pending_.load();

                if (is_user_suspend)
                {
                    // Mark this thread as stopped by user
                    thread_states_[pid].is_stopped = true;
                    thread_states_[pid].stopped_by_user = true;

                    kill(pid, SIGSTOP);  // Pass SIGSTOP to actually stop the thread
                }
                else
                {
                    thread_states_[pid].is_stopped = true;
                    // Don't set stopped_by_user for non-user SIGSTOPs (e.g., from thread creation)
                    // Don't continue automatically - leave stopped for hardware register access
                }
                return 0;
            }

            case SIGCONT:
            {
                // SIGCONT is received when resume_process is called
                // Only resume if the thread was previously stopped by user (SIGSTOP)
                auto it = thread_states_.find(pid);
                if (it != thread_states_.end() && it->second.stopped_by_user)
                {
                    it->second.stopped_by_user = false;
                    it->second.is_stopped = false;
                    // Pass SIGCONT to actually resume the process
                    if (kill(pid, SIGCONT) == -1)
                    {
                        debug_log(LOG_ERROR, "Failed to continue thread %d with SIGCONT: %s", pid,
                                  strerror(errno));
                        return -1;
                    }
                }
                else
                {
                    // Not stopped by user, just pass the signal through
                    if (kill(pid, SIGCONT) == -1)
                    {
                        debug_log(LOG_ERROR, "Failed to continue thread %d with SIGCONT: %s", pid,
                                  strerror(errno));
                        return -1;
                    }
                }
                return 0;
            }

            default:
            {
                // Get signal configuration (catch/pass settings)
                SignalConfig config = get_signal_config(signal);

                // Skip logging for common signals that are frequently received
                // SIGPWR=30 (Power failure), SIGXCPU=24 (CPU time limit exceeded)
                // These are typically used for internal system purposes
                if (signal != 30 && signal != 24)
                {
                    debug_log(LOG_INFO, "handle_exception: signal %d (%s), catch=%d, pass=%d",
                              signal, strsignal(signal), config.catch_signal, config.pass_signal);
                }

                // Determine what to do based on catch/pass configuration:
                // - catch=true, pass=true: Stop, notify UI, deliver signal on continue
                // - catch=true, pass=false: Stop, notify UI, suppress signal on continue
                // - catch=false, pass=true: Don't stop, deliver signal immediately
                // - catch=false, pass=false: Don't stop, suppress signal (silent ignore)

                if (config.catch_signal)
                {
                    // Catch mode: Get register state for exception info
#if defined(__aarch64__)
                    struct iovec sig_iov;
                    struct user_pt_regs sig_regs;
                    sig_iov.iov_base = &sig_regs;
                    sig_iov.iov_len = sizeof(sig_regs);
                    if (PTRACE_CALL(DYNA_PTRACE_GETREGSET, pid, NT_PRSTATUS, &sig_iov) == 0)
#elif defined(__x86_64__)
                    struct user_regs_struct sig_regs;
                    if (PTRACE_CALL(PTRACE_GETREGS, pid, nullptr, &sig_regs) == 0)
#endif
                    {
                        // Log register values for debugging
#if defined(__x86_64__)
                        debug_log(LOG_INFO,
                                  "Signal %d: registers read - rip=0x%lx, rsp=0x%lx, rax=0x%lx, "
                                  "rbx=0x%lx",
                                  signal, sig_regs.rip, sig_regs.rsp, sig_regs.rax, sig_regs.rbx);
#elif defined(__aarch64__)
                        debug_log(
                            LOG_INFO,
                            "Signal %d: registers read - pc=0x%lx, sp=0x%lx, x0=0x%lx, x1=0x%lx",
                            signal, sig_regs.pc, sig_regs.sp, sig_regs.regs[0], sig_regs.regs[1]);
#endif
                        // Determine exception type based on signal
                        ExceptionType exc_type = EXCEPTION_SIGNAL;
                        switch (signal)
                        {
                            case SIGSEGV:
                                exc_type = EXCEPTION_SIGSEGV;
                                break;
                            case SIGBUS:
                                exc_type = EXCEPTION_SIGBUS;
                                break;
                            case SIGFPE:
                                exc_type = EXCEPTION_SIGFPE;
                                break;
                            case SIGILL:
                                exc_type = EXCEPTION_SIGILL;
                                break;
                            case SIGABRT:
                                exc_type = EXCEPTION_SIGABRT;
                                break;
                            default:
                                exc_type = EXCEPTION_SIGNAL;
                                break;
                        }

                        // Get fault address from siginfo
                        siginfo_t sig_siginfo;
                        memset(&sig_siginfo, 0, sizeof(sig_siginfo));
                        uint64_t fault_addr = 0;
                        if (PTRACE_CALL(PTRACE_GETSIGINFO, pid, nullptr, &sig_siginfo) == 0)
                        {
                            fault_addr = reinterpret_cast<uint64_t>(sig_siginfo.si_addr);
                        }

                        debug_state_ = DebugState::Paused;
                        current_thread = pid;

                        // Store thread state, including pending signal for continue
                        thread_states_[pid].regs = sig_regs;
                        thread_states_[pid].current_breakpoint_index = -1;
                        thread_states_[pid].is_stopped = true;
                        // Store the signal to potentially deliver on continue
                        thread_states_[pid].pending_signal = config.pass_signal ? signal : 0;

                        // Send exception info for signal
                        NativeExceptionInfo exception_info;
                        populate_exception_info(exception_info, sig_regs, exc_type, pid,
                                                fault_addr);
                        exception_info.is_trace = 0;
                        SEND_EXCEPTION_INFO(&exception_info, pid_);

                        debug_log(
                            LOG_INFO, "Signal %d (%s) caught at thread %d (pass=%s), notifying UI",
                            signal, strsignal(signal), pid, config.pass_signal ? "true" : "false");

                        // Leave thread stopped for user to inspect
                        return 0;
                    }
                    else
                    {
                        // PTRACE_GETREGS failed - log error but still try to handle
                        debug_log(LOG_ERROR,
                                  "Failed to get registers for signal %d in thread %d: %s", signal,
                                  pid, strerror(errno));
                    }
                }

                // Not catching: continue immediately
                // Determine signal to pass (0 = suppress, signal = pass)
                // Always pass SIGPWR(30) and SIGXCPU(24) - these are system signals
                int signal_to_pass =
                    (config.pass_signal || signal == 30 || signal == 24) ? signal : 0;

                // Mark thread as running before continuing
                auto thread_it = thread_states_.find(pid);
                if (thread_it != thread_states_.end())
                {
                    thread_it->second.is_stopped = false;
                }

                // If thread was in single step mode, use PTRACE_SINGLESTEP to preserve the step
                // Otherwise the single step would be cancelled
                bool use_single_step = false;
                if (thread_it != thread_states_.end() &&
                    thread_it->second.single_step_mode != SingleStepMode::None)
                {
                    use_single_step = true;
                    debug_log(
                        LOG_INFO,
                        "Thread %d in single step mode, using PTRACE_SINGLESTEP for signal %d", pid,
                        signal);
                }

                // Continue execution (pass or suppress the signal)
                int continue_req = use_single_step ? PTRACE_SINGLESTEP : PTRACE_CONT;
                if (PTRACE_CALL(continue_req, pid, nullptr, (void*)(long)signal_to_pass) == -1)
                {
                    debug_log(LOG_ERROR, "Failed to continue thread %d with signal %d: %s", pid,
                              signal_to_pass, strerror(errno));
                    // Restore stopped state on failure
                    if (thread_it != thread_states_.end())
                    {
                        thread_it->second.is_stopped = true;
                    }
                    return -1;
                }
                return 0;
            }
        }

        // All signals during hardware register access should leave threads stopped
        // Manual continuation will be done after register operations complete
    }
    else if (WIFEXITED(status))
    {
        attached_threads_.erase(pid);
        thread_states_.erase(pid);
    }

    return 0;
}

int Debugger::continue_execution(pid_t thread_id)
{
    // Create request and enqueue it to the debug thread
    auto request = std::make_shared<DebugRequest>(DebugCommand::ContinueExecution);
    request->thread_id = thread_id;

    enqueue_command(request);

    // Wait for the result
    std::unique_lock<std::mutex> lock(request->result_mutex);
    request->result_cv.wait(lock, [request] { return request->completed; });

    return request->result;
}

int Debugger::continue_execution_internal(pid_t thread_id)
{
    auto thread_it = thread_states_.find(thread_id);
    if (thread_it == thread_states_.end())
    {
        // If debug state is already Running, thread was likely already resumed
        // This can happen when multiple threads are continued in a batch
        if (debug_state_ == DebugState::Running)
        {
            return 0;
        }
        debug_log(LOG_ERROR, "Thread %d not found in break state", thread_id);
        return -1;
    }

    // Check if thread is actually stopped (like darwin)
    if (!thread_it->second.is_stopped)
    {
        return -1;
    }

    if (attached_threads_.count(thread_id) == 0)
    {
        debug_log(LOG_ERROR, "Thread %d is not attached", thread_id);
        return -1;
    }

    // Check if we're at a software breakpoint - if so, we need to single step over it first
    int sw_bp_index = thread_it->second.disabled_watchpoint_index;
    if (sw_bp_index >= 1000)
    {
        int actual_sw_index = sw_bp_index - 1000;
        debug_log(LOG_INFO,
                  "Continuing from software breakpoint (index %d), need to single step first",
                  actual_sw_index);

        // Get current PC
        uint64_t current_pc = 0;
#if defined(__aarch64__)
        current_pc = thread_it->second.regs.pc;
#elif defined(__x86_64__)
        current_pc = thread_it->second.regs.rip;
#endif

        // Temporarily restore the original instruction
        {
            std::lock_guard<std::mutex> lock(software_breakpoint_mutex_);
            if (actual_sw_index >= 0 && actual_sw_index < MAX_SOFTWARE_BREAKPOINTS &&
                software_breakpoint_used[actual_sw_index])
            {
                uint64_t bp_addr = software_breakpoint_addresses[actual_sw_index];
                if (bp_addr == current_pc)
                {
                    // Read current memory word
                    errno = 0;
                    long word = ptrace(PTRACE_PEEKDATA, pid_, (void*)current_pc, nullptr);
                    if (errno == 0)
                    {
                        // Get original bytes
                        uint8_t original_bytes[4] = {0};
                        size_t offset = actual_sw_index * 4;
#if defined(__aarch64__)
                        const size_t bp_size = 4;
#elif defined(__x86_64__)
                        const size_t bp_size = 1;
#endif
                        for (size_t j = 0; j < bp_size; j++)
                        {
                            original_bytes[j] = software_breakpoint_original_bytes[offset + j];
                        }

                        // Restore original instruction
#if defined(__aarch64__)
                        uint32_t original_instruction;
                        memcpy(&original_instruction, original_bytes, 4);
                        long restored_word = (word & ~0xFFFFFFFFUL) | original_instruction;
#elif defined(__x86_64__)
                        long restored_word = (word & ~0xFFUL) | original_bytes[0];
#endif
                        if (ptrace(PTRACE_POKEDATA, pid_, (void*)current_pc,
                                   (void*)restored_word) == 0)
                        {
                            debug_log(
                                LOG_INFO,
                                "Temporarily restored original instruction at 0x%lx for continue",
                                current_pc);
                        }
                    }
                }
            }
        }

        // Set up single step mode to re-insert breakpoint after step and continue
        thread_it->second.single_step_mode = SingleStepMode::SoftwareBreakpointContinue;
        thread_it->second.single_step_count = 0;
        thread_it->second.is_stopped = false;
        thread_it->second.stopped_by_user = false;  // Clear user suspend flag on continue

        // Single step first
        int signal_to_pass = thread_it->second.pending_signal;
        thread_it->second.pending_signal = 0;

        debug_state_ = DebugState::SingleStepping;

        if (PTRACE_CALL(PTRACE_SINGLESTEP, thread_id, nullptr, (void*)(long)signal_to_pass) == -1)
        {
            debug_log(LOG_ERROR, "Failed to single step thread %d from software breakpoint: %s",
                      thread_id, strerror(errno));
            return -1;
        }

        return 0;
    }

    // Resume only this specific thread (consistent with darwin behavior)
    int signal_to_pass = thread_it->second.pending_signal;
    thread_it->second.pending_signal = 0;  // Clear after use

    if (PTRACE_CALL(PTRACE_CONT, thread_id, nullptr, (void*)(long)signal_to_pass) == -1)
    {
        debug_log(LOG_ERROR, "Failed to resume thread %d: %s", thread_id, strerror(errno));
        return -1;
    }

    // Mark thread as running (consistent with darwin)
    thread_it->second.is_stopped = false;
    thread_it->second.stopped_by_user = false;  // Clear user suspend flag on continue

    if (signal_to_pass != 0)
    {
        debug_log(LOG_INFO, "Thread %d resumed with signal %d (%s)", thread_id, signal_to_pass,
                  strsignal(signal_to_pass));
    }

    // If this was the current thread, check if any other threads are still stopped
    if (current_thread == thread_id)
    {
        bool any_stopped = false;
        for (const auto& state_pair : thread_states_)
        {
            if (state_pair.second.is_stopped)
            {
                any_stopped = true;
                break;
            }
        }

        // Only reset global state if no other threads are stopped
        if (!any_stopped)
        {
            debug_state_ = DebugState::Running;
            current_thread = 0;
        }
    }

    return 0;
}

int Debugger::single_step(pid_t thread_id)
{
    // Create request and enqueue it to the debug thread
    auto request = std::make_shared<DebugRequest>(DebugCommand::SingleStep);
    request->thread_id = thread_id;

    enqueue_command(request);

    // Wait for the result
    std::unique_lock<std::mutex> lock(request->result_mutex);
    request->result_cv.wait(lock, [request] { return request->completed; });

    return request->result;
}

int Debugger::single_step_internal(pid_t thread_id)
{
    auto thread_it = thread_states_.find(thread_id);
    if (thread_it == thread_states_.end())
    {
        debug_log(LOG_ERROR, "Thread %d not found in break state", thread_id);
        return -1;
    }

    if (attached_threads_.count(thread_id) == 0)
    {
        debug_log(LOG_ERROR, "Thread %d is not attached", thread_id);
        return -1;
    }

    // Check if thread is actually stopped (like continue_execution_internal)
    if (!thread_it->second.is_stopped)
    {
        debug_log(LOG_ERROR, "Thread %d is not stopped (cannot single step a running thread)",
                  thread_id);
        return -1;
    }

    // Get current PC to check for software breakpoint
    uint64_t current_pc = 0;
#if defined(__aarch64__)
    struct iovec iov;
    struct user_pt_regs regs;
    iov.iov_base = &regs;
    iov.iov_len = sizeof(regs);
    if (PTRACE_CALL(DYNA_PTRACE_GETREGSET, thread_id, NT_PRSTATUS, &iov) == 0)
    {
        current_pc = regs.pc;
    }
#elif defined(__x86_64__)
    struct user_regs_struct regs;
    if (PTRACE_CALL(PTRACE_GETREGS, thread_id, nullptr, &regs) == 0)
    {
        current_pc = regs.rip;
    }
#endif

    // Check if there's a software breakpoint at current PC and temporarily restore original
    // instruction
    int software_bp_index = -1;
    if (current_pc != 0)
    {
        std::lock_guard<std::mutex> lock(software_breakpoint_mutex_);
        for (int i = 0; i < MAX_SOFTWARE_BREAKPOINTS; i++)
        {
            if (software_breakpoint_used[i] && software_breakpoint_addresses[i] == current_pc)
            {
                software_bp_index = i;
                debug_log(LOG_DEBUG,
                          "Software breakpoint found at PC 0x%lx (index %d), temporarily restoring "
                          "original instruction for single step",
                          current_pc, i);

                // Restore original instruction
#if defined(__aarch64__)
                const size_t bp_size = 4;
#elif defined(__x86_64__)
                const size_t bp_size = 1;
#endif
                // Read current memory word
                errno = 0;
                long word = ptrace(PTRACE_PEEKDATA, pid_, (void*)current_pc, nullptr);
                if (errno != 0)
                {
                    debug_log(LOG_ERROR,
                              "Failed to read memory at 0x%lx for software breakpoint restore: %s",
                              current_pc, strerror(errno));
                }
                else
                {
                    // Get original bytes from storage
                    uint8_t original_bytes[4] = {0};
                    size_t offset = i * 4;  // 4 bytes per breakpoint in storage
                    for (size_t j = 0; j < bp_size; j++)
                    {
                        original_bytes[j] = software_breakpoint_original_bytes[offset + j];
                    }

                    // Restore original bytes
#if defined(__aarch64__)
                    uint32_t original_instruction;
                    memcpy(&original_instruction, original_bytes, 4);
                    long restored_word = (word & ~0xFFFFFFFFUL) | original_instruction;
#elif defined(__x86_64__)
                    long restored_word = (word & ~0xFFUL) | original_bytes[0];
#endif
                    if (ptrace(PTRACE_POKEDATA, pid_, (void*)current_pc, (void*)restored_word) ==
                        -1)
                    {
                        debug_log(LOG_ERROR, "Failed to restore original instruction at 0x%lx: %s",
                                  current_pc, strerror(errno));
                    }
                    else
                    {
                        debug_log(
                            LOG_DEBUG,
                            "Temporarily restored original instruction at 0x%lx for single step",
                            current_pc);
                        // Store the index so we can re-insert the breakpoint after single step
                        thread_it->second.disabled_watchpoint_index =
                            software_bp_index +
                            1000;  // Use offset to distinguish from watchpoint index
                    }
                }
                break;
            }
        }
    }

    // Temporarily disable the current breakpoint to avoid re-triggering during single step
    int bp_index = thread_it->second.current_breakpoint_index;
    if (bp_index >= 0 && bp_index < MAX_BREAKPOINTS)
    {
#if defined(__aarch64__)
        struct user_hwdebug_state bp_state;
        memset(&bp_state, 0, sizeof(bp_state));
        struct iovec iov = {.iov_base = &bp_state, .iov_len = 8 + 16 * MAX_BREAKPOINTS};

        // Get current breakpoint state
        if (ptrace(PTRACE_GETREGSET, thread_id, NT_ARM_HW_BREAK, &iov) == 0)
        {
            // Disable the specific breakpoint temporarily
            bp_state.dbg_regs[bp_index].ctrl = 0;

            if (ptrace(PTRACE_SETREGSET, thread_id, NT_ARM_HW_BREAK, &iov) == -1)
            {
                debug_log(LOG_ERROR, "Failed to disable breakpoint %d for single step: %s",
                          bp_index, strerror(errno));
            }
        }
        else
        {
            debug_log(LOG_ERROR, "Failed to get breakpoint state for single step: %s",
                      strerror(errno));
        }
#elif defined(__x86_64__)
        // x86_64: Disable hardware breakpoint by clearing DR7 enable bits
        unsigned long dr7 =
            PTRACE_CALL(PTRACE_PEEKUSER, thread_id, X86_DR7_OFFSET, nullptr);
        // Clear local enable bit for this breakpoint
        dr7 &= ~(1UL << (bp_index * 2));
        if (PTRACE_CALL(PTRACE_POKEUSER, thread_id, X86_DR7_OFFSET, (void*)dr7) == -1)
        {
            debug_log(LOG_ERROR, "Failed to disable breakpoint %d for single step: %s", bp_index,
                      strerror(errno));
        }
#endif
    }

    // Set debug state before single stepping
    if (current_thread == thread_id)
    {
        debug_state_ = DebugState::SingleStepping;
    }

    // Update single step mode if not already set
    if (thread_it->second.single_step_mode == SingleStepMode::None)
    {
        thread_it->second.single_step_mode = SingleStepMode::Breakpoint;
    }
    thread_it->second.single_step_count = 0;

    // Mark thread as no longer stopped before single stepping
    thread_it->second.is_stopped = false;

    // Get pending signal to deliver during single step (for pass_signal=true)
    int signal_to_pass = thread_it->second.pending_signal;
    thread_it->second.pending_signal = 0;  // Clear after use

    if (signal_to_pass != 0)
    {
        debug_log(LOG_INFO, "Single stepping thread %d with signal %d (%s)", thread_id,
                  signal_to_pass, strsignal(signal_to_pass));
    }

    if (PTRACE_CALL(PTRACE_SINGLESTEP, thread_id, nullptr, (void*)(long)signal_to_pass) == -1)
    {
        debug_log(LOG_ERROR, "Failed to single step thread %d: %s", thread_id, strerror(errno));
        return -1;
    }
    return 0;
}

int Debugger::handle_single_step(pid_t thread)
{
    auto thread_it = thread_states_.find(thread);
    if (thread_it == thread_states_.end())
    {
        debug_log(LOG_ERROR, "Thread %d not found in single step state", thread);
        return -1;
    }

    switch (thread_it->second.single_step_mode)
    {
        case SingleStepMode::Watchpoint:
            return complete_watchpoint_single_step(thread);
        case SingleStepMode::Breakpoint:
        case SingleStepMode::SoftwareBreakpointContinue:
            return continue_breakpoint_single_step(thread);
        default:
            debug_log(LOG_ERROR, "Unknown single step mode for thread %d", thread);
            return -1;
    }
}

int Debugger::complete_watchpoint_single_step(pid_t thread)
{
    auto thread_it = thread_states_.find(thread);
    if (thread_it == thread_states_.end())
    {
        debug_log(LOG_ERROR, "Thread %d not found in watchpoint single step state", thread);
        return -1;
    }

    // Decrement handler count (detected by polling)
    int wp_index = thread_it->second.disabled_watchpoint_index;
    if (wp_index >= 0 && wp_index < MAX_WATCHPOINTS)
    {
        watchpoint_sync_[wp_index].active_handlers.fetch_sub(1);
    }

    // Clear single step mode and restoration info
    // Keep is_stopped = true because thread is still stopped after PTRACE_SINGLESTEP completion
    thread_it->second.single_step_mode = SingleStepMode::None;
    thread_it->second.original_wcr = 0;
    thread_it->second.disabled_watchpoint_index = -1;
    thread_it->second.is_stopped = false;  // Thread is still stopped after single step

    // Enqueue command to reapply all watchpoints to all threads
    // Pass the thread ID so stop_all_threads won't send PTRACE_INTERRUPT to it
    // (it's already stopped temporarily for reapply, but should be resumed after)
    auto request = std::make_shared<DebugRequest>(DebugCommand::ReapplyWatchpoints);
    request->thread_id = thread;
    enqueue_command(request);

    return 0;
}

int Debugger::continue_breakpoint_single_step(pid_t thread)
{
    auto thread_it = thread_states_.find(thread);
    if (thread_it == thread_states_.end())
    {
        debug_log(LOG_ERROR, "Thread %d not found in breakpoint single step state", thread);
        return -1;
    }

    int bp_index = thread_it->second.current_breakpoint_index;
    SingleStepMode step_mode = thread_it->second.single_step_mode;

    if (bp_index < 0 || bp_index >= MAX_BREAKPOINTS)
    {
        // bp_index == -1 is normal for non-hardware-breakpoint single steps (e.g., spawn, or
        // software breakpoint) Re-insert software breakpoint if it was temporarily removed
        if (thread_it->second.disabled_watchpoint_index >= 1000)
        {
            int sw_bp_index = thread_it->second.disabled_watchpoint_index - 1000;
            std::lock_guard<std::mutex> lock(software_breakpoint_mutex_);
            if (sw_bp_index >= 0 && sw_bp_index < MAX_SOFTWARE_BREAKPOINTS &&
                software_breakpoint_used[sw_bp_index])
            {
                uint64_t bp_addr = software_breakpoint_addresses[sw_bp_index];
                debug_log(LOG_DEBUG,
                          "Re-inserting software breakpoint at 0x%lx after single step (no hw bp)",
                          bp_addr);

                errno = 0;
                long word = ptrace(PTRACE_PEEKDATA, pid_, (void*)bp_addr, nullptr);
                if (errno == 0)
                {
#if defined(__aarch64__)
                    const uint32_t brk_instruction = 0xD4200000;  // BRK #0
                    long patched_word = (word & ~0xFFFFFFFFUL) | brk_instruction;
#elif defined(__x86_64__)
                    const uint8_t brk_instruction = 0xCC;  // INT3
                    long patched_word = (word & ~0xFFUL) | brk_instruction;
#endif
                    if (ptrace(PTRACE_POKEDATA, pid_, (void*)bp_addr, (void*)patched_word) == 0)
                    {
                        // debug_log(LOG_DEBUG, "Software breakpoint re-inserted at 0x%lx", bp_addr);
                    }
                }
            }
            thread_it->second.disabled_watchpoint_index = -1;
        }

        // Reset single step mode
        thread_it->second.single_step_mode = SingleStepMode::None;
        thread_it->second.current_breakpoint_index = -1;

        // If this was a software breakpoint continue, resume execution
        if (step_mode == SingleStepMode::SoftwareBreakpointContinue)
        {
            debug_log(LOG_INFO, "Continuing execution after software breakpoint step-over");
            thread_it->second.is_stopped = false;
            debug_state_ = DebugState::Running;

            if (PTRACE_CALL(PTRACE_CONT, thread, nullptr, nullptr) == -1)
            {
                debug_log(LOG_ERROR, "Failed to continue after software breakpoint: %s",
                          strerror(errno));
                return -1;
            }
            return 0;
        }

        // Just reset state and return success (for user-initiated single step)
        thread_it->second.is_stopped = true;  // Mark as stopped (back in break state)
        debug_state_ = DebugState::BreakpointHit;
        return 0;
    }

    // Get target_count and increment hit count (for single-step counting)
    int target_count = 0;
    int current_hit_count = 0;
    {
        std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
        target_count = breakpoint_target_counts[bp_index];
        breakpoint_hit_counts[bp_index]++;
        current_hit_count = breakpoint_hit_counts[bp_index];
    }

    // Check if trace mode is complete
    if (target_count > 0 && current_hit_count >= target_count)
    {
        // Trace complete: remove breakpoint and let execution continue

#if defined(__aarch64__)
        // Breakpoint is already disabled from initial hit, ensure it stays disabled
        struct user_hwdebug_state bp_state;
        memset(&bp_state, 0, sizeof(bp_state));
        struct iovec iov = {.iov_base = &bp_state, .iov_len = 8 + 16 * MAX_BREAKPOINTS};

        if (ptrace(PTRACE_GETREGSET, thread, NT_ARM_HW_BREAK, &iov) == 0)
        {
            bp_state.dbg_regs[bp_index].ctrl = 0;
            bp_state.dbg_regs[bp_index].addr = 0;
            ptrace(PTRACE_SETREGSET, thread, NT_ARM_HW_BREAK, &iov);
        }
#elif defined(__x86_64__)
        // x86_64: Clear the hardware breakpoint
        unsigned long dr7 =
            PTRACE_CALL(PTRACE_PEEKUSER, thread, X86_DR7_OFFSET, nullptr);
        dr7 &= ~(1UL << (bp_index * 2));  // Clear local enable bit
        PTRACE_CALL(PTRACE_POKEUSER, thread, X86_DR7_OFFSET, (void*)dr7);
        PTRACE_CALL(PTRACE_POKEUSER, thread, x86_dr_offset(bp_index), (void*)0);
#endif

        // Clean up thread state
        thread_it->second.single_step_mode = SingleStepMode::None;
        thread_it->second.single_step_count = 0;
        thread_it->second.is_stopped = false;  // Mark as not stopped before continuing

        // Remove breakpoint data
        {
            std::lock_guard<std::mutex> lock(breakpoint_data_mutex_);
            breakpoint_used[bp_index] = false;
            breakpoint_addresses[bp_index] = 0;
            breakpoint_hit_counts[bp_index] = 0;
            breakpoint_target_counts[bp_index] = 0;
        }

        debug_state_ = DebugState::Running;
        current_thread = 0;

        // Continue execution (don't suspend)
        if (PTRACE_CALL(PTRACE_CONT, thread, nullptr, nullptr) == -1)
        {
            debug_log(LOG_ERROR, "Failed to continue thread %d after trace complete: %s", thread,
                      strerror(errno));
            return -1;
        }

        return 0;
    }

    // Trace mode: continue single-stepping
    if (target_count > 0 && current_hit_count < target_count)
    {
        debug_state_ = DebugState::SingleStepping;

        if (PTRACE_CALL(PTRACE_SINGLESTEP, thread, nullptr, nullptr) == -1)
        {
            debug_log(LOG_ERROR, "Failed to continue single step for thread %d: %s", thread,
                      strerror(errno));
            return -1;
        }

        return 0;
    }

    // Wait mode (target_count == 0): return to break state
    // Re-enable the breakpoint that was temporarily disabled
#if defined(__aarch64__)
    struct user_hwdebug_state bp_state;
    memset(&bp_state, 0, sizeof(bp_state));
    struct iovec iov = {.iov_base = &bp_state, .iov_len = 8 + 16 * MAX_BREAKPOINTS};

    if (ptrace(PTRACE_GETREGSET, thread, NT_ARM_HW_BREAK, &iov) == 0)
    {
        bp_state.dbg_regs[bp_index].addr = breakpoint_addresses[bp_index];
        bp_state.dbg_regs[bp_index].ctrl =
            encode_ctrl_reg(0, ARM_BREAKPOINT_LEN_4, ARM_BREAKPOINT_EXECUTE, 0, 1);

        if (ptrace(PTRACE_SETREGSET, thread, NT_ARM_HW_BREAK, &iov) == 0)
        {
        }
        else
        {
            debug_log(LOG_ERROR, "Failed to re-enable breakpoint %d: %s", bp_index,
                      strerror(errno));
        }
    }
#elif defined(__x86_64__)
    // x86_64: Re-enable the hardware breakpoint
    unsigned long dr7 = PTRACE_CALL(PTRACE_PEEKUSER, thread, X86_DR7_OFFSET, nullptr);
    dr7 |= (1UL << (bp_index * 2));  // Set local enable bit
    // Set condition (execution) and length (1 byte for exec)
    int shift = 16 + bp_index * 4;
    dr7 &= ~(0xFUL << shift);
    dr7 |= ((X86_DR7_BREAK_ON_EXEC | (X86_DR7_LEN_1 << 2)) << shift);
    PTRACE_CALL(PTRACE_POKEUSER, thread, X86_DR7_OFFSET, (void*)dr7);
#endif

    // Re-insert software breakpoint if it was temporarily removed
    if (thread_it->second.disabled_watchpoint_index >= 1000)
    {
        int sw_bp_index = thread_it->second.disabled_watchpoint_index - 1000;
        std::lock_guard<std::mutex> lock(software_breakpoint_mutex_);
        if (sw_bp_index >= 0 && sw_bp_index < MAX_SOFTWARE_BREAKPOINTS &&
            software_breakpoint_used[sw_bp_index])
        {
            uint64_t bp_addr = software_breakpoint_addresses[sw_bp_index];

            // Read current memory word
            errno = 0;
            long word = ptrace(PTRACE_PEEKDATA, pid_, (void*)bp_addr, nullptr);
            if (errno == 0)
            {
#if defined(__aarch64__)
                const uint32_t brk_instruction = 0xD4200000;  // BRK #0
                long patched_word = (word & ~0xFFFFFFFFUL) | brk_instruction;
#elif defined(__x86_64__)
                const uint8_t brk_instruction = 0xCC;  // INT3
                long patched_word = (word & ~0xFFUL) | brk_instruction;
#endif
                if (ptrace(PTRACE_POKEDATA, pid_, (void*)bp_addr, (void*)patched_word) == 0)
                {
                    // debug_log(LOG_INFO, "Software breakpoint re-inserted at 0x%lx", bp_addr);
                }
                else
                {
                    debug_log(LOG_ERROR, "Failed to re-insert software breakpoint at 0x%lx: %s",
                              bp_addr, strerror(errno));
                }
            }
        }
        thread_it->second.disabled_watchpoint_index = -1;
    }

    thread_it->second.single_step_mode = SingleStepMode::None;
    thread_it->second.single_step_count = 0;
    thread_it->second.is_stopped = true;  // Mark as stopped (back in break state)
    debug_state_ = DebugState::BreakpointHit;
    return 0;
}

```

`src/server/src/cpp/src/linux/debugger/debugger_internal.h`:

```h
/**
 * @file debugger_internal.h
 * @brief Internal header for debugger implementation files
 *
 * This header provides common includes and declarations used across
 * the split debugger implementation files. Include this in all
 * debugger_*.cpp files instead of individual headers.
 */

#ifndef DEBUGGER_INTERNAL_H
#define DEBUGGER_INTERNAL_H

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>

#include "debugger.h"
#ifndef TARGET_IS_ANDROID
#include <pty.h>
#endif
#include <signal.h>
#include <string.h>
#include <sys/ptrace.h>
#include <sys/wait.h>
#include <termios.h>
#include <unistd.h>

#include <chrono>
#include <set>

#include "../../common/exception_info.h"
#include "../../common/util.h"
#include "../core/native_api.h"

// Helper macro to call send_exception_info
#define SEND_EXCEPTION_INFO(info_ptr, pid_val) send_exception_info(info_ptr, pid_val)

// =============================================================================
// Exception info population functions (defined in debugger_core.cpp)
// =============================================================================

#if defined(__aarch64__)
void populate_exception_info(NativeExceptionInfo& info, const struct user_pt_regs& regs,
                             ExceptionType exception_type, pid_t thread_id,
                             uint64_t memory_address = 0, uint64_t singlestep_mode = 0,
                             bool is_trace = false);
#elif defined(__x86_64__)
void populate_exception_info(NativeExceptionInfo& info, const struct user_regs_struct& regs,
                             ExceptionType exception_type, pid_t thread_id,
                             uint64_t memory_address = 0, uint64_t singlestep_mode = 0,
                             bool is_trace = false);
#endif

// =============================================================================
// Global declarations (defined in debugger_core.cpp)
// =============================================================================

extern std::map<int, SignalConfig> g_signal_config;
extern std::mutex g_signal_config_mutex;

// =============================================================================
// Memory helper functions (defined in debugger_core.cpp)
// =============================================================================

uint64_t read_memory_word(pid_t pid, uint64_t address);
int write_memory_word(pid_t pid, uint64_t address, uint64_t data);

// =============================================================================
// Thread helper functions (defined in debugger_thread.cpp)
// =============================================================================

bool is_thread_stopped(pid_t pid, pid_t tid);

#endif  // DEBUGGER_INTERNAL_H

```

`src/server/src/cpp/src/linux/debugger/debugger_memory.cpp`:

```cpp
/**
 * @file debugger_memory.cpp
 * @brief Memory read operations for the Linux debugger
 *
 * This file contains the memory read functionality for the Debugger class,
 * including internal ptrace-based memory reading and the public API.
 *
 * Memory reading strategy:
 * 1. If current_thread is stopped (break state), use it
 * 2. Otherwise, find any already-stopped thread via /proc
 * 3. If no stopped thread found, stop all threads temporarily
 *
 * Memory is shared across all threads, so we can read from any stopped thread.
 */

#include "debugger_internal.h"

/**
 * @brief Internal memory read implementation using ptrace PEEKDATA
 *
 * Reads memory from the target process using ptrace. This function handles
 * finding an appropriate stopped thread, reading memory word by word, and
 * handling various error conditions.
 *
 * @param address The starting address to read from
 * @param size The number of bytes to read
 * @param buffer The buffer to store the read data
 * @return The number of bytes read, or -1 on failure
 */
ssize_t Debugger::read_memory_internal(uint64_t address, size_t size, unsigned char* buffer)
{
    debug_log(LOG_DEBUG, "read_memory_internal: address=0x%lx, size=%zu, attached_threads=%zu",
              address, size, attached_threads_.size());

    // Memory is shared across all threads, so we can read from any stopped thread
    // Strategy:
    // 1. If current_thread is stopped (break state), use it
    // 2. Otherwise, find any already-stopped thread via /proc
    // 3. If no stopped thread found, stop all threads temporarily

    bool need_resume = false;
    std::vector<pid_t> stopped_threads;
    pid_t read_thread = 0;

    // Try to find any stopped thread via /proc
    if (read_thread == 0)
    {
        read_thread = find_stopped_thread();
        debug_log(LOG_DEBUG, "find_stopped_thread returned: %d", read_thread);
    }

    // If no stopped thread found, we need to stop threads
    if (read_thread == 0)
    {
        debug_log(LOG_DEBUG, "No stopped thread found, calling stop_all_threads");
        stopped_threads = stop_all_threads();
        if (stopped_threads.empty())
        {
            debug_log(LOG_ERROR, "Failed to stop threads for memory read");
            return -1;
        }
        read_thread = stopped_threads[0];
        need_resume = true;
    }

    if (read_thread == 0)
    {
        debug_log(LOG_ERROR, "No thread available for memory read");
        return -1;
    }

    // Read memory using ptrace PEEKDATA
    size_t bytes_read = 0;
    size_t word_size = sizeof(long);
    int consecutive_failures = 0;
    const int max_consecutive_failures = 3;

    while (bytes_read < size && consecutive_failures < max_consecutive_failures)
    {
        uintptr_t aligned_addr = (address + bytes_read) & ~(word_size - 1);
        size_t offset = (address + bytes_read) - aligned_addr;

        errno = 0;
        long word = PTRACE_CALL(PTRACE_PEEKDATA, read_thread, reinterpret_cast<void*>(aligned_addr),
                                nullptr);

        if (errno != 0)
        {
            consecutive_failures++;
            debug_log(LOG_ERROR, "PTRACE_PEEKDATA failed at 0x%lx: %d (%s)", aligned_addr, errno,
                      strerror(errno));

            if (errno == EIO || errno == EFAULT)
            {
                size_t skip_bytes = word_size - offset;
                if (bytes_read + skip_bytes >= size) break;
                bytes_read += skip_bytes;
                continue;
            }
            else if (errno == ESRCH)
            {
                break;
            }
            else
            {
                bytes_read += 1;
                continue;
            }
        }

        consecutive_failures = 0;

        size_t bytes_to_copy = std::min(size - bytes_read, word_size - offset);
        unsigned char* word_bytes = reinterpret_cast<unsigned char*>(&word);
        memcpy(buffer + bytes_read, word_bytes + offset, bytes_to_copy);
        bytes_read += bytes_to_copy;
    }

    // Resume threads if we stopped them
    if (need_resume)
    {
        resume_threads(stopped_threads);
    }

    return bytes_read > 0 ? static_cast<ssize_t>(bytes_read) : -1;
}

/**
 * @brief Public API for reading memory from the target process
 *
 * This function enqueues a memory read command to be executed by the
 * debugger's command processing thread. It blocks until the read is complete.
 *
 * @param address The starting address to read from
 * @param size The number of bytes to read
 * @param buffer The buffer to store the read data (must be pre-allocated)
 * @return The number of bytes read, or -1 on failure
 */
ssize_t Debugger::read_memory(uint64_t address, size_t size, unsigned char* buffer)
{
    if (!buffer || size == 0)
    {
        return -1;
    }

    auto request = std::make_shared<DebugRequest>(DebugCommand::ReadMemory);
    request->address = address;
    request->memory_size = size;
    request->memory_buffer = buffer;

    enqueue_command(request);

    // Wait for completion
    std::unique_lock<std::mutex> lock(request->result_mutex);
    request->result_cv.wait(lock, [&request] { return request->completed; });

    return request->memory_bytes_read;
}

```

`src/server/src/cpp/src/linux/debugger/debugger_native_api.cpp`:

```cpp
/**
 * @file debugger_native_api.cpp
 * @brief Native C API for debugger functionality
 *
 * This file contains the extern "C" API functions that expose the Debugger
 * class functionality to Rust and other C-compatible languages.
 *
 * Functions:
 * - debugger_new: Create and initialize debugger for a PID
 * - set_watchpoint_native: Set a hardware watchpoint
 * - remove_watchpoint_native: Remove a watchpoint
 * - set_breakpoint_native: Set a breakpoint (hardware or software)
 * - remove_breakpoint_native: Remove a breakpoint
 * - get_software_breakpoint_original_bytes_native: Get original instruction bytes
 * - continue_execution_native: Resume thread execution
 * - single_step_native: Single step a thread
 * - read_register_native: Read a register value
 * - write_register_native: Write a register value
 * - is_in_break_state_native: Check if debugger is at a breakpoint
 * - is_debugger_attached_native: Check if debugger is attached
 * - read_memory_debugger_native: Read process memory
 * - Signal configuration APIs: set/get/remove signal catch/pass behavior
 */

#include "debugger_internal.h"

extern "C"
{
    bool debugger_new(pid_t pid)
    {
        // If debugger already exists for the same PID and is running, reuse it
        if (g_debugger != nullptr)
        {
            if (g_debugger->get_pid() == pid && g_debugger->is_running())
            {
                return true;
            }
            // Different PID or not running - delete old debugger
            delete g_debugger;
            g_debugger = nullptr;
        }

        g_debugger = new Debugger(pid);

        // Sync global signal settings to new debugger instance
        {
            std::lock_guard<std::mutex> lock(g_signal_config_mutex);
            if (!g_signal_config.empty())
            {
                g_debugger->set_all_signal_configs(g_signal_config);
                debug_log(LOG_INFO, "Synced %zu signal configs to new debugger instance",
                          g_signal_config.size());
            }
        }

        if (g_debugger->initialize())
        {
            g_debugger->run();
            return true;
        }
        else
        {
            delete g_debugger;
            g_debugger = nullptr;
            return false;
        }
    }

    int set_watchpoint_native(uint64_t address, int size, WatchpointType type)
    {
        if (g_debugger)
        {
            return g_debugger->set_watchpoint(address, size, type);
        }
        return -1;
    }

    int remove_watchpoint_native(uint64_t address)
    {
        if (g_debugger)
        {
            return g_debugger->remove_watchpoint(address);
        }
        return -1;
    }

    int set_breakpoint_native(uint64_t address, int hit_count, bool is_software)
    {
        if (g_debugger)
        {
            return g_debugger->set_breakpoint(address, hit_count, is_software);
        }
        return -1;
    }

    int remove_breakpoint_native(uint64_t address)
    {
        if (g_debugger)
        {
            return g_debugger->remove_breakpoint(address);
        }
        return -1;
    }

    bool get_software_breakpoint_original_bytes_native(uint64_t address, uint8_t* out_bytes,
                                                       size_t* out_size)
    {
        if (g_debugger)
        {
            return g_debugger->get_software_breakpoint_original_bytes(address, out_bytes, out_size);
        }
        return false;
    }

    int continue_execution_native(pid_t thread_id)
    {
        if (g_debugger)
        {
            return g_debugger->continue_execution(thread_id);
        }
        return -1;
    }

    int single_step_native(pid_t thread_id)
    {
        if (g_debugger)
        {
            return g_debugger->single_step(thread_id);
        }
        return -1;
    }

    int read_register_native(pid_t thread_id, const char* reg_name, uint64_t* value)
    {
        if (g_debugger && reg_name && value)
        {
            std::string reg_str(reg_name);
            return g_debugger->read_register(thread_id, reg_str, value);
        }
        return -1;
    }

    int write_register_native(pid_t thread_id, const char* reg_name, uint64_t value)
    {
        if (g_debugger && reg_name)
        {
            std::string reg_str(reg_name);
            return g_debugger->write_register(thread_id, reg_str, value);
        }
        return -1;
    }

    bool is_in_break_state_native()
    {
        if (g_debugger)
        {
            return g_debugger->is_in_break_state();
        }
        return false;
    }

    bool is_debugger_attached_native()
    {
        return g_debugger != nullptr;
    }

    ssize_t read_memory_debugger_native(uint64_t address, size_t size, unsigned char* buffer)
    {
        if (g_debugger && buffer && size > 0)
        {
            return g_debugger->read_memory(address, size, buffer);
        }
        return -1;
    }

    // ==========================================================================
    // Signal configuration APIs (catch/pass behavior)
    // ==========================================================================

    void set_signal_config_native(int signal, bool catch_signal, bool pass_signal)
    {
        SignalConfig config(catch_signal, pass_signal);
        {
            std::lock_guard<std::mutex> lock(g_signal_config_mutex);
            g_signal_config[signal] = config;
        }
        if (g_debugger)
        {
            g_debugger->set_signal_config(signal, config);
            debug_log(LOG_INFO, "Set signal %d config: catch=%d, pass=%d (g_debugger updated)",
                      signal, catch_signal, pass_signal);
        }
        else
        {
            debug_log(LOG_INFO, "Set signal %d config: catch=%d, pass=%d (stored globally)", signal,
                      catch_signal, pass_signal);
        }
    }

    void get_signal_config_native(int signal, bool* catch_signal, bool* pass_signal)
    {
        std::lock_guard<std::mutex> lock(g_signal_config_mutex);
        auto it = g_signal_config.find(signal);
        if (it != g_signal_config.end())
        {
            if (catch_signal) *catch_signal = it->second.catch_signal;
            if (pass_signal) *pass_signal = it->second.pass_signal;
        }
        else
        {
            if (catch_signal) *catch_signal = false;
            if (pass_signal) *pass_signal = false;
        }
    }

    size_t get_all_signal_configs_native(int* signals, bool* catch_signals, bool* pass_signals,
                                         size_t max_count)
    {
        std::lock_guard<std::mutex> lock(g_signal_config_mutex);
        size_t count = 0;
        for (const auto& pair : g_signal_config)
        {
            if (count >= max_count) break;
            if (signals) signals[count] = pair.first;
            if (catch_signals) catch_signals[count] = pair.second.catch_signal;
            if (pass_signals) pass_signals[count] = pair.second.pass_signal;
            ++count;
        }
        return count;
    }

    void remove_signal_config_native(int signal)
    {
        {
            std::lock_guard<std::mutex> lock(g_signal_config_mutex);
            g_signal_config.erase(signal);
        }
        if (g_debugger)
        {
            g_debugger->remove_signal_config(signal);
        }
        debug_log(LOG_INFO, "Removed signal %d config", signal);
    }
}

```

`src/server/src/cpp/src/linux/debugger/debugger_register.cpp`:

```cpp
/**
 * @file debugger_register.cpp
 * @brief Register read/write and debug state Debugger class member functions
 *
 * This file contains the implementation of register access and debug state
 * management for the Linux debugger. It includes extensive register mapping
 * for both ARM64 and x86_64 architectures.
 *
 * Functions included:
 *   - read_register: Public API for reading a register value
 *   - read_register_internal: Internal implementation of register read
 *   - write_register: Public API for writing a register value
 *   - write_register_internal: Internal implementation of register write
 *   - resume_all_user_stopped_threads: Public API to resume user-stopped threads
 *   - resume_all_user_stopped_threads_internal: Internal implementation of resume
 */

#include "debugger_internal.h"

// =============================================================================
// Register Read Operations
// =============================================================================

int Debugger::read_register(pid_t thread_id, const std::string& reg_name, uint64_t* value)
{
    // Create request and enqueue it to the debug thread
    auto request = std::make_shared<DebugRequest>(DebugCommand::ReadRegister);
    request->thread_id = thread_id;
    request->reg_name = reg_name;
    request->reg_value_ptr = value;

    enqueue_command(request);

    // Wait for the result
    std::unique_lock<std::mutex> lock(request->result_mutex);
    request->result_cv.wait(lock, [request] { return request->completed; });

    return request->result;
}

int Debugger::read_register_internal(pid_t thread_id, const std::string& reg_name, uint64_t* value)
{
    if (!value || attached_threads_.count(thread_id) == 0)
    {
        debug_log(LOG_ERROR,
                  "read_register_internal: invalid params - value=%p, thread_id=%d, attached=%d",
                  value, thread_id, attached_threads_.count(thread_id));
        return -1;
    }

    debug_log(LOG_DEBUG, "read_register_internal: thread_id=%d, reg_name=%s", thread_id,
              reg_name.c_str());

#if defined(__aarch64__)
    struct iovec iov;
    struct user_pt_regs regs;
    iov.iov_base = &regs;
    iov.iov_len = sizeof(regs);
    if (PTRACE_CALL(DYNA_PTRACE_GETREGSET, thread_id, NT_PRSTATUS, &iov) == -1)
#elif defined(__x86_64__)
    struct user_regs_struct regs;
    if (PTRACE_CALL(PTRACE_GETREGS, thread_id, nullptr, &regs) == -1)
#endif
    {
        debug_log(LOG_ERROR, "Failed to get registers for thread %d: %s", thread_id,
                  strerror(errno));
        return -1;
    }

#if defined(__aarch64__)
    // ARM64 register mapping
    if (reg_name == "x0")
        *value = regs.regs[0];
    else if (reg_name == "x1")
        *value = regs.regs[1];
    else if (reg_name == "x2")
        *value = regs.regs[2];
    else if (reg_name == "x3")
        *value = regs.regs[3];
    else if (reg_name == "x4")
        *value = regs.regs[4];
    else if (reg_name == "x5")
        *value = regs.regs[5];
    else if (reg_name == "x6")
        *value = regs.regs[6];
    else if (reg_name == "x7")
        *value = regs.regs[7];
    else if (reg_name == "x8")
        *value = regs.regs[8];
    else if (reg_name == "x9")
        *value = regs.regs[9];
    else if (reg_name == "x10")
        *value = regs.regs[10];
    else if (reg_name == "x11")
        *value = regs.regs[11];
    else if (reg_name == "x12")
        *value = regs.regs[12];
    else if (reg_name == "x13")
        *value = regs.regs[13];
    else if (reg_name == "x14")
        *value = regs.regs[14];
    else if (reg_name == "x15")
        *value = regs.regs[15];
    else if (reg_name == "x16")
        *value = regs.regs[16];
    else if (reg_name == "x17")
        *value = regs.regs[17];
    else if (reg_name == "x18")
        *value = regs.regs[18];
    else if (reg_name == "x19")
        *value = regs.regs[19];
    else if (reg_name == "x20")
        *value = regs.regs[20];
    else if (reg_name == "x21")
        *value = regs.regs[21];
    else if (reg_name == "x22")
        *value = regs.regs[22];
    else if (reg_name == "x23")
        *value = regs.regs[23];
    else if (reg_name == "x24")
        *value = regs.regs[24];
    else if (reg_name == "x25")
        *value = regs.regs[25];
    else if (reg_name == "x26")
        *value = regs.regs[26];
    else if (reg_name == "x27")
        *value = regs.regs[27];
    else if (reg_name == "x28")
        *value = regs.regs[28];
    else if (reg_name == "x29")
        *value = regs.regs[29];
    else if (reg_name == "x30")
        *value = regs.regs[30];
    else if (reg_name == "sp")
        *value = regs.sp;
    else if (reg_name == "pc")
        *value = regs.pc;
    else if (reg_name == "pstate")
        *value = regs.pstate;
    else
    {
        debug_log(LOG_ERROR, "Unknown register: %s", reg_name.c_str());
        return -1;
    }
#elif defined(__x86_64__)
    // x86_64 register mapping
    if (reg_name == "rax")
        *value = regs.rax;
    else if (reg_name == "rbx")
        *value = regs.rbx;
    else if (reg_name == "rcx")
        *value = regs.rcx;
    else if (reg_name == "rdx")
        *value = regs.rdx;
    else if (reg_name == "rsi")
        *value = regs.rsi;
    else if (reg_name == "rdi")
        *value = regs.rdi;
    else if (reg_name == "rbp")
        *value = regs.rbp;
    else if (reg_name == "rsp")
        *value = regs.rsp;
    else if (reg_name == "r8")
        *value = regs.r8;
    else if (reg_name == "r9")
        *value = regs.r9;
    else if (reg_name == "r10")
        *value = regs.r10;
    else if (reg_name == "r11")
        *value = regs.r11;
    else if (reg_name == "r12")
        *value = regs.r12;
    else if (reg_name == "r13")
        *value = regs.r13;
    else if (reg_name == "r14")
        *value = regs.r14;
    else if (reg_name == "r15")
        *value = regs.r15;
    else if (reg_name == "rip")
        *value = regs.rip;
    else if (reg_name == "rflags" || reg_name == "eflags")
        *value = regs.eflags;
    else if (reg_name == "cs")
        *value = regs.cs;
    else if (reg_name == "ss")
        *value = regs.ss;
    else if (reg_name == "ds")
        *value = regs.ds;
    else if (reg_name == "es")
        *value = regs.es;
    else if (reg_name == "fs")
        *value = regs.fs;
    else if (reg_name == "gs")
        *value = regs.gs;
    else if (reg_name == "fs_base")
        *value = regs.fs_base;
    else if (reg_name == "gs_base")
        *value = regs.gs_base;
    else
    {
        debug_log(LOG_ERROR, "Unknown register: %s", reg_name.c_str());
        return -1;
    }
#endif

    return 0;
}

// =============================================================================
// Register Write Operations
// =============================================================================

int Debugger::write_register(pid_t thread_id, const std::string& reg_name, uint64_t value)
{
    // Create request and enqueue it to the debug thread
    auto request = std::make_shared<DebugRequest>(DebugCommand::WriteRegister);
    request->thread_id = thread_id;
    request->reg_name = reg_name;
    request->reg_value = value;

    enqueue_command(request);

    // Wait for the result
    std::unique_lock<std::mutex> lock(request->result_mutex);
    request->result_cv.wait(lock, [request] { return request->completed; });

    return request->result;
}

int Debugger::write_register_internal(pid_t thread_id, const std::string& reg_name, uint64_t value)
{
    if (attached_threads_.count(thread_id) == 0)
    {
        return -1;
    }

#if defined(__aarch64__)
    struct iovec iov;
    struct user_pt_regs regs;
    iov.iov_base = &regs;
    iov.iov_len = sizeof(regs);
    if (PTRACE_CALL(DYNA_PTRACE_GETREGSET, thread_id, NT_PRSTATUS, &iov) == -1)
#elif defined(__x86_64__)
    struct user_regs_struct regs;
    if (PTRACE_CALL(PTRACE_GETREGS, thread_id, nullptr, &regs) == -1)
#endif
    {
        debug_log(LOG_ERROR, "Failed to get registers for thread %d", thread_id);
        return -1;
    }

#if defined(__aarch64__)
    // ARM64 register mapping
    if (reg_name == "x0")
        regs.regs[0] = value;
    else if (reg_name == "x1")
        regs.regs[1] = value;
    else if (reg_name == "x2")
        regs.regs[2] = value;
    else if (reg_name == "x3")
        regs.regs[3] = value;
    else if (reg_name == "x4")
        regs.regs[4] = value;
    else if (reg_name == "x5")
        regs.regs[5] = value;
    else if (reg_name == "x6")
        regs.regs[6] = value;
    else if (reg_name == "x7")
        regs.regs[7] = value;
    else if (reg_name == "x8")
        regs.regs[8] = value;
    else if (reg_name == "x9")
        regs.regs[9] = value;
    else if (reg_name == "x10")
        regs.regs[10] = value;
    else if (reg_name == "x11")
        regs.regs[11] = value;
    else if (reg_name == "x12")
        regs.regs[12] = value;
    else if (reg_name == "x13")
        regs.regs[13] = value;
    else if (reg_name == "x14")
        regs.regs[14] = value;
    else if (reg_name == "x15")
        regs.regs[15] = value;
    else if (reg_name == "x16")
        regs.regs[16] = value;
    else if (reg_name == "x17")
        regs.regs[17] = value;
    else if (reg_name == "x18")
        regs.regs[18] = value;
    else if (reg_name == "x19")
        regs.regs[19] = value;
    else if (reg_name == "x20")
        regs.regs[20] = value;
    else if (reg_name == "x21")
        regs.regs[21] = value;
    else if (reg_name == "x22")
        regs.regs[22] = value;
    else if (reg_name == "x23")
        regs.regs[23] = value;
    else if (reg_name == "x24")
        regs.regs[24] = value;
    else if (reg_name == "x25")
        regs.regs[25] = value;
    else if (reg_name == "x26")
        regs.regs[26] = value;
    else if (reg_name == "x27")
        regs.regs[27] = value;
    else if (reg_name == "x28")
        regs.regs[28] = value;
    else if (reg_name == "x29")
        regs.regs[29] = value;
    else if (reg_name == "x30")
        regs.regs[30] = value;
    else if (reg_name == "sp")
        regs.sp = value;
    else if (reg_name == "pc")
        regs.pc = value;
    else if (reg_name == "pstate")
        regs.pstate = value;
    else
    {
        debug_log(LOG_ERROR, "Unknown register: %s", reg_name.c_str());
        return -1;
    }
#elif defined(__x86_64__)
    // x86_64 register mapping
    if (reg_name == "rax")
        regs.rax = value;
    else if (reg_name == "rbx")
        regs.rbx = value;
    else if (reg_name == "rcx")
        regs.rcx = value;
    else if (reg_name == "rdx")
        regs.rdx = value;
    else if (reg_name == "rsi")
        regs.rsi = value;
    else if (reg_name == "rdi")
        regs.rdi = value;
    else if (reg_name == "rbp")
        regs.rbp = value;
    else if (reg_name == "rsp")
        regs.rsp = value;
    else if (reg_name == "r8")
        regs.r8 = value;
    else if (reg_name == "r9")
        regs.r9 = value;
    else if (reg_name == "r10")
        regs.r10 = value;
    else if (reg_name == "r11")
        regs.r11 = value;
    else if (reg_name == "r12")
        regs.r12 = value;
    else if (reg_name == "r13")
        regs.r13 = value;
    else if (reg_name == "r14")
        regs.r14 = value;
    else if (reg_name == "r15")
        regs.r15 = value;
    else if (reg_name == "rip")
        regs.rip = value;
    else if (reg_name == "rflags" || reg_name == "eflags")
        regs.eflags = value;
    else if (reg_name == "cs")
        regs.cs = value;
    else if (reg_name == "ss")
        regs.ss = value;
    else if (reg_name == "ds")
        regs.ds = value;
    else if (reg_name == "es")
        regs.es = value;
    else if (reg_name == "fs")
        regs.fs = value;
    else if (reg_name == "gs")
        regs.gs = value;
    else if (reg_name == "fs_base")
        regs.fs_base = value;
    else if (reg_name == "gs_base")
        regs.gs_base = value;
    else
    {
        debug_log(LOG_ERROR, "Unknown register: %s", reg_name.c_str());
        return -1;
    }
#endif

#if defined(__aarch64__)
    if (PTRACE_CALL(DYNA_PTRACE_SETREGSET, thread_id, NT_PRSTATUS, &iov) == -1)
#elif defined(__x86_64__)
    if (PTRACE_CALL(PTRACE_SETREGS, thread_id, nullptr, &regs) == -1)
#endif
    {
        debug_log(LOG_ERROR, "Failed to set registers for thread %d", thread_id);
        return -1;
    }

    return 0;
}

// =============================================================================
// Thread Resume Operations
// =============================================================================

int Debugger::resume_all_user_stopped_threads()
{
    // Create request and enqueue it to the debug thread
    auto request = std::make_shared<DebugRequest>(DebugCommand::ResumeUserStoppedThreads);

    enqueue_command(request);

    // Wait for the result
    std::unique_lock<std::mutex> lock(request->result_mutex);
    request->result_cv.wait(lock, [request] { return request->completed; });

    return request->result;
}

int Debugger::resume_all_user_stopped_threads_internal()
{
    std::lock_guard<std::mutex> lock(thread_states_mutex_);
    int resumed_count = 0;

    for (auto& [tid, state] : thread_states_)
    {
        if (state.stopped_by_user)
        {
            debug_log(LOG_INFO, "Resuming user-stopped thread %d", tid);

            // Resume the thread with PTRACE_CONT (must be called from debugger thread)
            if (PTRACE_CALL(PTRACE_CONT, tid, nullptr, nullptr) == -1)
            {
                debug_log(LOG_ERROR, "Failed to PTRACE_CONT thread %d: %s", tid, strerror(errno));
                // Continue trying other threads
            }
            else
            {
                state.stopped_by_user = false;
                state.is_stopped = false;
                resumed_count++;
            }
        }
    }

    debug_log(LOG_INFO, "Resumed %d user-stopped threads via PTRACE_CONT", resumed_count);
    return resumed_count;
}

```

`src/server/src/cpp/src/linux/debugger/debugger_spawn.cpp`:

```cpp
/**
 * @file debugger_spawn.cpp
 * @brief Process spawning functions for the Linux debugger
 *
 * This file contains the Debugger class member functions related to process
 * spawning, including:
 * - spawn_process: Public API for spawning a new process
 * - spawn_process_with_pty: Public API for spawning with PTY support
 * - spawn_process_internal: Internal implementation for debug thread
 * - spawn_process_with_pty_internal: Internal PTY spawn implementation
 * - is_thread_stopped: Helper to check thread state via /proc
 * - find_stopped_thread: Find any stopped thread from attached threads
 *
 * @note PTY spawn is not supported on Android.
 */

#include "debugger_internal.h"

// Helper function to check if a thread is stopped via /proc
bool is_thread_stopped(pid_t pid, pid_t tid)
{
    char status_path[256];
    snprintf(status_path, sizeof(status_path), "/proc/%d/task/%d/status", pid, tid);

    FILE* fp = fopen(status_path, "r");
    if (!fp)
    {
        return false;
    }

    char line[256];
    bool is_stopped = false;
    while (fgets(line, sizeof(line), fp))
    {
        if (strncmp(line, "State:", 6) == 0)
        {
            // State: T (stopped) or t (tracing stop)
            char state = line[7];
            while (state == ' ' || state == '\t')
            {
                state = *(strchr(line, state) + 1);
            }
            // Find the actual state character after whitespace
            const char* state_ptr = line + 6;
            while (*state_ptr == ' ' || *state_ptr == '\t') state_ptr++;
            state = *state_ptr;

            is_stopped = (state == 'T' || state == 't');
            break;
        }
    }

    fclose(fp);
    return is_stopped;
}

// Find any stopped thread from attached threads
pid_t Debugger::find_stopped_thread()
{
    for (pid_t tid : attached_threads_)
    {
        if (is_thread_stopped(pid_, tid))
        {
            return tid;
        }
    }
    return 0;
}

// Spawn a new process - public API (enqueues command to debug thread)
int Debugger::spawn_process(const std::string& executable_path,
                            const std::vector<std::string>& args, pid_t* out_pid)
{
    auto request = std::make_shared<DebugRequest>(DebugCommand::SpawnProcess);
    request->executable_path = executable_path;
    request->spawn_args = args;

    enqueue_command(request);

    // Wait for the result
    std::unique_lock<std::mutex> lock(request->result_mutex);
    request->result_cv.wait(lock, [request] { return request->completed; });

    if (out_pid != nullptr)
    {
        *out_pid = request->spawned_pid;
    }

    return request->result;
}

// Spawn a new process with PTY - public API (enqueues command to debug thread)
int Debugger::spawn_process_with_pty(const std::string& executable_path,
                                     const std::vector<std::string>& args, pid_t* out_pid,
                                     int* out_pty_fd)
{
    auto request = std::make_shared<DebugRequest>(DebugCommand::SpawnProcessWithPty);
    request->executable_path = executable_path;
    request->spawn_args = args;

    enqueue_command(request);

    // Wait for the result
    std::unique_lock<std::mutex> lock(request->result_mutex);
    request->result_cv.wait(lock, [request] { return request->completed; });

    if (out_pid != nullptr)
    {
        *out_pid = request->spawned_pid;
    }
    if (out_pty_fd != nullptr)
    {
        *out_pty_fd = request->pty_fd;
    }

    return request->result;
}

// Internal spawn implementation - runs in debug thread
int Debugger::spawn_process_internal(std::shared_ptr<DebugRequest> request)
{
    debug_log(LOG_INFO, "Spawning process in debug thread: %s", request->executable_path.c_str());

    pid_t pid = fork();

    if (pid < 0)
    {
        debug_log(LOG_ERROR, "fork() failed: %s", strerror(errno));
        return -1;
    }

    if (pid == 0)
    {
        // Child process
        if (ptrace(PTRACE_TRACEME, 0, nullptr, nullptr) < 0)
        {
            debug_log(LOG_ERROR, "PTRACE_TRACEME failed: %s", strerror(errno));
            _exit(1);
        }

        // Prepare argv
        std::vector<char*> argv;
        argv.push_back(const_cast<char*>(request->executable_path.c_str()));
        for (const auto& arg : request->spawn_args)
        {
            argv.push_back(const_cast<char*>(arg.c_str()));
        }
        argv.push_back(nullptr);

        execvp(request->executable_path.c_str(), argv.data());

        // If execvp returns, it failed
        fprintf(stderr, "execvp failed: %s\n", strerror(errno));
        _exit(1);
    }
    else
    {
        // Parent process (debug thread)
        int status;
        pid_t result = waitpid(pid, &status, 0);

        if (result < 0)
        {
            debug_log(LOG_ERROR, "waitpid failed: %s", strerror(errno));
            return -1;
        }

        if (WIFSTOPPED(status))
        {
            int sig = WSTOPSIG(status);
            debug_log(LOG_INFO, "Child process %d stopped with signal %d (TRACEME)", pid, sig);

            // Transition from PTRACE_TRACEME to PTRACE_SEIZE for consistency
            // 1. Send SIGSTOP to ensure process stays stopped after detach
            if (kill(pid, SIGSTOP) < 0)
            {
                debug_log(LOG_ERROR, "Failed to send SIGSTOP to pid %d: %s", pid, strerror(errno));
                return -1;
            }

            // 2. Detach from PTRACE_TRACEME tracing
            if (ptrace(PTRACE_DETACH, pid, nullptr, nullptr) < 0)
            {
                debug_log(LOG_ERROR, "Failed to detach from pid %d: %s", pid, strerror(errno));
                return -1;
            }

            // 3. Wait for SIGSTOP to take effect
            int stop_status;
            pid_t wait_result = waitpid(pid, &stop_status, WUNTRACED);
            if (wait_result != pid || !WIFSTOPPED(stop_status))
            {
                debug_log(LOG_ERROR, "Failed to wait for SIGSTOP on pid %d", pid);
                return -1;
            }

            // 4. Re-attach using PTRACE_SEIZE with PTRACE_O_TRACECLONE
            if (PTRACE_CALL(DYNA_PTRACE_SEIZE, pid, nullptr, PTRACE_O_TRACECLONE) < 0)
            {
                debug_log(LOG_ERROR, "Failed to PTRACE_SEIZE pid %d: %s", pid, strerror(errno));
                return -1;
            }

            // 5. Use PTRACE_INTERRUPT to stop the process under SEIZE tracing
            if (PTRACE_CALL(DYNA_PTRACE_INTERRUPT, pid, nullptr, nullptr) < 0)
            {
                debug_log(LOG_ERROR, "Failed to PTRACE_INTERRUPT pid %d: %s", pid, strerror(errno));
                return -1;
            }

            // 6. Wait for the interrupt-induced stop
            int int_status;
            wait_result = waitpid(pid, &int_status, 0);
            if (wait_result != pid)
            {
                debug_log(LOG_ERROR, "Failed to wait for PTRACE_INTERRUPT on pid %d", pid);
                return -1;
            }

            debug_log(LOG_INFO, "Child process %d re-attached with PTRACE_SEIZE", pid);

            // Update debugger state
            pid_ = pid;
            attached_threads_.insert(pid);
            thread_states_[pid].is_attached = true;
            thread_states_[pid].is_stopped = true;
            thread_states_[pid].current_breakpoint_index = -1;
            thread_states_[pid].single_step_mode = SingleStepMode::None;
            threads_attached_ = true;
            current_thread = pid;
            debug_state_ = DebugState::Paused;

            // Send exception info
#if defined(__aarch64__)
            struct user_pt_regs regs;
            struct iovec iov = {.iov_base = &regs, .iov_len = sizeof(regs)};

            if (ptrace(PTRACE_GETREGSET, pid, NT_PRSTATUS, &iov) == 0)
            {
                NativeExceptionInfo exception_info;
                memset(&exception_info, 0, sizeof(exception_info));
                exception_info.architecture = ARCH_ARM64;
                for (int i = 0; i < 30; i++)
                {
                    exception_info.regs.arm64.x[i] = regs.regs[i];
                }
                exception_info.regs.arm64.lr = regs.regs[30];
                exception_info.regs.arm64.sp = regs.sp;
                exception_info.regs.arm64.pc = regs.pc;
                exception_info.regs.arm64.cpsr = regs.pstate;
                exception_info.regs.arm64.fp = regs.regs[29];
                exception_info.exception_type = EXCEPTION_BREAKPOINT;
                exception_info.thread_id = pid;
                SEND_EXCEPTION_INFO(&exception_info, pid);
            }
#elif defined(__x86_64__)
            struct user_regs_struct regs;
            if (ptrace(PTRACE_GETREGS, pid, nullptr, &regs) == 0)
            {
                NativeExceptionInfo exception_info;
                memset(&exception_info, 0, sizeof(exception_info));
                exception_info.architecture = ARCH_X86_64;
                exception_info.regs.x86_64.rax = regs.rax;
                exception_info.regs.x86_64.rbx = regs.rbx;
                exception_info.regs.x86_64.rcx = regs.rcx;
                exception_info.regs.x86_64.rdx = regs.rdx;
                exception_info.regs.x86_64.rsi = regs.rsi;
                exception_info.regs.x86_64.rdi = regs.rdi;
                exception_info.regs.x86_64.rbp = regs.rbp;
                exception_info.regs.x86_64.rsp = regs.rsp;
                exception_info.regs.x86_64.r8 = regs.r8;
                exception_info.regs.x86_64.r9 = regs.r9;
                exception_info.regs.x86_64.r10 = regs.r10;
                exception_info.regs.x86_64.r11 = regs.r11;
                exception_info.regs.x86_64.r12 = regs.r12;
                exception_info.regs.x86_64.r13 = regs.r13;
                exception_info.regs.x86_64.r14 = regs.r14;
                exception_info.regs.x86_64.r15 = regs.r15;
                exception_info.regs.x86_64.rip = regs.rip;
                exception_info.regs.x86_64.rflags = regs.eflags;
                exception_info.exception_type = EXCEPTION_BREAKPOINT;
                exception_info.thread_id = pid;
                SEND_EXCEPTION_INFO(&exception_info, pid);
            }
#endif

            request->spawned_pid = pid;
            debug_log(LOG_INFO, "Spawn successful in debug thread: pid=%d", pid);
            return 0;
        }
        else if (WIFEXITED(status))
        {
            debug_log(LOG_ERROR, "Child process exited with status %d", WEXITSTATUS(status));
            return -1;
        }
        else if (WIFSIGNALED(status))
        {
            debug_log(LOG_ERROR, "Child process killed by signal %d", WTERMSIG(status));
            return -1;
        }
    }

    return -1;
}

#ifdef TARGET_IS_ANDROID
// PTY spawn not supported on Android
int Debugger::spawn_process_with_pty_internal(std::shared_ptr<DebugRequest> request)
{
    debug_log(LOG_ERROR, "PTY spawn is not supported on Android");
    return -1;
}
#else
// Internal spawn with PTY implementation - runs in debug thread
int Debugger::spawn_process_with_pty_internal(std::shared_ptr<DebugRequest> request)
{
    debug_log(LOG_INFO, "Spawning process with PTY in debug thread: %s",
              request->executable_path.c_str());

    int master_fd;
    pid_t pid;

    // Set up terminal attributes
    struct termios termp;
    memset(&termp, 0, sizeof(termp));
    termp.c_iflag = ICRNL | IXON;
    termp.c_oflag = OPOST | ONLCR;
    termp.c_cflag = B38400 | CS8 | CREAD | CLOCAL;
    termp.c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK;
    termp.c_cc[VMIN] = 1;
    termp.c_cc[VTIME] = 0;

    // Set up window size - use larger default for modern terminals
    struct winsize ws;
    ws.ws_row = 50;
    ws.ws_col = 120;
    ws.ws_xpixel = 0;
    ws.ws_ypixel = 0;

    // Fork with PTY
    pid = forkpty(&master_fd, nullptr, &termp, &ws);

    if (pid < 0)
    {
        debug_log(LOG_ERROR, "forkpty() failed: %s", strerror(errno));
        return -1;
    }

    if (pid == 0)
    {
        // Child process
        if (ptrace(PTRACE_TRACEME, 0, nullptr, nullptr) < 0)
        {
            debug_log(LOG_ERROR, "PTRACE_TRACEME failed: %s", strerror(errno));
            _exit(1);
        }

        // Prepare argv
        std::vector<char*> argv;
        argv.push_back(const_cast<char*>(request->executable_path.c_str()));
        for (const auto& arg : request->spawn_args)
        {
            argv.push_back(const_cast<char*>(arg.c_str()));
        }
        argv.push_back(nullptr);

        execvp(request->executable_path.c_str(), argv.data());

        fprintf(stderr, "execvp failed: %s\n", strerror(errno));
        _exit(1);
    }
    else
    {
        // Parent process (debug thread)

        // Set master_fd to non-blocking
        int flags = fcntl(master_fd, F_GETFL, 0);
        if (flags != -1)
        {
            fcntl(master_fd, F_SETFL, flags | O_NONBLOCK);
        }

        int status;
        pid_t result = waitpid(pid, &status, 0);

        if (result < 0)
        {
            debug_log(LOG_ERROR, "waitpid failed: %s", strerror(errno));
            close(master_fd);
            return -1;
        }

        if (WIFSTOPPED(status))
        {
            int sig = WSTOPSIG(status);
            debug_log(LOG_INFO, "Child process %d stopped with signal %d (PTY TRACEME)", pid, sig);

            // Transition from PTRACE_TRACEME to PTRACE_SEIZE for consistency
            // 1. Send SIGSTOP to ensure process stays stopped after detach
            if (kill(pid, SIGSTOP) < 0)
            {
                debug_log(LOG_ERROR, "Failed to send SIGSTOP to pid %d: %s", pid, strerror(errno));
                close(master_fd);
                return -1;
            }

            // 2. Detach from PTRACE_TRACEME tracing
            if (ptrace(PTRACE_DETACH, pid, nullptr, nullptr) < 0)
            {
                debug_log(LOG_ERROR, "Failed to detach from pid %d: %s", pid, strerror(errno));
                close(master_fd);
                return -1;
            }

            // 3. Wait for SIGSTOP to take effect
            int stop_status;
            pid_t wait_result = waitpid(pid, &stop_status, WUNTRACED);
            if (wait_result != pid || !WIFSTOPPED(stop_status))
            {
                debug_log(LOG_ERROR, "Failed to wait for SIGSTOP on pid %d", pid);
                close(master_fd);
                return -1;
            }

            // 4. Re-attach using PTRACE_SEIZE with PTRACE_O_TRACECLONE
            if (PTRACE_CALL(DYNA_PTRACE_SEIZE, pid, nullptr, PTRACE_O_TRACECLONE) < 0)
            {
                debug_log(LOG_ERROR, "Failed to PTRACE_SEIZE pid %d: %s", pid, strerror(errno));
                close(master_fd);
                return -1;
            }

            // 5. Use PTRACE_INTERRUPT to stop the process under SEIZE tracing
            if (PTRACE_CALL(DYNA_PTRACE_INTERRUPT, pid, nullptr, nullptr) < 0)
            {
                debug_log(LOG_ERROR, "Failed to PTRACE_INTERRUPT pid %d: %s", pid, strerror(errno));
                close(master_fd);
                return -1;
            }

            // 6. Wait for the interrupt-induced stop
            int int_status;
            wait_result = waitpid(pid, &int_status, 0);
            if (wait_result != pid)
            {
                debug_log(LOG_ERROR, "Failed to wait for PTRACE_INTERRUPT on pid %d", pid);
                close(master_fd);
                return -1;
            }

            debug_log(LOG_INFO, "Child process %d re-attached with PTRACE_SEIZE (PTY)", pid);

            // Update debugger state
            pid_ = pid;
            attached_threads_.insert(pid);
            thread_states_[pid].is_attached = true;
            thread_states_[pid].is_stopped = true;
            thread_states_[pid].current_breakpoint_index = -1;
            thread_states_[pid].single_step_mode = SingleStepMode::None;
            threads_attached_ = true;
            current_thread = pid;
            debug_state_ = DebugState::Paused;

            // Send exception info
#if defined(__aarch64__)
            struct user_pt_regs regs;
            struct iovec iov = {.iov_base = &regs, .iov_len = sizeof(regs)};

            if (ptrace(PTRACE_GETREGSET, pid, NT_PRSTATUS, &iov) == 0)
            {
                NativeExceptionInfo exception_info;
                memset(&exception_info, 0, sizeof(exception_info));
                exception_info.architecture = ARCH_ARM64;
                for (int i = 0; i < 30; i++)
                {
                    exception_info.regs.arm64.x[i] = regs.regs[i];
                }
                exception_info.regs.arm64.lr = regs.regs[30];
                exception_info.regs.arm64.sp = regs.sp;
                exception_info.regs.arm64.pc = regs.pc;
                exception_info.regs.arm64.cpsr = regs.pstate;
                exception_info.regs.arm64.fp = regs.regs[29];
                exception_info.exception_type = EXCEPTION_BREAKPOINT;
                exception_info.thread_id = pid;
                SEND_EXCEPTION_INFO(&exception_info, pid);
            }
#elif defined(__x86_64__)
            struct user_regs_struct regs;
            if (ptrace(PTRACE_GETREGS, pid, nullptr, &regs) == 0)
            {
                NativeExceptionInfo exception_info;
                memset(&exception_info, 0, sizeof(exception_info));
                exception_info.architecture = ARCH_X86_64;
                exception_info.regs.x86_64.rax = regs.rax;
                exception_info.regs.x86_64.rbx = regs.rbx;
                exception_info.regs.x86_64.rcx = regs.rcx;
                exception_info.regs.x86_64.rdx = regs.rdx;
                exception_info.regs.x86_64.rsi = regs.rsi;
                exception_info.regs.x86_64.rdi = regs.rdi;
                exception_info.regs.x86_64.rbp = regs.rbp;
                exception_info.regs.x86_64.rsp = regs.rsp;
                exception_info.regs.x86_64.r8 = regs.r8;
                exception_info.regs.x86_64.r9 = regs.r9;
                exception_info.regs.x86_64.r10 = regs.r10;
                exception_info.regs.x86_64.r11 = regs.r11;
                exception_info.regs.x86_64.r12 = regs.r12;
                exception_info.regs.x86_64.r13 = regs.r13;
                exception_info.regs.x86_64.r14 = regs.r14;
                exception_info.regs.x86_64.r15 = regs.r15;
                exception_info.regs.x86_64.rip = regs.rip;
                exception_info.regs.x86_64.rflags = regs.eflags;
                exception_info.exception_type = EXCEPTION_BREAKPOINT;
                exception_info.thread_id = pid;
                SEND_EXCEPTION_INFO(&exception_info, pid);
            }
#endif

            request->spawned_pid = pid;
            request->pty_fd = master_fd;
            debug_log(LOG_INFO, "PTY spawn successful in debug thread: pid=%d, pty_fd=%d", pid,
                      master_fd);
            return 0;
        }
        else if (WIFEXITED(status))
        {
            debug_log(LOG_ERROR, "Child process exited with status %d", WEXITSTATUS(status));
            close(master_fd);
            return -1;
        }
        else if (WIFSIGNALED(status))
        {
            debug_log(LOG_ERROR, "Child process killed by signal %d", WTERMSIG(status));
            close(master_fd);
            return -1;
        }
    }

    return -1;
}
#endif  // !TARGET_IS_ANDROID

```

`src/server/src/cpp/src/linux/debugger/debugger_thread.cpp`:

```cpp
/**
 * @file debugger_thread.cpp
 * @brief Thread management functions for the Linux Debugger class
 *
 * This file contains member functions of the Debugger class that handle
 * thread-related operations including:
 * - Thread enumeration and listing
 * - Thread attachment using ptrace
 * - Debug message loop and event handling
 * - Stopping and resuming threads
 * - Thread state verification
 *
 * These functions are extracted from the main debugger.cpp for better
 * code organization and maintainability.
 */

#include "debugger_internal.h"

std::vector<pid_t> Debugger::get_thread_list()
{
    std::vector<pid_t> threads;
    char task_path[256];
    snprintf(task_path, sizeof(task_path), "/proc/%d/task", pid_);

    DIR* dir = opendir(task_path);
    if (!dir)
    {
        debug_log(LOG_ERROR, "Failed to open task directory: %s", task_path);
        return threads;
    }

    struct dirent* entry;
    while ((entry = readdir(dir)) != nullptr)
    {
        if (entry->d_type == DT_DIR)
        {
            pid_t tid = atoi(entry->d_name);
            if (tid > 0)
            {
                // Check thread state to exclude zombie/dead threads
                char status_path[256];
                snprintf(status_path, sizeof(status_path), "/proc/%d/task/%d/status", pid_, tid);

                FILE* fp = fopen(status_path, "r");
                if (!fp)
                {
                    // Thread may have exited, skip it
                    continue;
                }

                char line[256];
                char state = '\0';
                while (fgets(line, sizeof(line), fp))
                {
                    if (strncmp(line, "State:", 6) == 0)
                    {
                        // Find state character after whitespace
                        const char* state_ptr = line + 6;
                        while (*state_ptr == ' ' || *state_ptr == '\t') state_ptr++;
                        state = *state_ptr;
                        break;
                    }
                }
                fclose(fp);

                // Skip zombie (Z), dead (X/x) threads
                // R=running, S=sleeping, D=disk sleep, T=stopped, t=tracing stop
                if (state == 'Z' || state == 'X' || state == 'x')
                {
                    continue;
                }

                threads.push_back(tid);
            }
        }
    }

    closedir(dir);
    return threads;
}

int Debugger::attach_to_threads()
{
    std::vector<pid_t> threads = get_thread_list();

    for (pid_t tid : threads)
    {
        // Use PTRACE_SEIZE with PTRACE_O_TRACECLONE option
        // This automatically attaches to new threads created via clone()
        if (PTRACE_CALL(DYNA_PTRACE_SEIZE, tid, nullptr, PTRACE_O_TRACECLONE) == -1)
        {
            debug_log(LOG_ERROR, "Failed to seize thread %d: %s", tid, strerror(errno));
            continue;
        }

        // PTRACE_SEIZE doesn't stop the process, so we continue normally
        // No need to wait or continue as the thread remains running

        attached_threads_.insert(tid);
        thread_states_[tid].is_attached = true;
    }

    return attached_threads_.empty() ? -1 : 0;
}

void Debugger::debug_message_loop()
{
    // Attach to all threads if not already attached and we have a valid pid
    // Skip if pid_ is 0 (spawn mode - pid will be set by spawn command)
    if (!threads_attached_ && pid_ != 0)
    {
        int result = attach_to_threads();
        if (result == 0)
        {
            threads_attached_ = true;
        }
        else
        {
            debug_log(LOG_ERROR, "Failed to attach to threads in debug thread (pid=%d)", pid_);
            return;
        }
    }

    while (debug_loop_running_)
    {
        // Process command queue first (this may include spawn commands that set up threads)
        process_command_queue();

        // Handle debug events
        pid_t thread_id;
        int status;

        int result = wait_for_debug_event(&thread_id, &status);
        if (result == 0)
        {
            handle_exception(thread_id, status);
        }

        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
}

int Debugger::wait_for_debug_event(pid_t* thread_id, int* status)
{
    // Wait for any child process
    pid_t tid = waitpid(-1, status, WNOHANG);

    if (tid > 0 && attached_threads_.count(tid) > 0)
    {
        *thread_id = tid;
        return 0;
    }

    return -1;
}

std::vector<pid_t> Debugger::stop_all_threads(pid_t exclude_thread_id,
                                              std::vector<pid_t>* already_stopped_out)
{
    std::vector<pid_t> stopped_threads;

    // With PTRACE_O_TRACECLONE, new threads are automatically attached
    // Just verify our attached_threads_ list against /proc to clean up dead threads
    std::vector<pid_t> current_threads = get_thread_list();
    std::set<pid_t> current_thread_set(current_threads.begin(), current_threads.end());

    // Clean up threads that no longer exist
    for (auto it = attached_threads_.begin(); it != attached_threads_.end();)
    {
        if (current_thread_set.find(*it) == current_thread_set.end())
        {
            thread_states_.erase(*it);
            it = attached_threads_.erase(it);
        }
        else
        {
            ++it;
        }
    }

    // Track which threads have actually stopped to avoid timeout removal
    std::set<pid_t> confirmed_stopped;

    // Send PTRACE_INTERRUPT to all threads except the excluded one and already stopped threads
    for (pid_t tid : attached_threads_)
    {
        // Skip the already-stopped thread (passed as parameter)
        if (tid == exclude_thread_id)
        {
            continue;
        }

        // Check if thread is already stopped (e.g., at a breakpoint)
        auto state_it = thread_states_.find(tid);
        if (state_it != thread_states_.end() && state_it->second.is_stopped)
        {
            stopped_threads.push_back(tid);
            confirmed_stopped.insert(tid);
            // Record this thread as "already stopped" so caller knows not to resume it
            if (already_stopped_out)
            {
                already_stopped_out->push_back(tid);
            }
            continue;
        }

        if (PTRACE_CALL(DYNA_PTRACE_INTERRUPT, tid, nullptr, nullptr) == 0)
        {
            stopped_threads.push_back(tid);
        }
        else
        {
            int err = errno;
            if (err == ESRCH)
            {
                // Thread no longer exists - clean up
                attached_threads_.erase(tid);
                thread_states_.erase(tid);
            }
            else
            {
                debug_log(LOG_ERROR, "Failed to send PTRACE_INTERRUPT to thread %d: %s", tid,
                          strerror(err));
            }
        }
    }

    // Wait for each thread to actually stop using waitpid
    auto start_time = std::chrono::steady_clock::now();
    const auto timeout = std::chrono::milliseconds(5000);  // 5 second timeout

    for (auto it = stopped_threads.begin(); it != stopped_threads.end();)
    {
        pid_t tid = *it;

        // Skip threads that are already confirmed as stopped
        if (confirmed_stopped.find(tid) != confirmed_stopped.end())
        {
            ++it;
            continue;
        }

        int status;

        // Use WNOHANG to avoid blocking indefinitely
        pid_t result = waitpid(tid, &status, WNOHANG);

        if (result == tid)
        {
            // Thread has stopped
            if (WIFSTOPPED(status))
            {
                confirmed_stopped.insert(tid);  // Mark as confirmed stopped
                // Update is_stopped state
                thread_states_[tid].is_stopped = true;
                ++it;
            }
            else
            {
                it = stopped_threads.erase(it);
            }
        }
        else if (result == 0)
        {
            // Thread not ready yet, check timeout
            auto current_time = std::chrono::steady_clock::now();
            if (current_time - start_time > timeout)
            {
                // Only remove threads that haven't been confirmed as stopped
                if (confirmed_stopped.find(tid) == confirmed_stopped.end())
                {
                    it = stopped_threads.erase(it);
                }
                else
                {
                    // Thread is confirmed stopped, keep it
                    ++it;
                }
            }
            else
            {
                // Small delay before checking again
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
                ++it;
            }
        }
        else
        {
            // Error occurred
            debug_log(LOG_ERROR, "Error waiting for thread %d: %s", tid, strerror(errno));
            it = stopped_threads.erase(it);
        }

        // Reset iterator if we've reached the end but still have time
        if (it == stopped_threads.end() && !stopped_threads.empty())
        {
            auto current_time = std::chrono::steady_clock::now();
            if (current_time - start_time < timeout)
            {
                // Check if all remaining threads are confirmed stopped
                bool all_confirmed = true;
                for (pid_t remaining_tid : stopped_threads)
                {
                    if (confirmed_stopped.find(remaining_tid) == confirmed_stopped.end())
                    {
                        all_confirmed = false;
                        break;
                    }
                }

                if (all_confirmed)
                {
                    // All threads are confirmed stopped, no need to continue waiting
                    break;
                }

                it = stopped_threads.begin();
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
            }
        }
    }

    // Cancel PTRACE_INTERRUPT for threads that didn't stop
    cancel_interrupt_for_non_stopped_threads(stopped_threads);

    // Final verification using hardware register access
    // verify_threads_stopped(stopped_threads);

    return stopped_threads;
}

void Debugger::resume_threads(const std::vector<pid_t>& stopped_threads)
{
    for (pid_t tid : stopped_threads)
    {
        // Check if there's a pending signal to deliver
        int signal_to_pass = 0;
        auto state_it = thread_states_.find(tid);
        if (state_it != thread_states_.end())
        {
            signal_to_pass = state_it->second.pending_signal;
            state_it->second.pending_signal = 0;  // Clear after use
        }

        if (PTRACE_CALL(PTRACE_CONT, tid, nullptr, (void*)(long)signal_to_pass) == -1)
        {
            int err = errno;
            if (err == ESRCH)
            {
                // Thread no longer exists - clean up
                attached_threads_.erase(tid);
                thread_states_.erase(tid);
            }
            else
            {
                // Failed to resume but thread still exists
                // Keep is_stopped = true since thread is still stopped
                debug_log(LOG_ERROR, "Failed to resume thread %d: %s (thread remains stopped)", tid,
                          strerror(err));
            }
        }
        else
        {
            if (signal_to_pass != 0)
            {
                debug_log(LOG_INFO, "resume_threads: thread %d resumed with signal %d (%s)", tid,
                          signal_to_pass, strsignal(signal_to_pass));
            }
            // Successfully resumed - now mark as not stopped
            if (state_it != thread_states_.end())
            {
                state_it->second.is_stopped = false;
            }
        }
    }
}

void Debugger::cancel_interrupt_for_non_stopped_threads(const std::vector<pid_t>& stopped_threads)
{
    // Find threads that received PTRACE_INTERRUPT but didn't stop
    std::set<pid_t> stopped_set(stopped_threads.begin(), stopped_threads.end());

    for (pid_t tid : attached_threads_)
    {
        if (stopped_set.find(tid) == stopped_set.end())
        {
            // Check if thread might be in a stopped state we haven't detected
            int status;
            pid_t result = waitpid(tid, &status, WNOHANG);

            if (result == tid && WIFSTOPPED(status))
            {
                // Thread is actually stopped, continue it to cancel the interrupt
                if (PTRACE_CALL(PTRACE_CONT, tid, nullptr, nullptr) == 0)
                {
                    debug_log(LOG_ERROR, "Continued thread %d to cancel PTRACE_INTERRUPT", tid);
                }
                else
                {
                    debug_log(LOG_ERROR, "Failed to continue thread %d: %s", tid, strerror(errno));
                }
            }
        }
    }
}

bool Debugger::verify_threads_stopped(std::vector<pid_t>& threads_to_verify)
{
    for (auto it = threads_to_verify.begin(); it != threads_to_verify.end();)
    {
        pid_t tid = *it;

#if defined(__aarch64__)
        struct user_hwdebug_state test_state;
        memset(&test_state, 0, sizeof(test_state));

        // Try to access debug registers using ARM64 hardware breakpoint regset - this will succeed
        // if thread is stopped
        struct iovec iov;
        iov.iov_base = &test_state;
        iov.iov_len = sizeof(test_state);
        if (ptrace(PTRACE_GETREGSET, tid, NT_ARM_HW_BREAK, &iov) == -1)
        {
            it = threads_to_verify.erase(it);
        }
        else
        {
            ++it;
        }
#elif defined(__x86_64__)
        // x86_64: Try to access debug registers
        errno = 0;
        PTRACE_CALL(PTRACE_PEEKUSER, tid, X86_DR7_OFFSET, nullptr);
        if (errno != 0)
        {
            it = threads_to_verify.erase(it);
        }
        else
        {
            ++it;
        }
#endif
    }

    return threads_to_verify.size() == attached_threads_.size();
}

```

`src/server/src/cpp/src/linux/debugger/debugger_types.h`:

```h
// Type definitions for Linux debugger
// Separated from debugger.h for cleaner organization

#ifndef DEBUGGER_TYPES_H
#define DEBUGGER_TYPES_H

#include <sys/types.h>

#include <condition_variable>
#include <cstdint>
#include <mutex>
#include <string>
#include <vector>

// =============================================================================
// Signal configuration
// =============================================================================

// Configuration for signal catch/pass behavior
struct SignalConfig
{
    bool catch_signal;  // If true, stop and notify UI when signal received
    bool pass_signal;   // If true, deliver signal to process on continue

    // Default: catch=false (don't stop), pass=false (suppress signal, like GDB)
    SignalConfig() : catch_signal(false), pass_signal(false) {}
    SignalConfig(bool catch_sig, bool pass_sig) : catch_signal(catch_sig), pass_signal(pass_sig) {}
};

// =============================================================================
// Debugger enums
// =============================================================================

enum class WatchpointType
{
    READ = 1,
    WRITE = 2,
    READWRITE = 3
};

enum class BreakpointType
{
    HARDWARE = 0,
    SOFTWARE = 1
};

enum class DebugState
{
    Running,
    BreakpointHit,
    WatchpointHit,
    SingleStepping,
    Paused
};

enum class DebugCommand
{
    AttachToThreads,
    SetWatchpoint,
    RemoveWatchpoint,
    SetBreakpoint,
    RemoveBreakpoint,
    ContinueExecution,
    SingleStep,
    ReapplyWatchpoints,
    ReadRegister,
    WriteRegister,
    ReadMemory,
    SpawnProcess,
    SpawnProcessWithPty,
    ResumeUserStoppedThreads
};

// =============================================================================
// Debug request structure
// =============================================================================

// Request structure for queue-based command processing
struct DebugRequest
{
    DebugCommand command;
    std::mutex result_mutex;
    std::condition_variable result_cv;
    bool completed = false;
    int result = -1;

    // Parameters for different commands
    uint64_t address = 0;
    int size = 0;
    WatchpointType watchpoint_type = WatchpointType::READWRITE;
    BreakpointType breakpoint_type = BreakpointType::HARDWARE;
    int hit_count = 0;
    pid_t thread_id = 0;
    std::string reg_name;
    uint64_t reg_value = 0;
    uint64_t* reg_value_ptr = nullptr;

    // Parameters for ReadMemory command
    unsigned char* memory_buffer = nullptr;
    size_t memory_size = 0;
    ssize_t memory_bytes_read = 0;

    // Parameters for SpawnProcess command
    std::string executable_path;
    std::vector<std::string> spawn_args;
    pid_t spawned_pid = 0;
    int pty_fd = -1;  // For SpawnProcessWithPty

    explicit DebugRequest(DebugCommand cmd) : command(cmd) {}
};

#endif  // DEBUGGER_TYPES_H

```

`src/server/src/cpp/src/linux/debugger/debugger_watchpoint.cpp`:

```cpp
/**
 * @file debugger_watchpoint.cpp
 * @brief Watchpoint-related member functions for the Debugger class
 *
 * This file contains all watchpoint management functionality including:
 * - Hardware watchpoint set/remove operations
 * - Watchpoint hit handling
 * - Thread-specific watchpoint application
 * - Watchpoint reapplication after single-step
 *
 * Part of the DynaDbg Linux debugger implementation.
 */

#include "debugger_internal.h"

// =============================================================================
// Public Watchpoint API
// =============================================================================

int Debugger::set_watchpoint(uint64_t address, int size, WatchpointType type)
{
    // Create request and enqueue it to the debug thread
    auto request = std::make_shared<DebugRequest>(DebugCommand::SetWatchpoint);
    request->address = address;
    request->size = size;
    request->watchpoint_type = type;

    enqueue_command(request);

    // Wait for the result
    std::unique_lock<std::mutex> lock(request->result_mutex);
    request->result_cv.wait(lock, [request] { return request->completed; });

    return request->result;
}

int Debugger::remove_watchpoint(uint64_t address)
{
    // Create request and enqueue it to the debug thread
    auto request = std::make_shared<DebugRequest>(DebugCommand::RemoveWatchpoint);
    request->address = address;

    enqueue_command(request);

    // Wait for the result
    std::unique_lock<std::mutex> lock(request->result_mutex);
    request->result_cv.wait(lock, [request] { return request->completed; });

    return request->result;
}

// =============================================================================
// Internal Watchpoint Operations
// =============================================================================

int Debugger::set_watchpoint_internal(uint64_t address, int size, WatchpointType type)
{
    int index = find_free_watchpoint();
    if (index == -1)
    {
        debug_log(LOG_ERROR, "No free watchpoints available");
        return -1;
    }

    // Step 1: Stop all threads, tracking which were already stopped
    std::vector<pid_t> already_stopped;
    std::vector<pid_t> stopped_threads = stop_all_threads(0, &already_stopped);
    if (stopped_threads.empty())
    {
        debug_log(LOG_ERROR, "Failed to stop any threads for watchpoint setup");
        return -1;
    }

    // Step 2: Apply watchpoint to all stopped threads
    bool success = apply_watchpoint_to_threads(stopped_threads, index, address, size, type);

    // Step 3: Resume only threads that were NOT already stopped before this call
    std::set<pid_t> already_stopped_set(already_stopped.begin(), already_stopped.end());
    std::vector<pid_t> threads_to_resume;
    for (pid_t tid : stopped_threads)
    {
        if (already_stopped_set.find(tid) == already_stopped_set.end())
        {
            threads_to_resume.push_back(tid);
        }
    }
    resume_threads(threads_to_resume);

    if (success)
    {
        std::lock_guard<std::mutex> lock(watchpoint_data_mutex_);
        watchpoint_used[index] = true;
        watchpoint_addresses[index] = address;
        watchpoint_sizes[index] = size;
        watchpoint_types[index] = type;

        return 0;
    }
    else
    {
        debug_log(LOG_ERROR, "Failed to apply watchpoint to threads");
        return -1;
    }
}

int Debugger::remove_watchpoint_internal(uint64_t address)
{
    int index = find_watchpoint_index(address);
    if (index == -1)
    {
        debug_log(LOG_ERROR, "Watchpoint not found at address 0x%lx", address);
        return -1;
    }

    // Set the removal flag for this watchpoint
    watchpoint_sync_[index].removing.store(true);
    removing_mask_.fetch_or(1U << index);

    // Wait for any in-progress hit handlers on this watchpoint to complete
    // Use polling instead of pthread_cond_clockwait for compatibility
    {
        const int max_wait_ms = 1000;
        const int poll_interval_ms = 10;
        int waited_ms = 0;

        while (watchpoint_sync_[index].active_handlers.load() > 0 && waited_ms < max_wait_ms)
        {
            std::this_thread::sleep_for(std::chrono::milliseconds(poll_interval_ms));
            waited_ms += poll_interval_ms;
        }

        if (watchpoint_sync_[index].active_handlers.load() > 0)
        {
            debug_log(
                LOG_WARN,
                "Timeout waiting for watchpoint %d handlers (count: %d), proceeding with removal",
                index, watchpoint_sync_[index].active_handlers.load());
        }
    }

    // Step 1: Stop all threads, tracking which were already stopped
    std::vector<pid_t> already_stopped;
    std::vector<pid_t> stopped_threads = stop_all_threads(0, &already_stopped);
    if (stopped_threads.empty())
    {
        debug_log(LOG_ERROR, "Failed to stop any threads for watchpoint removal");
        watchpoint_sync_[index].removing.store(false);
        removing_mask_.fetch_and(~(1U << index));
        return -1;
    }

    // Step 2: Clear watchpoint from all stopped threads
    bool success = clear_watchpoint_from_threads(stopped_threads, index);

    // Step 3: Resume only threads that were NOT already stopped before this call
    std::set<pid_t> already_stopped_set(already_stopped.begin(), already_stopped.end());
    std::vector<pid_t> threads_to_resume;
    for (pid_t tid : stopped_threads)
    {
        if (already_stopped_set.find(tid) == already_stopped_set.end())
        {
            threads_to_resume.push_back(tid);
        }
    }
    resume_threads(threads_to_resume);

    // Cleanup
    watchpoint_sync_[index].removing.store(false);
    removing_mask_.fetch_and(~(1U << index));

    if (success)
    {
        std::lock_guard<std::mutex> lock(watchpoint_data_mutex_);
        watchpoint_used[index] = false;
        watchpoint_addresses[index] = 0;
        watchpoint_sizes[index] = 0;

        return 0;
    }
    else
    {
        debug_log(LOG_ERROR, "Failed to clear watchpoint from threads");
        return -1;
    }
}

// =============================================================================
// Watchpoint Lookup Functions
// =============================================================================

int Debugger::find_free_watchpoint()
{
    std::lock_guard<std::mutex> lock(watchpoint_data_mutex_);
    for (int i = 0; i < MAX_WATCHPOINTS; i++)
    {
        if (!watchpoint_used[i])
        {
            return i;
        }
    }
    return -1;
}

int Debugger::find_watchpoint_index(uint64_t address)
{
    std::lock_guard<std::mutex> lock(watchpoint_data_mutex_);
    for (int i = 0; i < MAX_WATCHPOINTS; i++)
    {
        if (watchpoint_used[i] && watchpoint_addresses[i] == address)
        {
            return i;
        }
    }
    return -1;
}

// =============================================================================
// Watchpoint Helper Functions
// =============================================================================

int Debugger::get_available_watchpoints(pid_t thread)
{
    return MAX_WATCHPOINTS;
}

int Debugger::set_watchpoint_on_thread(pid_t thread, uint64_t address, int size,
                                       WatchpointType type, int index)
{
    return 0;
}

int Debugger::clear_watchpoint_on_thread(pid_t thread, int index)
{
    return 0;
}

int Debugger::remove_watchpoint_by_index(int index)
{
    return 0;
}

// =============================================================================
// Watchpoint Hit Handling
// =============================================================================

int Debugger::handle_watchpoint_hit(pid_t thread, int watchpoint_index)
{
    // Check if watchpoint is being removed using bitmask
    if (removing_mask_.load() & (1U << watchpoint_index))
    {
        // Thread must be resumed even during removal
        if (PTRACE_CALL(PTRACE_CONT, thread, nullptr, nullptr) == -1)
        {
            debug_log(LOG_ERROR, "Failed to continue thread %d after ignored watchpoint: %s",
                      thread, strerror(errno));
        }
        return 0;
    }

    // Increment handler count
    watchpoint_sync_[watchpoint_index].active_handlers.fetch_add(1);

#if defined(__aarch64__)
    // For Linux ARM64, we'll temporarily disable the watchpoint using hardware debug registers
    struct user_hwdebug_state wp_state;
    memset(&wp_state, 0, sizeof(wp_state));

    // Set proper iov length: 8 bytes header + 16 bytes per watchpoint * MAX_WATCHPOINTS
    struct iovec iov = {.iov_base = &wp_state, .iov_len = 8 + 16 * MAX_WATCHPOINTS};

    // Get current watchpoint state
    if (ptrace(PTRACE_GETREGSET, thread, NT_ARM_HW_WATCH, &iov) == -1)
    {
        debug_log(LOG_ERROR, "Failed to get hardware watchpoint state for thread %d: %s", thread,
                  strerror(errno));
        // Decrement handler count
        watchpoint_sync_[watchpoint_index].active_handlers.fetch_sub(1);
        return -1;
    }

    // Store original control register value and watchpoint index for restoration
    {
        std::lock_guard<std::mutex> lock(thread_states_mutex_);
        thread_states_[thread].original_wcr = wp_state.dbg_regs[watchpoint_index].ctrl;
        thread_states_[thread].disabled_watchpoint_index = watchpoint_index;
    }

    // Temporarily disable the watchpoint that was hit
    wp_state.dbg_regs[watchpoint_index].ctrl = 0;

    // Apply the modified state
    if (ptrace(PTRACE_SETREGSET, thread, NT_ARM_HW_WATCH, &iov) == -1)
    {
        debug_log(LOG_ERROR, "Failed to disable watchpoint %d for thread %d: %s", watchpoint_index,
                  thread, strerror(errno));
    }
#elif defined(__x86_64__)
    // x86_64: Temporarily disable the watchpoint using debug registers
    unsigned long dr7 = PTRACE_CALL(PTRACE_PEEKUSER, thread, X86_DR7_OFFSET, nullptr);

    // Store original DR7 for restoration
    {
        std::lock_guard<std::mutex> lock(thread_states_mutex_);
        thread_states_[thread].original_wcr = static_cast<uint32_t>(dr7 & 0xFFFFFFFF);
        thread_states_[thread].disabled_watchpoint_index = watchpoint_index;
    }

    // Clear local enable bit for this watchpoint
    dr7 &= ~(1UL << (watchpoint_index * 2));
    if (PTRACE_CALL(PTRACE_POKEUSER, thread, X86_DR7_OFFSET, (void*)dr7) == -1)
    {
        debug_log(LOG_ERROR, "Failed to disable watchpoint %d for thread %d: %s", watchpoint_index,
                  thread, strerror(errno));
    }
#endif

    // Set thread-specific single step mode to re-enable watchpoint after one instruction
    {
        std::lock_guard<std::mutex> lock(thread_states_mutex_);
        thread_states_[thread].single_step_mode = SingleStepMode::Watchpoint;
        thread_states_[thread].single_step_count = 0;
        thread_states_[thread].current_breakpoint_index = -1;
        thread_states_[thread].is_stopped = false;  // Mark as no longer stopped before single step
    }

    // Enable single step for one instruction
    if (PTRACE_CALL(PTRACE_SINGLESTEP, thread, nullptr, nullptr) == -1)
    {
        debug_log(LOG_ERROR, "Failed to enable single step for thread %d", thread);
        // Decrement handler count
        watchpoint_sync_[watchpoint_index].active_handlers.fetch_sub(1);
        return -1;
    }

    return 0;
}

// =============================================================================
// Thread-Specific Watchpoint Operations
// =============================================================================

bool Debugger::apply_watchpoint_to_threads(const std::vector<pid_t>& threads, int index,
                                           uint64_t address, int size, WatchpointType type)
{
    for (pid_t tid : threads)
    {
#if defined(__aarch64__)
        struct user_hwdebug_state wp_state;
        memset(&wp_state, 0, sizeof(wp_state));

        // Set proper iov length: 8 bytes header + 16 bytes per watchpoint * MAX_WATCHPOINTS
        struct iovec iov = {.iov_base = &wp_state, .iov_len = 8 + 16 * MAX_WATCHPOINTS};

        // Get current watchpoint state using ARM64 hardware watchpoint regset
        if (ptrace(PTRACE_GETREGSET, tid, NT_ARM_HW_WATCH, &iov) == -1)
        {
            debug_log(LOG_ERROR, "Failed to get hardware watchpoint state for thread %d: %s", tid,
                      strerror(errno));
            continue;
        }

        // Re-enable existing watchpoints that have addresses set
        for (int i = 0; i < MAX_WATCHPOINTS; i++)
        {
            if (wp_state.dbg_regs[i].addr != 0)
            {
                wp_state.dbg_regs[i].ctrl = wp_state.dbg_regs[i].ctrl | 1;
            }
        }

        // Determine watchpoint length encoding based on size
        uint32_t arm_length;
        if (size <= 1)
            arm_length = ARM_BREAKPOINT_LEN_1;
        else if (size <= 2)
            arm_length = ARM_BREAKPOINT_LEN_2;
        else if (size <= 4)
            arm_length = ARM_BREAKPOINT_LEN_4;
        else
            arm_length = ARM_BREAKPOINT_LEN_8;

        // Determine access type
        int btype;
        switch (type)
        {
            case WatchpointType::READ:
                btype = ARM_BREAKPOINT_LOAD;
                break;
            case WatchpointType::WRITE:
                btype = ARM_BREAKPOINT_STORE;
                break;
            case WatchpointType::READWRITE:
                btype = ARM_BREAKPOINT_STORE | ARM_BREAKPOINT_LOAD;
                break;
            default:
                btype = ARM_BREAKPOINT_RW;
                break;
        }

        // Set watchpoint address and control register
        // encode_ctrl_reg(ssc, bas, lsc, pmc, enabled) - PMC=2 for EL1
        wp_state.dbg_regs[index].addr = address;
        wp_state.dbg_regs[index].ctrl = encode_ctrl_reg(0, arm_length, btype, 2, 1);

        // Apply the watchpoint state using ARM64 hardware watchpoint regset
        if (ptrace(PTRACE_SETREGSET, tid, NT_ARM_HW_WATCH, &iov) == -1)
        {
            int err = errno;
            if (err == ESRCH)
            {
                continue;
            }
            debug_log(LOG_ERROR, "Failed to set hardware watchpoint for thread %d: %s", tid,
                      strerror(err));
            return false;
        }
#elif defined(__x86_64__)
        // x86_64: Use debug registers DR0-DR3 for watchpoints
        // Set the address in DR0-DR3 (index)
        if (PTRACE_CALL(PTRACE_POKEUSER, tid, x86_dr_offset(index), (void*)address) ==
            -1)
        {
            int err = errno;
            if (err == ESRCH)
            {
                continue;
            }
            debug_log(LOG_ERROR, "Failed to set watchpoint address for thread %d: %s", tid,
                      strerror(err));
            return false;
        }

        // Configure DR7
        unsigned long dr7 = PTRACE_CALL(PTRACE_PEEKUSER, tid, X86_DR7_OFFSET, nullptr);

        // Determine length encoding for x86_64
        int x86_len;
        if (size <= 1)
            x86_len = X86_DR7_LEN_1;
        else if (size <= 2)
            x86_len = X86_DR7_LEN_2;
        else if (size <= 4)
            x86_len = X86_DR7_LEN_4;
        else
            x86_len = X86_DR7_LEN_8;

        // Determine condition (break type)
        int x86_cond;
        switch (type)
        {
            case WatchpointType::WRITE:
                x86_cond = X86_DR7_BREAK_ON_WRITE;
                break;
            case WatchpointType::READ:
            case WatchpointType::READWRITE:
                x86_cond = X86_DR7_BREAK_ON_RW;
                break;
            default:
                x86_cond = X86_DR7_BREAK_ON_RW;
                break;
        }

        // Set local enable bit for this watchpoint
        dr7 |= (1UL << (index * 2));

        // Clear and set condition and length bits
        int shift = 16 + index * 4;
        dr7 &= ~(0xFUL << shift);
        dr7 |= ((x86_cond | (x86_len << 2)) << shift);

        if (PTRACE_CALL(PTRACE_POKEUSER, tid, X86_DR7_OFFSET, (void*)dr7) == -1)
        {
            int err = errno;
            if (err == ESRCH)
            {
                continue;
            }
            debug_log(LOG_ERROR, "Failed to set DR7 for thread %d: %s", tid, strerror(err));
            return false;
        }
#endif
    }
    return true;
}

bool Debugger::apply_watchpoint_to_thread(pid_t tid, int index, uint64_t address, int size,
                                          WatchpointType type)
{
#if defined(__aarch64__)
    struct user_hwdebug_state wp_state;
    memset(&wp_state, 0, sizeof(wp_state));

    struct iovec iov = {.iov_base = &wp_state, .iov_len = 8 + 16 * MAX_WATCHPOINTS};

    if (ptrace(PTRACE_GETREGSET, tid, NT_ARM_HW_WATCH, &iov) == -1)
    {
        debug_log(LOG_ERROR, "Failed to get hardware watchpoint state for thread %d: %s", tid,
                  strerror(errno));
        return false;
    }

    uint32_t arm_length;
    if (size <= 1)
        arm_length = ARM_BREAKPOINT_LEN_1;
    else if (size <= 2)
        arm_length = ARM_BREAKPOINT_LEN_2;
    else if (size <= 4)
        arm_length = ARM_BREAKPOINT_LEN_4;
    else
        arm_length = ARM_BREAKPOINT_LEN_8;

    int btype;
    switch (type)
    {
        case WatchpointType::READ:
            btype = ARM_BREAKPOINT_LOAD;
            break;
        case WatchpointType::WRITE:
            btype = ARM_BREAKPOINT_STORE;
            break;
        case WatchpointType::READWRITE:
            btype = ARM_BREAKPOINT_STORE | ARM_BREAKPOINT_LOAD;
            break;
        default:
            btype = ARM_BREAKPOINT_RW;
            break;
    }

    wp_state.dbg_regs[index].addr = address;
    wp_state.dbg_regs[index].ctrl = encode_ctrl_reg(0, arm_length, btype, 2, 1);

    if (ptrace(PTRACE_SETREGSET, tid, NT_ARM_HW_WATCH, &iov) == -1)
    {
        debug_log(LOG_ERROR, "Failed to set hardware watchpoint for thread %d: %s", tid,
                  strerror(errno));
        return false;
    }
#elif defined(__x86_64__)
    if (PTRACE_CALL(PTRACE_POKEUSER, tid, x86_dr_offset(index), (void*)address) == -1)
    {
        debug_log(LOG_ERROR, "Failed to set watchpoint address for thread %d: %s", tid,
                  strerror(errno));
        return false;
    }

    unsigned long dr7 = PTRACE_CALL(PTRACE_PEEKUSER, tid, X86_DR7_OFFSET, nullptr);

    uint32_t x86_len;
    if (size <= 1)
        x86_len = X86_DR7_LEN_1;
    else if (size <= 2)
        x86_len = X86_DR7_LEN_2;
    else if (size <= 4)
        x86_len = X86_DR7_LEN_4;
    else
        x86_len = X86_DR7_LEN_8;

    uint32_t x86_type;
    switch (type)
    {
        case WatchpointType::WRITE:
            x86_type = X86_DR7_BREAK_ON_WRITE;
            break;
        case WatchpointType::READ:
        case WatchpointType::READWRITE:
        default:
            x86_type = X86_DR7_BREAK_ON_RW;
            break;
    }

    dr7 |= (1UL << (index * 2));
    int shift = 16 + index * 4;
    dr7 &= ~(0xFUL << shift);
    dr7 |= ((x86_type | (x86_len << 2)) << shift);

    if (PTRACE_CALL(PTRACE_POKEUSER, tid, X86_DR7_OFFSET, (void*)dr7) == -1)
    {
        debug_log(LOG_ERROR, "Failed to set DR7 for watchpoint on thread %d: %s", tid,
                  strerror(errno));
        return false;
    }
#endif

    return true;
}

bool Debugger::clear_watchpoint_from_threads(const std::vector<pid_t>& threads, int index)
{
    for (pid_t tid : threads)
    {
#if defined(__aarch64__)
        struct user_hwdebug_state wp_state;
        memset(&wp_state, 0, sizeof(wp_state));

        // Set proper iov length: 8 bytes header + 16 bytes per watchpoint * MAX_WATCHPOINTS
        struct iovec iov = {.iov_base = &wp_state, .iov_len = 8 + 16 * MAX_WATCHPOINTS};

        // Get current watchpoint state using ARM64 hardware watchpoint regset
        if (ptrace(PTRACE_GETREGSET, tid, NT_ARM_HW_WATCH, &iov) == -1)
        {
            int err = errno;
            if (err == ESRCH)
            {
                continue;
            }
            debug_log(LOG_ERROR, "Failed to get hardware watchpoint state for thread %d: %s", tid,
                      strerror(err));
            return false;
        }

        // Clear watchpoint control register to disable
        wp_state.dbg_regs[index].ctrl = 0;
        wp_state.dbg_regs[index].addr = 0;

        // Apply the changes using ARM64 hardware watchpoint regset
        if (ptrace(PTRACE_SETREGSET, tid, NT_ARM_HW_WATCH, &iov) == -1)
        {
            int err = errno;
            if (err == ESRCH)
            {
                continue;
            }
            debug_log(LOG_ERROR, "Failed to clear hardware watchpoint for thread %d: %s", tid,
                      strerror(err));
            return false;
        }
#elif defined(__x86_64__)
        // x86_64: Clear the debug register for this watchpoint
        if (PTRACE_CALL(PTRACE_POKEUSER, tid, x86_dr_offset(index), (void*)0) == -1)
        {
            int err = errno;
            if (err == ESRCH)
            {
                continue;
            }
            debug_log(LOG_ERROR, "Failed to clear watchpoint address for thread %d: %s", tid,
                      strerror(err));
            return false;
        }

        // Clear enable bit in DR7
        unsigned long dr7 = PTRACE_CALL(PTRACE_PEEKUSER, tid, X86_DR7_OFFSET, nullptr);
        dr7 &= ~(1UL << (index * 2));  // Clear local enable bit
        // Clear condition and length bits
        int shift = 16 + index * 4;
        dr7 &= ~(0xFUL << shift);

        if (PTRACE_CALL(PTRACE_POKEUSER, tid, X86_DR7_OFFSET, (void*)dr7) == -1)
        {
            int err = errno;
            if (err == ESRCH)
            {
                continue;
            }
            debug_log(LOG_ERROR, "Failed to clear DR7 for thread %d: %s", tid, strerror(err));
            return false;
        }
#endif
    }

    return true;
}

// =============================================================================
// Watchpoint Reapplication
// =============================================================================

int Debugger::reapply_all_watchpoints_internal()
{
    return reapply_all_watchpoints_internal(0);
}

int Debugger::reapply_all_watchpoints_internal(pid_t already_stopped_thread)
{
    // Step 1: Stop all threads, tracking which were already stopped
    // Note: already_stopped_thread is the watchpoint hit thread which completed single-step
    // It should be resumed after reapply, so we pass it to stop_all_threads to avoid
    // sending PTRACE_INTERRUPT to it (it's already stopped), but we do NOT add it to
    // already_stopped list because it should be resumed.
    std::vector<pid_t> already_stopped;
    std::vector<pid_t> stopped_threads = stop_all_threads(already_stopped_thread, &already_stopped);

    // Add the watchpoint hit thread to stopped_threads first
    // (it needs watchpoints reapplied too, and should be resumed at the end)
    if (already_stopped_thread != 0)
    {
        bool found = false;
        for (pid_t tid : stopped_threads)
        {
            if (tid == already_stopped_thread)
            {
                found = true;
                break;
            }
        }
        if (!found)
        {
            stopped_threads.push_back(already_stopped_thread);
        }
        // Note: Do NOT add to already_stopped - this thread completed watchpoint handling
        // and should be resumed
    }

    // Now check if we have any threads to work with
    if (stopped_threads.empty())
    {
        debug_log(LOG_ERROR, "Failed to stop any threads for watchpoint reapplication");
        return -1;
    }

    // Step 2: Reapply all active watchpoints to all stopped threads
    // Skip watchpoints that are being removed
    bool success = true;
    {
        std::lock_guard<std::mutex> lock(watchpoint_data_mutex_);
        for (int i = 0; i < MAX_WATCHPOINTS; i++)
        {
            // Skip watchpoints that are being removed
            if (watchpoint_sync_[i].removing.load())
            {
                continue;
            }

            if (watchpoint_used[i])
            {
                if (!apply_watchpoint_to_threads(stopped_threads, i, watchpoint_addresses[i],
                                                 watchpoint_sizes[i], watchpoint_types[i]))
                {
                    debug_log(LOG_ERROR, "Failed to reapply watchpoint %d", i);
                    success = false;
                }
            }
        }
    }

    // Step 3: Resume only threads that were NOT already stopped before this call
    // Threads at breakpoints or other watchpoints should remain stopped
    std::set<pid_t> already_stopped_set(already_stopped.begin(), already_stopped.end());
    std::vector<pid_t> threads_to_resume;
    for (pid_t tid : stopped_threads)
    {
        if (already_stopped_set.find(tid) == already_stopped_set.end())
        {
            threads_to_resume.push_back(tid);
            // Update thread state to running
            std::lock_guard<std::mutex> lock(thread_states_mutex_);
            if (thread_states_.find(tid) != thread_states_.end())
            {
                thread_states_[tid].is_stopped = false;
            }
        }
    }
    resume_threads(threads_to_resume);

    if (!success)
    {
        debug_log(LOG_ERROR, "Failed to reapply some watchpoints");
        return -1;
    }

    return 0;
}

```

`src/server/src/cpp/src/linux/elf/elf_parser.cpp`:

```cpp
/**
 * @file elf_parser.cpp
 * @brief ELF file parsing utilities for Linux/Android
 */

#include "elf_parser.h"

#include <elf.h>
#include <fcntl.h>
#include <limits.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

#include <fstream>
#include <sstream>
#include <vector>

#include "../core/memory_io.h"
#include "../core/native_api.h"  // For debug_log

static unsigned char ELF_MAGIC[] = {0x7F, 'E', 'L', 'F'};

bool is_elf64(const char* filename)
{
    int fd = open(filename, O_RDONLY);
    if (fd < 0)
    {
        return false;
    }

    unsigned char e_ident[EI_NIDENT];
    if (read(fd, e_ident, EI_NIDENT) != EI_NIDENT)
    {
        close(fd);
        return false;
    }

    close(fd);

    return (e_ident[EI_CLASS] == ELFCLASS64);
}

bool is_elf(const char* filename)
{
    int fd = open(filename, O_RDONLY);
    if (fd < 0)
    {
        return false;
    }

    unsigned char e_ident[EI_NIDENT];
    bool result = false;

    if (read(fd, e_ident, EI_NIDENT) == EI_NIDENT)
    {
        result = (memcmp(e_ident, ELF_MAGIC, 4) == 0);
    }

    close(fd);
    return result;
}

bool read_elf_header_from_memory(int pid, uintptr_t base_address, Elf64_Ehdr* elf_header)
{
    if (read_memory_native(pid, base_address, sizeof(Elf64_Ehdr),
                           reinterpret_cast<unsigned char*>(elf_header)) != sizeof(Elf64_Ehdr))
    {
        return false;
    }
    return true;
}

bool read_elf_header_from_file(const char* filename, Elf64_Ehdr* elf_header)
{
    int fd = open(filename, O_RDONLY);
    if (fd < 0)
    {
        return false;
    }

    if (read(fd, elf_header, sizeof(Elf64_Ehdr)) != sizeof(Elf64_Ehdr))
    {
        close(fd);
        return false;
    }

    close(fd);
    return true;
}

bool compare_elf_headers(int pid, uintptr_t base_address, const char* filename)
{
    Elf64_Ehdr mem_elf_header;
    Elf64_Ehdr file_elf_header;

    if (!read_elf_header_from_memory(pid, base_address, &mem_elf_header))
    {
        return false;
    }

    if (!read_elf_header_from_file(filename, &file_elf_header))
    {
        return false;
    }
    return memcmp(&mem_elf_header, &file_elf_header, sizeof(Elf64_Ehdr)) == 0;
}

/**
 * Get .text section offset relative to the ELF base (first LOAD segment's p_vaddr)
 * This is needed for PIE executables where vaddr is not the actual offset from load base
 * Returns 0 if .text section is not found
 */
uintptr_t get_text_section_offset(const char* filename)
{
    int fd = open(filename, O_RDONLY);
    if (fd < 0)
    {
        return 0;
    }

    struct stat st;
    if (fstat(fd, &st) < 0)
    {
        close(fd);
        return 0;
    }

    void* mapped = mmap(nullptr, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
    if (mapped == MAP_FAILED)
    {
        close(fd);
        return 0;
    }

    Elf64_Ehdr* ehdr = (Elf64_Ehdr*)mapped;
    if (memcmp(ehdr->e_ident, ELFMAG, SELFMAG) != 0)
    {
        munmap(mapped, st.st_size);
        close(fd);
        return 0;
    }

    bool is_64bit = (ehdr->e_ident[EI_CLASS] == ELFCLASS64);
    uintptr_t text_vaddr = 0;
    uintptr_t base_vaddr = 0;

    if (is_64bit)
    {
        Elf64_Phdr* phdrs = (Elf64_Phdr*)((char*)mapped + ehdr->e_phoff);
        for (int i = 0; i < ehdr->e_phnum; i++)
        {
            if (phdrs[i].p_type == PT_LOAD)
            {
                base_vaddr = phdrs[i].p_vaddr;
                break;
            }
        }

        Elf64_Shdr* shdrs = (Elf64_Shdr*)((char*)mapped + ehdr->e_shoff);
        Elf64_Shdr* shstrtab = &shdrs[ehdr->e_shstrndx];
        char* shstrtab_data = (char*)mapped + shstrtab->sh_offset;

        for (int i = 0; i < ehdr->e_shnum; i++)
        {
            char* section_name = shstrtab_data + shdrs[i].sh_name;
            if (strcmp(section_name, ".text") == 0)
            {
                text_vaddr = shdrs[i].sh_addr;
                break;
            }
        }
    }
    else
    {
        Elf32_Ehdr* ehdr32 = (Elf32_Ehdr*)mapped;

        Elf32_Phdr* phdrs = (Elf32_Phdr*)((char*)mapped + ehdr32->e_phoff);
        for (int i = 0; i < ehdr32->e_phnum; i++)
        {
            if (phdrs[i].p_type == PT_LOAD)
            {
                base_vaddr = phdrs[i].p_vaddr;
                break;
            }
        }

        Elf32_Shdr* shdrs = (Elf32_Shdr*)((char*)mapped + ehdr32->e_shoff);
        Elf32_Shdr* shstrtab = &shdrs[ehdr32->e_shstrndx];
        char* shstrtab_data = (char*)mapped + shstrtab->sh_offset;

        for (int i = 0; i < ehdr32->e_shnum; i++)
        {
            char* section_name = shstrtab_data + shdrs[i].sh_name;
            if (strcmp(section_name, ".text") == 0)
            {
                text_vaddr = shdrs[i].sh_addr;
                break;
            }
        }
    }

    munmap(mapped, st.st_size);
    close(fd);

    if (text_vaddr == 0)
    {
        return 0;
    }
    return text_vaddr - base_vaddr;
}

// Note: get_module_path has been moved to native_api.cpp

std::vector<SymbolInfo> parse_elf_symbols(const std::string& elf_path, uintptr_t module_base)
{
    std::vector<SymbolInfo> symbols;

    int fd = open(elf_path.c_str(), O_RDONLY);
    if (fd < 0)
    {
        debug_log(LOG_ERROR, "Failed to open ELF file: %s", elf_path.c_str());
        return symbols;
    }

    struct stat st;
    if (fstat(fd, &st) < 0)
    {
        debug_log(LOG_ERROR, "Failed to stat ELF file: %s", elf_path.c_str());
        close(fd);
        return symbols;
    }

    void* mapped = mmap(nullptr, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
    if (mapped == MAP_FAILED)
    {
        debug_log(LOG_ERROR, "Failed to mmap ELF file: %s", elf_path.c_str());
        close(fd);
        return symbols;
    }

    Elf64_Ehdr* ehdr = (Elf64_Ehdr*)mapped;
    if (memcmp(ehdr->e_ident, ELFMAG, SELFMAG) != 0)
    {
        debug_log(LOG_ERROR, "Invalid ELF magic in file: %s", elf_path.c_str());
        munmap(mapped, st.st_size);
        close(fd);
        return symbols;
    }

    bool is_64bit = (ehdr->e_ident[EI_CLASS] == ELFCLASS64);

    if (is_64bit)
    {
        // Boundary checks
        if (ehdr->e_shoff == 0 || ehdr->e_shnum == 0 ||
            ehdr->e_shoff + ehdr->e_shnum * sizeof(Elf64_Shdr) > (size_t)st.st_size)
        {
            debug_log(LOG_ERROR, "Invalid section header in file: %s", elf_path.c_str());
            munmap(mapped, st.st_size);
            close(fd);
            return symbols;
        }

        if (ehdr->e_shstrndx >= ehdr->e_shnum)
        {
            debug_log(LOG_ERROR, "Invalid section string table index in file: %s",
                      elf_path.c_str());
            munmap(mapped, st.st_size);
            close(fd);
            return symbols;
        }

        Elf64_Shdr* shdrs = (Elf64_Shdr*)((char*)mapped + ehdr->e_shoff);
        Elf64_Shdr* shstrtab = &shdrs[ehdr->e_shstrndx];

        if (shstrtab->sh_offset + shstrtab->sh_size > (size_t)st.st_size)
        {
            debug_log(LOG_ERROR, "Invalid string table in file: %s", elf_path.c_str());
            munmap(mapped, st.st_size);
            close(fd);
            return symbols;
        }

        char* shstrtab_data = (char*)mapped + shstrtab->sh_offset;

        Elf64_Shdr* symtab = nullptr;
        Elf64_Shdr* strtab = nullptr;
        Elf64_Shdr* dynsym = nullptr;
        Elf64_Shdr* dynstr = nullptr;
        Elf64_Shdr* rela_plt = nullptr;
        Elf64_Shdr* plt_section = nullptr;

        for (int i = 0; i < ehdr->e_shnum; i++)
        {
            if (shdrs[i].sh_name >= shstrtab->sh_size) continue;
            char* section_name = shstrtab_data + shdrs[i].sh_name;

            if (strcmp(section_name, ".symtab") == 0)
                symtab = &shdrs[i];
            else if (strcmp(section_name, ".strtab") == 0)
                strtab = &shdrs[i];
            else if (strcmp(section_name, ".dynsym") == 0)
                dynsym = &shdrs[i];
            else if (strcmp(section_name, ".dynstr") == 0)
                dynstr = &shdrs[i];
            else if (strcmp(section_name, ".rela.plt") == 0 ||
                     strcmp(section_name, ".rel.plt") == 0)
                rela_plt = &shdrs[i];
            else if (strcmp(section_name, ".plt") == 0)
                plt_section = &shdrs[i];
        }

        if (!symtab)
        {
            symtab = dynsym;
            strtab = dynstr;
        }

        if (symtab && strtab)
        {
            if (symtab->sh_offset + symtab->sh_size > (size_t)st.st_size ||
                strtab->sh_offset + strtab->sh_size > (size_t)st.st_size)
            {
                debug_log(LOG_ERROR, "Invalid symbol/string table bounds in file: %s",
                          elf_path.c_str());
                munmap(mapped, st.st_size);
                close(fd);
                return symbols;
            }

            Elf64_Sym* syms = (Elf64_Sym*)((char*)mapped + symtab->sh_offset);
            char* strtab_data = (char*)mapped + strtab->sh_offset;
            int sym_count = symtab->sh_size / sizeof(Elf64_Sym);

            for (int i = 0; i < sym_count; i++)
            {
                Elf64_Sym* sym = &syms[i];

                if (sym->st_shndx == SHN_UNDEF) continue;
                if (sym->st_name == 0) continue;
                if (sym->st_name >= strtab->sh_size) continue;

                char* name = strtab_data + sym->st_name;
                if (strlen(name) == 0) continue;

                SymbolInfo symbol_info;
                symbol_info.address = module_base + sym->st_value;
                symbol_info.name = strdup(name);
                symbol_info.size = sym->st_size;
                symbol_info.module_base = module_base;
                symbol_info.file_name = strdup(elf_path.c_str());
                symbol_info.line_number = 0;

                int sym_type = ELF64_ST_TYPE(sym->st_info);
                switch (sym_type)
                {
                    case STT_FUNC:
                    case STT_GNU_IFUNC:
                        symbol_info.type = strdup("Function");
                        break;
                    case STT_OBJECT:
                        symbol_info.type = strdup("Variable");
                        break;
                    case STT_SECTION:
                        symbol_info.type = strdup("Section");
                        break;
                    case STT_FILE:
                        symbol_info.type = strdup("File");
                        break;
                    default:
                        symbol_info.type = strdup("Unknown");
                        break;
                }

                int sym_bind = ELF64_ST_BIND(sym->st_info);
                switch (sym_bind)
                {
                    case STB_GLOBAL:
                        symbol_info.scope = strdup("Global");
                        break;
                    case STB_LOCAL:
                        symbol_info.scope = strdup("Local");
                        break;
                    case STB_WEAK:
                        symbol_info.scope = strdup("Weak");
                        break;
                    default:
                        symbol_info.scope = strdup("Unknown");
                        break;
                }

                symbols.push_back(symbol_info);
            }
        }

        // Parse PLT entries
        if (rela_plt && dynsym && dynstr && plt_section)
        {
            Elf64_Sym* dynsyms = (Elf64_Sym*)((char*)mapped + dynsym->sh_offset);
            char* dynstr_data = (char*)mapped + dynstr->sh_offset;

            uintptr_t plt_base = plt_section->sh_addr;
            size_t plt_entry_size = 16;

            bool is_arm64 = (ehdr->e_machine == EM_AARCH64);
            size_t plt_header_size = is_arm64 ? 32 : 16;

            bool is_rela = (rela_plt->sh_type == SHT_RELA);

            if (is_rela)
            {
                Elf64_Rela* relas = (Elf64_Rela*)((char*)mapped + rela_plt->sh_offset);
                int rela_count = rela_plt->sh_size / sizeof(Elf64_Rela);

                for (int i = 0; i < rela_count; i++)
                {
                    Elf64_Rela* rela = &relas[i];
                    int sym_idx = ELF64_R_SYM(rela->r_info);

                    if (sym_idx == 0) continue;

                    Elf64_Sym* sym = &dynsyms[sym_idx];
                    if (sym->st_name == 0) continue;

                    char* name = dynstr_data + sym->st_name;
                    if (strlen(name) == 0) continue;

                    uintptr_t plt_entry_addr = plt_base + plt_header_size + i * plt_entry_size;

                    SymbolInfo symbol_info;
                    symbol_info.address = module_base + plt_entry_addr;

                    std::string plt_name = std::string(name) + "@plt";
                    symbol_info.name = strdup(plt_name.c_str());
                    symbol_info.size = plt_entry_size;
                    symbol_info.module_base = module_base;
                    symbol_info.file_name = strdup(elf_path.c_str());
                    symbol_info.line_number = 0;
                    symbol_info.type = strdup("Function");
                    symbol_info.scope = strdup("PLT");

                    symbols.push_back(symbol_info);
                }
            }
            else
            {
                Elf64_Rel* rels = (Elf64_Rel*)((char*)mapped + rela_plt->sh_offset);
                int rel_count = rela_plt->sh_size / sizeof(Elf64_Rel);

                for (int i = 0; i < rel_count; i++)
                {
                    Elf64_Rel* rel = &rels[i];
                    int sym_idx = ELF64_R_SYM(rel->r_info);

                    if (sym_idx == 0) continue;

                    Elf64_Sym* sym = &dynsyms[sym_idx];
                    if (sym->st_name == 0) continue;

                    char* name = dynstr_data + sym->st_name;
                    if (strlen(name) == 0) continue;

                    uintptr_t plt_entry_addr = plt_base + plt_header_size + i * plt_entry_size;

                    SymbolInfo symbol_info;
                    symbol_info.address = module_base + plt_entry_addr;

                    std::string plt_name = std::string(name) + "@plt";
                    symbol_info.name = strdup(plt_name.c_str());
                    symbol_info.size = plt_entry_size;
                    symbol_info.module_base = module_base;
                    symbol_info.file_name = strdup(elf_path.c_str());
                    symbol_info.line_number = 0;
                    symbol_info.type = strdup("Function");
                    symbol_info.scope = strdup("PLT");

                    symbols.push_back(symbol_info);
                }
            }
        }
    }
    else
    {
        // 32-bit ELF parsing
        Elf32_Ehdr* ehdr32 = (Elf32_Ehdr*)mapped;
        Elf32_Shdr* shdrs = (Elf32_Shdr*)((char*)mapped + ehdr32->e_shoff);
        Elf32_Shdr* shstrtab = &shdrs[ehdr32->e_shstrndx];
        char* shstrtab_data = (char*)mapped + shstrtab->sh_offset;

        Elf32_Shdr* symtab = nullptr;
        Elf32_Shdr* strtab = nullptr;
        Elf32_Shdr* dynsym = nullptr;
        Elf32_Shdr* dynstr = nullptr;
        Elf32_Shdr* rel_plt = nullptr;
        Elf32_Shdr* plt_section = nullptr;

        for (int i = 0; i < ehdr32->e_shnum; i++)
        {
            char* section_name = shstrtab_data + shdrs[i].sh_name;

            if (strcmp(section_name, ".symtab") == 0)
                symtab = &shdrs[i];
            else if (strcmp(section_name, ".strtab") == 0)
                strtab = &shdrs[i];
            else if (strcmp(section_name, ".dynsym") == 0)
                dynsym = &shdrs[i];
            else if (strcmp(section_name, ".dynstr") == 0)
                dynstr = &shdrs[i];
            else if (strcmp(section_name, ".rel.plt") == 0 ||
                     strcmp(section_name, ".rela.plt") == 0)
                rel_plt = &shdrs[i];
            else if (strcmp(section_name, ".plt") == 0)
                plt_section = &shdrs[i];
        }

        if (!symtab)
        {
            symtab = dynsym;
            strtab = dynstr;
        }

        if (symtab && strtab)
        {
            Elf32_Sym* syms = (Elf32_Sym*)((char*)mapped + symtab->sh_offset);
            char* strtab_data = (char*)mapped + strtab->sh_offset;
            int sym_count = symtab->sh_size / sizeof(Elf32_Sym);

            for (int i = 0; i < sym_count; i++)
            {
                Elf32_Sym* sym = &syms[i];

                if (sym->st_shndx == SHN_UNDEF) continue;
                if (sym->st_name == 0) continue;

                char* name = strtab_data + sym->st_name;
                if (strlen(name) == 0) continue;

                SymbolInfo symbol_info;
                symbol_info.address = module_base + sym->st_value;
                symbol_info.name = strdup(name);
                symbol_info.size = sym->st_size;
                symbol_info.module_base = module_base;
                symbol_info.file_name = strdup(elf_path.c_str());
                symbol_info.line_number = 0;

                int sym_type = ELF32_ST_TYPE(sym->st_info);
                switch (sym_type)
                {
                    case STT_FUNC:
                    case STT_GNU_IFUNC:
                        symbol_info.type = strdup("Function");
                        break;
                    case STT_OBJECT:
                        symbol_info.type = strdup("Variable");
                        break;
                    case STT_SECTION:
                        symbol_info.type = strdup("Section");
                        break;
                    case STT_FILE:
                        symbol_info.type = strdup("File");
                        break;
                    default:
                        symbol_info.type = strdup("Unknown");
                        break;
                }

                int sym_bind = ELF32_ST_BIND(sym->st_info);
                switch (sym_bind)
                {
                    case STB_GLOBAL:
                        symbol_info.scope = strdup("Global");
                        break;
                    case STB_LOCAL:
                        symbol_info.scope = strdup("Local");
                        break;
                    case STB_WEAK:
                        symbol_info.scope = strdup("Weak");
                        break;
                    default:
                        symbol_info.scope = strdup("Unknown");
                        break;
                }

                symbols.push_back(symbol_info);
            }
        }

        // Parse PLT entries for 32-bit
        if (rel_plt && dynsym && dynstr && plt_section)
        {
            Elf32_Sym* dynsyms = (Elf32_Sym*)((char*)mapped + dynsym->sh_offset);
            char* dynstr_data = (char*)mapped + dynstr->sh_offset;

            uintptr_t plt_base = plt_section->sh_addr;
            size_t plt_entry_size = 16;

            bool is_arm = (ehdr32->e_machine == EM_ARM);
            size_t plt_header_size = is_arm ? 20 : 16;

            bool is_rela = (rel_plt->sh_type == SHT_RELA);

            if (is_rela)
            {
                Elf32_Rela* relas = (Elf32_Rela*)((char*)mapped + rel_plt->sh_offset);
                int rela_count = rel_plt->sh_size / sizeof(Elf32_Rela);

                for (int i = 0; i < rela_count; i++)
                {
                    Elf32_Rela* rela = &relas[i];
                    int sym_idx = ELF32_R_SYM(rela->r_info);

                    if (sym_idx == 0) continue;

                    Elf32_Sym* sym = &dynsyms[sym_idx];
                    if (sym->st_name == 0) continue;

                    char* name = dynstr_data + sym->st_name;
                    if (strlen(name) == 0) continue;

                    uintptr_t plt_entry_addr = plt_base + plt_header_size + i * plt_entry_size;

                    SymbolInfo symbol_info;
                    symbol_info.address = module_base + plt_entry_addr;

                    std::string plt_name = std::string(name) + "@plt";
                    symbol_info.name = strdup(plt_name.c_str());
                    symbol_info.size = plt_entry_size;
                    symbol_info.module_base = module_base;
                    symbol_info.file_name = strdup(elf_path.c_str());
                    symbol_info.line_number = 0;
                    symbol_info.type = strdup("Function");
                    symbol_info.scope = strdup("PLT");

                    symbols.push_back(symbol_info);
                }
            }
            else
            {
                Elf32_Rel* rels = (Elf32_Rel*)((char*)mapped + rel_plt->sh_offset);
                int rel_count = rel_plt->sh_size / sizeof(Elf32_Rel);

                for (int i = 0; i < rel_count; i++)
                {
                    Elf32_Rel* rel = &rels[i];
                    int sym_idx = ELF32_R_SYM(rel->r_info);

                    if (sym_idx == 0) continue;

                    Elf32_Sym* sym = &dynsyms[sym_idx];
                    if (sym->st_name == 0) continue;

                    char* name = dynstr_data + sym->st_name;
                    if (strlen(name) == 0) continue;

                    uintptr_t plt_entry_addr = plt_base + plt_header_size + i * plt_entry_size;

                    SymbolInfo symbol_info;
                    symbol_info.address = module_base + plt_entry_addr;

                    std::string plt_name = std::string(name) + "@plt";
                    symbol_info.name = strdup(plt_name.c_str());
                    symbol_info.size = plt_entry_size;
                    symbol_info.module_base = module_base;
                    symbol_info.file_name = strdup(elf_path.c_str());
                    symbol_info.line_number = 0;
                    symbol_info.type = strdup("Function");
                    symbol_info.scope = strdup("PLT");

                    symbols.push_back(symbol_info);
                }
            }
        }
    }

    munmap(mapped, st.st_size);
    close(fd);

    return symbols;
}

extern "C" SymbolInfo* enumerate_symbols(int pid, uintptr_t module_base, size_t* count)
{
    *count = 0;

    std::string module_path = get_module_path(pid, module_base);
    if (module_path.empty())
    {
        debug_log(LOG_ERROR, "Failed to find module path for base address 0x%lx in pid %d",
                  module_base, pid);
        return nullptr;
    }

    std::vector<SymbolInfo> symbols = parse_elf_symbols(module_path, module_base);

    if (symbols.empty())
    {
        return nullptr;
    }

    SymbolInfo* result = (SymbolInfo*)malloc(symbols.size() * sizeof(SymbolInfo));
    if (!result)
    {
        debug_log(LOG_ERROR, "Failed to allocate memory for symbols array");
        return nullptr;
    }

    for (size_t i = 0; i < symbols.size(); i++)
    {
        result[i] = symbols[i];
    }

    *count = symbols.size();

    return result;
}

```

`src/server/src/cpp/src/linux/elf/elf_parser.h`:

```h
/**
 * @file elf_parser.h
 * @brief ELF file parsing utilities for Linux/Android
 *
 * Provides functions for:
 * - ELF file detection and validation
 * - ELF header reading from file and memory
 * - Symbol table parsing (symtab, dynsym, PLT)
 *
 */

#ifndef ELF_PARSER_H
#define ELF_PARSER_H

#include <elf.h>
#include <sys/types.h>

#include <cstddef>
#include <cstdint>
#include <string>
#include <vector>

#include "../core/native_api.h"  // For ModuleInfo, SymbolInfo

/**
 * Check if a file is an ELF file
 */
bool is_elf(const char* filename);

/**
 * Check if a file is a 64-bit ELF file
 */
bool is_elf64(const char* filename);

/**
 * Read ELF header from process memory
 */
bool read_elf_header_from_memory(int pid, uintptr_t base_address, Elf64_Ehdr* elf_header);

/**
 * Read ELF header from file
 */
bool read_elf_header_from_file(const char* filename, Elf64_Ehdr* elf_header);

/**
 * Compare ELF headers between memory and file
 * Used to verify module base address matches file
 */
bool compare_elf_headers(int pid, uintptr_t base_address, const char* filename);

/**
 * Get .text section offset relative to ELF base
 * Used for module enumeration to find executable sections
 * @param filename Path to ELF file
 * @return Offset of .text section, or 0 if not found
 */
uintptr_t get_text_section_offset(const char* filename);

/**
 * Enumerate symbols from an ELF module
 * @param pid Process ID
 * @param module_base Base address of the module
 * @param count Output: number of symbols found
 * @return Array of SymbolInfo, caller must free
 */
extern "C" SymbolInfo* enum_symbols_native(int pid, uintptr_t module_base, size_t* count);

/**
 * Parse ELF symbols from file
 * @param elf_path Path to ELF file
 * @param module_base Base address in memory
 * @return Vector of SymbolInfo
 */
std::vector<SymbolInfo> parse_elf_symbols(const std::string& elf_path, uintptr_t module_base);

#endif  // ELF_PARSER_H

```

`src/server/src/cpp/src/linux/pty/pty_manager.cpp`:

```cpp
/**
 * @file pty_manager.cpp
 * @brief Pseudo-terminal (PTY) management for process I/O
 */

#include "pty_manager.h"

#include <errno.h>
#include <string.h>
#include <sys/ioctl.h>
#include <termios.h>
#include <unistd.h>

#include <map>
#include <mutex>
#include <string>
#include <vector>

#include "../core/native_api.h"  // For debug_log
#include "../debugger/debugger.h"

// Global storage for PTY file descriptors (indexed by PID)
static std::map<pid_t, int> g_pty_fds;
static std::mutex g_pty_mutex;

int spawn_process_with_pty(const char* executable_path, const char** args, int argc, pid_t* out_pid,
                           int* out_pty_fd)
{
    debug_log(LOG_INFO, "Spawning process with PTY: %s with %d args", executable_path, argc);

    // Destroy existing debugger if any
    if (g_debugger != nullptr)
    {
        debug_log(LOG_INFO, "Destroying existing debugger before PTY spawn");
        delete g_debugger;
        g_debugger = nullptr;
    }

    // Create debugger with pid=0 (will be set during spawn)
    g_debugger = new Debugger();
    if (!g_debugger->initialize())
    {
        debug_log(LOG_ERROR, "Failed to initialize debugger");
        delete g_debugger;
        g_debugger = nullptr;
        return -1;
    }

    // Start the debug thread
    g_debugger->run();

    // Prepare arguments
    std::vector<std::string> spawn_args;
    for (int i = 0; i < argc; i++)
    {
        spawn_args.push_back(args[i]);
    }

    // Spawn process with PTY in debug thread
    pid_t pid = 0;
    int pty_fd = -1;
    int result = g_debugger->spawn_process_with_pty(executable_path, spawn_args, &pid, &pty_fd);

    if (result == 0)
    {
        if (out_pid != nullptr)
        {
            *out_pid = pid;
        }
        if (out_pty_fd != nullptr)
        {
            *out_pty_fd = pty_fd;
        }

        // Store PTY fd
        {
            std::lock_guard<std::mutex> lock(g_pty_mutex);
            g_pty_fds[pid] = pty_fd;
        }

        debug_log(LOG_INFO, "PTY spawn successful: pid=%d, pty_fd=%d", pid, pty_fd);
    }
    else
    {
        debug_log(LOG_ERROR, "PTY spawn failed");
        delete g_debugger;
        g_debugger = nullptr;
    }

    return result;
}

ssize_t read_pty(int pty_fd, char* buffer, size_t buffer_size)
{
    if (pty_fd < 0 || buffer == nullptr || buffer_size == 0)
    {
        return -1;
    }

    ssize_t bytes_read = read(pty_fd, buffer, buffer_size);

    if (bytes_read < 0)
    {
        if (errno == EAGAIN || errno == EWOULDBLOCK)
        {
            // No data available (non-blocking)
            return 0;
        }
        debug_log(LOG_ERROR, "read_pty failed: %s", strerror(errno));
        return -1;
    }

    return bytes_read;
}

ssize_t write_pty(int pty_fd, const char* data, size_t data_len)
{
    if (pty_fd < 0 || data == nullptr || data_len == 0)
    {
        return -1;
    }

    ssize_t bytes_written = write(pty_fd, data, data_len);

    if (bytes_written < 0)
    {
        debug_log(LOG_ERROR, "write_pty failed: %s", strerror(errno));
        return -1;
    }

    return bytes_written;
}

void close_pty(int pty_fd)
{
    if (pty_fd >= 0)
    {
        close(pty_fd);

        // Remove from global map
        std::lock_guard<std::mutex> lock(g_pty_mutex);
        for (auto it = g_pty_fds.begin(); it != g_pty_fds.end(); ++it)
        {
            if (it->second == pty_fd)
            {
                g_pty_fds.erase(it);
                break;
            }
        }
    }
}

int get_pty_size(int pty_fd, int* rows, int* cols)
{
    struct winsize ws;
    if (ioctl(pty_fd, TIOCGWINSZ, &ws) < 0)
    {
        debug_log(LOG_ERROR, "TIOCGWINSZ failed: %s", strerror(errno));
        return -1;
    }

    if (rows != nullptr) *rows = ws.ws_row;
    if (cols != nullptr) *cols = ws.ws_col;

    return 0;
}

int set_pty_size(int pty_fd, int rows, int cols)
{
    struct winsize ws;
    ws.ws_row = rows;
    ws.ws_col = cols;
    ws.ws_xpixel = 0;
    ws.ws_ypixel = 0;

    if (ioctl(pty_fd, TIOCSWINSZ, &ws) < 0)
    {
        debug_log(LOG_ERROR, "TIOCSWINSZ failed: %s", strerror(errno));
        return -1;
    }

    return 0;
}

```

`src/server/src/cpp/src/linux/pty/pty_manager.h`:

```h
/**
 * @file pty_manager.h
 * @brief Pseudo-terminal (PTY) management for process I/O
 *
 * Provides PTY-based process spawning and I/O operations.
 * PTY allows capturing stdout/stderr and sending stdin to spawned processes.
 */

#ifndef PTY_MANAGER_H
#define PTY_MANAGER_H

#include <sys/types.h>

#include <cstddef>

#ifdef __cplusplus
extern "C"
{
#endif

    /**
     * Spawn a new process with PTY (pseudo terminal) for I/O
     * @param executable_path Path to executable
     * @param args Array of argument strings
     * @param argc Number of arguments
     * @param out_pid Output: spawned process ID
     * @param out_pty_fd Output: PTY file descriptor for I/O
     * @return 0 on success, -1 on failure
     */
    int spawn_process_with_pty(const char* executable_path, const char** args, int argc,
                               pid_t* out_pid, int* out_pty_fd);

    /**
     * Read from PTY (non-blocking)
     * @param pty_fd PTY file descriptor
     * @param buffer Output buffer
     * @param buffer_size Buffer size
     * @return Number of bytes read, 0 if no data available, -1 on error
     */
    ssize_t read_pty(int pty_fd, char* buffer, size_t buffer_size);

    /**
     * Write to PTY
     * @param pty_fd PTY file descriptor
     * @param data Data to write
     * @param data_len Data length
     * @return Number of bytes written, -1 on error
     */
    ssize_t write_pty(int pty_fd, const char* data, size_t data_len);

    /**
     * Close PTY and cleanup resources
     * @param pty_fd PTY file descriptor
     */
    void close_pty(int pty_fd);

    /**
     * Get PTY window size
     * @param pty_fd PTY file descriptor
     * @param rows Output: number of rows
     * @param cols Output: number of columns
     * @return 0 on success, -1 on error
     */
    int get_pty_size(int pty_fd, int* rows, int* cols);

    /**
     * Set PTY window size
     * @param pty_fd PTY file descriptor
     * @param rows Number of rows
     * @param cols Number of columns
     * @return 0 on success, -1 on error
     */
    int set_pty_size(int pty_fd, int rows, int cols);

#ifdef __cplusplus
}
#endif

#endif  // PTY_MANAGER_H

```

`src/server/src/cpp/src/windows/core/callback_stubs.cpp`:

```cpp
// Callback stubs for DLL mode
// These functions are normally provided by Rust when statically linked.
// In DLL mode, Rust must set these function pointers after loading the DLL.

#include "../../common/dll_export.h"
#include "../../common/exception_info.h"
#include "native_api.h"

// Function pointer types
typedef void (*native_log_fn)(int level, const char* message);
typedef bool (*send_exception_info_fn)(const NativeExceptionInfo* info, int pid);

// Function pointers (set by Rust after DLL load)
static native_log_fn g_native_log = nullptr;
static send_exception_info_fn g_send_exception_info = nullptr;

// Set callback functions (called by Rust after DLL load)
extern "C" NATIVE_API void set_native_log_callback(native_log_fn fn)
{
    g_native_log = fn;
}

extern "C" NATIVE_API void set_send_exception_info_callback(send_exception_info_fn fn)
{
    g_send_exception_info = fn;
}

// Implementations called by C++ code
extern "C" void native_log(int level, const char* message)
{
    if (g_native_log)
    {
        g_native_log(level, message);
    }
    else
    {
        // Fallback: print to stderr
        const char* level_str = "UNKNOWN";
        switch (level)
        {
            case 1:
                level_str = "ERROR";
                break;
            case 2:
                level_str = "WARN";
                break;
            case 3:
                level_str = "INFO";
                break;
            case 4:
                level_str = "DEBUG";
                break;
            case 5:
                level_str = "TRACE";
                break;
        }
        fprintf(stderr, "[%s] %s\n", level_str, message);
    }
}

extern "C" bool send_exception_info(const NativeExceptionInfo* info, int pid)
{
    if (g_send_exception_info)
    {
        return g_send_exception_info(info, pid);
    }
    else
    {
        // Fallback: print basic info
        fprintf(stderr, "[WARN] send_exception_info: callback not set (rip=0x%llx, pid=%d)\n",
                (unsigned long long)info->regs.x86_64.rip, pid);
        return false;
    }
}

```

`src/server/src/cpp/src/windows/core/file_api.cpp`:

```cpp
#include "file_api.h"

static std::string escape_json_string(const std::string& input)
{
    std::ostringstream escaped;
    for (char c : input)
    {
        switch (c)
        {
            case '"':
                escaped << "\\\"";
                break;
            case '\\':
                escaped << "\\\\";
                break;
            case '\b':
                escaped << "\\b";
                break;
            case '\f':
                escaped << "\\f";
                break;
            case '\n':
                escaped << "\\n";
                break;
            case '\r':
                escaped << "\\r";
                break;
            case '\t':
                escaped << "\\t";
                break;
            default:
                escaped << c;
                break;
        }
    }
    return escaped.str();
}

static std::string normalize_path(const std::string& path)
{
    std::string normalized = path;
    std::replace(normalized.begin(), normalized.end(), '/', '\\');
    if (normalized.back() == '\\')
    {
        normalized.pop_back();
    }
    return normalized;
}

static const char* explore_directory_recursive(const char* path, int maxDepth, int currentDepth = 0)
{
    if (maxDepth < 0 || currentDepth > maxDepth)
    {
        return strdup("");
    }

    std::string normalizedPath = normalize_path(path);
    std::string searchPath = normalizedPath + "\\*";

    WIN32_FIND_DATA findFileData;
    HANDLE hFind = FindFirstFile(searchPath.c_str(), &findFileData);

    if (hFind == INVALID_HANDLE_VALUE)
    {
        std::ostringstream error;
        error << "Error: Failed to open directory " << normalizedPath;
        debug_log(LOG_ERROR, "Failed to open directory %s. Error code: %lu", normalizedPath.c_str(),
                  GetLastError());
        return strdup(error.str().c_str());
    }

    std::ostringstream result;
    std::string indent(currentDepth * 2, ' ');

    do
    {
        const std::string itemName = findFileData.cFileName;
        if (itemName == "." || itemName == "..") continue;

        std::string fullPath = normalizedPath + "\\" + itemName;

        if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            result << indent << "dir:" << itemName << "\n";
            if (currentDepth < maxDepth)
            {
                const char* subDirContent =
                    explore_directory_recursive(fullPath.c_str(), maxDepth, currentDepth + 1);
                result << subDirContent;
                free((void*)subDirContent);
            }
        }
        else
        {
            LARGE_INTEGER fileSize;
            fileSize.LowPart = findFileData.nFileSizeLow;
            fileSize.HighPart = findFileData.nFileSizeHigh;

            FILETIME lastWriteTime = findFileData.ftLastWriteTime;
            ULARGE_INTEGER uli;
            uli.LowPart = lastWriteTime.dwLowDateTime;
            uli.HighPart = lastWriteTime.dwHighDateTime;
            long long timestamp = (uli.QuadPart / 10000000ULL) - 11644473600ULL;

            result << indent << "file:" << itemName << "," << fileSize.QuadPart << "," << timestamp
                   << "\n";
        }
    } while (FindNextFile(hFind, &findFileData) != 0);

    FindClose(hFind);
    return strdup(result.str().c_str());
}

const char* explore_directory(const char* path, int maxDepth)
{
    return explore_directory_recursive(path, maxDepth);
}

const void* read_file(const char* path, size_t* size, char** error_message)
{
    HANDLE hFile =
        CreateFile(path, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        std::ostringstream error;
        error << "Error: Could not open file " << path;
        *error_message = strdup(error.str().c_str());
        debug_log(LOG_ERROR, "Failed to open file %s. Error code: %lu", path, GetLastError());
        *size = 0;
        return NULL;
    }

    LARGE_INTEGER fileSize;
    if (!GetFileSizeEx(hFile, &fileSize))
    {
        std::ostringstream error;
        error << "Error: Could not get file size for " << path;
        *error_message = strdup(error.str().c_str());
        debug_log(LOG_ERROR, "Failed to get file size for file %s. Error code: %lu", path,
                  GetLastError());
        CloseHandle(hFile);
        *size = 0;
        return NULL;
    }

    std::vector<char> buffer(fileSize.QuadPart);
    DWORD bytesRead;
    if (!ReadFile(hFile, buffer.data(), static_cast<DWORD>(fileSize.QuadPart), &bytesRead, NULL))
    {
        std::ostringstream error;
        error << "Error: Could not read file " << path;
        *error_message = strdup(error.str().c_str());
        debug_log(LOG_ERROR, "Failed to read file %s. Error code: %lu", path, GetLastError());
        CloseHandle(hFile);
        *size = 0;
        return NULL;
    }

    CloseHandle(hFile);
    *size = fileSize.QuadPart;
    void* data = malloc(*size);
    memcpy(data, buffer.data(), *size);
    return data;
}

const char* get_application_info_native(DWORD pid)
{
    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
    if (hProcess == NULL)
    {
        std::ostringstream error;
        error << "{\"error\":\"Failed to open process " << pid << "\"}";
        debug_log(LOG_ERROR, "Failed to open process %d for reading. Error code: %lu", pid,
                  GetLastError());
        return strdup(error.str().c_str());
    }

    char processPath[MAX_PATH];
    if (!GetModuleFileNameEx(hProcess, NULL, processPath, MAX_PATH))
    {
        std::ostringstream error;
        error << "{\"error\":\"Could not retrieve process path for PID " << pid << "\"}";
        debug_log(LOG_ERROR, "Failed to retrieve process path for PID %d. Error code: %lu", pid,
                  GetLastError());
        CloseHandle(hProcess);
        return strdup(error.str().c_str());
    }

    char appDataPath[MAX_PATH];
    if (FAILED(SHGetFolderPath(NULL, CSIDL_LOCAL_APPDATA, NULL, 0, appDataPath)))
    {
        std::ostringstream error;
        error << "{\"error\":\"Could not retrieve AppData path\"}";
        debug_log(LOG_ERROR, "Failed to retrieve AppData path. Error code: %lu", GetLastError());
        CloseHandle(hProcess);
        return strdup(error.str().c_str());
    }

    CloseHandle(hProcess);

    std::ostringstream json;
    json << "{"
         << "\"BinaryPath\":\"" << escape_json_string(processPath) << "\"}";

    return strdup(json.str().c_str());
}

```

`src/server/src/cpp/src/windows/core/file_api.h`:

```h
#ifndef WINDOWS_CORE_FILE_API_H
#define WINDOWS_CORE_FILE_API_H

#include <ShlObj.h>

#include <algorithm>
#include <iostream>
#include <sstream>
#include <string>

#include "native_api.h"

// Directory exploration
extern "C" const char* explore_directory(const char* path, int maxDepth);

// File reading
extern "C" const void* read_file(const char* path, size_t* size, char** error_message);

// Application information
extern "C" const char* get_application_info_native(DWORD pid);

#endif  // WINDOWS_CORE_FILE_API_H

```

`src/server/src/cpp/src/windows/core/memory_io.cpp`:

```cpp
/**
 * @file memory_io.cpp
 * @brief Memory read/write operations for process memory access (Windows)
 */

#include "memory_io.h"

#include "native_api.h"

// =============================================================================
// Memory Read/Write Functions
// =============================================================================

SSIZE_T read_memory_native(int pid, uintptr_t address, size_t size, unsigned char* buffer)
{
    return read_memory_native_with_method(pid, address, size, buffer, 0);
}

SSIZE_T read_memory_native_with_method(int pid, uintptr_t address, size_t size,
                                       unsigned char* buffer, int mode)
{
    // Windows does not use mode parameter, always uses ReadProcessMemory
    HANDLE processHandle = OpenProcess(PROCESS_VM_READ, FALSE, pid);
    if (processHandle == NULL)
    {
        debug_log(LOG_ERROR, "Failed to open process %d for reading. Error code: %lu", pid,
                  GetLastError());
        return -1;
    }

    SIZE_T bytesRead;
    if (ReadProcessMemory(processHandle, (LPCVOID)address, buffer, size, &bytesRead))
    {
        CloseHandle(processHandle);
        return (SSIZE_T)bytesRead;
    }
    else
    {
        DWORD error = GetLastError();
        CloseHandle(processHandle);
        debug_log(LOG_DEBUG,
                  "Failed to read memory from process %d at address 0x%p. Error code: %lu", pid,
                  (void*)address, error);
        return -1;
    }
}

SSIZE_T write_memory_native(int pid, void* address, size_t size, unsigned char* buffer)
{
    HANDLE processHandle = OpenProcess(
        PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_QUERY_INFORMATION, FALSE, pid);
    if (processHandle == NULL)
    {
        debug_log(LOG_ERROR, "Failed to open process %d for writing. Error code: %lu", pid,
                  GetLastError());
        return -1;
    }

    DWORD oldProtect;
    if (!VirtualProtectEx(processHandle, address, size, PAGE_EXECUTE_READWRITE, &oldProtect))
    {
        DWORD error = GetLastError();
        debug_log(LOG_ERROR,
                  "VirtualProtectEx failed for process %d at address 0x%p. Error code: %lu", pid,
                  address, error);
        CloseHandle(processHandle);
        return -1;
    }

    SIZE_T bytesWritten;
    if (!WriteProcessMemory(processHandle, address, buffer, size, &bytesWritten))
    {
        DWORD error = GetLastError();
        debug_log(LOG_ERROR,
                  "WriteProcessMemory failed for process %d at address 0x%p. Error code: %lu", pid,
                  address, error);
        VirtualProtectEx(processHandle, address, size, oldProtect, &oldProtect);
        CloseHandle(processHandle);
        return -1;
    }

    DWORD tempProtect;
    if (!VirtualProtectEx(processHandle, address, size, oldProtect, &tempProtect))
    {
        debug_log(LOG_ERROR,
                  "Failed to restore memory protection for process %d at address 0x%p. Error "
                  "code: %lu",
                  pid, address, GetLastError());
    }

    CloseHandle(processHandle);
    return bytesWritten;
}

```

`src/server/src/cpp/src/windows/core/memory_io.h`:

```h
/**
 * @file memory_io.h
 * @brief Memory read/write operations for process memory access (Windows)
 *
 * Provides memory access via Windows APIs:
 * - ReadProcessMemory (for reading)
 * - WriteProcessMemory (for writing)
 * - VirtualQueryEx (for region enumeration)
 */

#ifndef WINDOWS_MEMORY_IO_H
#define WINDOWS_MEMORY_IO_H

#include <windows.h>

#include <cstddef>
#include <cstdint>

#include "../../common/dll_export.h"

// =============================================================================
// Memory Read/Write Functions
// =============================================================================

/**
 * Read memory from a process
 * @param pid Process ID
 * @param address Address to read from
 * @param size Number of bytes to read
 * @param buffer Output buffer
 * @return Number of bytes read, or -1 on error
 */
extern "C" NATIVE_API SSIZE_T read_memory_native(int pid, uintptr_t address, size_t size,
                                                 unsigned char* buffer);

/**
 * Read memory from a process with specified method
 * @param pid Process ID
 * @param address Address to read from
 * @param size Number of bytes to read
 * @param buffer Output buffer
 * @param mode Read mode (ignored on Windows, always uses ReadProcessMemory)
 * @return Number of bytes read, or -1 on error
 */
extern "C" NATIVE_API SSIZE_T read_memory_native_with_method(int pid, uintptr_t address,
                                                             size_t size, unsigned char* buffer,
                                                             int mode);

/**
 * Write memory to a process
 * @param pid Process ID
 * @param address Address to write to
 * @param size Number of bytes to write
 * @param buffer Input buffer
 * @return Number of bytes written, or -1 on error
 */
extern "C" NATIVE_API SSIZE_T write_memory_native(int pid, void* address, size_t size,
                                                  unsigned char* buffer);

#endif  // WINDOWS_MEMORY_IO_H

```

`src/server/src/cpp/src/windows/core/native_api.cpp`:

```cpp
/**
 * @file native_api.cpp
 * @brief Native API implementations for Windows platform
 *
 * Implements process, module, thread, and symbol enumeration functions
 * using Windows APIs.
 *
 * Memory operations are in memory_io.cpp
 */

#include "native_api.h"

#include "../../common/dll_export.h"

// =============================================================================
// Logging Functions
// =============================================================================

NATIVE_API int debug_log(LogLevel level, const char* format, ...)
{
    va_list args;
    va_start(args, format);

    char tagged_format[256];
    _snprintf_s(tagged_format, sizeof(tagged_format), _TRUNCATE, "[NATIVE] %s", format);

    char buffer[1024];
    int result = _vsnprintf_s(buffer, sizeof(buffer), _TRUNCATE, tagged_format, args);

    if (result >= 0)
    {
        OutputDebugStringA(buffer);
        native_log(level, buffer);
    }

    va_end(args);
    return result;
}

// =============================================================================
// Process Functions
// =============================================================================

int get_pid_native()
{
    return GetCurrentProcessId();
}

ProcessInfo* enumerate_processes(size_t* count)
{
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE)
    {
        debug_log(LOG_ERROR, "Failed to create process snapshot. Error code: %lu", GetLastError());
        *count = 0;
        return nullptr;
    }

    PROCESSENTRY32W pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32W);

    if (!Process32FirstW(hSnapshot, &pe32))
    {
        debug_log(LOG_ERROR, "Failed to get first process. Error code: %lu", GetLastError());
        CloseHandle(hSnapshot);
        *count = 0;
        return nullptr;
    }

    std::vector<ProcessInfo> processes;

    do
    {
        ProcessInfo info;
        info.pid = pe32.th32ProcessID;
        info.processname = new char[MAX_PATH];

        if (wcstombs(info.processname, pe32.szExeFile, MAX_PATH) == (size_t)-1)
        {
            debug_log(LOG_DEBUG, "Failed to convert process name for PID %lu", info.pid);
            strcpy(info.processname, "Unknown");
        }

        processes.push_back(info);
    } while (Process32NextW(hSnapshot, &pe32));

    CloseHandle(hSnapshot);

    ProcessInfo* retArray = new ProcessInfo[processes.size()];
    for (size_t i = 0; i < processes.size(); i++)
    {
        retArray[i] = processes[i];
    }

    *count = processes.size();
    return retArray;
}

bool suspend_process(int pid)
{
    HANDLE hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (hThreadSnap == INVALID_HANDLE_VALUE)
    {
        debug_log(LOG_ERROR, "Failed to create snapshot of threads for process %d. Error code: %lu",
                  pid, GetLastError());
        return false;
    }

    THREADENTRY32 te32;
    te32.dwSize = sizeof(THREADENTRY32);

    if (!Thread32First(hThreadSnap, &te32))
    {
        debug_log(LOG_ERROR, "Failed to get first thread for process %d. Error code: %lu", pid,
                  GetLastError());
        CloseHandle(hThreadSnap);
        return false;
    }

    bool suspended_any = false;
    do
    {
        if (te32.th32OwnerProcessID == pid)
        {
            HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME, FALSE, te32.th32ThreadID);
            if (hThread == NULL)
            {
                debug_log(LOG_ERROR, "Failed to open thread %lu for process %d. Error code: %lu",
                          te32.th32ThreadID, pid, GetLastError());
                continue;
            }

            if (SuspendThread(hThread) == (DWORD)-1)
            {
                debug_log(LOG_ERROR, "Failed to suspend thread %lu for process %d. Error code: %lu",
                          te32.th32ThreadID, pid, GetLastError());
                CloseHandle(hThread);
                continue;
            }

            suspended_any = true;
            CloseHandle(hThread);
        }
    } while (Thread32Next(hThreadSnap, &te32));

    CloseHandle(hThreadSnap);

    if (suspended_any)
    {
        return true;
    }
    else
    {
        debug_log(LOG_ERROR, " No threads were suspended for process %d", pid);
        return false;
    }
}

bool resume_process(int pid)
{
    HANDLE hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (hThreadSnap == INVALID_HANDLE_VALUE)
    {
        debug_log(LOG_ERROR, "Failed to create snapshot of threads for process %d. Error code: %lu",
                  pid, GetLastError());
        return false;
    }

    THREADENTRY32 te32;
    te32.dwSize = sizeof(THREADENTRY32);

    if (!Thread32First(hThreadSnap, &te32))
    {
        debug_log(LOG_ERROR, "Failed to get first thread for process %d. Error code: %lu", pid,
                  GetLastError());
        CloseHandle(hThreadSnap);
        return false;
    }

    bool resumed_any = false;
    do
    {
        if (te32.th32OwnerProcessID == pid)
        {
            HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME, FALSE, te32.th32ThreadID);
            if (hThread == NULL)
            {
                debug_log(LOG_ERROR, "Failed to open thread %lu for process %d. Error code: %lu",
                          te32.th32ThreadID, pid, GetLastError());
                continue;
            }

            if (ResumeThread(hThread) == (DWORD)-1)
            {
                debug_log(LOG_ERROR, "Failed to resume thread %lu for process %d. Error code: %lu",
                          te32.th32ThreadID, pid, GetLastError());
                CloseHandle(hThread);
                continue;
            }

            resumed_any = true;
            CloseHandle(hThread);
        }
    } while (Thread32Next(hThreadSnap, &te32));

    CloseHandle(hThreadSnap);

    if (resumed_any)
    {
        return true;
    }
    else
    {
        debug_log(LOG_ERROR, "No threads were resumed for process %d", pid);
        return false;
    }
}

// =============================================================================
// Module Functions
// =============================================================================

static bool IsPE64Bit(HANDLE hProcess, LPVOID baseAddress)
{
    IMAGE_DOS_HEADER dosHeader;
    IMAGE_NT_HEADERS ntHeaders;

    if (!ReadProcessMemory(hProcess, baseAddress, &dosHeader, sizeof(dosHeader), nullptr))
    {
        return false;
    }

    if (dosHeader.e_magic != IMAGE_DOS_SIGNATURE)
    {
        return false;
    }

    if (!ReadProcessMemory(hProcess, (LPVOID)((DWORD_PTR)baseAddress + dosHeader.e_lfanew),
                           &ntHeaders, sizeof(ntHeaders), nullptr))
    {
        return false;
    }

    if (ntHeaders.Signature != IMAGE_NT_SIGNATURE)
    {
        return false;
    }

    return ntHeaders.FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64;
}

ModuleInfo* enumerate_modules(DWORD pid, size_t* count)
{
    std::vector<ModuleInfo> modules;
    HANDLE hModuleSnap = INVALID_HANDLE_VALUE;
    MODULEENTRY32 me32;

    hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pid);
    if (hModuleSnap == INVALID_HANDLE_VALUE)
    {
        *count = 0;
        return nullptr;
    }

    me32.dwSize = sizeof(MODULEENTRY32);

    if (!Module32First(hModuleSnap, &me32))
    {
        CloseHandle(hModuleSnap);
        *count = 0;
        return nullptr;
    }

    HANDLE hProcess = OpenProcess(PROCESS_VM_READ, FALSE, pid);
    if (hProcess == NULL)
    {
        CloseHandle(hModuleSnap);
        *count = 0;
        return nullptr;
    }

    do
    {
        ModuleInfo info;
        info.base = reinterpret_cast<uintptr_t>(me32.modBaseAddr);
        info.size = me32.modBaseSize;

        info.is_64bit = IsPE64Bit(hProcess, me32.modBaseAddr);

        // Use szExePath (full path) instead of szModule (name only)
        size_t pathLength = strlen(me32.szExePath) + 1;
        info.modulename = new char[pathLength];
        strcpy_s(info.modulename, pathLength, me32.szExePath);

        modules.push_back(info);
    } while (Module32Next(hModuleSnap, &me32));

    CloseHandle(hProcess);
    CloseHandle(hModuleSnap);

    *count = modules.size();
    ModuleInfo* result = new ModuleInfo[*count];
    std::copy(modules.begin(), modules.end(), result);

    return result;
}

// =============================================================================
// Symbol Functions
// =============================================================================

SymbolInfo* enumerate_symbols(int pid, uintptr_t module_base, size_t* count)
{
    // Symbol enumeration using Windows Sym** API
    std::vector<SymbolInfo> symbols;
    *count = 0;

    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (hProcess == NULL)
    {
        debug_log(LOG_ERROR, "Failed to open process %d for symbol enumeration. Error: %lu", pid,
                  GetLastError());
        return nullptr;
    }

    // Initialize symbol handler
    if (!SymInitialize(hProcess, NULL, FALSE))
    {
        debug_log(LOG_ERROR, "SymInitialize failed for process %d. Error: %lu", pid,
                  GetLastError());
        CloseHandle(hProcess);
        return nullptr;
    }

    // Set symbol options for better compatibility
    DWORD options = SymGetOptions();
    options |= SYMOPT_DEBUG | SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS | SYMOPT_LOAD_LINES |
               SYMOPT_INCLUDE_32BIT_MODULES;
    options &= ~SYMOPT_NO_PUBLICS;  // Make sure we can load public symbols
    SymSetOptions(options);

    // Get module information first
    char modulePath[MAX_PATH] = {0};
    char moduleName[MAX_PATH] = {0};
    DWORD moduleSize = 0;

    if (GetModuleFileNameExA(hProcess, (HMODULE)module_base, modulePath, MAX_PATH) > 0)
    {
        // Extract module name from path
        const char* lastSlash = strrchr(modulePath, '\\');
        if (lastSlash)
        {
            strcpy_s(moduleName, MAX_PATH, lastSlash + 1);
        }
        else
        {
            strcpy_s(moduleName, MAX_PATH, modulePath);
        }
    }

    // Get module size
    MODULEINFO modInfo;
    if (GetModuleInformation(hProcess, (HMODULE)module_base, &modInfo, sizeof(modInfo)))
    {
        moduleSize = modInfo.SizeOfImage;
    }

    // Load module symbols - try multiple approaches
    DWORD64 baseAddress = 0;

    // Method 1: Load with full path and name
    if (strlen(modulePath) > 0)
    {
        baseAddress =
            SymLoadModule64(hProcess, NULL, modulePath, moduleName, module_base, moduleSize);
        if (baseAddress != 0)
        {
            debug_log(LOG_DEBUG, "SymLoadModule64 succeeded with path for module %s", moduleName);
        }
    }

    // Method 2: Load without path if method 1 failed
    if (baseAddress == 0)
    {
        baseAddress = SymLoadModule64(hProcess, NULL, NULL, moduleName, module_base, moduleSize);
        if (baseAddress != 0)
        {
            debug_log(LOG_DEBUG, "SymLoadModule64 succeeded without path for module %s",
                      moduleName);
        }
    }

    // Method 3: Load with just base address if both failed
    if (baseAddress == 0)
    {
        baseAddress = SymLoadModule64(hProcess, NULL, NULL, NULL, module_base, moduleSize);
        if (baseAddress != 0)
        {
            debug_log(LOG_DEBUG, "SymLoadModule64 succeeded with base address only");
        }
    }

    if (baseAddress == 0)
    {
        DWORD error = GetLastError();
        debug_log(LOG_ERROR, "All SymLoadModule64 attempts failed for module at 0x%p. Error: %lu",
                  (void*)module_base, error);
        SymCleanup(hProcess);
        CloseHandle(hProcess);
        return nullptr;
    }

    // Structure for enumeration callback
    struct EnumContext
    {
        std::vector<SymbolInfo>* symbols;
        HANDLE hProcess;
    };

    EnumContext context = {&symbols, hProcess};

    // Callback function for symbol enumeration
    auto enumSymbolsCallback = [](PSYMBOL_INFO pSymInfo, ULONG SymbolSize,
                                  PVOID UserContext) -> BOOL
    {
        EnumContext* ctx = static_cast<EnumContext*>(UserContext);

        // Skip symbols without names or invalid addresses
        if (pSymInfo->NameLen == 0 || pSymInfo->Address == 0) return TRUE;

        SymbolInfo info;
        memset(&info, 0, sizeof(SymbolInfo));  // Initialize all fields to zero

        info.address = pSymInfo->Address;
        info.size = pSymInfo->Size;
        info.module_base = pSymInfo->ModBase;
        info.line_number = 0;  // Default value

        // Copy symbol name safely
        if (pSymInfo->NameLen > 0 && pSymInfo->Name)
        {
            size_t nameLength = pSymInfo->NameLen + 1;
            info.name = new (std::nothrow) char[nameLength];
            if (info.name)
            {
                strcpy_s(info.name, nameLength, pSymInfo->Name);
            }
            else
            {
                return TRUE;  // Skip this symbol if memory allocation failed
            }
        }
        else
        {
            return TRUE;  // Skip symbols without names
        }

        // Determine symbol type safely using numeric values (SymTag enums)
        const char* symbolType = "Other";
        switch (pSymInfo->Tag)
        {
            case 5:  // SymTagFunction
                symbolType = "Function";
                break;
            case 7:  // SymTagData
                symbolType = "Variable";
                break;
            case 10:  // SymTagPublicSymbol
                symbolType = "Public";
                break;
            case 16:  // SymTagThunk
                symbolType = "Thunk";
                break;
            case 17:  // SymTagLabel
                symbolType = "Label";
                break;
            default:
                // Use symbol flags to make better guesses
                if (pSymInfo->Flags & SYMFLAG_FUNCTION)
                {
                    symbolType = "Function";
                }
                else if (pSymInfo->Flags & SYMFLAG_PUBLIC_CODE)
                {
                    symbolType = "Public";
                }
                else
                {
                    symbolType = "Other";
                }
                break;
        }
        size_t typeLength = strlen(symbolType) + 1;
        info.type = new (std::nothrow) char[typeLength];
        if (info.type)
        {
            strcpy_s(info.type, typeLength, symbolType);
        }
        else
        {
            delete[] info.name;
            return TRUE;  // Skip if allocation failed
        }

        // Determine scope safely
        const char* scope = "Global";  // Default to Global
        if (pSymInfo->Flags & SYMFLAG_LOCAL)
        {
            scope = "Local";
        }
        else if (pSymInfo->Flags & SYMFLAG_PARAMETER)
        {
            scope = "Parameter";
        }
        else if (pSymInfo->Flags & SYMFLAG_EXPORT)
        {
            scope = "Export";
        }
        size_t scopeLength = strlen(scope) + 1;
        info.scope = new (std::nothrow) char[scopeLength];
        if (info.scope)
        {
            strcpy_s(info.scope, scopeLength, scope);
        }
        else
        {
            delete[] info.name;
            delete[] info.type;
            return TRUE;  // Skip if allocation failed
        }

        // Initialize file_name to empty string by default
        info.file_name = new (std::nothrow) char[1];
        if (info.file_name)
        {
            info.file_name[0] = '\0';
        }
        else
        {
            delete[] info.name;
            delete[] info.type;
            delete[] info.scope;
            return TRUE;  // Skip if allocation failed
        }

        // Try to get source file and line information (optional, may fail)
        try
        {
            DWORD displacement;
            IMAGEHLP_LINE64 line;
            line.SizeOfStruct = sizeof(IMAGEHLP_LINE64);

            if (SymGetLineFromAddr64(ctx->hProcess, pSymInfo->Address, &displacement, &line) &&
                line.FileName)
            {
                // Extract just filename from full path
                const char* fileName = strrchr(line.FileName, '\\');
                fileName = fileName ? fileName + 1 : line.FileName;

                if (strlen(fileName) > 0)
                {
                    delete[] info.file_name;  // Delete the empty string we allocated above

                    size_t fileNameLength = strlen(fileName) + 1;
                    info.file_name = new (std::nothrow) char[fileNameLength];
                    if (info.file_name)
                    {
                        strcpy_s(info.file_name, fileNameLength, fileName);
                        info.line_number = line.LineNumber;
                    }
                    else
                    {
                        // Fallback to empty string
                        info.file_name = new char[1];
                        info.file_name[0] = '\0';
                    }
                }
            }
        }
        catch (...)
        {
            // Ignore any exceptions from line info retrieval
            debug_log(LOG_DEBUG, "Exception while getting line info for symbol %s", pSymInfo->Name);
        }

        ctx->symbols->push_back(info);

        return TRUE;  // Continue enumeration
    };

    // Enumerate symbols
    if (!SymEnumSymbols(hProcess, baseAddress, "*", enumSymbolsCallback, &context))
    {
        DWORD error = GetLastError();
        debug_log(LOG_ERROR, "SymEnumSymbols failed for module at 0x%p. Error: %lu",
                  (void*)module_base, error);

        // Try different pattern
        if (!SymEnumSymbols(hProcess, baseAddress, NULL, enumSymbolsCallback, &context))
        {
            debug_log(LOG_ERROR, "SymEnumSymbols with NULL pattern also failed. Error: %lu",
                      GetLastError());
        }
    }

    // Cleanup
    SymUnloadModule64(hProcess, baseAddress);
    SymCleanup(hProcess);
    CloseHandle(hProcess);

    *count = symbols.size();
    if (*count == 0)
    {
        debug_log(LOG_INFO, "No symbols found for module at 0x%p", (void*)module_base);
        return nullptr;
    }

    SymbolInfo* result = new SymbolInfo[*count];
    std::copy(symbols.begin(), symbols.end(), result);

    debug_log(LOG_INFO, "Enumerated %zu symbols from module at 0x%p using Sym** API", *count,
              (void*)module_base);
    return result;
}

// =============================================================================
// Initialization
// =============================================================================

int native_init(int mode)
{
    return 1;
}

// =============================================================================
// Thread Functions
// =============================================================================

// Function pointer type for GetThreadDescription (Windows 10 1607+)
typedef HRESULT(WINAPI* GetThreadDescriptionFunc)(HANDLE hThread, PWSTR* ppszThreadDescription);

// Get thread description using GetThreadDescription API (Windows 10 1607+)
static bool GetThreadName(HANDLE hThread, char* nameBuf, size_t bufSize)
{
    static GetThreadDescriptionFunc pGetThreadDescription = nullptr;
    static bool initialized = false;

    if (!initialized)
    {
        HMODULE hKernel32 = GetModuleHandleA("kernel32.dll");
        if (hKernel32)
        {
            pGetThreadDescription =
                (GetThreadDescriptionFunc)GetProcAddress(hKernel32, "GetThreadDescription");
        }
        initialized = true;
    }

    if (pGetThreadDescription)
    {
        PWSTR pszThreadName = nullptr;
        HRESULT hr = pGetThreadDescription(hThread, &pszThreadName);
        if (SUCCEEDED(hr) && pszThreadName && pszThreadName[0] != L'\0')
        {
            // Convert wide string to narrow string
            int len = WideCharToMultiByte(CP_UTF8, 0, pszThreadName, -1, nameBuf, (int)bufSize,
                                          NULL, NULL);
            LocalFree(pszThreadName);
            if (len > 0)
            {
                return true;
            }
        }
        if (pszThreadName)
        {
            LocalFree(pszThreadName);
        }
    }

    return false;
}

ThreadInfo* enumerate_threads(int pid, size_t* count)
{
    *count = 0;

    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE)
    {
        debug_log(LOG_ERROR, "Failed to create thread snapshot. Error code: %lu", GetLastError());
        return nullptr;
    }

    std::vector<ThreadInfo> threads;

    THREADENTRY32 te32;
    te32.dwSize = sizeof(THREADENTRY32);

    if (!Thread32First(hSnapshot, &te32))
    {
        debug_log(LOG_ERROR, "Failed to get first thread. Error code: %lu", GetLastError());
        CloseHandle(hSnapshot);
        return nullptr;
    }

    do
    {
        if (te32.th32OwnerProcessID == (DWORD)pid)
        {
            ThreadInfo info = {0};
            info.thread_id = te32.th32ThreadID;
            info.state = 1;  // Default to running
            info.suspend_count = 0;

            // Try to get thread context for PC/SP/FP
            HANDLE hThread =
                OpenThread(THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION | THREAD_SUSPEND_RESUME,
                           FALSE, te32.th32ThreadID);
            if (hThread != NULL)
            {
                // Suspend thread temporarily to get context
                DWORD suspendCount = SuspendThread(hThread);
                if (suspendCount != (DWORD)-1)
                {
                    if (suspendCount > 0)
                    {
                        debug_log(LOG_INFO,
                                  "enumerate_threads: Thread %lu was already suspended (count=%lu)",
                                  te32.th32ThreadID, suspendCount);
                    }
                    info.suspend_count = suspendCount;

                    CONTEXT ctx;
                    ctx.ContextFlags = CONTEXT_FULL;
                    if (GetThreadContext(hThread, &ctx))
                    {
#ifdef _WIN64
                        info.pc = ctx.Rip;
                        info.sp = ctx.Rsp;
                        info.fp = ctx.Rbp;
#else
                        info.pc = ctx.Eip;
                        info.sp = ctx.Esp;
                        info.fp = ctx.Ebp;
#endif
                    }

                    // Resume thread
                    ResumeThread(hThread);
                }

                // Try to get thread description (Windows 10 1607+)
                char threadName[256];
                if (GetThreadName(hThread, threadName, sizeof(threadName)))
                {
                    info.name = new char[strlen(threadName) + 1];
                    strcpy(info.name, threadName);
                }
                else
                {
                    // Fallback to generic name
                    char nameBuf[64];
                    snprintf(nameBuf, sizeof(nameBuf), "Thread %lu", te32.th32ThreadID);
                    info.name = new char[strlen(nameBuf) + 1];
                    strcpy(info.name, nameBuf);
                }

                CloseHandle(hThread);
            }
            else
            {
                // Could not open thread, use generic name
                char nameBuf[64];
                snprintf(nameBuf, sizeof(nameBuf), "Thread %lu", te32.th32ThreadID);
                info.name = new char[strlen(nameBuf) + 1];
                strcpy(info.name, nameBuf);
            }

            threads.push_back(info);
        }
    } while (Thread32Next(hSnapshot, &te32));

    CloseHandle(hSnapshot);

    if (threads.empty())
    {
        return nullptr;
    }

    *count = threads.size();
    ThreadInfo* result = new ThreadInfo[*count];
    std::copy(threads.begin(), threads.end(), result);

    debug_log(LOG_INFO, "Successfully enumerated %zu threads for pid %d", *count, pid);
    return result;
}

void free_thread_info(ThreadInfo* threads, size_t count)
{
    if (threads)
    {
        for (size_t i = 0; i < count; i++)
        {
            if (threads[i].name)
            {
                delete[] threads[i].name;
            }
        }
        delete[] threads;
    }
}

// =============================================================================
// Debugger Control Stub Implementations
// Note: continue_execution_native, single_step_native, is_in_break_state_native
// are implemented in debugger/debugger.cpp
// =============================================================================

int read_register_native(uintptr_t thread_id, const char* reg_name, uint64_t* value)
{
    // Stub implementation - not yet implemented for Windows
    debug_log(LOG_WARN,
              "read_register_native not implemented for Windows (thread_id: %llu, reg: %s)",
              (unsigned long long)thread_id, reg_name ? reg_name : "null");
    if (value) *value = 0;
    return -1;  // Return error
}

int write_register_native(uintptr_t thread_id, const char* reg_name, uint64_t value)
{
    // Stub implementation - not yet implemented for Windows
    debug_log(
        LOG_WARN,
        "write_register_native not implemented for Windows (thread_id: %llu, reg: %s, value: %llu)",
        (unsigned long long)thread_id, reg_name ? reg_name : "null", (unsigned long long)value);
    return -1;  // Return error
}

// =============================================================================
// Process Icon
// =============================================================================

const unsigned char* get_process_icon_native(int pid, size_t* size)
{
    *size = 0;

    // Get process handle
    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
    if (!hProcess)
    {
        debug_log(LOG_ERROR, "Failed to open process %d for icon extraction. Error: %lu", pid,
                  GetLastError());
        return nullptr;
    }

    // Get process executable path
    WCHAR szProcessPath[MAX_PATH];
    DWORD dwSize = MAX_PATH;
    if (!QueryFullProcessImageNameW(hProcess, 0, szProcessPath, &dwSize))
    {
        debug_log(LOG_ERROR, "Failed to get process path for PID %d. Error: %lu", pid,
                  GetLastError());
        CloseHandle(hProcess);
        return nullptr;
    }
    CloseHandle(hProcess);

    // Extract icon from executable
    HICON hIcon = ExtractIconW(GetModuleHandle(nullptr), szProcessPath, 0);
    if (!hIcon || hIcon == (HICON)1)
    {
        debug_log(LOG_DEBUG, "No icon found for process %d", pid);
        return nullptr;
    }

    // Get icon info
    ICONINFO iconInfo;
    if (!GetIconInfo(hIcon, &iconInfo))
    {
        debug_log(LOG_ERROR, "Failed to get icon info for PID %d. Error: %lu", pid, GetLastError());
        DestroyIcon(hIcon);
        return nullptr;
    }

    // Create memory DC and select bitmap
    HDC hdc = GetDC(nullptr);
    HDC memDC = CreateCompatibleDC(hdc);

    // Get bitmap info
    BITMAP bmp;
    GetObject(iconInfo.hbmColor, sizeof(BITMAP), &bmp);

    // Create DIB section for PNG conversion
    BITMAPINFOHEADER bi = {0};
    bi.biSize = sizeof(BITMAPINFOHEADER);
    bi.biWidth = bmp.bmWidth;
    bi.biHeight = -bmp.bmHeight;  // Top-down DIB
    bi.biPlanes = 1;
    bi.biBitCount = 32;
    bi.biCompression = BI_RGB;

    void* pBits;
    HBITMAP hDIB = CreateDIBSection(memDC, (BITMAPINFO*)&bi, DIB_RGB_COLORS, &pBits, nullptr, 0);
    if (!hDIB)
    {
        debug_log(LOG_ERROR, "Failed to create DIB section for PID %d", pid);
        DeleteDC(memDC);
        ReleaseDC(nullptr, hdc);
        DeleteObject(iconInfo.hbmColor);
        DeleteObject(iconInfo.hbmMask);
        DestroyIcon(hIcon);
        return nullptr;
    }

    // Select DIB and draw icon
    HBITMAP oldBmp = (HBITMAP)SelectObject(memDC, hDIB);
    DrawIconEx(memDC, 0, 0, hIcon, bmp.bmWidth, bmp.bmHeight, 0, nullptr, DI_NORMAL);

    // Create a simple PNG-like header (for simplicity, we'll return raw RGBA data)
    // In a real implementation, you'd want to use a proper PNG encoder
    int imageSize = bmp.bmWidth * bmp.bmHeight * 4;
    unsigned char* iconData = new unsigned char[imageSize];

    // Copy bitmap data
    memcpy(iconData, pBits, imageSize);

    // Convert BGRA to RGBA
    for (int i = 0; i < imageSize; i += 4)
    {
        std::swap(iconData[i], iconData[i + 2]);  // Swap B and R
    }

    *size = imageSize;

    // Cleanup
    SelectObject(memDC, oldBmp);
    DeleteObject(hDIB);
    DeleteDC(memDC);
    ReleaseDC(nullptr, hdc);
    DeleteObject(iconInfo.hbmColor);
    DeleteObject(iconInfo.hbmMask);
    DestroyIcon(hIcon);

    debug_log(LOG_DEBUG, "Successfully extracted icon for PID %d, size: %zu bytes", pid, *size);
    return iconData;
}

// =============================================================================
// Trace File Output Functions (Stub implementations for Windows)
// These are implemented in Darwin but need stubs for Windows builds
// =============================================================================

extern "C" void enable_trace_file_output_native(const char* filepath)
{
    (void)filepath;
    debug_log(LOG_WARN, "enable_trace_file_output_native: Not implemented for this platform");
}

extern "C" void disable_trace_file_output_native()
{
    debug_log(LOG_WARN, "disable_trace_file_output_native: Not implemented for this platform");
}

extern "C" bool is_trace_file_output_enabled_native()
{
    debug_log(LOG_WARN, "is_trace_file_output_enabled_native: Not implemented for this platform");
    return false;
}

extern "C" const char* get_trace_file_path_native()
{
    debug_log(LOG_WARN, "get_trace_file_path_native: Not implemented for this platform");
    return "";
}

extern "C" uint32_t get_trace_file_entry_count_native()
{
    debug_log(LOG_WARN, "get_trace_file_entry_count_native: Not implemented for this platform");
    return 0;
}

extern "C" bool is_trace_ended_by_end_address_native()
{
    debug_log(LOG_WARN, "is_trace_ended_by_end_address_native: Not implemented for this platform");
    return false;
}

extern "C" void enable_full_memory_cache_native(const char* dump_filepath, const char* log_filepath)
{
    (void)dump_filepath;
    (void)log_filepath;
    debug_log(LOG_WARN, "enable_full_memory_cache_native: Not implemented for this platform");
}

extern "C" void disable_full_memory_cache_native()
{
    debug_log(LOG_WARN, "disable_full_memory_cache_native: Not implemented for this platform");
}

// =============================================================================
// Region Enumeration Helper Functions
// =============================================================================

static void setMemoryProtection(DWORD protect, DWORD type, char* permissions)
{
    permissions[0] = '-';
    permissions[1] = '-';
    permissions[2] = '-';
    permissions[3] = '-';

    switch (protect & 0xFF)
    {
        case PAGE_EXECUTE:
            permissions[2] = 'x';
            break;
        case PAGE_EXECUTE_READ:
            permissions[0] = 'r';
            permissions[2] = 'x';
            break;
        case PAGE_EXECUTE_READWRITE:
        case PAGE_EXECUTE_WRITECOPY:
            permissions[0] = 'r';
            permissions[1] = 'w';
            permissions[2] = 'x';
            break;
        case PAGE_NOACCESS:
            break;
        case PAGE_READONLY:
            permissions[0] = 'r';
            break;
        case PAGE_READWRITE:
        case PAGE_WRITECOPY:
            permissions[0] = 'r';
            permissions[1] = 'w';
            break;
    }

    if (type & MEM_PRIVATE || type & MEM_IMAGE)
    {
        permissions[3] = 'p';  // private
    }
    else if (type & MEM_MAPPED)
    {
        permissions[3] = 's';  // shared
    }
    else
    {
        permissions[3] = '-';
    }
}

// Convert device path (e.g., \Device\HarddiskVolume3\...) to drive letter path (e.g., C:\...)
static bool ConvertDevicePathToDriveLetter(const char* devicePath, char* drivePath,
                                           size_t drivePathSize)
{
    char drives[512];
    if (GetLogicalDriveStringsA(sizeof(drives) - 1, drives) == 0)
    {
        return false;
    }

    for (const char* drive = drives; *drive; drive += strlen(drive) + 1)
    {
        char driveLetter[3] = {drive[0], ':', '\0'};
        char deviceName[MAX_PATH];

        if (QueryDosDeviceA(driveLetter, deviceName, sizeof(deviceName)) > 0)
        {
            size_t deviceNameLen = strlen(deviceName);
            if (_strnicmp(devicePath, deviceName, deviceNameLen) == 0 &&
                devicePath[deviceNameLen] == '\\')
            {
                snprintf(drivePath, drivePathSize, "%s%s", driveLetter, devicePath + deviceNameLen);
                return true;
            }
        }
    }
    return false;
}

// Parse protection bits from Windows memory protection
static uint32_t parse_protection_bits(DWORD protect)
{
    uint32_t prot = 0;
    switch (protect & 0xFF)
    {
        case PAGE_READONLY:
            prot = 1;  // PROT_READ
            break;
        case PAGE_READWRITE:
        case PAGE_WRITECOPY:
            prot = 1 | 2;  // PROT_READ | PROT_WRITE
            break;
        case PAGE_EXECUTE:
            prot = 4;  // PROT_EXEC
            break;
        case PAGE_EXECUTE_READ:
            prot = 1 | 4;  // PROT_READ | PROT_EXEC
            break;
        case PAGE_EXECUTE_READWRITE:
        case PAGE_EXECUTE_WRITECOPY:
            prot = 1 | 2 | 4;  // PROT_READ | PROT_WRITE | PROT_EXEC
            break;
        default:
            prot = 0;
            break;
    }
    return prot;
}

// =============================================================================
// Region Enumeration Functions
// =============================================================================

void enumerate_regions_to_buffer(DWORD pid, char* buffer, size_t buffer_size,
                                 bool include_filenames)
{
    HANDLE processHandle = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
    if (processHandle == NULL)
    {
        debug_log(LOG_ERROR, "Failed to open process %lu. Error code: %lu", pid, GetLastError());
        snprintf(buffer, buffer_size, "Failed to open process\n");
        return;
    }

    MEMORY_BASIC_INFORMATION memInfo;
    unsigned char* addr = 0;
    size_t offset = 0;

    while (VirtualQueryEx(processHandle, addr, &memInfo, sizeof(memInfo)))
    {
        char permissions[5] = "----";
        if (memInfo.State == MEM_COMMIT)
        {
            setMemoryProtection(memInfo.Protect, memInfo.Type, permissions);
        }

        char mappedFileName[MAX_PATH] = {0};
        // Get file path for both MEM_MAPPED and MEM_IMAGE (DLLs/EXEs)
        if (include_filenames && (memInfo.Type == MEM_MAPPED || memInfo.Type == MEM_IMAGE))
        {
            char devicePath[MAX_PATH] = {0};
            if (GetMappedFileNameA(processHandle, addr, devicePath, sizeof(devicePath)))
            {
                // Convert device path to drive letter path
                if (!ConvertDevicePathToDriveLetter(devicePath, mappedFileName,
                                                    sizeof(mappedFileName)))
                {
                    // Fallback to device path if conversion fails
                    strncpy(mappedFileName, devicePath, sizeof(mappedFileName) - 1);
                }
            }
            // Silently ignore failures
        }

        char start_address[17], end_address[17];
        snprintf(start_address, sizeof(start_address), "%p", addr);
        snprintf(end_address, sizeof(end_address), "%p",
                 (unsigned char*)addr + memInfo.RegionSize - 1);

        int written = snprintf(buffer + offset, buffer_size - offset, "%s-%s %s %s _ _ %s\n",
                               start_address, end_address, permissions,
                               memInfo.State == MEM_COMMIT    ? "committed"
                               : memInfo.State == MEM_RESERVE ? "reserved"
                                                              : "free",
                               mappedFileName);

        if (written <= 0 || written >= buffer_size - offset)
        {
            debug_log(LOG_ERROR, "Buffer full or write error. Stopping enumeration.");
            break;
        }

        offset += written;
        addr = (unsigned char*)memInfo.BaseAddress + memInfo.RegionSize;
    }
    CloseHandle(processHandle);
}

RegionInfo* enumerate_regions(DWORD pid, size_t* count, bool include_filenames)
{
    *count = 0;

    HANDLE processHandle = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
    if (processHandle == NULL)
    {
        debug_log(LOG_ERROR, "Failed to open process %lu. Error code: %lu", pid, GetLastError());
        return nullptr;
    }

    std::vector<RegionInfo> regions;
    MEMORY_BASIC_INFORMATION memInfo;
    unsigned char* addr = 0;

    while (VirtualQueryEx(processHandle, addr, &memInfo, sizeof(memInfo)))
    {
        if (memInfo.State == MEM_COMMIT)
        {
            RegionInfo region;
            region.start = reinterpret_cast<uintptr_t>(memInfo.BaseAddress);
            region.end = reinterpret_cast<uintptr_t>(memInfo.BaseAddress) + memInfo.RegionSize;
            region.protection = parse_protection_bits(memInfo.Protect);
            region.pathname = nullptr;

            // Get file path for both MEM_MAPPED and MEM_IMAGE (DLLs/EXEs)
            if (include_filenames && (memInfo.Type == MEM_MAPPED || memInfo.Type == MEM_IMAGE))
            {
                char devicePath[MAX_PATH] = {0};
                char mappedFileName[MAX_PATH] = {0};
                if (GetMappedFileNameA(processHandle, addr, devicePath, sizeof(devicePath)))
                {
                    if (ConvertDevicePathToDriveLetter(devicePath, mappedFileName,
                                                       sizeof(mappedFileName)))
                    {
                        region.pathname = _strdup(mappedFileName);
                    }
                    else
                    {
                        region.pathname = _strdup(devicePath);
                    }
                }
            }

            regions.push_back(region);
        }

        addr = (unsigned char*)memInfo.BaseAddress + memInfo.RegionSize;
    }

    CloseHandle(processHandle);

    if (regions.empty())
    {
        return nullptr;
    }

    RegionInfo* result = static_cast<RegionInfo*>(malloc(regions.size() * sizeof(RegionInfo)));
    if (!result)
    {
        // Free pathnames on allocation failure
        for (auto& r : regions)
        {
            if (r.pathname) free(r.pathname);
        }
        return nullptr;
    }

    memcpy(result, regions.data(), regions.size() * sizeof(RegionInfo));
    *count = regions.size();
    return result;
}

void free_region_info(RegionInfo* regions, size_t count)
{
    if (!regions) return;
    for (size_t i = 0; i < count; i++)
    {
        if (regions[i].pathname)
        {
            free(regions[i].pathname);
        }
    }
    free(regions);
}

```

`src/server/src/cpp/src/windows/core/native_api.h`:

```h
/**
 * @file native_api.h
 * @brief Native API declarations for Windows platform
 *
 * Provides process, module, thread, and symbol enumeration functions
 * using Windows APIs like CreateToolhelp32Snapshot and SymEnumSymbols.
 *
 * Memory operations are in memory_io.h
 */

#ifndef WINDOWS_NATIVE_API_H
#define WINDOWS_NATIVE_API_H

#include <windows.h>
//
#include <dbghelp.h>
#include <psapi.h>
#include <stdio.h>
#include <tlhelp32.h>

#include <cstdint>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <vector>

#include "../../common/dll_export.h"

// =============================================================================
// Log Level Enumeration
// =============================================================================

enum LogLevel
{
    LOG_ERROR = 1,
    LOG_WARN = 2,
    LOG_INFO = 3,
    LOG_DEBUG = 4,
    LOG_TRACE = 5
};

// =============================================================================
// Data Structures
// =============================================================================

typedef struct
{
    int pid;
    char* processname;
} ProcessInfo;

typedef struct
{
    uintptr_t base;
    size_t size;
    bool is_64bit;
    char* modulename;
} ModuleInfo;

typedef struct
{
    uintptr_t address;
    char* name;
    size_t size;
    char* type;             // Function, Variable, etc.
    char* scope;            // Global, Local, etc.
    uintptr_t module_base;  // Base address of containing module
    char* file_name;        // Source file name (if available)
    int line_number;        // Line number (if available)
} SymbolInfo;

typedef struct
{
    uint64_t thread_id;  // Thread ID
    char* name;          // Thread name (if available)
    uint64_t pc;         // Program counter (RIP)
    uint64_t sp;         // Stack pointer (RSP)
    uint64_t fp;         // Frame pointer (RBP)
    int state;           // Thread state (running, waiting, etc.)
    int suspend_count;   // Suspend count
} ThreadInfo;

typedef struct
{
    uintptr_t start;
    uintptr_t end;
    uint32_t protection;  // PROT_READ=1, PROT_WRITE=2, PROT_EXEC=4
    char* pathname;
} RegionInfo;

// =============================================================================
// Logging Functions
// =============================================================================

extern "C" NATIVE_API void native_log(int level, const char* message);
NATIVE_API int debug_log(LogLevel level, const char* format, ...);

// =============================================================================
// Process Functions
// =============================================================================

extern "C" NATIVE_API int get_pid_native();
extern "C" NATIVE_API ProcessInfo* enumerate_processes(size_t* count);
extern "C" NATIVE_API bool suspend_process(int pid);
extern "C" NATIVE_API bool resume_process(int pid);

// =============================================================================
// Module Functions
// =============================================================================

extern "C" NATIVE_API ModuleInfo* enumerate_modules(DWORD pid, size_t* count);

// =============================================================================
// Symbol Functions
// =============================================================================

extern "C" NATIVE_API SymbolInfo* enumerate_symbols(int pid, uintptr_t module_base, size_t* count);

// =============================================================================
// Thread Functions
// =============================================================================

extern "C" NATIVE_API ThreadInfo* enumerate_threads(int pid, size_t* count);
extern "C" NATIVE_API void free_thread_info(ThreadInfo* threads, size_t count);

// =============================================================================
// Region Functions
// =============================================================================

/**
 * Enumerate memory regions (structured array)
 * @param pid Process ID
 * @param count Output parameter for number of regions
 * @param include_filenames Whether to include mapped file names
 * @return Array of RegionInfo structures, or nullptr on error. Caller must call free_region_info.
 */
extern "C" NATIVE_API RegionInfo* enumerate_regions(DWORD pid, size_t* count,
                                                    bool include_filenames);

/**
 * Free region info array
 * @param regions Array returned by enumerate_regions
 * @param count Number of elements in array
 */
extern "C" NATIVE_API void free_region_info(RegionInfo* regions, size_t count);

/**
 * Enumerate memory regions to buffer (legacy API for backward compatibility)
 * @param pid Process ID
 * @param buffer Output buffer
 * @param buffer_size Buffer size
 * @param include_filenames Whether to include mapped file names
 */
extern "C" NATIVE_API void enumerate_regions_to_buffer(DWORD pid, char* buffer, size_t buffer_size,
                                                       bool include_filenames);

// =============================================================================
// Initialization
// =============================================================================

extern "C" NATIVE_API int native_init(int mode);

// =============================================================================
// Process Icon
// =============================================================================

extern "C" NATIVE_API const unsigned char* get_process_icon_native(int pid, size_t* size);

// =============================================================================
// Debugger Control Functions (stub implementations for Windows)
// =============================================================================

extern "C" NATIVE_API int continue_execution_native(uintptr_t thread_id);
extern "C" NATIVE_API int single_step_native(uintptr_t thread_id);
extern "C" NATIVE_API int read_register_native(uintptr_t thread_id, const char* reg_name,
                                               uint64_t* value);
extern "C" NATIVE_API int write_register_native(uintptr_t thread_id, const char* reg_name,
                                                uint64_t value);
extern "C" NATIVE_API bool is_in_break_state_native();

// =============================================================================
// Trace File Output Functions (stub implementations for Windows)
// =============================================================================

extern "C" NATIVE_API void enable_trace_file_output_native(const char* filepath);
extern "C" NATIVE_API void disable_trace_file_output_native();
extern "C" NATIVE_API bool is_trace_file_output_enabled_native();
extern "C" NATIVE_API const char* get_trace_file_path_native();
extern "C" NATIVE_API uint32_t get_trace_file_entry_count_native();
extern "C" NATIVE_API bool is_trace_ended_by_end_address_native();
extern "C" NATIVE_API void enable_full_memory_cache_native(const char* dump_filepath,
                                                           const char* log_filepath);
extern "C" NATIVE_API void disable_full_memory_cache_native();

#endif  // WINDOWS_NATIVE_API_H

```

`src/server/src/cpp/src/windows/debugger/debugger.cpp`:

```cpp
#include "debugger.h"

#include "../core/native_api.h"

// Global debugger instance
Debugger* g_debugger = nullptr;

// ============================================================================
// Debugger class implementation (Mock)
// ============================================================================

Debugger::Debugger(int pid) : pid_(pid), running_(false), debug_state_(DebugState::NotStarted)
{
    // Initialize watchpoint slots
    for (int i = 0; i < MAX_WATCHPOINTS; i++)
    {
        watchpoints_[i].used = false;
        watchpoints_[i].address = 0;
        watchpoints_[i].size = 0;
        watchpoints_[i].type = WatchpointType::WRITE;
    }

    // Initialize breakpoint slots
    for (int i = 0; i < MAX_BREAKPOINTS; i++)
    {
        breakpoints_[i].used = false;
        breakpoints_[i].address = 0;
        breakpoints_[i].hit_count = 0;
        breakpoints_[i].target_count = 0;
    }

    // Initialize software breakpoint slots
    for (int i = 0; i < MAX_SOFTWARE_BREAKPOINTS; i++)
    {
        software_breakpoints_[i].used = false;
        software_breakpoints_[i].address = 0;
        software_breakpoints_[i].original_byte = 0;
        software_breakpoints_[i].hit_count = 0;
        software_breakpoints_[i].target_count = 0;
    }
}

Debugger::~Debugger()
{
    stop();
}

bool Debugger::initialize()
{
    // Mock: Just validate that PID exists
    HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, (DWORD)pid_);
    if (hProcess == NULL)
    {
        debug_log(LOG_ERROR, "[Mock] Failed to validate process %d. Error: %lu", pid_,
                  GetLastError());
        return false;
    }
    CloseHandle(hProcess);
    debug_log(LOG_INFO, "[Mock] Debugger initialized for process %d", pid_);
    return true;
}

void Debugger::run()
{
    std::lock_guard<std::mutex> lock(mutex_);
    running_ = true;
    debug_state_ = DebugState::Running;
    debug_log(LOG_INFO, "[Mock] Debugger started for process %d", pid_);
}

void Debugger::stop()
{
    std::lock_guard<std::mutex> lock(mutex_);
    running_ = false;
    debug_state_ = DebugState::Stopped;
    debug_log(LOG_INFO, "[Mock] Debugger stopped for process %d", pid_);
}

bool Debugger::wait_for_attach(int timeout_ms)
{
    // Mock: Always succeeds immediately
    debug_log(LOG_INFO, "[Mock] Debugger attach completed for process %d", pid_);
    return true;
}

// ============================================================================
// Watchpoint operations (Mock)
// ============================================================================

int Debugger::find_free_watchpoint_slot()
{
    for (int i = 0; i < MAX_WATCHPOINTS; i++)
    {
        if (!watchpoints_[i].used) return i;
    }
    return -1;
}

int Debugger::find_watchpoint_index(uint64_t address)
{
    for (int i = 0; i < MAX_WATCHPOINTS; i++)
    {
        if (watchpoints_[i].used && watchpoints_[i].address == address) return i;
    }
    return -1;
}

int Debugger::set_watchpoint(uint64_t address, int size, WatchpointType type)
{
    std::lock_guard<std::mutex> lock(mutex_);

    int index = find_free_watchpoint_slot();
    if (index < 0)
    {
        debug_log(LOG_ERROR, "[Mock] No free watchpoint slots available");
        return -1;
    }

    watchpoints_[index].used = true;
    watchpoints_[index].address = address;
    watchpoints_[index].size = size;
    watchpoints_[index].type = type;

    debug_log(LOG_INFO, "[Mock] Set watchpoint at 0x%llx (size=%d, type=%d, slot=%d)",
              (unsigned long long)address, size, (int)type, index);
    return index;
}

int Debugger::remove_watchpoint(uint64_t address)
{
    std::lock_guard<std::mutex> lock(mutex_);

    int index = find_watchpoint_index(address);
    if (index < 0)
    {
        debug_log(LOG_WARN, "[Mock] Watchpoint not found at 0x%llx", (unsigned long long)address);
        return -1;
    }

    watchpoints_[index].used = false;
    watchpoints_[index].address = 0;
    debug_log(LOG_INFO, "[Mock] Removed watchpoint at 0x%llx (slot=%d)",
              (unsigned long long)address, index);
    return 0;
}

// ============================================================================
// Hardware breakpoint operations (Mock)
// ============================================================================

int Debugger::find_free_breakpoint_slot()
{
    for (int i = 0; i < MAX_BREAKPOINTS; i++)
    {
        if (!breakpoints_[i].used) return i;
    }
    return -1;
}

int Debugger::find_breakpoint_index(uint64_t address)
{
    for (int i = 0; i < MAX_BREAKPOINTS; i++)
    {
        if (breakpoints_[i].used && breakpoints_[i].address == address) return i;
    }
    return -1;
}

int Debugger::set_breakpoint(uint64_t address, int hit_count, bool is_software)
{
    if (is_software)
    {
        return set_software_breakpoint(address, hit_count);
    }

    std::lock_guard<std::mutex> lock(mutex_);

    int index = find_free_breakpoint_slot();
    if (index < 0)
    {
        debug_log(LOG_ERROR, "[Mock] No free hardware breakpoint slots available");
        return -1;
    }

    breakpoints_[index].used = true;
    breakpoints_[index].address = address;
    breakpoints_[index].hit_count = 0;
    breakpoints_[index].target_count = hit_count;

    debug_log(LOG_INFO, "[Mock] Set hardware breakpoint at 0x%llx (hit_count=%d, slot=%d)",
              (unsigned long long)address, hit_count, index);
    return index;
}

int Debugger::remove_breakpoint(uint64_t address)
{
    std::lock_guard<std::mutex> lock(mutex_);

    int index = find_breakpoint_index(address);
    if (index < 0)
    {
        debug_log(LOG_WARN, "[Mock] Hardware breakpoint not found at 0x%llx",
                  (unsigned long long)address);
        return -1;
    }

    breakpoints_[index].used = false;
    breakpoints_[index].address = 0;
    debug_log(LOG_INFO, "[Mock] Removed hardware breakpoint at 0x%llx (slot=%d)",
              (unsigned long long)address, index);
    return 0;
}

// ============================================================================
// Software breakpoint operations (Mock)
// ============================================================================

int Debugger::find_free_software_breakpoint_slot()
{
    for (int i = 0; i < MAX_SOFTWARE_BREAKPOINTS; i++)
    {
        if (!software_breakpoints_[i].used) return i;
    }
    return -1;
}

int Debugger::find_software_breakpoint_index(uint64_t address)
{
    for (int i = 0; i < MAX_SOFTWARE_BREAKPOINTS; i++)
    {
        if (software_breakpoints_[i].used && software_breakpoints_[i].address == address) return i;
    }
    return -1;
}

int Debugger::set_software_breakpoint(uint64_t address, int hit_count)
{
    std::lock_guard<std::mutex> lock(mutex_);

    int index = find_free_software_breakpoint_slot();
    if (index < 0)
    {
        debug_log(LOG_ERROR, "[Mock] No free software breakpoint slots available");
        return -1;
    }

    software_breakpoints_[index].used = true;
    software_breakpoints_[index].address = address;
    software_breakpoints_[index].original_byte = 0xCC;  // Mock: pretend we saved INT3
    software_breakpoints_[index].hit_count = 0;
    software_breakpoints_[index].target_count = hit_count;

    debug_log(LOG_INFO, "[Mock] Set software breakpoint at 0x%llx (hit_count=%d, slot=%d)",
              (unsigned long long)address, hit_count, index);
    return index;
}

int Debugger::remove_software_breakpoint(uint64_t address)
{
    std::lock_guard<std::mutex> lock(mutex_);

    int index = find_software_breakpoint_index(address);
    if (index < 0)
    {
        debug_log(LOG_WARN, "[Mock] Software breakpoint not found at 0x%llx",
                  (unsigned long long)address);
        return -1;
    }

    software_breakpoints_[index].used = false;
    software_breakpoints_[index].address = 0;
    debug_log(LOG_INFO, "[Mock] Removed software breakpoint at 0x%llx (slot=%d)",
              (unsigned long long)address, index);
    return 0;
}

bool Debugger::get_software_breakpoint_original_bytes(uint64_t address, uint8_t* out_bytes,
                                                      size_t* out_size)
{
    std::lock_guard<std::mutex> lock(mutex_);

    int index = find_software_breakpoint_index(address);
    if (index < 0)
    {
        debug_log(LOG_WARN, "[Mock] Software breakpoint not found at 0x%llx for original bytes",
                  (unsigned long long)address);
        return false;
    }

    if (out_bytes && out_size)
    {
        out_bytes[0] = software_breakpoints_[index].original_byte;
        *out_size = 1;
    }

    debug_log(LOG_DEBUG, "[Mock] Retrieved original bytes for software breakpoint at 0x%llx",
              (unsigned long long)address);
    return true;
}

// ============================================================================
// Debug control (Mock)
// ============================================================================

int Debugger::continue_execution(DWORD thread_id)
{
    std::lock_guard<std::mutex> lock(mutex_);
    debug_state_ = DebugState::Running;
    debug_log(LOG_INFO, "[Mock] Continue execution for thread %lu", thread_id);
    return 0;
}

int Debugger::single_step(DWORD thread_id)
{
    std::lock_guard<std::mutex> lock(mutex_);
    debug_state_ = DebugState::SingleStepping;
    debug_log(LOG_INFO, "[Mock] Single step for thread %lu", thread_id);
    return 0;
}

bool Debugger::is_in_break_state() const
{
    DebugState state = debug_state_.load();
    return state == DebugState::BreakpointHit || state == DebugState::WatchpointHit;
}

// ============================================================================
// C API implementations for Rust FFI
// ============================================================================

extern "C" int continue_execution_native(uintptr_t thread_id)
{
    if (g_debugger)
    {
        return g_debugger->continue_execution((DWORD)thread_id);
    }
    debug_log(LOG_WARN, "[Mock] continue_execution_native: No debugger attached");
    return -1;
}

extern "C" int single_step_native(uintptr_t thread_id)
{
    if (g_debugger)
    {
        return g_debugger->single_step((DWORD)thread_id);
    }
    debug_log(LOG_WARN, "[Mock] single_step_native: No debugger attached");
    return -1;
}

extern "C" bool is_in_break_state_native()
{
    if (g_debugger)
    {
        return g_debugger->is_in_break_state();
    }
    return false;
}

extern "C" int set_watchpoint_native(int pid, uint64_t address, int size, int type)
{
    if (g_debugger && g_debugger->get_pid() == pid)
    {
        return g_debugger->set_watchpoint(address, size, static_cast<WatchpointType>(type));
    }
    debug_log(LOG_WARN, "[Mock] set_watchpoint_native: Debugger not attached to pid %d", pid);
    return -1;
}

extern "C" int remove_watchpoint_native(int pid, uint64_t address)
{
    if (g_debugger && g_debugger->get_pid() == pid)
    {
        return g_debugger->remove_watchpoint(address);
    }
    debug_log(LOG_WARN, "[Mock] remove_watchpoint_native: Debugger not attached to pid %d", pid);
    return -1;
}

extern "C" int set_breakpoint_native(int pid, uint64_t address, int hit_count)
{
    if (g_debugger && g_debugger->get_pid() == pid)
    {
        return g_debugger->set_breakpoint(address, hit_count, false);
    }
    debug_log(LOG_WARN, "[Mock] set_breakpoint_native: Debugger not attached to pid %d", pid);
    return -1;
}

extern "C" int remove_breakpoint_native(int pid, uint64_t address)
{
    if (g_debugger && g_debugger->get_pid() == pid)
    {
        return g_debugger->remove_breakpoint(address);
    }
    debug_log(LOG_WARN, "[Mock] remove_breakpoint_native: Debugger not attached to pid %d", pid);
    return -1;
}

extern "C" int set_software_breakpoint_native(int pid, uint64_t address, int hit_count)
{
    if (g_debugger && g_debugger->get_pid() == pid)
    {
        return g_debugger->set_software_breakpoint(address, hit_count);
    }
    debug_log(LOG_WARN, "[Mock] set_software_breakpoint_native: Debugger not attached to pid %d",
              pid);
    return -1;
}

extern "C" int remove_software_breakpoint_native(int pid, uint64_t address)
{
    if (g_debugger && g_debugger->get_pid() == pid)
    {
        return g_debugger->remove_software_breakpoint(address);
    }
    debug_log(LOG_WARN,
              "[Mock] remove_software_breakpoint_native: Debugger not attached to pid %d", pid);
    return -1;
}

extern "C" bool get_software_breakpoint_original_bytes_native(uint64_t address, uint8_t* out_bytes,
                                                              size_t* out_size)
{
    if (g_debugger)
    {
        return g_debugger->get_software_breakpoint_original_bytes(address, out_bytes, out_size);
    }
    debug_log(LOG_WARN,
              "[Mock] get_software_breakpoint_original_bytes_native: No debugger attached");
    return false;
}

// ============================================================================
// Signal configuration (Mock - signals are Unix-specific)
// ============================================================================

extern "C" void set_signal_config_native(int signal, bool catch_signal, bool pass_signal)
{
    // Mock: Windows does not have Unix signals
    debug_log(LOG_DEBUG, "[Mock] set_signal_config_native: Signals not supported on Windows");
}

extern "C" void get_signal_config_native(int signal, bool* catch_signal, bool* pass_signal)
{
    // Mock: Windows does not have Unix signals
    if (catch_signal) *catch_signal = false;
    if (pass_signal) *pass_signal = false;
    debug_log(LOG_DEBUG, "[Mock] get_signal_config_native: Signals not supported on Windows");
}

extern "C" size_t get_all_signal_configs_native(int* signals, bool* catch_signals,
                                                bool* pass_signals, size_t max_count)
{
    // Mock: Windows does not have Unix signals
    debug_log(LOG_DEBUG, "[Mock] get_all_signal_configs_native: Signals not supported on Windows");
    return 0;
}

extern "C" void remove_signal_config_native(int signal)
{
    // Mock: Windows does not have Unix signals
    debug_log(LOG_DEBUG, "[Mock] remove_signal_config_native: Signals not supported on Windows");
}

// ============================================================================
// Debugger lifecycle
// ============================================================================

extern "C" bool debugger_new(int pid)
{
    if (g_debugger)
    {
        debug_log(LOG_WARN, "[Mock] Debugger already exists for pid %d", g_debugger->get_pid());
        // If same pid, return success
        if (g_debugger->get_pid() == pid)
        {
            return true;
        }
        // Different pid, clean up old debugger
        delete g_debugger;
        g_debugger = nullptr;
    }

    g_debugger = new Debugger(pid);
    if (!g_debugger->initialize())
    {
        delete g_debugger;
        g_debugger = nullptr;
        return false;
    }

    g_debugger->run();
    debug_log(LOG_INFO, "[Mock] Created debugger for pid %d", pid);
    return true;
}

extern "C" int attach_debugger_native(int pid)
{
    if (g_debugger)
    {
        debug_log(LOG_WARN, "[Mock] Debugger already attached to pid %d", g_debugger->get_pid());
        return -1;
    }

    g_debugger = new Debugger(pid);
    if (!g_debugger->initialize())
    {
        delete g_debugger;
        g_debugger = nullptr;
        return -1;
    }

    g_debugger->run();
    debug_log(LOG_INFO, "[Mock] Attached debugger to pid %d", pid);
    return 0;
}

extern "C" int detach_debugger_native(int pid)
{
    if (!g_debugger || g_debugger->get_pid() != pid)
    {
        debug_log(LOG_WARN, "[Mock] Debugger not attached to pid %d", pid);
        return -1;
    }

    g_debugger->stop();
    delete g_debugger;
    g_debugger = nullptr;
    debug_log(LOG_INFO, "[Mock] Detached debugger from pid %d", pid);
    return 0;
}

extern "C" bool is_debugger_attached_native(int pid)
{
    return g_debugger && g_debugger->get_pid() == pid && g_debugger->is_running();
}

```

`src/server/src/cpp/src/windows/debugger/debugger.h`:

```h
#ifndef WINDOWS_DEBUGGER_H
#define WINDOWS_DEBUGGER_H

#include <windows.h>

#include <atomic>
#include <cstdint>
#include <mutex>

#include "../../common/dll_export.h"
#include "../../common/exception_info.h"

// Watchpoint type enumeration
enum class WatchpointType
{
    READ = 1,
    WRITE = 2,
    READWRITE = 3
};

// Debug state enumeration
enum class DebugState
{
    NotStarted,
    Running,
    BreakpointHit,
    WatchpointHit,
    SingleStepping,
    Stopped
};

// Maximum number of hardware watchpoints/breakpoints (x86_64 has DR0-DR3)
static const int MAX_WATCHPOINTS = 4;
static const int MAX_BREAKPOINTS = 4;
static const int MAX_SOFTWARE_BREAKPOINTS = 256;

// Watchpoint slot info
struct WatchpointSlot
{
    bool used = false;
    uint64_t address = 0;
    int size = 0;
    WatchpointType type = WatchpointType::WRITE;
};

// Breakpoint slot info
struct BreakpointSlot
{
    bool used = false;
    uint64_t address = 0;
    int hit_count = 0;
    int target_count = 0;
};

// Software breakpoint slot info
struct SoftwareBreakpointSlot
{
    bool used = false;
    uint64_t address = 0;
    uint8_t original_byte = 0;  // Original byte at BP address (before INT3)
    int hit_count = 0;
    int target_count = 0;
};

// Exception type constants (matching common/exception_info.h)
#define EXCEPTION_BREAKPOINT_TYPE 1
#define EXCEPTION_WATCHPOINT_TYPE 2
#define EXCEPTION_SINGLE_STEP_TYPE 3

/**
 * Mock Debugger class for Windows
 *
 * This is a mock implementation that provides the expected interface
 * without actual debugging functionality. It can be extended with
 * real Windows Debug API implementation in the future.
 */
class Debugger
{
public:
    Debugger(int pid);
    ~Debugger();

    // Initialization and control
    bool initialize();
    void run();
    void stop();
    bool wait_for_attach(int timeout_ms = 10000);

    // Watchpoint operations (mock)
    int set_watchpoint(uint64_t address, int size, WatchpointType type);
    int remove_watchpoint(uint64_t address);

    // Hardware breakpoint operations (mock)
    int set_breakpoint(uint64_t address, int hit_count, bool is_software = false);
    int remove_breakpoint(uint64_t address);

    // Software breakpoint operations (mock)
    int set_software_breakpoint(uint64_t address, int hit_count);
    int remove_software_breakpoint(uint64_t address);
    bool get_software_breakpoint_original_bytes(uint64_t address, uint8_t* out_bytes,
                                                size_t* out_size);

    // Debug control
    int continue_execution(DWORD thread_id);
    int single_step(DWORD thread_id);

    // State accessors
    DebugState get_debug_state() const
    {
        return debug_state_.load();
    }
    bool is_in_break_state() const;

    int get_pid() const
    {
        return pid_;
    }
    bool is_running() const
    {
        return running_.load();
    }

private:
    int pid_;
    std::atomic<bool> running_;
    std::atomic<DebugState> debug_state_;
    std::mutex mutex_;

    // Watchpoint and breakpoint storage (for mock state tracking)
    WatchpointSlot watchpoints_[MAX_WATCHPOINTS];
    BreakpointSlot breakpoints_[MAX_BREAKPOINTS];
    SoftwareBreakpointSlot software_breakpoints_[MAX_SOFTWARE_BREAKPOINTS];

    // Helper functions
    int find_free_watchpoint_slot();
    int find_watchpoint_index(uint64_t address);
    int find_free_breakpoint_slot();
    int find_breakpoint_index(uint64_t address);
    int find_free_software_breakpoint_slot();
    int find_software_breakpoint_index(uint64_t address);
};

// Global debugger instance
extern Debugger* g_debugger;

// C API for Rust FFI
extern "C"
{
    // Debugger control
    NATIVE_API int continue_execution_native(uintptr_t thread_id);
    NATIVE_API int single_step_native(uintptr_t thread_id);
    NATIVE_API bool is_in_break_state_native();

    // Watchpoint operations
    NATIVE_API int set_watchpoint_native(int pid, uint64_t address, int size, int type);
    NATIVE_API int remove_watchpoint_native(int pid, uint64_t address);

    // Hardware breakpoint operations
    NATIVE_API int set_breakpoint_native(int pid, uint64_t address, int hit_count);
    NATIVE_API int remove_breakpoint_native(int pid, uint64_t address);

    // Software breakpoint operations
    NATIVE_API int set_software_breakpoint_native(int pid, uint64_t address, int hit_count);
    NATIVE_API int remove_software_breakpoint_native(int pid, uint64_t address);
    NATIVE_API bool get_software_breakpoint_original_bytes_native(uint64_t address,
                                                                  uint8_t* out_bytes,
                                                                  size_t* out_size);

    // Signal configuration (mock for Windows - signals are Unix-specific)
    NATIVE_API void set_signal_config_native(int signal, bool catch_signal, bool pass_signal);
    NATIVE_API void get_signal_config_native(int signal, bool* catch_signal, bool* pass_signal);
    NATIVE_API size_t get_all_signal_configs_native(int* signals, bool* catch_signals,
                                                    bool* pass_signals, size_t max_count);
    NATIVE_API void remove_signal_config_native(int signal);

    // Debugger lifecycle
    NATIVE_API bool debugger_new(int pid);
    NATIVE_API int attach_debugger_native(int pid);
    NATIVE_API int detach_debugger_native(int pid);
    NATIVE_API bool is_debugger_attached_native(int pid);
}

#endif  // WINDOWS_DEBUGGER_H

```

`src/server/src/lib.rs`:

```rs
#![recursion_limit = "256"]

use ctor::ctor;
use std::net::IpAddr;
use std::thread;

mod allocator;
mod api;
mod logger;
#[cfg(any(target_os = "macos", target_os = "ios"))]
pub mod macho_bridge;
mod native_bridge;
mod ptrscan;
mod request;
mod serve;
mod util;
mod wasm_bridge;

#[ctor]
fn main() {
    thread::spawn(|| {
        let runtime = tokio::runtime::Runtime::new().unwrap();

        runtime.block_on(async {
            std::env::set_var("DBGSRV_RUNNING_MODE", "embedded");

            let host: IpAddr = "0.0.0.0".parse().unwrap();
            let port: u16 = 3030;
            
            logger::init_log(None);
            log::info!("memory_spy has started listening on host {} and port {}.", host, port);
            serve::serve(1, host, port).await;
        });
    });
}

```

`src/server/src/logger.rs`:

```rs
use chrono::Local;
use colored::*;
use env_logger::{Builder, Env};
use log::info;
use log::LevelFilter;
use std::io::Write;
use std::fs::OpenOptions;
use std::sync::Mutex;
use warp::log::Info;

lazy_static::lazy_static! {
    static ref LOG_FILE: Mutex<Option<std::fs::File>> = Mutex::new(None);
}

static EXCLUDED_PATHS: &[&str] = &["/_next", "/exceptioninfo", "/resolveaddr", "/api/pty/", "/api/debug/trace/status"];
static EXCLUDED_EXTENSIONS: &[&str] = &[
    ".png", ".jpg", ".jpeg", ".gif", ".ico", ".svg", ".webp", ".bmp", ".tiff",
];

fn color_native_prefix(message: &str) -> String {
    if message.starts_with("[NATIVE]") {
        let parts: Vec<&str> = message.splitn(2, ']').collect();
        if parts.len() == 2 {
            format!("{}{}", "[NATIVE]".color(Color::BrightRed), parts[1])
        } else {
            message.to_string()
        }
    } else {
        message.to_string()
    }
}

pub fn init_log(log_file_path: Option<&str>) {
    if let Some(path) = log_file_path {
        match OpenOptions::new()
            .create(true)
            .append(true)
            .open(path)
        {
            Ok(file) => {
                *LOG_FILE.lock().unwrap() = Some(file);
                eprintln!("Log file output enabled: {}", path);
            }
            Err(e) => {
                eprintln!("Failed to open log file {}: {}", path, e);
            }
        }
    }

    Builder::new()
        .format(|buf, record| {
            let level = record.level();
            let (level_string, level_color) = match level {
                log::Level::Error => ("ERROR", Color::Red),
                log::Level::Warn => ("WARN ", Color::Yellow),
                log::Level::Info => ("INFO ", Color::Green),
                log::Level::Debug => ("DEBUG", Color::Blue),
                log::Level::Trace => ("TRACE", Color::Magenta),
            };
            let args = record.args().to_string();
            let colored_args = if args.contains("GET")
                || args.contains("POST")
                || args.contains("PUT")
                || args.contains("DELETE")
            {
                let parts: Vec<&str> = args.splitn(3, ' ').collect();
                if parts.len() == 3 {
                    format!(
                        "{} {} {}",
                        parts[0].color(Color::Cyan),
                        parts[1].color(Color::Yellow),
                        color_native_prefix(parts[2])
                    )
                } else {
                    color_native_prefix(&args)
                }
            } else {
                color_native_prefix(&args)
            };
            
            // File output (no color)
            if let Some(ref mut file) = *LOG_FILE.lock().unwrap() {
                let _ = writeln!(
                    file,
                    "{} [{}] {}",
                    Local::now().format("%Y-%m-%d %H:%M:%S"),
                    level_string,
                    args
                );
            }
            
            // Console output (with color)
            writeln!(
                buf,
                "{} [{}] {}",
                Local::now()
                    .format("%H:%M:%S")
                    .to_string()
                    .color(Color::White),
                level_string.color(level_color),
                colored_args
            )
        })
        .filter_level(LevelFilter::Error)
        .parse_env(Env::default().default_filter_or("info"))
        .init();
    
}


pub fn http_log(info: Info) {
    if EXCLUDED_PATHS
        .iter()
        .any(|prefix| info.path().starts_with(prefix))
    {
        return;
    }

    // readprocessmemory
    if info.path() == "/api/memory/read" && (info.method() == "GET" || info.method() == "OPTIONS") {
        return;
    }
    if info.path() == "/api/debug/exception" && (info.method() == "GET" || info.method() == "OPTIONS") {
        return;
    }
    if info.path() == "/api/memory/resolve" && (info.method() == "GET" || info.method() == "OPTIONS") {
        return;
    }
    if info.path() == "/health" && (info.method() == "GET" || info.method() == "OPTIONS") {
        return;
    }
    if EXCLUDED_EXTENSIONS
        .iter()
        .any(|ext| info.path().ends_with(ext))
    {
        return;
    }

    info!(
        "{} {} {} {}ms",
        info.method(),
        info.path(),
        info.status(),
        info.elapsed().as_millis(),
    );
}

```

`src/server/src/macho_bridge.rs`:

```rs
// macho_bridge.rs
// Rust FFI bindings for MachOKit Swift library

use libc::{c_char, c_void};
use std::ffi::{CStr, CString};
use std::path::Path;

// Logging callback from Swift
#[no_mangle]
pub extern "C" fn rust_log_from_swift(level: i32, message: *const c_char) {
    if message.is_null() {
        return;
    }
    let msg = unsafe {
        match CStr::from_ptr(message).to_str() {
            Ok(s) => s,
            Err(_) => return,
        }
    };
    match level {
        0 => log::info!("[MachOBridge] {}", msg),
        1 => log::warn!("[MachOBridge] {}", msg),
        2 => log::error!("[MachOBridge] {}", msg),
        3 => log::debug!("[MachOBridge] {}", msg),
        _ => log::info!("[MachOBridge] {}", msg),
    }
}

/// Symbol type from MachO
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum MachOSymbolType {
    Undefined = 0,
    Absolute = 1,
    Section = 2,
    Indirect = 3,
}

/// C-compatible MachO symbol structure
#[repr(C)]
#[derive(Debug)]
pub struct CMachOSymbol {
    pub name: *const c_char,
    pub address: u64,
    pub size: u64,
    pub symbol_type: u8,
}

/// C-compatible MachO section structure
#[repr(C)]
#[derive(Debug)]
pub struct CMachOSection {
    pub sectname: *const c_char,
    pub segname: *const c_char,
    pub addr: u64,
    pub size: u64,
    pub offset: u32,
    pub flags: u32,
}

/// C-compatible MachO segment structure
#[repr(C)]
#[derive(Debug)]
pub struct CMachOSegment {
    pub segname: *const c_char,
    pub vmaddr: u64,
    pub vmsize: u64,
    pub fileoff: u64,
    pub filesize: u64,
    pub maxprot: i32,
    pub initprot: i32,
    pub nsects: u32,
}

/// C-compatible MachO parse result structure
#[repr(C)]
pub struct CMachOParseResult {
    pub success: bool,
    pub error_message: *const c_char,
    pub is_64bit: bool,
    pub cpu_type: i32,
    pub cpu_subtype: i32,
    pub file_type: u32,
    pub ncmds: u32,
    pub symbols: *mut CMachOSymbol,
    pub symbol_count: u64,
    pub segments: *mut CMachOSegment,
    pub segment_count: u64,
    pub sections: *mut CMachOSection,
    pub section_count: u64,
}

// Opaque pointer type for Swift results
type MachoResultPtr = *mut c_void;

// FFI declarations for MachOKit Swift bridge
#[cfg(any(target_os = "macos", target_os = "ios"))]
extern "C" {
    // Cache management
    fn macho_load_dyld_cache(path: *const c_char) -> bool;
    fn macho_load_system_dyld_cache() -> bool;
    fn macho_unload_dyld_cache();
    
    // Parse functions (return opaque pointer)
    fn macho_parse_file(path: *const c_char) -> MachoResultPtr;
    fn macho_parse_from_dyld_cache(image_path: *const c_char) -> MachoResultPtr;
    
    // Result accessors
    fn macho_result_success(result: MachoResultPtr) -> bool;
    fn macho_result_error_message(result: MachoResultPtr) -> *mut c_char;
    fn macho_result_is_64bit(result: MachoResultPtr) -> bool;
    fn macho_result_cpu_type(result: MachoResultPtr) -> i32;
    fn macho_result_cpu_subtype(result: MachoResultPtr) -> i32;
    fn macho_result_file_type(result: MachoResultPtr) -> i32;
    fn macho_result_ncmds(result: MachoResultPtr) -> u32;
    
    // Symbol accessors
    fn macho_result_symbol_count(result: MachoResultPtr) -> u64;
    fn macho_result_symbol_name(result: MachoResultPtr, index: u64) -> *mut c_char;
    fn macho_result_symbol_address(result: MachoResultPtr, index: u64) -> u64;
    fn macho_result_symbol_size(result: MachoResultPtr, index: u64) -> u64;
    fn macho_result_symbol_type(result: MachoResultPtr, index: u64) -> u8;
    fn macho_result_symbol_is_external(result: MachoResultPtr, index: u64) -> bool;
    fn macho_result_symbol_is_private_external(result: MachoResultPtr, index: u64) -> bool;
    fn macho_result_symbol_is_weak_def(result: MachoResultPtr, index: u64) -> bool;
    fn macho_result_symbol_is_weak_ref(result: MachoResultPtr, index: u64) -> bool;
    fn macho_result_symbol_is_thumb(result: MachoResultPtr, index: u64) -> bool;
    fn macho_result_symbol_section_index(result: MachoResultPtr, index: u64) -> u8;
    fn macho_result_symbol_library_ordinal(result: MachoResultPtr, index: u64) -> i32;
    fn macho_result_symbol_source(result: MachoResultPtr, index: u64) -> u8;
    
    // Segment accessors
    fn macho_result_segment_count(result: MachoResultPtr) -> u64;
    fn macho_result_segment_name(result: MachoResultPtr, index: u64) -> *mut c_char;
    fn macho_result_segment_vmaddr(result: MachoResultPtr, index: u64) -> u64;
    fn macho_result_segment_vmsize(result: MachoResultPtr, index: u64) -> u64;
    
    // Section accessors
    fn macho_result_section_count(result: MachoResultPtr) -> u64;
    fn macho_result_section_name(result: MachoResultPtr, index: u64) -> *mut c_char;
    fn macho_result_section_segname(result: MachoResultPtr, index: u64) -> *mut c_char;
    fn macho_result_section_addr(result: MachoResultPtr, index: u64) -> u64;
    fn macho_result_section_size(result: MachoResultPtr, index: u64) -> u64;
    
    // Free functions
    fn macho_free_result(result: MachoResultPtr);
    fn macho_get_dyld_cache_image_count() -> u64;
    fn macho_get_dyld_cache_image_path(index: u64) -> *mut c_char;
    fn macho_free_string(s: *mut c_char);
    
    // Module size functions
    fn macho_get_module_size_by_name(name: *const c_char) -> u64;
    fn macho_get_module_size_by_address(address: u64) -> u64;
    fn macho_get_module_size_from_cache(image_path: *const c_char) -> u64;
    
    // Loaded image enumeration (for current process)
    fn macho_get_loaded_image_count() -> u32;
    fn macho_get_loaded_image_path(index: u32) -> *mut c_char;
    fn macho_get_loaded_image_base(index: u32) -> u64;
    fn macho_get_loaded_image_size(index: u32) -> u64;
    fn macho_get_loaded_image_slide(index: u32) -> i64;
}

/// Symbol source - where the symbol was found
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum MachOSymbolSource {
    SymbolTable = 0,
    ExportTrie = 1,
}

/// Rust-friendly MachO symbol with extended metadata
#[derive(Debug, Clone)]
pub struct MachOSymbol {
    pub name: String,
    pub address: u64,
    pub size: u64,
    pub symbol_type: MachOSymbolType,
    pub is_external: bool,
    pub is_private_external: bool,
    pub is_weak_def: bool,
    pub is_weak_ref: bool,
    pub is_thumb: bool,
    pub section_index: u8,
    pub library_ordinal: i32,
    pub source: MachOSymbolSource,
}

/// Rust-friendly MachO section
#[derive(Debug, Clone)]
pub struct MachOSection {
    pub sectname: String,
    pub segname: String,
    pub addr: u64,
    pub size: u64,
    pub offset: u32,
    pub flags: u32,
}

/// Rust-friendly MachO segment
#[derive(Debug, Clone)]
pub struct MachOSegment {
    pub segname: String,
    pub vmaddr: u64,
    pub vmsize: u64,
    pub fileoff: u64,
    pub filesize: u64,
    pub maxprot: i32,
    pub initprot: i32,
    pub nsects: u32,
}

/// MachO parse result
#[derive(Debug, Clone)]
pub struct MachOParseResult {
    pub is_64bit: bool,
    pub cpu_type: i32,
    pub cpu_subtype: i32,
    pub file_type: u32,
    pub ncmds: u32,
    pub symbols: Vec<MachOSymbol>,
    pub segments: Vec<MachOSegment>,
    pub sections: Vec<MachOSection>,
}

/// Check if a path is a system library (in dyld shared cache)
pub fn is_system_library(path: &str) -> bool {
    let system_prefixes = [
        "/System/Library/",
        "/usr/lib/",
        "/System/Cryptexes/",
        "/System/iOSSupport/",
    ];
    
    system_prefixes.iter().any(|prefix| path.starts_with(prefix))
}

/// Load the system dyld shared cache
#[cfg(any(target_os = "macos", target_os = "ios"))]
pub fn load_system_dyld_cache() -> Result<(), String> {
    let success = unsafe { macho_load_system_dyld_cache() };
    if success {
        Ok(())
    } else {
        Err("Failed to load system dyld cache".to_string())
    }
}

#[cfg(not(any(target_os = "macos", target_os = "ios")))]
pub fn load_system_dyld_cache() -> Result<(), String> {
    Err("Dyld cache is only available on macOS/iOS".to_string())
}

/// Load a specific dyld cache file
#[cfg(any(target_os = "macos", target_os = "ios"))]
pub fn load_dyld_cache(path: &str) -> Result<(), String> {
    let c_path = CString::new(path).map_err(|e| e.to_string())?;
    let success = unsafe { macho_load_dyld_cache(c_path.as_ptr()) };
    if success {
        Ok(())
    } else {
        Err(format!("Failed to load dyld cache from: {}", path))
    }
}

#[cfg(not(any(target_os = "macos", target_os = "ios")))]
pub fn load_dyld_cache(_path: &str) -> Result<(), String> {
    Err("Dyld cache is only available on macOS/iOS".to_string())
}

/// Unload the currently loaded dyld cache
#[cfg(any(target_os = "macos", target_os = "ios"))]
pub fn unload_dyld_cache() {
    unsafe { macho_unload_dyld_cache() };
}

#[cfg(not(any(target_os = "macos", target_os = "ios")))]
pub fn unload_dyld_cache() {}

/// Get the number of images in the loaded dyld cache
#[cfg(any(target_os = "macos", target_os = "ios"))]
pub fn get_dyld_cache_image_count() -> u64 {
    unsafe { macho_get_dyld_cache_image_count() }
}

#[cfg(not(any(target_os = "macos", target_os = "ios")))]
pub fn get_dyld_cache_image_count() -> u64 {
    0
}

/// Get the path of an image in the dyld cache by index
#[cfg(any(target_os = "macos", target_os = "ios"))]
pub fn get_dyld_cache_image_path(index: u64) -> Option<String> {
    let ptr = unsafe { macho_get_dyld_cache_image_path(index) };
    if ptr.is_null() {
        return None;
    }
    
    let result = unsafe { CStr::from_ptr(ptr) }
        .to_string_lossy()
        .into_owned();
    
    unsafe { macho_free_string(ptr) };
    
    Some(result)
}

#[cfg(not(any(target_os = "macos", target_os = "ios")))]
pub fn get_dyld_cache_image_path(_index: u64) -> Option<String> {
    None
}

// MARK: - Module Size Functions

/// Get module size by name (for current process only)
#[cfg(any(target_os = "macos", target_os = "ios"))]
pub fn get_module_size_by_name(name: &str) -> u64 {
    let c_name = match CString::new(name) {
        Ok(s) => s,
        Err(_) => return 0,
    };
    unsafe { macho_get_module_size_by_name(c_name.as_ptr()) }
}

#[cfg(not(any(target_os = "macos", target_os = "ios")))]
pub fn get_module_size_by_name(_name: &str) -> u64 {
    0
}

/// Get module size by base address (for current process only)
#[cfg(any(target_os = "macos", target_os = "ios"))]
pub fn get_module_size_by_address(address: u64) -> u64 {
    unsafe { macho_get_module_size_by_address(address) }
}

#[cfg(not(any(target_os = "macos", target_os = "ios")))]
pub fn get_module_size_by_address(_address: u64) -> u64 {
    0
}

/// Get module size from dyld cache by path
#[cfg(any(target_os = "macos", target_os = "ios"))]
pub fn get_module_size_from_cache(image_path: &str) -> u64 {
    let c_path = match CString::new(image_path) {
        Ok(s) => s,
        Err(_) => return 0,
    };
    unsafe { macho_get_module_size_from_cache(c_path.as_ptr()) }
}

#[cfg(not(any(target_os = "macos", target_os = "ios")))]
pub fn get_module_size_from_cache(_image_path: &str) -> u64 {
    0
}

// MARK: - Loaded Image Enumeration (for current process)

/// Loaded image information
#[derive(Debug, Clone)]
pub struct LoadedImageInfo {
    pub path: String,
    pub base: u64,
    pub size: u64,
    pub slide: i64,
}

/// Get all loaded images in the current process
#[cfg(any(target_os = "macos", target_os = "ios"))]
pub fn get_loaded_images() -> Vec<LoadedImageInfo> {
    let count = unsafe { macho_get_loaded_image_count() };
    let mut images = Vec::with_capacity(count as usize);
    
    for i in 0..count {
        let path_ptr = unsafe { macho_get_loaded_image_path(i) };
        let path = if path_ptr.is_null() {
            String::new()
        } else {
            let p = unsafe { CStr::from_ptr(path_ptr) }.to_string_lossy().into_owned();
            unsafe { macho_free_string(path_ptr) };
            p
        };
        
        let base = unsafe { macho_get_loaded_image_base(i) };
        let size = unsafe { macho_get_loaded_image_size(i) };
        let slide = unsafe { macho_get_loaded_image_slide(i) };
        
        images.push(LoadedImageInfo { path, base, size, slide });
    }
    
    images
}

#[cfg(not(any(target_os = "macos", target_os = "ios")))]
pub fn get_loaded_images() -> Vec<LoadedImageInfo> {
    Vec::new()
}

/// Get the count of loaded images
#[cfg(any(target_os = "macos", target_os = "ios"))]
pub fn get_loaded_image_count() -> u32 {
    unsafe { macho_get_loaded_image_count() }
}

#[cfg(not(any(target_os = "macos", target_os = "ios")))]
pub fn get_loaded_image_count() -> u32 {
    0
}

/// List all images in the loaded dyld cache
pub fn list_dyld_cache_images() -> Vec<String> {
    let count = get_dyld_cache_image_count();
    (0..count)
        .filter_map(|i| get_dyld_cache_image_path(i))
        .collect()
}

/// Helper function to convert opaque result pointer to Rust result using accessor functions
#[cfg(any(target_os = "macos", target_os = "ios"))]
unsafe fn convert_parse_result(result_ptr: MachoResultPtr) -> Result<MachOParseResult, String> {
    if result_ptr.is_null() {
        return Err("Null result from parser".to_string());
    }
    
    if !macho_result_success(result_ptr) {
        let error_ptr = macho_result_error_message(result_ptr);
        let error_msg = if error_ptr.is_null() {
            "Unknown error".to_string()
        } else {
            let msg = CStr::from_ptr(error_ptr).to_string_lossy().into_owned();
            macho_free_string(error_ptr);
            msg
        };
        macho_free_result(result_ptr);
        return Err(error_msg);
    }
    
    // Get basic info
    let is_64bit = macho_result_is_64bit(result_ptr);
    let cpu_type = macho_result_cpu_type(result_ptr);
    let cpu_subtype = macho_result_cpu_subtype(result_ptr);
    let file_type = macho_result_file_type(result_ptr) as u32;
    let ncmds = macho_result_ncmds(result_ptr);
    
    // Convert symbols
    let symbol_count = macho_result_symbol_count(result_ptr);
    let mut symbols = Vec::with_capacity(symbol_count as usize);
    for i in 0..symbol_count {
        let name_ptr = macho_result_symbol_name(result_ptr, i);
        let name = if name_ptr.is_null() {
            String::new()
        } else {
            let s = CStr::from_ptr(name_ptr).to_string_lossy().into_owned();
            macho_free_string(name_ptr);
            s
        };
        
        let address = macho_result_symbol_address(result_ptr, i);
        let size = macho_result_symbol_size(result_ptr, i);
        let sym_type = macho_result_symbol_type(result_ptr, i);
        let source = macho_result_symbol_source(result_ptr, i);
        
        symbols.push(MachOSymbol {
            name,
            address,
            size, // Calculated from LC_FUNCTION_STARTS
            symbol_type: match sym_type {
                0 => MachOSymbolType::Undefined,
                1 => MachOSymbolType::Absolute,
                2 => MachOSymbolType::Section,
                3 | 4 => MachOSymbolType::Indirect,
                _ => MachOSymbolType::Undefined,
            },
            is_external: macho_result_symbol_is_external(result_ptr, i),
            is_private_external: macho_result_symbol_is_private_external(result_ptr, i),
            is_weak_def: macho_result_symbol_is_weak_def(result_ptr, i),
            is_weak_ref: macho_result_symbol_is_weak_ref(result_ptr, i),
            is_thumb: macho_result_symbol_is_thumb(result_ptr, i),
            section_index: macho_result_symbol_section_index(result_ptr, i),
            library_ordinal: macho_result_symbol_library_ordinal(result_ptr, i),
            source: if source == 1 { MachOSymbolSource::ExportTrie } else { MachOSymbolSource::SymbolTable },
        });
    }
    
    // Convert segments
    let segment_count = macho_result_segment_count(result_ptr);
    let mut segments = Vec::with_capacity(segment_count as usize);
    for i in 0..segment_count {
        let name_ptr = macho_result_segment_name(result_ptr, i);
        let segname = if name_ptr.is_null() {
            String::new()
        } else {
            let s = CStr::from_ptr(name_ptr).to_string_lossy().into_owned();
            macho_free_string(name_ptr);
            s
        };
        
        segments.push(MachOSegment {
            segname,
            vmaddr: macho_result_segment_vmaddr(result_ptr, i),
            vmsize: macho_result_segment_vmsize(result_ptr, i),
            fileoff: 0,
            filesize: 0,
            maxprot: 0,
            initprot: 0,
            nsects: 0,
        });
    }
    
    // Convert sections
    let section_count = macho_result_section_count(result_ptr);
    let mut sections = Vec::with_capacity(section_count as usize);
    for i in 0..section_count {
        let sectname_ptr = macho_result_section_name(result_ptr, i);
        let sectname = if sectname_ptr.is_null() {
            String::new()
        } else {
            let s = CStr::from_ptr(sectname_ptr).to_string_lossy().into_owned();
            macho_free_string(sectname_ptr);
            s
        };
        
        let segname_ptr = macho_result_section_segname(result_ptr, i);
        let segname = if segname_ptr.is_null() {
            String::new()
        } else {
            let s = CStr::from_ptr(segname_ptr).to_string_lossy().into_owned();
            macho_free_string(segname_ptr);
            s
        };
        
        sections.push(MachOSection {
            sectname,
            segname,
            addr: macho_result_section_addr(result_ptr, i),
            size: macho_result_section_size(result_ptr, i),
            offset: 0,
            flags: 0,
        });
    }
    
    // Free the result
    macho_free_result(result_ptr);
    
    Ok(MachOParseResult {
        is_64bit,
        cpu_type,
        cpu_subtype,
        file_type,
        ncmds,
        symbols,
        segments,
        sections,
    })
}

/// Parse a MachO file from disk
#[cfg(any(target_os = "macos", target_os = "ios"))]
pub fn parse_macho_file(path: &str) -> Result<MachOParseResult, String> {
    let c_path = CString::new(path).map_err(|e| e.to_string())?;
    let c_result = unsafe { macho_parse_file(c_path.as_ptr()) };
    unsafe { convert_parse_result(c_result) }
}

#[cfg(not(any(target_os = "macos", target_os = "ios")))]
pub fn parse_macho_file(_path: &str) -> Result<MachOParseResult, String> {
    Err("MachO parsing is only available on macOS/iOS".to_string())
}

/// Parse a MachO file from the loaded dyld cache
#[cfg(any(target_os = "macos", target_os = "ios"))]
pub fn parse_macho_from_cache(image_path: &str) -> Result<MachOParseResult, String> {
    let c_path = CString::new(image_path).map_err(|e| e.to_string())?;
    let c_result = unsafe { macho_parse_from_dyld_cache(c_path.as_ptr()) };
    unsafe { convert_parse_result(c_result) }
}

#[cfg(not(any(target_os = "macos", target_os = "ios")))]
pub fn parse_macho_from_cache(_image_path: &str) -> Result<MachOParseResult, String> {
    Err("MachO parsing is only available on macOS/iOS".to_string())
}

/// Parse a MachO file, automatically using dyld cache for system libraries
pub fn parse_macho(path: &str) -> Result<MachOParseResult, String> {
    log::debug!("parse_macho: path={}, is_system_library={}", path, is_system_library(path));
    
    if is_system_library(path) {
        // Try to parse from dyld cache first
        log::debug!("parse_macho: Trying dyld cache for system library: {}", path);
        match parse_macho_from_cache(path) {
            Ok(result) => {
                log::debug!("parse_macho: Successfully parsed from dyld cache, symbols: {}", result.symbols.len());
                return Ok(result);
            }
            Err(e) => {
                log::debug!("parse_macho: Failed to parse from dyld cache: {}, falling back to file", e);
                // Fall back to file parsing if not in cache
            }
        }
    }
    
    // Parse from file
    log::debug!("parse_macho: Trying to parse from file: {}", path);
    parse_macho_file(path)
}

/// Initialize MachO parsing (load dyld cache if available)
pub fn init_macho_parser() -> Result<(), String> {
    #[cfg(any(target_os = "macos", target_os = "ios"))]
    {
        // Try to load system dyld cache (ignore errors, file parsing will still work)
        match load_system_dyld_cache() {
            Ok(_) => (),
            Err(e) => log::warn!("Failed to load system dyld cache: {}", e),
        }
    }
    Ok(())
}

/// Cleanup MachO parser resources
pub fn cleanup_macho_parser() {
    unload_dyld_cache();
}

/// Symbol information for FFI (matches native SymbolInfo structure)
#[derive(Debug, Clone)]
pub struct RebasedSymbol {
    pub address: usize,
    pub name: String,
    pub size: usize,
    pub symbol_type: String,
    pub scope: String,
    pub module_base: usize,
    // Mach-O specific metadata
    pub is_external: bool,
    pub is_weak_def: bool,
    pub is_thumb: bool,
    pub source: String, // "symtab" or "export_trie"
}

/// Get symbols for a module path, rebased to the specified module base address
/// This is the main entry point for replacing enum_symbols_native
pub fn get_module_symbols(module_path: &str, module_base: usize) -> Result<Vec<RebasedSymbol>, String> {
    // Parse the MachO file (automatically uses dyld cache for system libraries)
    let parse_result = parse_macho(module_path)?;
    
    if parse_result.symbols.is_empty() {
        return Err(format!("No symbols found in {}", module_path));
    }
    
    log::debug!("get_module_symbols: module_path={}, module_base=0x{:X}", module_path, module_base);
    log::debug!("  segments: {:?}", parse_result.segments.iter().map(|s| format!("{}: 0x{:X}", s.segname, s.vmaddr)).collect::<Vec<_>>());
    
    // For MachOKit symbols, the address is the offset from the start of the image.
    // We need to add module_base to get the runtime address.
    // However, if vmaddr is non-zero (position-dependent code), we need to calculate the slide.
    
    // Find the __TEXT segment's vmaddr - this is the preferred load address
    let text_segment = parse_result.segments.iter()
        .find(|seg| seg.segname == "__TEXT")
        .or_else(|| parse_result.segments.first());
    
    let preferred_base = text_segment.map(|seg| seg.vmaddr).unwrap_or(0);
    
    log::debug!("  preferred_base=0x{:X}", preferred_base);
    
    // Convert and rebase symbols
    let mut rebased_symbols: Vec<RebasedSymbol> = parse_result.symbols
        .into_iter()
        .filter(|sym| {
            // Skip undefined symbols and symbols with no address
            sym.symbol_type != MachOSymbolType::Undefined && sym.address > 0
        })
        .map(|sym| {
            // Symbol address is either:
            // 1. A file offset (for symbols from export trie) - add module_base directly
            // 2. A preferred vmaddr (for symbols from nlist) - calculate slide
            
            let runtime_address = if sym.address < preferred_base || preferred_base == 0 {
                // Address is a file offset, add module_base directly
                module_base.saturating_add(sym.address as usize)
            } else {
                // Address is a preferred vmaddr, calculate slide and apply
                let slide = (module_base as i64) - (preferred_base as i64);
                if slide >= 0 {
                    sym.address.saturating_add(slide as u64) as usize
                } else {
                    sym.address.saturating_sub((-slide) as u64) as usize
                }
            };
            
            let symbol_type_str = match sym.symbol_type {
                MachOSymbolType::Absolute => "ABS",
                MachOSymbolType::Section => "SECT",
                MachOSymbolType::Indirect => "INDR",
                MachOSymbolType::Undefined => "UNDEF",
            };
            
            // Determine scope based on external flag or symbol name
            let scope = if sym.is_external {
                "Global"
            } else if sym.is_private_external {
                "Private"
            } else if sym.name.starts_with('_') {
                "Global"
            } else {
                "Local"
            };
            
            let source_str = match sym.source {
                MachOSymbolSource::ExportTrie => "export_trie",
                MachOSymbolSource::SymbolTable => "symtab",
            };
            
            RebasedSymbol {
                address: runtime_address,
                name: sym.name.clone(),
                size: sym.size as usize,
                symbol_type: symbol_type_str.to_string(),
                scope: scope.to_string(),
                module_base,
                is_external: sym.is_external,
                is_weak_def: sym.is_weak_def,
                is_thumb: sym.is_thumb,
                source: source_str.to_string(),
            }
        })
        .collect();
    
    // Sort symbols by address
    rebased_symbols.sort_by_key(|sym| sym.address);
    
    // Log first few symbols for debugging
    if !rebased_symbols.is_empty() {
        log::debug!("  First symbols:");
        for sym in rebased_symbols.iter().take(5) {
            log::debug!("    {} @ 0x{:X}", sym.name, sym.address);
        }
    }
    
    Ok(rebased_symbols)
}

/// Check if MachOKit parsing is available for the given module path
pub fn can_parse_module(module_path: &str) -> bool {
    if is_system_library(module_path) {
        // For system libraries, check if we can access via dyld cache
        #[cfg(any(target_os = "macos", target_os = "ios"))]
        {
            // Try to ensure cache is loaded
            let _ = load_system_dyld_cache();
            return true;
        }
        #[cfg(not(any(target_os = "macos", target_os = "ios")))]
        {
            return false;
        }
    }
    
    // For non-system libraries, check if file exists
    std::path::Path::new(module_path).exists()
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    #[cfg(any(target_os = "macos", target_os = "ios"))]
    fn test_parse_system_library() {
        init_macho_parser().unwrap();
        
        // Try to parse a system library
        let result = parse_macho("/usr/lib/libSystem.B.dylib");
        assert!(result.is_ok(), "Failed to parse libSystem: {:?}", result.err());
        
        let parsed = result.unwrap();
        assert!(parsed.is_64bit);
        assert!(!parsed.symbols.is_empty() || !parsed.segments.is_empty());
        
        cleanup_macho_parser();
    }
    
    #[test]
    fn test_is_system_library() {
        assert!(is_system_library("/System/Library/Frameworks/Foundation.framework/Foundation"));
        assert!(is_system_library("/usr/lib/libSystem.B.dylib"));
        assert!(!is_system_library("/Applications/MyApp.app/Contents/MacOS/MyApp"));
        assert!(!is_system_library("/Users/test/mylib.dylib"));
    }
}

```

`src/server/src/main.rs`:

```rs
#![recursion_limit = "2048"]

use ctor::ctor;

use clap::{Arg, Command};
use std::env;
use std::net::IpAddr;

mod allocator;
mod api;
mod logger;
#[cfg(any(target_os = "macos", target_os = "ios"))]
pub mod macho_bridge;
mod native_bridge;
mod ptrscan;
mod request;
mod serve;
mod util;
mod wasm_bridge;

#[ctor]
fn init() {
    env::set_var("RUST_BACKTRACE", "full");
}

#[tokio::main]
async fn main() {
    std::env::set_var("DBGSRV_RUNNING_MODE", "normal");

    let matches = Command::new("dynadbg")
        .version("0.0.3")
        .about("Dynamic analysis tool")
        .arg(
            Arg::new("port")
                .short('p')
                .long("port")
                .num_args(1)
                .value_name("PORT")
                .help("Sets the port number to listen on"),
        )
        .arg(
            Arg::new("host")
                .short('H')
                .long("host")
                .num_args(1)
                .value_name("HOST")
                .help("Sets the host to listen on"),
        )
        .arg(
            Arg::new("log-file")
                .short('l')
                .long("log-file")
                .num_args(1)
                .value_name("FILE")
                .help("Sets the log file path (appends to existing file)"),
        )
        .arg(
            Arg::new("wasm")
                .long("wasm")
                .num_args(0)
                .help("Enable WASM mode for browser-based WebAssembly debugging"),
        )
        .arg(
            Arg::new("wasm-ws-port")
                .long("wasm-ws-port")
                .num_args(1)
                .value_name("PORT")
                .default_value("8765")
                .help("WebSocket port for WASM memory bridge (default: 8765)"),
        )
        .get_matches();

    let port: u16 = matches
        .get_one("port")
        .map(|s: &String| s.parse().expect("Valid port number"))
        .unwrap_or(3030);

    let host: IpAddr = matches
        .get_one("host")
        .map(|s: &String| s.parse().expect("Valid IP address"))
        .unwrap_or_else(|| "0.0.0.0".parse().unwrap());

    let log_file: Option<String> = matches
        .get_one("log-file")
        .map(|s: &String| s.to_string());

    let wasm_mode = matches.get_flag("wasm");
    let wasm_ws_port: u16 = matches
        .get_one::<String>("wasm-ws-port")
        .and_then(|s| s.parse().ok())
        .unwrap_or(8765);

    // Set running mode based on --wasm flag
    if wasm_mode {
        std::env::set_var("DBGSRV_RUNNING_MODE", "wasm");
        std::env::set_var("DBGSRV_WASM_WS_PORT", wasm_ws_port.to_string());
        println!("WASM mode enabled. WebSocket server will listen on port {}", wasm_ws_port);
    }

    println!(
        "DynaDbg server has started listening on host {} and port {}.",
        host, port
    );

    logger::init_log(log_file.as_deref());

    // Initialize WASM bridge if in WASM mode
    if wasm_mode {
        if let Err(e) = wasm_bridge::init_wasm_bridge().await {
            log::error!("Failed to initialize WASM bridge: {}", e);
            eprintln!("Failed to initialize WASM bridge: {}", e);
            return;
        }
    }

    // Lua engine is lightweight and doesn't need pre-initialization

    // Try to initialize dynamic library, fall back to static if not available
    // Currently only enabled in debug builds during development
    #[cfg(debug_assertions)]
    if native_bridge::init_dynamic_library() {
        log::info!("Dynamic library loaded successfully");
    }

    serve::serve(0, host, port).await;
}

```

`src/server/src/native_bridge.rs`:

```rs
#![allow(dead_code)]

use libc::{self, c_char, c_int, c_void};
use libloading::{Library, Symbol};
use serde_json::json;
use std::ffi::{CStr, CString};
use std::io::{BufRead, BufReader, Error};
use std::sync::OnceLock;

use crate::wasm_bridge;

#[cfg(any(target_os = "macos", target_os = "ios"))]
use crate::macho_bridge;

// Exception types matching C++ enum
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ExceptionType {
    Unknown = 0,
    Breakpoint = 1,
    Watchpoint = 2,
    SingleStep = 3,
    Signal = 4,
    Sigsegv = 5,
    Sigbus = 6,
    Sigfpe = 7,
    Sigill = 8,
    Sigabrt = 9,
    Sigtrap = 10,
}

impl ExceptionType {
    pub fn from_str(s: &str) -> Self {
        match s {
            "breakpoint" => ExceptionType::Breakpoint,
            "watchpoint" => ExceptionType::Watchpoint,
            "singlestep" => ExceptionType::SingleStep,
            "signal" => ExceptionType::Signal,
            "sigsegv" | "segfault" => ExceptionType::Sigsegv,
            "sigbus" => ExceptionType::Sigbus,
            "sigfpe" => ExceptionType::Sigfpe,
            "sigill" => ExceptionType::Sigill,
            "sigabrt" => ExceptionType::Sigabrt,
            "sigtrap" => ExceptionType::Sigtrap,
            _ => ExceptionType::Unknown,
        }
    }

    pub fn to_str(&self) -> &'static str {
        match self {
            ExceptionType::Breakpoint => "breakpoint",
            ExceptionType::Watchpoint => "watchpoint",
            ExceptionType::SingleStep => "singlestep",
            ExceptionType::Signal => "signal",
            ExceptionType::Sigsegv => "sigsegv",
            ExceptionType::Sigbus => "sigbus",
            ExceptionType::Sigfpe => "sigfpe",
            ExceptionType::Sigill => "sigill",
            ExceptionType::Sigabrt => "sigabrt",
            ExceptionType::Sigtrap => "sigtrap",
            ExceptionType::Unknown => "unknown",
        }
    }
}

#[cfg_attr(target_os = "android", link(name = "c++_shared", kind = "dylib"))]
#[cfg_attr(target_os = "android", link(name = "c++abi", kind = "dylib"))]
#[link(name = "native", kind = "static")]
extern "C" {
    #[link_name = "get_pid_native"]
    pub fn get_pid_native_static() -> i32;
    #[link_name = "enumerate_processes"]
    pub fn enumerate_processes_static(count: *mut usize) -> *mut ProcessInfo;
    #[link_name = "enumerate_modules"]
    pub fn enumerate_modules_static(pid: i32, count: *mut usize) -> *mut ModuleInfo;
    #[link_name = "enumerate_regions_to_buffer"]
    pub fn enumerate_regions_to_buffer_static(
        pid: i32,
        buffer: *mut u8,
        buffer_size: usize,
        include_filenames: bool,
    );
    #[link_name = "enumerate_regions"]
    pub fn enumerate_regions_static(
        pid: i32,
        count: *mut usize,
        include_filenames: bool,
    ) -> *mut RegionInfo;
    #[link_name = "free_region_info"]
    pub fn free_region_info_static(regions: *mut RegionInfo, count: usize);
    #[link_name = "read_memory_native"]
    pub fn read_memory_native_static(
        pid: libc::c_int,
        address: libc::uintptr_t,
        size: libc::size_t,
        buffer: *mut u8,
    ) -> libc::ssize_t;
    #[link_name = "read_memory_native_with_method"]
    pub fn read_memory_native_with_method_static(
        pid: libc::c_int,
        address: libc::uintptr_t,
        size: libc::size_t,
        buffer: *mut u8,
        mode: libc::c_int,
    ) -> libc::ssize_t;
    #[link_name = "write_memory_native"]
    pub fn write_memory_native_static(
        pid: i32,
        address: libc::uintptr_t,
        size: libc::size_t,
        buffer: *const u8,
    ) -> libc::ssize_t;
    #[link_name = "suspend_process"]
    pub fn suspend_process_static(pid: i32) -> bool;
    #[link_name = "resume_process"]
    pub fn resume_process_static(pid: i32) -> bool;
    #[link_name = "native_init"]
    pub fn native_init_static(mode: i32) -> libc::c_int;
    #[link_name = "explore_directory"]
    pub fn explore_directory_static(path: *const c_char, max_depth: i32) -> *mut libc::c_char;
    #[link_name = "read_file"]
    pub fn read_file_static(
        path: *const c_char,
        size: *mut usize,
        error_message: *mut *mut c_char,
    ) -> *const c_void;
    #[link_name = "get_application_info_native"]
    pub fn get_application_info_native_static(pid: c_int) -> *const c_char;
    #[link_name = "debugger_new"]
    pub fn debugger_new_static(pid: c_int) -> bool;
    #[link_name = "set_watchpoint_native"]
    pub fn set_watchpoint_native_static(
        address: libc::uintptr_t,
        size: libc::size_t,
        _type: libc::c_int,
    ) -> libc::c_int;
    #[link_name = "remove_watchpoint_native"]
    pub fn remove_watchpoint_native_static(address: libc::uintptr_t) -> libc::c_int;
    #[link_name = "set_breakpoint_native"]
    pub fn set_breakpoint_native_static(address: usize, hit_count: i32, is_software: bool) -> i32;
    #[link_name = "remove_breakpoint_native"]
    pub fn remove_breakpoint_native_static(address: usize) -> i32;
    #[link_name = "get_software_breakpoint_original_bytes_native"]
    pub fn get_software_breakpoint_original_bytes_native_static(
        address: usize,
        out_bytes: *mut u8,
        out_size: *mut usize,
    ) -> bool;
    #[link_name = "get_process_icon_native"]
    pub fn get_process_icon_native_static(pid: i32, size: *mut usize) -> *const u8;
    #[link_name = "enumerate_symbols"]
    pub fn enum_symbols_native_static(
        pid: i32,
        module_base: usize,
        count: *mut usize,
    ) -> *mut SymbolInfo;
    #[link_name = "continue_execution_native"]
    pub fn continue_execution_native_static(thread_id: libc::uintptr_t) -> libc::c_int;
    #[link_name = "single_step_native"]
    pub fn single_step_native_static(thread_id: libc::uintptr_t) -> libc::c_int;
    #[link_name = "read_register_native"]
    pub fn read_register_native_static(
        thread_id: libc::uintptr_t,
        reg_name: *const c_char,
        value: *mut u64,
    ) -> libc::c_int;
    #[link_name = "write_register_native"]
    pub fn write_register_native_static(
        thread_id: libc::uintptr_t,
        reg_name: *const c_char,
        value: u64,
    ) -> libc::c_int;
    #[link_name = "is_in_break_state_native"]
    pub fn is_in_break_state_native_static() -> bool;
    #[link_name = "enable_trace_file_output_native"]
    pub fn enable_trace_file_output_native_static(filepath: *const c_char);
    #[link_name = "disable_trace_file_output_native"]
    pub fn disable_trace_file_output_native_static();
    #[link_name = "is_trace_file_output_enabled_native"]
    pub fn is_trace_file_output_enabled_native_static() -> bool;
    #[link_name = "get_trace_file_path_native"]
    pub fn get_trace_file_path_native_static() -> *const c_char;
    #[link_name = "get_trace_file_entry_count_native"]
    pub fn get_trace_file_entry_count_native_static() -> u32;
    #[link_name = "is_trace_ended_by_end_address_native"]
    pub fn is_trace_ended_by_end_address_native_static() -> bool;
    #[link_name = "reset_trace_ended_flag_native"]
    pub fn reset_trace_ended_flag_native_static();
    #[link_name = "request_script_trace_stop_native"]
    pub fn request_script_trace_stop_native_static(notify_ui: bool);
    #[link_name = "clear_script_trace_stop_request_native"]
    pub fn clear_script_trace_stop_request_native_static();
    #[link_name = "is_script_trace_stop_requested_native"]
    pub fn is_script_trace_stop_requested_native_static() -> bool;
    #[link_name = "enable_full_memory_cache_native"]
    pub fn enable_full_memory_cache_native_static(
        dump_filepath: *const c_char,
        log_filepath: *const c_char,
    );
    #[link_name = "disable_full_memory_cache_native"]
    pub fn disable_full_memory_cache_native_static();
    #[link_name = "is_full_memory_cache_enabled_native"]
    pub fn is_full_memory_cache_enabled_native_static() -> bool;
    #[link_name = "dump_all_memory_regions_native"]
    pub fn dump_all_memory_regions_native_static() -> bool;
    #[link_name = "get_installed_apps_native"]
    pub fn get_installed_apps_native_static() -> *const c_char;
    #[link_name = "get_app_icon_native"]
    pub fn get_app_icon_native_static(
        bundle_identifier: *const c_char,
        size: *mut usize,
    ) -> *const u8;
    #[link_name = "spawn_app_native"]
    pub fn spawn_app_native_static(
        bundle_identifier: *const c_char,
        suspended: c_int,
    ) -> *const c_char;
    #[link_name = "terminate_app_native"]
    pub fn terminate_app_native_static(pid: c_int) -> c_int;
    #[link_name = "resume_app_native"]
    pub fn resume_app_native_static(pid: c_int) -> *const c_char;
    #[link_name = "enumerate_threads"]
    pub fn enumerate_threads_static(pid: i32, count: *mut usize) -> *mut ThreadInfo;
    #[link_name = "free_thread_info"]
    pub fn free_thread_info_static(threads: *mut ThreadInfo, count: usize);
    #[link_name = "get_app_running_status_native"]
    pub fn get_app_running_status_native_static(bundle_identifier: *const c_char) -> *const c_char;
    #[link_name = "spawn_process_native"]
    pub fn spawn_process_native_static(
        executable_path: *const c_char,
        args: *const *const c_char,
        arg_count: c_int,
        out_pid: *mut i32,
    ) -> c_int;
    #[link_name = "spawn_process_with_pty"]
    pub fn spawn_process_with_pty_static(
        executable_path: *const c_char,
        args: *const *const c_char,
        arg_count: c_int,
        out_pid: *mut i32,
        out_pty_fd: *mut c_int,
    ) -> c_int;
    #[link_name = "read_pty"]
    pub fn read_pty_static(pty_fd: c_int, buffer: *mut c_char, buffer_size: usize) -> isize;
    #[link_name = "write_pty"]
    pub fn write_pty_static(pty_fd: c_int, data: *const c_char, data_len: usize) -> isize;
    #[link_name = "close_pty"]
    pub fn close_pty_static(pty_fd: c_int);
    #[link_name = "set_pty_size"]
    pub fn set_pty_size_static(pty_fd: c_int, rows: c_int, cols: c_int) -> c_int;
    // Signal configuration (catch/pass behavior)
    #[link_name = "set_signal_config_native"]
    pub fn set_signal_config_native_static(signal: c_int, catch_signal: bool, pass_signal: bool);
    #[link_name = "get_signal_config_native"]
    pub fn get_signal_config_native_static(
        signal: c_int,
        catch_signal: *mut bool,
        pass_signal: *mut bool,
    );
    #[link_name = "get_all_signal_configs_native"]
    pub fn get_all_signal_configs_native_static(
        signals: *mut c_int,
        catch_signals: *mut bool,
        pass_signals: *mut bool,
        max_count: usize,
    ) -> usize;
    #[link_name = "remove_signal_config_native"]
    pub fn remove_signal_config_native_static(signal: c_int);
}

// Dynamic library loader
static DYNAMIC_LIB: OnceLock<Option<Library>> = OnceLock::new();

// Type definitions for callback setters
type NativeLogFn = extern "C" fn(i32, *const c_char);
// On Linux, send_exception_info returns bool (true = break, false = continue)
// We pass send_exception_info (bool return) but C++ stores it as function pointer
type SendExceptionInfoFn = extern "C" fn(*const crate::api::NativeExceptionInfo, i32) -> bool;
type SetNativeLogCallbackFn = unsafe extern "C" fn(NativeLogFn);
type SetSendExceptionInfoCallbackFn = unsafe extern "C" fn(SendExceptionInfoFn);

/// Initialize dynamic library loading
/// Returns true if dynamic library was loaded successfully
pub fn init_dynamic_library() -> bool {
    DYNAMIC_LIB
        .get_or_init(|| {
            #[cfg(target_os = "macos")]
            let lib_name = "libdbgsrv_native.dylib";

            #[cfg(target_os = "ios")]
            let lib_name = "libdbgsrv_native.dylib";

            #[cfg(target_os = "linux")]
            let lib_name = "libdbgsrv_native.so";

            #[cfg(target_os = "android")]
            let lib_name = "libdbgsrv_native.so";

            #[cfg(target_os = "windows")]
            let lib_name = "libdbgsrv_native.dll";

            // Try loading from executable's directory first
            if let Ok(exe_path) = std::env::current_exe() {
                if let Some(exe_dir) = exe_path.parent() {
                    let lib_path = exe_dir.join(lib_name);
                    log::info!("Trying to load dynamic library from: {:?}", lib_path);
                    if let Ok(lib) = unsafe { Library::new(&lib_path) } {
                        log::info!("Successfully loaded dynamic library from executable directory");
                        // Set callback functions
                        setup_dll_callbacks(&lib);
                        return Some(lib);
                    } else {
                        log::warn!("Failed to load from {:?}", lib_path);
                    }
                }
            }

            // Fall back to system library search path
            log::info!(
                "Trying to load dynamic library from system path: {}",
                lib_name
            );
            match unsafe { Library::new(lib_name) } {
                Ok(lib) => {
                    log::info!("Successfully loaded dynamic library from system path");
                    // Set callback functions
                    setup_dll_callbacks(&lib);
                    Some(lib)
                }
                Err(e) => {
                    log::warn!("Failed to load dynamic library: {}", e);
                    None
                }
            }
        })
        .is_some()
}

/// Set up callbacks from DLL to Rust
fn setup_dll_callbacks(lib: &Library) {
    // Set native_log callback
    match unsafe { lib.get::<SetNativeLogCallbackFn>(b"set_native_log_callback") } {
        Ok(set_log_cb) => {
            log::info!("Setting native_log callback");
            unsafe {
                set_log_cb(crate::api::native_log);
            }
        }
        Err(e) => {
            log::warn!("set_native_log_callback not found: {}", e);
        }
    }

    // Set send_exception_info callback
    match unsafe { lib.get::<SetSendExceptionInfoCallbackFn>(b"set_send_exception_info_callback") }
    {
        Ok(set_exc_cb) => {
            log::info!("Setting send_exception_info callback");
            unsafe {
                set_exc_cb(crate::api::send_exception_info);
            }
        }
        Err(e) => {
            log::warn!("set_send_exception_info_callback not found: {}", e);
        }
    }
}

/// Check if dynamic library is available
pub fn has_dynamic_library() -> bool {
    DYNAMIC_LIB.get().and_then(|opt| opt.as_ref()).is_some()
}

// Macro to create wrapper functions that try dynamic library first, then fall back to static
macro_rules! wrap_native_fn {
    ($fn_name:ident() -> $ret:ty) => {
        pub unsafe fn $fn_name() -> $ret {
            if let Some(Some(lib)) = DYNAMIC_LIB.get() {
                if let Ok(func) = lib.get::<Symbol<unsafe extern "C" fn() -> $ret>>(stringify!($fn_name).as_bytes()) {
                    return func();
                }
            }
            paste::paste! {
                [<$fn_name _static>]()
            }
        }
    };

    ($fn_name:ident($($arg:ident: $typ:ty),*) -> $ret:ty) => {
        pub unsafe fn $fn_name($($arg: $typ),*) -> $ret {
            if let Some(Some(lib)) = DYNAMIC_LIB.get() {
                if let Ok(func) = lib.get::<Symbol<unsafe extern "C" fn($($typ),*) -> $ret>>(stringify!($fn_name).as_bytes()) {
                    return func($($arg),*);
                }
            }
            paste::paste! {
                [<$fn_name _static>]($($arg),*)
            }
        }
    };
}

// Wrapper functions for all native calls
wrap_native_fn!(get_pid_native() -> i32);
wrap_native_fn!(enumerate_processes(count: *mut usize) -> *mut ProcessInfo);
wrap_native_fn!(enumerate_modules(pid: i32, count: *mut usize) -> *mut ModuleInfo);
wrap_native_fn!(enumerate_regions_to_buffer(pid: i32, buffer: *mut u8, buffer_size: usize, include_filenames: bool) -> ());
wrap_native_fn!(enumerate_regions(pid: i32, count: *mut usize, include_filenames: bool) -> *mut RegionInfo);
wrap_native_fn!(free_region_info(regions: *mut RegionInfo, count: usize) -> ());
wrap_native_fn!(read_memory_native(pid: libc::c_int, address: libc::uintptr_t, size: libc::size_t, buffer: *mut u8) -> libc::ssize_t);
wrap_native_fn!(read_memory_native_with_method(pid: libc::c_int, address: libc::uintptr_t, size: libc::size_t, buffer: *mut u8, mode: libc::c_int) -> libc::ssize_t);
wrap_native_fn!(write_memory_native(pid: i32, address: libc::uintptr_t, size: libc::size_t, buffer: *const u8) -> libc::ssize_t);
wrap_native_fn!(suspend_process(pid: i32) -> bool);
wrap_native_fn!(resume_process(pid: i32) -> bool);
wrap_native_fn!(native_init(mode: i32) -> libc::c_int);
wrap_native_fn!(explore_directory(path: *const c_char, max_depth: i32) -> *mut libc::c_char);
wrap_native_fn!(read_file(path: *const c_char, size: *mut usize, error_message: *mut *mut c_char) -> *const c_void);
wrap_native_fn!(get_application_info_native(pid: c_int) -> *const c_char);
wrap_native_fn!(debugger_new(pid: c_int) -> bool);
wrap_native_fn!(set_watchpoint_native(address: libc::uintptr_t, size: libc::size_t, _type: libc::c_int) -> libc::c_int);
wrap_native_fn!(remove_watchpoint_native(address: libc::uintptr_t) -> libc::c_int);
wrap_native_fn!(set_breakpoint_native(address: usize, hit_count: i32, is_software: bool) -> i32);
wrap_native_fn!(remove_breakpoint_native(address: usize) -> i32);
wrap_native_fn!(get_software_breakpoint_original_bytes_native(address: usize, out_bytes: *mut u8, out_size: *mut usize) -> bool);
wrap_native_fn!(get_process_icon_native(pid: i32, size: *mut usize) -> *const u8);
wrap_native_fn!(enum_symbols_native(pid: i32, module_base: usize, count: *mut usize) -> *mut SymbolInfo);
wrap_native_fn!(continue_execution_native(thread_id: libc::uintptr_t) -> libc::c_int);
wrap_native_fn!(single_step_native(thread_id: libc::uintptr_t) -> libc::c_int);
wrap_native_fn!(read_register_native(thread_id: libc::uintptr_t, reg_name: *const c_char, value: *mut u64) -> libc::c_int);
wrap_native_fn!(write_register_native(thread_id: libc::uintptr_t, reg_name: *const c_char, value: u64) -> libc::c_int);
wrap_native_fn!(is_in_break_state_native() -> bool);
wrap_native_fn!(enable_trace_file_output_native(filepath: *const c_char) -> ());
wrap_native_fn!(disable_trace_file_output_native() -> ());
wrap_native_fn!(is_trace_file_output_enabled_native() -> bool);
wrap_native_fn!(get_trace_file_path_native() -> *const c_char);
wrap_native_fn!(get_trace_file_entry_count_native() -> u32);
wrap_native_fn!(is_trace_ended_by_end_address_native() -> bool);
wrap_native_fn!(reset_trace_ended_flag_native() -> ());
wrap_native_fn!(request_script_trace_stop_native(notify_ui: bool) -> ());
wrap_native_fn!(clear_script_trace_stop_request_native() -> ());
wrap_native_fn!(is_script_trace_stop_requested_native() -> bool);
wrap_native_fn!(enable_full_memory_cache_native(dump_filepath: *const c_char, log_filepath: *const c_char) -> ());
wrap_native_fn!(disable_full_memory_cache_native() -> ());
wrap_native_fn!(is_full_memory_cache_enabled_native() -> bool);
wrap_native_fn!(dump_all_memory_regions_native() -> bool);
wrap_native_fn!(get_installed_apps_native() -> *const c_char);
wrap_native_fn!(get_app_icon_native(bundle_identifier: *const c_char, size: *mut usize) -> *const u8);
wrap_native_fn!(spawn_app_native(bundle_identifier: *const c_char, suspended: c_int) -> *const c_char);
wrap_native_fn!(terminate_app_native(pid: c_int) -> c_int);
wrap_native_fn!(resume_app_native(pid: c_int) -> *const c_char);
wrap_native_fn!(enumerate_threads(pid: i32, count: *mut usize) -> *mut ThreadInfo);
wrap_native_fn!(free_thread_info(threads: *mut ThreadInfo, count: usize) -> ());
wrap_native_fn!(get_app_running_status_native(bundle_identifier: *const c_char) -> *const c_char);
wrap_native_fn!(spawn_process_native(executable_path: *const c_char, args: *const *const c_char, arg_count: c_int, out_pid: *mut i32) -> c_int);
wrap_native_fn!(spawn_process_with_pty(executable_path: *const c_char, args: *const *const c_char, arg_count: c_int, out_pid: *mut i32, out_pty_fd: *mut c_int) -> c_int);
wrap_native_fn!(read_pty(pty_fd: c_int, buffer: *mut c_char, buffer_size: usize) -> isize);
wrap_native_fn!(write_pty(pty_fd: c_int, data: *const c_char, data_len: usize) -> isize);
wrap_native_fn!(close_pty(pty_fd: c_int) -> ());
wrap_native_fn!(set_pty_size(pty_fd: c_int, rows: c_int, cols: c_int) -> c_int);
// Signal configuration (catch/pass behavior)
wrap_native_fn!(set_signal_config_native(signal: c_int, catch_signal: bool, pass_signal: bool) -> ());
wrap_native_fn!(get_signal_config_native(signal: c_int, catch_signal: *mut bool, pass_signal: *mut bool) -> ());
wrap_native_fn!(get_all_signal_configs_native(signals: *mut c_int, catch_signals: *mut bool, pass_signals: *mut bool, max_count: usize) -> usize);
wrap_native_fn!(remove_signal_config_native(signal: c_int) -> ());

#[repr(C)]
pub struct ProcessInfo {
    pub pid: i32,
    pub processname: *mut c_char,
}

#[repr(C)]
pub struct ModuleInfo {
    pub base: usize,
    pub size: usize,
    pub is_64bit: bool,
    pub modulename: *mut c_char,
}

#[repr(C)]
pub struct SymbolInfo {
    pub address: usize,
    pub name: *mut c_char,
    pub size: usize,
    pub symbol_type: *mut c_char,
    pub scope: *mut c_char,
    pub module_base: usize,
    pub file_name: *mut c_char,
    pub line_number: i32,
}

#[repr(C)]
pub struct ThreadInfo {
    pub thread_id: u64,
    pub name: *mut c_char,
    pub pc: u64,
    pub sp: u64,
    pub fp: u64,
    pub state: i32,
    pub suspend_count: i32,
}

/// Memory region information structure
/// Used for structured region enumeration
#[repr(C)]
pub struct RegionInfo {
    pub start: usize,
    pub end: usize,
    pub protection: u32, // PROT_READ=1, PROT_WRITE=2, PROT_EXEC=4
    pub pathname: *mut c_char,
}

pub fn read_process_memory(
    pid: i32,
    address: *mut libc::c_void,
    size: usize,
    buffer: &mut [u8],
) -> Result<isize, Error> {
    // Check if WASM mode is enabled
    if wasm_bridge::is_wasm_mode() {
        // If base address is found, use native memory with offset
        if wasm_bridge::is_wasm_base_found() {
            let native_addr = wasm_bridge::wasm_to_native_address(address as usize);
            let result = unsafe { 
                read_memory_native(pid, native_addr as libc::uintptr_t, size, buffer.as_mut_ptr()) 
            };
            if result >= 0 {
                return Ok(result as isize);
            } else {
                return Err(Error::last_os_error());
            }
        }
        // Fallback to WebSocket if base not found
        match wasm_bridge::read_wasm_memory_sync(address as usize, size) {
            Ok(data) => {
                let copy_len = std::cmp::min(data.len(), buffer.len());
                buffer[..copy_len].copy_from_slice(&data[..copy_len]);
                Ok(copy_len as isize)
            }
            Err(e) => {
                log::error!("WASM read_memory failed: {}", e);
                Err(Error::new(std::io::ErrorKind::Other, e))
            }
        }
    } else {
        let result =
            unsafe { read_memory_native(pid, address as libc::uintptr_t, size, buffer.as_mut_ptr()) };
        if result >= 0 {
            Ok(result as isize)
        } else {
            Err(Error::last_os_error())
        }
    }
}

/// Read process memory with explicit tokio handle (for use from rayon/thread pools)
pub fn read_process_memory_with_handle(
    pid: i32,
    address: *mut libc::c_void,
    size: usize,
    buffer: &mut [u8],
    tokio_handle: Option<&tokio::runtime::Handle>,
) -> Result<isize, Error> {
    // Check if WASM mode is enabled
    if wasm_bridge::is_wasm_mode() {
        // If base address is found, use native memory with offset
        if wasm_bridge::is_wasm_base_found() {
            let native_addr = wasm_bridge::wasm_to_native_address(address as usize);
            let result = unsafe { 
                read_memory_native(pid, native_addr as libc::uintptr_t, size, buffer.as_mut_ptr()) 
            };
            if result >= 0 {
                return Ok(result as isize);
            } else {
                return Err(Error::last_os_error());
            }
        }
        // Fallback to WebSocket if base not found - use provided handle
        let result = if let Some(handle) = tokio_handle {
            wasm_bridge::read_wasm_memory_sync_with_handle(address as usize, size, handle)
        } else {
            wasm_bridge::read_wasm_memory_sync(address as usize, size)
        };
        match result {
            Ok(data) => {
                let copy_len = std::cmp::min(data.len(), buffer.len());
                buffer[..copy_len].copy_from_slice(&data[..copy_len]);
                Ok(copy_len as isize)
            }
            Err(e) => {
                log::error!("WASM read_memory failed: {}", e);
                Err(Error::new(std::io::ErrorKind::Other, e))
            }
        }
    } else {
        let result =
            unsafe { read_memory_native(pid, address as libc::uintptr_t, size, buffer.as_mut_ptr()) };
        if result >= 0 {
            Ok(result as isize)
        } else {
            Err(Error::last_os_error())
        }
    }
}

pub fn read_process_memory_with_method(
    pid: i32,
    address: *mut libc::c_void,
    size: usize,
    buffer: &mut [u8],
    mode: i32,
) -> Result<isize, Error> {
    // Check if WASM mode is enabled
    if wasm_bridge::is_wasm_mode() {
        // If base address is found, use native memory with offset
        if wasm_bridge::is_wasm_base_found() {
            let native_addr = wasm_bridge::wasm_to_native_address(address as usize);
            let result = unsafe { 
                read_memory_native_with_method(
                    pid, 
                    native_addr as libc::uintptr_t, 
                    size, 
                    buffer.as_mut_ptr(),
                    mode
                ) 
            };
            if result >= 0 {
                return Ok(result as isize);
            } else {
                return Err(Error::last_os_error());
            }
        }
        // Fallback to WebSocket if base not found
        match wasm_bridge::read_wasm_memory_sync(address as usize, size) {
            Ok(data) => {
                let copy_len = std::cmp::min(data.len(), buffer.len());
                buffer[..copy_len].copy_from_slice(&data[..copy_len]);
                Ok(copy_len as isize)
            }
            Err(e) => {
                log::error!("WASM read_memory failed: {}", e);
                Err(Error::new(std::io::ErrorKind::Other, e))
            }
        }
    } else {
        let result = unsafe {
            read_memory_native_with_method(
                pid,
                address as libc::uintptr_t,
                size,
                buffer.as_mut_ptr(),
                mode,
            )
        };
        if result >= 0 {
            Ok(result as isize)
        } else {
            Err(Error::last_os_error())
        }
    }
}

pub fn write_process_memory(
    pid: i32,
    address: *mut libc::c_void,
    size: usize,
    buffer: &[u8],
) -> Result<isize, Error> {
    // Check if WASM mode is enabled
    if wasm_bridge::is_wasm_mode() {
        // If base address is found, use native memory with offset
        if wasm_bridge::is_wasm_base_found() {
            let native_addr = wasm_bridge::wasm_to_native_address(address as usize);
            let result = unsafe { 
                write_memory_native(pid, native_addr as libc::uintptr_t, size, buffer.as_ptr()) 
            };
            if result >= 0 {
                return Ok(result as isize);
            } else {
                return Err(Error::last_os_error());
            }
        }
        // Fallback to WebSocket if base not found
        match wasm_bridge::write_wasm_memory_sync(address as usize, buffer) {
            Ok(success) => {
                if success {
                    Ok(size as isize)
                } else {
                    Err(Error::new(std::io::ErrorKind::Other, "WASM write failed"))
                }
            }
            Err(e) => {
                log::error!("WASM write_memory failed: {}", e);
                Err(Error::new(std::io::ErrorKind::Other, e))
            }
        }
    } else {
        let result =
            unsafe { write_memory_native(pid, address as libc::uintptr_t, size, buffer.as_ptr()) };
        if result >= 0 {
            Ok(result as isize)
        } else {
            Err(Error::last_os_error())
        }
    }
}

pub fn set_watchpoint(pid: i32, address: usize, size: usize, type_: i32) -> Result<i32, Error> {
    let result: bool = unsafe { debugger_new(pid) };

    if !result {
        return Err(Error::new(
            std::io::ErrorKind::Other,
            "Failed to create debugger instance",
        ));
    }
    let result = unsafe { set_watchpoint_native(address, size, type_) };
    if result == 0 {
        Ok(result as i32)
    } else {
        Err(Error::last_os_error())
    }
}

pub fn remove_watchpoint(address: usize) -> Result<i32, Error> {
    let result = unsafe { remove_watchpoint_native(address) };
    if result == 0 {
        Ok(result as i32)
    } else {
        Err(Error::last_os_error())
    }
}

pub fn set_breakpoint(
    pid: i32,
    address: usize,
    hit_count: i32,
    is_software: bool,
) -> Result<i32, Error> {
    let result: bool = unsafe { debugger_new(pid) };
    if !result {
        return Err(Error::new(
            std::io::ErrorKind::Other,
            "Failed to create debugger instance",
        ));
    }
    let result = unsafe { set_breakpoint_native(address, hit_count, is_software) };
    if result == 0 {
        Ok(result)
    } else {
        Err(Error::last_os_error())
    }
}

pub fn remove_breakpoint(address: usize) -> Result<i32, Error> {
    let result = unsafe { remove_breakpoint_native(address) };
    if result == 0 {
        Ok(result)
    } else {
        Err(Error::last_os_error())
    }
}

pub fn get_software_breakpoint_original_bytes(address: usize) -> Option<Vec<u8>> {
    let mut bytes = [0u8; 4];
    let mut size: usize = 0;
    let result = unsafe {
        get_software_breakpoint_original_bytes_native(address, bytes.as_mut_ptr(), &mut size)
    };
    if result && size > 0 {
        Some(bytes[..size].to_vec())
    } else {
        None
    }
}

pub fn native_api_init(mode: i32) {
    unsafe { native_init(mode) };
}

pub fn enum_modules(pid: i32) -> Result<Vec<serde_json::Value>, String> {
    let mut count: usize = 0;
    let module_info_ptr = unsafe { enumerate_modules(pid, &mut count) };

    if module_info_ptr.is_null() {
        return Err("Failed to enumerate modules".to_string());
    }

    let module_info_slice = unsafe { std::slice::from_raw_parts(module_info_ptr, count) };

    let mut modules = Vec::new();

    for info in module_info_slice {
        let module_name = unsafe {
            CStr::from_ptr(info.modulename)
                .to_string_lossy()
                .into_owned()
        };

        modules.push(json!({
            "base": info.base,
            "size": info.size,
            "is_64bit": info.is_64bit,
            "modulename": module_name
        }));

        unsafe { libc::free(info.modulename as *mut libc::c_void) };
    }

    unsafe { libc::free(module_info_ptr as *mut libc::c_void) };

    Ok(modules)
}

/// Get module path for a given base address by looking up the module list
fn get_module_path_for_base(pid: i32, module_base: usize) -> Option<String> {
    let mut count: usize = 0;
    let module_info_ptr = unsafe { enumerate_modules(pid, &mut count) };

    if module_info_ptr.is_null() || count == 0 {
        return None;
    }

    let module_info_slice = unsafe { std::slice::from_raw_parts(module_info_ptr, count) };
    let mut result = None;

    for info in module_info_slice {
        if info.base == module_base {
            let module_name = unsafe {
                CStr::from_ptr(info.modulename)
                    .to_string_lossy()
                    .into_owned()
            };
            result = Some(module_name);
        }
        // Free the module name regardless
        unsafe { libc::free(info.modulename as *mut libc::c_void) };
    }

    unsafe { libc::free(module_info_ptr as *mut libc::c_void) };

    result
}

/// Enumerate symbols using MachOKit (macOS/iOS only)
#[cfg(any(target_os = "macos", target_os = "ios"))]
fn enum_symbols_machokit(pid: i32, module_base: usize) -> Result<Vec<serde_json::Value>, String> {
    // Get the module path for this base address
    let module_path = get_module_path_for_base(pid, module_base)
        .ok_or_else(|| "Could not find module path for base address".to_string())?;

    log::debug!("MachOKit: Trying to parse module at path: {}", module_path);

    // Check if we can parse this module with MachOKit
    if !macho_bridge::can_parse_module(&module_path) {
        return Err(format!(
            "Cannot parse module with MachOKit: {}",
            module_path
        ));
    }

    log::debug!(
        "MachOKit: can_parse_module returned true for {}",
        module_path
    );

    // Get symbols from MachOKit
    let rebased_symbols = match macho_bridge::get_module_symbols(&module_path, module_base) {
        Ok(syms) => {
            log::debug!(
                "MachOKit: Successfully got {} symbols for {}",
                syms.len(),
                module_path
            );
            syms
        }
        Err(e) => {
            log::debug!(
                "MachOKit: get_module_symbols failed for {}: {}",
                module_path,
                e
            );
            return Err(e);
        }
    };

    // Convert to JSON format
    let symbols: Vec<serde_json::Value> = rebased_symbols
        .into_iter()
        .map(|sym| {
            json!({
                "address": format!("0x{:X}", sym.address),
                "name": sym.name,
                "size": sym.size,
                "type": sym.symbol_type,
                "scope": sym.scope,
                "module_base": format!("0x{:X}", sym.module_base),
                "file_name": "",
                "line_number": 0,
                // Mach-O specific metadata
                "is_external": sym.is_external,
                "is_weak_def": sym.is_weak_def,
                "is_thumb": sym.is_thumb,
                "source": sym.source
            })
        })
        .collect();

    if symbols.is_empty() {
        Err("No symbols found via MachOKit".to_string())
    } else {
        Ok(symbols)
    }
}

/// Enumerate symbols using native C++ implementation (fallback)
fn enum_symbols_native_impl(
    pid: i32,
    module_base: usize,
) -> Result<Vec<serde_json::Value>, String> {
    let mut count: usize = 0;
    let symbol_info_ptr = unsafe { enum_symbols_native(pid, module_base, &mut count) };

    if symbol_info_ptr.is_null() {
        return Err("Failed to enumerate symbols".to_string());
    }

    let symbol_info_slice = unsafe { std::slice::from_raw_parts(symbol_info_ptr, count) };

    let mut symbols = Vec::new();

    for info in symbol_info_slice {
        let symbol_name = unsafe { CStr::from_ptr(info.name).to_string_lossy().into_owned() };

        let symbol_type = unsafe {
            CStr::from_ptr(info.symbol_type)
                .to_string_lossy()
                .into_owned()
        };

        let scope = unsafe { CStr::from_ptr(info.scope).to_string_lossy().into_owned() };

        let file_name = unsafe {
            if info.file_name.is_null() || *info.file_name == 0 {
                String::new()
            } else {
                CStr::from_ptr(info.file_name)
                    .to_string_lossy()
                    .into_owned()
            }
        };

        symbols.push(json!({
            "address": format!("0x{:X}", info.address),
            "name": symbol_name,
            "size": info.size,
            "type": symbol_type,
            "scope": scope,
            "module_base": format!("0x{:X}", info.module_base),
            "file_name": file_name,
            "line_number": info.line_number
        }));

        // Free allocated memory
        unsafe {
            libc::free(info.name as *mut libc::c_void);
            libc::free(info.symbol_type as *mut libc::c_void);
            libc::free(info.scope as *mut libc::c_void);
            if !info.file_name.is_null() {
                libc::free(info.file_name as *mut libc::c_void);
            }
        };
    }

    unsafe { libc::free(symbol_info_ptr as *mut libc::c_void) };

    Ok(symbols)
}

/// Main entry point for symbol enumeration
/// Tries MachOKit first on macOS/iOS, falls back to native implementation
pub fn enum_symbols(pid: i32, module_base: usize) -> Result<Vec<serde_json::Value>, String> {
    #[cfg(any(target_os = "macos", target_os = "ios"))]
    {
        // Try MachOKit first for better symbol coverage (especially for dyld cache)
        match enum_symbols_machokit(pid, module_base) {
            Ok(symbols) => {
                log::debug!(
                    "Successfully enumerated {} symbols via MachOKit for module at 0x{:X}",
                    symbols.len(),
                    module_base
                );
                return Ok(symbols);
            }
            Err(e) => {
                log::debug!(
                    "MachOKit symbol enumeration failed, falling back to native: {}",
                    e
                );
                // Fall through to native implementation
            }
        }
    }

    // Fallback to native C++ implementation
    enum_symbols_native_impl(pid, module_base)
}

pub fn enum_threads(pid: i32) -> Result<Vec<serde_json::Value>, String> {
    let mut count: usize = 0;
    let thread_info_ptr = unsafe { enumerate_threads(pid, &mut count) };

    if thread_info_ptr.is_null() {
        return Err("Failed to enumerate threads".to_string());
    }

    let thread_info_slice = unsafe { std::slice::from_raw_parts(thread_info_ptr, count) };

    let mut threads = Vec::new();

    for info in thread_info_slice {
        let thread_name = unsafe {
            if info.name.is_null() {
                String::from("Unknown")
            } else {
                CStr::from_ptr(info.name).to_string_lossy().into_owned()
            }
        };

        let state_str = match info.state {
            1 => "Running",
            2 => "Stopped",
            3 => "Waiting",
            4 => "Uninterruptible",
            5 => "Halted",
            _ => "Unknown",
        };

        threads.push(json!({
            "thread_id": info.thread_id,
            "name": thread_name,
            "pc": format!("0x{:X}", info.pc),
            "sp": format!("0x{:X}", info.sp),
            "fp": format!("0x{:X}", info.fp),
            "state": state_str,
            "suspend_count": info.suspend_count
        }));
    }

    // Free allocated memory using the native free function
    unsafe { free_thread_info(thread_info_ptr, count) };

    Ok(threads)
}

pub fn enum_regions(pid: i32) -> Result<Vec<serde_json::Value>, String> {
    enum_regions_with_filenames(pid, true)
}

pub fn enum_regions_fast(pid: i32) -> Result<Vec<serde_json::Value>, String> {
    enum_regions_with_filenames(pid, false)
}

pub fn enum_regions_with_filenames(
    pid: i32,
    include_filenames: bool,
) -> Result<Vec<serde_json::Value>, String> {
    let mut buffer = vec![0u8; 4 * 1024 * 1024]; // 4MB buffer for large /proc/pid/maps on Android

    unsafe {
        enumerate_regions_to_buffer(pid, buffer.as_mut_ptr(), buffer.len(), include_filenames)
    };

    let buffer_cstring = unsafe { CString::from_vec_unchecked(buffer) };
    let buffer_string = match buffer_cstring.into_string() {
        Ok(s) => s,
        Err(_) => return Err("Failed to convert buffer to string".to_string()),
    };

    let buffer_reader = BufReader::new(buffer_string.as_bytes());
    let mut regions = Vec::new();

    for line in buffer_reader.lines() {
        if let Ok(line) = line {
            let parts: Vec<&str> = line.split_whitespace().collect();

            if parts.len() >= 5 {
                let addresses: Vec<&str> = parts[0].split('-').collect();
                if addresses.len() == 2 {
                    let region = json!({
                        "start_address": addresses[0],
                        "end_address": addresses[1],
                        "protection": parts[1],
                        "file_path": if parts.len() > 5 {
                            parts[5..].join(" ")
                        } else {
                            "".to_string()
                        }
                    });
                    regions.push(region);
                }
            }
        }
    }

    if regions.is_empty() {
        Err("No regions found".to_string())
    } else {
        Ok(regions)
    }
}

pub fn get_application_info(pid: i32) -> Result<String, Error> {
    let result = unsafe {
        let raw_ptr = get_application_info_native(pid as c_int);
        if raw_ptr.is_null() {
            return Err(Error::new(
                std::io::ErrorKind::Other,
                "Failed to get application info",
            ));
        }

        let c_str = CStr::from_ptr(raw_ptr);
        let result_str = c_str.to_str().unwrap_or("Invalid UTF-8").to_owned();
        libc::free(raw_ptr as *mut libc::c_void);

        result_str
    };

    Ok(result)
}

pub fn get_process_icon(pid: i32) -> Result<Vec<u8>, Error> {
    let mut size: usize = 0;

    let result = unsafe {
        let raw_ptr = get_process_icon_native(pid, &mut size as *mut usize);
        if raw_ptr.is_null() || size == 0 {
            return Err(Error::new(
                std::io::ErrorKind::Other,
                "Failed to get process icon",
            ));
        }

        let icon_data = std::slice::from_raw_parts(raw_ptr, size).to_vec();
        libc::free(raw_ptr as *mut libc::c_void);

        icon_data
    };

    Ok(result)
}

// New break state control functions
pub fn continue_execution(thread_id: libc::uintptr_t) -> Result<(), Error> {
    let result = unsafe { continue_execution_native(thread_id) };
    if result == 0 {
        Ok(())
    } else {
        // Convert Mach kernel return to appropriate error
        Err(Error::new(
            std::io::ErrorKind::Other,
            format!("Continue execution failed with kernel return: {}", result),
        ))
    }
}

pub fn single_step(thread_id: libc::uintptr_t) -> Result<(), Error> {
    let result = unsafe { single_step_native(thread_id) };
    if result == 0 {
        Ok(())
    } else {
        // Convert Mach kernel return to appropriate error
        Err(Error::new(
            std::io::ErrorKind::Other,
            format!("Single step failed with kernel return: {}", result),
        ))
    }
}

pub fn read_register(thread_id: libc::uintptr_t, reg_name: &str) -> Result<u64, Error> {
    let c_reg_name = CString::new(reg_name).unwrap();
    let mut value: u64 = 0;
    let result = unsafe { read_register_native(thread_id, c_reg_name.as_ptr(), &mut value) };
    if result == 0 {
        Ok(value)
    } else {
        Err(Error::last_os_error())
    }
}

pub fn write_register(thread_id: libc::uintptr_t, reg_name: &str, value: u64) -> Result<(), Error> {
    let c_reg_name = CString::new(reg_name).unwrap();
    let result = unsafe { write_register_native(thread_id, c_reg_name.as_ptr(), value) };
    if result == 0 {
        Ok(())
    } else {
        Err(Error::last_os_error())
    }
}

pub fn is_in_break_state() -> bool {
    unsafe { is_in_break_state_native() }
}

// Signal configuration functions (catch/pass behavior)
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct SignalConfig {
    pub catch_signal: bool,
    pub pass_signal: bool,
}

impl Default for SignalConfig {
    fn default() -> Self {
        // Default: catch=false (don't stop), pass=false (suppress signal, like GDB)
        SignalConfig {
            catch_signal: false,
            pass_signal: false,
        }
    }
}

pub fn set_signal_config(signal: i32, config: SignalConfig) {
    unsafe { set_signal_config_native(signal, config.catch_signal, config.pass_signal) }
}

pub fn get_signal_config(signal: i32) -> SignalConfig {
    let mut catch_signal = false;
    let mut pass_signal = false; // Default: don't pass (like GDB)
    unsafe { get_signal_config_native(signal, &mut catch_signal, &mut pass_signal) }
    SignalConfig {
        catch_signal,
        pass_signal,
    }
}

pub fn get_all_signal_configs() -> Vec<(i32, SignalConfig)> {
    let mut signals = vec![0i32; 32];
    let mut catch_signals = vec![false; 32];
    let mut pass_signals = vec![false; 32];
    let count = unsafe {
        get_all_signal_configs_native(
            signals.as_mut_ptr(),
            catch_signals.as_mut_ptr(),
            pass_signals.as_mut_ptr(),
            32,
        )
    };
    (0..count)
        .map(|i| {
            (
                signals[i],
                SignalConfig {
                    catch_signal: catch_signals[i],
                    pass_signal: pass_signals[i],
                },
            )
        })
        .collect()
}

pub fn remove_signal_config(signal: i32) {
    unsafe { remove_signal_config_native(signal) }
}

// Trace file output functions
pub fn enable_trace_file_output(filepath: &str) {
    if let Ok(c_filepath) = CString::new(filepath) {
        unsafe { enable_trace_file_output_native(c_filepath.as_ptr()) }
    }
}

pub fn disable_trace_file_output() {
    unsafe { disable_trace_file_output_native() }
}

pub fn is_trace_file_output_enabled() -> bool {
    unsafe { is_trace_file_output_enabled_native() }
}

pub fn get_trace_file_path() -> String {
    unsafe {
        let raw_ptr = get_trace_file_path_native();
        if raw_ptr.is_null() {
            return String::new();
        }
        let c_str = CStr::from_ptr(raw_ptr);
        c_str.to_str().unwrap_or("").to_owned()
    }
}

pub fn get_trace_file_entry_count() -> u32 {
    unsafe { get_trace_file_entry_count_native() }
}

pub fn is_trace_ended_by_end_address() -> bool {
    unsafe { is_trace_ended_by_end_address_native() }
}

pub fn reset_trace_ended_flag() {
    unsafe { reset_trace_ended_flag_native() }
}

// Script trace control functions
pub fn request_script_trace_stop(notify_ui: bool) {
    unsafe { request_script_trace_stop_native(notify_ui) }
}

pub fn clear_script_trace_stop_request() {
    unsafe { clear_script_trace_stop_request_native() }
}

pub fn is_script_trace_stop_requested() -> bool {
    unsafe { is_script_trace_stop_requested_native() }
}

// Full memory cache functions
pub fn enable_full_memory_cache(dump_filepath: &str, log_filepath: &str) {
    if let (Ok(c_dump_path), Ok(c_log_path)) =
        (CString::new(dump_filepath), CString::new(log_filepath))
    {
        unsafe { enable_full_memory_cache_native(c_dump_path.as_ptr(), c_log_path.as_ptr()) }
    }
}

pub fn disable_full_memory_cache() {
    unsafe { disable_full_memory_cache_native() }
}

pub fn is_full_memory_cache_enabled() -> bool {
    unsafe { is_full_memory_cache_enabled_native() }
}

pub fn dump_all_memory_regions() -> bool {
    unsafe { dump_all_memory_regions_native() }
}

pub fn get_installed_apps() -> Result<String, Error> {
    let result = unsafe {
        let raw_ptr = get_installed_apps_native();
        if raw_ptr.is_null() {
            return Err(Error::new(
                std::io::ErrorKind::Other,
                "Failed to get installed apps",
            ));
        }

        let c_str = CStr::from_ptr(raw_ptr);
        let result_str = c_str.to_str().unwrap_or("[]").to_owned();
        libc::free(raw_ptr as *mut libc::c_void);

        result_str
    };

    Ok(result)
}

pub fn get_app_icon(bundle_identifier: &str) -> Result<Vec<u8>, Error> {
    let c_bundle_id = CString::new(bundle_identifier).map_err(|_| {
        Error::new(
            std::io::ErrorKind::InvalidInput,
            "Invalid bundle identifier",
        )
    })?;
    let mut size: usize = 0;

    let result = unsafe {
        let raw_ptr = get_app_icon_native(c_bundle_id.as_ptr(), &mut size as *mut usize);
        if raw_ptr.is_null() || size == 0 {
            return Err(Error::new(
                std::io::ErrorKind::NotFound,
                "Failed to get app icon",
            ));
        }

        let icon_data = std::slice::from_raw_parts(raw_ptr, size).to_vec();
        libc::free(raw_ptr as *mut libc::c_void);

        icon_data
    };

    Ok(result)
}

pub fn spawn_app(bundle_identifier: &str, suspended: bool) -> Result<String, Error> {
    let c_bundle_id = CString::new(bundle_identifier).map_err(|_| {
        Error::new(
            std::io::ErrorKind::InvalidInput,
            "Invalid bundle identifier",
        )
    })?;

    let result = unsafe {
        let raw_ptr = spawn_app_native(c_bundle_id.as_ptr(), if suspended { 1 } else { 0 });
        if raw_ptr.is_null() {
            return Err(Error::new(std::io::ErrorKind::Other, "Failed to spawn app"));
        }

        let c_str = CStr::from_ptr(raw_ptr);
        let result_str = c_str
            .to_str()
            .unwrap_or("{\"success\":false,\"error\":\"Invalid UTF-8\"}")
            .to_owned();
        libc::free(raw_ptr as *mut libc::c_void);

        result_str
    };

    Ok(result)
}

pub fn terminate_app(pid: i32) -> Result<bool, Error> {
    let result = unsafe { terminate_app_native(pid) };

    Ok(result != 0)
}

pub fn resume_app(pid: i32) -> Result<String, Error> {
    let result = unsafe {
        let raw_ptr = resume_app_native(pid);
        if raw_ptr.is_null() {
            return Err(Error::new(
                std::io::ErrorKind::Other,
                "Failed to resume app",
            ));
        }

        let c_str = CStr::from_ptr(raw_ptr);
        let result_str = c_str
            .to_str()
            .unwrap_or("{\"success\":false,\"error\":\"Invalid UTF-8\"}")
            .to_owned();
        libc::free(raw_ptr as *mut libc::c_void);

        result_str
    };

    Ok(result)
}

pub fn get_app_running_status(bundle_identifier: &str) -> Result<String, Error> {
    let c_bundle_id = CString::new(bundle_identifier).map_err(|_| {
        Error::new(
            std::io::ErrorKind::InvalidInput,
            "Invalid bundle identifier",
        )
    })?;

    let result = unsafe {
        let raw_ptr = get_app_running_status_native(c_bundle_id.as_ptr());
        if raw_ptr.is_null() {
            return Err(Error::new(
                std::io::ErrorKind::Other,
                "Failed to get app running status",
            ));
        }

        let c_str = CStr::from_ptr(raw_ptr);
        let result_str = c_str
            .to_str()
            .unwrap_or("{\"running\":false,\"pid\":0}")
            .to_owned();
        libc::free(raw_ptr as *mut libc::c_void);

        result_str
    };

    Ok(result)
}

```

`src/server/src/ptrscan.rs`:

```rs
use crate::native_bridge;
use libc;
use lz4_flex::compress_prepend_size;
use std::collections::HashMap;
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;

/// Progress callback type for pointermap generation
pub type ProgressCallback = Arc<dyn Fn(&str, u64, u64, u64, u64) + Send + Sync>;

#[repr(C)]
struct ModuleEntry {
    entry_length: u32,
    entry_string: String,
    memory_size: i32,
    memory_address: u64,
}

// Make StaticData Send + Sync for parallel processing
#[derive(Clone, Copy)]
struct StaticData {
    module_index: u32,
    offset: u32,
}

// Helper function to find module for a given address using binary search
fn find_static_data(address: u64, modules: &[ModuleEntry]) -> Option<StaticData> {
    match modules.binary_search_by(|module| {
        if address < module.memory_address {
            std::cmp::Ordering::Greater
        } else if address >= module.memory_address + module.memory_size as u64 {
            std::cmp::Ordering::Less
        } else {
            std::cmp::Ordering::Equal
        }
    }) {
        Ok(idx) => Some(StaticData {
            module_index: idx as u32,
            offset: (address - modules[idx].memory_address) as u32,
        }),
        Err(_) => None,
    }
}

// Process memory read helper function
fn read_memory(pid: i32, address: usize, size: usize) -> Result<Vec<u8>, String> {
    let mut buffer = vec![0u8; size];

    match native_bridge::read_process_memory(pid, address as *mut libc::c_void, size, &mut buffer) {
        Ok(bytes_read) => {
            if bytes_read <= 0 {
                Err(format!("Failed to read memory at 0x{:x}", address))
            } else {
                buffer.truncate(bytes_read as usize);
                Ok(buffer)
            }
        }
        Err(e) => Err(format!("Failed to read memory at 0x{:x}: {}", address, e)),
    }
}

/// Region info for parallel processing
#[derive(Clone)]
struct RegionInfo {
    start_address: usize,
    end_address: usize,
    size: u64,
}

pub fn generate_pointermap(pid: i32) -> Result<Vec<u8>, String> {
    generate_pointermap_with_progress(pid, None)
}

pub fn generate_pointermap_with_progress(
    pid: i32,
    progress_callback: Option<ProgressCallback>,
) -> Result<Vec<u8>, String> {
    let progress_callback = progress_callback.map(Arc::new);

    let report_progress =
        |phase: &str, regions_done: u64, total_regions: u64, bytes_done: u64, total_bytes: u64| {
            if let Some(ref cb) = progress_callback {
                cb(phase, regions_done, total_regions, bytes_done, total_bytes);
            }
        };

    report_progress("Initializing", 0, 0, 0, 0);

    // Get memory regions
    let regions = native_bridge::enum_regions(pid)?;

    report_progress("Analyzing regions", 0, regions.len() as u64, 0, 0);

    // Helper function to check if a region should be skipped (iOS only)
    #[cfg(target_os = "ios")]
    fn should_skip_region(file_path: &str) -> bool {
        file_path.contains("dyld_shared_cache")
            || file_path.contains(".sqlite-shm")
            || file_path.contains(".db-shm")
            || file_path.contains("analyticsd")
            || file_path.contains("/usr/share/")
            || file_path.contains("/System/Library/Fonts")
            || file_path.contains("AppleKeyStore")
    }

    #[cfg(not(target_os = "ios"))]
    fn should_skip_region(_file_path: &str) -> bool {
        false
    }

    // Pre-filter and collect valid regions
    let mut valid_regions: Vec<RegionInfo> = Vec::new();
    let mut min_valid_addr = u64::MAX;
    let mut max_valid_addr: u64 = 0;

    for region in &regions {
        let start =
            u64::from_str_radix(region["start_address"].as_str().unwrap_or("0"), 16).unwrap_or(0);
        let end =
            u64::from_str_radix(region["end_address"].as_str().unwrap_or("0"), 16).unwrap_or(0);
        let protection = region["protection"].as_str().unwrap_or("");
        let file_path = region["file_path"].as_str().unwrap_or("");

        #[cfg(any(target_os = "ios", target_os = "macos"))]
        let is_valid = protection.contains('r');
        #[cfg(not(any(target_os = "ios", target_os = "macos")))]
        let is_valid = protection.contains('r') && protection.contains('p');

        if !is_valid || should_skip_region(file_path) {
            continue;
        }

        min_valid_addr = min_valid_addr.min(start);
        max_valid_addr = max_valid_addr.max(end);

        valid_regions.push(RegionInfo {
            start_address: start as usize,
            end_address: end as usize,
            size: end - start,
        });
    }

    let total_bytes_to_scan: u64 = valid_regions.iter().map(|r| r.size).sum();
    let valid_region_count = valid_regions.len() as u64;

    // Get modules
    let modules: Arc<Vec<ModuleEntry>> = Arc::new(match native_bridge::enum_modules(pid) {
        Ok(modules) => {
            let mut module_entries = Vec::new();
            for module in modules {
                let name = module["modulename"].as_str().unwrap_or("");
                let base = module["base"].as_u64().unwrap_or(0);
                let size: i32 = module["size"].as_i64().unwrap_or(0) as i32;
                module_entries.push(ModuleEntry {
                    entry_length: name.len() as u32,
                    entry_string: name.to_string(),
                    memory_size: size,
                    memory_address: base,
                });
            }
            module_entries
        }
        Err(e) => return Err(format!("Failed to enumerate modules: {}", e)),
    });

    report_progress(
        "Scanning memory",
        0,
        valid_region_count,
        0,
        total_bytes_to_scan,
    );

    // Atomic counters for progress tracking
    let processed_bytes = Arc::new(AtomicU64::new(0));
    let processed_regions = Arc::new(AtomicU64::new(0));

    // Use rayon for parallel processing if available, otherwise use threads
    let num_threads = std::thread::available_parallelism()
        .map(|p| p.get())
        .unwrap_or(4)
        .min(8); // Cap at 8 threads

    // Split regions into chunks for parallel processing
    let chunk_size = (valid_regions.len() + num_threads - 1) / num_threads;
    let region_chunks: Vec<Vec<RegionInfo>> = valid_regions
        .into_iter()
        .collect::<Vec<_>>()
        .chunks(chunk_size.max(1))
        .map(|c| c.to_vec())
        .collect();

    // Process regions in parallel using threads
    let handles: Vec<_> = region_chunks
        .into_iter()
        .map(|chunk| {
            let modules = Arc::clone(&modules);
            let processed_bytes = Arc::clone(&processed_bytes);
            let processed_regions = Arc::clone(&processed_regions);

            std::thread::spawn(move || {
                let mut local_map: HashMap<u64, Vec<(u64, Option<StaticData>)>> = HashMap::new();

                for region in chunk {
                    const CHUNK_SIZE: usize = 1024 * 1024 * 32; // 32MB chunks for better throughput
                    let mut current_address = region.start_address;

                    while current_address < region.end_address {
                        let chunk_end = (current_address + CHUNK_SIZE).min(region.end_address);
                        let chunk_size = chunk_end - current_address;

                        if chunk_size < 8 {
                            current_address = chunk_end;
                            continue;
                        }

                        if let Ok(memory) = read_memory(pid, current_address, chunk_size) {
                            // Process 8-byte aligned addresses only
                            let aligned_start = (current_address + 7) & !7;
                            let offset = aligned_start.saturating_sub(current_address);

                            // Use unsafe for faster memory access
                            let mem_slice = &memory[offset..];
                            let ptr_count = mem_slice.len() / 8;

                            for i in 0..ptr_count {
                                let idx = i * 8;
                                // Safe: we've verified bounds above
                                let value =
                                    u64::from_le_bytes(mem_slice[idx..idx + 8].try_into().unwrap());

                                // Quick range check first (most values will fail this)
                                if value >= min_valid_addr
                                    && value < max_valid_addr
                                    && value & 3 == 0
                                {
                                    let source_address = (aligned_start + idx) as u64;
                                    let static_data = find_static_data(source_address, &modules);
                                    local_map
                                        .entry(value)
                                        .or_insert_with(Vec::new)
                                        .push((source_address, static_data));
                                }
                            }

                            processed_bytes.fetch_add(memory.len() as u64, Ordering::Relaxed);
                        }

                        current_address = chunk_end;
                    }

                    processed_regions.fetch_add(1, Ordering::Relaxed);
                }

                local_map
            })
        })
        .collect();

    // Progress reporting thread
    let progress_callback_clone = progress_callback.clone();
    let processed_bytes_clone = Arc::clone(&processed_bytes);
    let processed_regions_clone = Arc::clone(&processed_regions);

    let progress_thread = std::thread::spawn(move || loop {
        std::thread::sleep(std::time::Duration::from_millis(200));
        let bytes = processed_bytes_clone.load(Ordering::Relaxed);
        let regions = processed_regions_clone.load(Ordering::Relaxed);

        if let Some(ref cb) = progress_callback_clone {
            cb(
                "Scanning memory",
                regions,
                valid_region_count,
                bytes,
                total_bytes_to_scan,
            );
        }

        if regions >= valid_region_count {
            break;
        }
    });

    // Merge results from all threads
    let mut pointer_map: HashMap<u64, Vec<(u64, Option<StaticData>)>> = HashMap::new();
    for handle in handles {
        let local_map = handle.join().unwrap();
        for (key, mut values) in local_map {
            pointer_map
                .entry(key)
                .or_insert_with(Vec::new)
                .append(&mut values);
        }
    }

    // Wait for progress thread to finish
    let _ = progress_thread.join();

    let final_bytes = processed_bytes.load(Ordering::Relaxed);
    let final_regions = processed_regions.load(Ordering::Relaxed);

    report_progress(
        "Building output",
        final_regions,
        valid_region_count,
        final_bytes,
        total_bytes_to_scan,
    );

    // Pre-allocate output buffer based on estimated size
    let estimated_size = 1024 + modules.len() * 64 + pointer_map.len() * 32;
    let mut uncompressed = Vec::with_capacity(estimated_size);

    // Write header: DynaDbg PointerMap format
    uncompressed.extend_from_slice(b"DPTR");
    uncompressed.extend_from_slice(&1u32.to_le_bytes());

    // Write modules
    uncompressed.extend_from_slice(&(modules.len() as u32).to_le_bytes());
    for module in modules.iter() {
        uncompressed.extend_from_slice(&module.entry_length.to_le_bytes());
        uncompressed.extend_from_slice(module.entry_string.as_bytes());
        uncompressed.extend_from_slice(&module.memory_address.to_le_bytes());
        uncompressed.extend_from_slice(&module.memory_size.to_le_bytes());
    }

    // Convert HashMap into a sorted Vec
    let mut sorted_entries: Vec<_> = pointer_map.into_iter().collect();
    sorted_entries.sort_unstable_by_key(|&(address, _)| address);

    // Total unique target addresses
    uncompressed.extend_from_slice(&(sorted_entries.len() as u64).to_le_bytes());

    // Total pointer count
    let total_count: u64 = sorted_entries.iter().map(|(_, v)| v.len() as u64).sum();
    uncompressed.extend_from_slice(&total_count.to_le_bytes());

    // Write all pointer entries
    for (target_value, mut pointers) in sorted_entries {
        pointers.sort_unstable_by_key(|(address, _)| *address);

        uncompressed.extend_from_slice(&target_value.to_le_bytes());
        uncompressed.extend_from_slice(&(pointers.len() as u32).to_le_bytes());

        for (address, static_data) in pointers {
            uncompressed.extend_from_slice(&address.to_le_bytes());

            match static_data {
                Some(data) => {
                    uncompressed.push(1);
                    uncompressed.extend_from_slice(&data.module_index.to_le_bytes());
                    uncompressed.extend_from_slice(&data.offset.to_le_bytes());
                }
                None => {
                    uncompressed.push(0);
                }
            }
        }
    }

    report_progress(
        "Compressing",
        final_regions,
        valid_region_count,
        final_bytes,
        total_bytes_to_scan,
    );

    let compressed = compress_prepend_size(&uncompressed);

    report_progress(
        "Complete",
        final_regions,
        valid_region_count,
        final_bytes,
        total_bytes_to_scan,
    );

    Ok(compressed)
}

```

`src/server/src/request.rs`:

```rs
#![allow(dead_code)]

use serde::{Deserialize, Serialize};

#[derive(Deserialize)]
pub struct OpenProcessRequest {
    pub pid: i32,
}

#[derive(Deserialize)]
pub struct ReadMemoryRequest {
    pub address: usize,
    pub size: usize,
    #[serde(default)]
    pub use_ptrace: bool,
}

#[derive(Deserialize)]
pub struct ResolveAddrRequest {
    pub query: String,
}

#[derive(Deserialize)]
pub struct WriteMemoryRequest {
    pub address: usize,
    pub buffer: Vec<u8>,
}

#[derive(Deserialize, Clone)]
pub struct MemoryScanRequest {
    pub pattern: String,
    #[serde(default)]
    pub pattern_max: Option<String>, // For range search: pattern is min, pattern_max is max
    pub address_ranges: Vec<(usize, usize)>,
    pub find_type: String,
    pub data_type: String,
    pub scan_id: String,
    pub align: usize,
    pub return_as_json: bool,
    pub do_suspend: bool,
}

#[derive(Deserialize, Clone)]
pub struct MemoryFilterRequest {
    pub pattern: String,
    #[serde(default)]
    pub pattern_max: Option<String>, // For range filter: pattern is min, pattern_max is max
    pub data_type: String,
    pub scan_id: String,
    pub filter_method: String,
    pub return_as_json: bool,
    pub do_suspend: bool,
}

// YARA memory scan request
#[derive(Deserialize, Clone)]
pub struct YaraScanRequest {
    /// YARA rule source code
    pub rule: String,
    /// Memory address ranges to scan
    pub address_ranges: Vec<(usize, usize)>,
    /// Unique scan identifier
    pub scan_id: String,
    /// Alignment for match addresses (filter results to aligned addresses)
    pub align: usize,
    /// Suspend process during scan
    pub do_suspend: bool,
}

// YARA match result
#[derive(Serialize, Clone)]
pub struct YaraMatch {
    /// Rule identifier that matched
    pub rule_name: String,
    /// Address where match was found
    pub address: usize,
    /// Length of matched data
    pub length: usize,
    /// Pattern identifier within the rule
    pub pattern_id: String,
    /// Matched data as hex string (first 64 bytes max)
    pub matched_data: String,
}

// YARA scan response
#[derive(Serialize)]
pub struct YaraScanResponse {
    pub success: bool,
    pub message: String,
    pub scan_id: String,
    pub matches: Vec<YaraMatch>,
    pub total_matches: usize,
    pub scanned_bytes: u64,
}

#[derive(Deserialize)]
pub struct ExploreDirectoryRequest {
    pub path: String,
    pub max_depth: i32,
}

#[derive(Deserialize)]
pub struct ReadFileRequest {
    pub path: String,
}

#[derive(Deserialize)]
pub struct UploadFileRequest {
    pub path: String,
}

#[derive(Deserialize)]
pub struct SetWatchPointRequest {
    pub address: usize,
    pub size: usize,
    pub _type: String, // "r", "w", "rw", "x", "rx", "wx", "rwx"
}

#[derive(Serialize)]
pub struct SetWatchPointResponse {
    pub success: bool,
    pub message: String,
    pub watchpoint_id: Option<String>, // Added for tracking
}

#[derive(Deserialize)]
pub struct RemoveWatchPointRequest {
    pub address: usize,
}

#[derive(Serialize)]
pub struct RemoveWatchPointResponse {
    pub success: bool,
    pub message: String,
}

// New watchpoint list request/response
#[derive(Deserialize)]
pub struct ListWatchPointsRequest {
    // Empty for now, might add filtering options later
}

#[derive(Serialize)]
pub struct WatchPointInfo {
    pub id: String,
    pub address: usize,
    pub size: usize,
    pub access_type: String, // "r", "w", "rw", "x", "rx", "wx", "rwx"
    pub hit_count: u64,
    pub created_at: String, // ISO 8601 timestamp
    pub description: Option<String>,
}

#[derive(Serialize)]
pub struct ListWatchPointsResponse {
    pub success: bool,
    pub watchpoints: Vec<WatchPointInfo>,
    pub message: Option<String>,
}

#[derive(Deserialize)]
pub struct SetBreakPointRequest {
    pub address: usize,
    pub hit_count: i32,
    /// If true, trace results will be written to a file on the server instead of sending to UI
    #[serde(default)]
    pub trace_to_file: bool,
    /// File path for trace output (required if trace_to_file is true)
    #[serde(default)]
    pub trace_file_path: Option<String>,
    /// Optional end address - trace stops when PC reaches this address
    #[serde(default)]
    pub end_address: Option<usize>,
    /// If true, dump initial memory and log all memory accesses during trace
    #[serde(default)]
    pub full_memory_cache: bool,
    /// If true, use software breakpoint instead of hardware breakpoint
    #[serde(default)]
    pub is_software: Option<bool>,
}

#[derive(Serialize)]
pub struct SetBreakPointResponse {
    pub success: bool,
    pub message: String,
    /// If trace_to_file was enabled, this contains the file path
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trace_file_path: Option<String>,
}

#[derive(Deserialize)]
pub struct RemoveBreakPointRequest {
    pub address: usize,
}

#[derive(Serialize)]
pub struct RemoveBreakPointResponse {
    pub success: bool,
    pub message: String,
}

// Software breakpoint original bytes response
#[derive(Serialize)]
pub struct SoftwareBreakpointBytesResponse {
    pub success: bool,
    pub address: usize,
    pub original_bytes: String,
    pub size: usize,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}

// Trace status request/response
#[derive(Serialize)]
pub struct TraceStatusResponse {
    pub success: bool,
    pub enabled: bool,
    pub file_path: Option<String>,
    pub entry_count: u32,
    pub ended_by_end_address: bool,
    pub message: String,
}

#[derive(Deserialize)]
pub struct ChangeProcessStateRequest {
    pub do_play: bool,
}

#[derive(Serialize)]
pub struct ChangeProcessStateResponse {
    pub success: bool,
    pub message: String,
}

#[derive(Deserialize)]
pub struct DisassembleRequest {
    pub address: u64,
    pub size: usize,
    pub architecture: String, // "x86_64" or "arm64"
}

#[derive(Deserialize)]
pub struct PointerMapGenerateRequest {
    pub address: u64,
}

#[derive(Deserialize)]
pub struct ScanProgressRequest {
    pub scan_id: String,
}

#[derive(Deserialize)]
pub struct FilterProgressRequest {
    pub filter_id: String,
}

#[derive(Serialize, Clone)]
pub struct ScanProgressResponse {
    pub scan_id: String,
    pub progress_percentage: f64,
    pub scanned_bytes: u64,
    pub total_bytes: u64,
    pub is_scanning: bool,
    pub current_region: Option<String>,
}

#[derive(Serialize, Clone)]
pub struct FilterProgressResponse {
    pub filter_id: String,
    pub progress_percentage: f64,
    pub processed_results: u64,
    pub total_results: u64,
    pub is_filtering: bool,
    pub current_region: Option<String>,
}

#[derive(Deserialize)]
pub struct StopScanRequest {
    pub scan_id: String,
}

#[derive(Serialize)]
pub struct StopScanResponse {
    pub success: bool,
    pub message: String,
}

#[derive(Deserialize)]
pub struct ClearScanRequest {
    pub scan_id: String,
}

#[derive(Serialize)]
pub struct ClearScanResponse {
    pub success: bool,
    pub message: String,
}

#[derive(Deserialize)]
pub struct ClientVerificationRequest {
    pub encrypted_git_hash: String,
}

#[derive(Serialize)]
pub struct ClientVerificationResponse {
    pub success: bool,
    pub message: String,
    pub server_info: Option<serde_json::Value>,
    pub access_token: Option<String>,
}

// New break state control requests/responses
#[derive(Deserialize)]
pub struct ContinueExecutionRequest {
    #[serde(default)]
    pub thread_id: Option<u64>, // For backward compatibility (single thread)
    #[serde(default)]
    pub thread_ids: Option<Vec<u64>>, // Multiple threads
}

#[derive(Serialize)]
pub struct ContinueExecutionResponse {
    pub success: bool,
    pub message: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub results: Option<Vec<ThreadContinueResult>>, // Details for multiple threads
}

#[derive(Serialize)]
pub struct ThreadContinueResult {
    pub thread_id: u64,
    pub success: bool,
    pub message: String,
}

#[derive(Deserialize)]
pub struct SingleStepRequest {
    pub thread_id: u64,
}

#[derive(Serialize)]
pub struct SingleStepResponse {
    pub success: bool,
    pub message: String,
}

#[derive(Deserialize)]
pub struct ReadRegisterRequest {
    pub thread_id: u64,
    pub register_name: String,
}

#[derive(Serialize)]
pub struct ReadRegisterResponse {
    pub success: bool,
    pub register_name: String,
    pub value: Option<u64>,
    pub message: String,
}

#[derive(Deserialize)]
pub struct WriteRegisterRequest {
    pub thread_id: u64,
    pub register_name: String,
    pub value: u64,
}

#[derive(Serialize)]
pub struct WriteRegisterResponse {
    pub success: bool,
    pub message: String,
}

#[derive(Deserialize)]
pub struct DebugStateRequest {}

#[derive(Serialize)]
pub struct DebugStateResponse {
    pub success: bool,
    pub is_in_break_state: bool,
    pub message: String,
}

#[derive(Deserialize)]
pub struct GetAppIconRequest {
    pub bundle_identifier: String,
}

#[derive(Deserialize)]
pub struct SpawnAppRequest {
    pub bundle_identifier: String,
    #[serde(default)]
    pub suspended: bool,
}

#[derive(Deserialize)]
pub struct TerminateAppRequest {
    pub pid: i32,
}

#[derive(Deserialize)]
pub struct SpawnProcessRequest {
    pub executable_path: String,
    #[serde(default)]
    pub args: Vec<String>,
}

#[derive(Deserialize)]
pub struct SpawnProcessWithPtyRequest {
    pub executable_path: String,
    #[serde(default)]
    pub args: Vec<String>,
}

#[derive(Deserialize)]
pub struct PtyWriteRequest {
    pub pty_fd: i32,
    pub data: String,
}

#[derive(Deserialize)]
pub struct PtyResizeRequest {
    pub pty_fd: i32,
    pub rows: i32,
    pub cols: i32,
}

#[derive(Deserialize)]
pub struct ResumeAppRequest {
    pub pid: i32,
}

#[derive(Deserialize)]
pub struct AppRunningStatusRequest {
    pub bundle_identifier: String,
}

/// Script engine type
#[derive(Deserialize, Clone, Debug, Default)]
#[serde(rename_all = "lowercase")]
pub enum ScriptEngineType {
    /// Python 3 (default) - RustPython interpreter
    #[default]
    Python,
    /// Rhai scripting language (legacy)
    Rhai,
}

// General-purpose script execution (async)
#[derive(Deserialize)]
pub struct ExecuteScriptRequest {
    /// Script source code
    pub script: String,
    /// Script engine type (default: python)
    #[serde(default)]
    pub engine: ScriptEngineType,
}

/// Response when starting a script execution (async)
#[derive(Serialize)]
pub struct ExecuteScriptResponse {
    pub success: bool,
    /// Job ID for tracking the script execution
    pub job_id: String,
    pub message: String,
}

/// Script execution status
#[derive(Serialize, Clone, Debug, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum ScriptJobStatus {
    /// Script is queued but not yet running
    Pending,
    /// Script is currently running
    Running,
    /// Script completed successfully
    Completed,
    /// Script failed with an error
    Failed,
    /// Script was cancelled
    Cancelled,
}

/// File upload queued by script
#[derive(Serialize, Clone, Debug)]
pub struct ScriptFileUpload {
    /// Suggested filename
    pub filename: String,
    /// File data as base64
    pub data_base64: String,
    /// MIME type if known
    pub mime_type: Option<String>,
}

/// Response for script status query
#[derive(Serialize)]
pub struct ScriptStatusResponse {
    pub success: bool,
    pub job_id: String,
    pub status: ScriptJobStatus,
    /// Accumulated output so far (new lines since last query)
    pub output: String,
    /// Error message if failed
    pub error: Option<String>,
    /// Whether a trace callback was registered
    pub trace_callback_registered: bool,
    /// Files queued for upload by the script
    pub files: Vec<ScriptFileUpload>,
}

/// Response for script cancellation
#[derive(Serialize)]
pub struct ScriptCancelResponse {
    pub success: bool,
    pub message: String,
}

/// Response for script session disable
#[derive(Serialize)]
pub struct ScriptDisableResponse {
    pub success: bool,
    pub message: String,
}

/// Signal configuration entry (catch/pass behavior)
#[derive(Serialize, Deserialize, Clone)]
pub struct SignalConfigEntry {
    pub signal: i32,
    pub catch_signal: bool,
    pub pass_signal: bool,
}

/// Request for setting a single signal configuration
#[derive(Deserialize)]
pub struct SetSignalConfigRequest {
    pub signal: i32,
    pub catch_signal: bool,
    pub pass_signal: bool,
}

/// Request for setting all signal configurations
#[derive(Deserialize)]
pub struct SetAllSignalConfigsRequest {
    pub configs: Vec<SignalConfigEntry>,
}

/// Response for getting signal configurations
#[derive(Serialize)]
pub struct GetSignalConfigsResponse {
    pub success: bool,
    pub configs: Vec<SignalConfigEntry>,
}

/// Request for removing a signal configuration
#[derive(Deserialize)]
pub struct RemoveSignalConfigRequest {
    pub signal: i32,
}

// PointerMap generation types
#[derive(Serialize, Clone)]
pub struct PointerMapProgressResponse {
    pub task_id: String,
    pub progress_percentage: f64,
    pub current_phase: String,
    pub processed_regions: u64,
    pub total_regions: u64,
    pub processed_bytes: u64,
    pub total_bytes: u64,
    pub is_generating: bool,
    pub is_complete: bool,
    pub error: Option<String>,
}

#[derive(Deserialize)]
pub struct PointerMapProgressRequest {
    pub task_id: String,
}

#[derive(Serialize, Clone)]
pub struct PointerMapStartResponse {
    pub success: bool,
    pub task_id: String,
    pub message: String,
}

```

`src/server/src/serve.rs`:

```rs
use bytes::Bytes;
use std::net::IpAddr;
use std::sync::{Arc, Mutex};
use warp::Filter;

use crate::api;
use crate::logger;
use crate::native_bridge;
use crate::request;
use crate::wasm_bridge;

pub async fn serve(mode: i32, host: IpAddr, port: u16) {
    // Initialize WASM bridge if in WASM mode
    if wasm_bridge::is_wasm_mode() {
        if let Err(e) = wasm_bridge::init_wasm_bridge().await {
            log::error!("Failed to initialize WASM bridge: {}", e);
        }
    }

    let pid_state = Arc::new(Mutex::new(None));

    let cors = warp::cors()
        .allow_any_origin()
        .allow_headers(vec!["*", "Content-Type", "Authorization"])
        .allow_methods(vec!["GET", "POST", "PUT", "DELETE", "OPTIONS"]);

    // API Routes with /api prefix
    let api = warp::path("api");

    // CORS Preflight handler
    let cors_preflight = api
        .and(warp::options())
        .map(|| {
            warp::reply::with_status("", warp::http::StatusCode::OK)
        });

    // Server Info Routes
    let server_info = api
        .and(warp::path!("server" / "info"))
        .and(warp::get())
        .and(api::with_auth())
        .and_then(api::server_info_handler);

    // Process Routes
    let enum_process = api
        .and(warp::path!("processes"))
        .and(warp::get())
        .and(api::with_auth())
        .and_then(|| async move { api::enumerate_process_handler().await });

    let get_process_icon = api
        .and(warp::path!("processes" / i32 / "icon"))
        .and(warp::get())
        .and(api::with_auth())
        .and_then(|pid| async move { api::get_process_icon_handler(pid).await });

    let enum_module = api
        .and(warp::path!("modules"))
        .and(warp::get())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|pid_state| async move { api::enumerate_modules_handler(pid_state).await });

    let enum_threads = api
        .and(warp::path!("threads"))
        .and(warp::get())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|pid_state| async move { api::enumerate_threads_handler(pid_state).await });

    let enum_symbols = api
        .and(warp::path!("modules" / usize / "symbols"))
        .and(warp::get())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|module_base, pid_state| async move { 
            api::enumerate_symbols_handler(module_base, pid_state).await 
        });

    let open_process = api
        .and(warp::path!("processes" / i32 / "attach"))
        .and(warp::post())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|pid, pid_state| async move {
            let open_process = request::OpenProcessRequest { pid };
            api::open_process_handler(pid_state, open_process).await
        });

    let change_process_state = api
        .and(warp::path!("process" / "state"))
        .and(warp::put())
        .and(warp::body::json())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|state_request, pid_state| async move {
            api::change_process_state_handler(pid_state, state_request).await
        });

    let get_process_info = api
        .and(warp::path!("process" / "info"))
        .and(warp::get())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|pid_state| async move { api::get_app_info_handler(pid_state).await });
    // Memory Operation Routes
    let read_memory = api
        .and(warp::path!("memory" / "read"))
        .and(warp::get())
        .and(warp::query::<request::ReadMemoryRequest>())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|read_memory_request, pid_state| async move {
            api::read_memory_handler(pid_state, read_memory_request).await
        });

    let write_memory = api
        .and(warp::path!("memory" / "write"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|write_memory, pid_state| async move {
            api::write_memory_handler(pid_state, write_memory).await
        });

    let enum_regions = api
        .and(warp::path!("memory" / "regions"))
        .and(warp::get())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and(warp::query::<api::EnumerateRegionsQuery>())
        .and_then(|pid_state, query: api::EnumerateRegionsQuery| async move { 
            api::enumerate_regions_handler(pid_state, query.include_file_path.unwrap_or(false)).await 
        });

    // Memory Analysis Routes
    let memory_scan = api
        .and(warp::path!("memory" / "scan"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|scan_request, pid_state| async move {
            api::memory_scan_handler(pid_state, scan_request).await
        });

    let yara_scan = api
        .and(warp::path!("memory" / "yara"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|scan_request, pid_state| async move {
            api::yara_scan_handler(pid_state, scan_request).await
        });

    let memory_filter = api
        .and(warp::path!("memory" / "filter"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|filter_request, pid_state| async move {
            api::memory_filter_handler(pid_state, filter_request).await
        });

    let get_scan_progress = api
        .and(warp::path!("memory" / "scan" / "progress"))
        .and(warp::post())
        .and(warp::body::json())
        .and_then(|scan_progress_request| async move {
            api::get_scan_progress_handler(scan_progress_request).await
        });

    let get_filter_progress = api
        .and(warp::path!("memory" / "filter" / "progress"))
        .and(warp::post())
        .and(warp::body::json())
        .and_then(|filter_progress_request| async move {
            api::get_filter_progress_handler(filter_progress_request).await
        });

    let get_scan_results = api
        .and(warp::path!("memory" / "scan" / "results"))
        .and(warp::post())
        .and(warp::body::json())
        .and_then(|scan_results_request| async move {
            api::get_scan_results_handler(scan_results_request).await
        });

    let get_filter_results = api
        .and(warp::path!("memory" / "filter" / "results"))
        .and(warp::post())
        .and(warp::body::json())
        .and_then(|filter_results_request| async move {
            api::get_scan_results_handler(filter_results_request).await
        });

    let stop_scan = api
        .and(warp::path!("memory" / "scan" / "stop"))
        .and(warp::post())
        .and(warp::body::json())
        .and_then(|stop_scan_request| async move {
            api::stop_scan_handler(stop_scan_request).await
        });

    let clear_scan = api
        .and(warp::path!("memory" / "scan" / "clear"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|clear_scan_request, pid_state| async move {
            api::clear_scan_handler(pid_state, clear_scan_request).await
        });

    let disassemble = api
        .and(warp::path!("memory" / "disassemble"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|disasm_request, pid_state| async move {
            api::disassemble_handler(disasm_request, pid_state).await
        });

    // Pointer Map Routes
    let generate_pointermap = api
        .and(warp::path!("memory" / "pointermap"))
        .and(warp::get())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|pid_state| async move {
            api::generate_pointermap_handler(pid_state).await
        });

    let start_pointermap = api
        .and(warp::path!("memory" / "pointermap" / "start"))
        .and(warp::post())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|pid_state| async move {
            api::start_pointermap_handler(pid_state).await
        });

    let pointermap_progress = api
        .and(warp::path!("memory" / "pointermap" / "progress"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and_then(|progress_request| async move {
            api::pointermap_progress_handler(progress_request).await
        });

    let pointermap_download = api
        .and(warp::path!("memory" / "pointermap" / "download"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and_then(|progress_request| async move {
            api::pointermap_download_handler(progress_request).await
        });

    // Debug Routes
    let set_watchpoint = api
        .and(warp::path!("debug" / "watchpoint"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|set_watchpoint_request, pid_state| async move {
            api::set_watchpoint_handler(pid_state, set_watchpoint_request).await
        });

    let remove_watchpoint = api
        .and(warp::path!("debug" / "watchpoint"))
        .and(warp::delete())
        .and(warp::body::json())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|remove_watchpoint_request, pid_state| async move {
            api::remove_watchpoint_handler(pid_state, remove_watchpoint_request).await
        });

    let list_watchpoints = api
        .and(warp::path!("debug" / "watchpoints"))
        .and(warp::get())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|pid_state| async move {
            let request = request::ListWatchPointsRequest {};
            api::list_watchpoints_handler(pid_state, request).await
        });

    let set_breakpoint = api
        .and(warp::path!("debug" / "breakpoint"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|set_breakpoint_request, pid_state| async move {
            api::set_breakpoint_handler(pid_state, set_breakpoint_request).await
        });

    let remove_breakpoint = api
        .and(warp::path!("debug" / "breakpoint"))
        .and(warp::delete())
        .and(warp::body::json())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|remove_breakpoint_request, pid_state| async move {
            api::remove_breakpoint_handler(pid_state, remove_breakpoint_request).await
        });

    // Get software breakpoint original bytes
    let get_software_bp_bytes = api
        .and(warp::path!("debug" / "breakpoint" / "software" / usize))
        .and(warp::get())
        .and(api::with_auth())
        .and_then(|address: usize| async move {
            api::get_software_breakpoint_bytes_handler(address).await
        });

    // Signal configuration routes (catch/pass behavior)
    let get_signal_configs = api
        .and(warp::path!("debug" / "signals"))
        .and(warp::get())
        .and(api::with_auth())
        .and_then(|| async move {
            api::get_signal_configs_handler().await
        });

    let set_signal_config = api
        .and(warp::path!("debug" / "signals"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and_then(|request| async move {
            api::set_signal_config_handler(request).await
        });

    let set_all_signal_configs = api
        .and(warp::path!("debug" / "signals" / "all"))
        .and(warp::put())
        .and(warp::body::json())
        .and(api::with_auth())
        .and_then(|request| async move {
            api::set_all_signal_configs_handler(request).await
        });

    let remove_signal_config = api
        .and(warp::path!("debug" / "signals" / "remove"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and_then(|request| async move {
            api::remove_signal_config_handler(request).await
        });

    // Trace status and download routes
    let get_trace_status = api
        .and(warp::path!("debug" / "trace" / "status"))
        .and(warp::get())
        .and(api::with_auth())
        .and_then(|| async move {
            api::get_trace_status_handler().await
        });

    let download_trace_file = api
        .and(warp::path!("debug" / "trace" / "file" / "download"))
        .and(warp::get())
        .and(api::with_auth())
        .and_then(|| async move {
            api::download_trace_file_handler().await
        });

    // New break state control routes
    let continue_execution = api
        .and(warp::path!("debug" / "continue"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|continue_request, pid_state| async move {
            api::continue_execution_handler(pid_state, continue_request).await
        });

    let single_step = api
        .and(warp::path!("debug" / "step"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|step_request, pid_state| async move {
            api::single_step_handler(pid_state, step_request).await
        });

    let read_register = api
        .and(warp::path!("debug" / "register" / "read"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|read_request, pid_state| async move {
            api::read_register_handler(pid_state, read_request).await
        });

    let write_register = api
        .and(warp::path!("debug" / "register" / "write"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|write_request, pid_state| async move {
            api::write_register_handler(pid_state, write_request).await
        });

    let debug_state = api
        .and(warp::path!("debug" / "state"))
        .and(warp::get())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|pid_state| async move {
            let debug_state_request = request::DebugStateRequest {};
            api::debug_state_handler(pid_state, debug_state_request).await
        });

    // Auth Routes
    // クライアント検証エンドポイント
    let verify_client = api
        .and(warp::path!("auth" / "verify"))
        .and(warp::post())
        .and(warp::body::json())
        .and_then(|verification_request| async move {
            api::verify_client_handler(verification_request).await
        });

    // トークン無効化エンドポイント (simplified - auth disabled)
    let logout = api
        .and(warp::path!("auth" / "logout"))
        .and(warp::post())
        .and(api::with_auth())
        .and_then(|| async move {
            let response = serde_json::json!({
                "success": true,
                "message": "Logout successful (auth disabled)"
            });
            Ok::<_, warp::Rejection>(warp::reply::json(&response))
        });

    // Utility Routes
    let resolve_addr = api
        .and(warp::path!("memory" / "resolve"))
        .and(warp::get())
        .and(warp::query::<request::ResolveAddrRequest>())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|resolve_addr_request, pid_state| async move {
            api::resolve_addr_handler(pid_state, resolve_addr_request).await
        });

    let explore_directory = api
        .and(warp::path!("utils" / "directory"))
        .and(warp::get())
        .and(warp::query::<request::ExploreDirectoryRequest>())
        .and(api::with_auth())
        .and_then(|explore_directory_request| async move {
            api::explore_directory_handler(explore_directory_request).await
        });

    let read_file = api
        .and(warp::path!("utils" / "file"))
        .and(warp::get())
        .and(warp::query::<request::ReadFileRequest>())
        .and(api::with_auth())
        .and_then(|read_file_request| async move { 
            api::read_file_handler(read_file_request).await 
        });

    let upload_file = api
        .and(warp::path!("utils" / "file"))
        .and(warp::post())
        .and(warp::query::<request::UploadFileRequest>())
        .and(warp::body::bytes())
        .and(api::with_auth())
        .and_then(|upload_request: request::UploadFileRequest, body: Bytes| async move {
            api::upload_file_handler(upload_request.path, body).await
        });

    // WASM binary dump for Ghidra analysis
    let wasm_dump = api
        .and(warp::path!("wasm" / "dump"))
        .and(warp::get())
        .and(api::with_auth())
        .and_then(|| async move {
            api::wasm_dump_handler().await
        });

    // WASM module info
    let wasm_info = api
        .and(warp::path!("wasm" / "info"))
        .and(warp::get())
        .and(api::with_auth())
        .and_then(|| async move {
            api::wasm_info_handler().await
        });

    let get_exception_info = api
        .and(warp::path!("debug" / "exception"))
        .and(warp::get())
        .and(warp::query::<std::collections::HashMap<String, String>>()
            .or(warp::any().map(|| std::collections::HashMap::new()))
            .unify())
        .and(api::with_auth())
        .and_then(|query_params: std::collections::HashMap<String, String>| async move { 
            let exception_type_filter = query_params.get("exception_type").cloned();
            let singlestep_mode_filter = query_params.get("singlestep_mode").cloned();
            api::get_exception_info_handler(exception_type_filter, singlestep_mode_filter).await 
        });

    // Execute general-purpose script (async)
    let execute_script = api
        .and(warp::path!("script" / "execute"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|script_request: request::ExecuteScriptRequest, pid_state| async move {
            api::execute_script_handler(pid_state, script_request).await
        });

    // Get script execution status
    let script_status = api
        .and(warp::path!("script" / "status" / String))
        .and(warp::get())
        .and(api::with_auth())
        .and_then(|job_id: String| async move {
            api::script_status_handler(job_id).await
        });

    // Cancel script execution
    let script_cancel = api
        .and(warp::path!("script" / String))
        .and(warp::delete())
        .and(api::with_auth())
        .and_then(|job_id: String| async move {
            api::script_cancel_handler(job_id).await
        });

    // Disable script session (removes all script-owned breakpoints)
    let script_disable = api
        .and(warp::path!("script" / "disable"))
        .and(warp::post())
        .and(api::with_auth())
        .and_then(|| async move {
            api::script_disable_handler().await
        });

    // List installed apps
    let get_installed_apps = api
        .and(warp::path!("apps"))
        .and(warp::get())
        .and(api::with_auth())
        .and_then(|| async move {
            api::get_installed_apps_handler().await
        });

    // Get app icon
    let get_app_icon = api
        .and(warp::path!("apps" / "icon"))
        .and(warp::get())
        .and(warp::query::<request::GetAppIconRequest>())
        .and(api::with_auth())
        .and_then(|request| async move {
            api::get_app_icon_handler(request).await
        });

    // Spawn app via FBSSystemService
    let spawn_app = api
        .and(warp::path!("apps" / "spawn"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|request, pid_state| async move {
            api::spawn_app_handler(pid_state, request).await
        });

    // Spawn process via fork/exec (Linux)
    let spawn_process = api
        .and(warp::path!("process" / "spawn"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|request, pid_state| async move {
            api::spawn_process_handler(pid_state, request).await
        });

    // Spawn process with PTY (Linux)
    let spawn_process_pty = api
        .and(warp::path!("process" / "spawn-pty"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|request, pid_state| async move {
            api::spawn_process_with_pty_handler(pid_state, request).await
        });

    // PTY read
    let pty_read = api
        .and(warp::path!("pty" / i32 / "read"))
        .and(warp::get())
        .and(api::with_auth())
        .and_then(|pty_fd| async move {
            api::pty_read_handler(pty_fd).await
        });

    // PTY write
    let pty_write = api
        .and(warp::path!("pty" / "write"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and_then(|request| async move {
            api::pty_write_handler(request).await
        });

    // PTY resize
    let pty_resize = api
        .and(warp::path!("pty" / "resize"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and_then(|request| async move {
            api::pty_resize_handler(request).await
        });

    // PTY close
    let pty_close = api
        .and(warp::path!("pty" / i32 / "close"))
        .and(warp::post())
        .and(api::with_auth())
        .and_then(|pty_fd| async move {
            api::pty_close_handler(pty_fd).await
        });

    // Terminate app
    let terminate_app = api
        .and(warp::path!("apps" / "terminate"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and_then(|request| async move {
            api::terminate_app_handler(request).await
        });

    // Resume suspended app
    let resume_app = api
        .and(warp::path!("apps" / "resume"))
        .and(warp::post())
        .and(warp::body::json())
        .and(api::with_auth())
        .and(api::with_state(pid_state.clone()))
        .and_then(|request, pid_state| async move {
            api::resume_app_handler(pid_state, request).await
        });

    // Check app running status
    let get_app_running_status = api
        .and(warp::path!("apps" / "status"))
        .and(warp::get())
        .and(warp::query::<request::AppRunningStatusRequest>())
        .and(api::with_auth())
        .and_then(|request| async move {
            api::get_app_running_status_handler(request).await
        });

    // Combine all routes - grouped with boxed() to reduce type nesting depth
    
    // Group 1: Basic routes
    let basic_routes = cors_preflight
        .or(server_info)
        .or(enum_process)
        .or(get_process_icon)
        .or(enum_module)
        .or(enum_threads)
        .or(enum_symbols)
        .or(open_process)
        .or(change_process_state)
        .or(get_process_info)
        .boxed();
    
    // Group 2: Memory routes
    let memory_routes = read_memory
        .or(write_memory)
        .or(enum_regions)
        .or(yara_scan)
        .or(memory_scan)
        .or(memory_filter)
        .or(get_scan_progress)
        .or(get_filter_progress)
        .or(get_scan_results)
        .or(get_filter_results)
        .or(stop_scan)
        .or(clear_scan)
        .or(disassemble)
        .or(generate_pointermap)
        .or(start_pointermap)
        .or(pointermap_progress)
        .or(pointermap_download)
        .or(resolve_addr)
        .boxed();
    
    // Group 3: Debug routes
    let debug_routes = set_watchpoint
        .or(remove_watchpoint)
        .or(list_watchpoints)
        .or(set_breakpoint)
        .or(remove_breakpoint)
        .or(get_software_bp_bytes)
        .or(get_signal_configs)
        .or(set_signal_config)
        .or(set_all_signal_configs)
        .or(remove_signal_config)
        .or(get_trace_status)
        .or(download_trace_file)
        .or(continue_execution)
        .or(single_step)
        .or(read_register)
        .or(write_register)
        .or(debug_state)
        .or(get_exception_info)
        .boxed();
    
    // Group 4: Utility routes
    let utility_routes = explore_directory
        .or(read_file)
        .or(upload_file)
        .or(wasm_dump)
        .or(wasm_info)
        .or(execute_script)
        .or(script_status)
        .or(script_disable)
        .or(script_cancel)
        .boxed();
    
    // Group 5: App management routes
    let app_routes = get_installed_apps
        .or(get_app_icon)
        .or(spawn_app)
        .or(spawn_process)
        .or(spawn_process_pty)
        .or(pty_read)
        .or(pty_write)
        .or(pty_resize)
        .or(pty_close)
        .or(terminate_app)
        .or(resume_app)
        .or(get_app_running_status)
        .boxed();
    
    // Group 6: Auth routes
    let auth_routes = verify_client
        .or(logout)
        .boxed();
    
    // Combine all groups
    let routes = basic_routes
        .or(memory_routes)
        .or(debug_routes)
        .or(utility_routes)
        .or(app_routes)
        .or(auth_routes)
        .with(cors)
        .with(warp::log::custom(logger::http_log))
        .recover(api::handle_auth_rejection);

    native_bridge::native_api_init(mode);
    
    // Initialize MachOKit parser for symbol enumeration (macOS/iOS only)
    #[cfg(any(target_os = "macos", target_os = "ios"))]
    {
        if let Err(e) = crate::macho_bridge::init_macho_parser() {
            log::warn!("Failed to initialize Symbol parser: {}", e);
        } else {
            // log::info!("MachOKit parser initialized successfully");
        }
    }
    
    warp::serve(routes).run((host, port)).await;
}

```

`src/server/src/swift/Package.resolved`:

```resolved
{
  "originHash" : "212eb45402a67a174d7ad5c76e67805141b0f9f1a4c40bca44233fbe9e5ba1be",
  "pins" : [
    {
      "identity" : "swift-fileio",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/p-x9/swift-fileio.git",
      "state" : {
        "revision" : "76a4c719e796a1e5052e283788d8cd92408758fe",
        "version" : "0.12.0"
      }
    }
  ],
  "version" : 3
}

```

`src/server/src/swift/Package.swift`:

```swift
// swift-tools-version: 5.10

import PackageDescription

let package = Package(
    name: "MachOBridge",
    platforms: [
        .macOS(.v10_15),
        .iOS(.v13),
    ],
    products: [
        .library(
            name: "MachOBridge",
            type: .static,
            targets: ["MachOBridge"]
        ),
    ],
    dependencies: [
        .package(path: "../../../MachOKit")
    ],
    targets: [
        .target(
            name: "MachOBridge",
            dependencies: [
                .product(name: "MachOKit", package: "MachOKit")
            ],
            path: "Sources"
        ),
    ]
)

```

`src/server/src/swift/Sources/MachOBridge.swift`:

```swift
// MachOBridge.swift
// C-compatible wrapper for MachOKit functionality

import Foundation
import MachOKit

// MARK: - Logging bridge to Rust

// Rust logging function (implemented in Rust, called from Swift)
@_silgen_name("rust_log_from_swift")
func rust_log_from_swift(_ level: Int32, _ message: UnsafePointer<CChar>?)

func logInfo(_ message: String) {
    //message.withCString { ptr in
    //    rust_log_from_swift(0, ptr)  // 0 = INFO
    //}
}

func logWarn(_ message: String) {
    message.withCString { ptr in
        rust_log_from_swift(1, ptr)  // 1 = WARN
    }
}

func logError(_ message: String) {
    message.withCString { ptr in
        rust_log_from_swift(2, ptr)  // 2 = ERROR
    }
}

func logDebug(_ message: String) {
    message.withCString { ptr in
        rust_log_from_swift(3, ptr)  // 3 = DEBUG
    }
}

// MARK: - Internal result storage

// Symbol info structure with extended Mach-O metadata
struct SymbolInfo {
    var name: String
    var address: UInt64
    var size: UInt64         // Calculated from function starts (0 if unknown)
    var type: UInt8           // 0=UNDF, 1=ABS, 2=SECT, 3=PBUD, 4=INDR
    var isExternal: Bool      // N_EXT flag
    var isPrivateExternal: Bool // N_PEXT flag
    var isWeakDef: Bool       // N_WEAK_DEF
    var isWeakRef: Bool       // N_WEAK_REF
    var isThumbDef: Bool      // N_ARM_THUMB_DEF (ARM only)
    var sectionIndex: UInt8   // Section number (n_sect)
    var libraryOrdinal: Int32 // Library ordinal for imports (Int32 from MachOKit)
    var source: UInt8         // 0=symtab, 1=export_trie
}

final class MachOParseResultInternal {
    var success: Bool = false
    var errorMessage: String?
    var is64Bit: Bool = false
    var cpuType: Int32 = 0
    var cpuSubtype: Int32 = 0
    var fileType: Int32 = 0
    var ncmds: UInt32 = 0
    var symbols: [SymbolInfo] = []
    var segments: [(name: String, vmaddr: UInt64, vmsize: UInt64, fileoff: UInt64, filesize: UInt64, maxprot: Int32, initprot: Int32, nsects: UInt32)] = []
    var sections: [(sectname: String, segname: String, addr: UInt64, size: UInt64, offset: UInt32, flags: UInt32)] = []
}

// Global storage for results
private var resultStorage: [Int: MachOParseResultInternal] = [:]
private var resultCounter: Int = 0
private let storageLock = NSLock()

private func allocateResult() -> (OpaquePointer, MachOParseResultInternal) {
    storageLock.lock()
    defer { storageLock.unlock() }
    
    resultCounter += 1
    let result = MachOParseResultInternal()
    resultStorage[resultCounter] = result
    
    let ptr = OpaquePointer(bitPattern: resultCounter)!
    return (ptr, result)
}

private func getResult(_ ptr: OpaquePointer?) -> MachOParseResultInternal? {
    guard let ptr = ptr else { return nil }
    let id = Int(bitPattern: ptr)
    storageLock.lock()
    defer { storageLock.unlock() }
    return resultStorage[id]
}

private func freeResult(_ ptr: OpaquePointer?) {
    guard let ptr = ptr else { return }
    let id = Int(bitPattern: ptr)
    storageLock.lock()
    defer { storageLock.unlock() }
    resultStorage.removeValue(forKey: id)
}

// MARK: - String helpers

private func allocateCString(_ string: String) -> UnsafeMutablePointer<CChar> {
    let utf8 = string.utf8CString
    let buffer = UnsafeMutablePointer<CChar>.allocate(capacity: utf8.count)
    for (i, char) in utf8.enumerated() {
        buffer[i] = char
    }
    return buffer
}

// MARK: - Dyld Shared Cache

private var loadedDyldCache: FullDyldCache?
// Cache for fast path-to-size lookup
private var dyldCacheModuleSizes: [String: UInt64] = [:]
private let dyldCacheLock = NSLock()

// Build the size cache when loading dyld cache
private func buildModuleSizeCache() {
    guard let cache = loadedDyldCache else { return }
    
    dyldCacheLock.lock()
    defer { dyldCacheLock.unlock() }
    
    dyldCacheModuleSizes.removeAll()
    
    for machO in cache.machOFiles() {
        let size = calculateModuleSizeFromFile(machO: machO)
        if size > 0 {
            dyldCacheModuleSizes[machO.imagePath] = size
        }
    }
    
    logInfo("Built module size cache with \(dyldCacheModuleSizes.count) entries")
}

@_cdecl("macho_load_dyld_cache")
public func macho_load_dyld_cache(_ path: UnsafePointer<CChar>?) -> Bool {
    guard let path = path else { return false }
    let pathString = String(cString: path)
    
    do {
        let url = URL(fileURLWithPath: pathString)
        loadedDyldCache = try FullDyldCache(url: url)
        buildModuleSizeCache()
        return true
    } catch {
        logError("Failed to load dyld cache: \(error)")
        return false
    }
}

@_cdecl("macho_load_system_dyld_cache")
public func macho_load_system_dyld_cache() -> Bool {
    // Method 1: Use dyld_shared_cache_file_path() API to get the current process's cache path
    // This is the most reliable method as it returns the actual cache being used by dyld
#if canImport(Darwin)
    if let pathPtr = dyld_shared_cache_file_path() {
        let path = String(cString: pathPtr)
        logInfo("dyld_shared_cache_file_path() returned: \(path)")
        
        let url = URL(fileURLWithPath: path)
        let exists = FileManager.default.fileExists(atPath: path)
        logInfo("File exists at path: \(exists)")
        
        if exists {
            do {
                loadedDyldCache = try FullDyldCache(url: url)
                logInfo("Successfully loaded dyld cache from: \(path)")
                buildModuleSizeCache()
                return true
            } catch {
                logError("Failed to load dyld cache from \(path): \(error)")
            }
        } else {
            // Check if the file is accessible
            let readable = FileManager.default.isReadableFile(atPath: path)
            logInfo("File readable: \(readable)")
            
            // Try to list parent directory
            let parentDir = url.deletingLastPathComponent().path
            if let contents = try? FileManager.default.contentsOfDirectory(atPath: parentDir) {
                logInfo("Parent directory contents: \(contents.prefix(10))")
            } else {
                logWarn("Cannot list parent directory: \(parentDir)")
            }
        }
    } else {
        logWarn("dyld_shared_cache_file_path() returned nil")
    }
#else
    logWarn("Darwin not available, skipping dyld API")
#endif
    
    logInfo("Falling back to path search...")
    
    // Method 2: Fallback to searching known paths
    // Standard paths + Jailbreak paths (dopamine, unc0ver, checkra1n, etc.)
    // Note: iOS 15+ uses split cache files in com.apple.dyld directory
    let cachePaths = [
        // iOS 15+ split cache (main file without extension)
        "/private/preboot/Cryptexes/OS/System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64e",
        "/private/preboot/Cryptexes/OS/System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64",
        // DriverKit cache
        "/private/preboot/Cryptexes/OS/System/DriverKit/System/Library/dyld/dyld_shared_cache_arm64e",
        "/private/preboot/Cryptexes/OS/System/DriverKit/System/Library/dyld/dyld_shared_cache_arm64",
        // Standard iOS/macOS paths
        "/System/Library/dyld/dyld_shared_cache_arm64e",
        "/System/Library/dyld/dyld_shared_cache_arm64",
        "/System/Cryptexes/OS/System/Library/dyld/dyld_shared_cache_arm64e",
        "/System/Cryptexes/OS/System/Library/dyld/dyld_shared_cache_arm64",
        "/var/db/dyld/dyld_shared_cache_arm64e",
        "/var/db/dyld/dyld_shared_cache_arm64",
        // Legacy iOS paths
        "/private/preboot/Cryptexes/OS/System/Library/dyld/dyld_shared_cache_arm64e",
        "/private/preboot/Cryptexes/OS/System/Library/dyld/dyld_shared_cache_arm64",
        // Jailbreak paths (dopamine, etc.)
        "/var/jb/System/Library/dyld/dyld_shared_cache_arm64e",
        "/var/jb/System/Library/dyld/dyld_shared_cache_arm64",
        // Legacy jailbreak paths
        "/var/LIB/dyld/dyld_shared_cache_arm64e",
        "/var/LIB/dyld/dyld_shared_cache_arm64",
    ]
    
    // Try each path
    for cachePath in cachePaths {
        let exists = FileManager.default.fileExists(atPath: cachePath)
        if !exists {
            continue
        }
        
        logInfo("Found cache at: \(cachePath)")
        let url = URL(fileURLWithPath: cachePath)
        do {
            loadedDyldCache = try FullDyldCache(url: url)
            logInfo("Successfully loaded dyld cache from: \(cachePath)")
            buildModuleSizeCache()
            return true
        } catch {
            logError("Failed to load \(cachePath): \(error)")
            continue
        }
    }
    
    // Try to find cache in /private/preboot for rootless jailbreaks
    let prebootPath = "/private/preboot"
    if FileManager.default.fileExists(atPath: prebootPath) {
        logInfo("Searching in /private/preboot for dyld cache...")
        if let prebootContents = try? FileManager.default.contentsOfDirectory(atPath: prebootPath) {
            for uuid in prebootContents {
                let possiblePaths = [
                    "\(prebootPath)/\(uuid)/procursus/System/Library/dyld/dyld_shared_cache_arm64e",
                    "\(prebootPath)/\(uuid)/procursus/System/Library/dyld/dyld_shared_cache_arm64",
                    "\(prebootPath)/\(uuid)/System/Library/dyld/dyld_shared_cache_arm64e",
                    "\(prebootPath)/\(uuid)/System/Library/dyld/dyld_shared_cache_arm64",
                    "\(prebootPath)/\(uuid)/System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64e",
                    "\(prebootPath)/\(uuid)/System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64",
                ]
                
                for path in possiblePaths {
                    if FileManager.default.fileExists(atPath: path) {
                        logInfo("Found cache at: \(path)")
                        let url = URL(fileURLWithPath: path)
                        do {
                            loadedDyldCache = try FullDyldCache(url: url)
                            logInfo("Successfully loaded dyld cache from: \(path)")
                            buildModuleSizeCache()
                            return true
                        } catch {
                            logError("Failed to load \(path): \(error)")
                            continue
                        }
                    }
                }
            }
        }
    }
    
    logError("Could not find or access any dyld cache file")
    return false
}

@_cdecl("macho_unload_dyld_cache")
public func macho_unload_dyld_cache() {
    loadedDyldCache = nil
}

// MARK: - Parse MachO File

@_cdecl("macho_parse_file")
public func macho_parse_file(_ path: UnsafePointer<CChar>?) -> OpaquePointer? {
    let (ptr, result) = allocateResult()
    
    guard let path = path else {
        result.success = false
        result.errorMessage = "Invalid path"
        return ptr
    }
    
    let pathString = String(cString: path)
    
    do {
        let url = URL(fileURLWithPath: pathString)
        let machO = try MachOFile(url: url)
        
        result.success = true
        result.is64Bit = machO.is64Bit
        result.cpuType = machO.header.cpuType?.rawValue ?? 0
        result.cpuSubtype = machO.header.cpuSubType?.rawValue ?? 0
        result.fileType = machO.header.fileType?.rawValue ?? 0
        result.ncmds = machO.header.ncmds
        
        // Parse symbols
        parseSymbols(from: machO, into: result)
        
        // Calculate function sizes from LC_FUNCTION_STARTS
        calculateFunctionSizes(from: machO, into: result)
        
        // Parse segments and sections
        parseSegments(from: machO, into: result)
        
    } catch {
        result.success = false
        result.errorMessage = "Failed to parse: \(error)"
    }
    
    return ptr
}

@_cdecl("macho_parse_from_dyld_cache")
public func macho_parse_from_dyld_cache(_ imagePath: UnsafePointer<CChar>?) -> OpaquePointer? {
    let (ptr, result) = allocateResult()
    
    guard let imagePath = imagePath else {
        result.success = false
        result.errorMessage = "Invalid image path"
        return ptr
    }
    
    guard let cache = loadedDyldCache else {
        result.success = false
        result.errorMessage = "Dyld cache not loaded"
        return ptr
    }
    
    let imagePathString = String(cString: imagePath)
    
    // Find MachO file matching the path
    var foundMachO: MachOFile? = nil
    for machO in cache.machOFiles() {
        if machO.imagePath == imagePathString {
            foundMachO = machO
            break
        }
    }
    
    guard let machO = foundMachO else {
        result.success = false
        result.errorMessage = "Image not found in cache: \(imagePathString)"
        return ptr
    }
    
    result.success = true
    result.is64Bit = machO.is64Bit
    result.cpuType = machO.header.cpuType?.rawValue ?? 0
    result.cpuSubtype = machO.header.cpuSubType?.rawValue ?? 0
    result.fileType = machO.header.fileType?.rawValue ?? 0
    result.ncmds = machO.header.ncmds
    
    // Parse symbols
    parseSymbols(from: machO, into: result)
    
    // Calculate function sizes from LC_FUNCTION_STARTS
    calculateFunctionSizes(from: machO, into: result)
    
    // Parse segments and sections
    parseSegments(from: machO, into: result)
    
    return ptr
}

// MARK: - Parse helpers

private func parseSymbols(from machO: MachOFile, into result: MachOParseResultInternal) {
    // Track already-added symbols to avoid duplicates
    var addedSymbols = Set<String>()
    
    // Get exported symbols from export trie (these have limited metadata)
    let exportedSymbols = machO.exportedSymbols
    for symbol in exportedSymbols {
        let addr = UInt64(symbol.offset ?? 0)
        let key = "\(symbol.name)_\(addr)"
        guard !addedSymbols.contains(key) else { continue }
        addedSymbols.insert(key)
        
        let info = SymbolInfo(
            name: symbol.name,
            address: addr,
            size: 0,  // Will be calculated from function starts
            type: 2,  // SECT (exported symbols are always defined)
            isExternal: true,
            isPrivateExternal: false,
            isWeakDef: false,
            isWeakRef: false,
            isThumbDef: false,
            sectionIndex: 0,
            libraryOrdinal: 0,
            source: 1  // export_trie
        )
        result.symbols.append(info)
    }
    
    // Get symbols from symbol table (64-bit)
    if machO.is64Bit {
        if let symbolsSeq = machO.symbols64 {
            for symbol in symbolsSeq {
                let key = "\(symbol.name)_\(symbol.offset)"
                guard !addedSymbols.contains(key) else { continue }
                addedSymbols.insert(key)
                
                let info = extractSymbolInfo(from: symbol)
                result.symbols.append(info)
            }
        }
    } else {
        // 32-bit symbols
        let symbolsSeq = machO.symbols
        for symbol in symbolsSeq {
            let key = "\(symbol.name)_\(symbol.offset)"
            guard !addedSymbols.contains(key) else { continue }
            addedSymbols.insert(key)
            
            let info = extractSymbolInfo(from: symbol)
            result.symbols.append(info)
        }
    }
}

private func extractSymbolInfo<T: SymbolProtocol>(from symbol: T) -> SymbolInfo {
    var symbolType: UInt8 = 0
    var isExternal = false
    var isPrivateExternal = false
    var isWeakDef = false
    var isWeakRef = false
    var isThumbDef = false
    var sectionIndex: UInt8 = 0
    var libraryOrdinal: Int32 = 0
    
    // Get type from nlist flags
    if let flags = symbol.nlist.flags {
        if let type = flags.type {
            switch type {
            case .undf: symbolType = 0
            case .abs: symbolType = 1
            case .sect: symbolType = 2
            case .pbud: symbolType = 3
            case .indr: symbolType = 4
            }
        }
        
        // Check N_EXT (external symbol)
        isExternal = flags.contains(.ext)
        // Check N_PEXT (private external symbol)
        isPrivateExternal = flags.contains(.pext)
    }
    
    // Get section index
    if let sectNum = symbol.nlist.sectionNumber {
        sectionIndex = UInt8(sectNum)
    }
    
    // Get description flags
    if let desc = symbol.nlist.symbolDescription {
        isWeakDef = desc.contains(.weak_def)
        isWeakRef = desc.contains(.weak_ref)
        isThumbDef = desc.contains(.arm_thumb_def)
        libraryOrdinal = desc.libraryOrdinal
    }
    
    return SymbolInfo(
        name: symbol.name,
        address: UInt64(symbol.offset),
        size: 0,  // Will be calculated from function starts
        type: symbolType,
        isExternal: isExternal,
        isPrivateExternal: isPrivateExternal,
        isWeakDef: isWeakDef,
        isWeakRef: isWeakRef,
        isThumbDef: isThumbDef,
        sectionIndex: sectionIndex,
        libraryOrdinal: libraryOrdinal,
        source: 0  // symtab
    )
}

/// Calculate function sizes from LC_FUNCTION_STARTS
/// This uses the difference between consecutive function start addresses
private func calculateFunctionSizes(from machO: MachOFile, into result: MachOParseResultInternal) {
    guard let functionStarts = machO.functionStarts else {
        return
    }
    
    // Collect all function start offsets and sort them
    let offsets = Array(functionStarts).map { $0.offset }.sorted()
    guard !offsets.isEmpty else { return }
    
    // Build a dictionary of offset -> size
    var sizeMap: [UInt64: UInt64] = [:]
    for i in 0..<offsets.count - 1 {
        let currentOffset = UInt64(offsets[i])
        let nextOffset = UInt64(offsets[i + 1])
        sizeMap[currentOffset] = nextOffset - currentOffset
    }
    
    // For the last function, we can't determine size from function starts alone
    // Leave it as 0 (unknown)
    
    // Update symbol sizes
    for i in 0..<result.symbols.count {
        let addr = result.symbols[i].address
        if let size = sizeMap[addr] {
            result.symbols[i].size = size
        }
    }
}

private func parseSegments(from machO: MachOFile, into result: MachOParseResultInternal) {
    for cmd in machO.loadCommands {
        switch cmd {
        case .segment(let segment):
            result.segments.append((
                name: segment.segmentName,
                vmaddr: UInt64(segment.vmaddr),
                vmsize: UInt64(segment.vmsize),
                fileoff: UInt64(segment.fileoff),
                filesize: UInt64(segment.filesize),
                maxprot: segment.maxprot,
                initprot: segment.initprot,
                nsects: segment.nsects
            ))
            
            for section in segment.sections(in: machO) {
                result.sections.append((
                    sectname: section.sectionName,
                    segname: section.segmentName,
                    addr: UInt64(section.address),
                    size: UInt64(section.size),
                    offset: UInt32(section.offset),
                    flags: section.flags.rawValue
                ))
            }
            
        case .segment64(let segment):
            result.segments.append((
                name: segment.segmentName,
                vmaddr: segment.vmaddr,
                vmsize: segment.vmsize,
                fileoff: segment.fileoff,
                filesize: segment.filesize,
                maxprot: segment.maxprot,
                initprot: segment.initprot,
                nsects: segment.nsects
            ))
            
            for section in segment.sections(in: machO) {
                result.sections.append((
                    sectname: section.sectionName,
                    segname: section.segmentName,
                    addr: UInt64(section.address),
                    size: UInt64(section.size),
                    offset: UInt32(section.offset),
                    flags: section.flags.rawValue
                ))
            }
            
        default:
            break
        }
    }
}

// MARK: - Result accessors

@_cdecl("macho_result_success")
public func macho_result_success(_ result: OpaquePointer?) -> Bool {
    return getResult(result)?.success ?? false
}

@_cdecl("macho_result_error_message")
public func macho_result_error_message(_ result: OpaquePointer?) -> UnsafeMutablePointer<CChar>? {
    guard let msg = getResult(result)?.errorMessage else { return nil }
    return allocateCString(msg)
}

@_cdecl("macho_result_is_64bit")
public func macho_result_is_64bit(_ result: OpaquePointer?) -> Bool {
    return getResult(result)?.is64Bit ?? false
}

@_cdecl("macho_result_cpu_type")
public func macho_result_cpu_type(_ result: OpaquePointer?) -> Int32 {
    return getResult(result)?.cpuType ?? 0
}

@_cdecl("macho_result_cpu_subtype")
public func macho_result_cpu_subtype(_ result: OpaquePointer?) -> Int32 {
    return getResult(result)?.cpuSubtype ?? 0
}

@_cdecl("macho_result_file_type")
public func macho_result_file_type(_ result: OpaquePointer?) -> Int32 {
    return getResult(result)?.fileType ?? 0
}

@_cdecl("macho_result_ncmds")
public func macho_result_ncmds(_ result: OpaquePointer?) -> UInt32 {
    return getResult(result)?.ncmds ?? 0
}

@_cdecl("macho_result_symbol_count")
public func macho_result_symbol_count(_ result: OpaquePointer?) -> UInt64 {
    return UInt64(getResult(result)?.symbols.count ?? 0)
}

@_cdecl("macho_result_symbol_name")
public func macho_result_symbol_name(_ result: OpaquePointer?, _ index: UInt64) -> UnsafeMutablePointer<CChar>? {
    guard let symbols = getResult(result)?.symbols,
          Int(index) < symbols.count else { return nil }
    return allocateCString(symbols[Int(index)].name)
}

@_cdecl("macho_result_symbol_address")
public func macho_result_symbol_address(_ result: OpaquePointer?, _ index: UInt64) -> UInt64 {
    guard let symbols = getResult(result)?.symbols,
          Int(index) < symbols.count else { return 0 }
    return symbols[Int(index)].address
}

@_cdecl("macho_result_symbol_size")
public func macho_result_symbol_size(_ result: OpaquePointer?, _ index: UInt64) -> UInt64 {
    guard let symbols = getResult(result)?.symbols,
          Int(index) < symbols.count else { return 0 }
    return symbols[Int(index)].size
}

@_cdecl("macho_result_symbol_type")
public func macho_result_symbol_type(_ result: OpaquePointer?, _ index: UInt64) -> UInt8 {
    guard let symbols = getResult(result)?.symbols,
          Int(index) < symbols.count else { return 0 }
    return symbols[Int(index)].type
}

@_cdecl("macho_result_symbol_is_external")
public func macho_result_symbol_is_external(_ result: OpaquePointer?, _ index: UInt64) -> Bool {
    guard let symbols = getResult(result)?.symbols,
          Int(index) < symbols.count else { return false }
    return symbols[Int(index)].isExternal
}

@_cdecl("macho_result_symbol_is_private_external")
public func macho_result_symbol_is_private_external(_ result: OpaquePointer?, _ index: UInt64) -> Bool {
    guard let symbols = getResult(result)?.symbols,
          Int(index) < symbols.count else { return false }
    return symbols[Int(index)].isPrivateExternal
}

@_cdecl("macho_result_symbol_is_weak_def")
public func macho_result_symbol_is_weak_def(_ result: OpaquePointer?, _ index: UInt64) -> Bool {
    guard let symbols = getResult(result)?.symbols,
          Int(index) < symbols.count else { return false }
    return symbols[Int(index)].isWeakDef
}

@_cdecl("macho_result_symbol_is_weak_ref")
public func macho_result_symbol_is_weak_ref(_ result: OpaquePointer?, _ index: UInt64) -> Bool {
    guard let symbols = getResult(result)?.symbols,
          Int(index) < symbols.count else { return false }
    return symbols[Int(index)].isWeakRef
}

@_cdecl("macho_result_symbol_is_thumb")
public func macho_result_symbol_is_thumb(_ result: OpaquePointer?, _ index: UInt64) -> Bool {
    guard let symbols = getResult(result)?.symbols,
          Int(index) < symbols.count else { return false }
    return symbols[Int(index)].isThumbDef
}

@_cdecl("macho_result_symbol_section_index")
public func macho_result_symbol_section_index(_ result: OpaquePointer?, _ index: UInt64) -> UInt8 {
    guard let symbols = getResult(result)?.symbols,
          Int(index) < symbols.count else { return 0 }
    return symbols[Int(index)].sectionIndex
}

@_cdecl("macho_result_symbol_library_ordinal")
public func macho_result_symbol_library_ordinal(_ result: OpaquePointer?, _ index: UInt64) -> Int32 {
    guard let symbols = getResult(result)?.symbols,
          Int(index) < symbols.count else { return 0 }
    return symbols[Int(index)].libraryOrdinal
}

@_cdecl("macho_result_symbol_source")
public func macho_result_symbol_source(_ result: OpaquePointer?, _ index: UInt64) -> UInt8 {
    guard let symbols = getResult(result)?.symbols,
          Int(index) < symbols.count else { return 0 }
    return symbols[Int(index)].source
}

@_cdecl("macho_result_segment_count")
public func macho_result_segment_count(_ result: OpaquePointer?) -> UInt64 {
    return UInt64(getResult(result)?.segments.count ?? 0)
}

@_cdecl("macho_result_segment_name")
public func macho_result_segment_name(_ result: OpaquePointer?, _ index: UInt64) -> UnsafeMutablePointer<CChar>? {
    guard let segments = getResult(result)?.segments,
          Int(index) < segments.count else { return nil }
    return allocateCString(segments[Int(index)].name)
}

@_cdecl("macho_result_segment_vmaddr")
public func macho_result_segment_vmaddr(_ result: OpaquePointer?, _ index: UInt64) -> UInt64 {
    guard let segments = getResult(result)?.segments,
          Int(index) < segments.count else { return 0 }
    return segments[Int(index)].vmaddr
}

@_cdecl("macho_result_segment_vmsize")
public func macho_result_segment_vmsize(_ result: OpaquePointer?, _ index: UInt64) -> UInt64 {
    guard let segments = getResult(result)?.segments,
          Int(index) < segments.count else { return 0 }
    return segments[Int(index)].vmsize
}

@_cdecl("macho_result_section_count")
public func macho_result_section_count(_ result: OpaquePointer?) -> UInt64 {
    return UInt64(getResult(result)?.sections.count ?? 0)
}

@_cdecl("macho_result_section_name")
public func macho_result_section_name(_ result: OpaquePointer?, _ index: UInt64) -> UnsafeMutablePointer<CChar>? {
    guard let sections = getResult(result)?.sections,
          Int(index) < sections.count else { return nil }
    return allocateCString(sections[Int(index)].sectname)
}

@_cdecl("macho_result_section_segname")
public func macho_result_section_segname(_ result: OpaquePointer?, _ index: UInt64) -> UnsafeMutablePointer<CChar>? {
    guard let sections = getResult(result)?.sections,
          Int(index) < sections.count else { return nil }
    return allocateCString(sections[Int(index)].segname)
}

@_cdecl("macho_result_section_addr")
public func macho_result_section_addr(_ result: OpaquePointer?, _ index: UInt64) -> UInt64 {
    guard let sections = getResult(result)?.sections,
          Int(index) < sections.count else { return 0 }
    return sections[Int(index)].addr
}

@_cdecl("macho_result_section_size")
public func macho_result_section_size(_ result: OpaquePointer?, _ index: UInt64) -> UInt64 {
    guard let sections = getResult(result)?.sections,
          Int(index) < sections.count else { return 0 }
    return sections[Int(index)].size
}

// MARK: - Free functions

@_cdecl("macho_free_result")
public func macho_free_result(_ result: OpaquePointer?) {
    freeResult(result)
}

@_cdecl("macho_free_string")
public func macho_free_string(_ str: UnsafeMutablePointer<CChar>?) {
    str?.deallocate()
}

// MARK: - List dyld cache images

@_cdecl("macho_get_dyld_cache_image_count")
public func macho_get_dyld_cache_image_count() -> UInt64 {
    guard let cache = loadedDyldCache,
          let imageInfos = cache.imageInfos else { return 0 }
    return UInt64(imageInfos.count)
}

@_cdecl("macho_get_dyld_cache_image_path")
public func macho_get_dyld_cache_image_path(_ index: UInt64) -> UnsafeMutablePointer<CChar>? {
    guard let cache = loadedDyldCache,
          let imageInfos = cache.imageInfos else { return nil }
    
    var idx = 0
    for imageInfo in imageInfos {
        if idx == Int(index) {
            if let path = imageInfo.path(in: cache) {
                return allocateCString(path)
            }
            return nil
        }
        idx += 1
    }
    return nil
}

// MARK: - Module Size from dyld (for current process)

/// Get module size by name using dyld APIs (for current process only)
/// Returns the sum of all segment vmsizes
@_cdecl("macho_get_module_size_by_name")
public func macho_get_module_size_by_name(_ name: UnsafePointer<CChar>?) -> UInt64 {
#if canImport(Darwin)
    guard let name = name else { return 0 }
    let nameString = String(cString: name)
    
    // Try to find the MachOImage by name
    if let image = MachOImage(name: nameString) {
        return calculateModuleSize(image: image)
    }
    
    // Try exact path match
    let indices = 0..<_dyld_image_count()
    for index in indices {
        guard let pathC = _dyld_get_image_name(index) else { continue }
        let path = String(cString: pathC)
        
        if path == nameString || path.hasSuffix("/\(nameString)") {
            if let mh = _dyld_get_image_header(index) {
                let image = MachOImage(ptr: mh)
                return calculateModuleSize(image: image)
            }
        }
    }
    
    return 0
#else
    return 0
#endif
}

/// Get module size by base address using dyld APIs (for current process only)
/// Returns the sum of all segment vmsizes
@_cdecl("macho_get_module_size_by_address")
public func macho_get_module_size_by_address(_ address: UInt64) -> UInt64 {
#if canImport(Darwin)
    guard let header = UnsafeRawPointer(bitPattern: UInt(address)) else { return 0 }
    
    // Validate that this looks like a mach header
    let mh = header.assumingMemoryBound(to: mach_header.self)
    let magic = mh.pointee.magic
    guard magic == MH_MAGIC || magic == MH_MAGIC_64 else { return 0 }
    
    let image = MachOImage(ptr: mh)
    return calculateModuleSize(image: image)
#else
    return 0
#endif
}

/// Get module size from dyld cache by path
@_cdecl("macho_get_module_size_from_cache")
public func macho_get_module_size_from_cache(_ imagePath: UnsafePointer<CChar>?) -> UInt64 {
    guard let imagePath = imagePath else { return 0 }
    guard loadedDyldCache != nil else { return 0 }
    
    let imagePathString = String(cString: imagePath)
    
    // O(1) lookup from pre-built dictionary
    return dyldCacheModuleSizes[imagePathString] ?? 0
}

#if canImport(Darwin)
private func calculateModuleSize(image: MachOImage) -> UInt64 {    
    var textSize: UInt64 = 0
    var dataSize: UInt64 = 0
    
    if image.is64Bit {
        for segment in image.segments64 {
            let name = segment.segmentName
            if name == "__TEXT" {
                textSize = segment.vmsize
            } else if name.hasPrefix("__DATA") {
                dataSize += segment.vmsize
            }
        }
    } else {
        for segment in image.segments32 {
            let name = segment.segmentName
            if name == "__TEXT" {
                textSize = UInt64(segment.vmsize)
            } else if name.hasPrefix("__DATA") {
                dataSize += UInt64(segment.vmsize)
            }
        }
    }
    
    if textSize > 0 {
        return textSize
    }
    
    // Fallback to data segments if no __TEXT
    return dataSize
}
#endif

private func calculateModuleSizeFromFile(machO: MachOFile) -> UInt64 {
    var textSize: UInt64 = 0
    var dataSize: UInt64 = 0
    
    for cmd in machO.loadCommands {
        switch cmd {
        case .segment(let segment):
            let name = segment.segmentName
            if name == "__TEXT" {
                textSize = UInt64(segment.vmsize)
            } else if name.hasPrefix("__DATA") {
                dataSize += UInt64(segment.vmsize)
            }
        case .segment64(let segment):
            let name = segment.segmentName
            if name == "__TEXT" {
                textSize = segment.vmsize
            } else if name.hasPrefix("__DATA") {
                dataSize += segment.vmsize
            }
        default:
            break
        }
    }
    
    if textSize > 0 {
        return textSize
    }
    
    // Fallback to data segments if no __TEXT
    return dataSize
}

// MARK: - Enumerate loaded images (for current process)

/// Get the count of loaded images using dyld APIs
@_cdecl("macho_get_loaded_image_count")
public func macho_get_loaded_image_count() -> UInt32 {
#if canImport(Darwin)
    return _dyld_image_count()
#else
    return 0
#endif
}

/// Get image path at index using dyld APIs
@_cdecl("macho_get_loaded_image_path")
public func macho_get_loaded_image_path(_ index: UInt32) -> UnsafeMutablePointer<CChar>? {
#if canImport(Darwin)
    guard let pathC = _dyld_get_image_name(index) else { return nil }
    let path = String(cString: pathC)
    return allocateCString(path)
#else
    return nil
#endif
}

/// Get image base address at index using dyld APIs
@_cdecl("macho_get_loaded_image_base")
public func macho_get_loaded_image_base(_ index: UInt32) -> UInt64 {
#if canImport(Darwin)
    guard let mh = _dyld_get_image_header(index) else { return 0 }
    return UInt64(UInt(bitPattern: mh))
#else
    return 0
#endif
}

/// Get image size at index using dyld APIs
@_cdecl("macho_get_loaded_image_size")
public func macho_get_loaded_image_size(_ index: UInt32) -> UInt64 {
#if canImport(Darwin)
    guard let mh = _dyld_get_image_header(index) else { return 0 }
    let image = MachOImage(ptr: mh)
    return calculateModuleSize(image: image)
#else
    return 0
#endif
}

/// Get image vmaddr slide at index using dyld APIs
@_cdecl("macho_get_loaded_image_slide")
public func macho_get_loaded_image_slide(_ index: UInt32) -> Int64 {
#if canImport(Darwin)
    return Int64(_dyld_get_image_vmaddr_slide(index))
#else
    return 0
#endif
}

```

`src/server/src/util.rs`:

```rs
use crate::native_bridge;
use capstone::prelude::*;
use libc::{self, c_char};
use regex::Regex;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::ffi::CString;
use std::num::ParseIntError;
use std::path::Path;
use std::slice;
use std::str;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct FileItem {
    item_type: String,
    name: String,
    size: Option<i64>,
    last_opened: Option<i64>,
    children: Option<Vec<FileItem>>,
}

pub fn read_memory_64(pid: i32, address: u64) -> Result<u64, String> {
    let mut buffer = [0u8; 8];
    native_bridge::read_process_memory(pid, address as *mut libc::c_void, 8, &mut buffer).map_err(
        |e| {
            format!(
                "Failed to read 64-bit memory at address {:#x}: {}",
                address, e
            )
        },
    )?;
    Ok(u64::from_le_bytes(buffer))
}

pub fn _read_memory_32(pid: i32, address: u32) -> Result<u32, String> {
    let mut buffer = [0u8; 4];
    native_bridge::read_process_memory(pid, address as *mut libc::c_void, 4, &mut buffer).map_err(
        |e| {
            format!(
                "Failed to read 32-bit memory at address {:#x}: {}",
                address, e
            )
        },
    )?;
    Ok(u32::from_le_bytes(buffer))
}

pub fn _evaluate_expression(expr: &str) -> Result<isize, String> {
    let re = Regex::new(r"(\d+)\s*([+\-*/])\s*(\d+)").unwrap();
    if let Some(caps) = re.captures(expr) {
        let a: isize = caps[1]
            .parse()
            .map_err(|_| "Invalid number in expression".to_string())?;
        let b: isize = caps[3]
            .parse()
            .map_err(|_| "Invalid number in expression".to_string())?;
        match &caps[2] {
            "+" => Ok(a + b),
            "-" => Ok(a - b),
            "*" => Ok(a * b),
            "/" => Ok(a / b),
            _ => Err("Unsupported operation".to_string()),
        }
    } else {
        expr.parse().map_err(|_| "Invalid expression".to_string())
    }
}

pub fn resolve_nested_address(
    pid: i32,
    nested_addr: &str,
    modules: &[serde_json::Value],
) -> Result<u64, String> {
    // Check if it's the arrow format: "base → [0x10] → [0x20]"
    if nested_addr.contains(" → ") {
        return resolve_arrow_format_address(pid, nested_addr, modules);
    }
    
    // Original nested bracket format: [[base+0x10]+0x20]
    let re = Regex::new(r"(\[)|(\])|([^\[\]]+)").map_err(|e| format!("Regex error: {}", e))?;
    let mut stack = Vec::new();
    let mut current_expr = String::new();

    for cap in re.captures_iter(nested_addr) {
        if cap.get(1).is_some() {
            if !current_expr.is_empty() {
                stack.push(current_expr);
                current_expr = String::new();
            }
            current_expr.push('[');
        } else if cap.get(2).is_some() {
            if !current_expr.is_empty() {
                let inner_value = resolve_single_level_address(&current_expr, modules)?;
                let memory_value = read_memory_64(pid, inner_value)?;
                if let Some(mut prev_expr) = stack.pop() {
                    prev_expr.push_str(&format!("0x{:X}", memory_value));
                    current_expr = prev_expr;
                } else {
                    current_expr = format!("0x{:X}", memory_value);
                }
            }
            current_expr.push(']');
        } else if let Some(m) = cap.get(3) {
            current_expr.push_str(m.as_str());
        }
    }

    resolve_single_level_address(&current_expr, modules)
}

/// Resolve arrow format pointer chain: "base → [0x10] → [0x20]"
/// This format means: read memory at (base + 0x10), then read memory at (result + 0x20)
fn resolve_arrow_format_address(
    pid: i32,
    addr: &str,
    modules: &[serde_json::Value],
) -> Result<u64, String> {
    let parts: Vec<&str> = addr.split(" → ").collect();
    
    if parts.is_empty() {
        return Err("Empty pointer chain".to_string());
    }
    
    // First part is the base address (e.g., "Tutorial-x86_64.exe+0x34eca0")
    let base_str = parts[0].trim();
    let mut current_addr = resolve_single_level_address(base_str, modules)?;
    
    // For each subsequent part, extract offset and dereference
    for i in 1..parts.len() {
        let part = parts[i].trim();
        
        // Extract offset from format like "[0x10]" or "[+0x10]"
        let offset_str = part
            .trim_start_matches('[')
            .trim_end_matches(']')
            .trim_start_matches('+')
            .trim();
        
        // Read memory at current address to get pointer value
        let ptr_value = read_memory_64(pid, current_addr)?;
        
        // Parse the offset
        let offset = parse_number(offset_str)?;
        
        // Add offset to pointer value
        current_addr = ptr_value.wrapping_add(offset);
    }
    
    Ok(current_addr)
}

pub fn resolve_single_level_address(
    addr: &str,
    modules: &[serde_json::Value],
) -> Result<u64, String> {
    let resolved_addr = preemptive_module_resolution(addr, modules)?;

    let re = Regex::new(r"(?:([+\-*])?\s*)(0x[\da-fA-F]+|\d+)")
        .map_err(|e| format!("Regex error: {}", e))?;

    let mut current_address: u64 = 0;
    let mut first_item = true;

    for cap in re.captures_iter(&resolved_addr) {
        let op = cap.get(1).map(|m| m.as_str());
        let value_str = cap.get(2).unwrap().as_str();
        let value = parse_number(value_str)?;

        if first_item {
            current_address = value;
            first_item = false;
        } else if let Some(operator) = op {
            match operator {
                "+" => current_address = current_address.wrapping_add(value),
                "-" => current_address = current_address.wrapping_sub(value),
                "*" => current_address = current_address.wrapping_mul(value),
                _ => return Err(format!("Invalid operation: {}", operator)),
            }
        } else {
            return Err("Expected operator, but none found".to_string());
        }
    }

    if first_item {
        current_address = parse_number(&resolved_addr)?;
    }

    Ok(current_address)
}

fn preemptive_module_resolution(
    addr: &str,
    modules: &[serde_json::Value],
) -> Result<String, String> {
    let mut resolved = String::from(addr);
    for module in modules {
        if let (Some(name), Some(base)) = (module["modulename"].as_str(), module["base"].as_u64()) {
            let path = Path::new(name);
            if let Some(file_name) = path.file_name() {
                let file_name_str = file_name.to_string_lossy();
                let escaped_name = regex::escape(&file_name_str);
                // Use case-insensitive matching for module names
                let re = Regex::new(&format!(r"(?i)\b{}\b", escaped_name))
                    .map_err(|e| format!("Regex error: {}", e))?;

                resolved = re
                    .replace_all(&resolved, |caps: &regex::Captures| {
                        let matched = caps.get(0).unwrap().as_str();
                        if resolved[caps.get(0).unwrap().end()..].starts_with('.') {
                            matched.to_string()
                        } else {
                            format!("0x{:X}", base)
                        }
                    })
                    .to_string();
            }
        }
    }
    Ok(resolved)
}

fn parse_number(s: &str) -> Result<u64, String> {
    let s = s.trim();
    // Handle both lowercase 0x and uppercase 0X hex prefix
    if s.starts_with("0x") || s.starts_with("0X") {
        u64::from_str_radix(&s[2..], 16)
    } else {
        s.parse::<u64>()
    }
    .map_err(|e: ParseIntError| format!("Invalid number '{}': {}", s, e))
}

pub fn resolve_symbolic_address(
    pid: i32,
    symbolic_addr: &str,
    modules: &[serde_json::Value],
) -> Result<usize, String> {
    let resolved = resolve_nested_address(pid, symbolic_addr, modules)?;
    Ok(resolved as usize)
}
pub fn parse_directory_structure(raw_data: &str) -> Vec<FileItem> {
    let mut root_items = Vec::new();
    let mut stack: Vec<*mut FileItem> = Vec::new();

    for line in raw_data.lines() {
        let indent = line.chars().take_while(|&c| c == ' ').count() / 2;
        let content = line.trim_start();

        if let Some((item_type, rest)) = content.split_once(':') {
            let new_item = match item_type {
                "dir" => FileItem {
                    item_type: "directory".to_string(),
                    name: rest.to_string(),
                    size: None,
                    last_opened: None,
                    children: None,
                },
                "file" => {
                    let parts: Vec<&str> = rest.split(',').collect();
                    if parts.len() == 3 {
                        FileItem {
                            item_type: "file".to_string(),
                            name: parts[0].to_string(),
                            size: parts[1].parse().ok(),
                            last_opened: parts[2].parse().ok(),
                            children: None,
                        }
                    } else {
                        continue;
                    }
                }
                _ => continue,
            };

            while stack.len() > indent {
                stack.pop();
            }

            if stack.is_empty() {
                root_items.push(new_item);

                if item_type == "dir" {
                    let last_ptr = root_items.last_mut().unwrap() as *mut FileItem;
                    stack.push(last_ptr);
                }
            } else {
                unsafe {
                    let parent = stack.last_mut().unwrap();
                    if let Some(children) = &mut (**parent).children {
                        children.push(new_item);
                    } else {
                        (**parent).children = Some(vec![new_item]);
                    }

                    if item_type == "dir" {
                        let last_ptr = (**parent).children.as_mut().unwrap().last_mut().unwrap()
                            as *mut FileItem;
                        stack.push(last_ptr);
                    }
                }
            }
        }
    }

    root_items
}

pub fn get_cache_directory(pid: i32) -> String {
    let result = native_bridge::get_application_info(pid);
    let parsed_result: Value = serde_json::from_str(&result.unwrap()).unwrap();
    let target_os = env!("TARGET_OS");
    if target_os == "ios" {
        parsed_result["CachesDirectory"]
            .to_string()
            .replace("\"", "")
    } else {
        "".to_string()
    }
}

/// Internal disassemble function for Rust code
pub fn disassemble_internal(bytecode: *const u8, length: usize, address: u64, arch: &str) -> String {
    let bytes = unsafe { slice::from_raw_parts(bytecode, length) };
    
    let cs = match arch {
        "x86_64" => {
            Capstone::new()
                .x86()
                .mode(arch::x86::ArchMode::Mode64)
                .detail(true)
                .build()
                .expect("Failed to create Capstone object for x86_64")
        },
        "arm64" | "aarch64" => {
            Capstone::new()
                .arm64()
                .mode(arch::arm64::ArchMode::Arm)
                .detail(true)
                .build()
                .expect("Failed to create Capstone object for ARM64")
        },
        _ => {
            return format!("Unsupported architecture: {}", arch);
        }
    };

    let instructions = match cs.disasm_all(bytes, address) {
        Ok(instructions) => instructions,
        Err(e) => return format!("Failed to disassemble: {}", e),
    };
    
    let mut result = String::new();
    let mut actual_bytes_covered = 0usize;

    for i in instructions.iter() {
        let mnemonic = i.mnemonic().unwrap_or("");
        let op_str = i.op_str().unwrap_or("");
        
        // Format the raw bytes as hex string
        let instruction_bytes = i.bytes();
        let bytes_hex = instruction_bytes.iter()
            .map(|b| format!("{:02X}", b))
            .collect::<Vec<String>>()
            .join(" ");
        
        // Track actual bytes covered by instructions
        actual_bytes_covered += instruction_bytes.len();
        
        // Format: address|bytes|mnemonic operands
        result.push_str(&format!("{:#x}|{}|{} {}\n", i.address(), bytes_hex, mnemonic, op_str));
    }

    // Add metadata about actual vs requested size at the end
    result.push_str(&format!("__METADATA__|actual_size:{}|requested_size:{}\n", actual_bytes_covered, length));

    result
}

/// FFI function to disassemble bytecode from C++ with a base address
/// This version takes the actual PC address for correct relative address calculation
/// Returns a C string that must be freed with free_string()
#[no_mangle]
pub extern "C" fn disassemble_at_address(bytecode: *const u8, length: usize, address: u64) -> *mut c_char {
    if bytecode.is_null() || length == 0 {
        return std::ptr::null_mut();
    }

    let bytes = unsafe { slice::from_raw_parts(bytecode, length) };
    
    // Default to ARM64 for iOS/macOS
    let cs = match Capstone::new()
        .arm64()
        .mode(arch::arm64::ArchMode::Arm)
        .detail(true)
        .build()
    {
        Ok(cs) => cs,
        Err(_) => return std::ptr::null_mut(),
    };

    let instructions = match cs.disasm_all(bytes, address) {
        Ok(instructions) => instructions,
        Err(_) => return std::ptr::null_mut(),
    };

    // Get the first instruction's mnemonic and operands
    if let Some(instr) = instructions.iter().next() {
        let mnemonic = instr.mnemonic().unwrap_or("");
        let op_str = instr.op_str().unwrap_or("");
        let result = if op_str.is_empty() {
            mnemonic.to_string()
        } else {
            format!("{} {}", mnemonic, op_str)
        };
        
        match CString::new(result) {
            Ok(c_str) => c_str.into_raw(),
            Err(_) => std::ptr::null_mut(),
        }
    } else {
        std::ptr::null_mut()
    }
}

/// FFI function to disassemble bytecode from C++ (legacy, uses address 0)
/// Returns a C string that must be freed with free_string()
#[no_mangle]
pub extern "C" fn disassemble(bytecode: *const u8, length: usize) -> *mut c_char {
    disassemble_at_address(bytecode, length, 0)
}

/// FFI function to free a string allocated by Rust
#[no_mangle]
pub extern "C" fn free_string(s: *mut c_char) {
    if !s.is_null() {
        unsafe {
            let _ = CString::from_raw(s);
        }
    }
}

```

`src/server/src/wasm_bridge.rs`:

```rs
//! WASM Bridge Module
//! 
//! This module provides a WebSocket server for browser WASM instances
//! to connect and handle memory read/write operations.
//! 
//! Inspired by Cetus (https://github.com/Qwokka/cetus), this module supports:
//! - Initial memory snapshot storage for comparison/analysis
//! - Symbol extraction from WASM instrumentation
//! - Multiple memory regions (live heap + initial snapshot)

#![allow(dead_code)]

use futures_util::{SinkExt, StreamExt};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};
use std::sync::{Arc, OnceLock};
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::{mpsc, oneshot, RwLock};
use tokio_tungstenite::{accept_async, tungstenite::Message};

/// Global WASM bridge instance
static WASM_BRIDGE: OnceLock<Arc<WasmBridge>> = OnceLock::new();

/// Request ID counter for tracking responses
static REQUEST_ID: AtomicU64 = AtomicU64::new(1);

/// WASM signature received from browser (64 bytes)
static WASM_SIGNATURE: OnceLock<RwLock<Option<Vec<u8>>>> = OnceLock::new();

/// WASM heap size received from browser
static WASM_HEAP_SIZE: AtomicUsize = AtomicUsize::new(0);

/// Base address where WASM signature was found in native process memory
static WASM_BASE_ADDRESS: AtomicUsize = AtomicUsize::new(0);

// ============================================================================
// Cetus-style Initial Snapshot and Symbol Storage
// ============================================================================

/// Initial memory snapshot taken at WASM instance initialization
/// This allows comparison between initial and current state (Cetus-style)
static WASM_INITIAL_SNAPSHOT: OnceLock<RwLock<Option<WasmMemorySnapshot>>> = OnceLock::new();

/// WASM symbols extracted from instrumentation (Cetus-style)
static WASM_SYMBOLS: OnceLock<RwLock<Vec<WasmSymbol>>> = OnceLock::new();

/// WASM module info for the instrumented module
static WASM_MODULE_INFO: OnceLock<RwLock<Option<WasmModuleInfo>>> = OnceLock::new();

/// Represents a memory snapshot of the WASM heap
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WasmMemorySnapshot {
    /// The snapshot data
    pub data: Vec<u8>,
    /// Size of the snapshot
    pub size: usize,
    /// Timestamp when snapshot was taken
    pub timestamp: u64,
    /// Description/label for this snapshot
    pub label: String,
}

/// WASM symbol information (from instrumentation like Cetus)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WasmSymbol {
    /// Function index in the WASM module
    pub index: u32,
    /// Symbol name (e.g., "_wp_config0", "_wp_read", "_wp_write")
    pub name: String,
    /// Symbol type (function, global, etc.)
    pub symbol_type: WasmSymbolType,
    /// Address/offset in the module
    pub address: usize,
    /// Size of the symbol (for functions, this is the code size)
    pub size: usize,
}

/// Types of WASM symbols
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum WasmSymbolType {
    Function,
    Global,
    Table,
    Memory,
    Export,
    Import,
}

/// WASM module information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WasmModuleInfo {
    /// Module name/identifier
    pub name: String,
    /// Base address (always 0 for WASM linear memory)
    pub base: usize,
    /// Size of the module's linear memory
    pub size: usize,
    /// Size of the WASM binary (code region)
    pub code_size: usize,
    /// Whether the module has been instrumented
    pub instrumented: bool,
    /// Number of watchpoints configured
    pub watchpoint_count: usize,
    /// Whether the WASM binary has been captured
    pub has_binary: bool,
    /// Additional metadata
    pub metadata: HashMap<String, String>,
}

/// Memory region descriptor for WASM mode
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WasmMemoryRegion {
    /// Region name/identifier
    pub name: String,
    /// Start address
    pub start: usize,
    /// End address
    pub end: usize,
    /// Protection flags (e.g., "rw-")
    pub protection: String,
    /// Region type
    pub region_type: WasmRegionType,
}

/// Types of WASM memory regions
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum WasmRegionType {
    /// Live linear memory (heap)
    LinearMemory,
    /// Initial snapshot (frozen at initialization)
    InitialSnapshot,
    /// WASM binary code region
    CodeRegion,
}

/// Whether base address has been found
static WASM_BASE_FOUND: OnceLock<RwLock<bool>> = OnceLock::new();

/// WASM code region (binary) storage
static WASM_CODE_REGION: OnceLock<RwLock<Option<Vec<u8>>>> = OnceLock::new();

/// WASM code size received from browser
static WASM_CODE_SIZE: AtomicUsize = AtomicUsize::new(0);

/// Command sent to the WASM WebSocket client (browser)
#[derive(Serialize, Debug, Clone)]
struct WasmCommand {
    id: u64,
    command: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    address: Option<usize>,
    #[serde(skip_serializing_if = "Option::is_none")]
    size: Option<usize>,
    #[serde(skip_serializing_if = "Option::is_none")]
    bytes: Option<String>,
}

/// Response from WASM WebSocket client (browser)
#[derive(Deserialize, Debug)]
struct WasmResponse {
    id: Option<u64>,
    message: Option<serde_json::Value>,
    // Error field for failed operations
    error: Option<String>,
    // For init_signature message
    command: Option<String>,
    signature: Option<String>,
    heap_size: Option<usize>,
    // Cetus-style: symbols from instrumentation
    symbols: Option<serde_json::Value>,
    // Cetus-style: module info
    module_name: Option<String>,
    instrumented: Option<bool>,
    watchpoint_count: Option<usize>,
    // Cetus-style: code region info
    code_size: Option<usize>,
    has_binary: Option<bool>,
}

/// Response data types
#[derive(Debug)]
pub enum WasmResponseData {
    HeapSize(usize),
    Memory(Vec<u8>),
    WriteResult(bool),
    Error(String),
}

/// Pending request waiting for response
struct PendingRequest {
    response_tx: oneshot::Sender<WasmResponseData>,
}

/// WASM Bridge WebSocket Server
pub struct WasmBridge {
    /// Channel to send commands to connected browser client
    command_tx: mpsc::Sender<WasmCommand>,
    /// Pending requests waiting for responses
    pending_requests: Arc<RwLock<HashMap<u64, PendingRequest>>>,
    /// Whether a browser client is connected
    connected: Arc<RwLock<bool>>,
}

impl WasmBridge {
    /// Create a new WASM bridge and start the WebSocket server
    pub async fn new(port: u16) -> Result<Arc<Self>, String> {
        let addr = format!("0.0.0.0:{}", port);
        let listener = TcpListener::bind(&addr)
            .await
            .map_err(|e| format!("Failed to bind WebSocket server: {}", e))?;
        
        log::info!("WASM Bridge WebSocket server listening on {}", addr);
        
        let (command_tx, command_rx) = mpsc::channel::<WasmCommand>(100);
        let pending_requests: Arc<RwLock<HashMap<u64, PendingRequest>>> = 
            Arc::new(RwLock::new(HashMap::new()));
        let connected = Arc::new(RwLock::new(false));
        
        let bridge = Arc::new(Self {
            command_tx,
            pending_requests: pending_requests.clone(),
            connected: connected.clone(),
        });
        
        // Spawn the WebSocket server task
        let pending_clone = pending_requests.clone();
        let connected_clone = connected.clone();
        tokio::spawn(async move {
            Self::run_server(listener, command_rx, pending_clone, connected_clone).await;
        });
        
        Ok(bridge)
    }

    /// Run the WebSocket server
    async fn run_server(
        listener: TcpListener,
        mut command_rx: mpsc::Receiver<WasmCommand>,
        pending_requests: Arc<RwLock<HashMap<u64, PendingRequest>>>,
        connected: Arc<RwLock<bool>>,
    ) {
        // We only handle one browser connection at a time
        loop {
            match listener.accept().await {
                Ok((stream, addr)) => {
                    log::info!("WASM Bridge: Browser connected from {}", addr);
                    *connected.write().await = true;
                    
                    // Handle the connection
                    Self::handle_connection(
                        stream, 
                        &mut command_rx, 
                        pending_requests.clone(),
                    ).await;
                    
                    *connected.write().await = false;
                    log::info!("WASM Bridge: Browser disconnected");
                }
                Err(e) => {
                    log::error!("WASM Bridge: Failed to accept connection: {}", e);
                }
            }
        }
    }
    
    /// Handle a single WebSocket connection from a browser
    async fn handle_connection(
        stream: TcpStream,
        command_rx: &mut mpsc::Receiver<WasmCommand>,
        pending_requests: Arc<RwLock<HashMap<u64, PendingRequest>>>,
    ) {
        let ws_stream = match accept_async(stream).await {
            Ok(ws) => ws,
            Err(e) => {
                log::error!("WASM Bridge: WebSocket handshake failed: {}", e);
                return;
            }
        };
        
        let (mut write, mut read) = ws_stream.split();
        
        loop {
            tokio::select! {
                // Handle incoming messages from browser
                msg = read.next() => {
                    match msg {
                        Some(Ok(Message::Text(text))) => {
                            // Try to parse as JSON
                            if let Ok(response) = serde_json::from_str::<WasmResponse>(&text) {
                                // Check if this is an init_signature message
                                if let Some(cmd) = &response.command {
                                    if cmd == "init_signature" {
                                        if let Some(sig_hex) = &response.signature {
                                            if let Ok(sig_bytes) = hex::decode(sig_hex) {
                                                set_wasm_signature(sig_bytes);
                                                if let Some(heap_size) = response.heap_size {
                                                    WASM_HEAP_SIZE.store(heap_size, Ordering::SeqCst);
                                                }
                                            }
                                        }
                                        
                                        // Cetus-style: Process symbols from instrumentation
                                        if let Some(symbols) = &response.symbols {
                                            if let Err(e) = add_symbols_from_json(symbols) {
                                                log::warn!("WASM Bridge: Failed to parse symbols: {}", e);
                                            }
                                        }
                                        
                                        // Cetus-style: Store code size
                                        if let Some(code_size) = response.code_size {
                                            WASM_CODE_SIZE.store(code_size, Ordering::SeqCst);
                                        }
                                        
                                        // Cetus-style: Set module info
                                        let heap_size = response.heap_size.unwrap_or(0);
                                        let code_size = response.code_size.unwrap_or(0);
                                        let module_info = WasmModuleInfo {
                                            name: response.module_name.clone().unwrap_or_else(|| "wasm".to_string()),
                                            base: 0,
                                            size: heap_size,
                                            code_size,
                                            instrumented: response.instrumented.unwrap_or(true),
                                            watchpoint_count: response.watchpoint_count.unwrap_or(0),
                                            has_binary: response.has_binary.unwrap_or(code_size > 0),
                                            metadata: HashMap::new(),
                                        };
                                        set_wasm_module_info(module_info);
                                        
                                        continue;
                                    }
                                }
                                
                                // Regular response with id
                                if let Some(id) = response.id {
                                    let mut pending = pending_requests.write().await;
                                    if let Some(req) = pending.remove(&id) {
                                        // Check for error field first
                                        if let Some(ref error) = response.error {
                                            let _ = req.response_tx.send(WasmResponseData::Error(error.clone()));
                                        } else {
                                            let data = match &response.message {
                                                Some(serde_json::Value::Number(n)) => {
                                                    WasmResponseData::HeapSize(n.as_u64().unwrap_or(0) as usize)
                                                }
                                                Some(serde_json::Value::Bool(b)) => {
                                                    if *b {
                                                        WasmResponseData::WriteResult(true)
                                                    } else {
                                                        WasmResponseData::Error("Operation failed".to_string())
                                                    }
                                                }
                                                _ => WasmResponseData::Error("Unexpected response format".to_string()),
                                            };
                                            let _ = req.response_tx.send(data);
                                        }
                                    }
                                }
                            }
                        }
                        Some(Ok(Message::Binary(data))) => {
                            // Binary memory read response - find the oldest pending read request
                            let mut pending = pending_requests.write().await;
                            // Get the smallest ID (oldest request)
                            if let Some(&id) = pending.keys().min() {
                                if let Some(req) = pending.remove(&id) {
                                    let _ = req.response_tx.send(WasmResponseData::Memory(data));
                                }
                            }
                        }
                        Some(Ok(Message::Close(_))) | None => {
                            return;
                        }
                        Some(Err(e)) => {
                            log::error!("WASM Bridge: WebSocket error: {}", e);
                            return;
                        }
                        _ => {}
                    }
                }
                
                // Handle outgoing commands to browser
                cmd = command_rx.recv() => {
                    match cmd {
                        Some(cmd) => {
                            let json_cmd = serde_json::to_string(&cmd).unwrap();
                            if let Err(e) = write.send(Message::Text(json_cmd)).await {
                                log::error!("WASM Bridge: Failed to send command: {}", e);
                                return;
                            }
                        }
                        None => {
                            return;
                        }
                    }
                }
            }
        }
    }

    /// Send a command and wait for response
    async fn send_command(&self, cmd: WasmCommand) -> Result<WasmResponseData, String> {
        // Check if browser is connected
        if !*self.connected.read().await {
            return Err("No browser connected".to_string());
        }
        
        let id = cmd.id;
        let (response_tx, response_rx) = oneshot::channel();
        
        // Register pending request
        {
            let mut pending = self.pending_requests.write().await;
            pending.insert(id, PendingRequest { response_tx });
        }
        
        // Send command
        self.command_tx
            .send(cmd)
            .await
            .map_err(|e| format!("Failed to send command: {}", e))?;
        
        // Wait for response with timeout
        match tokio::time::timeout(tokio::time::Duration::from_secs(10), response_rx).await {
            Ok(Ok(data)) => Ok(data),
            Ok(Err(_)) => {
                // Remove pending request on error
                self.pending_requests.write().await.remove(&id);
                Err("Response channel closed".to_string())
            }
            Err(_) => {
                // Remove pending request on timeout
                self.pending_requests.write().await.remove(&id);
                Err("Timeout waiting for response".to_string())
            }
        }
    }

    /// Get the heap size from the WASM instance
    pub async fn get_heap_size(&self) -> Result<usize, String> {
        let cmd = WasmCommand {
            id: REQUEST_ID.fetch_add(1, Ordering::SeqCst),
            command: "get_heap_size".to_string(),
            address: None,
            size: None,
            bytes: None,
        };
        
        match self.send_command(cmd).await? {
            WasmResponseData::HeapSize(size) => Ok(size),
            WasmResponseData::Error(e) => Err(e),
            _ => Err("Unexpected response type".to_string()),
        }
    }

    /// Read memory from the WASM instance
    pub async fn read_memory(&self, address: usize, size: usize) -> Result<Vec<u8>, String> {
        let cmd = WasmCommand {
            id: REQUEST_ID.fetch_add(1, Ordering::SeqCst),
            command: "read_memory".to_string(),
            address: Some(address),
            size: Some(size),
            bytes: None,
        };
        
        match self.send_command(cmd).await? {
            WasmResponseData::Memory(data) => Ok(data),
            WasmResponseData::Error(e) => Err(e),
            _ => Err("Unexpected response type".to_string()),
        }
    }

    /// Write memory to the WASM instance
    pub async fn write_memory(&self, address: usize, data: &[u8]) -> Result<bool, String> {
        let hex_bytes = hex::encode(data);
        let cmd = WasmCommand {
            id: REQUEST_ID.fetch_add(1, Ordering::SeqCst),
            command: "write_memory".to_string(),
            address: Some(address),
            size: None,
            bytes: Some(hex_bytes),
        };
        
        match self.send_command(cmd).await? {
            WasmResponseData::WriteResult(success) => Ok(success),
            WasmResponseData::Error(e) => Err(e),
            _ => Err("Unexpected response type".to_string()),
        }
    }

    /// Read code (WASM binary) from the browser
    /// Offset is relative to the start of the WASM binary
    pub async fn read_code(&self, offset: usize, size: usize) -> Result<Vec<u8>, String> {
        let cmd = WasmCommand {
            id: REQUEST_ID.fetch_add(1, Ordering::SeqCst),
            command: "read_code".to_string(),
            address: Some(offset),
            size: Some(size),
            bytes: None,
        };
        
        match self.send_command(cmd).await? {
            WasmResponseData::Memory(data) => Ok(data),
            WasmResponseData::Error(e) => Err(e),
            _ => Err("Unexpected response type".to_string()),
        }
    }

    /// Check if a browser client is connected
    pub async fn is_connected(&self) -> bool {
        *self.connected.read().await
    }
}

/// Check if WASM mode is enabled
pub fn is_wasm_mode() -> bool {
    std::env::var("DBGSRV_RUNNING_MODE")
        .map(|v| v == "wasm")
        .unwrap_or(false)
}

/// Get the WASM WebSocket port from environment
pub fn get_wasm_ws_port() -> u16 {
    std::env::var("DBGSRV_WASM_WS_PORT")
        .ok()
        .and_then(|v| v.parse().ok())
        .unwrap_or(8765)
}

/// Initialize the global WASM bridge (call this at startup if in WASM mode)
pub async fn init_wasm_bridge() -> Result<(), String> {
    if !is_wasm_mode() {
        return Ok(());
    }
    
    let port = get_wasm_ws_port();
    let bridge = WasmBridge::new(port).await?;
    
    WASM_BRIDGE
        .set(bridge)
        .map_err(|_| "WASM bridge already initialized".to_string())?;
    
    log::info!("WASM bridge initialized on port {}", port);
    Ok(())
}

/// Get the global WASM bridge instance
pub fn get_wasm_bridge() -> Option<Arc<WasmBridge>> {
    WASM_BRIDGE.get().cloned()
}

/// Async memory read for WASM - handles all region types (heap, code, snapshot)
pub async fn read_wasm_memory_async(address: usize, size: usize) -> Result<Vec<u8>, String> {
    if address >= SNAPSHOT_REGION_BASE {
        // Reading from snapshot region (>= 0x80000000)
        let snapshot_offset = address - SNAPSHOT_REGION_BASE;
        read_initial_snapshot(snapshot_offset, size)
    } else if address >= CODE_REGION_BASE {
        // Reading from code region (0x40000000 - 0x80000000)
        let code_offset = address - CODE_REGION_BASE;
        if let Some(bridge) = get_wasm_bridge() {
            bridge.read_code(code_offset, size).await
        } else {
            Err("WASM bridge not initialized".to_string())
        }
    } else {
        // Reading from live heap (0x0 - 0x40000000)
        if let Some(bridge) = get_wasm_bridge() {
            bridge.read_memory(address, size).await
        } else {
            Err("WASM bridge not initialized".to_string())
        }
    }
}

/// Async wrapper for writing WASM memory
pub async fn write_wasm_memory_async(address: usize, data: &[u8]) -> Result<bool, String> {
    if let Some(bridge) = get_wasm_bridge() {
        bridge.write_memory(address, data).await
    } else {
        Err("WASM bridge not initialized".to_string())
    }
}

/// Async wrapper for getting WASM heap size
pub async fn get_wasm_heap_size_async() -> Result<usize, String> {
    if let Some(bridge) = get_wasm_bridge() {
        bridge.get_heap_size().await
    } else {
        Err("WASM bridge not initialized".to_string())
    }
}

/// Synchronous wrapper for reading WASM memory (blocking)
/// Uses current tokio runtime handle - works from async context or main thread
pub fn read_wasm_memory_sync(address: usize, size: usize) -> Result<Vec<u8>, String> {
    if let Some(bridge) = get_wasm_bridge() {
        // Use tokio's Handle to run async code from sync context
        let handle = tokio::runtime::Handle::try_current()
            .map_err(|_| "No tokio runtime available".to_string())?;
        
        // Use spawn_blocking to avoid blocking the async runtime
        std::thread::scope(|s| {
            s.spawn(|| {
                handle.block_on(async {
                    bridge.read_memory(address, size).await
                })
            }).join().unwrap()
        })
    } else {
        Err("WASM bridge not initialized".to_string())
    }
}

/// Synchronous wrapper for reading WASM memory with explicit handle
/// Use this version when calling from rayon/thread pool where tokio runtime is not available
pub fn read_wasm_memory_sync_with_handle(
    address: usize, 
    size: usize, 
    handle: &tokio::runtime::Handle
) -> Result<Vec<u8>, String> {
    if let Some(bridge) = get_wasm_bridge() {
        std::thread::scope(|s| {
            s.spawn(|| {
                handle.block_on(async {
                    bridge.read_memory(address, size).await
                })
            }).join().unwrap()
        })
    } else {
        Err("WASM bridge not initialized".to_string())
    }
}

/// Synchronous wrapper for reading WASM code (binary) region (blocking)
pub fn read_wasm_code_sync(offset: usize, size: usize) -> Result<Vec<u8>, String> {
    if let Some(bridge) = get_wasm_bridge() {
        let handle = tokio::runtime::Handle::try_current()
            .map_err(|_| "No tokio runtime available".to_string())?;
        
        std::thread::scope(|s| {
            s.spawn(|| {
                handle.block_on(async {
                    bridge.read_code(offset, size).await
                })
            }).join().unwrap()
        })
    } else {
        Err("WASM bridge not initialized".to_string())
    }
}

/// Synchronous wrapper for writing WASM memory (blocking)
pub fn write_wasm_memory_sync(address: usize, data: &[u8]) -> Result<bool, String> {
    if let Some(bridge) = get_wasm_bridge() {
        let handle = tokio::runtime::Handle::try_current()
            .map_err(|_| "No tokio runtime available".to_string())?;
        
        let data = data.to_vec();
        std::thread::scope(|s| {
            s.spawn(|| {
                handle.block_on(async {
                    bridge.write_memory(address, &data).await
                })
            }).join().unwrap()
        })
    } else {
        Err("WASM bridge not initialized".to_string())
    }
}

/// Get WASM heap size synchronously
pub fn get_wasm_heap_size_sync() -> Result<usize, String> {
    if let Some(bridge) = get_wasm_bridge() {
        let handle = tokio::runtime::Handle::try_current()
            .map_err(|_| "No tokio runtime available".to_string())?;
        
        std::thread::scope(|s| {
            s.spawn(|| {
                handle.block_on(async {
                    bridge.get_heap_size().await
                })
            }).join().unwrap()
        })
    } else {
        Err("WASM bridge not initialized".to_string())
    }
}

// ============================================================================
// Signature and Base Address Management
// ============================================================================

fn get_signature_lock() -> &'static RwLock<Option<Vec<u8>>> {
    WASM_SIGNATURE.get_or_init(|| RwLock::new(None))
}

fn get_base_found_lock() -> &'static RwLock<bool> {
    WASM_BASE_FOUND.get_or_init(|| RwLock::new(false))
}

/// Store the WASM signature received from browser
pub fn set_wasm_signature(signature: Vec<u8>) {
    let lock = get_signature_lock();
    if let Ok(mut guard) = lock.try_write() {
        *guard = Some(signature);
    }
}

/// Get the stored WASM signature
pub fn get_wasm_signature() -> Option<Vec<u8>> {
    let lock = get_signature_lock();
    if let Ok(guard) = lock.try_read() {
        guard.clone()
    } else {
        None
    }
}

/// Check if WASM signature is available
pub fn has_wasm_signature() -> bool {
    get_wasm_signature().is_some()
}

/// Get the cached WASM heap size
pub fn get_cached_wasm_heap_size() -> usize {
    WASM_HEAP_SIZE.load(Ordering::SeqCst)
}

/// Set the WASM base address (where signature was found in native memory)
pub fn set_wasm_base_address(address: usize) {
    WASM_BASE_ADDRESS.store(address, Ordering::SeqCst);
    if let Ok(mut guard) = get_base_found_lock().try_write() {
        *guard = true;
    }
}

/// Get the WASM base address
pub fn get_wasm_base_address() -> usize {
    WASM_BASE_ADDRESS.load(Ordering::SeqCst)
}

/// Check if WASM base address has been found
pub fn is_wasm_base_found() -> bool {
    if let Ok(guard) = get_base_found_lock().try_read() {
        *guard
    } else {
        false
    }
}

/// Clear the WASM base address (for reattaching)
pub fn clear_wasm_base_address() {
    WASM_BASE_ADDRESS.store(0, Ordering::SeqCst);
    if let Ok(mut guard) = get_base_found_lock().try_write() {
        *guard = false;
    }
}

/// Convert a WASM virtual address to native process address
/// In WASM mode, address 0 in WASM corresponds to base_address in native memory
pub fn wasm_to_native_address(wasm_address: usize) -> usize {
    if is_wasm_mode() && is_wasm_base_found() {
        get_wasm_base_address() + wasm_address
    } else {
        wasm_address
    }
}

/// Convert a native process address to WASM virtual address
pub fn native_to_wasm_address(native_address: usize) -> usize {
    if is_wasm_mode() && is_wasm_base_found() {
        let base = get_wasm_base_address();
        if native_address >= base {
            native_address - base
        } else {
            native_address
        }
    } else {
        native_address
    }
}

// ============================================================================
// Cetus-style Initial Snapshot Management
// ============================================================================

fn get_snapshot_lock() -> &'static RwLock<Option<WasmMemorySnapshot>> {
    WASM_INITIAL_SNAPSHOT.get_or_init(|| RwLock::new(None))
}

fn get_symbols_lock() -> &'static RwLock<Vec<WasmSymbol>> {
    WASM_SYMBOLS.get_or_init(|| RwLock::new(Vec::new()))
}

fn get_module_info_lock() -> &'static RwLock<Option<WasmModuleInfo>> {
    WASM_MODULE_INFO.get_or_init(|| RwLock::new(None))
}

/// Take a snapshot of the current WASM memory and store it as the initial state
/// This is called at WASM instance initialization (Cetus-style)
pub async fn take_initial_snapshot(label: Option<String>) -> Result<(), String> {
    let bridge = get_wasm_bridge()
        .ok_or_else(|| "WASM bridge not initialized".to_string())?;
    
    let heap_size = bridge.get_heap_size().await?;
    
    if heap_size == 0 {
        return Err("Heap size is 0, cannot take snapshot".to_string());
    }
    
    let data = bridge.read_memory(0, heap_size).await?;
    
    let snapshot = WasmMemorySnapshot {
        data,
        size: heap_size,
        timestamp: std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .map(|d| d.as_secs())
            .unwrap_or(0),
        label: label.unwrap_or_else(|| "initial".to_string()),
    };
    
    if let Ok(mut guard) = get_snapshot_lock().try_write() {
        *guard = Some(snapshot);
        Ok(())
    } else {
        Err("Failed to acquire snapshot lock".to_string())
    }
}

/// Take a snapshot synchronously (blocking)
pub fn take_initial_snapshot_sync(label: Option<String>) -> Result<(), String> {
    let handle = tokio::runtime::Handle::try_current()
        .map_err(|_| "No tokio runtime available".to_string())?;
    
    std::thread::scope(|s| {
        s.spawn(|| {
            handle.block_on(async {
                take_initial_snapshot(label).await
            })
        }).join().unwrap()
    })
}

/// Check if an initial snapshot exists
pub fn has_initial_snapshot() -> bool {
    if let Ok(guard) = get_snapshot_lock().try_read() {
        guard.is_some()
    } else {
        false
    }
}

/// Get the initial snapshot size
pub fn get_initial_snapshot_size() -> Option<usize> {
    if let Ok(guard) = get_snapshot_lock().try_read() {
        guard.as_ref().map(|s| s.size)
    } else {
        None
    }
}

/// Read from the initial snapshot (for comparison with current state)
pub fn read_initial_snapshot(address: usize, size: usize) -> Result<Vec<u8>, String> {
    let guard = get_snapshot_lock()
        .try_read()
        .map_err(|_| "Failed to acquire snapshot lock".to_string())?;
    
    let snapshot = guard.as_ref()
        .ok_or_else(|| "No initial snapshot available".to_string())?;
    
    if address + size > snapshot.size {
        return Err(format!(
            "Read out of bounds: address={}, size={}, snapshot_size={}",
            address, size, snapshot.size
        ));
    }
    
    Ok(snapshot.data[address..address + size].to_vec())
}

/// Clear the initial snapshot
pub fn clear_initial_snapshot() {
    if let Ok(mut guard) = get_snapshot_lock().try_write() {
        *guard = None;
    }
}

/// Get snapshot metadata
pub fn get_snapshot_info() -> Option<(usize, u64, String)> {
    if let Ok(guard) = get_snapshot_lock().try_read() {
        guard.as_ref().map(|s| (s.size, s.timestamp, s.label.clone()))
    } else {
        None
    }
}

// ============================================================================
// Cetus-style Symbol Management
// ============================================================================

/// Add a symbol from WASM instrumentation
pub fn add_wasm_symbol(symbol: WasmSymbol) {
    if let Ok(mut guard) = get_symbols_lock().try_write() {
        // Avoid duplicates
        if !guard.iter().any(|s| s.index == symbol.index && s.name == symbol.name) {
            guard.push(symbol);
        }
    }
}

/// Add symbols received from browser (JSON format from Cetus-style instrumentation)
/// Supports both array format (from Chrome extension) and object format (from legacy)
pub fn add_symbols_from_json(symbols_json: &serde_json::Value) -> Result<usize, String> {
    let mut count = 0;
    
    // Try array format first (Chrome extension style)
    if let Some(symbols_array) = symbols_json.as_array() {
        for (idx, symbol_value) in symbols_array.iter().enumerate() {
            if let Some(obj) = symbol_value.as_object() {
                let name = obj.get("name")
                    .and_then(|v| v.as_str())
                    .unwrap_or("unknown");
                let sym_type = obj.get("type")
                    .and_then(|v| v.as_str())
                    .unwrap_or("unknown");
                let address = obj.get("address")
                    .and_then(|v| v.as_u64())
                    .unwrap_or(idx as u64) as usize;
                let size = obj.get("size")
                    .and_then(|v| v.as_u64())
                    .unwrap_or(0) as usize;
                
                // Convert type string to enum (case-insensitive)
                let sym_type_lower = sym_type.to_lowercase();
                let symbol_type = match sym_type_lower.as_str() {
                    "function" => WasmSymbolType::Function,
                    "memory" => WasmSymbolType::Memory,
                    "table" => WasmSymbolType::Table,
                    "global" => WasmSymbolType::Global,
                    _ => WasmSymbolType::Export,
                };
                
                let symbol = WasmSymbol {
                    index: idx as u32,
                    name: name.to_string(),
                    symbol_type,
                    address,
                    size,
                };
                
                add_wasm_symbol(symbol);
                count += 1;
            }
        }
        
        return Ok(count);
    }
    
    // Try object format (legacy Cetus style: {"0": "funcName", "1": "funcName2", ...})
    if let Some(symbols_obj) = symbols_json.as_object() {
        for (index_str, name_value) in symbols_obj {
            let index: u32 = index_str.parse()
                .map_err(|_| format!("Invalid symbol index: {}", index_str))?;
            
            let name = name_value.as_str()
                .ok_or_else(|| format!("Symbol name must be a string: {}", name_value))?;
            
            let symbol = WasmSymbol {
                index,
                name: name.to_string(),
                symbol_type: if name.starts_with("_wp_") {
                    WasmSymbolType::Function
                } else {
                    WasmSymbolType::Export
                },
                address: index as usize,
                size: 0,
            };
            
            add_wasm_symbol(symbol);
            count += 1;
        }
        
        return Ok(count);
    }
    
    Err("Symbols must be a JSON array or object".to_string())
}

/// Get all WASM symbols
pub fn get_wasm_symbols() -> Vec<WasmSymbol> {
    if let Ok(guard) = get_symbols_lock().try_read() {
        guard.clone()
    } else {
        Vec::new()
    }
}

/// Get symbols as JSON for API response (compatible with native symbol format)
/// Only returns function symbols (belonging to wasm_code module)
/// Other symbol types (like globals) are not returned as they don't have meaningful addresses
pub fn get_wasm_symbols_json() -> Vec<serde_json::Value> {
    get_wasm_symbols()
        .into_iter()
        .filter(|s| s.symbol_type == WasmSymbolType::Function) // Only function symbols for wasm_code
        .map(|s| {
            // Function symbols get CODE_REGION_BASE offset
            let adjusted_address = CODE_REGION_BASE + s.address;
            serde_json::json!({
                "index": s.index,
                "name": s.name,
                "type": format!("{:?}", s.symbol_type),
                "address": format!("0x{:x}", adjusted_address),
                "size": s.size,
                // Add module_base for frontend compatibility (SymbolInfo interface)
                "module_base": format!("0x{:x}", CODE_REGION_BASE),
                "module_name": "wasm_code",
                "scope": "global",
            })
        })
        .collect()
}

/// Find symbol by name
pub fn find_symbol_by_name(name: &str) -> Option<WasmSymbol> {
    if let Ok(guard) = get_symbols_lock().try_read() {
        guard.iter().find(|s| s.name == name).cloned()
    } else {
        None
    }
}

/// Find symbol by function index
pub fn find_symbol_by_index(index: u32) -> Option<WasmSymbol> {
    if let Ok(guard) = get_symbols_lock().try_read() {
        guard.iter().find(|s| s.index == index).cloned()
    } else {
        None
    }
}

/// Clear all symbols
pub fn clear_wasm_symbols() {
    if let Ok(mut guard) = get_symbols_lock().try_write() {
        guard.clear();
    }
}

// ============================================================================
// Cetus-style Module Management
// ============================================================================

/// Set WASM module information
pub fn set_wasm_module_info(info: WasmModuleInfo) {
    if let Ok(mut guard) = get_module_info_lock().try_write() {
        *guard = Some(info);
    }
}

/// Get WASM module information
pub fn get_wasm_module_info() -> Option<WasmModuleInfo> {
    if let Ok(guard) = get_module_info_lock().try_read() {
        guard.clone()
    } else {
        None
    }
}

/// Get WASM modules as JSON for API response (compatible with enum_modules)
pub fn get_wasm_modules_json() -> Vec<serde_json::Value> {
    let heap_size = get_cached_wasm_heap_size();
    let code_size = WASM_CODE_SIZE.load(Ordering::SeqCst);
    
    let mut modules = vec![];
    
    // Add the main WASM module (heap region at base 0)
    if let Some(info) = get_wasm_module_info() {
        modules.push(serde_json::json!({
            "base": info.base,
            "size": info.size,
            "code_size": info.code_size,
            "is_64bit": false,
            "name": "wasm_heap",
            "modulename": "wasm_heap",
            "path": "wasm_heap",
            "instrumented": info.instrumented,
            "watchpoint_count": info.watchpoint_count,
            "has_binary": info.has_binary,
            "metadata": info.metadata,
        }));
    } else {
        // Default WASM module if no info set
        modules.push(serde_json::json!({
            "base": 0,
            "size": heap_size,
            "code_size": code_size,
            "is_64bit": false,
            "name": "wasm_heap",
            "modulename": "wasm_heap",
            "path": "wasm_heap",
            "instrumented": false,
            "watchpoint_count": 0,
            "has_binary": code_size > 0,
        }));
    }
    
    // Add the WASM code region as a separate module (for disassembly/symbol lookup)
    // This allows address-to-symbol resolution for CODE_REGION_BASE addresses
    if code_size > 0 {
        modules.push(serde_json::json!({
            "base": CODE_REGION_BASE,
            "size": code_size,
            "is_64bit": false,
            "name": "wasm_code",
            "modulename": "wasm_code",
            "path": "wasm_code",
            "instrumented": false,
            "watchpoint_count": 0,
            "has_binary": true,
        }));
    }
    
    modules
}

/// Clear module info
pub fn clear_wasm_module_info() {
    if let Ok(mut guard) = get_module_info_lock().try_write() {
        *guard = None;
    }
}

// ============================================================================
// Cetus-style Region Enumeration (returns multiple regions)
// ============================================================================

/// Virtual base address for the code region
pub const CODE_REGION_BASE: usize = 0x40000000; // 1GB offset for code region

/// Enumerate WASM memory regions
/// Returns multiple regions:
/// 1. Live linear memory (heap) - current state
/// 2. WASM code region (binary) - if captured
/// 3. Initial snapshot (if available) - frozen initial state
pub fn enum_wasm_regions() -> Vec<WasmMemoryRegion> {
    let heap_size = get_cached_wasm_heap_size();
    let code_size = WASM_CODE_SIZE.load(Ordering::SeqCst);
    let mut regions = vec![];
    
    // Region 1: Live linear memory
    regions.push(WasmMemoryRegion {
        name: "wasm_heap".to_string(),
        start: 0,
        end: heap_size,
        protection: "rw-".to_string(),
        region_type: WasmRegionType::LinearMemory,
    });
    
    // Region 2: WASM code region (if binary was captured)
    if code_size > 0 {
        regions.push(WasmMemoryRegion {
            name: "wasm_code".to_string(),
            start: CODE_REGION_BASE,
            end: CODE_REGION_BASE + code_size,
            protection: "r-x".to_string(), // Read + execute (code)
            region_type: WasmRegionType::CodeRegion,
        });
    }
    
    // Region 3: Initial snapshot (if available)
    if let Some(snapshot_size) = get_initial_snapshot_size() {
        // Snapshot is stored at a virtual offset (e.g., after heap)
        // This allows addressing both regions distinctly
        let snapshot_base = SNAPSHOT_REGION_BASE;
        regions.push(WasmMemoryRegion {
            name: "wasm_initial_snapshot".to_string(),
            start: snapshot_base,
            end: snapshot_base + snapshot_size,
            protection: "r--".to_string(), // Read-only snapshot
            region_type: WasmRegionType::InitialSnapshot,
        });
    }
    
    regions
}

/// Get regions as JSON for API response
pub fn get_wasm_regions_json() -> Vec<serde_json::Value> {
    enum_wasm_regions()
        .into_iter()
        .map(|r| serde_json::json!({
            "start_address": format!("{:x}", r.start),
            "end_address": format!("{:x}", r.end),
            "protection": r.protection,
            "file_path": r.name,
            "region_type": format!("{:?}", r.region_type),
        }))
        .collect()
}

/// Virtual base address for the initial snapshot region
pub const SNAPSHOT_REGION_BASE: usize = 0x80000000;

/// Read memory from either live heap, code region, or snapshot based on address
pub fn read_wasm_virtual_memory(address: usize, size: usize) -> Result<Vec<u8>, String> {
    if address >= SNAPSHOT_REGION_BASE {
        // Reading from snapshot region (>= 0x80000000)
        let snapshot_offset = address - SNAPSHOT_REGION_BASE;
        read_initial_snapshot(snapshot_offset, size)
    } else if address >= CODE_REGION_BASE {
        // Reading from code region (0x40000000 - 0x80000000)
        let code_offset = address - CODE_REGION_BASE;
        read_wasm_code_sync(code_offset, size)
    } else {
        // Reading from live heap (0x0 - 0x40000000)
        read_wasm_memory_sync(address, size)
    }
}

/// Check if an address is in the snapshot region
pub fn is_snapshot_address(address: usize) -> bool {
    address >= SNAPSHOT_REGION_BASE
}

/// Check if an address is in the code region
pub fn is_code_address(address: usize) -> bool {
    address >= CODE_REGION_BASE && address < SNAPSHOT_REGION_BASE
}

/// Convert snapshot address to linear memory address
pub fn snapshot_to_linear_address(address: usize) -> usize {
    if address >= SNAPSHOT_REGION_BASE {
        address - SNAPSHOT_REGION_BASE
    } else {
        address
    }
}

// ============================================================================
// Cleanup / Reset Functions
// ============================================================================

/// Clear all Cetus-style state (snapshot, symbols, module info)
pub fn clear_all_wasm_state() {
    clear_initial_snapshot();
    clear_wasm_symbols();
    clear_wasm_module_info();
    clear_wasm_base_address();
}

// ============================================================================
// WASM Binary Dump for Ghidra Analysis
// ============================================================================

/// Dump the entire WASM binary for Ghidra/external analysis
/// Returns the complete WASM module binary (with magic number and all sections)
pub async fn dump_wasm_binary() -> Result<Vec<u8>, String> {
    let code_size = WASM_CODE_SIZE.load(Ordering::SeqCst);
    
    if code_size == 0 {
        return Err("No WASM binary captured (code_size is 0)".to_string());
    }
    
    // Read the entire code region from Chrome extension
    let bridge = get_wasm_bridge().ok_or("WASM bridge not initialized")?;
    let binary = bridge.read_code(0, code_size).await?;
    
    // Verify it's a valid WASM binary (magic number: \0asm)
    if binary.len() < 8 {
        return Err(format!("WASM binary too small: {} bytes", binary.len()));
    }
    
    if &binary[0..4] != b"\0asm" {
        log::warn!("WASM binary doesn't start with magic number, first 4 bytes: {:02x?}", &binary[0..4]);
    }
    
    Ok(binary)
}

/// Get WASM code size for dump
pub fn get_wasm_code_size() -> usize {
    WASM_CODE_SIZE.load(Ordering::SeqCst)
}

```